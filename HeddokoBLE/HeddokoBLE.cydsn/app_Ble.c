/* ========================================
 *
 * Copyright YOUR COMPANY, THE YEAR
 * All Rights Reserved
 * UNPUBLISHED, LICENSED SOFTWARE.
 *
 * CONFIDENTIAL AND PROPRIETARY INFORMATION
 * WHICH IS THE PROPERTY OF your company.
 *
 * ========================================
*/

#include "app_ble.h"

extern void sendUnsentRawData();

extern bool restartFastAdv;

/* MTU size to be used by Client and Server after MTU exchange */
uint16 mtuSize      = CYBLE_GATT_MTU;   

uint8 txDataClientConfigDesc[2] = {0, 0};   
CYBLE_GATT_HANDLE_VALUE_PAIR_T  attrValue = { 
                                                    {(uint8 *)txDataClientConfigDesc, 2, 2}, 
                                                    CYBLE_SERVER_UART_SERVER_UART_TX_DATA_CLIENT_CHARACTERISTIC_CONFIGURATION_DESC_HANDLE
                                                };

uint8 rawDataConfigDesc[2] = {0, 0};
CYBLE_GATT_HANDLE_VALUE_PAIR_T  rawDataConfigAttrValue = {
                                                            {(uint8 *)rawDataConfigDesc, 2, 2}, 
                                                            CYBLE_HEDDOKO_RAW_DATA_RAW_DATA_CLIENT_CHARACTERISTIC_CONFIGURATION_DESC_HANDLE
                                                        };

uint8 bpStatusConfigDesc[2] = {0, 0};
CYBLE_GATT_HANDLE_VALUE_PAIR_T  bpStatusConfigAttrValue = {
                                                            {(uint8 *)bpStatusConfigDesc, 2, 2}, 
                                                            CYBLE_HEDDOKO_BRAINPACK_STATUS_BPSTATUS_CLIENT_CHARACTERISTIC_CONFIGURATION_DESC_HANDLE
                                                        };

/*******************************************************************************
* Function Name: HandleBleProcessing
********************************************************************************
*
* Summary:
*   Handles the BLE state machine for intiating different procedures
*   during different states of BLESS.
*
* Parameters:
*   None.
*
* Return:
*   None.
*
*******************************************************************************/
void HandleBleProcessing(void)
{    
    
    switch (cyBle_state)
    {
        case CYBLE_STATE_ADVERTISING:
            break;
        
        case CYBLE_STATE_CONNECTED:
            
            /* read CCCD for TX characteristic for checking if notifications are enabled*/
            CyBle_GattsReadAttributeValue(&attrValue, &cyBle_connHandle, CYBLE_GATT_DB_LOCALLY_INITIATED);
            CyBle_GattsReadAttributeValue(&rawDataConfigAttrValue, &cyBle_connHandle, CYBLE_GATT_DB_LOCALLY_INITIATED);
            CyBle_GattsReadAttributeValue(&bpStatusConfigAttrValue, &cyBle_connHandle, CYBLE_GATT_DB_LOCALLY_INITIATED);
            
            /* if stack is free, handle UART traffic */
            if(CyBle_GattGetBusStatus() != CYBLE_STACK_STATE_BUSY)
            {
                sendUnsentData();
            }
            break;
                
        case CYBLE_STATE_DISCONNECTED:
        
            txDataClientConfigDesc[0] = NOTIFICATON_DISABLED;
            txDataClientConfigDesc[1] = NOTIFICATON_DISABLED;
            
            rawDataConfigDesc[0] = NOTIFICATON_DISABLED;
            rawDataConfigDesc[1] = NOTIFICATON_DISABLED;
            
            bpStatusConfigDesc[0] = NOTIFICATON_DISABLED;
            bpStatusConfigDesc[1] = NOTIFICATON_DISABLED;
            
            CyBle_GappStartAdvertisement(CYBLE_ADVERTISING_FAST);

            break;
       
        case CYBLE_STATE_INITIALIZING:
        case CYBLE_STATE_STOPPED:
        default:
            break;       
    }
}


/*******************************************************************************
* Function Name: AppCallBack
********************************************************************************
*
* Summary:
*   Call back function for BLE stack to handle BLESS events
*
* Parameters:
*   event       - the event generated by stack
*   eventParam  - the parameters related to the corresponding event
*
* Return:
*   None.
*
*******************************************************************************/
void AppCallBack(uint32 event, void *eventParam)
{   
    CYBLE_GATT_ERR_CODE_T           errorCode;
    CYBLE_GATTS_WRITE_REQ_PARAM_T   *writeReqParam;
    
    switch (event)
    {
        case CYBLE_EVT_STACK_ON:
            break;
            
        case CYBLE_EVT_GAP_DEVICE_DISCONNECTED:
            
            #ifdef PRINT_MESSAGE_LOG   
                UART_UartPutString("\n\r DISCONNECTED!!! \n\r ");
                while(0 != (UART_SpiUartGetTxBufferSize() + UART_GET_TX_FIFO_SR_VALID));
            #endif
            
            /* RESET Uart and flush all buffers */
            UART_Stop();
            UART_SpiUartClearTxBuffer();
            UART_SpiUartClearRxBuffer();
            UART_Start();
            break;
            
        case CYBLE_EVT_GATT_CONNECT_IND:
            
            #ifdef PRINT_MESSAGE_LOG   
                UART_UartPutString("\n\rConnection established");             
            #endif
            
            break;
        
        case CYBLE_EVT_GATTS_WRITE_CMD_REQ:
            
            writeReqParam = (CYBLE_GATTS_WRITE_REQ_PARAM_T *) eventParam;
            
            //Add conditions to limit the write to only desired values
            if (CYBLE_HEDDOKO_WIFI_SECURITY_TYPE_CHAR_HANDLE == writeReqParam->handleValPair.attrHandle)
            {
                if ((*writeReqParam->handleValPair.value.val >= 0) && (*writeReqParam->handleValPair.value.val <= 3))
                {
                    //Only write the Security type if the value is in valid range.
                    CyBle_GattsWriteAttributeValue(&(writeReqParam->handleValPair), \
                                                   0, &cyBle_connHandle, CYBLE_GATT_DB_PEER_INITIATED);
                
                    HandleUartRxTraffic((CYBLE_GATTS_WRITE_REQ_PARAM_T *) eventParam);
                }
            }
            
            else
            {
                CyBle_GattsWriteAttributeValue(&(writeReqParam->handleValPair), \
                                                0, &cyBle_connHandle, CYBLE_GATT_DB_PEER_INITIATED);
                
                HandleUartRxTraffic((CYBLE_GATTS_WRITE_REQ_PARAM_T *) eventParam);
            }
            
            break;
        
        case CYBLE_EVT_GATTS_XCNHG_MTU_REQ:
            //set the MTU size as the minimum of both the device.
            if(CYBLE_GATT_MTU > ((CYBLE_GATT_XCHG_MTU_PARAM_T *)eventParam)->mtu)
            {
                mtuSize = ((CYBLE_GATT_XCHG_MTU_PARAM_T *)eventParam)->mtu;
            }
            else
            {
                mtuSize = CYBLE_GATT_MTU;
            }
            
            break;
            
        case CYBLE_EVT_GATTS_WRITE_REQ:
            
            writeReqParam = (CYBLE_GATTS_WRITE_REQ_PARAM_T *) eventParam;
            
//            // notification status flags
//            if(CYBLE_SERVER_UART_SERVER_UART_TX_DATA_CLIENT_CHARACTERISTIC_CONFIGURATION_DESC_HANDLE == \
//                                                                    writeReqParam->handleValPair.attrHandle)
//            {
//                errorCode = CyBle_GattsWriteAttributeValue(&(writeReqParam->handleValPair), \
//                                                0, &cyBle_connHandle, CYBLE_GATT_DB_PEER_INITIATED);
//                
//                if (CYBLE_GATT_ERR_NONE  == errorCode)
//                {
//                    CyBle_GattsWriteRsp(cyBle_connHandle);
//                    #ifdef PRINT_MESSAGE_LOG   
//                        UART_UartPutString("\n\rNotifications enabled\n\r");
//                        UART_UartPutString("\n\rStart entering data:\n\r");
//                    #endif
//                }
//            }
//            
//            // enable notification flag for RAW data
//            if(CYBLE_HEDDOKO_RAW_DATA_RAW_DATA_CLIENT_CHARACTERISTIC_CONFIGURATION_DESC_HANDLE == \
//                                                                    writeReqParam->handleValPair.attrHandle)
//            {
//                errorCode = CyBle_GattsWriteAttributeValue(&(writeReqParam->handleValPair), \
//                                                0, &cyBle_connHandle, CYBLE_GATT_DB_PEER_INITIATED);
//                
//                if (CYBLE_GATT_ERR_NONE  == errorCode)
//                {
//                    CyBle_GattsWriteRsp(cyBle_connHandle);
//                    #ifdef PRINT_MESSAGE_LOG   
//                        UART_UartPutString("\n\rRaw data Notifications enabled\n\r");
//                        UART_UartPutString("\n\rStart entering data:\n\r");
//                    #endif
//                }
//            }
//            
//            // enable notification flag for Brain Pack Status
//            if(CYBLE_HEDDOKO_BRAINPACK_STATUS_BPSTATUS_CLIENT_CHARACTERISTIC_CONFIGURATION_DESC_HANDLE == \
//                                                                    writeReqParam->handleValPair.attrHandle)
//            {
//                errorCode = CyBle_GattsWriteAttributeValue(&(writeReqParam->handleValPair), \
//                                                0, &cyBle_connHandle, CYBLE_GATT_DB_PEER_INITIATED);
//                
//                if (CYBLE_GATT_ERR_NONE  == errorCode)
//                {
//                    CyBle_GattsWriteRsp(cyBle_connHandle);
//                    #ifdef PRINT_MESSAGE_LOG   
//                        UART_UartPutString("\n\rBrain Pack Status Notifications enabled\n\r");
//                        UART_UartPutString("\n\rStart entering data:\n\r");
//                    #endif
//                }
//            }
            //                errorCode = CyBle_GattsWriteAttributeValue(&(writeReqParam->handleValPair), \
//                                                0, &cyBle_connHandle, CYBLE_GATT_DB_PEER_INITIATED);
            //                
            errorCode = CyBle_GattsWriteAttributeValue(&(writeReqParam->handleValPair), \
                                        0, &cyBle_connHandle, CYBLE_GATT_DB_PEER_INITIATED);
            HandleUartRxTraffic((CYBLE_GATTS_WRITE_REQ_PARAM_T *) eventParam);
            if (CYBLE_GATT_ERR_NONE  == errorCode)
            {
                CyBle_GattsWriteRsp(cyBle_connHandle);
                #ifdef PRINT_MESSAGE_LOG   
                    UART_UartPutString("\n\rBrain Pack Status Notifications enabled\n\r");
                    UART_UartPutString("\n\rStart entering data:\n\r");
                #endif
            }
            break;
        
        case CYBLE_EVT_GATTC_READ_RSP:
            break;
        
        case CYBLE_EVT_GAPP_ADVERTISEMENT_START_STOP:
             if (restartFastAdv)
            {
                CyBle_GappStartAdvertisement(CYBLE_ADVERTISING_FAST);
                restartFastAdv = false;
            }
            break;
            
        default:
            break;
    }
}
CYBLE_API_RESULT_T CyBle_CustomSetCharacteristicValue(CYBLE_GATT_DB_ATTR_HANDLE_T handle, 
    uint8 attrSize, uint8 *attrValue)
{
    CYBLE_API_RESULT_T apiResult = CYBLE_ERROR_OK;
    CYBLE_GATT_HANDLE_VALUE_PAIR_T locHandleValuePair;


    /* Store data in database */
    locHandleValuePair.attrHandle = handle;
    locHandleValuePair.value.len = attrSize;
    locHandleValuePair.value.val = attrValue;
    if(CYBLE_GATT_ERR_NONE !=
        CyBle_GattsWriteAttributeValue(&locHandleValuePair, 0u, NULL, CYBLE_GATT_DB_LOCALLY_INITIATED))
    {
        apiResult = CYBLE_ERROR_INVALID_PARAMETER;
    }
    
    return (apiResult);
}

CYBLE_API_RESULT_T CyBle_CustomSendNotification(CYBLE_CONN_HANDLE_T connHandle,
    CYBLE_GATT_DB_ATTR_HANDLE_T handle, CYBLE_GATT_DB_ATTR_HANDLE_T cccdHandle,
    uint8 attrSize, uint8 *attrValue)
{
    CYBLE_API_RESULT_T apiResult;

    /* Store new data in database */
    apiResult = CyBle_CustomSetCharacteristicValue(handle, attrSize, attrValue);
    
    if(CYBLE_ERROR_OK == apiResult)  
    {
        /* Send Notification if it is enabled and connected */
        if(CYBLE_STATE_CONNECTED != CyBle_GetState())
        {
            apiResult = CYBLE_ERROR_INVALID_STATE;
        }
        else if((cccdHandle == CYBLE_GATT_INVALID_ATTR_HANDLE_VALUE)
            || (!CYBLE_IS_NOTIFICATION_ENABLED(cccdHandle)))
        {
            apiResult = CYBLE_ERROR_NTF_DISABLED;
        }
        else
        {
            CYBLE_GATTS_HANDLE_VALUE_NTF_T ntfReqParam;            
            /* Fill all fields of write request structure ... */
            ntfReqParam.attrHandle = handle;
            ntfReqParam.value.val = attrValue;
            ntfReqParam.value.len = attrSize;            
            /* Send notification to client using previously filled structure */
            apiResult = CyBle_GattsNotification(connHandle, &ntfReqParam);
        }
    }
    
    return (apiResult);
}
/* [] END OF FILE */
