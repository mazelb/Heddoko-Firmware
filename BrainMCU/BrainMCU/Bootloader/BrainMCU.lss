
BrainMCU.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000070f8  00400000  00400000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000008  004070f8  004070f8  0000f0f8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .relocate     00000aec  20000000  00407100  00010000  2**3
                  CONTENTS, ALLOC, LOAD, CODE
  3 .bss          0000195c  20000aec  00407bec  00010aec  2**2
                  ALLOC
  4 .stack        00003000  20002448  00409548  00010aec  2**0
                  ALLOC
  5 .ARM.attributes 0000002a  00000000  00000000  00010aec  2**0
                  CONTENTS, READONLY
  6 .comment      0000005b  00000000  00000000  00010b16  2**0
                  CONTENTS, READONLY
  7 .debug_info   00028ce3  00000000  00000000  00010b71  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000064de  00000000  00000000  00039854  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00015f12  00000000  00000000  0003fd32  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 00001718  00000000  00000000  00055c44  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00002970  00000000  00000000  0005735c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  0000fa48  00000000  00000000  00059ccc  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00023f55  00000000  00000000  00069714  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0005d9a1  00000000  00000000  0008d669  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00003c28  00000000  00000000  000eb00c  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00400000 <_sfixed>:
  400000:	20005448 	.word	0x20005448
  400004:	00405671 	.word	0x00405671
  400008:	0040566d 	.word	0x0040566d
  40000c:	0040587d 	.word	0x0040587d
  400010:	00405881 	.word	0x00405881
  400014:	00405885 	.word	0x00405885
  400018:	00405889 	.word	0x00405889
	...
  40002c:	00403e2d 	.word	0x00403e2d
  400030:	0040566d 	.word	0x0040566d
  400034:	00000000 	.word	0x00000000
  400038:	00403e8d 	.word	0x00403e8d
  40003c:	0040588d 	.word	0x0040588d
  400040:	0040566d 	.word	0x0040566d
  400044:	0040566d 	.word	0x0040566d
  400048:	0040566d 	.word	0x0040566d
  40004c:	0040566d 	.word	0x0040566d
  400050:	00404869 	.word	0x00404869
  400054:	0040566d 	.word	0x0040566d
  400058:	0040566d 	.word	0x0040566d
  40005c:	00000000 	.word	0x00000000
  400060:	00404f71 	.word	0x00404f71
  400064:	00404fb9 	.word	0x00404fb9
  400068:	00000000 	.word	0x00000000
  40006c:	00405519 	.word	0x00405519
  400070:	0040552d 	.word	0x0040552d
  400074:	00000000 	.word	0x00000000
  400078:	00405009 	.word	0x00405009
  40007c:	00405059 	.word	0x00405059
	...
  400088:	0040566d 	.word	0x0040566d
  40008c:	00400301 	.word	0x00400301
  400090:	00400311 	.word	0x00400311
  400094:	0040566d 	.word	0x0040566d
  400098:	0040566d 	.word	0x0040566d
  40009c:	0040566d 	.word	0x0040566d
  4000a0:	0040566d 	.word	0x0040566d
  4000a4:	0040566d 	.word	0x0040566d
	...
  4000b4:	0040566d 	.word	0x0040566d
  4000b8:	0040566d 	.word	0x0040566d
  4000bc:	0040566d 	.word	0x0040566d
  4000c0:	0040566d 	.word	0x0040566d
  4000c4:	0040566d 	.word	0x0040566d
  4000c8:	0040566d 	.word	0x0040566d

004000cc <__do_global_dtors_aux>:
  4000cc:	b510      	push	{r4, lr}
  4000ce:	4c05      	ldr	r4, [pc, #20]	; (4000e4 <__do_global_dtors_aux+0x18>)
  4000d0:	7823      	ldrb	r3, [r4, #0]
  4000d2:	b933      	cbnz	r3, 4000e2 <__do_global_dtors_aux+0x16>
  4000d4:	4b04      	ldr	r3, [pc, #16]	; (4000e8 <__do_global_dtors_aux+0x1c>)
  4000d6:	b113      	cbz	r3, 4000de <__do_global_dtors_aux+0x12>
  4000d8:	4804      	ldr	r0, [pc, #16]	; (4000ec <__do_global_dtors_aux+0x20>)
  4000da:	f3af 8000 	nop.w
  4000de:	2301      	movs	r3, #1
  4000e0:	7023      	strb	r3, [r4, #0]
  4000e2:	bd10      	pop	{r4, pc}
  4000e4:	20000aec 	.word	0x20000aec
  4000e8:	00000000 	.word	0x00000000
  4000ec:	00407100 	.word	0x00407100

004000f0 <frame_dummy>:
  4000f0:	b508      	push	{r3, lr}
  4000f2:	4b06      	ldr	r3, [pc, #24]	; (40010c <frame_dummy+0x1c>)
  4000f4:	b11b      	cbz	r3, 4000fe <frame_dummy+0xe>
  4000f6:	4806      	ldr	r0, [pc, #24]	; (400110 <frame_dummy+0x20>)
  4000f8:	4906      	ldr	r1, [pc, #24]	; (400114 <frame_dummy+0x24>)
  4000fa:	f3af 8000 	nop.w
  4000fe:	4806      	ldr	r0, [pc, #24]	; (400118 <frame_dummy+0x28>)
  400100:	6803      	ldr	r3, [r0, #0]
  400102:	b113      	cbz	r3, 40010a <frame_dummy+0x1a>
  400104:	4b05      	ldr	r3, [pc, #20]	; (40011c <frame_dummy+0x2c>)
  400106:	b103      	cbz	r3, 40010a <frame_dummy+0x1a>
  400108:	4798      	blx	r3
  40010a:	bd08      	pop	{r3, pc}
  40010c:	00000000 	.word	0x00000000
  400110:	00407100 	.word	0x00407100
  400114:	20000af0 	.word	0x20000af0
  400118:	00407100 	.word	0x00407100
  40011c:	00000000 	.word	0x00000000

00400120 <local_twi_handler>:
/*
 * For internal use only.
 * A common TWI interrupt handler that is called for all TWI peripherals.
 */
static void local_twi_handler(const portBASE_TYPE twi_index)
{
  400120:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	portBASE_TYPE higher_priority_task_woken = pdFALSE;
	uint32_t twi_status;
	Twi *twi_port;
	bool transfer_timeout = false;

	twi_port = all_twi_definitions[twi_index].peripheral_base_address;
  400124:	0107      	lsls	r7, r0, #4
  400126:	f8df 81d4 	ldr.w	r8, [pc, #468]	; 4002fc <local_twi_handler+0x1dc>

	twi_status = twi_get_interrupt_status(twi_port);
  40012a:	4b6b      	ldr	r3, [pc, #428]	; (4002d8 <local_twi_handler+0x1b8>)
	portBASE_TYPE higher_priority_task_woken = pdFALSE;
	uint32_t twi_status;
	Twi *twi_port;
	bool transfer_timeout = false;

	twi_port = all_twi_definitions[twi_index].peripheral_base_address;
  40012c:	f858 5007 	ldr.w	r5, [r8, r7]
/*
 * For internal use only.
 * A common TWI interrupt handler that is called for all TWI peripherals.
 */
static void local_twi_handler(const portBASE_TYPE twi_index)
{
  400130:	b083      	sub	sp, #12
  400132:	4606      	mov	r6, r0
	portBASE_TYPE higher_priority_task_woken = pdFALSE;
  400134:	2400      	movs	r4, #0
	Twi *twi_port;
	bool transfer_timeout = false;

	twi_port = all_twi_definitions[twi_index].peripheral_base_address;

	twi_status = twi_get_interrupt_status(twi_port);
  400136:	4628      	mov	r0, r5
 * For internal use only.
 * A common TWI interrupt handler that is called for all TWI peripherals.
 */
static void local_twi_handler(const portBASE_TYPE twi_index)
{
	portBASE_TYPE higher_priority_task_woken = pdFALSE;
  400138:	9401      	str	r4, [sp, #4]
	Twi *twi_port;
	bool transfer_timeout = false;

	twi_port = all_twi_definitions[twi_index].peripheral_base_address;

	twi_status = twi_get_interrupt_status(twi_port);
  40013a:	4798      	blx	r3
	twi_status &= twi_get_interrupt_mask(twi_port);
  40013c:	4b67      	ldr	r3, [pc, #412]	; (4002dc <local_twi_handler+0x1bc>)
	Twi *twi_port;
	bool transfer_timeout = false;

	twi_port = all_twi_definitions[twi_index].peripheral_base_address;

	twi_status = twi_get_interrupt_status(twi_port);
  40013e:	4682      	mov	sl, r0
	twi_status &= twi_get_interrupt_mask(twi_port);
  400140:	4628      	mov	r0, r5
  400142:	4798      	blx	r3
  400144:	ea00 0a0a 	and.w	sl, r0, sl

	/* Has the PDC completed a transmission? */
	if ((twi_status & TWI_SR_ENDTX) != 0UL) {
  400148:	f41a 5900 	ands.w	r9, sl, #8192	; 0x2000
	portBASE_TYPE higher_priority_task_woken = pdFALSE;
	uint32_t twi_status;
	Twi *twi_port;
	bool transfer_timeout = false;

	twi_port = all_twi_definitions[twi_index].peripheral_base_address;
  40014c:	eb08 0307 	add.w	r3, r8, r7

	twi_status = twi_get_interrupt_status(twi_port);
	twi_status &= twi_get_interrupt_mask(twi_port);

	/* Has the PDC completed a transmission? */
	if ((twi_status & TWI_SR_ENDTX) != 0UL) {
  400150:	d179      	bne.n	400246 <local_twi_handler+0x126>
			}
		}
	}

	/* Has the PDC completed a reception? */
	if ((twi_status & TWI_SR_ENDRX) != 0UL) {
  400152:	f41a 5f80 	tst.w	sl, #4096	; 0x1000
  400156:	d12c      	bne.n	4001b2 <local_twi_handler+0x92>
						&higher_priority_task_woken);
			}
		}
	}

	if (((twi_status & SR_ERROR_INTERRUPTS) != 0) || (transfer_timeout == true)) {
  400158:	f41a 7f50 	tst.w	sl, #832	; 0x340
  40015c:	d109      	bne.n	400172 <local_twi_handler+0x52>
  40015e:	f1b9 0f00 	cmp.w	r9, #0
  400162:	d106      	bne.n	400172 <local_twi_handler+0x52>
	has a priority equal to or higher than the currently running task (the task
	this ISR interrupted), then higher_priority_task_woken will have
	automatically been set to pdTRUE within the semaphore function.
	portEND_SWITCHING_ISR() will then ensure that this ISR returns directly to
	the higher priority unblocked task. */
	portEND_SWITCHING_ISR(higher_priority_task_woken);
  400164:	9b01      	ldr	r3, [sp, #4]
  400166:	b10b      	cbz	r3, 40016c <local_twi_handler+0x4c>
  400168:	4b5d      	ldr	r3, [pc, #372]	; (4002e0 <local_twi_handler+0x1c0>)
  40016a:	4798      	blx	r3
}
  40016c:	b003      	add	sp, #12
  40016e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		Stop the transmission, disable interrupts used by the peripheral, and
		ensure the peripheral access mutex is made available to tasks.  As this
		peripheral is half duplex, only the Tx peripheral access mutex exits.*/

		/* Stop the PDC */
		pdc_disable_transfer(all_twi_definitions[twi_index].pdc_base_address, PERIPH_PTCR_TXTDIS | PERIPH_PTCR_RXTDIS);
  400172:	4447      	add	r7, r8
  400174:	4b5b      	ldr	r3, [pc, #364]	; (4002e4 <local_twi_handler+0x1c4>)
  400176:	6878      	ldr	r0, [r7, #4]

		if (!(twi_status & TWI_SR_NACK)) {
			/* Do not send stop if NACK received. Handled by hardware */
			twi_port->TWI_CR = TWI_CR_STOP;
		}
		twi_disable_interrupt(twi_port, TWI_IDR_ENDTX);
  400178:	4c5b      	ldr	r4, [pc, #364]	; (4002e8 <local_twi_handler+0x1c8>)
		Stop the transmission, disable interrupts used by the peripheral, and
		ensure the peripheral access mutex is made available to tasks.  As this
		peripheral is half duplex, only the Tx peripheral access mutex exits.*/

		/* Stop the PDC */
		pdc_disable_transfer(all_twi_definitions[twi_index].pdc_base_address, PERIPH_PTCR_TXTDIS | PERIPH_PTCR_RXTDIS);
  40017a:	f240 2102 	movw	r1, #514	; 0x202
  40017e:	4798      	blx	r3

		if (!(twi_status & TWI_SR_NACK)) {
  400180:	f41a 7f80 	tst.w	sl, #256	; 0x100
			/* Do not send stop if NACK received. Handled by hardware */
			twi_port->TWI_CR = TWI_CR_STOP;
  400184:	bf04      	itt	eq
  400186:	2302      	moveq	r3, #2
  400188:	602b      	streq	r3, [r5, #0]
		}
		twi_disable_interrupt(twi_port, TWI_IDR_ENDTX);
  40018a:	4628      	mov	r0, r5
  40018c:	f44f 5100 	mov.w	r1, #8192	; 0x2000
  400190:	47a0      	blx	r4
		twi_disable_interrupt(twi_port, TWI_IDR_ENDRX);
  400192:	4628      	mov	r0, r5
  400194:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  400198:	47a0      	blx	r4

		if (tx_dma_control[twi_index].peripheral_access_mutex != NULL) {
  40019a:	4b54      	ldr	r3, [pc, #336]	; (4002ec <local_twi_handler+0x1cc>)
  40019c:	eb03 06c6 	add.w	r6, r3, r6, lsl #3
  4001a0:	6870      	ldr	r0, [r6, #4]
  4001a2:	2800      	cmp	r0, #0
  4001a4:	d0de      	beq.n	400164 <local_twi_handler+0x44>
			xSemaphoreGiveFromISR(
  4001a6:	2100      	movs	r1, #0
  4001a8:	460b      	mov	r3, r1
  4001aa:	aa01      	add	r2, sp, #4
  4001ac:	4c50      	ldr	r4, [pc, #320]	; (4002f0 <local_twi_handler+0x1d0>)
  4001ae:	47a0      	blx	r4
  4001b0:	e7d8      	b.n	400164 <local_twi_handler+0x44>
	if ((twi_status & TWI_SR_ENDRX) != 0UL) {
		uint32_t timeout_counter = 0;
		uint32_t status;
		/* Must handle the two last bytes */
		/* Disable PDC */
		pdc_disable_transfer(all_twi_definitions[twi_index].pdc_base_address, PERIPH_PTCR_RXTDIS);
  4001b2:	eb08 0307 	add.w	r3, r8, r7
  4001b6:	2102      	movs	r1, #2
  4001b8:	6858      	ldr	r0, [r3, #4]
  4001ba:	4b4a      	ldr	r3, [pc, #296]	; (4002e4 <local_twi_handler+0x1c4>)
  4001bc:	4798      	blx	r3

		twi_disable_interrupt(twi_port, TWI_IDR_ENDRX);
  4001be:	4628      	mov	r0, r5
  4001c0:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  4001c4:	4b48      	ldr	r3, [pc, #288]	; (4002e8 <local_twi_handler+0x1c8>)
  4001c6:	4798      	blx	r3
		}
	}

	/* Has the PDC completed a reception? */
	if ((twi_status & TWI_SR_ENDRX) != 0UL) {
		uint32_t timeout_counter = 0;
  4001c8:	2400      	movs	r4, #0
  4001ca:	e002      	b.n	4001d2 <local_twi_handler+0xb2>
			status = twi_port->TWI_SR;
			if (status & TWI_SR_RXRDY) {
				break;
			}
			/* Check timeout condition. */
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
  4001cc:	3401      	adds	r4, #1
  4001ce:	1c63      	adds	r3, r4, #1
  4001d0:	d002      	beq.n	4001d8 <local_twi_handler+0xb8>

		twi_disable_interrupt(twi_port, TWI_IDR_ENDRX);

		/* Wait for RX ready flag */
		while (1) {
			status = twi_port->TWI_SR;
  4001d2:	6a2b      	ldr	r3, [r5, #32]
			if (status & TWI_SR_RXRDY) {
  4001d4:	079a      	lsls	r2, r3, #30
  4001d6:	d5f9      	bpl.n	4001cc <local_twi_handler+0xac>
			}
		}
		/* Complete the transfer. */
		twi_port->TWI_CR = TWI_CR_STOP;
		/* Read second last data */
		twis[twi_index].buffer[(twis[twi_index].length)-2] = twi_port->TWI_RHR;
  4001d8:	4b46      	ldr	r3, [pc, #280]	; (4002f4 <local_twi_handler+0x1d4>)
  4001da:	00f2      	lsls	r2, r6, #3
  4001dc:	1899      	adds	r1, r3, r2
  4001de:	f853 0036 	ldr.w	r0, [r3, r6, lsl #3]
  4001e2:	6849      	ldr	r1, [r1, #4]
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
				break;
			}
		}
		/* Complete the transfer. */
		twi_port->TWI_CR = TWI_CR_STOP;
  4001e4:	2302      	movs	r3, #2
  4001e6:	602b      	str	r3, [r5, #0]
		/* Read second last data */
		twis[twi_index].buffer[(twis[twi_index].length)-2] = twi_port->TWI_RHR;
  4001e8:	4401      	add	r1, r0
  4001ea:	6b2b      	ldr	r3, [r5, #48]	; 0x30
  4001ec:	f801 3c02 	strb.w	r3, [r1, #-2]
  4001f0:	e002      	b.n	4001f8 <local_twi_handler+0xd8>
			status = twi_port->TWI_SR;
			if (status & TWI_SR_RXRDY) {
				break;
			}
			/* Check timeout condition. */
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
  4001f2:	3401      	adds	r4, #1
  4001f4:	1c63      	adds	r3, r4, #1
  4001f6:	d00f      	beq.n	400218 <local_twi_handler+0xf8>
		/* Read second last data */
		twis[twi_index].buffer[(twis[twi_index].length)-2] = twi_port->TWI_RHR;

		/* Wait for RX ready flag */
		while (1) {
			status = twi_port->TWI_SR;
  4001f8:	6a2b      	ldr	r3, [r5, #32]
			if (status & TWI_SR_RXRDY) {
  4001fa:	0798      	lsls	r0, r3, #30
  4001fc:	d5f9      	bpl.n	4001f2 <local_twi_handler+0xd2>
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
				break;
			}
		}

		if (!(timeout_counter >= TWI_TIMEOUT_COUNTER)) {
  4001fe:	1c60      	adds	r0, r4, #1
  400200:	d00a      	beq.n	400218 <local_twi_handler+0xf8>
			/* Read last data */
			twis[twi_index].buffer[(twis[twi_index].length)-1] = twi_port->TWI_RHR;
  400202:	6b2b      	ldr	r3, [r5, #48]	; 0x30
  400204:	f801 3c01 	strb.w	r3, [r1, #-1]
			timeout_counter = 0;
  400208:	2400      	movs	r4, #0
  40020a:	e002      	b.n	400212 <local_twi_handler+0xf2>
				status = twi_port->TWI_SR;
				if (status & TWI_SR_TXCOMP) {
					break;
				}
				/* Check timeout condition. */
				if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
  40020c:	3401      	adds	r4, #1
  40020e:	1c63      	adds	r3, r4, #1
  400210:	d05e      	beq.n	4002d0 <local_twi_handler+0x1b0>
			/* Read last data */
			twis[twi_index].buffer[(twis[twi_index].length)-1] = twi_port->TWI_RHR;
			timeout_counter = 0;
			/* Wait for TX complete flag before releasing semaphore */
			while (1) {
				status = twi_port->TWI_SR;
  400212:	6a2b      	ldr	r3, [r5, #32]
				if (status & TWI_SR_TXCOMP) {
  400214:	07d9      	lsls	r1, r3, #31
  400216:	d5f9      	bpl.n	40020c <local_twi_handler+0xec>
		}

		/* If the driver is supporting multi-threading, then return the access
		mutex.  NOTE: As the peripheral is half duplex there is only one
		access mutex, and the reception uses the tx access muted. */
		if (tx_dma_control[twi_index].peripheral_access_mutex != NULL) {
  400218:	4b34      	ldr	r3, [pc, #208]	; (4002ec <local_twi_handler+0x1cc>)
  40021a:	441a      	add	r2, r3
  40021c:	6850      	ldr	r0, [r2, #4]
  40021e:	b128      	cbz	r0, 40022c <local_twi_handler+0x10c>
			xSemaphoreGiveFromISR(
  400220:	2100      	movs	r1, #0
  400222:	460b      	mov	r3, r1
  400224:	aa01      	add	r2, sp, #4
  400226:	f8df c0c8 	ldr.w	ip, [pc, #200]	; 4002f0 <local_twi_handler+0x1d0>
  40022a:	47e0      	blx	ip
					&higher_priority_task_woken);
		}

		/* if the receiving task supplied a notification semaphore, then
		notify the task that the transmission has completed. */
		if  (!(timeout_counter >= TWI_TIMEOUT_COUNTER)) {
  40022c:	3401      	adds	r4, #1
  40022e:	d093      	beq.n	400158 <local_twi_handler+0x38>
			if (rx_dma_control[twi_index].transaction_complete_notification_semaphore != NULL) {
  400230:	4b31      	ldr	r3, [pc, #196]	; (4002f8 <local_twi_handler+0x1d8>)
  400232:	f853 0036 	ldr.w	r0, [r3, r6, lsl #3]
  400236:	2800      	cmp	r0, #0
  400238:	d08e      	beq.n	400158 <local_twi_handler+0x38>
				xSemaphoreGiveFromISR(
  40023a:	2100      	movs	r1, #0
  40023c:	460b      	mov	r3, r1
  40023e:	aa01      	add	r2, sp, #4
  400240:	4c2b      	ldr	r4, [pc, #172]	; (4002f0 <local_twi_handler+0x1d0>)
  400242:	47a0      	blx	r4
  400244:	e788      	b.n	400158 <local_twi_handler+0x38>
	twi_status &= twi_get_interrupt_mask(twi_port);

	/* Has the PDC completed a transmission? */
	if ((twi_status & TWI_SR_ENDTX) != 0UL) {
		/* Disable PDC */
		pdc_disable_transfer(all_twi_definitions[twi_index].pdc_base_address, PERIPH_PTCR_TXTDIS);
  400246:	6858      	ldr	r0, [r3, #4]
  400248:	4b26      	ldr	r3, [pc, #152]	; (4002e4 <local_twi_handler+0x1c4>)
  40024a:	f44f 7100 	mov.w	r1, #512	; 0x200
  40024e:	4798      	blx	r3
		twi_disable_interrupt(twi_port, TWI_IDR_ENDTX);
  400250:	4628      	mov	r0, r5
  400252:	f44f 5100 	mov.w	r1, #8192	; 0x2000
  400256:	4b24      	ldr	r3, [pc, #144]	; (4002e8 <local_twi_handler+0x1c8>)
  400258:	4798      	blx	r3
  40025a:	e002      	b.n	400262 <local_twi_handler+0x142>
			status = twi_port->TWI_SR;
			if (status & TWI_SR_TXRDY) {
				break;
			}
			/* Check timeout condition. */
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
  40025c:	3401      	adds	r4, #1
  40025e:	1c63      	adds	r3, r4, #1
  400260:	d033      	beq.n	4002ca <local_twi_handler+0x1aa>
		uint8_t status;
		uint32_t timeout_counter = 0;

		/* Wait for TX ready flag */
		while (1) {
			status = twi_port->TWI_SR;
  400262:	6a2b      	ldr	r3, [r5, #32]
			if (status & TWI_SR_TXRDY) {
  400264:	075a      	lsls	r2, r3, #29
  400266:	d5f9      	bpl.n	40025c <local_twi_handler+0x13c>
static void local_twi_handler(const portBASE_TYPE twi_index)
{
	portBASE_TYPE higher_priority_task_woken = pdFALSE;
	uint32_t twi_status;
	Twi *twi_port;
	bool transfer_timeout = false;
  400268:	f04f 0900 	mov.w	r9, #0
				break;
			}
		}
		/* Complete the transfer - stop and last byte */
		twi_port->TWI_CR = TWI_CR_STOP;
		twi_port->TWI_THR = twis[twi_index].buffer[twis[twi_index].length-1];
  40026c:	4b21      	ldr	r3, [pc, #132]	; (4002f4 <local_twi_handler+0x1d4>)
  40026e:	00f2      	lsls	r2, r6, #3
  400270:	1899      	adds	r1, r3, r2
  400272:	f853 0036 	ldr.w	r0, [r3, r6, lsl #3]
  400276:	684b      	ldr	r3, [r1, #4]
				transfer_timeout = true;
				break;
			}
		}
		/* Complete the transfer - stop and last byte */
		twi_port->TWI_CR = TWI_CR_STOP;
  400278:	2102      	movs	r1, #2
		twi_port->TWI_THR = twis[twi_index].buffer[twis[twi_index].length-1];
  40027a:	4403      	add	r3, r0
				transfer_timeout = true;
				break;
			}
		}
		/* Complete the transfer - stop and last byte */
		twi_port->TWI_CR = TWI_CR_STOP;
  40027c:	6029      	str	r1, [r5, #0]
		twi_port->TWI_THR = twis[twi_index].buffer[twis[twi_index].length-1];
  40027e:	f813 3c01 	ldrb.w	r3, [r3, #-1]
  400282:	636b      	str	r3, [r5, #52]	; 0x34
  400284:	e002      	b.n	40028c <local_twi_handler+0x16c>
			status = twi_port->TWI_SR;
			if (status & TWI_SR_TXCOMP) {
				break;
			}
			/* Check timeout condition. */
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
  400286:	3401      	adds	r4, #1
  400288:	1c61      	adds	r1, r4, #1
  40028a:	d01b      	beq.n	4002c4 <local_twi_handler+0x1a4>
		twi_port->TWI_CR = TWI_CR_STOP;
		twi_port->TWI_THR = twis[twi_index].buffer[twis[twi_index].length-1];

		/* Wait for TX complete flag */
		while (1) {
			status = twi_port->TWI_SR;
  40028c:	6a2b      	ldr	r3, [r5, #32]
			if (status & TWI_SR_TXCOMP) {
  40028e:	07d8      	lsls	r0, r3, #31
  400290:	d5f9      	bpl.n	400286 <local_twi_handler+0x166>
				break;
			}
		}
		/* If the driver is supporting multi-threading, then return the access
		mutex. */
		if (tx_dma_control[twi_index].peripheral_access_mutex != NULL) {
  400292:	f8df b058 	ldr.w	fp, [pc, #88]	; 4002ec <local_twi_handler+0x1cc>
  400296:	445a      	add	r2, fp
  400298:	6850      	ldr	r0, [r2, #4]
  40029a:	b128      	cbz	r0, 4002a8 <local_twi_handler+0x188>
			xSemaphoreGiveFromISR(
  40029c:	2100      	movs	r1, #0
  40029e:	460b      	mov	r3, r1
  4002a0:	aa01      	add	r2, sp, #4
  4002a2:	f8df c04c 	ldr.w	ip, [pc, #76]	; 4002f0 <local_twi_handler+0x1d0>
  4002a6:	47e0      	blx	ip
					&higher_priority_task_woken);
		}

		/* if the sending task supplied a notification semaphore, then
		notify the task that the transmission has completed. */
		if (!(timeout_counter >= TWI_TIMEOUT_COUNTER)) {
  4002a8:	3401      	adds	r4, #1
  4002aa:	f43f af52 	beq.w	400152 <local_twi_handler+0x32>
			if (tx_dma_control[twi_index]. transaction_complete_notification_semaphore != NULL) {
  4002ae:	f85b 0036 	ldr.w	r0, [fp, r6, lsl #3]
  4002b2:	2800      	cmp	r0, #0
  4002b4:	f43f af4d 	beq.w	400152 <local_twi_handler+0x32>
				xSemaphoreGiveFromISR(
  4002b8:	2100      	movs	r1, #0
  4002ba:	460b      	mov	r3, r1
  4002bc:	aa01      	add	r2, sp, #4
  4002be:	4c0c      	ldr	r4, [pc, #48]	; (4002f0 <local_twi_handler+0x1d0>)
  4002c0:	47a0      	blx	r4
  4002c2:	e746      	b.n	400152 <local_twi_handler+0x32>
			if (status & TWI_SR_TXCOMP) {
				break;
			}
			/* Check timeout condition. */
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
				transfer_timeout = true;
  4002c4:	f04f 0901 	mov.w	r9, #1
  4002c8:	e7e3      	b.n	400292 <local_twi_handler+0x172>
			if (status & TWI_SR_TXRDY) {
				break;
			}
			/* Check timeout condition. */
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
				transfer_timeout = true;
  4002ca:	f04f 0901 	mov.w	r9, #1
  4002ce:	e7cd      	b.n	40026c <local_twi_handler+0x14c>
				if (status & TWI_SR_TXCOMP) {
					break;
				}
				/* Check timeout condition. */
				if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
					transfer_timeout = true;
  4002d0:	f04f 0901 	mov.w	r9, #1
  4002d4:	e7a0      	b.n	400218 <local_twi_handler+0xf8>
  4002d6:	bf00      	nop
  4002d8:	004005ed 	.word	0x004005ed
  4002dc:	004005f1 	.word	0x004005f1
  4002e0:	00403e4d 	.word	0x00403e4d
  4002e4:	00402261 	.word	0x00402261
  4002e8:	004005e5 	.word	0x004005e5
  4002ec:	20000b28 	.word	0x20000b28
  4002f0:	00404141 	.word	0x00404141
  4002f4:	20000b18 	.word	0x20000b18
  4002f8:	20000b08 	.word	0x20000b08
  4002fc:	00406a04 	.word	0x00406a04

00400300 <TWI0_Handler>:
#endif /* TWI */

#ifdef TWI0

void TWI0_Handler(void)
{
  400300:	b508      	push	{r3, lr}
	local_twi_handler(0);
  400302:	2000      	movs	r0, #0
  400304:	4b01      	ldr	r3, [pc, #4]	; (40030c <TWI0_Handler+0xc>)
  400306:	4798      	blx	r3
  400308:	bd08      	pop	{r3, pc}
  40030a:	bf00      	nop
  40030c:	00400121 	.word	0x00400121

00400310 <TWI1_Handler>:
#endif

#ifdef TWI1

void TWI1_Handler(void)
{
  400310:	b508      	push	{r3, lr}
	local_twi_handler(1);
  400312:	2001      	movs	r0, #1
  400314:	4b01      	ldr	r3, [pc, #4]	; (40031c <TWI1_Handler+0xc>)
  400316:	4798      	blx	r3
  400318:	bd08      	pop	{r3, pc}
  40031a:	bf00      	nop
  40031c:	00400121 	.word	0x00400121

00400320 <efc_get_wait_state>:
 *
 * \return The number of wait states in cycle (no shift).
 */
uint32_t efc_get_wait_state(Efc *p_efc)
{
	return ((p_efc->EEFC_FMR & EEFC_FMR_FWS_Msk) >> EEFC_FMR_FWS_Pos);
  400320:	6800      	ldr	r0, [r0, #0]
}
  400322:	f3c0 2003 	ubfx	r0, r0, #8, #4
  400326:	4770      	bx	lr

00400328 <efc_init>:
 * \param ul_fws The number of wait states in cycle (no shift).
 *
 * \return 0 if successful.
 */
uint32_t efc_init(Efc *p_efc, uint32_t ul_access_mode, uint32_t ul_fws)
{
  400328:	b508      	push	{r3, lr}
#if (SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM)
	efc_write_fmr(p_efc, ul_access_mode | EEFC_FMR_FWS(ul_fws) | EEFC_FMR_CLOE);
  40032a:	0212      	lsls	r2, r2, #8
  40032c:	f402 6270 	and.w	r2, r2, #3840	; 0xf00
  400330:	f041 6180 	orr.w	r1, r1, #67108864	; 0x4000000
  400334:	4311      	orrs	r1, r2
  400336:	4b02      	ldr	r3, [pc, #8]	; (400340 <efc_init+0x18>)
  400338:	4798      	blx	r3
#else
	efc_write_fmr(p_efc, ul_access_mode | EEFC_FMR_FWS(ul_fws));
#endif	
	return EFC_RC_OK;
}
  40033a:	2000      	movs	r0, #0
  40033c:	bd08      	pop	{r3, pc}
  40033e:	bf00      	nop
  400340:	20000069 	.word	0x20000069

00400344 <efc_set_wait_state>:
 *
 * \param p_efc Pointer to an EFC instance.
 * \param ul_fws The number of wait states in cycle (no shift).
 */
void efc_set_wait_state(Efc *p_efc, uint32_t ul_fws)
{
  400344:	b508      	push	{r3, lr}
	uint32_t ul_fmr = p_efc->EEFC_FMR & (~EEFC_FMR_FWS_Msk);
  400346:	6802      	ldr	r2, [r0, #0]

	efc_write_fmr(p_efc, ul_fmr | EEFC_FMR_FWS(ul_fws));
  400348:	4b04      	ldr	r3, [pc, #16]	; (40035c <efc_set_wait_state+0x18>)
  40034a:	0209      	lsls	r1, r1, #8
 * \param p_efc Pointer to an EFC instance.
 * \param ul_fws The number of wait states in cycle (no shift).
 */
void efc_set_wait_state(Efc *p_efc, uint32_t ul_fws)
{
	uint32_t ul_fmr = p_efc->EEFC_FMR & (~EEFC_FMR_FWS_Msk);
  40034c:	f422 6270 	bic.w	r2, r2, #3840	; 0xf00

	efc_write_fmr(p_efc, ul_fmr | EEFC_FMR_FWS(ul_fws));
  400350:	f401 6170 	and.w	r1, r1, #3840	; 0xf00
  400354:	4311      	orrs	r1, r2
  400356:	4798      	blx	r3
  400358:	bd08      	pop	{r3, pc}
  40035a:	bf00      	nop
  40035c:	20000069 	.word	0x20000069

00400360 <efc_perform_command>:
 *
 * \return 0 if successful, otherwise returns an error code.
 */
uint32_t efc_perform_command(Efc *p_efc, uint32_t ul_command,
		uint32_t ul_argument)
{
  400360:	b508      	push	{r3, lr}
	/* Unique ID commands are not supported. */
	if (ul_command == EFC_FCMD_STUI || ul_command == EFC_FCMD_SPUI) {
  400362:	f1a1 030e 	sub.w	r3, r1, #14
  400366:	2b01      	cmp	r3, #1
  400368:	d802      	bhi.n	400370 <efc_perform_command+0x10>
		return EFC_RC_NOT_SUPPORT;
  40036a:	f04f 30ff 	mov.w	r0, #4294967295

	/* Use RAM Function. */
	return efc_perform_fcr(p_efc,
			EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(ul_argument) |
			EEFC_FCR_FCMD(ul_command));
}
  40036e:	bd08      	pop	{r3, pc}
		return EFC_RC_NOT_SUPPORT;
	}

	/* Use RAM Function. */
	return efc_perform_fcr(p_efc,
			EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(ul_argument) |
  400370:	0212      	lsls	r2, r2, #8
  400372:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
  400376:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
  40037a:	f042 42b4 	orr.w	r2, r2, #1509949440	; 0x5a000000
			EEFC_FCR_FCMD(ul_command));
  40037e:	b2c9      	uxtb	r1, r1
	if (ul_command == EFC_FCMD_STUI || ul_command == EFC_FCMD_SPUI) {
		return EFC_RC_NOT_SUPPORT;
	}

	/* Use RAM Function. */
	return efc_perform_fcr(p_efc,
  400380:	4311      	orrs	r1, r2
  400382:	4b01      	ldr	r3, [pc, #4]	; (400388 <efc_perform_command+0x28>)
  400384:	4798      	blx	r3
  400386:	bd08      	pop	{r3, pc}
  400388:	2000006d 	.word	0x2000006d

0040038c <flash_init>:
 * \param ul_fws The number of wait states in cycle (no shift).
 *
 * \return 0 if successful; otherwise returns an error code.
 */
uint32_t flash_init(uint32_t ul_mode, uint32_t ul_fws)
{
  40038c:	b508      	push	{r3, lr}
  40038e:	460a      	mov	r2, r1
	efc_init(EFC, ul_mode, ul_fws);
  400390:	4b02      	ldr	r3, [pc, #8]	; (40039c <flash_init+0x10>)
  400392:	4601      	mov	r1, r0
  400394:	4802      	ldr	r0, [pc, #8]	; (4003a0 <flash_init+0x14>)
  400396:	4798      	blx	r3
#ifdef EFC1
	efc_init(EFC1, ul_mode, ul_fws);
#endif

	return FLASH_RC_OK;
}
  400398:	2000      	movs	r0, #0
  40039a:	bd08      	pop	{r3, pc}
  40039c:	00400329 	.word	0x00400329
  4003a0:	400e0a00 	.word	0x400e0a00

004003a4 <flash_erase_page>:
uint32_t flash_erase_page(uint32_t ul_address, uint8_t uc_page_num)
{
	Efc *p_efc;
	uint16_t us_page;

	if (uc_page_num >= IFLASH_ERASE_PAGES_INVALID) {
  4003a4:	2903      	cmp	r1, #3
 * \param ul_address Flash bank start address.
 *
 * \return 0 if successful; otherwise returns an error code.
 */
uint32_t flash_erase_page(uint32_t ul_address, uint8_t uc_page_num)
{
  4003a6:	b508      	push	{r3, lr}
	Efc *p_efc;
	uint16_t us_page;

	if (uc_page_num >= IFLASH_ERASE_PAGES_INVALID) {
  4003a8:	d901      	bls.n	4003ae <flash_erase_page+0xa>
		return FLASH_RC_INVALID;
  4003aa:	2011      	movs	r0, #17
	{
		return retVal;
	}

	return FLASH_RC_OK;
}
  4003ac:	bd08      	pop	{r3, pc}

	if (uc_page_num >= IFLASH_ERASE_PAGES_INVALID) {
		return FLASH_RC_INVALID;
	}

	if (ul_address & (IFLASH_PAGE_SIZE - 1)) {
  4003ae:	f3c0 0308 	ubfx	r3, r0, #0, #9
  4003b2:	2b00      	cmp	r3, #0
  4003b4:	d1f9      	bne.n	4003aa <flash_erase_page+0x6>
#else
	Assert(ul_addr >= IFLASH_ADDR);
	Assert(ul_addr <= (IFLASH_ADDR + IFLASH_SIZE));

	p_efc = EFC;
	us_page = (ul_addr - IFLASH_ADDR) / IFLASH_PAGE_SIZE;
  4003b6:	f5a0 0280 	sub.w	r2, r0, #4194304	; 0x400000
  4003ba:	f3c2 224f 	ubfx	r2, r2, #9, #16
	if (ul_address & (IFLASH_PAGE_SIZE - 1)) {
		return FLASH_RC_INVALID;
	}

	translate_address(&p_efc, ul_address, &us_page, NULL);
	uint32_t retVal = efc_perform_command(p_efc, EFC_FCMD_EPA,
  4003be:	430a      	orrs	r2, r1
  4003c0:	4b02      	ldr	r3, [pc, #8]	; (4003cc <flash_erase_page+0x28>)
  4003c2:	4803      	ldr	r0, [pc, #12]	; (4003d0 <flash_erase_page+0x2c>)
  4003c4:	2107      	movs	r1, #7
  4003c6:	4798      	blx	r3
  4003c8:	bd08      	pop	{r3, pc}
  4003ca:	bf00      	nop
  4003cc:	00400361 	.word	0x00400361
  4003d0:	400e0a00 	.word	0x400e0a00

004003d4 <flash_write>:
 *
 * \return 0 if successful, otherwise returns an error code.
 */
uint32_t __attribute__((optimize("O0"))) flash_write(uint32_t ul_address, const void *p_buffer,
		uint32_t ul_size, uint32_t ul_erase_flag)
{
  4003d4:	b580      	push	{r7, lr}
  4003d6:	b096      	sub	sp, #88	; 0x58
  4003d8:	af00      	add	r7, sp, #0
  4003da:	60f8      	str	r0, [r7, #12]
  4003dc:	60b9      	str	r1, [r7, #8]
  4003de:	607a      	str	r2, [r7, #4]
  4003e0:	603b      	str	r3, [r7, #0]
	uint32_t ul_page_addr;
	uint16_t us_padding;
	uint32_t ul_error;
	uint32_t ul_idx;
	uint32_t *p_aligned_dest;
	uint8_t *puc_page_buffer = (uint8_t *) gs_ul_page_buffer;
  4003e2:	4b62      	ldr	r3, [pc, #392]	; (40056c <flash_write+0x198>)
  4003e4:	64bb      	str	r3, [r7, #72]	; 0x48
  4003e6:	f107 0318 	add.w	r3, r7, #24
  4003ea:	63bb      	str	r3, [r7, #56]	; 0x38
  4003ec:	68fb      	ldr	r3, [r7, #12]
  4003ee:	637b      	str	r3, [r7, #52]	; 0x34
  4003f0:	f107 0316 	add.w	r3, r7, #22
  4003f4:	633b      	str	r3, [r7, #48]	; 0x30
  4003f6:	f107 0314 	add.w	r3, r7, #20
  4003fa:	62fb      	str	r3, [r7, #44]	; 0x2c
#else
	Assert(ul_addr >= IFLASH_ADDR);
	Assert(ul_addr <= (IFLASH_ADDR + IFLASH_SIZE));

	p_efc = EFC;
	us_page = (ul_addr - IFLASH_ADDR) / IFLASH_PAGE_SIZE;
  4003fc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  4003fe:	f5a3 0380 	sub.w	r3, r3, #4194304	; 0x400000
  400402:	0a5b      	lsrs	r3, r3, #9
  400404:	857b      	strh	r3, [r7, #42]	; 0x2a
	us_offset = (ul_addr - IFLASH_ADDR) % IFLASH_PAGE_SIZE;
  400406:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  400408:	b29b      	uxth	r3, r3
  40040a:	f3c3 0308 	ubfx	r3, r3, #0, #9
  40040e:	853b      	strh	r3, [r7, #40]	; 0x28
#endif

	/* Store values */
	if (pp_efc) {
  400410:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  400412:	2b00      	cmp	r3, #0
  400414:	d002      	beq.n	40041c <flash_write+0x48>
		*pp_efc = p_efc;
  400416:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  400418:	4a55      	ldr	r2, [pc, #340]	; (400570 <flash_write+0x19c>)
  40041a:	601a      	str	r2, [r3, #0]
	}

	if (pus_page) {
  40041c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  40041e:	2b00      	cmp	r3, #0
  400420:	d002      	beq.n	400428 <flash_write+0x54>
		*pus_page = us_page;
  400422:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  400424:	8d7a      	ldrh	r2, [r7, #42]	; 0x2a
  400426:	801a      	strh	r2, [r3, #0]
	}

	if (pus_offset) {
  400428:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40042a:	2b00      	cmp	r3, #0
  40042c:	d002      	beq.n	400434 <flash_write+0x60>
		*pus_offset = us_offset;
  40042e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  400430:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
  400432:	801a      	strh	r2, [r3, #0]
	uint8_t *puc_page_buffer = (uint8_t *) gs_ul_page_buffer;

	translate_address(&p_efc, ul_address, &us_page, &us_offset);

	/* According to the errata, set the wait state value to 6. */
	ul_fws_temp = efc_get_wait_state(p_efc);
  400434:	69bb      	ldr	r3, [r7, #24]
  400436:	4618      	mov	r0, r3
  400438:	4b4e      	ldr	r3, [pc, #312]	; (400574 <flash_write+0x1a0>)
  40043a:	4798      	blx	r3
  40043c:	6478      	str	r0, [r7, #68]	; 0x44
	efc_set_wait_state(p_efc, 6);
  40043e:	69bb      	ldr	r3, [r7, #24]
  400440:	4618      	mov	r0, r3
  400442:	2106      	movs	r1, #6
  400444:	4b4c      	ldr	r3, [pc, #304]	; (400578 <flash_write+0x1a4>)
  400446:	4798      	blx	r3

	/* Write all pages */
	while (ul_size > 0) {
  400448:	e082      	b.n	400550 <flash_write+0x17c>
		/* Copy data in temporary buffer to avoid alignment problems. */
		writeSize = Min((uint32_t) IFLASH_PAGE_SIZE - us_offset,
  40044a:	8abb      	ldrh	r3, [r7, #20]
  40044c:	f5c3 7200 	rsb	r2, r3, #512	; 0x200
  400450:	687b      	ldr	r3, [r7, #4]
  400452:	429a      	cmp	r2, r3
  400454:	bf38      	it	cc
  400456:	4613      	movcc	r3, r2
  400458:	643b      	str	r3, [r7, #64]	; 0x40
				ul_size);
		compute_address(p_efc, us_page, 0, &ul_page_addr);
  40045a:	8afb      	ldrh	r3, [r7, #22]
  40045c:	84fb      	strh	r3, [r7, #38]	; 0x26
  40045e:	2300      	movs	r3, #0
  400460:	84bb      	strh	r3, [r7, #36]	; 0x24
  400462:	f107 0310 	add.w	r3, r7, #16
  400466:	623b      	str	r3, [r7, #32]
/* One bank flash */
#else
	/* avoid Cppcheck Warning */
	UNUSED(p_efc);
	/* Compute address */
	ul_addr = IFLASH_ADDR + us_page * IFLASH_PAGE_SIZE + us_offset;
  400468:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
  40046a:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
  40046e:	025a      	lsls	r2, r3, #9
  400470:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
  400472:	4413      	add	r3, r2
  400474:	61fb      	str	r3, [r7, #28]
#endif

	/* Store result */
	if (pul_addr != NULL) {
  400476:	6a3b      	ldr	r3, [r7, #32]
  400478:	2b00      	cmp	r3, #0
  40047a:	d002      	beq.n	400482 <flash_write+0xae>
		*pul_addr = ul_addr;
  40047c:	6a3b      	ldr	r3, [r7, #32]
  40047e:	69fa      	ldr	r2, [r7, #28]
  400480:	601a      	str	r2, [r3, #0]
	while (ul_size > 0) {
		/* Copy data in temporary buffer to avoid alignment problems. */
		writeSize = Min((uint32_t) IFLASH_PAGE_SIZE - us_offset,
				ul_size);
		compute_address(p_efc, us_page, 0, &ul_page_addr);
		us_padding = IFLASH_PAGE_SIZE - us_offset - writeSize;
  400482:	8abb      	ldrh	r3, [r7, #20]
  400484:	425b      	negs	r3, r3
  400486:	b29a      	uxth	r2, r3
  400488:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  40048a:	b29b      	uxth	r3, r3
  40048c:	1ad3      	subs	r3, r2, r3
  40048e:	b29b      	uxth	r3, r3
  400490:	f503 7300 	add.w	r3, r3, #512	; 0x200
  400494:	87fb      	strh	r3, [r7, #62]	; 0x3e

		/* Pre-buffer data */
		memcpy(puc_page_buffer, (void *)ul_page_addr, us_offset);
  400496:	693b      	ldr	r3, [r7, #16]
  400498:	461a      	mov	r2, r3
  40049a:	8abb      	ldrh	r3, [r7, #20]
  40049c:	6cb8      	ldr	r0, [r7, #72]	; 0x48
  40049e:	4611      	mov	r1, r2
  4004a0:	461a      	mov	r2, r3
  4004a2:	4b36      	ldr	r3, [pc, #216]	; (40057c <flash_write+0x1a8>)
  4004a4:	4798      	blx	r3

		/* Buffer data */
		memcpy(puc_page_buffer + us_offset, p_buffer, writeSize);
  4004a6:	8abb      	ldrh	r3, [r7, #20]
  4004a8:	6cba      	ldr	r2, [r7, #72]	; 0x48
  4004aa:	4413      	add	r3, r2
  4004ac:	4618      	mov	r0, r3
  4004ae:	68b9      	ldr	r1, [r7, #8]
  4004b0:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  4004b2:	4b32      	ldr	r3, [pc, #200]	; (40057c <flash_write+0x1a8>)
  4004b4:	4798      	blx	r3

		/* Post-buffer data */
		memcpy(puc_page_buffer + us_offset + writeSize,
  4004b6:	8abb      	ldrh	r3, [r7, #20]
  4004b8:	461a      	mov	r2, r3
  4004ba:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  4004bc:	4413      	add	r3, r2
  4004be:	6cba      	ldr	r2, [r7, #72]	; 0x48
  4004c0:	18d1      	adds	r1, r2, r3
				(void *)(ul_page_addr + us_offset + writeSize),
  4004c2:	8abb      	ldrh	r3, [r7, #20]
  4004c4:	461a      	mov	r2, r3
  4004c6:	693b      	ldr	r3, [r7, #16]
  4004c8:	441a      	add	r2, r3
  4004ca:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  4004cc:	4413      	add	r3, r2

		/* Buffer data */
		memcpy(puc_page_buffer + us_offset, p_buffer, writeSize);

		/* Post-buffer data */
		memcpy(puc_page_buffer + us_offset + writeSize,
  4004ce:	461a      	mov	r2, r3
  4004d0:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
  4004d2:	4608      	mov	r0, r1
  4004d4:	4611      	mov	r1, r2
  4004d6:	461a      	mov	r2, r3
  4004d8:	4b28      	ldr	r3, [pc, #160]	; (40057c <flash_write+0x1a8>)
  4004da:	4798      	blx	r3

		/* Write page.
		 * Writing 8-bit and 16-bit data is not allowed and may lead to
		 * unpredictable data corruption.
		 */
		p_aligned_dest = (uint32_t *) ul_page_addr;
  4004dc:	693b      	ldr	r3, [r7, #16]
  4004de:	64fb      	str	r3, [r7, #76]	; 0x4c
		for (ul_idx = 0; ul_idx < (IFLASH_PAGE_SIZE / sizeof(uint32_t));
  4004e0:	2300      	movs	r3, #0
  4004e2:	653b      	str	r3, [r7, #80]	; 0x50
  4004e4:	e00a      	b.n	4004fc <flash_write+0x128>
				++ul_idx) {
			*p_aligned_dest++ = gs_ul_page_buffer[ul_idx];
  4004e6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  4004e8:	1d1a      	adds	r2, r3, #4
  4004ea:	64fa      	str	r2, [r7, #76]	; 0x4c
  4004ec:	4a1f      	ldr	r2, [pc, #124]	; (40056c <flash_write+0x198>)
  4004ee:	6d39      	ldr	r1, [r7, #80]	; 0x50
  4004f0:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
  4004f4:	601a      	str	r2, [r3, #0]
		 * Writing 8-bit and 16-bit data is not allowed and may lead to
		 * unpredictable data corruption.
		 */
		p_aligned_dest = (uint32_t *) ul_page_addr;
		for (ul_idx = 0; ul_idx < (IFLASH_PAGE_SIZE / sizeof(uint32_t));
				++ul_idx) {
  4004f6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  4004f8:	3301      	adds	r3, #1
  4004fa:	653b      	str	r3, [r7, #80]	; 0x50
		/* Write page.
		 * Writing 8-bit and 16-bit data is not allowed and may lead to
		 * unpredictable data corruption.
		 */
		p_aligned_dest = (uint32_t *) ul_page_addr;
		for (ul_idx = 0; ul_idx < (IFLASH_PAGE_SIZE / sizeof(uint32_t));
  4004fc:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  4004fe:	2b7f      	cmp	r3, #127	; 0x7f
  400500:	d9f1      	bls.n	4004e6 <flash_write+0x112>
				++ul_idx) {
			*p_aligned_dest++ = gs_ul_page_buffer[ul_idx];
		}

		if (ul_erase_flag) {
  400502:	683b      	ldr	r3, [r7, #0]
  400504:	2b00      	cmp	r3, #0
  400506:	d008      	beq.n	40051a <flash_write+0x146>
			ul_error = efc_perform_command(p_efc, EFC_FCMD_EWP,
  400508:	69ba      	ldr	r2, [r7, #24]
  40050a:	8afb      	ldrh	r3, [r7, #22]
  40050c:	4610      	mov	r0, r2
  40050e:	2103      	movs	r1, #3
  400510:	461a      	mov	r2, r3
  400512:	4b1b      	ldr	r3, [pc, #108]	; (400580 <flash_write+0x1ac>)
  400514:	4798      	blx	r3
  400516:	6578      	str	r0, [r7, #84]	; 0x54
  400518:	e007      	b.n	40052a <flash_write+0x156>
					us_page);
		} else {
			ul_error = efc_perform_command(p_efc, EFC_FCMD_WP,
  40051a:	69ba      	ldr	r2, [r7, #24]
  40051c:	8afb      	ldrh	r3, [r7, #22]
  40051e:	4610      	mov	r0, r2
  400520:	2101      	movs	r1, #1
  400522:	461a      	mov	r2, r3
  400524:	4b16      	ldr	r3, [pc, #88]	; (400580 <flash_write+0x1ac>)
  400526:	4798      	blx	r3
  400528:	6578      	str	r0, [r7, #84]	; 0x54
					us_page);
		}

		if (ul_error) {
  40052a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  40052c:	2b00      	cmp	r3, #0
  40052e:	d001      	beq.n	400534 <flash_write+0x160>
			return ul_error;
  400530:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  400532:	e017      	b.n	400564 <flash_write+0x190>
		}

		/* Progression */
		p_buffer = (void *)((uint32_t) p_buffer + writeSize);
  400534:	68ba      	ldr	r2, [r7, #8]
  400536:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  400538:	4413      	add	r3, r2
  40053a:	60bb      	str	r3, [r7, #8]
		ul_size -= writeSize;
  40053c:	687a      	ldr	r2, [r7, #4]
  40053e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  400540:	1ad3      	subs	r3, r2, r3
  400542:	607b      	str	r3, [r7, #4]
		us_page++;
  400544:	8afb      	ldrh	r3, [r7, #22]
  400546:	3301      	adds	r3, #1
  400548:	b29b      	uxth	r3, r3
  40054a:	82fb      	strh	r3, [r7, #22]
		us_offset = 0;
  40054c:	2300      	movs	r3, #0
  40054e:	82bb      	strh	r3, [r7, #20]
	/* According to the errata, set the wait state value to 6. */
	ul_fws_temp = efc_get_wait_state(p_efc);
	efc_set_wait_state(p_efc, 6);

	/* Write all pages */
	while (ul_size > 0) {
  400550:	687b      	ldr	r3, [r7, #4]
  400552:	2b00      	cmp	r3, #0
  400554:	f47f af79 	bne.w	40044a <flash_write+0x76>
		us_page++;
		us_offset = 0;
	}

	/* According to the errata, restore the wait state value. */
	efc_set_wait_state(p_efc, ul_fws_temp);
  400558:	69bb      	ldr	r3, [r7, #24]
  40055a:	4618      	mov	r0, r3
  40055c:	6c79      	ldr	r1, [r7, #68]	; 0x44
  40055e:	4b06      	ldr	r3, [pc, #24]	; (400578 <flash_write+0x1a4>)
  400560:	4798      	blx	r3

	return FLASH_RC_OK;
  400562:	2300      	movs	r3, #0
}
  400564:	4618      	mov	r0, r3
  400566:	3758      	adds	r7, #88	; 0x58
  400568:	46bd      	mov	sp, r7
  40056a:	bd80      	pop	{r7, pc}
  40056c:	20000b38 	.word	0x20000b38
  400570:	400e0a00 	.word	0x400e0a00
  400574:	00400321 	.word	0x00400321
  400578:	00400345 	.word	0x00400345
  40057c:	0040641d 	.word	0x0040641d
  400580:	00400361 	.word	0x00400361

00400584 <flash_unlock>:
		uint32_t *pul_actual_start, uint32_t *pul_actual_end)
{
	uint32_t ul_actual_start, ul_actual_end;

	ul_actual_start = ul_start - (ul_start % IFLASH_LOCK_REGION_SIZE);
	ul_actual_end = ul_end - (ul_end % IFLASH_LOCK_REGION_SIZE) +
  400584:	f421 51ff 	bic.w	r1, r1, #8160	; 0x1fe0
  400588:	f021 011f 	bic.w	r1, r1, #31
 *
 * \return 0 if successful, otherwise returns an error code.
 */
uint32_t flash_unlock(uint32_t ul_start, uint32_t ul_end,
		uint32_t *pul_actual_start, uint32_t *pul_actual_end)
{
  40058c:	b570      	push	{r4, r5, r6, lr}
static void compute_lock_range(uint32_t ul_start, uint32_t ul_end,
		uint32_t *pul_actual_start, uint32_t *pul_actual_end)
{
	uint32_t ul_actual_start, ul_actual_end;

	ul_actual_start = ul_start - (ul_start % IFLASH_LOCK_REGION_SIZE);
  40058e:	f420 50ff 	bic.w	r0, r0, #8160	; 0x1fe0
	ul_actual_end = ul_end - (ul_end % IFLASH_LOCK_REGION_SIZE) +
  400592:	f501 54ff 	add.w	r4, r1, #8160	; 0x1fe0
static void compute_lock_range(uint32_t ul_start, uint32_t ul_end,
		uint32_t *pul_actual_start, uint32_t *pul_actual_end)
{
	uint32_t ul_actual_start, ul_actual_end;

	ul_actual_start = ul_start - (ul_start % IFLASH_LOCK_REGION_SIZE);
  400596:	f020 001f 	bic.w	r0, r0, #31
	ul_actual_end = ul_end - (ul_end % IFLASH_LOCK_REGION_SIZE) +
  40059a:	341f      	adds	r4, #31
	uint16_t us_num_pages_in_region =
			IFLASH_LOCK_REGION_SIZE / IFLASH_PAGE_SIZE;

	/* Compute actual unlock range and store it */
	compute_lock_range(ul_start, ul_end, &ul_actual_start, &ul_actual_end);
	if (pul_actual_start != NULL) {
  40059c:	b102      	cbz	r2, 4005a0 <flash_unlock+0x1c>
		*pul_actual_start = ul_actual_start;
  40059e:	6010      	str	r0, [r2, #0]
	}
	if (pul_actual_end != NULL) {
  4005a0:	b103      	cbz	r3, 4005a4 <flash_unlock+0x20>
		*pul_actual_end = ul_actual_end;
  4005a2:	601c      	str	r4, [r3, #0]
#else
	Assert(ul_addr >= IFLASH_ADDR);
	Assert(ul_addr <= (IFLASH_ADDR + IFLASH_SIZE));

	p_efc = EFC;
	us_page = (ul_addr - IFLASH_ADDR) / IFLASH_PAGE_SIZE;
  4005a4:	4d0c      	ldr	r5, [pc, #48]	; (4005d8 <flash_unlock+0x54>)
  4005a6:	f5a0 0480 	sub.w	r4, r0, #4194304	; 0x400000
  4005aa:	0a64      	lsrs	r4, r4, #9
  4005ac:	440d      	add	r5, r1
  4005ae:	b2a4      	uxth	r4, r4
  4005b0:	f3c5 254f 	ubfx	r5, r5, #9, #16
	/* Compute page numbers */
	translate_address(&p_efc, ul_actual_start, &us_start_page, 0);
	translate_address(0, ul_actual_end, &us_end_page, 0);

	/* Unlock all pages */
	while (us_start_page < us_end_page) {
  4005b4:	42ac      	cmp	r4, r5
  4005b6:	d20c      	bcs.n	4005d2 <flash_unlock+0x4e>
  4005b8:	4e08      	ldr	r6, [pc, #32]	; (4005dc <flash_unlock+0x58>)
  4005ba:	e001      	b.n	4005c0 <flash_unlock+0x3c>
  4005bc:	42ac      	cmp	r4, r5
  4005be:	d208      	bcs.n	4005d2 <flash_unlock+0x4e>
		ul_error = efc_perform_command(p_efc, EFC_FCMD_CLB,
  4005c0:	4622      	mov	r2, r4
  4005c2:	4807      	ldr	r0, [pc, #28]	; (4005e0 <flash_unlock+0x5c>)
  4005c4:	2109      	movs	r1, #9
  4005c6:	47b0      	blx	r6
				us_start_page);
		if (ul_error) {
			return ul_error;
		}
		us_start_page += us_num_pages_in_region;
  4005c8:	3410      	adds	r4, #16
  4005ca:	b2a4      	uxth	r4, r4

	/* Unlock all pages */
	while (us_start_page < us_end_page) {
		ul_error = efc_perform_command(p_efc, EFC_FCMD_CLB,
				us_start_page);
		if (ul_error) {
  4005cc:	2800      	cmp	r0, #0
  4005ce:	d0f5      	beq.n	4005bc <flash_unlock+0x38>
		}
		us_start_page += us_num_pages_in_region;
	}

	return FLASH_RC_OK;
}
  4005d0:	bd70      	pop	{r4, r5, r6, pc}
			return ul_error;
		}
		us_start_page += us_num_pages_in_region;
	}

	return FLASH_RC_OK;
  4005d2:	2000      	movs	r0, #0
  4005d4:	bd70      	pop	{r4, r5, r6, pc}
  4005d6:	bf00      	nop
  4005d8:	ffc01fff 	.word	0xffc01fff
  4005dc:	00400361 	.word	0x00400361
  4005e0:	400e0a00 	.word	0x400e0a00

004005e4 <twi_disable_interrupt>:
 * \param ul_sources Interrupts to be disabled.
 */
void twi_disable_interrupt(Twi *p_twi, uint32_t ul_sources)
{
	/* Disable the specified interrupts */
	p_twi->TWI_IDR = ul_sources;
  4005e4:	6281      	str	r1, [r0, #40]	; 0x28
	/* Dummy read */
	p_twi->TWI_SR;
  4005e6:	6a03      	ldr	r3, [r0, #32]
  4005e8:	4770      	bx	lr
  4005ea:	bf00      	nop

004005ec <twi_get_interrupt_status>:
 *
 * \retval TWI interrupt status.
 */
uint32_t twi_get_interrupt_status(Twi *p_twi)
{
	return p_twi->TWI_SR;
  4005ec:	6a00      	ldr	r0, [r0, #32]
}
  4005ee:	4770      	bx	lr

004005f0 <twi_get_interrupt_mask>:
 *
 * \return The interrupt mask value.
 */
uint32_t twi_get_interrupt_mask(Twi *p_twi)
{
	return p_twi->TWI_IMR;
  4005f0:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
}
  4005f2:	4770      	bx	lr

004005f4 <loadNewFirmware>:
 * loadNewFirmware(char* filename)
 * @brief Load new firmware function. 
 * @return status_t returns STATUS_PASS if successful and STATUS_FAIL if there is a failure. 
 */
status_t __attribute__((optimize("O0"))) loadNewFirmware(char* filename)
{	
  4005f4:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
  4005f8:	f5ad 6dd1 	sub.w	sp, sp, #1672	; 0x688
  4005fc:	af00      	add	r7, sp, #0
  4005fe:	f107 0324 	add.w	r3, r7, #36	; 0x24
  400602:	6018      	str	r0, [r3, #0]
	status_t result = STATUS_PASS;
  400604:	2300      	movs	r3, #0
  400606:	f887 3677 	strb.w	r3, [r7, #1655]	; 0x677
	FIL firmwareFileObj = {0};
  40060a:	f207 433c 	addw	r3, r7, #1084	; 0x43c
  40060e:	f44f 720a 	mov.w	r2, #552	; 0x228
  400612:	4618      	mov	r0, r3
  400614:	2100      	movs	r1, #0
  400616:	4b76      	ldr	r3, [pc, #472]	; (4007f0 <loadNewFirmware+0x1fc>)
  400618:	4798      	blx	r3
	//initialize the suitNumber

	filename[0] = LUN_ID_SD_MMC_0_MEM + '0'; //is this necessary? 
  40061a:	f107 0324 	add.w	r3, r7, #36	; 0x24
  40061e:	681b      	ldr	r3, [r3, #0]
  400620:	2230      	movs	r2, #48	; 0x30
  400622:	701a      	strb	r2, [r3, #0]
	wdt_disable(WDT);
  400624:	4873      	ldr	r0, [pc, #460]	; (4007f4 <loadNewFirmware+0x200>)
  400626:	4b74      	ldr	r3, [pc, #464]	; (4007f8 <loadNewFirmware+0x204>)
  400628:	4798      	blx	r3
	
	FRESULT res = f_open(&firmwareFileObj, (char const *)filename, FA_OPEN_EXISTING | FA_READ);
  40062a:	f207 423c 	addw	r2, r7, #1084	; 0x43c
  40062e:	f107 0324 	add.w	r3, r7, #36	; 0x24
  400632:	4610      	mov	r0, r2
  400634:	6819      	ldr	r1, [r3, #0]
  400636:	2201      	movs	r2, #1
  400638:	4b70      	ldr	r3, [pc, #448]	; (4007fc <loadNewFirmware+0x208>)
  40063a:	4798      	blx	r3
  40063c:	4603      	mov	r3, r0
  40063e:	f887 3687 	strb.w	r3, [r7, #1671]	; 0x687
	if (res != FR_OK)
  400642:	f897 3687 	ldrb.w	r3, [r7, #1671]	; 0x687
  400646:	2b00      	cmp	r3, #0
  400648:	d001      	beq.n	40064e <loadNewFirmware+0x5a>
	{
		return STATUS_FAIL;
  40064a:	2301      	movs	r3, #1
  40064c:	e2d6      	b.n	400bfc <loadNewFirmware+0x608>
	}
	//read the header from the file. 
	firmwareHeader_t header = {0}; 
  40064e:	f507 6386 	add.w	r3, r7, #1072	; 0x430
  400652:	2200      	movs	r2, #0
  400654:	601a      	str	r2, [r3, #0]
  400656:	3304      	adds	r3, #4
  400658:	2200      	movs	r2, #0
  40065a:	601a      	str	r2, [r3, #0]
  40065c:	3304      	adds	r3, #4
  40065e:	2200      	movs	r2, #0
  400660:	601a      	str	r2, [r3, #0]
  400662:	3304      	adds	r3, #4
	uint32_t bytes_read = 0, total_bytes_read = 0;	
  400664:	f207 432c 	addw	r3, r7, #1068	; 0x42c
  400668:	2200      	movs	r2, #0
  40066a:	601a      	str	r2, [r3, #0]
  40066c:	2300      	movs	r3, #0
  40066e:	f8c7 3680 	str.w	r3, [r7, #1664]	; 0x680
	res = f_read(&firmwareFileObj, (void*)&header, sizeof(firmwareHeader_t), &bytes_read);
  400672:	f207 433c 	addw	r3, r7, #1084	; 0x43c
  400676:	f507 6286 	add.w	r2, r7, #1072	; 0x430
  40067a:	f207 442c 	addw	r4, r7, #1068	; 0x42c
  40067e:	4618      	mov	r0, r3
  400680:	4611      	mov	r1, r2
  400682:	220c      	movs	r2, #12
  400684:	4623      	mov	r3, r4
  400686:	4c5e      	ldr	r4, [pc, #376]	; (400800 <loadNewFirmware+0x20c>)
  400688:	47a0      	blx	r4
  40068a:	4603      	mov	r3, r0
  40068c:	f887 3687 	strb.w	r3, [r7, #1671]	; 0x687
	//confirm that the file has a valid header, with the CRC bytes matching. 
	if(header.fileHeaderBytes != FIRMWARE_FILE_HEADER_BYTES ) //|| header.crc1 != header.crc2
  400690:	f507 6386 	add.w	r3, r7, #1072	; 0x430
  400694:	681a      	ldr	r2, [r3, #0]
  400696:	4b5b      	ldr	r3, [pc, #364]	; (400804 <loadNewFirmware+0x210>)
  400698:	429a      	cmp	r2, r3
  40069a:	d006      	beq.n	4006aa <loadNewFirmware+0xb6>
	{
		//bad header, don't even try to load this crap!
		f_close(&firmwareFileObj); 
  40069c:	f207 433c 	addw	r3, r7, #1084	; 0x43c
  4006a0:	4618      	mov	r0, r3
  4006a2:	4b59      	ldr	r3, [pc, #356]	; (400808 <loadNewFirmware+0x214>)
  4006a4:	4798      	blx	r3
		return STATUS_FAIL; 
  4006a6:	2301      	movs	r3, #1
  4006a8:	e2a8      	b.n	400bfc <loadNewFirmware+0x608>
	}	
	uint32_t destAddress = FIRMWARE_TEMPORARY_LOCATION; //that where we are writing
  4006aa:	4b58      	ldr	r3, [pc, #352]	; (40080c <loadNewFirmware+0x218>)
  4006ac:	f8c7 3670 	str.w	r3, [r7, #1648]	; 0x670
	uint32_t retVal = 0;
  4006b0:	2300      	movs	r3, #0
  4006b2:	f8c7 366c 	str.w	r3, [r7, #1644]	; 0x66c
	//initialize the memory
	retVal = flash_init(FLASH_ACCESS_MODE_128, 6); //	| EEFC_FMR_CLOE | EEFC_FMR_SCOD 
  4006b6:	2000      	movs	r0, #0
  4006b8:	2106      	movs	r1, #6
  4006ba:	4b55      	ldr	r3, [pc, #340]	; (400810 <loadNewFirmware+0x21c>)
  4006bc:	4798      	blx	r3
  4006be:	f8c7 066c 	str.w	r0, [r7, #1644]	; 0x66c
	int resultTest = 	efc_perform_fcr(EFC0,
  4006c2:	4854      	ldr	r0, [pc, #336]	; (400814 <loadNewFirmware+0x220>)
  4006c4:	4954      	ldr	r1, [pc, #336]	; (400818 <loadNewFirmware+0x224>)
  4006c6:	4b55      	ldr	r3, [pc, #340]	; (40081c <loadNewFirmware+0x228>)
  4006c8:	4798      	blx	r3
  4006ca:	4603      	mov	r3, r0
  4006cc:	f8c7 3668 	str.w	r3, [r7, #1640]	; 0x668
	EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(0x0123) |
	0x07u);
	
	retVal = flash_unlock(destAddress,destAddress + firmwareFileObj.fsize ,NULL,NULL);			
  4006d0:	f207 433c 	addw	r3, r7, #1084	; 0x43c
  4006d4:	68da      	ldr	r2, [r3, #12]
  4006d6:	f8d7 3670 	ldr.w	r3, [r7, #1648]	; 0x670
  4006da:	4413      	add	r3, r2
  4006dc:	f8d7 0670 	ldr.w	r0, [r7, #1648]	; 0x670
  4006e0:	4619      	mov	r1, r3
  4006e2:	2200      	movs	r2, #0
  4006e4:	2300      	movs	r3, #0
  4006e6:	4c4e      	ldr	r4, [pc, #312]	; (400820 <loadNewFirmware+0x22c>)
  4006e8:	47a0      	blx	r4
  4006ea:	f8c7 066c 	str.w	r0, [r7, #1644]	; 0x66c
	char buf[FIRMWARE_BUFFER_SIZE] = {0}; 	 
  4006ee:	f507 730b 	add.w	r3, r7, #556	; 0x22c
  4006f2:	f44f 7200 	mov.w	r2, #512	; 0x200
  4006f6:	4618      	mov	r0, r3
  4006f8:	2100      	movs	r1, #0
  4006fa:	4b3d      	ldr	r3, [pc, #244]	; (4007f0 <loadNewFirmware+0x1fc>)
  4006fc:	4798      	blx	r3
	char nullBuf[FIRMWARE_BUFFER_SIZE] = {0}; 		
  4006fe:	f107 032c 	add.w	r3, r7, #44	; 0x2c
  400702:	f44f 7200 	mov.w	r2, #512	; 0x200
  400706:	4618      	mov	r0, r3
  400708:	2100      	movs	r1, #0
  40070a:	4b39      	ldr	r3, [pc, #228]	; (4007f0 <loadNewFirmware+0x1fc>)
  40070c:	4798      	blx	r3
		
	uint32_t i = 0, error = 0;
  40070e:	2300      	movs	r3, #0
  400710:	f8c7 367c 	str.w	r3, [r7, #1660]	; 0x67c
  400714:	2300      	movs	r3, #0
  400716:	f8c7 3678 	str.w	r3, [r7, #1656]	; 0x678
	//erase the program space first
	for(i=0x424000ul;i< 0x440000ul;i+=0x4000)
  40071a:	4b3c      	ldr	r3, [pc, #240]	; (40080c <loadNewFirmware+0x218>)
  40071c:	f8c7 367c 	str.w	r3, [r7, #1660]	; 0x67c
  400720:	e016      	b.n	400750 <loadNewFirmware+0x15c>
	{
		resultTest = flash_erase_page(i,IFLASH_ERASE_PAGES_32);
  400722:	f8d7 067c 	ldr.w	r0, [r7, #1660]	; 0x67c
  400726:	2103      	movs	r1, #3
  400728:	4b3e      	ldr	r3, [pc, #248]	; (400824 <loadNewFirmware+0x230>)
  40072a:	4798      	blx	r3
  40072c:	4603      	mov	r3, r0
  40072e:	f8c7 3668 	str.w	r3, [r7, #1640]	; 0x668
		if(resultTest != 0)
  400732:	f8d7 3668 	ldr.w	r3, [r7, #1640]	; 0x668
  400736:	2b00      	cmp	r3, #0
  400738:	d004      	beq.n	400744 <loadNewFirmware+0x150>
		{
			error++;
  40073a:	f8d7 3678 	ldr.w	r3, [r7, #1656]	; 0x678
  40073e:	3301      	adds	r3, #1
  400740:	f8c7 3678 	str.w	r3, [r7, #1656]	; 0x678
	char buf[FIRMWARE_BUFFER_SIZE] = {0}; 	 
	char nullBuf[FIRMWARE_BUFFER_SIZE] = {0}; 		
		
	uint32_t i = 0, error = 0;
	//erase the program space first
	for(i=0x424000ul;i< 0x440000ul;i+=0x4000)
  400744:	f8d7 367c 	ldr.w	r3, [r7, #1660]	; 0x67c
  400748:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
  40074c:	f8c7 367c 	str.w	r3, [r7, #1660]	; 0x67c
  400750:	f8d7 367c 	ldr.w	r3, [r7, #1660]	; 0x67c
  400754:	f5b3 0f88 	cmp.w	r3, #4456448	; 0x440000
  400758:	d3e3      	bcc.n	400722 <loadNewFirmware+0x12e>
		if(resultTest != 0)
		{
			error++;
		}	
	}
	drv_gpio_setPinState(DRV_GPIO_PIN_RED_LED, DRV_GPIO_PIN_STATE_HIGH);
  40075a:	200e      	movs	r0, #14
  40075c:	2101      	movs	r1, #1
  40075e:	4b32      	ldr	r3, [pc, #200]	; (400828 <loadNewFirmware+0x234>)
  400760:	4798      	blx	r3
	drv_gpio_setPinState(DRV_GPIO_PIN_GREEN_LED, DRV_GPIO_PIN_STATE_HIGH);
  400762:	200c      	movs	r0, #12
  400764:	2101      	movs	r1, #1
  400766:	4b30      	ldr	r3, [pc, #192]	; (400828 <loadNewFirmware+0x234>)
  400768:	4798      	blx	r3
	drv_gpio_setPinState(DRV_GPIO_PIN_BLUE_LED, DRV_GPIO_PIN_STATE_HIGH);			
  40076a:	200d      	movs	r0, #13
  40076c:	2101      	movs	r1, #1
  40076e:	4b2e      	ldr	r3, [pc, #184]	; (400828 <loadNewFirmware+0x234>)
  400770:	4798      	blx	r3
	while(total_bytes_read < firmwareFileObj.fsize - sizeof(firmwareHeader_t) && res == FR_OK)
  400772:	e093      	b.n	40089c <loadNewFirmware+0x2a8>
	{
		res = f_read(&firmwareFileObj, buf, FIRMWARE_BUFFER_SIZE, &bytes_read);
  400774:	f207 433c 	addw	r3, r7, #1084	; 0x43c
  400778:	f507 720b 	add.w	r2, r7, #556	; 0x22c
  40077c:	f207 442c 	addw	r4, r7, #1068	; 0x42c
  400780:	4618      	mov	r0, r3
  400782:	4611      	mov	r1, r2
  400784:	f44f 7200 	mov.w	r2, #512	; 0x200
  400788:	4623      	mov	r3, r4
  40078a:	4c1d      	ldr	r4, [pc, #116]	; (400800 <loadNewFirmware+0x20c>)
  40078c:	47a0      	blx	r4
  40078e:	4603      	mov	r3, r0
  400790:	f887 3687 	strb.w	r3, [r7, #1671]	; 0x687
		if(bytes_read != 0)
  400794:	f207 432c 	addw	r3, r7, #1068	; 0x42c
  400798:	681b      	ldr	r3, [r3, #0]
  40079a:	2b00      	cmp	r3, #0
  40079c:	d016      	beq.n	4007cc <loadNewFirmware+0x1d8>
		{		
			if(flash_write(destAddress+total_bytes_read, (void*)buf,bytes_read,0) != 0)
  40079e:	f8d7 2670 	ldr.w	r2, [r7, #1648]	; 0x670
  4007a2:	f8d7 3680 	ldr.w	r3, [r7, #1664]	; 0x680
  4007a6:	441a      	add	r2, r3
  4007a8:	f207 432c 	addw	r3, r7, #1068	; 0x42c
  4007ac:	681c      	ldr	r4, [r3, #0]
  4007ae:	f507 730b 	add.w	r3, r7, #556	; 0x22c
  4007b2:	4610      	mov	r0, r2
  4007b4:	4619      	mov	r1, r3
  4007b6:	4622      	mov	r2, r4
  4007b8:	2300      	movs	r3, #0
  4007ba:	4c1c      	ldr	r4, [pc, #112]	; (40082c <loadNewFirmware+0x238>)
  4007bc:	47a0      	blx	r4
  4007be:	4603      	mov	r3, r0
  4007c0:	2b00      	cmp	r3, #0
  4007c2:	d003      	beq.n	4007cc <loadNewFirmware+0x1d8>
			{
				result = STATUS_FAIL;
  4007c4:	2301      	movs	r3, #1
  4007c6:	f887 3677 	strb.w	r3, [r7, #1655]	; 0x677
				break;
  4007ca:	e075      	b.n	4008b8 <loadNewFirmware+0x2c4>
			}
		}
		total_bytes_read += bytes_read; 
  4007cc:	f207 432c 	addw	r3, r7, #1068	; 0x42c
  4007d0:	681b      	ldr	r3, [r3, #0]
  4007d2:	f8d7 2680 	ldr.w	r2, [r7, #1664]	; 0x680
  4007d6:	4413      	add	r3, r2
  4007d8:	f8c7 3680 	str.w	r3, [r7, #1664]	; 0x680
		if(total_bytes_read ==  firmwareFileObj.fsize - sizeof(firmwareHeader_t))
  4007dc:	f207 433c 	addw	r3, r7, #1084	; 0x43c
  4007e0:	68db      	ldr	r3, [r3, #12]
  4007e2:	f1a3 020c 	sub.w	r2, r3, #12
  4007e6:	f8d7 3680 	ldr.w	r3, [r7, #1664]	; 0x680
  4007ea:	429a      	cmp	r2, r3
  4007ec:	d120      	bne.n	400830 <loadNewFirmware+0x23c>
		{
			break; //this is redundant
  4007ee:	e063      	b.n	4008b8 <loadNewFirmware+0x2c4>
  4007f0:	00406551 	.word	0x00406551
  4007f4:	400e1450 	.word	0x400e1450
  4007f8:	00405661 	.word	0x00405661
  4007fc:	004037e1 	.word	0x004037e1
  400800:	00403a85 	.word	0x00403a85
  400804:	aa55aa55 	.word	0xaa55aa55
  400808:	00403ced 	.word	0x00403ced
  40080c:	00424000 	.word	0x00424000
  400810:	0040038d 	.word	0x0040038d
  400814:	400e0a00 	.word	0x400e0a00
  400818:	5a012307 	.word	0x5a012307
  40081c:	2000006d 	.word	0x2000006d
  400820:	00400585 	.word	0x00400585
  400824:	004003a5 	.word	0x004003a5
  400828:	00404ca5 	.word	0x00404ca5
  40082c:	004003d5 	.word	0x004003d5
		}
		drv_gpio_togglePin(DRV_GPIO_PIN_GREEN_LED); 
  400830:	200c      	movs	r0, #12
  400832:	4bac      	ldr	r3, [pc, #688]	; (400ae4 <loadNewFirmware+0x4f0>)
  400834:	4798      	blx	r3
  400836:	4bac      	ldr	r3, [pc, #688]	; (400ae8 <loadNewFirmware+0x4f4>)
		delay_ms(100);
  400838:	4618      	mov	r0, r3
  40083a:	f04f 0100 	mov.w	r1, #0
  40083e:	4602      	mov	r2, r0
  400840:	460b      	mov	r3, r1
  400842:	1892      	adds	r2, r2, r2
  400844:	eb43 0303 	adc.w	r3, r3, r3
  400848:	1812      	adds	r2, r2, r0
  40084a:	eb43 0301 	adc.w	r3, r3, r1
  40084e:	015c      	lsls	r4, r3, #5
  400850:	61fc      	str	r4, [r7, #28]
  400852:	69fd      	ldr	r5, [r7, #28]
  400854:	ea45 65d2 	orr.w	r5, r5, r2, lsr #27
  400858:	61fd      	str	r5, [r7, #28]
  40085a:	ea4f 1c42 	mov.w	ip, r2, lsl #5
  40085e:	f8c7 c018 	str.w	ip, [r7, #24]
  400862:	e9d7 4506 	ldrd	r4, r5, [r7, #24]
  400866:	1912      	adds	r2, r2, r4
  400868:	eb43 0305 	adc.w	r3, r3, r5
  40086c:	1880      	adds	r0, r0, r2
  40086e:	eb41 0103 	adc.w	r1, r1, r3
  400872:	f243 62af 	movw	r2, #13999	; 0x36af
  400876:	f04f 0300 	mov.w	r3, #0
  40087a:	1812      	adds	r2, r2, r0
  40087c:	eb43 0301 	adc.w	r3, r3, r1
  400880:	4c9a      	ldr	r4, [pc, #616]	; (400aec <loadNewFirmware+0x4f8>)
  400882:	4610      	mov	r0, r2
  400884:	4619      	mov	r1, r3
  400886:	f243 62b0 	movw	r2, #14000	; 0x36b0
  40088a:	f04f 0300 	mov.w	r3, #0
  40088e:	47a0      	blx	r4
  400890:	4602      	mov	r2, r0
  400892:	460b      	mov	r3, r1
  400894:	4613      	mov	r3, r2
  400896:	4618      	mov	r0, r3
  400898:	4b95      	ldr	r3, [pc, #596]	; (400af0 <loadNewFirmware+0x4fc>)
  40089a:	4798      	blx	r3
		}	
	}
	drv_gpio_setPinState(DRV_GPIO_PIN_RED_LED, DRV_GPIO_PIN_STATE_HIGH);
	drv_gpio_setPinState(DRV_GPIO_PIN_GREEN_LED, DRV_GPIO_PIN_STATE_HIGH);
	drv_gpio_setPinState(DRV_GPIO_PIN_BLUE_LED, DRV_GPIO_PIN_STATE_HIGH);			
	while(total_bytes_read < firmwareFileObj.fsize - sizeof(firmwareHeader_t) && res == FR_OK)
  40089c:	f207 433c 	addw	r3, r7, #1084	; 0x43c
  4008a0:	68db      	ldr	r3, [r3, #12]
  4008a2:	f1a3 020c 	sub.w	r2, r3, #12
  4008a6:	f8d7 3680 	ldr.w	r3, [r7, #1664]	; 0x680
  4008aa:	429a      	cmp	r2, r3
  4008ac:	d904      	bls.n	4008b8 <loadNewFirmware+0x2c4>
  4008ae:	f897 3687 	ldrb.w	r3, [r7, #1671]	; 0x687
  4008b2:	2b00      	cmp	r3, #0
  4008b4:	f43f af5e 	beq.w	400774 <loadNewFirmware+0x180>
			break; //this is redundant
		}
		drv_gpio_togglePin(DRV_GPIO_PIN_GREEN_LED); 
		delay_ms(100);
	}
	drv_gpio_setPinState(DRV_GPIO_PIN_BLUE_LED, DRV_GPIO_PIN_STATE_LOW);
  4008b8:	200d      	movs	r0, #13
  4008ba:	2100      	movs	r1, #0
  4008bc:	4b8d      	ldr	r3, [pc, #564]	; (400af4 <loadNewFirmware+0x500>)
  4008be:	4798      	blx	r3
  4008c0:	4b89      	ldr	r3, [pc, #548]	; (400ae8 <loadNewFirmware+0x4f4>)
	delay_ms(100);
  4008c2:	4618      	mov	r0, r3
  4008c4:	f04f 0100 	mov.w	r1, #0
  4008c8:	4602      	mov	r2, r0
  4008ca:	460b      	mov	r3, r1
  4008cc:	1892      	adds	r2, r2, r2
  4008ce:	eb43 0303 	adc.w	r3, r3, r3
  4008d2:	1812      	adds	r2, r2, r0
  4008d4:	eb43 0301 	adc.w	r3, r3, r1
  4008d8:	015d      	lsls	r5, r3, #5
  4008da:	617d      	str	r5, [r7, #20]
  4008dc:	f8d7 c014 	ldr.w	ip, [r7, #20]
  4008e0:	ea4c 6cd2 	orr.w	ip, ip, r2, lsr #27
  4008e4:	f8c7 c014 	str.w	ip, [r7, #20]
  4008e8:	0154      	lsls	r4, r2, #5
  4008ea:	613c      	str	r4, [r7, #16]
  4008ec:	e9d7 4504 	ldrd	r4, r5, [r7, #16]
  4008f0:	1912      	adds	r2, r2, r4
  4008f2:	eb43 0305 	adc.w	r3, r3, r5
  4008f6:	1880      	adds	r0, r0, r2
  4008f8:	eb41 0103 	adc.w	r1, r1, r3
  4008fc:	f243 62af 	movw	r2, #13999	; 0x36af
  400900:	f04f 0300 	mov.w	r3, #0
  400904:	1812      	adds	r2, r2, r0
  400906:	eb43 0301 	adc.w	r3, r3, r1
  40090a:	4c78      	ldr	r4, [pc, #480]	; (400aec <loadNewFirmware+0x4f8>)
  40090c:	4610      	mov	r0, r2
  40090e:	4619      	mov	r1, r3
  400910:	f243 62b0 	movw	r2, #14000	; 0x36b0
  400914:	f04f 0300 	mov.w	r3, #0
  400918:	47a0      	blx	r4
  40091a:	4602      	mov	r2, r0
  40091c:	460b      	mov	r3, r1
  40091e:	4613      	mov	r3, r2
  400920:	4618      	mov	r0, r3
  400922:	4b73      	ldr	r3, [pc, #460]	; (400af0 <loadNewFirmware+0x4fc>)
  400924:	4798      	blx	r3
	drv_gpio_setPinState(DRV_GPIO_PIN_BLUE_LED, DRV_GPIO_PIN_STATE_HIGH);
  400926:	200d      	movs	r0, #13
  400928:	2101      	movs	r1, #1
  40092a:	4b72      	ldr	r3, [pc, #456]	; (400af4 <loadNewFirmware+0x500>)
  40092c:	4798      	blx	r3
  40092e:	4b6e      	ldr	r3, [pc, #440]	; (400ae8 <loadNewFirmware+0x4f4>)
	delay_ms(100);	
  400930:	4618      	mov	r0, r3
  400932:	f04f 0100 	mov.w	r1, #0
  400936:	4602      	mov	r2, r0
  400938:	460b      	mov	r3, r1
  40093a:	1892      	adds	r2, r2, r2
  40093c:	eb43 0303 	adc.w	r3, r3, r3
  400940:	1812      	adds	r2, r2, r0
  400942:	eb43 0301 	adc.w	r3, r3, r1
  400946:	015d      	lsls	r5, r3, #5
  400948:	60fd      	str	r5, [r7, #12]
  40094a:	f8d7 c00c 	ldr.w	ip, [r7, #12]
  40094e:	ea4c 6cd2 	orr.w	ip, ip, r2, lsr #27
  400952:	f8c7 c00c 	str.w	ip, [r7, #12]
  400956:	0154      	lsls	r4, r2, #5
  400958:	60bc      	str	r4, [r7, #8]
  40095a:	e9d7 4502 	ldrd	r4, r5, [r7, #8]
  40095e:	1912      	adds	r2, r2, r4
  400960:	eb43 0305 	adc.w	r3, r3, r5
  400964:	1880      	adds	r0, r0, r2
  400966:	eb41 0103 	adc.w	r1, r1, r3
  40096a:	f243 62af 	movw	r2, #13999	; 0x36af
  40096e:	f04f 0300 	mov.w	r3, #0
  400972:	1812      	adds	r2, r2, r0
  400974:	eb43 0301 	adc.w	r3, r3, r1
  400978:	4c5c      	ldr	r4, [pc, #368]	; (400aec <loadNewFirmware+0x4f8>)
  40097a:	4610      	mov	r0, r2
  40097c:	4619      	mov	r1, r3
  40097e:	f243 62b0 	movw	r2, #14000	; 0x36b0
  400982:	f04f 0300 	mov.w	r3, #0
  400986:	47a0      	blx	r4
  400988:	4602      	mov	r2, r0
  40098a:	460b      	mov	r3, r1
  40098c:	4613      	mov	r3, r2
  40098e:	4618      	mov	r0, r3
  400990:	4b57      	ldr	r3, [pc, #348]	; (400af0 <loadNewFirmware+0x4fc>)
  400992:	4798      	blx	r3
	for(i=0x408000ul;i< 0x424000ul;i+=0x2000)
  400994:	f44f 0381 	mov.w	r3, #4227072	; 0x408000
  400998:	f8c7 367c 	str.w	r3, [r7, #1660]	; 0x67c
  40099c:	e016      	b.n	4009cc <loadNewFirmware+0x3d8>
	{
		resultTest = flash_erase_page(i,IFLASH_ERASE_PAGES_16);
  40099e:	f8d7 067c 	ldr.w	r0, [r7, #1660]	; 0x67c
  4009a2:	2102      	movs	r1, #2
  4009a4:	4b54      	ldr	r3, [pc, #336]	; (400af8 <loadNewFirmware+0x504>)
  4009a6:	4798      	blx	r3
  4009a8:	4603      	mov	r3, r0
  4009aa:	f8c7 3668 	str.w	r3, [r7, #1640]	; 0x668
		if(resultTest != 0)
  4009ae:	f8d7 3668 	ldr.w	r3, [r7, #1640]	; 0x668
  4009b2:	2b00      	cmp	r3, #0
  4009b4:	d004      	beq.n	4009c0 <loadNewFirmware+0x3cc>
		{
			error++;
  4009b6:	f8d7 3678 	ldr.w	r3, [r7, #1656]	; 0x678
  4009ba:	3301      	adds	r3, #1
  4009bc:	f8c7 3678 	str.w	r3, [r7, #1656]	; 0x678
	}
	drv_gpio_setPinState(DRV_GPIO_PIN_BLUE_LED, DRV_GPIO_PIN_STATE_LOW);
	delay_ms(100);
	drv_gpio_setPinState(DRV_GPIO_PIN_BLUE_LED, DRV_GPIO_PIN_STATE_HIGH);
	delay_ms(100);	
	for(i=0x408000ul;i< 0x424000ul;i+=0x2000)
  4009c0:	f8d7 367c 	ldr.w	r3, [r7, #1660]	; 0x67c
  4009c4:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
  4009c8:	f8c7 367c 	str.w	r3, [r7, #1660]	; 0x67c
  4009cc:	f8d7 267c 	ldr.w	r2, [r7, #1660]	; 0x67c
  4009d0:	4b4a      	ldr	r3, [pc, #296]	; (400afc <loadNewFirmware+0x508>)
  4009d2:	429a      	cmp	r2, r3
  4009d4:	d9e3      	bls.n	40099e <loadNewFirmware+0x3aa>
		{
			error++;
		}
	}	
	//verify firmware
	drv_gpio_setPinState(DRV_GPIO_PIN_GREEN_LED, DRV_GPIO_PIN_STATE_HIGH);
  4009d6:	200c      	movs	r0, #12
  4009d8:	2101      	movs	r1, #1
  4009da:	4b46      	ldr	r3, [pc, #280]	; (400af4 <loadNewFirmware+0x500>)
  4009dc:	4798      	blx	r3
	drv_gpio_setPinState(DRV_GPIO_PIN_RED_LED, DRV_GPIO_PIN_STATE_LOW);
  4009de:	200e      	movs	r0, #14
  4009e0:	2100      	movs	r1, #0
  4009e2:	4b44      	ldr	r3, [pc, #272]	; (400af4 <loadNewFirmware+0x500>)
  4009e4:	4798      	blx	r3
  4009e6:	4b40      	ldr	r3, [pc, #256]	; (400ae8 <loadNewFirmware+0x4f4>)
	delay_ms(100);
  4009e8:	4618      	mov	r0, r3
  4009ea:	f04f 0100 	mov.w	r1, #0
  4009ee:	4602      	mov	r2, r0
  4009f0:	460b      	mov	r3, r1
  4009f2:	1892      	adds	r2, r2, r2
  4009f4:	eb43 0303 	adc.w	r3, r3, r3
  4009f8:	1812      	adds	r2, r2, r0
  4009fa:	eb43 0301 	adc.w	r3, r3, r1
  4009fe:	ea4f 1b43 	mov.w	fp, r3, lsl #5
  400a02:	ea4b 6bd2 	orr.w	fp, fp, r2, lsr #27
  400a06:	ea4f 1a42 	mov.w	sl, r2, lsl #5
  400a0a:	eb12 020a 	adds.w	r2, r2, sl
  400a0e:	eb43 030b 	adc.w	r3, r3, fp
  400a12:	1880      	adds	r0, r0, r2
  400a14:	eb41 0103 	adc.w	r1, r1, r3
  400a18:	f243 62af 	movw	r2, #13999	; 0x36af
  400a1c:	f04f 0300 	mov.w	r3, #0
  400a20:	1812      	adds	r2, r2, r0
  400a22:	eb43 0301 	adc.w	r3, r3, r1
  400a26:	4c31      	ldr	r4, [pc, #196]	; (400aec <loadNewFirmware+0x4f8>)
  400a28:	4610      	mov	r0, r2
  400a2a:	4619      	mov	r1, r3
  400a2c:	f243 62b0 	movw	r2, #14000	; 0x36b0
  400a30:	f04f 0300 	mov.w	r3, #0
  400a34:	47a0      	blx	r4
  400a36:	4602      	mov	r2, r0
  400a38:	460b      	mov	r3, r1
  400a3a:	4613      	mov	r3, r2
  400a3c:	4618      	mov	r0, r3
  400a3e:	4b2c      	ldr	r3, [pc, #176]	; (400af0 <loadNewFirmware+0x4fc>)
  400a40:	4798      	blx	r3
	drv_gpio_setPinState(DRV_GPIO_PIN_RED_LED, DRV_GPIO_PIN_STATE_HIGH);
  400a42:	200e      	movs	r0, #14
  400a44:	2101      	movs	r1, #1
  400a46:	4b2b      	ldr	r3, [pc, #172]	; (400af4 <loadNewFirmware+0x500>)
  400a48:	4798      	blx	r3
  400a4a:	4b27      	ldr	r3, [pc, #156]	; (400ae8 <loadNewFirmware+0x4f4>)
	delay_ms(100);
  400a4c:	4618      	mov	r0, r3
  400a4e:	f04f 0100 	mov.w	r1, #0
  400a52:	4602      	mov	r2, r0
  400a54:	460b      	mov	r3, r1
  400a56:	1892      	adds	r2, r2, r2
  400a58:	eb43 0303 	adc.w	r3, r3, r3
  400a5c:	1812      	adds	r2, r2, r0
  400a5e:	eb43 0301 	adc.w	r3, r3, r1
  400a62:	ea4f 1943 	mov.w	r9, r3, lsl #5
  400a66:	ea49 69d2 	orr.w	r9, r9, r2, lsr #27
  400a6a:	ea4f 1842 	mov.w	r8, r2, lsl #5
  400a6e:	eb12 0208 	adds.w	r2, r2, r8
  400a72:	eb43 0309 	adc.w	r3, r3, r9
  400a76:	1880      	adds	r0, r0, r2
  400a78:	eb41 0103 	adc.w	r1, r1, r3
  400a7c:	f243 62af 	movw	r2, #13999	; 0x36af
  400a80:	f04f 0300 	mov.w	r3, #0
  400a84:	1812      	adds	r2, r2, r0
  400a86:	eb43 0301 	adc.w	r3, r3, r1
  400a8a:	4c18      	ldr	r4, [pc, #96]	; (400aec <loadNewFirmware+0x4f8>)
  400a8c:	4610      	mov	r0, r2
  400a8e:	4619      	mov	r1, r3
  400a90:	f243 62b0 	movw	r2, #14000	; 0x36b0
  400a94:	f04f 0300 	mov.w	r3, #0
  400a98:	47a0      	blx	r4
  400a9a:	4602      	mov	r2, r0
  400a9c:	460b      	mov	r3, r1
  400a9e:	4613      	mov	r3, r2
  400aa0:	4618      	mov	r0, r3
  400aa2:	4b13      	ldr	r3, [pc, #76]	; (400af0 <loadNewFirmware+0x4fc>)
  400aa4:	4798      	blx	r3
	//TODO fix CRC problem. 
	//uint32_t ul_crc = compute_crc((uint8_t *)FIRMWARE_TEMPORARY_LOCATION, firmwareFileObj.fsize - sizeof(firmwareHeader_t),
	//CRCCU_MR_PTYPE_CASTAGNOLI);
	uint32_t ul_crc =0;
  400aa6:	2300      	movs	r3, #0
  400aa8:	f8c7 3664 	str.w	r3, [r7, #1636]	; 0x664
	fileCRC = ul_crc; 
  400aac:	4b14      	ldr	r3, [pc, #80]	; (400b00 <loadNewFirmware+0x50c>)
  400aae:	f8d7 2664 	ldr.w	r2, [r7, #1636]	; 0x664
  400ab2:	601a      	str	r2, [r3, #0]
	//if(header.crc == fileCRC)
	//{
		//CRC checks out, let copy the firmware to the final location
		total_bytes_read =0;
  400ab4:	2300      	movs	r3, #0
  400ab6:	f8c7 3680 	str.w	r3, [r7, #1664]	; 0x680
		destAddress = APP_START_ADDRESS;
  400aba:	f44f 0381 	mov.w	r3, #4227072	; 0x408000
  400abe:	f8c7 3670 	str.w	r3, [r7, #1648]	; 0x670
		retVal = flash_unlock(destAddress,destAddress + firmwareFileObj.fsize ,NULL,NULL);
  400ac2:	f207 433c 	addw	r3, r7, #1084	; 0x43c
  400ac6:	68da      	ldr	r2, [r3, #12]
  400ac8:	f8d7 3670 	ldr.w	r3, [r7, #1648]	; 0x670
  400acc:	4413      	add	r3, r2
  400ace:	f8d7 0670 	ldr.w	r0, [r7, #1648]	; 0x670
  400ad2:	4619      	mov	r1, r3
  400ad4:	2200      	movs	r2, #0
  400ad6:	2300      	movs	r3, #0
  400ad8:	4c0a      	ldr	r4, [pc, #40]	; (400b04 <loadNewFirmware+0x510>)
  400ada:	47a0      	blx	r4
  400adc:	f8c7 066c 	str.w	r0, [r7, #1644]	; 0x66c
		while(total_bytes_read < firmwareFileObj.fsize - sizeof(firmwareHeader_t))
  400ae0:	e074      	b.n	400bcc <loadNewFirmware+0x5d8>
  400ae2:	bf00      	nop
  400ae4:	00404d4d 	.word	0x00404d4d
  400ae8:	07270e00 	.word	0x07270e00
  400aec:	004058d9 	.word	0x004058d9
  400af0:	20000085 	.word	0x20000085
  400af4:	00404ca5 	.word	0x00404ca5
  400af8:	004003a5 	.word	0x004003a5
  400afc:	00423fff 	.word	0x00423fff
  400b00:	20000d38 	.word	0x20000d38
  400b04:	00400585 	.word	0x00400585
		{			
			memcpy(buf,FIRMWARE_TEMPORARY_LOCATION+total_bytes_read,FIRMWARE_BUFFER_SIZE); 			
  400b08:	f8d7 3680 	ldr.w	r3, [r7, #1664]	; 0x680
  400b0c:	f503 0384 	add.w	r3, r3, #4325376	; 0x420000
  400b10:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
  400b14:	f507 720b 	add.w	r2, r7, #556	; 0x22c
  400b18:	4611      	mov	r1, r2
  400b1a:	461a      	mov	r2, r3
  400b1c:	f44f 7300 	mov.w	r3, #512	; 0x200
  400b20:	4608      	mov	r0, r1
  400b22:	4611      	mov	r1, r2
  400b24:	461a      	mov	r2, r3
  400b26:	4b38      	ldr	r3, [pc, #224]	; (400c08 <loadNewFirmware+0x614>)
  400b28:	4798      	blx	r3
			if(flash_write(destAddress+total_bytes_read, (void*)buf,FIRMWARE_BUFFER_SIZE,0) != 0)
  400b2a:	f8d7 2670 	ldr.w	r2, [r7, #1648]	; 0x670
  400b2e:	f8d7 3680 	ldr.w	r3, [r7, #1664]	; 0x680
  400b32:	441a      	add	r2, r3
  400b34:	f507 730b 	add.w	r3, r7, #556	; 0x22c
  400b38:	4610      	mov	r0, r2
  400b3a:	4619      	mov	r1, r3
  400b3c:	f44f 7200 	mov.w	r2, #512	; 0x200
  400b40:	2300      	movs	r3, #0
  400b42:	4c32      	ldr	r4, [pc, #200]	; (400c0c <loadNewFirmware+0x618>)
  400b44:	47a0      	blx	r4
  400b46:	4603      	mov	r3, r0
  400b48:	2b00      	cmp	r3, #0
  400b4a:	d003      	beq.n	400b54 <loadNewFirmware+0x560>
			{
				result = STATUS_FAIL;
  400b4c:	2301      	movs	r3, #1
  400b4e:	f887 3677 	strb.w	r3, [r7, #1655]	; 0x677
				break;
  400b52:	e044      	b.n	400bde <loadNewFirmware+0x5ea>
			}
			total_bytes_read += FIRMWARE_BUFFER_SIZE; 
  400b54:	f8d7 3680 	ldr.w	r3, [r7, #1664]	; 0x680
  400b58:	f503 7300 	add.w	r3, r3, #512	; 0x200
  400b5c:	f8c7 3680 	str.w	r3, [r7, #1664]	; 0x680
			drv_gpio_togglePin(DRV_GPIO_PIN_BLUE_LED);
  400b60:	200d      	movs	r0, #13
  400b62:	4b2b      	ldr	r3, [pc, #172]	; (400c10 <loadNewFirmware+0x61c>)
  400b64:	4798      	blx	r3
  400b66:	4b2b      	ldr	r3, [pc, #172]	; (400c14 <loadNewFirmware+0x620>)
			delay_ms(100);
  400b68:	4618      	mov	r0, r3
  400b6a:	f04f 0100 	mov.w	r1, #0
  400b6e:	4602      	mov	r2, r0
  400b70:	460b      	mov	r3, r1
  400b72:	1892      	adds	r2, r2, r2
  400b74:	eb43 0303 	adc.w	r3, r3, r3
  400b78:	1812      	adds	r2, r2, r0
  400b7a:	eb43 0301 	adc.w	r3, r3, r1
  400b7e:	015d      	lsls	r5, r3, #5
  400b80:	607d      	str	r5, [r7, #4]
  400b82:	f8d7 c004 	ldr.w	ip, [r7, #4]
  400b86:	ea4c 6cd2 	orr.w	ip, ip, r2, lsr #27
  400b8a:	f8c7 c004 	str.w	ip, [r7, #4]
  400b8e:	0154      	lsls	r4, r2, #5
  400b90:	603c      	str	r4, [r7, #0]
  400b92:	e9d7 4500 	ldrd	r4, r5, [r7]
  400b96:	1912      	adds	r2, r2, r4
  400b98:	eb43 0305 	adc.w	r3, r3, r5
  400b9c:	1880      	adds	r0, r0, r2
  400b9e:	eb41 0103 	adc.w	r1, r1, r3
  400ba2:	f243 62af 	movw	r2, #13999	; 0x36af
  400ba6:	f04f 0300 	mov.w	r3, #0
  400baa:	1812      	adds	r2, r2, r0
  400bac:	eb43 0301 	adc.w	r3, r3, r1
  400bb0:	4c19      	ldr	r4, [pc, #100]	; (400c18 <loadNewFirmware+0x624>)
  400bb2:	4610      	mov	r0, r2
  400bb4:	4619      	mov	r1, r3
  400bb6:	f243 62b0 	movw	r2, #14000	; 0x36b0
  400bba:	f04f 0300 	mov.w	r3, #0
  400bbe:	47a0      	blx	r4
  400bc0:	4602      	mov	r2, r0
  400bc2:	460b      	mov	r3, r1
  400bc4:	4613      	mov	r3, r2
  400bc6:	4618      	mov	r0, r3
  400bc8:	4b14      	ldr	r3, [pc, #80]	; (400c1c <loadNewFirmware+0x628>)
  400bca:	4798      	blx	r3
	//{
		//CRC checks out, let copy the firmware to the final location
		total_bytes_read =0;
		destAddress = APP_START_ADDRESS;
		retVal = flash_unlock(destAddress,destAddress + firmwareFileObj.fsize ,NULL,NULL);
		while(total_bytes_read < firmwareFileObj.fsize - sizeof(firmwareHeader_t))
  400bcc:	f207 433c 	addw	r3, r7, #1084	; 0x43c
  400bd0:	68db      	ldr	r3, [r3, #12]
  400bd2:	f1a3 020c 	sub.w	r2, r3, #12
  400bd6:	f8d7 3680 	ldr.w	r3, [r7, #1664]	; 0x680
  400bda:	429a      	cmp	r2, r3
  400bdc:	d894      	bhi.n	400b08 <loadNewFirmware+0x514>
	//else
	//{
		//result = STATUS_FAIL; 
	//}
		//
	res = f_close(&firmwareFileObj);
  400bde:	f207 433c 	addw	r3, r7, #1084	; 0x43c
  400be2:	4618      	mov	r0, r3
  400be4:	4b0e      	ldr	r3, [pc, #56]	; (400c20 <loadNewFirmware+0x62c>)
  400be6:	4798      	blx	r3
  400be8:	4603      	mov	r3, r0
  400bea:	f887 3687 	strb.w	r3, [r7, #1671]	; 0x687
	if (res != FR_OK)
  400bee:	f897 3687 	ldrb.w	r3, [r7, #1671]	; 0x687
  400bf2:	2b00      	cmp	r3, #0
  400bf4:	d001      	beq.n	400bfa <loadNewFirmware+0x606>
	{
		return STATUS_FAIL;
  400bf6:	2301      	movs	r3, #1
  400bf8:	e000      	b.n	400bfc <loadNewFirmware+0x608>
	}
	return STATUS_PASS; 	
  400bfa:	2300      	movs	r3, #0
}
  400bfc:	4618      	mov	r0, r3
  400bfe:	f507 67d1 	add.w	r7, r7, #1672	; 0x688
  400c02:	46bd      	mov	sp, r7
  400c04:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
  400c08:	0040641d 	.word	0x0040641d
  400c0c:	004003d5 	.word	0x004003d5
  400c10:	00404d4d 	.word	0x00404d4d
  400c14:	07270e00 	.word	0x07270e00
  400c18:	004058d9 	.word	0x004058d9
  400c1c:	20000085 	.word	0x20000085
  400c20:	00403ced 	.word	0x00403ced

00400c24 <runBootloader>:
 * It will copy a executable to a temporary location, then load it into the main program space. 
 * The bootloader program is always loaded onto a release board at location 0x00000000 and executes the main
 * program. 
 */
void runBootloader()
{
  400c24:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	status_t status = STATUS_PASS; 
	drv_gpio_initializeAll();
  400c28:	4b6e      	ldr	r3, [pc, #440]	; (400de4 <runBootloader+0x1c0>)
	pmc_enable_periph_clk(ID_CRCCU);   		    
	board_init();	
	drv_gpio_pin_state_t sw1State = DRV_GPIO_PIN_STATE_HIGH, sw2State = DRV_GPIO_PIN_STATE_HIGH, lboState = DRV_GPIO_PIN_STATE_HIGH; 	
	//check pins for seeing if the bootloader should be entered. 
	uint32_t enterBootloader = 0;
	drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW1,&sw1State);
  400c2a:	4c6f      	ldr	r4, [pc, #444]	; (400de8 <runBootloader+0x1c4>)
	drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW2,&sw2State);
	drv_gpio_getPinState(DRV_GPIO_PIN_LBO, &lboState);	//Check for Low Battery
	int i = 0; 
	drv_gpio_setPinState(DRV_GPIO_PIN_GREEN_LED, DRV_GPIO_PIN_STATE_LOW);
  400c2c:	4f6f      	ldr	r7, [pc, #444]	; (400dec <runBootloader+0x1c8>)
 * It will copy a executable to a temporary location, then load it into the main program space. 
 * The bootloader program is always loaded onto a release board at location 0x00000000 and executes the main
 * program. 
 */
void runBootloader()
{
  400c2e:	b085      	sub	sp, #20
	status_t status = STATUS_PASS; 
	drv_gpio_initializeAll();
  400c30:	4798      	blx	r3
	pmc_enable_periph_clk(ID_CRCCU);   		    
  400c32:	4b6f      	ldr	r3, [pc, #444]	; (400df0 <runBootloader+0x1cc>)
  400c34:	2020      	movs	r0, #32
  400c36:	4798      	blx	r3
	board_init();	
  400c38:	4b6e      	ldr	r3, [pc, #440]	; (400df4 <runBootloader+0x1d0>)
  400c3a:	4798      	blx	r3
	drv_gpio_pin_state_t sw1State = DRV_GPIO_PIN_STATE_HIGH, sw2State = DRV_GPIO_PIN_STATE_HIGH, lboState = DRV_GPIO_PIN_STATE_HIGH; 	
  400c3c:	2301      	movs	r3, #1
	//check pins for seeing if the bootloader should be entered. 
	uint32_t enterBootloader = 0;
	drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW1,&sw1State);
  400c3e:	4618      	mov	r0, r3
  400c40:	a903      	add	r1, sp, #12
{
	status_t status = STATUS_PASS; 
	drv_gpio_initializeAll();
	pmc_enable_periph_clk(ID_CRCCU);   		    
	board_init();	
	drv_gpio_pin_state_t sw1State = DRV_GPIO_PIN_STATE_HIGH, sw2State = DRV_GPIO_PIN_STATE_HIGH, lboState = DRV_GPIO_PIN_STATE_HIGH; 	
  400c42:	f88d 300c 	strb.w	r3, [sp, #12]
  400c46:	f88d 300d 	strb.w	r3, [sp, #13]
  400c4a:	f88d 300e 	strb.w	r3, [sp, #14]
	//check pins for seeing if the bootloader should be entered. 
	uint32_t enterBootloader = 0;
	drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW1,&sw1State);
  400c4e:	47a0      	blx	r4
	drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW2,&sw2State);
  400c50:	f10d 010d 	add.w	r1, sp, #13
  400c54:	2002      	movs	r0, #2
  400c56:	47a0      	blx	r4
	drv_gpio_getPinState(DRV_GPIO_PIN_LBO, &lboState);	//Check for Low Battery
  400c58:	f10d 010e 	add.w	r1, sp, #14
  400c5c:	200f      	movs	r0, #15
  400c5e:	47a0      	blx	r4
	int i = 0; 
	drv_gpio_setPinState(DRV_GPIO_PIN_GREEN_LED, DRV_GPIO_PIN_STATE_LOW);
  400c60:	2100      	movs	r1, #0
  400c62:	200c      	movs	r0, #12
  400c64:	47b8      	blx	r7
	drv_gpio_setPinState(DRV_GPIO_PIN_BLUE_LED, DRV_GPIO_PIN_STATE_LOW); 
  400c66:	200d      	movs	r0, #13
  400c68:	2100      	movs	r1, #0
  400c6a:	47b8      	blx	r7
	if(sw1State == DRV_GPIO_PIN_STATE_LOW && sw2State == DRV_GPIO_PIN_STATE_LOW)
  400c6c:	f89d 300c 	ldrb.w	r3, [sp, #12]
  400c70:	2b00      	cmp	r3, #0
  400c72:	d143      	bne.n	400cfc <runBootloader+0xd8>
  400c74:	f89d 300d 	ldrb.w	r3, [sp, #13]
  400c78:	2b00      	cmp	r3, #0
  400c7a:	d13f      	bne.n	400cfc <runBootloader+0xd8>
	{
		if (lboState == DRV_GPIO_PIN_STATE_LOW)
  400c7c:	f89d 300e 	ldrb.w	r3, [sp, #14]
  400c80:	2b00      	cmp	r3, #0
  400c82:	d048      	beq.n	400d16 <runBootloader+0xf2>
  400c84:	4e5c      	ldr	r6, [pc, #368]	; (400df8 <runBootloader+0x1d4>)
  400c86:	250a      	movs	r5, #10
  400c88:	e00a      	b.n	400ca0 <runBootloader+0x7c>
			for(i=0;i<10;i++)
			{		
				enterBootloader = 1; //set the enter bootloader flag
				drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW1,&sw1State);
				drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW2,&sw2State);
				if(sw1State != DRV_GPIO_PIN_STATE_LOW || sw2State != DRV_GPIO_PIN_STATE_LOW)
  400c8a:	f89d 800d 	ldrb.w	r8, [sp, #13]
				{
					enterBootloader = 0; 
				}
				delay_ms(100); 			
  400c8e:	485b      	ldr	r0, [pc, #364]	; (400dfc <runBootloader+0x1d8>)
			for(i=0;i<10;i++)
			{		
				enterBootloader = 1; //set the enter bootloader flag
				drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW1,&sw1State);
				drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW2,&sw2State);
				if(sw1State != DRV_GPIO_PIN_STATE_LOW || sw2State != DRV_GPIO_PIN_STATE_LOW)
  400c90:	f1d8 0801 	rsbs	r8, r8, #1
  400c94:	bf38      	it	cc
  400c96:	f04f 0800 	movcc.w	r8, #0
				{
					enterBootloader = 0; 
				}
				delay_ms(100); 			
  400c9a:	47b0      	blx	r6
			enterBootloader = 0;
		}
		else
		{
			//make sure that both IO stay low for 1 second
			for(i=0;i<10;i++)
  400c9c:	3d01      	subs	r5, #1
  400c9e:	d010      	beq.n	400cc2 <runBootloader+0x9e>
			{		
				enterBootloader = 1; //set the enter bootloader flag
				drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW1,&sw1State);
  400ca0:	a903      	add	r1, sp, #12
  400ca2:	2001      	movs	r0, #1
  400ca4:	47a0      	blx	r4
				drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW2,&sw2State);
  400ca6:	2002      	movs	r0, #2
  400ca8:	f10d 010d 	add.w	r1, sp, #13
  400cac:	47a0      	blx	r4
				if(sw1State != DRV_GPIO_PIN_STATE_LOW || sw2State != DRV_GPIO_PIN_STATE_LOW)
  400cae:	f89d 300c 	ldrb.w	r3, [sp, #12]
  400cb2:	2b00      	cmp	r3, #0
  400cb4:	d0e9      	beq.n	400c8a <runBootloader+0x66>
				{
					enterBootloader = 0; 
				}
				delay_ms(100); 			
  400cb6:	4851      	ldr	r0, [pc, #324]	; (400dfc <runBootloader+0x1d8>)
  400cb8:	47b0      	blx	r6
			enterBootloader = 0;
		}
		else
		{
			//make sure that both IO stay low for 1 second
			for(i=0;i<10;i++)
  400cba:	3d01      	subs	r5, #1
				enterBootloader = 1; //set the enter bootloader flag
				drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW1,&sw1State);
				drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW2,&sw2State);
				if(sw1State != DRV_GPIO_PIN_STATE_LOW || sw2State != DRV_GPIO_PIN_STATE_LOW)
				{
					enterBootloader = 0; 
  400cbc:	f04f 0800 	mov.w	r8, #0
			enterBootloader = 0;
		}
		else
		{
			//make sure that both IO stay low for 1 second
			for(i=0;i<10;i++)
  400cc0:	d1ee      	bne.n	400ca0 <runBootloader+0x7c>
				}
				delay_ms(100); 			
			}		
		}
	}	
	if(enterBootloader == 1)
  400cc2:	f1b8 0f00 	cmp.w	r8, #0
  400cc6:	d019      	beq.n	400cfc <runBootloader+0xd8>
	{
		//if bootloader conditions met initialize SD card and load firmware	
		drv_gpio_pin_state_t sdCardCD = DRV_GPIO_PIN_STATE_LOW; 
  400cc8:	a904      	add	r1, sp, #16
		//Check if SD card is installed
		drv_gpio_getPinState(DRV_GPIO_PIN_SD_CD,&sdCardCD);
  400cca:	2010      	movs	r0, #16
		}
	}	
	if(enterBootloader == 1)
	{
		//if bootloader conditions met initialize SD card and load firmware	
		drv_gpio_pin_state_t sdCardCD = DRV_GPIO_PIN_STATE_LOW; 
  400ccc:	f801 5d01 	strb.w	r5, [r1, #-1]!
		//Check if SD card is installed
		drv_gpio_getPinState(DRV_GPIO_PIN_SD_CD,&sdCardCD);
  400cd0:	47a0      	blx	r4
		if(sdCardCD != DRV_GPIO_PIN_STATE_HIGH)
  400cd2:	f89d 300f 	ldrb.w	r3, [sp, #15]
  400cd6:	2b01      	cmp	r3, #1
  400cd8:	d020      	beq.n	400d1c <runBootloader+0xf8>
 * errorBlink()
 * @brief blink led red 5 times to indicate error
 */
static void errorBlink()
{
	drv_gpio_setPinState(DRV_GPIO_PIN_RED_LED, DRV_GPIO_PIN_STATE_HIGH); 
  400cda:	2101      	movs	r1, #1
  400cdc:	200e      	movs	r0, #14
  400cde:	47b8      	blx	r7
	drv_gpio_setPinState(DRV_GPIO_PIN_GREEN_LED, DRV_GPIO_PIN_STATE_HIGH); 
  400ce0:	2101      	movs	r1, #1
  400ce2:	200c      	movs	r0, #12
  400ce4:	47b8      	blx	r7
	drv_gpio_setPinState(DRV_GPIO_PIN_BLUE_LED, DRV_GPIO_PIN_STATE_HIGH); 
  400ce6:	200d      	movs	r0, #13
  400ce8:	2101      	movs	r1, #1
  400cea:	47b8      	blx	r7
  400cec:	4d44      	ldr	r5, [pc, #272]	; (400e00 <runBootloader+0x1dc>)
  400cee:	240a      	movs	r4, #10
	
	int i = 0;
	for(i=0; i<10; i++)
	{
		delay_ms(200); 
  400cf0:	4844      	ldr	r0, [pc, #272]	; (400e04 <runBootloader+0x1e0>)
  400cf2:	47b0      	blx	r6
		drv_gpio_togglePin(DRV_GPIO_PIN_RED_LED); 	
  400cf4:	200e      	movs	r0, #14
  400cf6:	47a8      	blx	r5
	drv_gpio_setPinState(DRV_GPIO_PIN_RED_LED, DRV_GPIO_PIN_STATE_HIGH); 
	drv_gpio_setPinState(DRV_GPIO_PIN_GREEN_LED, DRV_GPIO_PIN_STATE_HIGH); 
	drv_gpio_setPinState(DRV_GPIO_PIN_BLUE_LED, DRV_GPIO_PIN_STATE_HIGH); 
	
	int i = 0;
	for(i=0; i<10; i++)
  400cf8:	3c01      	subs	r4, #1
  400cfa:	d1f9      	bne.n	400cf0 <runBootloader+0xcc>
 */
static void start_application(void)
{
	uint32_t app_start_address;
	/* Rebase the Stack Pointer */
	__set_MSP(*(uint32_t *) APP_START_ADDRESS);
  400cfc:	f44f 0381 	mov.w	r3, #4227072	; 0x408000

    \param [in]    topOfMainStack  Main Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
{
  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
  400d00:	681a      	ldr	r2, [r3, #0]
  400d02:	f382 8808 	msr	MSP, r2
	/* Rebase the vector table base address */
	SCB->VTOR = ((uint32_t) APP_START_ADDRESS & SCB_VTOR_TBLOFF_Msk);
  400d06:	4940      	ldr	r1, [pc, #256]	; (400e08 <runBootloader+0x1e4>)
	/* Load the Reset Handler address of the application */
	app_start_address = *(uint32_t *)(APP_START_ADDRESS+4); 
  400d08:	4a40      	ldr	r2, [pc, #256]	; (400e0c <runBootloader+0x1e8>)
{
	uint32_t app_start_address;
	/* Rebase the Stack Pointer */
	__set_MSP(*(uint32_t *) APP_START_ADDRESS);
	/* Rebase the vector table base address */
	SCB->VTOR = ((uint32_t) APP_START_ADDRESS & SCB_VTOR_TBLOFF_Msk);
  400d0a:	608b      	str	r3, [r1, #8]
	/* Load the Reset Handler address of the application */
	app_start_address = *(uint32_t *)(APP_START_ADDRESS+4); 
	/* Jump to application Reset Handler in the application */
	asm("bx %0"::"r"(app_start_address));
  400d0c:	6813      	ldr	r3, [r2, #0]
  400d0e:	4718      	bx	r3
		//unmount the drive
		//f_mount(LUN_ID_SD_MMC_0_MEM, NULL);		
	} 	   
	start_application();
	
}
  400d10:	b005      	add	sp, #20
  400d12:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if(sw1State == DRV_GPIO_PIN_STATE_LOW && sw2State == DRV_GPIO_PIN_STATE_LOW)
	{
		if (lboState == DRV_GPIO_PIN_STATE_LOW)
		{
			//battery is low, don't run bootloader
			lowBatteryBlink();
  400d16:	4b3e      	ldr	r3, [pc, #248]	; (400e10 <runBootloader+0x1ec>)
  400d18:	4798      	blx	r3
  400d1a:	e7ef      	b.n	400cfc <runBootloader+0xd8>
static status_t initializeSDCard()
{
	static FRESULT res;
	status_t status = STATUS_PASS; 
	////Initialize SD card
	sd_mmc_init();
  400d1c:	4b3d      	ldr	r3, [pc, #244]	; (400e14 <runBootloader+0x1f0>)
  400d1e:	f8df a110 	ldr.w	sl, [pc, #272]	; 400e30 <runBootloader+0x20c>
  400d22:	f8df 9110 	ldr.w	r9, [pc, #272]	; 400e34 <runBootloader+0x210>
  400d26:	f8df 8110 	ldr.w	r8, [pc, #272]	; 400e38 <runBootloader+0x214>
  400d2a:	4798      	blx	r3
	//
	///* Wait card present and ready */
	//
	////we don't want the firmware to freeze if we don't have an SD card.
	int maxAttemptCount = 500; 
  400d2c:	f44f 74fa 	mov.w	r4, #500	; 0x1f4
  400d30:	e008      	b.n	400d44 <runBootloader+0x120>
					break; 
				}
			}
		}
		maxAttemptCount--;
		if(maxAttemptCount == 0)
  400d32:	3c01      	subs	r4, #1
  400d34:	d049      	beq.n	400dca <runBootloader+0x1a6>
		{
			status = STATUS_FAIL;
			break;
		}
		delay_ms(10);
  400d36:	4838      	ldr	r0, [pc, #224]	; (400e18 <runBootloader+0x1f4>)
		
		
	} while (CTRL_GOOD != res);
  400d38:	f8df b0f8 	ldr.w	fp, [pc, #248]	; 400e34 <runBootloader+0x210>
		if(maxAttemptCount == 0)
		{
			status = STATUS_FAIL;
			break;
		}
		delay_ms(10);
  400d3c:	47b0      	blx	r6
		
		
	} while (CTRL_GOOD != res);
  400d3e:	f899 3000 	ldrb.w	r3, [r9]
  400d42:	b17b      	cbz	r3, 400d64 <runBootloader+0x140>
	//
	////we don't want the firmware to freeze if we don't have an SD card.
	int maxAttemptCount = 500; 
	do
	{
		res = sd_mmc_test_unit_ready(0);
  400d44:	2000      	movs	r0, #0
  400d46:	47d0      	blx	sl
		if (res == CTRL_FAIL)
  400d48:	2801      	cmp	r0, #1
	//
	////we don't want the firmware to freeze if we don't have an SD card.
	int maxAttemptCount = 500; 
	do
	{
		res = sd_mmc_test_unit_ready(0);
  400d4a:	f889 0000 	strb.w	r0, [r9]
		if (res == CTRL_FAIL)
  400d4e:	d1f0      	bne.n	400d32 <runBootloader+0x10e>
		{
			while (CTRL_NO_PRESENT != sd_mmc_check(0))
  400d50:	2000      	movs	r0, #0
  400d52:	47c0      	blx	r8
  400d54:	2802      	cmp	r0, #2
  400d56:	d0ec      	beq.n	400d32 <runBootloader+0x10e>
			{
				maxAttemptCount--; 
				if(maxAttemptCount == 0)
  400d58:	3c01      	subs	r4, #1
  400d5a:	d1f9      	bne.n	400d50 <runBootloader+0x12c>
				{
					status = STATUS_FAIL;
  400d5c:	2501      	movs	r5, #1
					break; 
				}
			}
		}
		maxAttemptCount--;
  400d5e:	f04f 34ff 	mov.w	r4, #4294967295
  400d62:	e7e8      	b.n	400d36 <runBootloader+0x112>
		
	} while (CTRL_GOOD != res);
		
		
	/*	Mount the SD card	*/
	memset(&fs, 0, sizeof(FATFS));
  400d64:	4619      	mov	r1, r3
  400d66:	f44f 720c 	mov.w	r2, #560	; 0x230
  400d6a:	9301      	str	r3, [sp, #4]
  400d6c:	482b      	ldr	r0, [pc, #172]	; (400e1c <runBootloader+0x1f8>)
  400d6e:	4c2c      	ldr	r4, [pc, #176]	; (400e20 <runBootloader+0x1fc>)
  400d70:	47a0      	blx	r4
	res = f_mount(LUN_ID_SD_MMC_0_MEM, &fs);
  400d72:	9b01      	ldr	r3, [sp, #4]
  400d74:	4929      	ldr	r1, [pc, #164]	; (400e1c <runBootloader+0x1f8>)
  400d76:	4618      	mov	r0, r3
  400d78:	4b2a      	ldr	r3, [pc, #168]	; (400e24 <runBootloader+0x200>)
  400d7a:	4798      	blx	r3
	if (res == FR_INVALID_DRIVE)
  400d7c:	280b      	cmp	r0, #11
	} while (CTRL_GOOD != res);
		
		
	/*	Mount the SD card	*/
	memset(&fs, 0, sizeof(FATFS));
	res = f_mount(LUN_ID_SD_MMC_0_MEM, &fs);
  400d7e:	f88b 0000 	strb.w	r0, [fp]
	if (res == FR_INVALID_DRIVE)
  400d82:	d0aa      	beq.n	400cda <runBootloader+0xb6>
		if(status == STATUS_PASS)
		{
			status = initializeSDCard(); 	
		}
		//load the new firmware only if the card was initialized. 		
		if(status == STATUS_PASS)
  400d84:	2d00      	cmp	r5, #0
  400d86:	d1a8      	bne.n	400cda <runBootloader+0xb6>
		{		
			//set the LED to purple during the firmware load
			drv_gpio_setPinState(DRV_GPIO_PIN_GREEN_LED, DRV_GPIO_PIN_STATE_HIGH);
  400d88:	2101      	movs	r1, #1
  400d8a:	200c      	movs	r0, #12
  400d8c:	47b8      	blx	r7
			drv_gpio_setPinState(DRV_GPIO_PIN_BLUE_LED, DRV_GPIO_PIN_STATE_LOW); 
  400d8e:	4629      	mov	r1, r5
  400d90:	200d      	movs	r0, #13
  400d92:	47b8      	blx	r7
			drv_gpio_setPinState(DRV_GPIO_PIN_RED_LED, DRV_GPIO_PIN_STATE_LOW); 
  400d94:	4629      	mov	r1, r5
  400d96:	200e      	movs	r0, #14
  400d98:	47b8      	blx	r7
			status = loadNewFirmware(FIRMWARE_IMAGE_NAME);						
  400d9a:	4823      	ldr	r0, [pc, #140]	; (400e28 <runBootloader+0x204>)
  400d9c:	4b23      	ldr	r3, [pc, #140]	; (400e2c <runBootloader+0x208>)
		}
		//load the new firmware only if the card was initialized. 		
		if(status == STATUS_PASS)
		{		
			//set the LED to purple during the firmware load
			drv_gpio_setPinState(DRV_GPIO_PIN_GREEN_LED, DRV_GPIO_PIN_STATE_HIGH);
  400d9e:	4c13      	ldr	r4, [pc, #76]	; (400dec <runBootloader+0x1c8>)
			drv_gpio_setPinState(DRV_GPIO_PIN_BLUE_LED, DRV_GPIO_PIN_STATE_LOW); 
			drv_gpio_setPinState(DRV_GPIO_PIN_RED_LED, DRV_GPIO_PIN_STATE_LOW); 
			status = loadNewFirmware(FIRMWARE_IMAGE_NAME);						
  400da0:	4798      	blx	r3
		}
		if(status != STATUS_PASS)
  400da2:	2800      	cmp	r0, #0
  400da4:	d199      	bne.n	400cda <runBootloader+0xb6>
 * successBlink()
 * @brief blink led green 3 times if successful
 */
static void successBlink()
{
	drv_gpio_setPinState(DRV_GPIO_PIN_RED_LED, DRV_GPIO_PIN_STATE_HIGH); 
  400da6:	2101      	movs	r1, #1
  400da8:	200e      	movs	r0, #14
  400daa:	47a0      	blx	r4
	drv_gpio_setPinState(DRV_GPIO_PIN_GREEN_LED, DRV_GPIO_PIN_STATE_HIGH); 
  400dac:	2101      	movs	r1, #1
  400dae:	200c      	movs	r0, #12
  400db0:	47a0      	blx	r4
  400db2:	4d13      	ldr	r5, [pc, #76]	; (400e00 <runBootloader+0x1dc>)
	drv_gpio_setPinState(DRV_GPIO_PIN_BLUE_LED, DRV_GPIO_PIN_STATE_HIGH); 
  400db4:	200d      	movs	r0, #13
  400db6:	2101      	movs	r1, #1
  400db8:	47a0      	blx	r4
  400dba:	2406      	movs	r4, #6
	
	int i = 0;
	for(i=0; i<6; i++)
	{
		delay_ms(200); 
  400dbc:	4811      	ldr	r0, [pc, #68]	; (400e04 <runBootloader+0x1e0>)
  400dbe:	47b0      	blx	r6
		drv_gpio_togglePin(DRV_GPIO_PIN_GREEN_LED); 	
  400dc0:	200c      	movs	r0, #12
  400dc2:	47a8      	blx	r5
	drv_gpio_setPinState(DRV_GPIO_PIN_RED_LED, DRV_GPIO_PIN_STATE_HIGH); 
	drv_gpio_setPinState(DRV_GPIO_PIN_GREEN_LED, DRV_GPIO_PIN_STATE_HIGH); 
	drv_gpio_setPinState(DRV_GPIO_PIN_BLUE_LED, DRV_GPIO_PIN_STATE_HIGH); 
	
	int i = 0;
	for(i=0; i<6; i++)
  400dc4:	3c01      	subs	r4, #1
  400dc6:	d1f9      	bne.n	400dbc <runBootloader+0x198>
  400dc8:	e798      	b.n	400cfc <runBootloader+0xd8>
		
	} while (CTRL_GOOD != res);
		
		
	/*	Mount the SD card	*/
	memset(&fs, 0, sizeof(FATFS));
  400dca:	4b15      	ldr	r3, [pc, #84]	; (400e20 <runBootloader+0x1fc>)
  400dcc:	4813      	ldr	r0, [pc, #76]	; (400e1c <runBootloader+0x1f8>)
  400dce:	4621      	mov	r1, r4
  400dd0:	f44f 720c 	mov.w	r2, #560	; 0x230
  400dd4:	4798      	blx	r3
	res = f_mount(LUN_ID_SD_MMC_0_MEM, &fs);
  400dd6:	4620      	mov	r0, r4
  400dd8:	4910      	ldr	r1, [pc, #64]	; (400e1c <runBootloader+0x1f8>)
  400dda:	4b12      	ldr	r3, [pc, #72]	; (400e24 <runBootloader+0x200>)
  400ddc:	4798      	blx	r3
  400dde:	f889 0000 	strb.w	r0, [r9]
  400de2:	e77a      	b.n	400cda <runBootloader+0xb6>
  400de4:	00404c69 	.word	0x00404c69
  400de8:	00404d1d 	.word	0x00404d1d
  400dec:	00404ca5 	.word	0x00404ca5
  400df0:	0040561d 	.word	0x0040561d
  400df4:	0040510d 	.word	0x0040510d
  400df8:	20000085 	.word	0x20000085
  400dfc:	000d1437 	.word	0x000d1437
  400e00:	00404d4d 	.word	0x00404d4d
  400e04:	001a286e 	.word	0x001a286e
  400e08:	e000ed00 	.word	0xe000ed00
  400e0c:	00408004 	.word	0x00408004
  400e10:	00400f79 	.word	0x00400f79
  400e14:	004010d9 	.word	0x004010d9
  400e18:	00014ed3 	.word	0x00014ed3
  400e1c:	20001190 	.word	0x20001190
  400e20:	00406551 	.word	0x00406551
  400e24:	004037a1 	.word	0x004037a1
  400e28:	00406a24 	.word	0x00406a24
  400e2c:	004005f5 	.word	0x004005f5
  400e30:	00401a81 	.word	0x00401a81
  400e34:	20000d3c 	.word	0x20000d3c
  400e38:	004010f9 	.word	0x004010f9

00400e3c <debugPrintString>:
		task_debugLogWriteEntry(timeStampedStr, length);
	}
}

void __attribute__((optimize("O0"))) debugPrintString(char* str)
{
  400e3c:	b580      	push	{r7, lr}
  400e3e:	b0b6      	sub	sp, #216	; 0xd8
  400e40:	af00      	add	r7, sp, #0
  400e42:	6078      	str	r0, [r7, #4]
	size_t length = 0;
  400e44:	2300      	movs	r3, #0
  400e46:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
	char timeStampedStr[MAX_DEBUG_STRING_LENGTH];
	int len = itoa(sgSysTickCount, timeStampedStr, 10);
  400e4a:	4b27      	ldr	r3, [pc, #156]	; (400ee8 <debugPrintString+0xac>)
  400e4c:	681b      	ldr	r3, [r3, #0]
  400e4e:	461a      	mov	r2, r3
  400e50:	f107 0308 	add.w	r3, r7, #8
  400e54:	4610      	mov	r0, r2
  400e56:	4619      	mov	r1, r3
  400e58:	220a      	movs	r2, #10
  400e5a:	4b24      	ldr	r3, [pc, #144]	; (400eec <debugPrintString+0xb0>)
  400e5c:	4798      	blx	r3
  400e5e:	f8c7 00d0 	str.w	r0, [r7, #208]	; 0xd0
	timeStampedStr[len++] = ',';
  400e62:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
  400e66:	1c5a      	adds	r2, r3, #1
  400e68:	f8c7 20d0 	str.w	r2, [r7, #208]	; 0xd0
  400e6c:	f107 02d8 	add.w	r2, r7, #216	; 0xd8
  400e70:	4413      	add	r3, r2
  400e72:	222c      	movs	r2, #44	; 0x2c
  400e74:	f803 2cd0 	strb.w	r2, [r3, #-208]
	strncpy(timeStampedStr+len, str, MAX_DEBUG_STRING_LENGTH-len);	
  400e78:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
  400e7c:	f107 0208 	add.w	r2, r7, #8
  400e80:	441a      	add	r2, r3
  400e82:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
  400e86:	f1c3 03c8 	rsb	r3, r3, #200	; 0xc8
  400e8a:	4610      	mov	r0, r2
  400e8c:	6879      	ldr	r1, [r7, #4]
  400e8e:	461a      	mov	r2, r3
  400e90:	4b17      	ldr	r3, [pc, #92]	; (400ef0 <debugPrintString+0xb4>)
  400e92:	4798      	blx	r3
	length = strlen(timeStampedStr); 
  400e94:	f107 0308 	add.w	r3, r7, #8
  400e98:	4618      	mov	r0, r3
  400e9a:	4b16      	ldr	r3, [pc, #88]	; (400ef4 <debugPrintString+0xb8>)
  400e9c:	4798      	blx	r3
  400e9e:	f8c7 00d4 	str.w	r0, [r7, #212]	; 0xd4
	if(length > 0)
  400ea2:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
  400ea6:	2b00      	cmp	r3, #0
  400ea8:	d01a      	beq.n	400ee0 <debugPrintString+0xa4>
	{
		if(brainSettings.debugPrintsEnabled)
  400eaa:	4b13      	ldr	r3, [pc, #76]	; (400ef8 <debugPrintString+0xbc>)
  400eac:	f893 309f 	ldrb.w	r3, [r3, #159]	; 0x9f
  400eb0:	2b00      	cmp	r3, #0
  400eb2:	d00e      	beq.n	400ed2 <debugPrintString+0x96>
		{
			if(config != NULL)
  400eb4:	4b11      	ldr	r3, [pc, #68]	; (400efc <debugPrintString+0xc0>)
  400eb6:	681b      	ldr	r3, [r3, #0]
  400eb8:	2b00      	cmp	r3, #0
  400eba:	d00a      	beq.n	400ed2 <debugPrintString+0x96>
			{
				drv_uart_putData((config->uart), timeStampedStr, length);
  400ebc:	4b0f      	ldr	r3, [pc, #60]	; (400efc <debugPrintString+0xc0>)
  400ebe:	681b      	ldr	r3, [r3, #0]
  400ec0:	681a      	ldr	r2, [r3, #0]
  400ec2:	f107 0308 	add.w	r3, r7, #8
  400ec6:	4610      	mov	r0, r2
  400ec8:	4619      	mov	r1, r3
  400eca:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
  400ece:	4b0c      	ldr	r3, [pc, #48]	; (400f00 <debugPrintString+0xc4>)
  400ed0:	4798      	blx	r3
			}
		}
		task_debugLogWriteEntry(timeStampedStr, length);
  400ed2:	f107 0308 	add.w	r3, r7, #8
  400ed6:	4618      	mov	r0, r3
  400ed8:	f8d7 10d4 	ldr.w	r1, [r7, #212]	; 0xd4
  400edc:	4b09      	ldr	r3, [pc, #36]	; (400f04 <debugPrintString+0xc8>)
  400ede:	4798      	blx	r3
	}
}
  400ee0:	37d8      	adds	r7, #216	; 0xd8
  400ee2:	46bd      	mov	sp, r7
  400ee4:	bd80      	pop	{r7, pc}
  400ee6:	bf00      	nop
  400ee8:	20001158 	.word	0x20001158
  400eec:	00404889 	.word	0x00404889
  400ef0:	00406671 	.word	0x00406671
  400ef4:	00406611 	.word	0x00406611
  400ef8:	200000c0 	.word	0x200000c0
  400efc:	20000d40 	.word	0x20000d40
  400f00:	00404f41 	.word	0x00404f41
  400f04:	00400f09 	.word	0x00400f09

00400f08 <task_debugLogWriteEntry>:

	return status; 
}

status_t task_debugLogWriteEntry(char* entry, size_t length)
{
  400f08:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	status_t status = STATUS_PASS;
	//take the semaphore
	if(semaphore_sdCardWrite == NULL)
  400f0a:	4c15      	ldr	r4, [pc, #84]	; (400f60 <task_debugLogWriteEntry+0x58>)
  400f0c:	6823      	ldr	r3, [r4, #0]

	return status; 
}

status_t task_debugLogWriteEntry(char* entry, size_t length)
{
  400f0e:	4607      	mov	r7, r0
  400f10:	460e      	mov	r6, r1
	status_t status = STATUS_PASS;
	//take the semaphore
	if(semaphore_sdCardWrite == NULL)
  400f12:	b13b      	cbz	r3, 400f24 <task_debugLogWriteEntry+0x1c>
	{
		return STATUS_FAIL; 
	}	
	if(xSemaphoreTake(semaphore_sdCardWrite,5) == true)
  400f14:	2100      	movs	r1, #0
  400f16:	4618      	mov	r0, r3
  400f18:	2205      	movs	r2, #5
  400f1a:	460b      	mov	r3, r1
  400f1c:	4d11      	ldr	r5, [pc, #68]	; (400f64 <task_debugLogWriteEntry+0x5c>)
  400f1e:	47a8      	blx	r5
  400f20:	2801      	cmp	r0, #1
  400f22:	d001      	beq.n	400f28 <task_debugLogWriteEntry+0x20>
{
	status_t status = STATUS_PASS;
	//take the semaphore
	if(semaphore_sdCardWrite == NULL)
	{
		return STATUS_FAIL; 
  400f24:	2001      	movs	r0, #1
  400f26:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	}	
	if(xSemaphoreTake(semaphore_sdCardWrite,5) == true)
	{
		//copy data to sdCard buffer, make sure we have room first
		if(debugLogBufferPointer + length < DEBUG_LOG_BUFFER_SIZE)
  400f28:	4d0f      	ldr	r5, [pc, #60]	; (400f68 <task_debugLogWriteEntry+0x60>)
  400f2a:	682a      	ldr	r2, [r5, #0]
  400f2c:	4432      	add	r2, r6
  400f2e:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
  400f32:	d308      	bcc.n	400f46 <task_debugLogWriteEntry+0x3e>
			memcpy(debugLogBuffer+debugLogBufferPointer,entry,length);
			debugLogBufferPointer += length;
		}
		else
		{
			status = STATUS_FAIL;
  400f34:	4605      	mov	r5, r0
		}
		xSemaphoreGive(semaphore_sdCardWrite);
  400f36:	2100      	movs	r1, #0
  400f38:	6820      	ldr	r0, [r4, #0]
  400f3a:	4c0c      	ldr	r4, [pc, #48]	; (400f6c <task_debugLogWriteEntry+0x64>)
  400f3c:	460a      	mov	r2, r1
  400f3e:	460b      	mov	r3, r1
  400f40:	47a0      	blx	r4
  400f42:	4628      	mov	r0, r5
	{
		status = STATUS_FAIL;
	}	
	return status;
	
}
  400f44:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if(xSemaphoreTake(semaphore_sdCardWrite,5) == true)
	{
		//copy data to sdCard buffer, make sure we have room first
		if(debugLogBufferPointer + length < DEBUG_LOG_BUFFER_SIZE)
		{
			memcpy(debugLogBuffer+debugLogBufferPointer,entry,length);
  400f46:	682a      	ldr	r2, [r5, #0]
  400f48:	4809      	ldr	r0, [pc, #36]	; (400f70 <task_debugLogWriteEntry+0x68>)
  400f4a:	4b0a      	ldr	r3, [pc, #40]	; (400f74 <task_debugLogWriteEntry+0x6c>)
  400f4c:	4410      	add	r0, r2
  400f4e:	4639      	mov	r1, r7
  400f50:	4632      	mov	r2, r6
  400f52:	4798      	blx	r3
			debugLogBufferPointer += length;
  400f54:	682b      	ldr	r3, [r5, #0]
  400f56:	441e      	add	r6, r3
  400f58:	602e      	str	r6, [r5, #0]
	return status; 
}

status_t task_debugLogWriteEntry(char* entry, size_t length)
{
	status_t status = STATUS_PASS;
  400f5a:	2500      	movs	r5, #0
  400f5c:	e7eb      	b.n	400f36 <task_debugLogWriteEntry+0x2e>
  400f5e:	bf00      	nop
  400f60:	20000d44 	.word	0x20000d44
  400f64:	0040419d 	.word	0x0040419d
  400f68:	20000f48 	.word	0x20000f48
  400f6c:	00404031 	.word	0x00404031
  400f70:	20000d48 	.word	0x20000d48
  400f74:	0040641d 	.word	0x0040641d

00400f78 <lowBatteryBlink>:
 * @brief Blink the LED to indicate low battery 
 * @param void
 * @return void
 ***********************************************************************************************/
void lowBatteryBlink()
{
  400f78:	4770      	bx	lr
  400f7a:	bf00      	nop

00400f7c <sd_mmc_configure_slot>:

/**
 * \brief Configures the driver with the selected card configuration
 */
static void sd_mmc_configure_slot(void)
{
  400f7c:	b510      	push	{r4, lr}
	driver_select_device(sd_mmc_slot_sel, sd_mmc_card->clock,
  400f7e:	4a07      	ldr	r2, [pc, #28]	; (400f9c <sd_mmc_configure_slot+0x20>)
  400f80:	4b07      	ldr	r3, [pc, #28]	; (400fa0 <sd_mmc_configure_slot+0x24>)
  400f82:	6812      	ldr	r2, [r2, #0]
  400f84:	7818      	ldrb	r0, [r3, #0]
  400f86:	f892 3022 	ldrb.w	r3, [r2, #34]	; 0x22
  400f8a:	6811      	ldr	r1, [r2, #0]
  400f8c:	4c05      	ldr	r4, [pc, #20]	; (400fa4 <sd_mmc_configure_slot+0x28>)
  400f8e:	7c52      	ldrb	r2, [r2, #17]
  400f90:	3300      	adds	r3, #0
  400f92:	bf18      	it	ne
  400f94:	2301      	movne	r3, #1
  400f96:	47a0      	blx	r4
  400f98:	bd10      	pop	{r4, pc}
  400f9a:	bf00      	nop
  400f9c:	20000f50 	.word	0x20000f50
  400fa0:	20000f56 	.word	0x20000f56
  400fa4:	00401df1 	.word	0x00401df1

00400fa8 <sd_mmc_select_slot.part.0>:
 * \retval SD_MMC_ERR_NO_CARD  No card present on slot
 * \retval SD_MMC_ERR_UNUSABLE Unusable card
 * \retval SD_MMC_INIT_ONGOING Card initialization requested
 * \retval SD_MMC_OK           Card present
 */
static sd_mmc_err_t sd_mmc_select_slot(uint8_t slot)
  400fa8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	}
	Assert(sd_mmc_nb_block_remaining == 0);

#if (defined SD_MMC_0_CD_GPIO)
	//! Card Detect pins
	if (ioport_get_pin_level(sd_mmc_cards[slot].cd_gpio)
  400faa:	00c5      	lsls	r5, r0, #3
  400fac:	4c34      	ldr	r4, [pc, #208]	; (401080 <sd_mmc_select_slot.part.0+0xd8>)
  400fae:	1829      	adds	r1, r5, r0
  400fb0:	eb04 0181 	add.w	r1, r4, r1, lsl #2
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
  400fb4:	2601      	movs	r6, #1
  400fb6:	688a      	ldr	r2, [r1, #8]
typedef uint32_t ioport_port_t;
typedef uint32_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 5;
  400fb8:	0953      	lsrs	r3, r2, #5
	} else {
		return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
		       (IOPORT_PIO_OFFSET * port));
	}
#else
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  400fba:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  400fbe:	f203 7307 	addw	r3, r3, #1799	; 0x707
  400fc2:	025b      	lsls	r3, r3, #9
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
  400fc4:	f002 021f 	and.w	r2, r2, #31
	base->PIO_CODR = mask & ~level;
}

__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	return arch_ioport_pin_to_base(pin)->PIO_PDSR & arch_ioport_pin_to_mask(pin);
  400fc8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
  400fca:	fa06 f202 	lsl.w	r2, r6, r2
  400fce:	4013      	ands	r3, r2
  400fd0:	f101 0108 	add.w	r1, r1, #8
  400fd4:	d110      	bne.n	400ff8 <sd_mmc_select_slot.part.0+0x50>
			!= SD_MMC_0_CD_DETECT_VALUE) {
		if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_DEBOUNCE) {
  400fd6:	7989      	ldrb	r1, [r1, #6]
  400fd8:	42b1      	cmp	r1, r6
  400fda:	d006      	beq.n	400fea <sd_mmc_select_slot.part.0+0x42>
			SD_MMC_STOP_TIMEOUT();
		}
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_NO_CARD;
  400fdc:	4428      	add	r0, r5
  400fde:	eb04 0480 	add.w	r4, r4, r0, lsl #2
  400fe2:	2304      	movs	r3, #4
  400fe4:	73a3      	strb	r3, [r4, #14]
		return SD_MMC_ERR_NO_CARD;
  400fe6:	2002      	movs	r0, #2
  400fe8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return false;
}

static inline void SD_MMC_STOP_TIMEOUT(void)
{
	if (sd_mmc_sam_systick_used) {
  400fea:	4a26      	ldr	r2, [pc, #152]	; (401084 <sd_mmc_select_slot.part.0+0xdc>)
  400fec:	7812      	ldrb	r2, [r2, #0]
  400fee:	2a00      	cmp	r2, #0
  400ff0:	d0f4      	beq.n	400fdc <sd_mmc_select_slot.part.0+0x34>
		SysTick->CTRL = 0;
  400ff2:	4a25      	ldr	r2, [pc, #148]	; (401088 <sd_mmc_select_slot.part.0+0xe0>)
  400ff4:	6013      	str	r3, [r2, #0]
  400ff6:	e7f1      	b.n	400fdc <sd_mmc_select_slot.part.0+0x34>
			SD_MMC_STOP_TIMEOUT();
		}
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_NO_CARD;
		return SD_MMC_ERR_NO_CARD;
	}
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_NO_CARD) {
  400ff8:	798b      	ldrb	r3, [r1, #6]
  400ffa:	2b04      	cmp	r3, #4
  400ffc:	d02a      	beq.n	401054 <sd_mmc_select_slot.part.0+0xac>
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_DEBOUNCE;
		// Debounce + Power On Setup
		SD_MMC_START_TIMEOUT();
		return SD_MMC_ERR_NO_CARD;
	}
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_DEBOUNCE) {
  400ffe:	2b01      	cmp	r3, #1
  401000:	d003      	beq.n	40100a <sd_mmc_select_slot.part.0+0x62>
		// Set 1-bit bus width and low clock for initialization
		sd_mmc_cards[slot].clock = SDMMC_CLOCK_INIT;
		sd_mmc_cards[slot].bus_width = 1;
		sd_mmc_cards[slot].high_speed = 0;
	}
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_UNUSABLE) {
  401002:	2b03      	cmp	r3, #3
  401004:	d118      	bne.n	401038 <sd_mmc_select_slot.part.0+0x90>
		return SD_MMC_ERR_UNUSABLE;
  401006:	4618      	mov	r0, r3
  401008:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	}
}

static inline bool SD_MMC_IS_TIMEOUT(void)
{
	if (!sd_mmc_sam_systick_used) {
  40100a:	4b1e      	ldr	r3, [pc, #120]	; (401084 <sd_mmc_select_slot.part.0+0xdc>)
  40100c:	781b      	ldrb	r3, [r3, #0]
  40100e:	b12b      	cbz	r3, 40101c <sd_mmc_select_slot.part.0+0x74>
		return (xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdTRUE);
#else
		return true;
#endif
	}
	if (SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) {
  401010:	4b1d      	ldr	r3, [pc, #116]	; (401088 <sd_mmc_select_slot.part.0+0xe0>)
  401012:	681a      	ldr	r2, [r3, #0]
  401014:	03d2      	lsls	r2, r2, #15
  401016:	d530      	bpl.n	40107a <sd_mmc_select_slot.part.0+0xd2>
		SysTick->CTRL = 0;
  401018:	2200      	movs	r2, #0
  40101a:	601a      	str	r2, [r3, #0]
		if (!SD_MMC_IS_TIMEOUT()) {
			// Debounce on going
			return SD_MMC_ERR_NO_CARD;
		}
		// Card is not initialized
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_INIT;
  40101c:	1829      	adds	r1, r5, r0
  40101e:	0089      	lsls	r1, r1, #2
  401020:	1863      	adds	r3, r4, r1
		// Set 1-bit bus width and low clock for initialization
		sd_mmc_cards[slot].clock = SDMMC_CLOCK_INIT;
  401022:	4f1a      	ldr	r7, [pc, #104]	; (40108c <sd_mmc_select_slot.part.0+0xe4>)
		if (!SD_MMC_IS_TIMEOUT()) {
			// Debounce on going
			return SD_MMC_ERR_NO_CARD;
		}
		// Card is not initialized
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_INIT;
  401024:	2602      	movs	r6, #2
  401026:	739e      	strb	r6, [r3, #14]
		// Set 1-bit bus width and low clock for initialization
		sd_mmc_cards[slot].clock = SDMMC_CLOCK_INIT;
  401028:	5067      	str	r7, [r4, r1]
		sd_mmc_cards[slot].bus_width = 1;
  40102a:	2701      	movs	r7, #1
		sd_mmc_cards[slot].high_speed = 0;
  40102c:	2100      	movs	r1, #0
		}
		// Card is not initialized
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_INIT;
		// Set 1-bit bus width and low clock for initialization
		sd_mmc_cards[slot].clock = SDMMC_CLOCK_INIT;
		sd_mmc_cards[slot].bus_width = 1;
  40102e:	745f      	strb	r7, [r3, #17]
		sd_mmc_cards[slot].high_speed = 0;
  401030:	f883 1022 	strb.w	r1, [r3, #34]	; 0x22
  401034:	7b9b      	ldrb	r3, [r3, #14]
  401036:	e7e4      	b.n	401002 <sd_mmc_select_slot.part.0+0x5a>
	}
#endif

	// Initialize interface
	sd_mmc_slot_sel = slot;
	sd_mmc_card = &sd_mmc_cards[slot];
  401038:	4405      	add	r5, r0
  40103a:	eb04 0485 	add.w	r4, r4, r5, lsl #2
  40103e:	4914      	ldr	r1, [pc, #80]	; (401090 <sd_mmc_select_slot.part.0+0xe8>)
		sd_mmc_cards[slot].high_speed = 0;
	}
#endif

	// Initialize interface
	sd_mmc_slot_sel = slot;
  401040:	4a14      	ldr	r2, [pc, #80]	; (401094 <sd_mmc_select_slot.part.0+0xec>)
	sd_mmc_card = &sd_mmc_cards[slot];
	sd_mmc_configure_slot();
  401042:	4b15      	ldr	r3, [pc, #84]	; (401098 <sd_mmc_select_slot.part.0+0xf0>)
		sd_mmc_cards[slot].high_speed = 0;
	}
#endif

	// Initialize interface
	sd_mmc_slot_sel = slot;
  401044:	7010      	strb	r0, [r2, #0]
	sd_mmc_card = &sd_mmc_cards[slot];
  401046:	600c      	str	r4, [r1, #0]
	sd_mmc_configure_slot();
  401048:	4798      	blx	r3
	return (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_INIT) ?
			SD_MMC_INIT_ONGOING : SD_MMC_OK;
  40104a:	7ba0      	ldrb	r0, [r4, #14]

	// Initialize interface
	sd_mmc_slot_sel = slot;
	sd_mmc_card = &sd_mmc_cards[slot];
	sd_mmc_configure_slot();
	return (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_INIT) ?
  40104c:	1e83      	subs	r3, r0, #2
  40104e:	4258      	negs	r0, r3
  401050:	4158      	adcs	r0, r3
  401052:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		static xTimeOutType xTimeOut;
#endif

static inline void SD_MMC_START_TIMEOUT(void)
{
	if (!SysTick->CTRL) {
  401054:	4b0c      	ldr	r3, [pc, #48]	; (401088 <sd_mmc_select_slot.part.0+0xe0>)
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_NO_CARD;
		return SD_MMC_ERR_NO_CARD;
	}
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_NO_CARD) {
		// A card plug on going, but this is not initialized
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_DEBOUNCE;
  401056:	718e      	strb	r6, [r1, #6]
		static xTimeOutType xTimeOut;
#endif

static inline void SD_MMC_START_TIMEOUT(void)
{
	if (!SysTick->CTRL) {
  401058:	681a      	ldr	r2, [r3, #0]
  40105a:	b932      	cbnz	r2, 40106a <sd_mmc_select_slot.part.0+0xc2>
		sd_mmc_sam_systick_used = true;
  40105c:	4909      	ldr	r1, [pc, #36]	; (401084 <sd_mmc_select_slot.part.0+0xdc>)
		SysTick->LOAD = (sysclk_get_cpu_hz() / (8 * 1000))
  40105e:	4a0f      	ldr	r2, [pc, #60]	; (40109c <sd_mmc_select_slot.part.0+0xf4>)
#endif

static inline void SD_MMC_START_TIMEOUT(void)
{
	if (!SysTick->CTRL) {
		sd_mmc_sam_systick_used = true;
  401060:	700e      	strb	r6, [r1, #0]
		SysTick->LOAD = (sysclk_get_cpu_hz() / (8 * 1000))
  401062:	605a      	str	r2, [r3, #4]
				* SD_MMC_DEBOUNCE_TIMEOUT;
		SysTick->CTRL = SysTick_CTRL_ENABLE_Msk;
  401064:	601e      	str	r6, [r3, #0]
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_NO_CARD) {
		// A card plug on going, but this is not initialized
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_DEBOUNCE;
		// Debounce + Power On Setup
		SD_MMC_START_TIMEOUT();
		return SD_MMC_ERR_NO_CARD;
  401066:	2002      	movs	r0, #2
  401068:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		sd_mmc_sam_systick_used = true;
		SysTick->LOAD = (sysclk_get_cpu_hz() / (8 * 1000))
				* SD_MMC_DEBOUNCE_TIMEOUT;
		SysTick->CTRL = SysTick_CTRL_ENABLE_Msk;
	} else {
		sd_mmc_sam_systick_used = false;
  40106a:	4a06      	ldr	r2, [pc, #24]	; (401084 <sd_mmc_select_slot.part.0+0xdc>)
#ifdef FREERTOS_USED
		// Note: the define INCLUDE_vTaskDelay must be set to one
		// in FreeRTOSConfig.h file.
		vTaskSetTimeOutState(&xTimeOut);
#else
		delay_ms(SD_MMC_DEBOUNCE_TIMEOUT);
  40106c:	480c      	ldr	r0, [pc, #48]	; (4010a0 <sd_mmc_select_slot.part.0+0xf8>)
  40106e:	4b0d      	ldr	r3, [pc, #52]	; (4010a4 <sd_mmc_select_slot.part.0+0xfc>)
		sd_mmc_sam_systick_used = true;
		SysTick->LOAD = (sysclk_get_cpu_hz() / (8 * 1000))
				* SD_MMC_DEBOUNCE_TIMEOUT;
		SysTick->CTRL = SysTick_CTRL_ENABLE_Msk;
	} else {
		sd_mmc_sam_systick_used = false;
  401070:	2100      	movs	r1, #0
  401072:	7011      	strb	r1, [r2, #0]
#ifdef FREERTOS_USED
		// Note: the define INCLUDE_vTaskDelay must be set to one
		// in FreeRTOSConfig.h file.
		vTaskSetTimeOutState(&xTimeOut);
#else
		delay_ms(SD_MMC_DEBOUNCE_TIMEOUT);
  401074:	4798      	blx	r3
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_NO_CARD) {
		// A card plug on going, but this is not initialized
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_DEBOUNCE;
		// Debounce + Power On Setup
		SD_MMC_START_TIMEOUT();
		return SD_MMC_ERR_NO_CARD;
  401076:	2002      	movs	r0, #2
  401078:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	}
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_DEBOUNCE) {
		if (!SD_MMC_IS_TIMEOUT()) {
			// Debounce on going
			return SD_MMC_ERR_NO_CARD;
  40107a:	2002      	movs	r0, #2
  40107c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  40107e:	bf00      	nop
  401080:	20000090 	.word	0x20000090
  401084:	20000f4e 	.word	0x20000f4e
  401088:	e000e010 	.word	0xe000e010
  40108c:	00061a80 	.word	0x00061a80
  401090:	20000f50 	.word	0x20000f50
  401094:	20000f56 	.word	0x20000f56
  401098:	00400f7d 	.word	0x00400f7d
  40109c:	00e4e1c0 	.word	0x00e4e1c0
  4010a0:	0082ca25 	.word	0x0082ca25
  4010a4:	20000085 	.word	0x20000085

004010a8 <sd_mmc_cmd9_mci>:
 * data (CSD) on the CMD line mci.
 *
 * \return true if success, otherwise false
 */
static bool sd_mmc_cmd9_mci(void)
{
  4010a8:	b538      	push	{r3, r4, r5, lr}
	if (!driver_send_cmd(SDMMC_MCI_CMD9_SEND_CSD, (uint32_t)sd_mmc_card->rca << 16)) {
  4010aa:	4d08      	ldr	r5, [pc, #32]	; (4010cc <sd_mmc_cmd9_mci+0x24>)
  4010ac:	4a08      	ldr	r2, [pc, #32]	; (4010d0 <sd_mmc_cmd9_mci+0x28>)
  4010ae:	682b      	ldr	r3, [r5, #0]
  4010b0:	8999      	ldrh	r1, [r3, #12]
  4010b2:	f641 3009 	movw	r0, #6921	; 0x1b09
  4010b6:	0409      	lsls	r1, r1, #16
  4010b8:	4790      	blx	r2
  4010ba:	4604      	mov	r4, r0
  4010bc:	b118      	cbz	r0, 4010c6 <sd_mmc_cmd9_mci+0x1e>
		return false;
	}
	driver_get_response_128(sd_mmc_card->csd);
  4010be:	6828      	ldr	r0, [r5, #0]
  4010c0:	4b04      	ldr	r3, [pc, #16]	; (4010d4 <sd_mmc_cmd9_mci+0x2c>)
  4010c2:	3012      	adds	r0, #18
  4010c4:	4798      	blx	r3
	return true;
}
  4010c6:	4620      	mov	r0, r4
  4010c8:	bd38      	pop	{r3, r4, r5, pc}
  4010ca:	bf00      	nop
  4010cc:	20000f50 	.word	0x20000f50
  4010d0:	00401e95 	.word	0x00401e95
  4010d4:	00401ec9 	.word	0x00401ec9

004010d8 <sd_mmc_init>:

//-------------------------------------------------------------------
//--------------------- PUBLIC FUNCTIONS ----------------------------

void sd_mmc_init(void)
{
  4010d8:	b510      	push	{r4, lr}
	pmc_enable_periph_clk(SD_MMC_##slot##_WP_PIO_ID);
	MREPEAT(SD_MMC_MEM_CNT, SD_MMC_ENABLE_WP_PIN, ~)
# undef SD_MMC_ENABLE_WP_PIN
#endif
	for (uint8_t slot = 0; slot < SD_MMC_MEM_CNT; slot++) {
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_NO_CARD;
  4010da:	4804      	ldr	r0, [pc, #16]	; (4010ec <sd_mmc_init+0x14>)
	}
	sd_mmc_slot_sel = 0xFF; // No slot configurated
  4010dc:	4a04      	ldr	r2, [pc, #16]	; (4010f0 <sd_mmc_init+0x18>)
	driver_init();
  4010de:	4b05      	ldr	r3, [pc, #20]	; (4010f4 <sd_mmc_init+0x1c>)
	pmc_enable_periph_clk(SD_MMC_##slot##_WP_PIO_ID);
	MREPEAT(SD_MMC_MEM_CNT, SD_MMC_ENABLE_WP_PIN, ~)
# undef SD_MMC_ENABLE_WP_PIN
#endif
	for (uint8_t slot = 0; slot < SD_MMC_MEM_CNT; slot++) {
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_NO_CARD;
  4010e0:	2404      	movs	r4, #4
	}
	sd_mmc_slot_sel = 0xFF; // No slot configurated
  4010e2:	21ff      	movs	r1, #255	; 0xff
	pmc_enable_periph_clk(SD_MMC_##slot##_WP_PIO_ID);
	MREPEAT(SD_MMC_MEM_CNT, SD_MMC_ENABLE_WP_PIN, ~)
# undef SD_MMC_ENABLE_WP_PIN
#endif
	for (uint8_t slot = 0; slot < SD_MMC_MEM_CNT; slot++) {
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_NO_CARD;
  4010e4:	7384      	strb	r4, [r0, #14]
	}
	sd_mmc_slot_sel = 0xFF; // No slot configurated
  4010e6:	7011      	strb	r1, [r2, #0]
	driver_init();
  4010e8:	4798      	blx	r3
  4010ea:	bd10      	pop	{r4, pc}
  4010ec:	20000090 	.word	0x20000090
  4010f0:	20000f56 	.word	0x20000f56
  4010f4:	00401db9 	.word	0x00401db9

004010f8 <sd_mmc_check>:
{
	return SD_MMC_MEM_CNT;
}

sd_mmc_err_t sd_mmc_check(uint8_t slot)
{
  4010f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 * \retval SD_MMC_INIT_ONGOING Card initialization requested
 * \retval SD_MMC_OK           Card present
 */
static sd_mmc_err_t sd_mmc_select_slot(uint8_t slot)
{
	if (slot >= SD_MMC_MEM_CNT) {
  4010fc:	4605      	mov	r5, r0
{
	return SD_MMC_MEM_CNT;
}

sd_mmc_err_t sd_mmc_check(uint8_t slot)
{
  4010fe:	b095      	sub	sp, #84	; 0x54
 * \retval SD_MMC_INIT_ONGOING Card initialization requested
 * \retval SD_MMC_OK           Card present
 */
static sd_mmc_err_t sd_mmc_select_slot(uint8_t slot)
{
	if (slot >= SD_MMC_MEM_CNT) {
  401100:	2800      	cmp	r0, #0
  401102:	f000 80ea 	beq.w	4012da <sd_mmc_check+0x1e2>
		return SD_MMC_ERR_SLOT;
  401106:	2404      	movs	r4, #4
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  401108:	4b9e      	ldr	r3, [pc, #632]	; (401384 <sd_mmc_check+0x28c>)
  40110a:	7818      	ldrb	r0, [r3, #0]
  40110c:	2800      	cmp	r0, #0
  40110e:	f000 80de 	beq.w	4012ce <sd_mmc_check+0x1d6>
	}
	sd_mmc_debug("SD/MMC card initialization failed\n\r");
	sd_mmc_card->state = SD_MMC_CARD_STATE_UNUSABLE;
	sd_mmc_deselect_slot();
	return SD_MMC_ERR_UNUSABLE;
}
  401112:	4620      	mov	r0, r4
  401114:	b015      	add	sp, #84	; 0x54
  401116:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
{
	uint32_t resp;

	*v2 = 0;
	// Test for SD version 2
	if (!driver_send_cmd(SD_CMD8_SEND_IF_COND,
  40111a:	f245 5008 	movw	r0, #21768	; 0x5508
  40111e:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
  401122:	47b0      	blx	r6
  401124:	2800      	cmp	r0, #0
  401126:	f040 80f7 	bne.w	401318 <sd_mmc_check+0x220>
 */
static bool sd_cmd8(uint8_t * v2)
{
	uint32_t resp;

	*v2 = 0;
  40112a:	f04f 0900 	mov.w	r9, #0
	// Try to get the SDIO card's operating condition
	if (!sdio_op_cond()) {
		return false;
	}

	if (sd_mmc_card->type & CARD_TYPE_SD) {
  40112e:	683b      	ldr	r3, [r7, #0]
  401130:	7bdb      	ldrb	r3, [r3, #15]
  401132:	07da      	lsls	r2, r3, #31
  401134:	f100 80fc 	bmi.w	401330 <sd_mmc_check+0x238>
		if (!driver_send_cmd(SDMMC_CMD2_ALL_SEND_CID, 0)) {
			return false;
		}
	}
	// Ask the card to publish a new relative address (RCA).
	if (!driver_send_cmd(SD_CMD3_SEND_RELATIVE_ADDR, 0)) {
  401138:	f245 1003 	movw	r0, #20739	; 0x5103
  40113c:	2100      	movs	r1, #0
  40113e:	47b0      	blx	r6
  401140:	2800      	cmp	r0, #0
  401142:	f000 80e0 	beq.w	401306 <sd_mmc_check+0x20e>
		return false;
	}
	sd_mmc_card->rca = (driver_get_response() >> 16) & 0xFFFF;
  401146:	f8df 9274 	ldr.w	r9, [pc, #628]	; 4013bc <sd_mmc_check+0x2c4>
  40114a:	683d      	ldr	r5, [r7, #0]
  40114c:	f8df a268 	ldr.w	sl, [pc, #616]	; 4013b8 <sd_mmc_check+0x2c0>
  401150:	47c8      	blx	r9

	// SD MEMORY, Get the Card-Specific Data
	if (sd_mmc_card->type & CARD_TYPE_SD) {
  401152:	683b      	ldr	r3, [r7, #0]
	}
	// Ask the card to publish a new relative address (RCA).
	if (!driver_send_cmd(SD_CMD3_SEND_RELATIVE_ADDR, 0)) {
		return false;
	}
	sd_mmc_card->rca = (driver_get_response() >> 16) & 0xFFFF;
  401154:	0c00      	lsrs	r0, r0, #16
  401156:	81a8      	strh	r0, [r5, #12]

	// SD MEMORY, Get the Card-Specific Data
	if (sd_mmc_card->type & CARD_TYPE_SD) {
  401158:	7bda      	ldrb	r2, [r3, #15]
  40115a:	07d5      	lsls	r5, r2, #31
  40115c:	d53a      	bpl.n	4011d4 <sd_mmc_check+0xdc>
		if (!sd_mmc_cmd9_mci()) {
  40115e:	4b8a      	ldr	r3, [pc, #552]	; (401388 <sd_mmc_check+0x290>)
  401160:	4798      	blx	r3
  401162:	2800      	cmp	r0, #0
  401164:	f000 80cf 	beq.w	401306 <sd_mmc_check+0x20e>
 	uint32_t unit;
	uint32_t mul;
	uint32_t tran_speed;

	// Get SD memory maximum transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
  401168:	f8da 3000 	ldr.w	r3, [sl]
	unit = sd_mmc_trans_units[tran_speed & 0x7];
  40116c:	4d87      	ldr	r5, [pc, #540]	; (40138c <sd_mmc_check+0x294>)
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  40116e:	7d5a      	ldrb	r2, [r3, #21]
	mul = sd_trans_multipliers[(tran_speed >> 3) & 0xF];
  401170:	4887      	ldr	r0, [pc, #540]	; (401390 <sd_mmc_check+0x298>)
  401172:	7c99      	ldrb	r1, [r3, #18]
	uint32_t mul;
	uint32_t tran_speed;

	// Get SD memory maximum transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
	unit = sd_mmc_trans_units[tran_speed & 0x7];
  401174:	f002 0e07 	and.w	lr, r2, #7
	mul = sd_trans_multipliers[(tran_speed >> 3) & 0xF];
  401178:	f3c2 02c3 	ubfx	r2, r2, #3, #4
	sd_mmc_card->clock = unit * mul * 1000;
  40117c:	f855 502e 	ldr.w	r5, [r5, lr, lsl #2]
  401180:	f850 0022 	ldr.w	r0, [r0, r2, lsl #2]
  401184:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  401188:	fb02 f205 	mul.w	r2, r2, r5
  40118c:	fb00 f202 	mul.w	r2, r0, r2
	 * BLOCK_LEN = 2 ^ READ_BL_LEN      (READ_BL_LEN < 12)
	 * ----------------------------------------------------
	 * For high capacity SD card:
	 * memory capacity = (C_SIZE+1) * 512K byte
	 */
	if (CSD_STRUCTURE_VERSION(sd_mmc_card->csd) >= SD_CSD_VER_2_0) {
  401190:	0989      	lsrs	r1, r1, #6

	// Get SD memory maximum transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
	unit = sd_mmc_trans_units[tran_speed & 0x7];
	mul = sd_trans_multipliers[(tran_speed >> 3) & 0xF];
	sd_mmc_card->clock = unit * mul * 1000;
  401192:	601a      	str	r2, [r3, #0]
	 * BLOCK_LEN = 2 ^ READ_BL_LEN      (READ_BL_LEN < 12)
	 * ----------------------------------------------------
	 * For high capacity SD card:
	 * memory capacity = (C_SIZE+1) * 512K byte
	 */
	if (CSD_STRUCTURE_VERSION(sd_mmc_card->csd) >= SD_CSD_VER_2_0) {
  401194:	f040 8179 	bne.w	40148a <sd_mmc_check+0x392>
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  401198:	7e58      	ldrb	r0, [r3, #25]
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  40119a:	f893 c018 	ldrb.w	ip, [r3, #24]
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  40119e:	7ed9      	ldrb	r1, [r3, #27]
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  4011a0:	f893 e01a 	ldrb.w	lr, [r3, #26]
  4011a4:	7f1d      	ldrb	r5, [r3, #28]
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	value &=  ((uint32_t)1 << size) - 1;
  4011a6:	7dda      	ldrb	r2, [r3, #23]
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  4011a8:	0080      	lsls	r0, r0, #2
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  4011aa:	ea40 208c 	orr.w	r0, r0, ip, lsl #10
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  4011ae:	0049      	lsls	r1, r1, #1
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  4011b0:	ea40 109e 	orr.w	r0, r0, lr, lsr #6
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  4011b4:	ea41 11d5 	orr.w	r1, r1, r5, lsr #7
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	value &=  ((uint32_t)1 << size) - 1;
  4011b8:	f3c0 000b 	ubfx	r0, r0, #0, #12
  4011bc:	f001 0107 	and.w	r1, r1, #7
		sd_mmc_card->capacity =
				(SD_CSD_2_0_C_SIZE(sd_mmc_card->csd) + 1)
				* 512;
	} else {
		uint32_t blocknr = ((SD_CSD_1_0_C_SIZE(sd_mmc_card->csd) + 1) *
  4011c0:	3001      	adds	r0, #1
				(1 << (SD_CSD_1_0_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
  4011c2:	3102      	adds	r1, #2
	if (CSD_STRUCTURE_VERSION(sd_mmc_card->csd) >= SD_CSD_VER_2_0) {
		sd_mmc_card->capacity =
				(SD_CSD_2_0_C_SIZE(sd_mmc_card->csd) + 1)
				* 512;
	} else {
		uint32_t blocknr = ((SD_CSD_1_0_C_SIZE(sd_mmc_card->csd) + 1) *
  4011c4:	fa00 f101 	lsl.w	r1, r0, r1
				(1 << (SD_CSD_1_0_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
		sd_mmc_card->capacity = blocknr *
  4011c8:	f002 020f 	and.w	r2, r2, #15
  4011cc:	fa01 f202 	lsl.w	r2, r1, r2
				(1 << SD_CSD_1_0_READ_BL_LEN(sd_mmc_card->csd))
				/ 1024;
  4011d0:	0a92      	lsrs	r2, r2, #10
				(SD_CSD_2_0_C_SIZE(sd_mmc_card->csd) + 1)
				* 512;
	} else {
		uint32_t blocknr = ((SD_CSD_1_0_C_SIZE(sd_mmc_card->csd) + 1) *
				(1 << (SD_CSD_1_0_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
		sd_mmc_card->capacity = blocknr *
  4011d2:	605a      	str	r2, [r3, #4]
		}
		sd_decode_csd();
	}
	// Select the and put it into Transfer Mode
	if (!driver_send_cmd(SDMMC_CMD7_SELECT_CARD_CMD,
			(uint32_t)sd_mmc_card->rca << 16)) {
  4011d4:	8999      	ldrh	r1, [r3, #12]
			return false;
		}
		sd_decode_csd();
	}
	// Select the and put it into Transfer Mode
	if (!driver_send_cmd(SDMMC_CMD7_SELECT_CARD_CMD,
  4011d6:	4d6f      	ldr	r5, [pc, #444]	; (401394 <sd_mmc_check+0x29c>)
  4011d8:	0409      	lsls	r1, r1, #16
  4011da:	f243 1007 	movw	r0, #12551	; 0x3107
  4011de:	47b0      	blx	r6
  4011e0:	2800      	cmp	r0, #0
  4011e2:	f000 8090 	beq.w	401306 <sd_mmc_check+0x20e>
			(uint32_t)sd_mmc_card->rca << 16)) {
		return false;
	}
	// SD MEMORY, Read the SCR to get card version
	if (sd_mmc_card->type & CARD_TYPE_SD) {
  4011e6:	683b      	ldr	r3, [r7, #0]
  4011e8:	f8df a1cc 	ldr.w	sl, [pc, #460]	; 4013b8 <sd_mmc_check+0x2c0>
  4011ec:	7bda      	ldrb	r2, [r3, #15]
  4011ee:	07d0      	lsls	r0, r2, #31
  4011f0:	d530      	bpl.n	401254 <sd_mmc_check+0x15c>
{
	uint8_t scr[SD_SCR_REG_BSIZE];

	// CMD55 - Indicate to the card that the next command is an
	// application specific command rather than a standard command.
	if (!driver_send_cmd(SDMMC_CMD55_APP_CMD, (uint32_t)sd_mmc_card->rca << 16)) {
  4011f2:	8999      	ldrh	r1, [r3, #12]
  4011f4:	f241 1037 	movw	r0, #4407	; 0x1137
  4011f8:	0409      	lsls	r1, r1, #16
  4011fa:	47a8      	blx	r5
  4011fc:	2800      	cmp	r0, #0
  4011fe:	f000 8082 	beq.w	401306 <sd_mmc_check+0x20e>
		return false;
	}
	if (!driver_adtc_start(SD_ACMD51_SEND_SCR, 0,
  401202:	2501      	movs	r5, #1
  401204:	9500      	str	r5, [sp, #0]
  401206:	462b      	mov	r3, r5
  401208:	4863      	ldr	r0, [pc, #396]	; (401398 <sd_mmc_check+0x2a0>)
  40120a:	f8df c1b8 	ldr.w	ip, [pc, #440]	; 4013c4 <sd_mmc_check+0x2cc>
  40120e:	2100      	movs	r1, #0
  401210:	2208      	movs	r2, #8
  401212:	47e0      	blx	ip
  401214:	2800      	cmp	r0, #0
  401216:	d076      	beq.n	401306 <sd_mmc_check+0x20e>
			SD_SCR_REG_BSIZE, 1, true)) {
		return false;
	}
	if (!driver_start_read_blocks(scr, 1)) {
  401218:	4629      	mov	r1, r5
  40121a:	a804      	add	r0, sp, #16
  40121c:	4b5f      	ldr	r3, [pc, #380]	; (40139c <sd_mmc_check+0x2a4>)
  40121e:	4798      	blx	r3
  401220:	2800      	cmp	r0, #0
  401222:	d070      	beq.n	401306 <sd_mmc_check+0x20e>
		return false;
	}
	if (!driver_wait_end_of_read_blocks()) {
  401224:	4b5e      	ldr	r3, [pc, #376]	; (4013a0 <sd_mmc_check+0x2a8>)
  401226:	4798      	blx	r3
  401228:	2800      	cmp	r0, #0
  40122a:	d06c      	beq.n	401306 <sd_mmc_check+0x20e>
  40122c:	f89d 3010 	ldrb.w	r3, [sp, #16]
		return false;
	}

	// Get SD Memory Card - Spec. Version
	switch (SD_SCR_SD_SPEC(scr)) {
  401230:	f003 030f 	and.w	r3, r3, #15
  401234:	2b01      	cmp	r3, #1
  401236:	f000 8223 	beq.w	401680 <sd_mmc_check+0x588>
  40123a:	f0c0 821c 	bcc.w	401676 <sd_mmc_check+0x57e>
  40123e:	2b02      	cmp	r3, #2
  401240:	f040 8219 	bne.w	401676 <sd_mmc_check+0x57e>
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  401244:	f89d 3012 	ldrb.w	r3, [sp, #18]
	case SD_SCR_SD_SPEC_1_10:
		sd_mmc_card->version = CARD_VER_SD_1_10;
		break;

	case SD_SCR_SD_SPEC_2_00:
		if (SD_SCR_SD_SPEC3(scr) == SD_SCR_SD_SPEC_3_00) {
  401248:	09db      	lsrs	r3, r3, #7
			sd_mmc_card->version = CARD_VER_SD_3_0;
  40124a:	683b      	ldr	r3, [r7, #0]
  40124c:	bf14      	ite	ne
  40124e:	2230      	movne	r2, #48	; 0x30
		} else {
			sd_mmc_card->version = CARD_VER_SD_2_0;
  401250:	2220      	moveq	r2, #32
  401252:	741a      	strb	r2, [r3, #16]
	if (IS_SDIO()) {
		if (!sdio_get_max_speed()) {
			return false;
		}
	}
	if ((4 <= driver_get_bus_width(sd_mmc_slot_sel))) {
  401254:	4d4b      	ldr	r5, [pc, #300]	; (401384 <sd_mmc_check+0x28c>)
  401256:	4b53      	ldr	r3, [pc, #332]	; (4013a4 <sd_mmc_check+0x2ac>)
  401258:	7828      	ldrb	r0, [r5, #0]
  40125a:	4798      	blx	r3
  40125c:	2803      	cmp	r0, #3
  40125e:	d91a      	bls.n	401296 <sd_mmc_check+0x19e>
		if (IS_SDIO()) {
			if (!sdio_cmd52_set_bus_width()) {
				return false;
			}
		}
		if (sd_mmc_card->type & CARD_TYPE_SD) {
  401260:	683b      	ldr	r3, [r7, #0]
  401262:	f8df a154 	ldr.w	sl, [pc, #340]	; 4013b8 <sd_mmc_check+0x2c0>
  401266:	7bda      	ldrb	r2, [r3, #15]
  401268:	07d1      	lsls	r1, r2, #31
  40126a:	d512      	bpl.n	401292 <sd_mmc_check+0x19a>
 */
static bool sd_acmd6(void)
{
	// CMD55 - Indicate to the card that the next command is an
	// application specific command rather than a standard command.
	if (!driver_send_cmd(SDMMC_CMD55_APP_CMD, (uint32_t)sd_mmc_card->rca << 16)) {
  40126c:	8999      	ldrh	r1, [r3, #12]
  40126e:	f8df b124 	ldr.w	fp, [pc, #292]	; 401394 <sd_mmc_check+0x29c>
  401272:	0409      	lsls	r1, r1, #16
  401274:	f241 1037 	movw	r0, #4407	; 0x1137
  401278:	47b0      	blx	r6
  40127a:	2800      	cmp	r0, #0
  40127c:	d044      	beq.n	401308 <sd_mmc_check+0x210>
		return false;
	}
	// 10b = 4 bits bus
	if (!driver_send_cmd(SD_ACMD6_SET_BUS_WIDTH, 0x2)) {
  40127e:	f241 1006 	movw	r0, #4358	; 0x1106
  401282:	2102      	movs	r1, #2
  401284:	47d8      	blx	fp
  401286:	2800      	cmp	r0, #0
  401288:	d03e      	beq.n	401308 <sd_mmc_check+0x210>
		return false;
	}
	sd_mmc_card->bus_width = 4;
  40128a:	f8da 3000 	ldr.w	r3, [sl]
  40128e:	2204      	movs	r2, #4
  401290:	745a      	strb	r2, [r3, #17]
			if (!sd_acmd6()) {
				return false;
			}
		}
		// Switch to selected bus mode
		sd_mmc_configure_slot();
  401292:	4b45      	ldr	r3, [pc, #276]	; (4013a8 <sd_mmc_check+0x2b0>)
  401294:	4798      	blx	r3
	}
	if (driver_is_high_speed_capable()) {
  401296:	4b45      	ldr	r3, [pc, #276]	; (4013ac <sd_mmc_check+0x2b4>)
  401298:	4798      	blx	r3
  40129a:	b158      	cbz	r0, 4012b4 <sd_mmc_check+0x1bc>
		if (IS_SDIO()) {
			if (!sdio_cmd52_set_high_speed()) {
				return false;
			}
		}
		if (sd_mmc_card->type & CARD_TYPE_SD) {
  40129c:	683b      	ldr	r3, [r7, #0]
  40129e:	f8df b118 	ldr.w	fp, [pc, #280]	; 4013b8 <sd_mmc_check+0x2c0>
  4012a2:	7bda      	ldrb	r2, [r3, #15]
  4012a4:	07d2      	lsls	r2, r2, #31
  4012a6:	d503      	bpl.n	4012b0 <sd_mmc_check+0x1b8>
			if (sd_mmc_card->version > CARD_VER_SD_1_0) {
  4012a8:	7c1b      	ldrb	r3, [r3, #16]
  4012aa:	2b10      	cmp	r3, #16
  4012ac:	f200 80fa 	bhi.w	4014a4 <sd_mmc_check+0x3ac>
					return false;
				}
			}
		}
		// Valid new configuration
		sd_mmc_configure_slot();
  4012b0:	4b3d      	ldr	r3, [pc, #244]	; (4013a8 <sd_mmc_check+0x2b0>)
  4012b2:	4798      	blx	r3
	}
	// SD MEMORY, Set default block size
	if (sd_mmc_card->type & CARD_TYPE_SD) {
  4012b4:	683a      	ldr	r2, [r7, #0]
  4012b6:	f8df 8100 	ldr.w	r8, [pc, #256]	; 4013b8 <sd_mmc_check+0x2c0>
  4012ba:	7bd3      	ldrb	r3, [r2, #15]
  4012bc:	07d9      	lsls	r1, r3, #31
  4012be:	f100 80d9 	bmi.w	401474 <sd_mmc_check+0x37c>
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  4012c2:	7828      	ldrb	r0, [r5, #0]
	//if (sd_mmc_is_spi()? sd_mmc_spi_card_init()
			//: sd_mmc_mci_card_init())
	if(sd_mmc_mci_card_init()) 
	{
		sd_mmc_debug("SD/MMC card ready\n\r");
		sd_mmc_card->state = SD_MMC_CARD_STATE_READY;
  4012c4:	2300      	movs	r3, #0
  4012c6:	7393      	strb	r3, [r2, #14]
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  4012c8:	2800      	cmp	r0, #0
  4012ca:	f47f af22 	bne.w	401112 <sd_mmc_check+0x1a>
		driver_deselect_device(sd_mmc_slot_sel);
  4012ce:	4b38      	ldr	r3, [pc, #224]	; (4013b0 <sd_mmc_check+0x2b8>)
  4012d0:	4798      	blx	r3
	}
	sd_mmc_debug("SD/MMC card initialization failed\n\r");
	sd_mmc_card->state = SD_MMC_CARD_STATE_UNUSABLE;
	sd_mmc_deselect_slot();
	return SD_MMC_ERR_UNUSABLE;
}
  4012d2:	4620      	mov	r0, r4
  4012d4:	b015      	add	sp, #84	; 0x54
  4012d6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4012da:	4b36      	ldr	r3, [pc, #216]	; (4013b4 <sd_mmc_check+0x2bc>)
  4012dc:	4798      	blx	r3
sd_mmc_err_t sd_mmc_check(uint8_t slot)
{
	sd_mmc_err_t sd_mmc_err;

	sd_mmc_err = sd_mmc_select_slot(slot);
	if (sd_mmc_err != SD_MMC_INIT_ONGOING) {
  4012de:	2801      	cmp	r0, #1
  4012e0:	4604      	mov	r4, r0
  4012e2:	f47f af11 	bne.w	401108 <sd_mmc_check+0x10>
static bool sd_mmc_mci_card_init(void)
{
	uint8_t v2 = 0;

	// In first, try to install SD/SDIO card
	sd_mmc_card->type = CARD_TYPE_SD;
  4012e6:	4f34      	ldr	r7, [pc, #208]	; (4013b8 <sd_mmc_check+0x2c0>)
	sd_mmc_card->version = CARD_VER_UNKNOWN;
	sd_mmc_card->rca = 0;
	sd_mmc_debug("Start SD card install\n\r");

	// Card need of 74 cycles clock minimum to start
	driver_send_clock();
  4012e8:	f8df 80dc 	ldr.w	r8, [pc, #220]	; 4013c8 <sd_mmc_check+0x2d0>
static bool sd_mmc_mci_card_init(void)
{
	uint8_t v2 = 0;

	// In first, try to install SD/SDIO card
	sd_mmc_card->type = CARD_TYPE_SD;
  4012ec:	683b      	ldr	r3, [r7, #0]

	// Card need of 74 cycles clock minimum to start
	driver_send_clock();

	// CMD0 - Reset all cards to idle state.
	if (!driver_send_cmd(SDMMC_MCI_CMD0_GO_IDLE_STATE, 0)) {
  4012ee:	4e29      	ldr	r6, [pc, #164]	; (401394 <sd_mmc_check+0x29c>)
static bool sd_mmc_mci_card_init(void)
{
	uint8_t v2 = 0;

	// In first, try to install SD/SDIO card
	sd_mmc_card->type = CARD_TYPE_SD;
  4012f0:	73d8      	strb	r0, [r3, #15]
	sd_mmc_card->version = CARD_VER_UNKNOWN;
  4012f2:	741d      	strb	r5, [r3, #16]
	sd_mmc_card->rca = 0;
  4012f4:	819d      	strh	r5, [r3, #12]
	sd_mmc_debug("Start SD card install\n\r");

	// Card need of 74 cycles clock minimum to start
	driver_send_clock();
  4012f6:	47c0      	blx	r8

	// CMD0 - Reset all cards to idle state.
	if (!driver_send_cmd(SDMMC_MCI_CMD0_GO_IDLE_STATE, 0)) {
  4012f8:	4629      	mov	r1, r5
  4012fa:	f44f 4080 	mov.w	r0, #16384	; 0x4000
  4012fe:	47b0      	blx	r6
  401300:	2800      	cmp	r0, #0
  401302:	f47f af0a 	bne.w	40111a <sd_mmc_check+0x22>
  401306:	4d1f      	ldr	r5, [pc, #124]	; (401384 <sd_mmc_check+0x28c>)
		// To notify that the card has been just initialized
		// It is necessary for USB Device MSC
		return SD_MMC_INIT_ONGOING;
	}
	sd_mmc_debug("SD/MMC card initialization failed\n\r");
	sd_mmc_card->state = SD_MMC_CARD_STATE_UNUSABLE;
  401308:	683b      	ldr	r3, [r7, #0]
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  40130a:	7828      	ldrb	r0, [r5, #0]
		// To notify that the card has been just initialized
		// It is necessary for USB Device MSC
		return SD_MMC_INIT_ONGOING;
	}
	sd_mmc_debug("SD/MMC card initialization failed\n\r");
	sd_mmc_card->state = SD_MMC_CARD_STATE_UNUSABLE;
  40130c:	2403      	movs	r4, #3
  40130e:	739c      	strb	r4, [r3, #14]
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  401310:	2800      	cmp	r0, #0
  401312:	f47f aefe 	bne.w	401112 <sd_mmc_check+0x1a>
  401316:	e7da      	b.n	4012ce <sd_mmc_check+0x1d6>
	if (!driver_send_cmd(SD_CMD8_SEND_IF_COND,
			SD_CMD8_PATTERN | SD_CMD8_HIGH_VOLTAGE)) {
		return true; // It is not a V2
	}
	// Check R7 response
	resp = driver_get_response();
  401318:	4b28      	ldr	r3, [pc, #160]	; (4013bc <sd_mmc_check+0x2c4>)
  40131a:	4798      	blx	r3
	if (resp == 0xFFFFFFFF) {
  40131c:	1c45      	adds	r5, r0, #1
  40131e:	f43f af04 	beq.w	40112a <sd_mmc_check+0x32>
		// No compliance R7 value
		return true; // It is not a V2
	}
	if ((resp & (SD_CMD8_MASK_PATTERN | SD_CMD8_MASK_VOLTAGE))
  401322:	f3c0 000b 	ubfx	r0, r0, #0, #12
  401326:	f5b0 7fd5 	cmp.w	r0, #426	; 0x1aa
  40132a:	d1ec      	bne.n	401306 <sd_mmc_check+0x20e>
		sd_mmc_debug("%s: CMD8 resp32 0x%08x UNUSABLE CARD\n\r",
				__func__, resp);
		return false;
	}
	sd_mmc_debug("SD card V2\n\r");
	*v2 = 1;
  40132c:	46a1      	mov	r9, r4
  40132e:	e6fe      	b.n	40112e <sd_mmc_check+0x36>
	// Try to get the SDIO card's operating condition
	if (!sdio_op_cond()) {
		return false;
	}

	if (sd_mmc_card->type & CARD_TYPE_SD) {
  401330:	f640 0535 	movw	r5, #2101	; 0x835
			sd_mmc_debug("%s: CMD55 Fail\n\r", __func__);
			return false;
		}

		// (ACMD41) Sends host OCR register
		arg = SD_MMC_VOLTAGE_SUPPORT;
  401334:	f8df a088 	ldr.w	sl, [pc, #136]	; 4013c0 <sd_mmc_check+0x2c8>
		// Check response
		if (!driver_send_cmd(SD_MCI_ACMD41_SD_SEND_OP_COND, arg)) {
			sd_mmc_debug("%s: ACMD41 Fail\n\r", __func__);
			return false;
		}
		resp = driver_get_response();
  401338:	f8df b080 	ldr.w	fp, [pc, #128]	; 4013bc <sd_mmc_check+0x2c4>
  40133c:	e00e      	b.n	40135c <sd_mmc_check+0x264>
			sd_mmc_debug("%s: CMD55 Fail\n\r", __func__);
			return false;
		}

		// (ACMD41) Sends host OCR register
		arg = SD_MMC_VOLTAGE_SUPPORT;
  40133e:	f1b9 0f00 	cmp.w	r9, #0
		if (v2) {
			arg |= SD_ACMD41_HCS;
		}
		// Check response
		if (!driver_send_cmd(SD_MCI_ACMD41_SD_SEND_OP_COND, arg)) {
  401342:	bf14      	ite	ne
  401344:	4651      	movne	r1, sl
  401346:	f44f 11fc 	moveq.w	r1, #2064384	; 0x1f8000
  40134a:	f244 5029 	movw	r0, #17705	; 0x4529
  40134e:	47b0      	blx	r6
  401350:	b150      	cbz	r0, 401368 <sd_mmc_check+0x270>
			sd_mmc_debug("%s: ACMD41 Fail\n\r", __func__);
			return false;
		}
		resp = driver_get_response();
  401352:	47d8      	blx	fp
		if (resp & OCR_POWER_UP_BUSY) {
  401354:	2800      	cmp	r0, #0
  401356:	db78      	blt.n	40144a <sd_mmc_check+0x352>
			if ((resp & OCR_CCS) != 0) {
				sd_mmc_card->type |= CARD_TYPE_HC;
			}
			break;
		}
		if (retry-- == 0) {
  401358:	3d01      	subs	r5, #1
  40135a:	d005      	beq.n	401368 <sd_mmc_check+0x270>
	 */
	retry = 2100;
	do {
		// CMD55 - Indicate to the card that the next command is an
		// application specific command rather than a standard command.
		if (!driver_send_cmd(SDMMC_CMD55_APP_CMD, 0)) {
  40135c:	f241 1037 	movw	r0, #4407	; 0x1137
  401360:	2100      	movs	r1, #0
  401362:	47b0      	blx	r6
  401364:	2800      	cmp	r0, #0
  401366:	d1ea      	bne.n	40133e <sd_mmc_check+0x246>
	if (sd_mmc_card->type & CARD_TYPE_SD) {
		// Try to get the SD card's operating condition
		if (!sd_mci_op_cond(v2)) {
			// It is not a SD card
			sd_mmc_debug("Start MMC Install\n\r");
			sd_mmc_card->type = CARD_TYPE_MMC;
  401368:	683b      	ldr	r3, [r7, #0]
  40136a:	2202      	movs	r2, #2
  40136c:	73da      	strb	r2, [r3, #15]
static bool sd_mmc_mci_install_mmc(void)
{
	uint8_t b_authorize_high_speed;

	// CMD0 - Reset all cards to idle state.
	if (!driver_send_cmd(SDMMC_MCI_CMD0_GO_IDLE_STATE, 0)) {
  40136e:	f44f 4080 	mov.w	r0, #16384	; 0x4000
  401372:	2100      	movs	r1, #0
  401374:	47b0      	blx	r6
  401376:	2800      	cmp	r0, #0
  401378:	d0c5      	beq.n	401306 <sd_mmc_check+0x20e>
  40137a:	f241 0569 	movw	r5, #4201	; 0x1069
			sd_mmc_debug("%s: CMD1 MCI Fail - Busy retry %d\n\r",
					__func__, (int)(4200 - retry));
			return false;
		}
		// Check busy flag
		resp = driver_get_response();
  40137e:	f8df 803c 	ldr.w	r8, [pc, #60]	; 4013bc <sd_mmc_check+0x2c4>
  401382:	e025      	b.n	4013d0 <sd_mmc_check+0x2d8>
  401384:	20000f56 	.word	0x20000f56
  401388:	004010a9 	.word	0x004010a9
  40138c:	00406a74 	.word	0x00406a74
  401390:	00406a34 	.word	0x00406a34
  401394:	00401e95 	.word	0x00401e95
  401398:	00081133 	.word	0x00081133
  40139c:	00402041 	.word	0x00402041
  4013a0:	004020a9 	.word	0x004020a9
  4013a4:	00401de1 	.word	0x00401de1
  4013a8:	00400f7d 	.word	0x00400f7d
  4013ac:	00401ded 	.word	0x00401ded
  4013b0:	00401e71 	.word	0x00401e71
  4013b4:	00400fa9 	.word	0x00400fa9
  4013b8:	20000f50 	.word	0x20000f50
  4013bc:	00401ec1 	.word	0x00401ec1
  4013c0:	401f8000 	.word	0x401f8000
  4013c4:	00401eed 	.word	0x00401eed
  4013c8:	00401e75 	.word	0x00401e75
					== OCR_ACCESS_MODE_SECTOR) {
				sd_mmc_card->type |= CARD_TYPE_HC;
			}
			break;
		}
		if (retry-- == 0) {
  4013cc:	3d01      	subs	r5, #1
  4013ce:	d09a      	beq.n	401306 <sd_mmc_check+0x20e>
	 * 6 = cmd byte size
	 * 6 = response byte size
	 */
	retry = 4200;
	do {
		if (!driver_send_cmd(MMC_MCI_CMD1_SEND_OP_COND,
  4013d0:	49af      	ldr	r1, [pc, #700]	; (401690 <sd_mmc_check+0x598>)
			sd_mmc_debug("%s: CMD1 MCI Fail - Busy retry %d\n\r",
					__func__, (int)(4200 - retry));
			return false;
		}
		// Check busy flag
		resp = driver_get_response();
  4013d2:	f8df 92fc 	ldr.w	r9, [pc, #764]	; 4016d0 <sd_mmc_check+0x5d8>
	 * 6 = cmd byte size
	 * 6 = response byte size
	 */
	retry = 4200;
	do {
		if (!driver_send_cmd(MMC_MCI_CMD1_SEND_OP_COND,
  4013d6:	f244 5001 	movw	r0, #17665	; 0x4501
  4013da:	47b0      	blx	r6
  4013dc:	2800      	cmp	r0, #0
  4013de:	d092      	beq.n	401306 <sd_mmc_check+0x20e>
			sd_mmc_debug("%s: CMD1 MCI Fail - Busy retry %d\n\r",
					__func__, (int)(4200 - retry));
			return false;
		}
		// Check busy flag
		resp = driver_get_response();
  4013e0:	47c0      	blx	r8
		if (resp & OCR_POWER_UP_BUSY) {
  4013e2:	2800      	cmp	r0, #0
  4013e4:	daf2      	bge.n	4013cc <sd_mmc_check+0x2d4>
			// Check OCR value
			if ((resp & OCR_ACCESS_MODE_MASK)
  4013e6:	f000 40c0 	and.w	r0, r0, #1610612736	; 0x60000000
  4013ea:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
  4013ee:	d104      	bne.n	4013fa <sd_mmc_check+0x302>
					== OCR_ACCESS_MODE_SECTOR) {
				sd_mmc_card->type |= CARD_TYPE_HC;
  4013f0:	683b      	ldr	r3, [r7, #0]
  4013f2:	7bda      	ldrb	r2, [r3, #15]
  4013f4:	f042 0208 	orr.w	r2, r2, #8
  4013f8:	73da      	strb	r2, [r3, #15]
		return false;
	}

	// Put the Card in Identify Mode
	// Note: The CID is not used in this stack
	if (!driver_send_cmd(SDMMC_CMD2_ALL_SEND_CID, 0)) {
  4013fa:	f645 3002 	movw	r0, #23298	; 0x5b02
  4013fe:	2100      	movs	r1, #0
  401400:	f8df 82d0 	ldr.w	r8, [pc, #720]	; 4016d4 <sd_mmc_check+0x5dc>
  401404:	47b0      	blx	r6
  401406:	2800      	cmp	r0, #0
  401408:	f43f af7d 	beq.w	401306 <sd_mmc_check+0x20e>
		return false;
	}
	// Assign relative address to the card.
	sd_mmc_card->rca = 1;
  40140c:	683b      	ldr	r3, [r7, #0]
  40140e:	4da1      	ldr	r5, [pc, #644]	; (401694 <sd_mmc_check+0x59c>)
  401410:	2201      	movs	r2, #1
  401412:	819a      	strh	r2, [r3, #12]
	if (!driver_send_cmd(MMC_CMD3_SET_RELATIVE_ADDR,
  401414:	f241 1003 	movw	r0, #4355	; 0x1103
  401418:	f44f 3180 	mov.w	r1, #65536	; 0x10000
  40141c:	47c0      	blx	r8
  40141e:	2800      	cmp	r0, #0
  401420:	f43f af71 	beq.w	401306 <sd_mmc_check+0x20e>
			(uint32_t)sd_mmc_card->rca << 16)) {
		return false;
	}
	// Get the Card-Specific Data
	if (!sd_mmc_cmd9_mci()) {
  401424:	4b9c      	ldr	r3, [pc, #624]	; (401698 <sd_mmc_check+0x5a0>)
  401426:	4798      	blx	r3
  401428:	2800      	cmp	r0, #0
  40142a:	f43f af6c 	beq.w	401306 <sd_mmc_check+0x20e>
 	uint32_t unit;
	uint32_t mul;
	uint32_t tran_speed;

	// Get MMC System Specification version supported by the card
	switch (MMC_CSD_SPEC_VERS(sd_mmc_card->csd)) {
  40142e:	682b      	ldr	r3, [r5, #0]
  401430:	7c9a      	ldrb	r2, [r3, #18]
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	value &=  ((uint32_t)1 << size) - 1;
  401432:	f3c2 0283 	ubfx	r2, r2, #2, #4
  401436:	3a01      	subs	r2, #1
  401438:	2a03      	cmp	r2, #3
  40143a:	f200 817c 	bhi.w	401736 <sd_mmc_check+0x63e>
  40143e:	e8df f012 	tbh	[pc, r2, lsl #1]
  401442:	0177      	.short	0x0177
  401444:	0124017d 	.word	0x0124017d
  401448:	0068      	.short	0x0068
			return false;
		}
		resp = driver_get_response();
		if (resp & OCR_POWER_UP_BUSY) {
			// Card is ready
			if ((resp & OCR_CCS) != 0) {
  40144a:	0041      	lsls	r1, r0, #1
  40144c:	d50f      	bpl.n	40146e <sd_mmc_check+0x376>
				sd_mmc_card->type |= CARD_TYPE_HC;
  40144e:	683a      	ldr	r2, [r7, #0]
  401450:	7bd3      	ldrb	r3, [r2, #15]
  401452:	f043 0308 	orr.w	r3, r3, #8
  401456:	73d3      	strb	r3, [r2, #15]
			sd_mmc_card->type = CARD_TYPE_MMC;
			return sd_mmc_mci_install_mmc();
		}
	}

	if (sd_mmc_card->type & CARD_TYPE_SD) {
  401458:	07db      	lsls	r3, r3, #31
  40145a:	f57f ae6d 	bpl.w	401138 <sd_mmc_check+0x40>
		// SD MEMORY, Put the Card in Identify Mode
		// Note: The CID is not used in this stack
		if (!driver_send_cmd(SDMMC_CMD2_ALL_SEND_CID, 0)) {
  40145e:	f645 3002 	movw	r0, #23298	; 0x5b02
  401462:	2100      	movs	r1, #0
  401464:	47b0      	blx	r6
  401466:	2800      	cmp	r0, #0
  401468:	f47f ae66 	bne.w	401138 <sd_mmc_check+0x40>
  40146c:	e74b      	b.n	401306 <sd_mmc_check+0x20e>
  40146e:	683b      	ldr	r3, [r7, #0]
  401470:	7bdb      	ldrb	r3, [r3, #15]
  401472:	e7f1      	b.n	401458 <sd_mmc_check+0x360>
		// Valid new configuration
		sd_mmc_configure_slot();
	}
	// SD MEMORY, Set default block size
	if (sd_mmc_card->type & CARD_TYPE_SD) {
		if (!driver_send_cmd(SDMMC_CMD16_SET_BLOCKLEN, SD_MMC_BLOCK_SIZE)) {
  401474:	f241 1010 	movw	r0, #4368	; 0x1110
  401478:	f44f 7100 	mov.w	r1, #512	; 0x200
  40147c:	47b0      	blx	r6
  40147e:	2800      	cmp	r0, #0
  401480:	f43f af42 	beq.w	401308 <sd_mmc_check+0x210>
  401484:	f8d8 2000 	ldr.w	r2, [r8]
  401488:	e71b      	b.n	4012c2 <sd_mmc_check+0x1ca>
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  40148a:	7e59      	ldrb	r1, [r3, #25]
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  40148c:	7e98      	ldrb	r0, [r3, #26]
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  40148e:	7eda      	ldrb	r2, [r3, #27]
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  401490:	0409      	lsls	r1, r1, #16
  401492:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  401496:	430a      	orrs	r2, r1
	}
	value &=  ((uint32_t)1 << size) - 1;
  401498:	f3c2 0215 	ubfx	r2, r2, #0, #22
	 * memory capacity = (C_SIZE+1) * 512K byte
	 */
	if (CSD_STRUCTURE_VERSION(sd_mmc_card->csd) >= SD_CSD_VER_2_0) {
		sd_mmc_card->capacity =
				(SD_CSD_2_0_C_SIZE(sd_mmc_card->csd) + 1)
				* 512;
  40149c:	3201      	adds	r2, #1
  40149e:	0252      	lsls	r2, r2, #9
	 * ----------------------------------------------------
	 * For high capacity SD card:
	 * memory capacity = (C_SIZE+1) * 512K byte
	 */
	if (CSD_STRUCTURE_VERSION(sd_mmc_card->csd) >= SD_CSD_VER_2_0) {
		sd_mmc_card->capacity =
  4014a0:	605a      	str	r2, [r3, #4]
  4014a2:	e697      	b.n	4011d4 <sd_mmc_check+0xdc>
 */
static bool sd_cm6_set_high_speed(void)
{
	uint8_t switch_status[SD_SW_STATUS_BSIZE];

	if (!driver_adtc_start(SD_CMD6_SWITCH_FUNC,
  4014a4:	f04f 0a01 	mov.w	sl, #1
  4014a8:	f8cd a000 	str.w	sl, [sp]
  4014ac:	4653      	mov	r3, sl
  4014ae:	487b      	ldr	r0, [pc, #492]	; (40169c <sd_mmc_check+0x5a4>)
  4014b0:	497b      	ldr	r1, [pc, #492]	; (4016a0 <sd_mmc_check+0x5a8>)
  4014b2:	f8df c204 	ldr.w	ip, [pc, #516]	; 4016b8 <sd_mmc_check+0x5c0>
  4014b6:	2240      	movs	r2, #64	; 0x40
  4014b8:	47e0      	blx	ip
  4014ba:	2800      	cmp	r0, #0
  4014bc:	f43f af24 	beq.w	401308 <sd_mmc_check+0x210>
			| SD_CMD6_GRP2_DEFAULT
			| SD_CMD6_GRP1_HIGH_SPEED,
			SD_SW_STATUS_BSIZE, 1, true)) {
		return false;
	}
	if (!driver_start_read_blocks(switch_status, 1)) {
  4014c0:	a804      	add	r0, sp, #16
  4014c2:	4651      	mov	r1, sl
  4014c4:	4b77      	ldr	r3, [pc, #476]	; (4016a4 <sd_mmc_check+0x5ac>)
  4014c6:	4798      	blx	r3
  4014c8:	2800      	cmp	r0, #0
  4014ca:	f43f af1d 	beq.w	401308 <sd_mmc_check+0x210>
		return false;
	}
	if (!driver_wait_end_of_read_blocks()) {
  4014ce:	4b76      	ldr	r3, [pc, #472]	; (4016a8 <sd_mmc_check+0x5b0>)
  4014d0:	4798      	blx	r3
  4014d2:	2800      	cmp	r0, #0
  4014d4:	f43f af18 	beq.w	401308 <sd_mmc_check+0x210>
		return false;
	}

	if (driver_get_response() & CARD_STATUS_SWITCH_ERROR) {
  4014d8:	47c8      	blx	r9
  4014da:	0600      	lsls	r0, r0, #24
  4014dc:	f53f af14 	bmi.w	401308 <sd_mmc_check+0x210>
  4014e0:	f89d 3020 	ldrb.w	r3, [sp, #32]
		sd_mmc_debug("%s: CMD6 CARD_STATUS_SWITCH_ERROR\n\r", __func__);
		return false;
	}
	if (SD_SW_STATUS_FUN_GRP1_RC(switch_status)
  4014e4:	f003 030f 	and.w	r3, r3, #15
  4014e8:	2b0f      	cmp	r3, #15
  4014ea:	f43f aee1 	beq.w	4012b0 <sd_mmc_check+0x1b8>
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  4014ee:	f89d 302d 	ldrb.w	r3, [sp, #45]	; 0x2d
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  4014f2:	f89d 202c 	ldrb.w	r2, [sp, #44]	; 0x2c
			== SD_SW_STATUS_FUN_GRP_RC_ERROR) {
		// No supported, it is not a protocol error
		return true;
	}
	if (SD_SW_STATUS_FUN_GRP1_BUSY(switch_status)) {
  4014f6:	ea53 2202 	orrs.w	r2, r3, r2, lsl #8
  4014fa:	f47f af05 	bne.w	401308 <sd_mmc_check+0x210>
		sd_mmc_debug("%s: CMD6 SD_SW_STATUS_FUN_GRP1_BUSY\n\r", __func__);
		return false;
	}
	// CMD6 function switching period is within 8 clocks
	// after the end bit of status data.
	driver_send_clock();
  4014fe:	47c0      	blx	r8
	sd_mmc_card->high_speed = 1;
  401500:	f8db 3000 	ldr.w	r3, [fp]
	sd_mmc_card->clock *= 2;
  401504:	681a      	ldr	r2, [r3, #0]
		return false;
	}
	// CMD6 function switching period is within 8 clocks
	// after the end bit of status data.
	driver_send_clock();
	sd_mmc_card->high_speed = 1;
  401506:	f883 a022 	strb.w	sl, [r3, #34]	; 0x22
	sd_mmc_card->clock *= 2;
  40150a:	fa02 f20a 	lsl.w	r2, r2, sl
  40150e:	601a      	str	r2, [r3, #0]
  401510:	e6ce      	b.n	4012b0 <sd_mmc_check+0x1b8>
	case 3:
		sd_mmc_card->version = CARD_VER_MMC_3;
		break;

	case 4:
		sd_mmc_card->version = CARD_VER_MMC_4;
  401512:	2240      	movs	r2, #64	; 0x40
  401514:	741a      	strb	r2, [r3, #16]
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  401516:	7d5a      	ldrb	r2, [r3, #21]
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  401518:	f893 e019 	ldrb.w	lr, [r3, #25]
		break;
	}

	// Get MMC memory max transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
	unit = sd_mmc_trans_units[tran_speed & 0x7];
  40151c:	4963      	ldr	r1, [pc, #396]	; (4016ac <sd_mmc_check+0x5b4>)
	mul = mmc_trans_multipliers[(tran_speed >> 3) & 0xF];
  40151e:	4864      	ldr	r0, [pc, #400]	; (4016b0 <sd_mmc_check+0x5b8>)
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  401520:	f893 c018 	ldrb.w	ip, [r3, #24]
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  401524:	7e9d      	ldrb	r5, [r3, #26]
		break;
	}

	// Get MMC memory max transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
	unit = sd_mmc_trans_units[tran_speed & 0x7];
  401526:	f002 0807 	and.w	r8, r2, #7
	mul = mmc_trans_multipliers[(tran_speed >> 3) & 0xF];
  40152a:	f3c2 02c3 	ubfx	r2, r2, #3, #4
	sd_mmc_card->clock = unit * mul * 1000;
  40152e:	f851 1028 	ldr.w	r1, [r1, r8, lsl #2]
  401532:	f850 0022 	ldr.w	r0, [r0, r2, lsl #2]
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  401536:	ea4f 028e 	mov.w	r2, lr, lsl #2
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  40153a:	ea42 228c 	orr.w	r2, r2, ip, lsl #10
  40153e:	f44f 7e7a 	mov.w	lr, #1000	; 0x3e8
  401542:	fb0e f101 	mul.w	r1, lr, r1
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  401546:	ea42 1295 	orr.w	r2, r2, r5, lsr #6
  40154a:	fb00 f001 	mul.w	r0, r0, r1
	}
	value &=  ((uint32_t)1 << size) - 1;
  40154e:	f3c2 020b 	ubfx	r2, r2, #0, #12
	 * BLOCK_LEN = 2 ^ READ_BL_LEN      (READ_BL_LEN < 12)
	 * ----------------------------------------------------
	 * For high capacity SD/MMC card:
	 * memory capacity = SEC_COUNT * 512 byte
	 */
	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) != 0xFFF) {
  401552:	f640 71ff 	movw	r1, #4095	; 0xfff
  401556:	428a      	cmp	r2, r1

	// Get MMC memory max transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
	unit = sd_mmc_trans_units[tran_speed & 0x7];
	mul = mmc_trans_multipliers[(tran_speed >> 3) & 0xF];
	sd_mmc_card->clock = unit * mul * 1000;
  401558:	6018      	str	r0, [r3, #0]
	 * BLOCK_LEN = 2 ^ READ_BL_LEN      (READ_BL_LEN < 12)
	 * ----------------------------------------------------
	 * For high capacity SD/MMC card:
	 * memory capacity = SEC_COUNT * 512 byte
	 */
	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) != 0xFFF) {
  40155a:	d011      	beq.n	401580 <sd_mmc_check+0x488>
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  40155c:	7ed9      	ldrb	r1, [r3, #27]
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  40155e:	7f1d      	ldrb	r5, [r3, #28]
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	value &=  ((uint32_t)1 << size) - 1;
  401560:	7dd8      	ldrb	r0, [r3, #23]
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  401562:	0049      	lsls	r1, r1, #1
  401564:	ea41 11d5 	orr.w	r1, r1, r5, lsr #7
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	value &=  ((uint32_t)1 << size) - 1;
  401568:	f001 0107 	and.w	r1, r1, #7
		uint32_t blocknr = ((MMC_CSD_C_SIZE(sd_mmc_card->csd) + 1) *
  40156c:	3201      	adds	r2, #1
			(1 << (MMC_CSD_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
  40156e:	3102      	adds	r1, #2
	 * ----------------------------------------------------
	 * For high capacity SD/MMC card:
	 * memory capacity = SEC_COUNT * 512 byte
	 */
	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) != 0xFFF) {
		uint32_t blocknr = ((MMC_CSD_C_SIZE(sd_mmc_card->csd) + 1) *
  401570:	fa02 f101 	lsl.w	r1, r2, r1
			(1 << (MMC_CSD_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
		sd_mmc_card->capacity = blocknr *
  401574:	f000 020f 	and.w	r2, r0, #15
  401578:	fa01 f202 	lsl.w	r2, r1, r2
			(1 << MMC_CSD_READ_BL_LEN(sd_mmc_card->csd)) / 1024;
  40157c:	0a92      	lsrs	r2, r2, #10
	 * memory capacity = SEC_COUNT * 512 byte
	 */
	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) != 0xFFF) {
		uint32_t blocknr = ((MMC_CSD_C_SIZE(sd_mmc_card->csd) + 1) *
			(1 << (MMC_CSD_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
		sd_mmc_card->capacity = blocknr *
  40157e:	605a      	str	r2, [r3, #4]
		return false;
	}
	mmc_decode_csd();
	// Select the and put it into Transfer Mode
	if (!driver_send_cmd(SDMMC_CMD7_SELECT_CARD_CMD,
			(uint32_t)sd_mmc_card->rca << 16)) {
  401580:	8999      	ldrh	r1, [r3, #12]
	if (!sd_mmc_cmd9_mci()) {
		return false;
	}
	mmc_decode_csd();
	// Select the and put it into Transfer Mode
	if (!driver_send_cmd(SDMMC_CMD7_SELECT_CARD_CMD,
  401582:	f243 1007 	movw	r0, #12551	; 0x3107
  401586:	0409      	lsls	r1, r1, #16
  401588:	47b0      	blx	r6
  40158a:	2800      	cmp	r0, #0
  40158c:	f43f aebb 	beq.w	401306 <sd_mmc_check+0x20e>
			(uint32_t)sd_mmc_card->rca << 16)) {
		return false;
	}
	if (sd_mmc_card->version >= CARD_VER_MMC_4) {
  401590:	683b      	ldr	r3, [r7, #0]
  401592:	7c1b      	ldrb	r3, [r3, #16]
  401594:	2b3f      	cmp	r3, #63	; 0x3f
  401596:	f240 80b1 	bls.w	4016fc <sd_mmc_check+0x604>
{
	uint16_t i;
	uint32_t ext_csd;
	uint32_t sec_count;

	if (!driver_adtc_start(MMC_CMD8_SEND_EXT_CSD, 0,
  40159a:	2100      	movs	r1, #0
  40159c:	9100      	str	r1, [sp, #0]
  40159e:	4845      	ldr	r0, [pc, #276]	; (4016b4 <sd_mmc_check+0x5bc>)
  4015a0:	4d45      	ldr	r5, [pc, #276]	; (4016b8 <sd_mmc_check+0x5c0>)
  4015a2:	f44f 7200 	mov.w	r2, #512	; 0x200
  4015a6:	2301      	movs	r3, #1
  4015a8:	47a8      	blx	r5
  4015aa:	2800      	cmp	r0, #0
  4015ac:	f43f aeab 	beq.w	401306 <sd_mmc_check+0x20e>
  4015b0:	f8df 8124 	ldr.w	r8, [pc, #292]	; 4016d8 <sd_mmc_check+0x5e0>
  4015b4:	2532      	movs	r5, #50	; 0x32
	// Note: The read access is done in byte to avoid a buffer
	// of EXT_CSD_BSIZE Byte in stack.

	// Read card type
	for (i = 0; i < (EXT_CSD_CARD_TYPE_INDEX + 4) / 4; i++) {
		if (!driver_read_word(&ext_csd)) {
  4015b6:	a803      	add	r0, sp, #12
  4015b8:	47c0      	blx	r8
  4015ba:	3d01      	subs	r5, #1
  4015bc:	b2ad      	uxth	r5, r5
  4015be:	2800      	cmp	r0, #0
  4015c0:	f43f aea1 	beq.w	401306 <sd_mmc_check+0x20e>
	//** Read and decode Extended Extended CSD
	// Note: The read access is done in byte to avoid a buffer
	// of EXT_CSD_BSIZE Byte in stack.

	// Read card type
	for (i = 0; i < (EXT_CSD_CARD_TYPE_INDEX + 4) / 4; i++) {
  4015c4:	2d00      	cmp	r5, #0
  4015c6:	d1f6      	bne.n	4015b6 <sd_mmc_check+0x4be>
		}
	}
	*b_authorize_high_speed = (ext_csd >> ((EXT_CSD_CARD_TYPE_INDEX % 4) * 8))
			& MMC_CTYPE_52MHZ;

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
  4015c8:	683b      	ldr	r3, [r7, #0]
	for (i = 0; i < (EXT_CSD_CARD_TYPE_INDEX + 4) / 4; i++) {
		if (!driver_read_word(&ext_csd)) {
			return false;
		}
	}
	*b_authorize_high_speed = (ext_csd >> ((EXT_CSD_CARD_TYPE_INDEX % 4) * 8))
  4015ca:	9a03      	ldr	r2, [sp, #12]
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  4015cc:	7e5d      	ldrb	r5, [r3, #25]
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  4015ce:	7e18      	ldrb	r0, [r3, #24]
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  4015d0:	7e99      	ldrb	r1, [r3, #26]
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  4015d2:	00ab      	lsls	r3, r5, #2
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  4015d4:	ea43 2380 	orr.w	r3, r3, r0, lsl #10
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  4015d8:	ea43 1191 	orr.w	r1, r3, r1, lsr #6
	}
	value &=  ((uint32_t)1 << size) - 1;
  4015dc:	f3c1 010b 	ubfx	r1, r1, #0, #12
			& MMC_CTYPE_52MHZ;

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
  4015e0:	f640 73ff 	movw	r3, #4095	; 0xfff
	for (i = 0; i < (EXT_CSD_CARD_TYPE_INDEX + 4) / 4; i++) {
		if (!driver_read_word(&ext_csd)) {
			return false;
		}
	}
	*b_authorize_high_speed = (ext_csd >> ((EXT_CSD_CARD_TYPE_INDEX % 4) * 8))
  4015e4:	f002 0202 	and.w	r2, r2, #2
			& MMC_CTYPE_52MHZ;

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
  4015e8:	4299      	cmp	r1, r3
	for (i = 0; i < (EXT_CSD_CARD_TYPE_INDEX + 4) / 4; i++) {
		if (!driver_read_word(&ext_csd)) {
			return false;
		}
	}
	*b_authorize_high_speed = (ext_csd >> ((EXT_CSD_CARD_TYPE_INDEX % 4) * 8))
  4015ea:	fa5f fa82 	uxtb.w	sl, r2
			& MMC_CTYPE_52MHZ;

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
  4015ee:	f04f 0532 	mov.w	r5, #50	; 0x32
  4015f2:	f10d 0b10 	add.w	fp, sp, #16
  4015f6:	d073      	beq.n	4016e0 <sd_mmc_check+0x5e8>
			}
		}
		sd_mmc_card->capacity = sec_count / 2;
	}
	for (; i < EXT_CSD_BSIZE / 4; i++) {
		if (!driver_read_word(&sec_count)) {
  4015f8:	4658      	mov	r0, fp
  4015fa:	47c0      	blx	r8
				return false;
			}
		}
		sd_mmc_card->capacity = sec_count / 2;
	}
	for (; i < EXT_CSD_BSIZE / 4; i++) {
  4015fc:	3501      	adds	r5, #1
  4015fe:	b2ad      	uxth	r5, r5
		if (!driver_read_word(&sec_count)) {
  401600:	2800      	cmp	r0, #0
  401602:	f43f ae80 	beq.w	401306 <sd_mmc_check+0x20e>
				return false;
			}
		}
		sd_mmc_card->capacity = sec_count / 2;
	}
	for (; i < EXT_CSD_BSIZE / 4; i++) {
  401606:	2d7f      	cmp	r5, #127	; 0x7f
  401608:	d9f6      	bls.n	4015f8 <sd_mmc_check+0x500>
		// For MMC 4.0 Higher version
		// Get EXT_CSD
		if (!mmc_cmd8(&b_authorize_high_speed)) {
			return false;
		}
		if (4 <= driver_get_bus_width(sd_mmc_slot_sel)) {
  40160a:	4d2c      	ldr	r5, [pc, #176]	; (4016bc <sd_mmc_check+0x5c4>)
  40160c:	f8df 80cc 	ldr.w	r8, [pc, #204]	; 4016dc <sd_mmc_check+0x5e4>
  401610:	7828      	ldrb	r0, [r5, #0]
  401612:	47c0      	blx	r8
  401614:	2803      	cmp	r0, #3
  401616:	d918      	bls.n	40164a <sd_mmc_check+0x552>
			// Enable more bus width
			if (!mmc_cmd6_set_bus_width(driver_get_bus_width(sd_mmc_slot_sel))) {
  401618:	7828      	ldrb	r0, [r5, #0]
  40161a:	47c0      	blx	r8
 */
static bool mmc_cmd6_set_bus_width(uint8_t bus_width)
{
	uint32_t arg;

	switch (bus_width) {
  40161c:	2804      	cmp	r0, #4
		if (!mmc_cmd8(&b_authorize_high_speed)) {
			return false;
		}
		if (4 <= driver_get_bus_width(sd_mmc_slot_sel)) {
			// Enable more bus width
			if (!mmc_cmd6_set_bus_width(driver_get_bus_width(sd_mmc_slot_sel))) {
  40161e:	4680      	mov	r8, r0
 */
static bool mmc_cmd6_set_bus_width(uint8_t bus_width)
{
	uint32_t arg;

	switch (bus_width) {
  401620:	d070      	beq.n	401704 <sd_mmc_check+0x60c>
		arg = MMC_CMD6_ACCESS_SET_BITS
				| MMC_CMD6_INDEX_BUS_WIDTH
				| MMC_CMD6_VALUE_BUS_WIDTH_4BIT;
		break;
	default:
		arg = MMC_CMD6_ACCESS_SET_BITS
  401622:	4927      	ldr	r1, [pc, #156]	; (4016c0 <sd_mmc_check+0x5c8>)
  401624:	4b27      	ldr	r3, [pc, #156]	; (4016c4 <sd_mmc_check+0x5cc>)
  401626:	2808      	cmp	r0, #8
  401628:	bf18      	it	ne
  40162a:	4619      	movne	r1, r3
				| MMC_CMD6_INDEX_BUS_WIDTH
				| MMC_CMD6_VALUE_BUS_WIDTH_1BIT;
		break;
	}
	if (!driver_send_cmd(MMC_CMD6_SWITCH, arg)) {
  40162c:	f243 1006 	movw	r0, #12550	; 0x3106
  401630:	47b0      	blx	r6
  401632:	2800      	cmp	r0, #0
  401634:	f43f ae68 	beq.w	401308 <sd_mmc_check+0x210>
		return false;
	}
	if (driver_get_response() & CARD_STATUS_SWITCH_ERROR) {
  401638:	47c8      	blx	r9
  40163a:	0602      	lsls	r2, r0, #24
  40163c:	f53f ae64 	bmi.w	401308 <sd_mmc_check+0x210>
		// No supported, it is not a protocol error
		sd_mmc_debug("%s: CMD6 CARD_STATUS_SWITCH_ERROR\n\r", __func__);
		return false;
	}
	sd_mmc_card->bus_width = bus_width;
  401640:	683b      	ldr	r3, [r7, #0]
			// Enable more bus width
			if (!mmc_cmd6_set_bus_width(driver_get_bus_width(sd_mmc_slot_sel))) {
				return false;
			}
			// Reinitialize the slot with the bus width
			sd_mmc_configure_slot();
  401642:	4a21      	ldr	r2, [pc, #132]	; (4016c8 <sd_mmc_check+0x5d0>)
	if (driver_get_response() & CARD_STATUS_SWITCH_ERROR) {
		// No supported, it is not a protocol error
		sd_mmc_debug("%s: CMD6 CARD_STATUS_SWITCH_ERROR\n\r", __func__);
		return false;
	}
	sd_mmc_card->bus_width = bus_width;
  401644:	f883 8011 	strb.w	r8, [r3, #17]
			// Enable more bus width
			if (!mmc_cmd6_set_bus_width(driver_get_bus_width(sd_mmc_slot_sel))) {
				return false;
			}
			// Reinitialize the slot with the bus width
			sd_mmc_configure_slot();
  401648:	4790      	blx	r2
		}
		if (driver_is_high_speed_capable() && b_authorize_high_speed) {
  40164a:	4b20      	ldr	r3, [pc, #128]	; (4016cc <sd_mmc_check+0x5d4>)
  40164c:	4798      	blx	r3
  40164e:	b110      	cbz	r0, 401656 <sd_mmc_check+0x55e>
  401650:	f1ba 0f00 	cmp.w	sl, #0
  401654:	d158      	bne.n	401708 <sd_mmc_check+0x610>
		arg = MMC_CMD6_ACCESS_SET_BITS
				| MMC_CMD6_INDEX_BUS_WIDTH
				| MMC_CMD6_VALUE_BUS_WIDTH_4BIT;
		break;
	default:
		arg = MMC_CMD6_ACCESS_SET_BITS
  401656:	f04f 080a 	mov.w	r8, #10
		// Retry is a WORKAROUND for no compliance card (Atmel Internal ref. MMC19):
		// These cards seem not ready immediatly
		// after the end of busy of mmc_cmd6_set_high_speed()

		// Set default block size
		if (driver_send_cmd(SDMMC_CMD16_SET_BLOCKLEN, SD_MMC_BLOCK_SIZE)) {
  40165a:	f241 1010 	movw	r0, #4368	; 0x1110
  40165e:	f44f 7100 	mov.w	r1, #512	; 0x200
  401662:	47b0      	blx	r6
  401664:	f108 38ff 	add.w	r8, r8, #4294967295
  401668:	2800      	cmp	r0, #0
  40166a:	d16a      	bne.n	401742 <sd_mmc_check+0x64a>
		// Reinitialize the slot with the new speed
		sd_mmc_configure_slot();
	}

	uint8_t retry = 10;
	while (retry--) {
  40166c:	f018 08ff 	ands.w	r8, r8, #255	; 0xff
  401670:	f43f ae4a 	beq.w	401308 <sd_mmc_check+0x210>
  401674:	e7f1      	b.n	40165a <sd_mmc_check+0x562>
			sd_mmc_card->version = CARD_VER_SD_2_0;
		}
		break;

	default:
		sd_mmc_card->version = CARD_VER_SD_1_0;
  401676:	f8da 3000 	ldr.w	r3, [sl]
  40167a:	2210      	movs	r2, #16
  40167c:	741a      	strb	r2, [r3, #16]
  40167e:	e5e9      	b.n	401254 <sd_mmc_check+0x15c>
	case SD_SCR_SD_SPEC_1_0_01:
		sd_mmc_card->version = CARD_VER_SD_1_0;
		break;

	case SD_SCR_SD_SPEC_1_10:
		sd_mmc_card->version = CARD_VER_SD_1_10;
  401680:	f8da 3000 	ldr.w	r3, [sl]
  401684:	221a      	movs	r2, #26
  401686:	741a      	strb	r2, [r3, #16]
  401688:	e5e4      	b.n	401254 <sd_mmc_check+0x15c>
	case 2:
		sd_mmc_card->version = CARD_VER_MMC_2_2;
		break;

	case 3:
		sd_mmc_card->version = CARD_VER_MMC_3;
  40168a:	2230      	movs	r2, #48	; 0x30
  40168c:	741a      	strb	r2, [r3, #16]
  40168e:	e742      	b.n	401516 <sd_mmc_check+0x41e>
  401690:	401f8000 	.word	0x401f8000
  401694:	20000f50 	.word	0x20000f50
  401698:	004010a9 	.word	0x004010a9
  40169c:	00081106 	.word	0x00081106
  4016a0:	80ffff01 	.word	0x80ffff01
  4016a4:	00402041 	.word	0x00402041
  4016a8:	004020a9 	.word	0x004020a9
  4016ac:	00406a74 	.word	0x00406a74
  4016b0:	00406a90 	.word	0x00406a90
  4016b4:	00081108 	.word	0x00081108
  4016b8:	00401eed 	.word	0x00401eed
  4016bc:	20000f56 	.word	0x20000f56
  4016c0:	01b70200 	.word	0x01b70200
  4016c4:	01b70000 	.word	0x01b70000
  4016c8:	00400f7d 	.word	0x00400f7d
  4016cc:	00401ded 	.word	0x00401ded
  4016d0:	00401ec1 	.word	0x00401ec1
  4016d4:	00401e95 	.word	0x00401e95
  4016d8:	00401f9d 	.word	0x00401f9d
  4016dc:	00401de1 	.word	0x00401de1

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
		// For high capacity SD/MMC card,
		// memory capacity = SEC_COUNT * 512 byte
		for (; i <(EXT_CSD_SEC_COUNT_INDEX + 4) / 4; i++) {
			if (!driver_read_word(&sec_count)) {
  4016e0:	4658      	mov	r0, fp
  4016e2:	47c0      	blx	r8
			& MMC_CTYPE_52MHZ;

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
		// For high capacity SD/MMC card,
		// memory capacity = SEC_COUNT * 512 byte
		for (; i <(EXT_CSD_SEC_COUNT_INDEX + 4) / 4; i++) {
  4016e4:	3501      	adds	r5, #1
  4016e6:	b2ad      	uxth	r5, r5
			if (!driver_read_word(&sec_count)) {
  4016e8:	2800      	cmp	r0, #0
  4016ea:	f43f ae0c 	beq.w	401306 <sd_mmc_check+0x20e>
			& MMC_CTYPE_52MHZ;

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
		// For high capacity SD/MMC card,
		// memory capacity = SEC_COUNT * 512 byte
		for (; i <(EXT_CSD_SEC_COUNT_INDEX + 4) / 4; i++) {
  4016ee:	2d36      	cmp	r5, #54	; 0x36
  4016f0:	d1f6      	bne.n	4016e0 <sd_mmc_check+0x5e8>
			if (!driver_read_word(&sec_count)) {
				return false;
			}
		}
		sd_mmc_card->capacity = sec_count / 2;
  4016f2:	9a04      	ldr	r2, [sp, #16]
  4016f4:	683b      	ldr	r3, [r7, #0]
  4016f6:	0852      	lsrs	r2, r2, #1
  4016f8:	605a      	str	r2, [r3, #4]
  4016fa:	e77d      	b.n	4015f8 <sd_mmc_check+0x500>
			// Reinitialize the slot with the new speed
			sd_mmc_configure_slot();
		}
	} else {
		// Reinitialize the slot with the new speed
		sd_mmc_configure_slot();
  4016fc:	4b12      	ldr	r3, [pc, #72]	; (401748 <sd_mmc_check+0x650>)
  4016fe:	4d13      	ldr	r5, [pc, #76]	; (40174c <sd_mmc_check+0x654>)
  401700:	4798      	blx	r3
  401702:	e7a8      	b.n	401656 <sd_mmc_check+0x55e>
		arg = MMC_CMD6_ACCESS_SET_BITS
				| MMC_CMD6_INDEX_BUS_WIDTH
				| MMC_CMD6_VALUE_BUS_WIDTH_8BIT;
		break;
	case 4:
		arg = MMC_CMD6_ACCESS_SET_BITS
  401704:	4912      	ldr	r1, [pc, #72]	; (401750 <sd_mmc_check+0x658>)
  401706:	e791      	b.n	40162c <sd_mmc_check+0x534>
 *
 * \return true if success, otherwise false
 */
static bool mmc_cmd6_set_high_speed(void)
{
	if (!driver_send_cmd(MMC_CMD6_SWITCH,
  401708:	f243 1006 	movw	r0, #12550	; 0x3106
  40170c:	4911      	ldr	r1, [pc, #68]	; (401754 <sd_mmc_check+0x65c>)
  40170e:	47b0      	blx	r6
  401710:	2800      	cmp	r0, #0
  401712:	f43f adf9 	beq.w	401308 <sd_mmc_check+0x210>
			MMC_CMD6_ACCESS_WRITE_BYTE
			| MMC_CMD6_INDEX_HS_TIMING
			| MMC_CMD6_VALUE_HS_TIMING_ENABLE)) {
		return false;
	}
	if (driver_get_response() & CARD_STATUS_SWITCH_ERROR) {
  401716:	47c8      	blx	r9
  401718:	0603      	lsls	r3, r0, #24
  40171a:	f53f adf5 	bmi.w	401308 <sd_mmc_check+0x210>
		// No supported, it is not a protocol error
		sd_mmc_debug("%s: CMD6 CARD_STATUS_SWITCH_ERROR\n\r", __func__);
		return false;
	}
	sd_mmc_card->high_speed = 1;
  40171e:	683b      	ldr	r3, [r7, #0]
	sd_mmc_card->clock = 52000000lu;
  401720:	4a0d      	ldr	r2, [pc, #52]	; (401758 <sd_mmc_check+0x660>)
  401722:	601a      	str	r2, [r3, #0]
	if (driver_get_response() & CARD_STATUS_SWITCH_ERROR) {
		// No supported, it is not a protocol error
		sd_mmc_debug("%s: CMD6 CARD_STATUS_SWITCH_ERROR\n\r", __func__);
		return false;
	}
	sd_mmc_card->high_speed = 1;
  401724:	2201      	movs	r2, #1
  401726:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
			// Enable HS
			if (!mmc_cmd6_set_high_speed()) {
				return false;
			}
			// Reinitialize the slot with the new speed
			sd_mmc_configure_slot();
  40172a:	4b07      	ldr	r3, [pc, #28]	; (401748 <sd_mmc_check+0x650>)
  40172c:	4798      	blx	r3
  40172e:	e792      	b.n	401656 <sd_mmc_check+0x55e>
	case 0:
		sd_mmc_card->version = CARD_VER_MMC_1_2;
		break;

	case 1:
		sd_mmc_card->version = CARD_VER_MMC_1_4;
  401730:	2214      	movs	r2, #20
  401732:	741a      	strb	r2, [r3, #16]
  401734:	e6ef      	b.n	401516 <sd_mmc_check+0x41e>

	// Get MMC System Specification version supported by the card
	switch (MMC_CSD_SPEC_VERS(sd_mmc_card->csd)) {
	default:
	case 0:
		sd_mmc_card->version = CARD_VER_MMC_1_2;
  401736:	2212      	movs	r2, #18
  401738:	741a      	strb	r2, [r3, #16]
  40173a:	e6ec      	b.n	401516 <sd_mmc_check+0x41e>
	case 1:
		sd_mmc_card->version = CARD_VER_MMC_1_4;
		break;

	case 2:
		sd_mmc_card->version = CARD_VER_MMC_2_2;
  40173c:	2222      	movs	r2, #34	; 0x22
  40173e:	741a      	strb	r2, [r3, #16]
  401740:	e6e9      	b.n	401516 <sd_mmc_check+0x41e>
  401742:	683a      	ldr	r2, [r7, #0]
  401744:	e5bd      	b.n	4012c2 <sd_mmc_check+0x1ca>
  401746:	bf00      	nop
  401748:	00400f7d 	.word	0x00400f7d
  40174c:	20000f56 	.word	0x20000f56
  401750:	01b70100 	.word	0x01b70100
  401754:	03b90100 	.word	0x03b90100
  401758:	03197500 	.word	0x03197500

0040175c <sd_mmc_get_type>:
	sd_mmc_deselect_slot();
	return SD_MMC_ERR_UNUSABLE;
}

card_type_t sd_mmc_get_type(uint8_t slot)
{
  40175c:	b508      	push	{r3, lr}
 * \retval SD_MMC_INIT_ONGOING Card initialization requested
 * \retval SD_MMC_OK           Card present
 */
static sd_mmc_err_t sd_mmc_select_slot(uint8_t slot)
{
	if (slot >= SD_MMC_MEM_CNT) {
  40175e:	b108      	cbz	r0, 401764 <sd_mmc_get_type+0x8>
}

card_type_t sd_mmc_get_type(uint8_t slot)
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
		return CARD_TYPE_UNKNOWN;
  401760:	2000      	movs	r0, #0
  401762:	bd08      	pop	{r3, pc}
  401764:	4b08      	ldr	r3, [pc, #32]	; (401788 <sd_mmc_get_type+0x2c>)
  401766:	4798      	blx	r3
	return SD_MMC_ERR_UNUSABLE;
}

card_type_t sd_mmc_get_type(uint8_t slot)
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
  401768:	2800      	cmp	r0, #0
  40176a:	d1f9      	bne.n	401760 <sd_mmc_get_type+0x4>
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  40176c:	4b07      	ldr	r3, [pc, #28]	; (40178c <sd_mmc_get_type+0x30>)
  40176e:	781b      	ldrb	r3, [r3, #0]
  401770:	b11b      	cbz	r3, 40177a <sd_mmc_get_type+0x1e>
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
		return CARD_TYPE_UNKNOWN;
	}
	sd_mmc_deselect_slot();
	return sd_mmc_card->type;
  401772:	4b07      	ldr	r3, [pc, #28]	; (401790 <sd_mmc_get_type+0x34>)
  401774:	681b      	ldr	r3, [r3, #0]
  401776:	7bd8      	ldrb	r0, [r3, #15]
}
  401778:	bd08      	pop	{r3, pc}
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
		driver_deselect_device(sd_mmc_slot_sel);
  40177a:	4b06      	ldr	r3, [pc, #24]	; (401794 <sd_mmc_get_type+0x38>)
  40177c:	4798      	blx	r3
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
		return CARD_TYPE_UNKNOWN;
	}
	sd_mmc_deselect_slot();
	return sd_mmc_card->type;
  40177e:	4b04      	ldr	r3, [pc, #16]	; (401790 <sd_mmc_get_type+0x34>)
  401780:	681b      	ldr	r3, [r3, #0]
  401782:	7bd8      	ldrb	r0, [r3, #15]
}
  401784:	bd08      	pop	{r3, pc}
  401786:	bf00      	nop
  401788:	00400fa9 	.word	0x00400fa9
  40178c:	20000f56 	.word	0x20000f56
  401790:	20000f50 	.word	0x20000f50
  401794:	00401e71 	.word	0x00401e71

00401798 <sd_mmc_get_capacity>:
	sd_mmc_deselect_slot();
	return sd_mmc_card->version;
}

uint32_t sd_mmc_get_capacity(uint8_t slot)
{
  401798:	b508      	push	{r3, lr}
 * \retval SD_MMC_INIT_ONGOING Card initialization requested
 * \retval SD_MMC_OK           Card present
 */
static sd_mmc_err_t sd_mmc_select_slot(uint8_t slot)
{
	if (slot >= SD_MMC_MEM_CNT) {
  40179a:	b108      	cbz	r0, 4017a0 <sd_mmc_get_capacity+0x8>
}

uint32_t sd_mmc_get_capacity(uint8_t slot)
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
		return 0;
  40179c:	2000      	movs	r0, #0
  40179e:	bd08      	pop	{r3, pc}
  4017a0:	4b08      	ldr	r3, [pc, #32]	; (4017c4 <sd_mmc_get_capacity+0x2c>)
  4017a2:	4798      	blx	r3
	return sd_mmc_card->version;
}

uint32_t sd_mmc_get_capacity(uint8_t slot)
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
  4017a4:	2800      	cmp	r0, #0
  4017a6:	d1f9      	bne.n	40179c <sd_mmc_get_capacity+0x4>
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  4017a8:	4b07      	ldr	r3, [pc, #28]	; (4017c8 <sd_mmc_get_capacity+0x30>)
  4017aa:	781b      	ldrb	r3, [r3, #0]
  4017ac:	b11b      	cbz	r3, 4017b6 <sd_mmc_get_capacity+0x1e>
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
		return 0;
	}
	sd_mmc_deselect_slot();
	return sd_mmc_card->capacity;
  4017ae:	4b07      	ldr	r3, [pc, #28]	; (4017cc <sd_mmc_get_capacity+0x34>)
  4017b0:	681b      	ldr	r3, [r3, #0]
  4017b2:	6858      	ldr	r0, [r3, #4]
}
  4017b4:	bd08      	pop	{r3, pc}
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
		driver_deselect_device(sd_mmc_slot_sel);
  4017b6:	4b06      	ldr	r3, [pc, #24]	; (4017d0 <sd_mmc_get_capacity+0x38>)
  4017b8:	4798      	blx	r3
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
		return 0;
	}
	sd_mmc_deselect_slot();
	return sd_mmc_card->capacity;
  4017ba:	4b04      	ldr	r3, [pc, #16]	; (4017cc <sd_mmc_get_capacity+0x34>)
  4017bc:	681b      	ldr	r3, [r3, #0]
  4017be:	6858      	ldr	r0, [r3, #4]
}
  4017c0:	bd08      	pop	{r3, pc}
  4017c2:	bf00      	nop
  4017c4:	00400fa9 	.word	0x00400fa9
  4017c8:	20000f56 	.word	0x20000f56
  4017cc:	20000f50 	.word	0x20000f50
  4017d0:	00401e71 	.word	0x00401e71

004017d4 <sd_mmc_is_write_protected>:
			== SD_MMC_0_WP_DETECT_VALUE) {
		return true;
	}
#endif
	return false;
}
  4017d4:	2000      	movs	r0, #0
  4017d6:	4770      	bx	lr

004017d8 <sd_mmc_init_read_blocks>:

sd_mmc_err_t sd_mmc_init_read_blocks(uint8_t slot, uint32_t start,
		uint16_t nb_block)
{
  4017d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4017dc:	468b      	mov	fp, r1
  4017de:	b083      	sub	sp, #12
  4017e0:	4692      	mov	sl, r2
 * \retval SD_MMC_INIT_ONGOING Card initialization requested
 * \retval SD_MMC_OK           Card present
 */
static sd_mmc_err_t sd_mmc_select_slot(uint8_t slot)
{
	if (slot >= SD_MMC_MEM_CNT) {
  4017e2:	b128      	cbz	r0, 4017f0 <sd_mmc_init_read_blocks+0x18>
		return SD_MMC_ERR_SLOT;
  4017e4:	f04f 0904 	mov.w	r9, #4
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}
  4017e8:	4648      	mov	r0, r9
  4017ea:	b003      	add	sp, #12
  4017ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4017f0:	4b26      	ldr	r3, [pc, #152]	; (40188c <sd_mmc_init_read_blocks+0xb4>)
  4017f2:	4798      	blx	r3
{
	sd_mmc_err_t sd_mmc_err;
	uint32_t cmd, arg, resp;

	sd_mmc_err = sd_mmc_select_slot(slot);
	if (sd_mmc_err != SD_MMC_OK) {
  4017f4:	4681      	mov	r9, r0
  4017f6:	2800      	cmp	r0, #0
  4017f8:	d1f6      	bne.n	4017e8 <sd_mmc_init_read_blocks+0x10>
  4017fa:	4c25      	ldr	r4, [pc, #148]	; (401890 <sd_mmc_init_read_blocks+0xb8>)
  4017fc:	4d25      	ldr	r5, [pc, #148]	; (401894 <sd_mmc_init_read_blocks+0xbc>)
  4017fe:	4e26      	ldr	r6, [pc, #152]	; (401898 <sd_mmc_init_read_blocks+0xc0>)
			if (!driver_send_cmd(SDMMC_MCI_CMD13_SEND_STATUS,
					(uint32_t)sd_mmc_card->rca << 16)) {
				return false;
			}
			// Check busy flag
			if (driver_get_response() & CARD_STATUS_READY_FOR_DATA) {
  401800:	4f26      	ldr	r7, [pc, #152]	; (40189c <sd_mmc_init_read_blocks+0xc4>)
  401802:	e004      	b.n	40180e <sd_mmc_init_read_blocks+0x36>
  401804:	47b8      	blx	r7
  401806:	05c2      	lsls	r2, r0, #23
  401808:	d414      	bmi.n	401834 <sd_mmc_init_read_blocks+0x5c>
				break;
			}
		}
		if (nec_timeout-- == 0) {
  40180a:	3c01      	subs	r4, #1
  40180c:	d009      	beq.n	401822 <sd_mmc_init_read_blocks+0x4a>
			if (!(driver_get_response() & 0xFF)) {
				break;
			}
		} else {
			if (!driver_send_cmd(SDMMC_MCI_CMD13_SEND_STATUS,
					(uint32_t)sd_mmc_card->rca << 16)) {
  40180e:	682b      	ldr	r3, [r5, #0]
				return false;
			}
			// Check busy flag
			if (driver_get_response() & CARD_STATUS_READY_FOR_DATA) {
  401810:	f8df 8088 	ldr.w	r8, [pc, #136]	; 40189c <sd_mmc_init_read_blocks+0xc4>
			if (!(driver_get_response() & 0xFF)) {
				break;
			}
		} else {
			if (!driver_send_cmd(SDMMC_MCI_CMD13_SEND_STATUS,
					(uint32_t)sd_mmc_card->rca << 16)) {
  401814:	8999      	ldrh	r1, [r3, #12]
			// Check busy flag
			if (!(driver_get_response() & 0xFF)) {
				break;
			}
		} else {
			if (!driver_send_cmd(SDMMC_MCI_CMD13_SEND_STATUS,
  401816:	f241 100d 	movw	r0, #4365	; 0x110d
  40181a:	0409      	lsls	r1, r1, #16
  40181c:	47b0      	blx	r6
  40181e:	2800      	cmp	r0, #0
  401820:	d1f0      	bne.n	401804 <sd_mmc_init_read_blocks+0x2c>
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  401822:	4b1f      	ldr	r3, [pc, #124]	; (4018a0 <sd_mmc_init_read_blocks+0xc8>)
  401824:	781b      	ldrb	r3, [r3, #0]
  401826:	b33b      	cbz	r3, 401878 <sd_mmc_init_read_blocks+0xa0>
		arg = (start * SD_MMC_BLOCK_SIZE);
	}

	if (!driver_adtc_start(cmd, arg, SD_MMC_BLOCK_SIZE, nb_block, true)) {
		sd_mmc_deselect_slot();
		return SD_MMC_ERR_COMM;
  401828:	f04f 0905 	mov.w	r9, #5
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}
  40182c:	4648      	mov	r0, r9
  40182e:	b003      	add	sp, #12
  401830:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  401834:	682b      	ldr	r3, [r5, #0]
	}

	if (nb_block > 1) {
		cmd = SDMMC_CMD18_READ_MULTIPLE_BLOCK;
	} else {
		cmd = SDMMC_CMD17_READ_SINGLE_BLOCK;
  401836:	481b      	ldr	r0, [pc, #108]	; (4018a4 <sd_mmc_init_read_blocks+0xcc>)
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  401838:	7bdb      	ldrb	r3, [r3, #15]
	}

	if (nb_block > 1) {
		cmd = SDMMC_CMD18_READ_MULTIPLE_BLOCK;
	} else {
		cmd = SDMMC_CMD17_READ_SINGLE_BLOCK;
  40183a:	4a1b      	ldr	r2, [pc, #108]	; (4018a8 <sd_mmc_init_read_blocks+0xd0>)
  40183c:	f1ba 0f01 	cmp.w	sl, #1
  401840:	bf98      	it	ls
  401842:	4610      	movls	r0, r2
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  401844:	071b      	lsls	r3, r3, #28
  401846:	d401      	bmi.n	40184c <sd_mmc_init_read_blocks+0x74>
		arg = start;
	} else {
		arg = (start * SD_MMC_BLOCK_SIZE);
  401848:	ea4f 2b4b 	mov.w	fp, fp, lsl #9
	}

	if (!driver_adtc_start(cmd, arg, SD_MMC_BLOCK_SIZE, nb_block, true)) {
  40184c:	2301      	movs	r3, #1
  40184e:	9300      	str	r3, [sp, #0]
  401850:	4659      	mov	r1, fp
  401852:	f44f 7200 	mov.w	r2, #512	; 0x200
  401856:	4653      	mov	r3, sl
  401858:	4c14      	ldr	r4, [pc, #80]	; (4018ac <sd_mmc_init_read_blocks+0xd4>)
  40185a:	47a0      	blx	r4
  40185c:	2800      	cmp	r0, #0
  40185e:	d0e0      	beq.n	401822 <sd_mmc_init_read_blocks+0x4a>
		sd_mmc_deselect_slot();
		return SD_MMC_ERR_COMM;
	}
	// Check response
	if (sd_mmc_is_mci()) {
		resp = driver_get_response();
  401860:	47c0      	blx	r8
		if (resp & CARD_STATUS_ERR_RD_WR) {
  401862:	4b13      	ldr	r3, [pc, #76]	; (4018b0 <sd_mmc_init_read_blocks+0xd8>)
  401864:	4003      	ands	r3, r0
  401866:	2b00      	cmp	r3, #0
  401868:	d1db      	bne.n	401822 <sd_mmc_init_read_blocks+0x4a>
					__func__, (int)SDMMC_CMD_GET_INDEX(cmd), resp);
			sd_mmc_deselect_slot();
			return SD_MMC_ERR_COMM;
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
  40186a:	4a12      	ldr	r2, [pc, #72]	; (4018b4 <sd_mmc_init_read_blocks+0xdc>)
	sd_mmc_nb_block_to_tranfer = nb_block;
  40186c:	4b12      	ldr	r3, [pc, #72]	; (4018b8 <sd_mmc_init_read_blocks+0xe0>)
					__func__, (int)SDMMC_CMD_GET_INDEX(cmd), resp);
			sd_mmc_deselect_slot();
			return SD_MMC_ERR_COMM;
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
  40186e:	f8a2 a000 	strh.w	sl, [r2]
	sd_mmc_nb_block_to_tranfer = nb_block;
  401872:	f8a3 a000 	strh.w	sl, [r3]
	return SD_MMC_OK;
  401876:	e7b7      	b.n	4017e8 <sd_mmc_init_read_blocks+0x10>
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
		driver_deselect_device(sd_mmc_slot_sel);
  401878:	2000      	movs	r0, #0
  40187a:	4b10      	ldr	r3, [pc, #64]	; (4018bc <sd_mmc_init_read_blocks+0xe4>)
  40187c:	4798      	blx	r3
	}

	// Wait for data ready status
	if (!sd_mmc_cmd13()) {
		sd_mmc_deselect_slot();
		return SD_MMC_ERR_COMM;
  40187e:	f04f 0905 	mov.w	r9, #5
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}
  401882:	4648      	mov	r0, r9
  401884:	b003      	add	sp, #12
  401886:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40188a:	bf00      	nop
  40188c:	00400fa9 	.word	0x00400fa9
  401890:	00030d41 	.word	0x00030d41
  401894:	20000f50 	.word	0x20000f50
  401898:	00401e95 	.word	0x00401e95
  40189c:	00401ec1 	.word	0x00401ec1
  4018a0:	20000f56 	.word	0x20000f56
  4018a4:	00101112 	.word	0x00101112
  4018a8:	00081111 	.word	0x00081111
  4018ac:	00401eed 	.word	0x00401eed
  4018b0:	e4580000 	.word	0xe4580000
  4018b4:	20000f54 	.word	0x20000f54
  4018b8:	20000f4c 	.word	0x20000f4c
  4018bc:	00401e71 	.word	0x00401e71

004018c0 <sd_mmc_start_read_blocks>:

sd_mmc_err_t sd_mmc_start_read_blocks(void *dest, uint16_t nb_block)
{
  4018c0:	b510      	push	{r4, lr}
	Assert(sd_mmc_nb_block_remaining >= nb_block);

	if (!driver_start_read_blocks(dest, nb_block)) {
  4018c2:	4b07      	ldr	r3, [pc, #28]	; (4018e0 <sd_mmc_start_read_blocks+0x20>)
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}

sd_mmc_err_t sd_mmc_start_read_blocks(void *dest, uint16_t nb_block)
{
  4018c4:	460c      	mov	r4, r1
	Assert(sd_mmc_nb_block_remaining >= nb_block);

	if (!driver_start_read_blocks(dest, nb_block)) {
  4018c6:	4798      	blx	r3
  4018c8:	4603      	mov	r3, r0
  4018ca:	b918      	cbnz	r0, 4018d4 <sd_mmc_start_read_blocks+0x14>
		sd_mmc_nb_block_remaining = 0;
  4018cc:	4a05      	ldr	r2, [pc, #20]	; (4018e4 <sd_mmc_start_read_blocks+0x24>)
  4018ce:	8013      	strh	r3, [r2, #0]
		return SD_MMC_ERR_COMM;
  4018d0:	2005      	movs	r0, #5
  4018d2:	bd10      	pop	{r4, pc}
	}
	sd_mmc_nb_block_remaining -= nb_block;
  4018d4:	4b03      	ldr	r3, [pc, #12]	; (4018e4 <sd_mmc_start_read_blocks+0x24>)
  4018d6:	881a      	ldrh	r2, [r3, #0]
  4018d8:	1b14      	subs	r4, r2, r4
  4018da:	801c      	strh	r4, [r3, #0]
	return SD_MMC_OK;
  4018dc:	2000      	movs	r0, #0
}
  4018de:	bd10      	pop	{r4, pc}
  4018e0:	00402041 	.word	0x00402041
  4018e4:	20000f54 	.word	0x20000f54

004018e8 <sd_mmc_wait_end_of_read_blocks>:

sd_mmc_err_t sd_mmc_wait_end_of_read_blocks(bool abort)
{
  4018e8:	b510      	push	{r4, lr}
	if (!driver_wait_end_of_read_blocks()) {
  4018ea:	4b12      	ldr	r3, [pc, #72]	; (401934 <sd_mmc_wait_end_of_read_blocks+0x4c>)
	sd_mmc_nb_block_remaining -= nb_block;
	return SD_MMC_OK;
}

sd_mmc_err_t sd_mmc_wait_end_of_read_blocks(bool abort)
{
  4018ec:	4604      	mov	r4, r0
	if (!driver_wait_end_of_read_blocks()) {
  4018ee:	4798      	blx	r3
  4018f0:	b908      	cbnz	r0, 4018f6 <sd_mmc_wait_end_of_read_blocks+0xe>
		return SD_MMC_ERR_COMM;
  4018f2:	2005      	movs	r0, #5
	if (!driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0)) {
		driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0);
	}
	sd_mmc_deselect_slot();
	return SD_MMC_OK;
}
  4018f4:	bd10      	pop	{r4, pc}
{
	if (!driver_wait_end_of_read_blocks()) {
		return SD_MMC_ERR_COMM;
	}
	if (abort) {
		sd_mmc_nb_block_remaining = 0;
  4018f6:	4b10      	ldr	r3, [pc, #64]	; (401938 <sd_mmc_wait_end_of_read_blocks+0x50>)
sd_mmc_err_t sd_mmc_wait_end_of_read_blocks(bool abort)
{
	if (!driver_wait_end_of_read_blocks()) {
		return SD_MMC_ERR_COMM;
	}
	if (abort) {
  4018f8:	b99c      	cbnz	r4, 401922 <sd_mmc_wait_end_of_read_blocks+0x3a>
		sd_mmc_nb_block_remaining = 0;
	} else if (sd_mmc_nb_block_remaining) {
  4018fa:	881b      	ldrh	r3, [r3, #0]
  4018fc:	b97b      	cbnz	r3, 40191e <sd_mmc_wait_end_of_read_blocks+0x36>
		return SD_MMC_OK;
	}

	// All blocks are transfered then stop read operation
	if (sd_mmc_nb_block_to_tranfer == 1) {
  4018fe:	4b0f      	ldr	r3, [pc, #60]	; (40193c <sd_mmc_wait_end_of_read_blocks+0x54>)
  401900:	881b      	ldrh	r3, [r3, #0]
  401902:	2b01      	cmp	r3, #1
  401904:	d005      	beq.n	401912 <sd_mmc_wait_end_of_read_blocks+0x2a>
		return SD_MMC_OK;
	}
	// WORKAROUND for no compliance card (Atmel Internal ref. !MMC7 !SD19):
	// The errors on this command must be ignored
	// and one retry can be necessary in SPI mode for no compliance card.
	if (!driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0)) {
  401906:	f243 100c 	movw	r0, #12556	; 0x310c
  40190a:	2100      	movs	r1, #0
  40190c:	4c0c      	ldr	r4, [pc, #48]	; (401940 <sd_mmc_wait_end_of_read_blocks+0x58>)
  40190e:	47a0      	blx	r4
  401910:	b150      	cbz	r0, 401928 <sd_mmc_wait_end_of_read_blocks+0x40>
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  401912:	4b0c      	ldr	r3, [pc, #48]	; (401944 <sd_mmc_wait_end_of_read_blocks+0x5c>)
  401914:	781b      	ldrb	r3, [r3, #0]
  401916:	b913      	cbnz	r3, 40191e <sd_mmc_wait_end_of_read_blocks+0x36>
		driver_deselect_device(sd_mmc_slot_sel);
  401918:	2000      	movs	r0, #0
  40191a:	4b0b      	ldr	r3, [pc, #44]	; (401948 <sd_mmc_wait_end_of_read_blocks+0x60>)
  40191c:	4798      	blx	r3

	// All blocks are transfered then stop read operation
	if (sd_mmc_nb_block_to_tranfer == 1) {
		// Single block transfer, then nothing to do
		sd_mmc_deselect_slot();
		return SD_MMC_OK;
  40191e:	2000      	movs	r0, #0
  401920:	bd10      	pop	{r4, pc}
{
	if (!driver_wait_end_of_read_blocks()) {
		return SD_MMC_ERR_COMM;
	}
	if (abort) {
		sd_mmc_nb_block_remaining = 0;
  401922:	2200      	movs	r2, #0
  401924:	801a      	strh	r2, [r3, #0]
  401926:	e7ea      	b.n	4018fe <sd_mmc_wait_end_of_read_blocks+0x16>
	}
	// WORKAROUND for no compliance card (Atmel Internal ref. !MMC7 !SD19):
	// The errors on this command must be ignored
	// and one retry can be necessary in SPI mode for no compliance card.
	if (!driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0)) {
		driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0);
  401928:	4601      	mov	r1, r0
  40192a:	f243 100c 	movw	r0, #12556	; 0x310c
  40192e:	47a0      	blx	r4
  401930:	e7ef      	b.n	401912 <sd_mmc_wait_end_of_read_blocks+0x2a>
  401932:	bf00      	nop
  401934:	004020a9 	.word	0x004020a9
  401938:	20000f54 	.word	0x20000f54
  40193c:	20000f4c 	.word	0x20000f4c
  401940:	00401e95 	.word	0x00401e95
  401944:	20000f56 	.word	0x20000f56
  401948:	00401e71 	.word	0x00401e71

0040194c <sd_mmc_init_write_blocks>:
	return SD_MMC_OK;
}

sd_mmc_err_t sd_mmc_init_write_blocks(uint8_t slot, uint32_t start,
		uint16_t nb_block)
{
  40194c:	b570      	push	{r4, r5, r6, lr}
  40194e:	4615      	mov	r5, r2
  401950:	b084      	sub	sp, #16
 * \retval SD_MMC_INIT_ONGOING Card initialization requested
 * \retval SD_MMC_OK           Card present
 */
static sd_mmc_err_t sd_mmc_select_slot(uint8_t slot)
{
	if (slot >= SD_MMC_MEM_CNT) {
  401952:	b118      	cbz	r0, 40195c <sd_mmc_init_write_blocks+0x10>
		return SD_MMC_ERR_SLOT;
  401954:	2404      	movs	r4, #4
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}
  401956:	4620      	mov	r0, r4
  401958:	b004      	add	sp, #16
  40195a:	bd70      	pop	{r4, r5, r6, pc}
  40195c:	9103      	str	r1, [sp, #12]
  40195e:	4b18      	ldr	r3, [pc, #96]	; (4019c0 <sd_mmc_init_write_blocks+0x74>)
  401960:	4798      	blx	r3
{
	sd_mmc_err_t sd_mmc_err;
	uint32_t cmd, arg, resp;

	sd_mmc_err = sd_mmc_select_slot(slot);
	if (sd_mmc_err != SD_MMC_OK) {
  401962:	9903      	ldr	r1, [sp, #12]
  401964:	4604      	mov	r4, r0
  401966:	2800      	cmp	r0, #0
  401968:	d1f5      	bne.n	401956 <sd_mmc_init_write_blocks+0xa>
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  40196a:	4b16      	ldr	r3, [pc, #88]	; (4019c4 <sd_mmc_init_write_blocks+0x78>)
		sd_mmc_deselect_slot();
		return SD_MMC_ERR_WP;
	}

	if (nb_block > 1) {
		cmd = SDMMC_CMD25_WRITE_MULTIPLE_BLOCK;
  40196c:	4a16      	ldr	r2, [pc, #88]	; (4019c8 <sd_mmc_init_write_blocks+0x7c>)
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  40196e:	681b      	ldr	r3, [r3, #0]
		sd_mmc_deselect_slot();
		return SD_MMC_ERR_WP;
	}

	if (nb_block > 1) {
		cmd = SDMMC_CMD25_WRITE_MULTIPLE_BLOCK;
  401970:	4816      	ldr	r0, [pc, #88]	; (4019cc <sd_mmc_init_write_blocks+0x80>)
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  401972:	7bdb      	ldrb	r3, [r3, #15]
		arg = start;
	} else {
		arg = (start * SD_MMC_BLOCK_SIZE);
	}
	if (!driver_adtc_start(cmd, arg, SD_MMC_BLOCK_SIZE, nb_block, true)) {
  401974:	4e16      	ldr	r6, [pc, #88]	; (4019d0 <sd_mmc_init_write_blocks+0x84>)
		sd_mmc_deselect_slot();
		return SD_MMC_ERR_WP;
	}

	if (nb_block > 1) {
		cmd = SDMMC_CMD25_WRITE_MULTIPLE_BLOCK;
  401976:	2d01      	cmp	r5, #1
  401978:	bf88      	it	hi
  40197a:	4610      	movhi	r0, r2
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  40197c:	071b      	lsls	r3, r3, #28
		arg = start;
	} else {
		arg = (start * SD_MMC_BLOCK_SIZE);
	}
	if (!driver_adtc_start(cmd, arg, SD_MMC_BLOCK_SIZE, nb_block, true)) {
  40197e:	f04f 0301 	mov.w	r3, #1
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
		arg = start;
	} else {
		arg = (start * SD_MMC_BLOCK_SIZE);
  401982:	bf58      	it	pl
  401984:	0249      	lslpl	r1, r1, #9
	}
	if (!driver_adtc_start(cmd, arg, SD_MMC_BLOCK_SIZE, nb_block, true)) {
  401986:	9300      	str	r3, [sp, #0]
  401988:	f44f 7200 	mov.w	r2, #512	; 0x200
  40198c:	462b      	mov	r3, r5
  40198e:	47b0      	blx	r6
  401990:	b930      	cbnz	r0, 4019a0 <sd_mmc_init_write_blocks+0x54>
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  401992:	4b10      	ldr	r3, [pc, #64]	; (4019d4 <sd_mmc_init_write_blocks+0x88>)
  401994:	781b      	ldrb	r3, [r3, #0]
  401996:	b173      	cbz	r3, 4019b6 <sd_mmc_init_write_blocks+0x6a>
	} else {
		arg = (start * SD_MMC_BLOCK_SIZE);
	}
	if (!driver_adtc_start(cmd, arg, SD_MMC_BLOCK_SIZE, nb_block, true)) {
		sd_mmc_deselect_slot();
		return SD_MMC_ERR_COMM;
  401998:	2405      	movs	r4, #5
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}
  40199a:	4620      	mov	r0, r4
  40199c:	b004      	add	sp, #16
  40199e:	bd70      	pop	{r4, r5, r6, pc}
		sd_mmc_deselect_slot();
		return SD_MMC_ERR_COMM;
	}
	// Check response
	if (sd_mmc_is_mci()) {
		resp = driver_get_response();
  4019a0:	4b0d      	ldr	r3, [pc, #52]	; (4019d8 <sd_mmc_init_write_blocks+0x8c>)
  4019a2:	4798      	blx	r3
		if (resp & CARD_STATUS_ERR_RD_WR) {
  4019a4:	4b0d      	ldr	r3, [pc, #52]	; (4019dc <sd_mmc_init_write_blocks+0x90>)
  4019a6:	4003      	ands	r3, r0
  4019a8:	2b00      	cmp	r3, #0
  4019aa:	d1f2      	bne.n	401992 <sd_mmc_init_write_blocks+0x46>
					__func__, (int)SDMMC_CMD_GET_INDEX(cmd), resp);
			sd_mmc_deselect_slot();
			return SD_MMC_ERR_COMM;
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
  4019ac:	4a0c      	ldr	r2, [pc, #48]	; (4019e0 <sd_mmc_init_write_blocks+0x94>)
	sd_mmc_nb_block_to_tranfer = nb_block;
  4019ae:	4b0d      	ldr	r3, [pc, #52]	; (4019e4 <sd_mmc_init_write_blocks+0x98>)
					__func__, (int)SDMMC_CMD_GET_INDEX(cmd), resp);
			sd_mmc_deselect_slot();
			return SD_MMC_ERR_COMM;
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
  4019b0:	8015      	strh	r5, [r2, #0]
	sd_mmc_nb_block_to_tranfer = nb_block;
  4019b2:	801d      	strh	r5, [r3, #0]
	return SD_MMC_OK;
  4019b4:	e7cf      	b.n	401956 <sd_mmc_init_write_blocks+0xa>
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
		driver_deselect_device(sd_mmc_slot_sel);
  4019b6:	2000      	movs	r0, #0
  4019b8:	4b0b      	ldr	r3, [pc, #44]	; (4019e8 <sd_mmc_init_write_blocks+0x9c>)
  4019ba:	4798      	blx	r3
  4019bc:	e7ec      	b.n	401998 <sd_mmc_init_write_blocks+0x4c>
  4019be:	bf00      	nop
  4019c0:	00400fa9 	.word	0x00400fa9
  4019c4:	20000f50 	.word	0x20000f50
  4019c8:	00109119 	.word	0x00109119
  4019cc:	00089118 	.word	0x00089118
  4019d0:	00401eed 	.word	0x00401eed
  4019d4:	20000f56 	.word	0x20000f56
  4019d8:	00401ec1 	.word	0x00401ec1
  4019dc:	e4580000 	.word	0xe4580000
  4019e0:	20000f54 	.word	0x20000f54
  4019e4:	20000f4c 	.word	0x20000f4c
  4019e8:	00401e71 	.word	0x00401e71

004019ec <sd_mmc_start_write_blocks>:
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}

sd_mmc_err_t sd_mmc_start_write_blocks(const void *src, uint16_t nb_block)
{
  4019ec:	b510      	push	{r4, lr}
	Assert(sd_mmc_nb_block_remaining >= nb_block);
	if (!driver_start_write_blocks(src, nb_block)) {
  4019ee:	4b07      	ldr	r3, [pc, #28]	; (401a0c <sd_mmc_start_write_blocks+0x20>)
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}

sd_mmc_err_t sd_mmc_start_write_blocks(const void *src, uint16_t nb_block)
{
  4019f0:	460c      	mov	r4, r1
	Assert(sd_mmc_nb_block_remaining >= nb_block);
	if (!driver_start_write_blocks(src, nb_block)) {
  4019f2:	4798      	blx	r3
  4019f4:	4603      	mov	r3, r0
  4019f6:	b918      	cbnz	r0, 401a00 <sd_mmc_start_write_blocks+0x14>
		sd_mmc_nb_block_remaining = 0;
  4019f8:	4a05      	ldr	r2, [pc, #20]	; (401a10 <sd_mmc_start_write_blocks+0x24>)
  4019fa:	8013      	strh	r3, [r2, #0]
		return SD_MMC_ERR_COMM;
  4019fc:	2005      	movs	r0, #5
  4019fe:	bd10      	pop	{r4, pc}
	}
	sd_mmc_nb_block_remaining -= nb_block;
  401a00:	4b03      	ldr	r3, [pc, #12]	; (401a10 <sd_mmc_start_write_blocks+0x24>)
  401a02:	881a      	ldrh	r2, [r3, #0]
  401a04:	1b14      	subs	r4, r2, r4
  401a06:	801c      	strh	r4, [r3, #0]
	return SD_MMC_OK;
  401a08:	2000      	movs	r0, #0
}
  401a0a:	bd10      	pop	{r4, pc}
  401a0c:	0040214d 	.word	0x0040214d
  401a10:	20000f54 	.word	0x20000f54

00401a14 <sd_mmc_wait_end_of_write_blocks>:

sd_mmc_err_t sd_mmc_wait_end_of_write_blocks(bool abort)
{
  401a14:	b510      	push	{r4, lr}
	if (!driver_wait_end_of_write_blocks()) {
  401a16:	4b14      	ldr	r3, [pc, #80]	; (401a68 <sd_mmc_wait_end_of_write_blocks+0x54>)
	sd_mmc_nb_block_remaining -= nb_block;
	return SD_MMC_OK;
}

sd_mmc_err_t sd_mmc_wait_end_of_write_blocks(bool abort)
{
  401a18:	4604      	mov	r4, r0
	if (!driver_wait_end_of_write_blocks()) {
  401a1a:	4798      	blx	r3
  401a1c:	b908      	cbnz	r0, 401a22 <sd_mmc_wait_end_of_write_blocks+0xe>
	if (sd_mmc_is_mci()) {
		// Note: SPI multiblock writes terminate using a special
		// token, not a STOP_TRANSMISSION request.
		if (!driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0)) {
			sd_mmc_deselect_slot();
			return SD_MMC_ERR_COMM;
  401a1e:	2005      	movs	r0, #5
  401a20:	bd10      	pop	{r4, pc}
{
	if (!driver_wait_end_of_write_blocks()) {
		return SD_MMC_ERR_COMM;
	}
	if (abort) {
		sd_mmc_nb_block_remaining = 0;
  401a22:	4b12      	ldr	r3, [pc, #72]	; (401a6c <sd_mmc_wait_end_of_write_blocks+0x58>)
sd_mmc_err_t sd_mmc_wait_end_of_write_blocks(bool abort)
{
	if (!driver_wait_end_of_write_blocks()) {
		return SD_MMC_ERR_COMM;
	}
	if (abort) {
  401a24:	b994      	cbnz	r4, 401a4c <sd_mmc_wait_end_of_write_blocks+0x38>
		sd_mmc_nb_block_remaining = 0;
	} else if (sd_mmc_nb_block_remaining) {
  401a26:	881b      	ldrh	r3, [r3, #0]
  401a28:	b9e3      	cbnz	r3, 401a64 <sd_mmc_wait_end_of_write_blocks+0x50>
		return SD_MMC_OK;
	}

	// All blocks are transfered then stop write operation
	if (sd_mmc_nb_block_to_tranfer == 1) {
  401a2a:	4b11      	ldr	r3, [pc, #68]	; (401a70 <sd_mmc_wait_end_of_write_blocks+0x5c>)
  401a2c:	881b      	ldrh	r3, [r3, #0]
  401a2e:	2b01      	cmp	r3, #1
  401a30:	d012      	beq.n	401a58 <sd_mmc_wait_end_of_write_blocks+0x44>
	}

	if (sd_mmc_is_mci()) {
		// Note: SPI multiblock writes terminate using a special
		// token, not a STOP_TRANSMISSION request.
		if (!driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0)) {
  401a32:	f243 100c 	movw	r0, #12556	; 0x310c
  401a36:	2100      	movs	r1, #0
  401a38:	4b0e      	ldr	r3, [pc, #56]	; (401a74 <sd_mmc_wait_end_of_write_blocks+0x60>)
  401a3a:	4798      	blx	r3
  401a3c:	b960      	cbnz	r0, 401a58 <sd_mmc_wait_end_of_write_blocks+0x44>
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  401a3e:	4b0e      	ldr	r3, [pc, #56]	; (401a78 <sd_mmc_wait_end_of_write_blocks+0x64>)
  401a40:	781b      	ldrb	r3, [r3, #0]
  401a42:	2b00      	cmp	r3, #0
  401a44:	d1eb      	bne.n	401a1e <sd_mmc_wait_end_of_write_blocks+0xa>
		driver_deselect_device(sd_mmc_slot_sel);
  401a46:	4b0d      	ldr	r3, [pc, #52]	; (401a7c <sd_mmc_wait_end_of_write_blocks+0x68>)
  401a48:	4798      	blx	r3
  401a4a:	e7e8      	b.n	401a1e <sd_mmc_wait_end_of_write_blocks+0xa>
{
	if (!driver_wait_end_of_write_blocks()) {
		return SD_MMC_ERR_COMM;
	}
	if (abort) {
		sd_mmc_nb_block_remaining = 0;
  401a4c:	2200      	movs	r2, #0
  401a4e:	801a      	strh	r2, [r3, #0]
	} else if (sd_mmc_nb_block_remaining) {
		return SD_MMC_OK;
	}

	// All blocks are transfered then stop write operation
	if (sd_mmc_nb_block_to_tranfer == 1) {
  401a50:	4b07      	ldr	r3, [pc, #28]	; (401a70 <sd_mmc_wait_end_of_write_blocks+0x5c>)
  401a52:	881b      	ldrh	r3, [r3, #0]
  401a54:	2b01      	cmp	r3, #1
  401a56:	d1ec      	bne.n	401a32 <sd_mmc_wait_end_of_write_blocks+0x1e>
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  401a58:	4b07      	ldr	r3, [pc, #28]	; (401a78 <sd_mmc_wait_end_of_write_blocks+0x64>)
  401a5a:	781b      	ldrb	r3, [r3, #0]
  401a5c:	b913      	cbnz	r3, 401a64 <sd_mmc_wait_end_of_write_blocks+0x50>
		driver_deselect_device(sd_mmc_slot_sel);
  401a5e:	2000      	movs	r0, #0
  401a60:	4b06      	ldr	r3, [pc, #24]	; (401a7c <sd_mmc_wait_end_of_write_blocks+0x68>)
  401a62:	4798      	blx	r3

	// All blocks are transfered then stop write operation
	if (sd_mmc_nb_block_to_tranfer == 1) {
		// Single block transfer, then nothing to do
		sd_mmc_deselect_slot();
		return SD_MMC_OK;
  401a64:	2000      	movs	r0, #0
  401a66:	bd10      	pop	{r4, pc}
  401a68:	004021b9 	.word	0x004021b9
  401a6c:	20000f54 	.word	0x20000f54
  401a70:	20000f4c 	.word	0x20000f4c
  401a74:	00401e95 	.word	0x00401e95
  401a78:	20000f56 	.word	0x20000f56
  401a7c:	00401e71 	.word	0x00401e71

00401a80 <sd_mmc_test_unit_ready>:
 */

static bool sd_mmc_ejected[2] = {false, false};

Ctrl_status sd_mmc_test_unit_ready(uint8_t slot)
{
  401a80:	b510      	push	{r4, lr}
	switch (sd_mmc_check(slot))
  401a82:	4b0f      	ldr	r3, [pc, #60]	; (401ac0 <sd_mmc_test_unit_ready+0x40>)
 */

static bool sd_mmc_ejected[2] = {false, false};

Ctrl_status sd_mmc_test_unit_ready(uint8_t slot)
{
  401a84:	4604      	mov	r4, r0
	switch (sd_mmc_check(slot))
  401a86:	4798      	blx	r3
  401a88:	2801      	cmp	r0, #1
  401a8a:	d00d      	beq.n	401aa8 <sd_mmc_test_unit_ready+0x28>
  401a8c:	d307      	bcc.n	401a9e <sd_mmc_test_unit_ready+0x1e>
  401a8e:	2802      	cmp	r0, #2
  401a90:	d103      	bne.n	401a9a <sd_mmc_test_unit_ready+0x1a>

	case SD_MMC_INIT_ONGOING:
		return CTRL_BUSY;

	case SD_MMC_ERR_NO_CARD:
		sd_mmc_ejected[slot] = false;
  401a92:	4b0c      	ldr	r3, [pc, #48]	; (401ac4 <sd_mmc_test_unit_ready+0x44>)
  401a94:	2200      	movs	r2, #0
  401a96:	551a      	strb	r2, [r3, r4]
		return CTRL_NO_PRESENT;
  401a98:	bd10      	pop	{r4, pc}

	default:
		return CTRL_FAIL;
  401a9a:	2001      	movs	r0, #1
  401a9c:	bd10      	pop	{r4, pc}
Ctrl_status sd_mmc_test_unit_ready(uint8_t slot)
{
	switch (sd_mmc_check(slot))
	{
	case SD_MMC_OK:
		if (sd_mmc_ejected[slot]) {
  401a9e:	4b09      	ldr	r3, [pc, #36]	; (401ac4 <sd_mmc_test_unit_ready+0x44>)
  401aa0:	5d1b      	ldrb	r3, [r3, r4]
  401aa2:	b11b      	cbz	r3, 401aac <sd_mmc_test_unit_ready+0x2c>
			return CTRL_NO_PRESENT;
  401aa4:	2002      	movs	r0, #2
		return CTRL_NO_PRESENT;

	default:
		return CTRL_FAIL;
	}
}
  401aa6:	bd10      	pop	{r4, pc}
		}
		// It is not a memory card
		return CTRL_NO_PRESENT;

	case SD_MMC_INIT_ONGOING:
		return CTRL_BUSY;
  401aa8:	2003      	movs	r0, #3
  401aaa:	bd10      	pop	{r4, pc}
	{
	case SD_MMC_OK:
		if (sd_mmc_ejected[slot]) {
			return CTRL_NO_PRESENT;
		}
		if (sd_mmc_get_type(slot) & (CARD_TYPE_SD | CARD_TYPE_MMC)) {
  401aac:	4620      	mov	r0, r4
  401aae:	4b06      	ldr	r3, [pc, #24]	; (401ac8 <sd_mmc_test_unit_ready+0x48>)
  401ab0:	4798      	blx	r3
  401ab2:	f010 0f03 	tst.w	r0, #3
			return CTRL_GOOD;
  401ab6:	bf0c      	ite	eq
  401ab8:	2002      	moveq	r0, #2
  401aba:	2000      	movne	r0, #0
  401abc:	bd10      	pop	{r4, pc}
  401abe:	bf00      	nop
  401ac0:	004010f9 	.word	0x004010f9
  401ac4:	20000f58 	.word	0x20000f58
  401ac8:	0040175d 	.word	0x0040175d

00401acc <sd_mmc_test_unit_ready_0>:
		return CTRL_FAIL;
	}
}

Ctrl_status sd_mmc_test_unit_ready_0(void)
{
  401acc:	b508      	push	{r3, lr}
	return sd_mmc_test_unit_ready(0);
  401ace:	2000      	movs	r0, #0
  401ad0:	4b01      	ldr	r3, [pc, #4]	; (401ad8 <sd_mmc_test_unit_ready_0+0xc>)
  401ad2:	4798      	blx	r3
}
  401ad4:	bd08      	pop	{r3, pc}
  401ad6:	bf00      	nop
  401ad8:	00401a81 	.word	0x00401a81

00401adc <sd_mmc_test_unit_ready_1>:


Ctrl_status sd_mmc_test_unit_ready_1(void)
{
  401adc:	b508      	push	{r3, lr}
	return sd_mmc_test_unit_ready(1);
  401ade:	2001      	movs	r0, #1
  401ae0:	4b01      	ldr	r3, [pc, #4]	; (401ae8 <sd_mmc_test_unit_ready_1+0xc>)
  401ae2:	4798      	blx	r3
}
  401ae4:	bd08      	pop	{r3, pc}
  401ae6:	bf00      	nop
  401ae8:	00401a81 	.word	0x00401a81

00401aec <sd_mmc_read_capacity>:

Ctrl_status sd_mmc_read_capacity(uint8_t slot, uint32_t *nb_sector)
{
  401aec:	b538      	push	{r3, r4, r5, lr}
	// Return last sector address (-1)
	*nb_sector = (sd_mmc_get_capacity(slot) * 2) - 1;
  401aee:	4b05      	ldr	r3, [pc, #20]	; (401b04 <sd_mmc_read_capacity+0x18>)
{
	return sd_mmc_test_unit_ready(1);
}

Ctrl_status sd_mmc_read_capacity(uint8_t slot, uint32_t *nb_sector)
{
  401af0:	460d      	mov	r5, r1
  401af2:	4604      	mov	r4, r0
	// Return last sector address (-1)
	*nb_sector = (sd_mmc_get_capacity(slot) * 2) - 1;
  401af4:	4798      	blx	r3
  401af6:	0040      	lsls	r0, r0, #1
  401af8:	3801      	subs	r0, #1
  401afa:	6028      	str	r0, [r5, #0]
	return sd_mmc_test_unit_ready(slot);
  401afc:	4b02      	ldr	r3, [pc, #8]	; (401b08 <sd_mmc_read_capacity+0x1c>)
  401afe:	4620      	mov	r0, r4
  401b00:	4798      	blx	r3
}
  401b02:	bd38      	pop	{r3, r4, r5, pc}
  401b04:	00401799 	.word	0x00401799
  401b08:	00401a81 	.word	0x00401a81

00401b0c <sd_mmc_read_capacity_0>:

Ctrl_status sd_mmc_read_capacity_0(uint32_t *nb_sector)
{
  401b0c:	b508      	push	{r3, lr}
  401b0e:	4601      	mov	r1, r0
	return sd_mmc_read_capacity(0, nb_sector);
  401b10:	4b01      	ldr	r3, [pc, #4]	; (401b18 <sd_mmc_read_capacity_0+0xc>)
  401b12:	2000      	movs	r0, #0
  401b14:	4798      	blx	r3
}
  401b16:	bd08      	pop	{r3, pc}
  401b18:	00401aed 	.word	0x00401aed

00401b1c <sd_mmc_read_capacity_1>:

Ctrl_status sd_mmc_read_capacity_1(uint32_t *nb_sector)
{
  401b1c:	b508      	push	{r3, lr}
  401b1e:	4601      	mov	r1, r0
	return sd_mmc_read_capacity(1, nb_sector);
  401b20:	4b01      	ldr	r3, [pc, #4]	; (401b28 <sd_mmc_read_capacity_1+0xc>)
  401b22:	2001      	movs	r0, #1
  401b24:	4798      	blx	r3
}
  401b26:	bd08      	pop	{r3, pc}
  401b28:	00401aed 	.word	0x00401aed

00401b2c <sd_mmc_unload_0>:

bool sd_mmc_unload(uint8_t slot, bool unload)
{
	sd_mmc_ejected[slot] = unload;
  401b2c:	4b01      	ldr	r3, [pc, #4]	; (401b34 <sd_mmc_unload_0+0x8>)
  401b2e:	7018      	strb	r0, [r3, #0]
}

bool sd_mmc_unload_0(bool unload)
{
	return sd_mmc_unload(0, unload);
}
  401b30:	2001      	movs	r0, #1
  401b32:	4770      	bx	lr
  401b34:	20000f58 	.word	0x20000f58

00401b38 <sd_mmc_unload_1>:
	return sd_mmc_read_capacity(1, nb_sector);
}

bool sd_mmc_unload(uint8_t slot, bool unload)
{
	sd_mmc_ejected[slot] = unload;
  401b38:	4b01      	ldr	r3, [pc, #4]	; (401b40 <sd_mmc_unload_1+0x8>)
  401b3a:	7058      	strb	r0, [r3, #1]
}

bool sd_mmc_unload_1(bool unload)
{
	return sd_mmc_unload(1, unload);
}
  401b3c:	2001      	movs	r0, #1
  401b3e:	4770      	bx	lr
  401b40:	20000f58 	.word	0x20000f58

00401b44 <sd_mmc_wr_protect_0>:
{
	return sd_mmc_is_write_protected(slot);
}

bool sd_mmc_wr_protect_0(void)
{
  401b44:	b508      	push	{r3, lr}
	return sd_mmc_unload(1, unload);
}

bool sd_mmc_wr_protect(uint8_t slot)
{
	return sd_mmc_is_write_protected(slot);
  401b46:	2000      	movs	r0, #0
  401b48:	4b01      	ldr	r3, [pc, #4]	; (401b50 <sd_mmc_wr_protect_0+0xc>)
  401b4a:	4798      	blx	r3
}

bool sd_mmc_wr_protect_0(void)
{
	return sd_mmc_wr_protect(0);
}
  401b4c:	bd08      	pop	{r3, pc}
  401b4e:	bf00      	nop
  401b50:	004017d5 	.word	0x004017d5

00401b54 <sd_mmc_wr_protect_1>:

bool sd_mmc_wr_protect_1(void)
{
  401b54:	b508      	push	{r3, lr}
	return sd_mmc_unload(1, unload);
}

bool sd_mmc_wr_protect(uint8_t slot)
{
	return sd_mmc_is_write_protected(slot);
  401b56:	2001      	movs	r0, #1
  401b58:	4b01      	ldr	r3, [pc, #4]	; (401b60 <sd_mmc_wr_protect_1+0xc>)
  401b5a:	4798      	blx	r3
}

bool sd_mmc_wr_protect_1(void)
{
	return sd_mmc_wr_protect(1);
}
  401b5c:	bd08      	pop	{r3, pc}
  401b5e:	bf00      	nop
  401b60:	004017d5 	.word	0x004017d5

00401b64 <sd_mmc_removal_0>:
}

bool sd_mmc_removal_0(void)
{
	return sd_mmc_removal(0);
}
  401b64:	2001      	movs	r0, #1
  401b66:	4770      	bx	lr

00401b68 <sd_mmc_removal_1>:

bool sd_mmc_removal_1(void)
{
	return sd_mmc_removal(1);
}
  401b68:	2001      	movs	r0, #1
  401b6a:	4770      	bx	lr

00401b6c <sd_mmc_mem_2_ram>:
/**
 * \name MEM <-> RAM Interface
 * @{
 */
Ctrl_status sd_mmc_mem_2_ram(uint8_t slot, uint32_t addr, void *ram)
{
  401b6c:	b510      	push	{r4, lr}
	switch (sd_mmc_init_read_blocks(slot, addr, 1)) {
  401b6e:	4b0b      	ldr	r3, [pc, #44]	; (401b9c <sd_mmc_mem_2_ram+0x30>)
/**
 * \name MEM <-> RAM Interface
 * @{
 */
Ctrl_status sd_mmc_mem_2_ram(uint8_t slot, uint32_t addr, void *ram)
{
  401b70:	4614      	mov	r4, r2
	switch (sd_mmc_init_read_blocks(slot, addr, 1)) {
  401b72:	2201      	movs	r2, #1
  401b74:	4798      	blx	r3
  401b76:	b120      	cbz	r0, 401b82 <sd_mmc_mem_2_ram+0x16>
  401b78:	2802      	cmp	r0, #2
	case SD_MMC_OK:
		break;
	case SD_MMC_ERR_NO_CARD:
		return CTRL_NO_PRESENT;
	default:
		return CTRL_FAIL;
  401b7a:	bf0c      	ite	eq
  401b7c:	2002      	moveq	r0, #2
  401b7e:	2001      	movne	r0, #1
  401b80:	bd10      	pop	{r4, pc}
	}
	if (SD_MMC_OK != sd_mmc_start_read_blocks(ram, 1)) {
  401b82:	4620      	mov	r0, r4
  401b84:	2101      	movs	r1, #1
  401b86:	4b06      	ldr	r3, [pc, #24]	; (401ba0 <sd_mmc_mem_2_ram+0x34>)
  401b88:	4798      	blx	r3
  401b8a:	b108      	cbz	r0, 401b90 <sd_mmc_mem_2_ram+0x24>
		return CTRL_FAIL;
  401b8c:	2001      	movs	r0, #1
	}
	if (SD_MMC_OK != sd_mmc_wait_end_of_read_blocks(false)) {
		return CTRL_FAIL;
	}
	return CTRL_GOOD;
}
  401b8e:	bd10      	pop	{r4, pc}
		return CTRL_FAIL;
	}
	if (SD_MMC_OK != sd_mmc_start_read_blocks(ram, 1)) {
		return CTRL_FAIL;
	}
	if (SD_MMC_OK != sd_mmc_wait_end_of_read_blocks(false)) {
  401b90:	4b04      	ldr	r3, [pc, #16]	; (401ba4 <sd_mmc_mem_2_ram+0x38>)
  401b92:	4798      	blx	r3
		return CTRL_FAIL;
  401b94:	3000      	adds	r0, #0
  401b96:	bf18      	it	ne
  401b98:	2001      	movne	r0, #1
  401b9a:	bd10      	pop	{r4, pc}
  401b9c:	004017d9 	.word	0x004017d9
  401ba0:	004018c1 	.word	0x004018c1
  401ba4:	004018e9 	.word	0x004018e9

00401ba8 <sd_mmc_mem_2_ram_0>:
	}
	return CTRL_GOOD;
}

Ctrl_status sd_mmc_mem_2_ram_0(uint32_t addr, void *ram)
{
  401ba8:	b508      	push	{r3, lr}
  401baa:	460a      	mov	r2, r1
	return sd_mmc_mem_2_ram(0, addr, ram);
  401bac:	4b02      	ldr	r3, [pc, #8]	; (401bb8 <sd_mmc_mem_2_ram_0+0x10>)
  401bae:	4601      	mov	r1, r0
  401bb0:	2000      	movs	r0, #0
  401bb2:	4798      	blx	r3
}
  401bb4:	bd08      	pop	{r3, pc}
  401bb6:	bf00      	nop
  401bb8:	00401b6d 	.word	0x00401b6d

00401bbc <sd_mmc_mem_2_ram_1>:

Ctrl_status sd_mmc_mem_2_ram_1(uint32_t addr, void *ram)
{
  401bbc:	b508      	push	{r3, lr}
  401bbe:	460a      	mov	r2, r1
	return sd_mmc_mem_2_ram(1, addr, ram);
  401bc0:	4b02      	ldr	r3, [pc, #8]	; (401bcc <sd_mmc_mem_2_ram_1+0x10>)
  401bc2:	4601      	mov	r1, r0
  401bc4:	2001      	movs	r0, #1
  401bc6:	4798      	blx	r3
}
  401bc8:	bd08      	pop	{r3, pc}
  401bca:	bf00      	nop
  401bcc:	00401b6d 	.word	0x00401b6d

00401bd0 <sd_mmc_ram_2_mem>:

Ctrl_status sd_mmc_ram_2_mem(uint8_t slot, uint32_t addr, const void *ram)
{
  401bd0:	b510      	push	{r4, lr}
	switch (sd_mmc_init_write_blocks(slot, addr, 1)) {
  401bd2:	4b0b      	ldr	r3, [pc, #44]	; (401c00 <sd_mmc_ram_2_mem+0x30>)
{
	return sd_mmc_mem_2_ram(1, addr, ram);
}

Ctrl_status sd_mmc_ram_2_mem(uint8_t slot, uint32_t addr, const void *ram)
{
  401bd4:	4614      	mov	r4, r2
	switch (sd_mmc_init_write_blocks(slot, addr, 1)) {
  401bd6:	2201      	movs	r2, #1
  401bd8:	4798      	blx	r3
  401bda:	b120      	cbz	r0, 401be6 <sd_mmc_ram_2_mem+0x16>
  401bdc:	2802      	cmp	r0, #2
	case SD_MMC_OK:
		break;
	case SD_MMC_ERR_NO_CARD:
		return CTRL_NO_PRESENT;
	default:
		return CTRL_FAIL;
  401bde:	bf0c      	ite	eq
  401be0:	2002      	moveq	r0, #2
  401be2:	2001      	movne	r0, #1
  401be4:	bd10      	pop	{r4, pc}
	}
	if (SD_MMC_OK != sd_mmc_start_write_blocks(ram, 1)) {
  401be6:	4620      	mov	r0, r4
  401be8:	2101      	movs	r1, #1
  401bea:	4b06      	ldr	r3, [pc, #24]	; (401c04 <sd_mmc_ram_2_mem+0x34>)
  401bec:	4798      	blx	r3
  401bee:	b108      	cbz	r0, 401bf4 <sd_mmc_ram_2_mem+0x24>
		return CTRL_FAIL;
  401bf0:	2001      	movs	r0, #1
	}
	if (SD_MMC_OK != sd_mmc_wait_end_of_write_blocks(false)) {
		return CTRL_FAIL;
	}
	return CTRL_GOOD;
}
  401bf2:	bd10      	pop	{r4, pc}
		return CTRL_FAIL;
	}
	if (SD_MMC_OK != sd_mmc_start_write_blocks(ram, 1)) {
		return CTRL_FAIL;
	}
	if (SD_MMC_OK != sd_mmc_wait_end_of_write_blocks(false)) {
  401bf4:	4b04      	ldr	r3, [pc, #16]	; (401c08 <sd_mmc_ram_2_mem+0x38>)
  401bf6:	4798      	blx	r3
		return CTRL_FAIL;
  401bf8:	3000      	adds	r0, #0
  401bfa:	bf18      	it	ne
  401bfc:	2001      	movne	r0, #1
  401bfe:	bd10      	pop	{r4, pc}
  401c00:	0040194d 	.word	0x0040194d
  401c04:	004019ed 	.word	0x004019ed
  401c08:	00401a15 	.word	0x00401a15

00401c0c <sd_mmc_ram_2_mem_0>:
	}
	return CTRL_GOOD;
}

Ctrl_status sd_mmc_ram_2_mem_0(uint32_t addr, const void *ram)
{
  401c0c:	b508      	push	{r3, lr}
  401c0e:	460a      	mov	r2, r1
	return sd_mmc_ram_2_mem(0, addr, ram);
  401c10:	4b02      	ldr	r3, [pc, #8]	; (401c1c <sd_mmc_ram_2_mem_0+0x10>)
  401c12:	4601      	mov	r1, r0
  401c14:	2000      	movs	r0, #0
  401c16:	4798      	blx	r3
}
  401c18:	bd08      	pop	{r3, pc}
  401c1a:	bf00      	nop
  401c1c:	00401bd1 	.word	0x00401bd1

00401c20 <sd_mmc_ram_2_mem_1>:

Ctrl_status sd_mmc_ram_2_mem_1(uint32_t addr, const void *ram)
{
  401c20:	b508      	push	{r3, lr}
  401c22:	460a      	mov	r2, r1
	return sd_mmc_ram_2_mem(1, addr, ram);
  401c24:	4b02      	ldr	r3, [pc, #8]	; (401c30 <sd_mmc_ram_2_mem_1+0x10>)
  401c26:	4601      	mov	r1, r0
  401c28:	2001      	movs	r0, #1
  401c2a:	4798      	blx	r3
}
  401c2c:	bd08      	pop	{r3, pc}
  401c2e:	bf00      	nop
  401c30:	00401bd1 	.word	0x00401bd1

00401c34 <mem_test_unit_ready>:
{
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
  401c34:	2801      	cmp	r0, #1
  return LUN_ID_0;
}


Ctrl_status mem_test_unit_ready(U8 lun)
{
  401c36:	b508      	push	{r3, lr}
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
  401c38:	d901      	bls.n	401c3e <mem_test_unit_ready+0xa>
  401c3a:	2001      	movs	r0, #1
#endif

  Ctrl_access_unlock();

  return status;
}
  401c3c:	bd08      	pop	{r3, pc}

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
#if MAX_LUN
         (lun < MAX_LUN) ? lun_desc[lun].test_unit_ready() :
  401c3e:	0140      	lsls	r0, r0, #5
  401c40:	4b01      	ldr	r3, [pc, #4]	; (401c48 <mem_test_unit_ready+0x14>)
{
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
  401c42:	581b      	ldr	r3, [r3, r0]
  401c44:	4798      	blx	r3
  401c46:	bd08      	pop	{r3, pc}
  401c48:	00406ad0 	.word	0x00406ad0

00401c4c <mem_read_capacity>:
{
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
  401c4c:	2801      	cmp	r0, #1
  return status;
}


Ctrl_status mem_read_capacity(U8 lun, U32 *u32_nb_sector)
{
  401c4e:	b508      	push	{r3, lr}
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
  401c50:	d901      	bls.n	401c56 <mem_read_capacity+0xa>
  401c52:	2001      	movs	r0, #1
#endif

  Ctrl_access_unlock();

  return status;
}
  401c54:	bd08      	pop	{r3, pc}

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
#if MAX_LUN
         (lun < MAX_LUN) ? lun_desc[lun].read_capacity(u32_nb_sector) :
  401c56:	4b03      	ldr	r3, [pc, #12]	; (401c64 <mem_read_capacity+0x18>)
  401c58:	eb03 1340 	add.w	r3, r3, r0, lsl #5
{
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
  401c5c:	4608      	mov	r0, r1
  401c5e:	685b      	ldr	r3, [r3, #4]
  401c60:	4798      	blx	r3
  401c62:	bd08      	pop	{r3, pc}
  401c64:	00406ad0 	.word	0x00406ad0

00401c68 <mem_sector_size>:
#endif

  Ctrl_access_unlock();

  return sector_size;
}
  401c68:	2801      	cmp	r0, #1
  401c6a:	bf8c      	ite	hi
  401c6c:	2000      	movhi	r0, #0
  401c6e:	2001      	movls	r0, #1
  401c70:	4770      	bx	lr
  401c72:	bf00      	nop

00401c74 <mem_wr_protect>:

  if (!Ctrl_access_lock()) return true;

  wr_protect =
#if MAX_LUN
             (lun < MAX_LUN) ? lun_desc[lun].wr_protect() :
  401c74:	2801      	cmp	r0, #1

  return unloaded;
}

bool mem_wr_protect(U8 lun)
{
  401c76:	b508      	push	{r3, lr}

  if (!Ctrl_access_lock()) return true;

  wr_protect =
#if MAX_LUN
             (lun < MAX_LUN) ? lun_desc[lun].wr_protect() :
  401c78:	d901      	bls.n	401c7e <mem_wr_protect+0xa>
  401c7a:	2001      	movs	r0, #1
#endif

  Ctrl_access_unlock();

  return wr_protect;
}
  401c7c:	bd08      	pop	{r3, pc}

  if (!Ctrl_access_lock()) return true;

  wr_protect =
#if MAX_LUN
             (lun < MAX_LUN) ? lun_desc[lun].wr_protect() :
  401c7e:	4b03      	ldr	r3, [pc, #12]	; (401c8c <mem_wr_protect+0x18>)
  401c80:	eb03 1040 	add.w	r0, r3, r0, lsl #5
  401c84:	68c3      	ldr	r3, [r0, #12]
  401c86:	4798      	blx	r3
  401c88:	bd08      	pop	{r3, pc}
  401c8a:	bf00      	nop
  401c8c:	00406ad0 	.word	0x00406ad0

00401c90 <memory_2_ram>:
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_read_action(1);
  status =
  401c90:	2801      	cmp	r0, #1
 */
//! @{


Ctrl_status memory_2_ram(U8 lun, U32 addr, void *ram)
{
  401c92:	b508      	push	{r3, lr}
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_read_action(1);
  status =
  401c94:	d901      	bls.n	401c9a <memory_2_ram+0xa>
  401c96:	2001      	movs	r0, #1
  memory_stop_read_action();

  Ctrl_access_unlock();

  return status;
}
  401c98:	bd08      	pop	{r3, pc}
  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_read_action(1);
  status =
#if MAX_LUN
           (lun < MAX_LUN) ? lun_desc[lun].mem_2_ram(addr, ram) :
  401c9a:	4b04      	ldr	r3, [pc, #16]	; (401cac <memory_2_ram+0x1c>)
  401c9c:	eb03 1340 	add.w	r3, r3, r0, lsl #5
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_read_action(1);
  status =
  401ca0:	4608      	mov	r0, r1
  401ca2:	695b      	ldr	r3, [r3, #20]
  401ca4:	4611      	mov	r1, r2
  401ca6:	4798      	blx	r3
  401ca8:	bd08      	pop	{r3, pc}
  401caa:	bf00      	nop
  401cac:	00406ad0 	.word	0x00406ad0

00401cb0 <ram_2_memory>:
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_write_action(1);
  status =
  401cb0:	2801      	cmp	r0, #1
  return status;
}


Ctrl_status ram_2_memory(U8 lun, U32 addr, const void *ram)
{
  401cb2:	b508      	push	{r3, lr}
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_write_action(1);
  status =
  401cb4:	d901      	bls.n	401cba <ram_2_memory+0xa>
  401cb6:	2001      	movs	r0, #1
  memory_stop_write_action();

  Ctrl_access_unlock();

  return status;
}
  401cb8:	bd08      	pop	{r3, pc}
  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_write_action(1);
  status =
#if MAX_LUN
           (lun < MAX_LUN) ? lun_desc[lun].ram_2_mem(addr, ram) :
  401cba:	4b04      	ldr	r3, [pc, #16]	; (401ccc <ram_2_memory+0x1c>)
  401cbc:	eb03 1340 	add.w	r3, r3, r0, lsl #5
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_write_action(1);
  status =
  401cc0:	4608      	mov	r0, r1
  401cc2:	699b      	ldr	r3, [r3, #24]
  401cc4:	4611      	mov	r1, r2
  401cc6:	4798      	blx	r3
  401cc8:	bd08      	pop	{r3, pc}
  401cca:	bf00      	nop
  401ccc:	00406ad0 	.word	0x00406ad0

00401cd0 <hsmci_send_cmd_execute>:
 *
 * \return true if success, otherwise false
 */
static bool hsmci_send_cmd_execute(uint32_t cmdr, sdmmc_cmd_def_t cmd,
		uint32_t arg)
{
  401cd0:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}
	uint32_t sr;

	cmdr |= HSMCI_CMDR_CMDNB(cmd) | HSMCI_CMDR_SPCMD_STD;
  401cd4:	f001 033f 	and.w	r3, r1, #63	; 0x3f
	if (cmd & SDMMC_RESP_PRESENT) {
  401cd8:	05cf      	lsls	r7, r1, #23
static bool hsmci_send_cmd_execute(uint32_t cmdr, sdmmc_cmd_def_t cmd,
		uint32_t arg)
{
	uint32_t sr;

	cmdr |= HSMCI_CMDR_CMDNB(cmd) | HSMCI_CMDR_SPCMD_STD;
  401cda:	ea43 0000 	orr.w	r0, r3, r0
	if (cmd & SDMMC_RESP_PRESENT) {
  401cde:	d503      	bpl.n	401ce8 <hsmci_send_cmd_execute+0x18>
		cmdr |= HSMCI_CMDR_MAXLAT;
		if (cmd & SDMMC_RESP_136) {
  401ce0:	050e      	lsls	r6, r1, #20
  401ce2:	d530      	bpl.n	401d46 <hsmci_send_cmd_execute+0x76>
			cmdr |= HSMCI_CMDR_RSPTYP_136_BIT;
  401ce4:	f440 5084 	orr.w	r0, r0, #4224	; 0x1080
	if (cmd & SDMMC_CMD_OPENDRAIN) {
		cmdr |= HSMCI_CMDR_OPDCMD_OPENDRAIN;
	}

	// Write argument
	HSMCI->HSMCI_ARGR = arg;
  401ce8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
			cmdr |= HSMCI_CMDR_RSPTYP_R1B;
		} else {
			cmdr |= HSMCI_CMDR_RSPTYP_48_BIT;
		}
	}
	if (cmd & SDMMC_CMD_OPENDRAIN) {
  401cec:	044c      	lsls	r4, r1, #17
		cmdr |= HSMCI_CMDR_OPDCMD_OPENDRAIN;
  401cee:	bf48      	it	mi
  401cf0:	f440 6000 	orrmi.w	r0, r0, #2048	; 0x800
	}

	// Write argument
	HSMCI->HSMCI_ARGR = arg;
  401cf4:	611a      	str	r2, [r3, #16]
	// Write and start command
	HSMCI->HSMCI_CMDR = cmdr;

	// Wait end of command
	do {
		sr = HSMCI->HSMCI_SR;
  401cf6:	461d      	mov	r5, r3
  401cf8:	f401 5480 	and.w	r4, r1, #4096	; 0x1000
	}

	// Write argument
	HSMCI->HSMCI_ARGR = arg;
	// Write and start command
	HSMCI->HSMCI_CMDR = cmdr;
  401cfc:	6158      	str	r0, [r3, #20]
  401cfe:	e004      	b.n	401d0a <hsmci_send_cmd_execute+0x3a>

	// Wait end of command
	do {
		sr = HSMCI->HSMCI_SR;
		if (cmd & SDMMC_RESP_CRC) {
			if (sr & (HSMCI_SR_CSTOE | HSMCI_SR_RTOE
  401d00:	f413 0f1f 	tst.w	r3, #10420224	; 0x9f0000
  401d04:	d12c      	bne.n	401d60 <hsmci_send_cmd_execute+0x90>
						__func__, cmd, sr);
				hsmci_reset();
				return false;
			}
		}
	} while (!(sr & HSMCI_SR_CMDRDY));
  401d06:	07da      	lsls	r2, r3, #31
  401d08:	d424      	bmi.n	401d54 <hsmci_send_cmd_execute+0x84>
	// Write and start command
	HSMCI->HSMCI_CMDR = cmdr;

	// Wait end of command
	do {
		sr = HSMCI->HSMCI_SR;
  401d0a:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  401d0e:	6c2b      	ldr	r3, [r5, #64]	; 0x40
		if (cmd & SDMMC_RESP_CRC) {
  401d10:	2c00      	cmp	r4, #0
  401d12:	d1f5      	bne.n	401d00 <hsmci_send_cmd_execute+0x30>
						__func__, cmd, sr);
				hsmci_reset();
				return false;
			}
		} else {
			if (sr & (HSMCI_SR_CSTOE | HSMCI_SR_RTOE
  401d14:	f413 0f1b 	tst.w	r3, #10158080	; 0x9b0000
  401d18:	d0f5      	beq.n	401d06 <hsmci_send_cmd_execute+0x36>
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  401d1a:	f8d2 c004 	ldr.w	ip, [r2, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  401d1e:	6897      	ldr	r7, [r2, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  401d20:	68d6      	ldr	r6, [r2, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  401d22:	69d5      	ldr	r5, [r2, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  401d24:	6d51      	ldr	r1, [r2, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401d26:	f04f 0880 	mov.w	r8, #128	; 0x80
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  401d2a:	2305      	movs	r3, #5
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401d2c:	f8c2 8000 	str.w	r8, [r2]
	HSMCI->HSMCI_MR = mr;
  401d30:	f8c2 c004 	str.w	ip, [r2, #4]
	HSMCI->HSMCI_DTOR = dtor;
  401d34:	6097      	str	r7, [r2, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  401d36:	60d6      	str	r6, [r2, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  401d38:	61d5      	str	r5, [r2, #28]
	HSMCI->HSMCI_CFG = cfg;
  401d3a:	6551      	str	r1, [r2, #84]	; 0x54
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  401d3c:	6013      	str	r3, [r2, #0]
					| HSMCI_SR_RENDE
					| HSMCI_SR_RDIRE | HSMCI_SR_RINDE)) {
				hsmci_debug("%s: CMD 0x%08x sr 0x%08x error\n\r",
						__func__, cmd, sr);
				hsmci_reset();
				return false;
  401d3e:	4620      	mov	r0, r4
		if (!hsmci_wait_busy()) {
			return false;
		}
	}
	return true;
}
  401d40:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
  401d44:	4770      	bx	lr
	cmdr |= HSMCI_CMDR_CMDNB(cmd) | HSMCI_CMDR_SPCMD_STD;
	if (cmd & SDMMC_RESP_PRESENT) {
		cmdr |= HSMCI_CMDR_MAXLAT;
		if (cmd & SDMMC_RESP_136) {
			cmdr |= HSMCI_CMDR_RSPTYP_136_BIT;
		} else if (cmd & SDMMC_RESP_BUSY) {
  401d46:	048d      	lsls	r5, r1, #18
			cmdr |= HSMCI_CMDR_RSPTYP_R1B;
  401d48:	bf4c      	ite	mi
  401d4a:	f440 5086 	orrmi.w	r0, r0, #4288	; 0x10c0
		} else {
			cmdr |= HSMCI_CMDR_RSPTYP_48_BIT;
  401d4e:	f440 5082 	orrpl.w	r0, r0, #4160	; 0x1040
  401d52:	e7c9      	b.n	401ce8 <hsmci_send_cmd_execute+0x18>
				return false;
			}
		}
	} while (!(sr & HSMCI_SR_CMDRDY));

	if (cmd & SDMMC_RESP_BUSY) {
  401d54:	048b      	lsls	r3, r1, #18
  401d56:	d415      	bmi.n	401d84 <hsmci_send_cmd_execute+0xb4>
		if (!hsmci_wait_busy()) {
			return false;
		}
	}
	return true;
  401d58:	2001      	movs	r0, #1
}
  401d5a:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
  401d5e:	4770      	bx	lr
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401d60:	2080      	movs	r0, #128	; 0x80
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  401d62:	6857      	ldr	r7, [r2, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  401d64:	6896      	ldr	r6, [r2, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  401d66:	68d5      	ldr	r5, [r2, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  401d68:	69d4      	ldr	r4, [r2, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  401d6a:	6d51      	ldr	r1, [r2, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401d6c:	6010      	str	r0, [r2, #0]
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  401d6e:	2305      	movs	r3, #5
					| HSMCI_SR_RENDE | HSMCI_SR_RCRCE
					| HSMCI_SR_RDIRE | HSMCI_SR_RINDE)) {
				hsmci_debug("%s: CMD 0x%08x sr 0x%08x error\n\r",
						__func__, cmd, sr);
				hsmci_reset();
				return false;
  401d70:	2000      	movs	r0, #0
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
	HSMCI->HSMCI_MR = mr;
  401d72:	6057      	str	r7, [r2, #4]
	HSMCI->HSMCI_DTOR = dtor;
  401d74:	6096      	str	r6, [r2, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  401d76:	60d5      	str	r5, [r2, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  401d78:	61d4      	str	r4, [r2, #28]
	HSMCI->HSMCI_CFG = cfg;
  401d7a:	6551      	str	r1, [r2, #84]	; 0x54
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  401d7c:	6013      	str	r3, [r2, #0]
		if (!hsmci_wait_busy()) {
			return false;
		}
	}
	return true;
}
  401d7e:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
  401d82:	4770      	bx	lr
{
	uint32_t busy_wait = 0xFFFFFFFF;
	uint32_t sr;

	do {
		sr = HSMCI->HSMCI_SR;
  401d84:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  401d88:	4619      	mov	r1, r3
  401d8a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  401d8c:	f04f 30ff 	mov.w	r0, #4294967295
		if (busy_wait-- == 0) {
			hsmci_debug("%s: timeout\n\r", __func__);
			hsmci_reset();
			return false;
		}
	} while (!((sr & HSMCI_SR_NOTBUSY) && ((sr & HSMCI_SR_DTIP) == 0)));
  401d90:	f003 0330 	and.w	r3, r3, #48	; 0x30
  401d94:	2b20      	cmp	r3, #32
{
	uint32_t busy_wait = 0xFFFFFFFF;
	uint32_t sr;

	do {
		sr = HSMCI->HSMCI_SR;
  401d96:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
		if (busy_wait-- == 0) {
			hsmci_debug("%s: timeout\n\r", __func__);
			hsmci_reset();
			return false;
		}
	} while (!((sr & HSMCI_SR_NOTBUSY) && ((sr & HSMCI_SR_DTIP) == 0)));
  401d9a:	d0dd      	beq.n	401d58 <hsmci_send_cmd_execute+0x88>
	uint32_t busy_wait = 0xFFFFFFFF;
	uint32_t sr;

	do {
		sr = HSMCI->HSMCI_SR;
		if (busy_wait-- == 0) {
  401d9c:	3801      	subs	r0, #1
{
	uint32_t busy_wait = 0xFFFFFFFF;
	uint32_t sr;

	do {
		sr = HSMCI->HSMCI_SR;
  401d9e:	6c0b      	ldr	r3, [r1, #64]	; 0x40
		if (busy_wait-- == 0) {
  401da0:	d1f6      	bne.n	401d90 <hsmci_send_cmd_execute+0xc0>
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401da2:	f04f 0c80 	mov.w	ip, #128	; 0x80
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  401da6:	6857      	ldr	r7, [r2, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  401da8:	6896      	ldr	r6, [r2, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  401daa:	68d5      	ldr	r5, [r2, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  401dac:	69d4      	ldr	r4, [r2, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  401dae:	6d51      	ldr	r1, [r2, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401db0:	f8c2 c000 	str.w	ip, [r2]
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  401db4:	2305      	movs	r3, #5
  401db6:	e7dc      	b.n	401d72 <hsmci_send_cmd_execute+0xa2>

00401db8 <hsmci_init>:

//-------------------------------------------------------------------
//--------------------- PUBLIC FUNCTIONS ----------------------------

void hsmci_init(void)
{
  401db8:	b510      	push	{r4, lr}
	pmc_enable_periph_clk(ID_HSMCI);
  401dba:	4b08      	ldr	r3, [pc, #32]	; (401ddc <hsmci_init+0x24>)
  401dbc:	2012      	movs	r0, #18
  401dbe:	4798      	blx	r3
	// Enable clock for DMA controller
	pmc_enable_periph_clk(ID_DMAC);
#endif

	// Set the Data Timeout Register to 2 Mega Cycles
	HSMCI->HSMCI_DTOR = HSMCI_DTOR_DTOMUL_1048576 | HSMCI_DTOR_DTOCYC(2);
  401dc0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  401dc4:	2272      	movs	r2, #114	; 0x72
	// Set Completion Signal Timeout to 2 Mega Cycles
	HSMCI->HSMCI_CSTOR = HSMCI_CSTOR_CSTOMUL_1048576 | HSMCI_CSTOR_CSTOCYC(2);
	// Set Configuration Register
	HSMCI->HSMCI_CFG = HSMCI_CFG_FIFOMODE | HSMCI_CFG_FERRCTRL;
  401dc6:	2411      	movs	r4, #17
	// Set power saving to maximum value
	HSMCI->HSMCI_MR = HSMCI_MR_PWSDIV_Msk;
  401dc8:	f44f 60e0 	mov.w	r0, #1792	; 0x700

	// Enable the HSMCI and the Power Saving
	HSMCI->HSMCI_CR = HSMCI_CR_MCIEN | HSMCI_CR_PWSEN;
  401dcc:	2105      	movs	r1, #5
	// Enable clock for DMA controller
	pmc_enable_periph_clk(ID_DMAC);
#endif

	// Set the Data Timeout Register to 2 Mega Cycles
	HSMCI->HSMCI_DTOR = HSMCI_DTOR_DTOMUL_1048576 | HSMCI_DTOR_DTOCYC(2);
  401dce:	609a      	str	r2, [r3, #8]
	// Set Completion Signal Timeout to 2 Mega Cycles
	HSMCI->HSMCI_CSTOR = HSMCI_CSTOR_CSTOMUL_1048576 | HSMCI_CSTOR_CSTOCYC(2);
  401dd0:	61da      	str	r2, [r3, #28]
	// Set Configuration Register
	HSMCI->HSMCI_CFG = HSMCI_CFG_FIFOMODE | HSMCI_CFG_FERRCTRL;
  401dd2:	655c      	str	r4, [r3, #84]	; 0x54
	// Set power saving to maximum value
	HSMCI->HSMCI_MR = HSMCI_MR_PWSDIV_Msk;
  401dd4:	6058      	str	r0, [r3, #4]

	// Enable the HSMCI and the Power Saving
	HSMCI->HSMCI_CR = HSMCI_CR_MCIEN | HSMCI_CR_PWSEN;
  401dd6:	6019      	str	r1, [r3, #0]
  401dd8:	bd10      	pop	{r4, pc}
  401dda:	bf00      	nop
  401ddc:	0040561d 	.word	0x0040561d

00401de0 <hsmci_get_bus_width>:
}

uint8_t hsmci_get_bus_width(uint8_t slot)
{
	switch (slot) {
  401de0:	2800      	cmp	r0, #0
		return SD_MMC_HSMCI_SLOT_1_SIZE;
#endif
	default:
		return 0; // Slot number wrong
	}
}
  401de2:	bf0c      	ite	eq
  401de4:	2004      	moveq	r0, #4
  401de6:	2000      	movne	r0, #0
  401de8:	4770      	bx	lr
  401dea:	bf00      	nop

00401dec <hsmci_is_high_speed_capable>:

bool hsmci_is_high_speed_capable(void)
{
	return true;
}
  401dec:	2001      	movs	r0, #1
  401dee:	4770      	bx	lr

00401df0 <hsmci_select_device>:
void hsmci_select_device(uint8_t slot, uint32_t clock, uint8_t bus_width, bool high_speed)
{
	uint32_t hsmci_slot = HSMCI_SDCR_SDCSEL_SLOTA;
	uint32_t hsmci_bus_width = HSMCI_SDCR_SDCBUS_1;

	if (high_speed) {
  401df0:	b33b      	cbz	r3, 401e42 <hsmci_select_device+0x52>
		HSMCI->HSMCI_CFG |= HSMCI_CFG_HSMODE;
  401df2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
#else
	uint32_t clkdiv = 0;
	uint32_t rest = 0;

	// Speed = MCK clock / (2 * (CLKDIV + 1))
	if ((speed * 2) < mck) {
  401df6:	0049      	lsls	r1, r1, #1
{
	uint32_t hsmci_slot = HSMCI_SDCR_SDCSEL_SLOTA;
	uint32_t hsmci_bus_width = HSMCI_SDCR_SDCBUS_1;

	if (high_speed) {
		HSMCI->HSMCI_CFG |= HSMCI_CFG_HSMODE;
  401df8:	6d58      	ldr	r0, [r3, #84]	; 0x54
  401dfa:	f440 7080 	orr.w	r0, r0, #256	; 0x100
  401dfe:	6558      	str	r0, [r3, #84]	; 0x54
#else
	uint32_t clkdiv = 0;
	uint32_t rest = 0;

	// Speed = MCK clock / (2 * (CLKDIV + 1))
	if ((speed * 2) < mck) {
  401e00:	4b1a      	ldr	r3, [pc, #104]	; (401e6c <hsmci_select_device+0x7c>)
  401e02:	4299      	cmp	r1, r3
  401e04:	d827      	bhi.n	401e56 <hsmci_select_device+0x66>
		clkdiv = mck / (2 * speed);
  401e06:	3301      	adds	r3, #1
		rest = mck % (2 * speed);
  401e08:	4618      	mov	r0, r3
	uint32_t clkdiv = 0;
	uint32_t rest = 0;

	// Speed = MCK clock / (2 * (CLKDIV + 1))
	if ((speed * 2) < mck) {
		clkdiv = mck / (2 * speed);
  401e0a:	fbb3 f3f1 	udiv	r3, r3, r1
		rest = mck % (2 * speed);
  401e0e:	fb01 f103 	mul.w	r1, r1, r3
  401e12:	1a40      	subs	r0, r0, r1
		if (rest > 0) {
  401e14:	bb08      	cbnz	r0, 401e5a <hsmci_select_device+0x6a>
			// Ensure that the card speed not be higher than expected.
			clkdiv++;
		}
		if (clkdiv > 0) {
  401e16:	bb0b      	cbnz	r3, 401e5c <hsmci_select_device+0x6c>
  401e18:	4619      	mov	r1, r3
			clkdiv -= 1;
		}
	} else {
		clkdiv = 0;
	}
	HSMCI->HSMCI_MR &= ~HSMCI_MR_CLKDIV_Msk;
  401e1a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
#endif
	default:
		Assert(false); // Slot number wrong
	}

	switch (bus_width) {
  401e1e:	2a04      	cmp	r2, #4
			clkdiv -= 1;
		}
	} else {
		clkdiv = 0;
	}
	HSMCI->HSMCI_MR &= ~HSMCI_MR_CLKDIV_Msk;
  401e20:	6858      	ldr	r0, [r3, #4]
  401e22:	f020 00ff 	bic.w	r0, r0, #255	; 0xff
  401e26:	6058      	str	r0, [r3, #4]
	HSMCI->HSMCI_MR |= HSMCI_MR_CLKDIV(clkdiv);
  401e28:	6858      	ldr	r0, [r3, #4]
  401e2a:	ea41 0100 	orr.w	r1, r1, r0
  401e2e:	6059      	str	r1, [r3, #4]
#endif
	default:
		Assert(false); // Slot number wrong
	}

	switch (bus_width) {
  401e30:	d017      	beq.n	401e62 <hsmci_select_device+0x72>
  401e32:	2a08      	cmp	r2, #8
		break;

	default:
		Assert(false); // Bus width wrong
	}
	HSMCI->HSMCI_SDCR = hsmci_slot | hsmci_bus_width;
  401e34:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
}

void hsmci_select_device(uint8_t slot, uint32_t clock, uint8_t bus_width, bool high_speed)
{
	uint32_t hsmci_slot = HSMCI_SDCR_SDCSEL_SLOTA;
	uint32_t hsmci_bus_width = HSMCI_SDCR_SDCBUS_1;
  401e38:	bf0c      	ite	eq
  401e3a:	22c0      	moveq	r2, #192	; 0xc0
  401e3c:	2200      	movne	r2, #0
		break;

	default:
		Assert(false); // Bus width wrong
	}
	HSMCI->HSMCI_SDCR = hsmci_slot | hsmci_bus_width;
  401e3e:	60da      	str	r2, [r3, #12]
  401e40:	4770      	bx	lr
	uint32_t hsmci_bus_width = HSMCI_SDCR_SDCBUS_1;

	if (high_speed) {
		HSMCI->HSMCI_CFG |= HSMCI_CFG_HSMODE;
	} else {
		HSMCI->HSMCI_CFG &= ~HSMCI_CFG_HSMODE;
  401e42:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
#else
	uint32_t clkdiv = 0;
	uint32_t rest = 0;

	// Speed = MCK clock / (2 * (CLKDIV + 1))
	if ((speed * 2) < mck) {
  401e46:	0049      	lsls	r1, r1, #1
	uint32_t hsmci_bus_width = HSMCI_SDCR_SDCBUS_1;

	if (high_speed) {
		HSMCI->HSMCI_CFG |= HSMCI_CFG_HSMODE;
	} else {
		HSMCI->HSMCI_CFG &= ~HSMCI_CFG_HSMODE;
  401e48:	6d58      	ldr	r0, [r3, #84]	; 0x54
  401e4a:	f420 7080 	bic.w	r0, r0, #256	; 0x100
  401e4e:	6558      	str	r0, [r3, #84]	; 0x54
#else
	uint32_t clkdiv = 0;
	uint32_t rest = 0;

	// Speed = MCK clock / (2 * (CLKDIV + 1))
	if ((speed * 2) < mck) {
  401e50:	4b06      	ldr	r3, [pc, #24]	; (401e6c <hsmci_select_device+0x7c>)
  401e52:	4299      	cmp	r1, r3
  401e54:	d9d7      	bls.n	401e06 <hsmci_select_device+0x16>
  401e56:	2100      	movs	r1, #0
  401e58:	e7df      	b.n	401e1a <hsmci_select_device+0x2a>
		clkdiv = mck / (2 * speed);
		rest = mck % (2 * speed);
		if (rest > 0) {
			// Ensure that the card speed not be higher than expected.
			clkdiv++;
  401e5a:	3301      	adds	r3, #1
		}
		if (clkdiv > 0) {
			clkdiv -= 1;
  401e5c:	3b01      	subs	r3, #1
  401e5e:	b2d9      	uxtb	r1, r3
  401e60:	e7db      	b.n	401e1a <hsmci_select_device+0x2a>
		break;

	default:
		Assert(false); // Bus width wrong
	}
	HSMCI->HSMCI_SDCR = hsmci_slot | hsmci_bus_width;
  401e62:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
	case 1:
		hsmci_bus_width = HSMCI_SDCR_SDCBUS_1;
		break;

	case 4:
		hsmci_bus_width = HSMCI_SDCR_SDCBUS_4;
  401e66:	2280      	movs	r2, #128	; 0x80
		break;

	default:
		Assert(false); // Bus width wrong
	}
	HSMCI->HSMCI_SDCR = hsmci_slot | hsmci_bus_width;
  401e68:	60da      	str	r2, [r3, #12]
  401e6a:	4770      	bx	lr
  401e6c:	07270dff 	.word	0x07270dff

00401e70 <hsmci_deselect_device>:
}

void hsmci_deselect_device(uint8_t slot)
{
  401e70:	4770      	bx	lr
  401e72:	bf00      	nop

00401e74 <hsmci_send_clock>:
}

void hsmci_send_clock(void)
{
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
  401e74:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
	// Write argument
	HSMCI->HSMCI_ARGR = 0;
  401e78:	2000      	movs	r0, #0
}

void hsmci_send_clock(void)
{
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
  401e7a:	685a      	ldr	r2, [r3, #4]
	// Write argument
	HSMCI->HSMCI_ARGR = 0;
	// Write and start initialization command
	HSMCI->HSMCI_CMDR = HSMCI_CMDR_RSPTYP_NORESP
  401e7c:	f44f 6110 	mov.w	r1, #2304	; 0x900
}

void hsmci_send_clock(void)
{
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
  401e80:	f422 5260 	bic.w	r2, r2, #14336	; 0x3800
  401e84:	605a      	str	r2, [r3, #4]
	// Write argument
	HSMCI->HSMCI_ARGR = 0;
  401e86:	6118      	str	r0, [r3, #16]
	// Write and start initialization command
	HSMCI->HSMCI_CMDR = HSMCI_CMDR_RSPTYP_NORESP
			| HSMCI_CMDR_SPCMD_INIT
			| HSMCI_CMDR_OPDCMD_OPENDRAIN;
	// Wait end of initialization command
	while (!(HSMCI->HSMCI_SR & HSMCI_SR_CMDRDY));
  401e88:	461a      	mov	r2, r3
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
	// Write argument
	HSMCI->HSMCI_ARGR = 0;
	// Write and start initialization command
	HSMCI->HSMCI_CMDR = HSMCI_CMDR_RSPTYP_NORESP
  401e8a:	6159      	str	r1, [r3, #20]
			| HSMCI_CMDR_SPCMD_INIT
			| HSMCI_CMDR_OPDCMD_OPENDRAIN;
	// Wait end of initialization command
	while (!(HSMCI->HSMCI_SR & HSMCI_SR_CMDRDY));
  401e8c:	6c13      	ldr	r3, [r2, #64]	; 0x40
  401e8e:	07db      	lsls	r3, r3, #31
  401e90:	d5fc      	bpl.n	401e8c <hsmci_send_clock+0x18>
}
  401e92:	4770      	bx	lr

00401e94 <hsmci_send_cmd>:

bool hsmci_send_cmd(sdmmc_cmd_def_t cmd, uint32_t arg)
{
  401e94:	b570      	push	{r4, r5, r6, lr}
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
  401e96:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
#endif
#ifdef HSMCI_MR_PDCMODE
	// Disable PDC for HSMCI
	HSMCI->HSMCI_MR &= ~HSMCI_MR_PDCMODE;
#endif
	HSMCI->HSMCI_BLKR = 0;
  401e9a:	2400      	movs	r4, #0
}

bool hsmci_send_cmd(sdmmc_cmd_def_t cmd, uint32_t arg)
{
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
  401e9c:	685a      	ldr	r2, [r3, #4]
#ifdef HSMCI_MR_PDCMODE
	// Disable PDC for HSMCI
	HSMCI->HSMCI_MR &= ~HSMCI_MR_PDCMODE;
#endif
	HSMCI->HSMCI_BLKR = 0;
	return hsmci_send_cmd_execute(0, cmd, arg);
  401e9e:	4d07      	ldr	r5, [pc, #28]	; (401ebc <hsmci_send_cmd+0x28>)
}

bool hsmci_send_cmd(sdmmc_cmd_def_t cmd, uint32_t arg)
{
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
  401ea0:	f422 5260 	bic.w	r2, r2, #14336	; 0x3800
  401ea4:	605a      	str	r2, [r3, #4]
	// Disable DMA for HSMCI
	HSMCI->HSMCI_DMA = 0;
#endif
#ifdef HSMCI_MR_PDCMODE
	// Disable PDC for HSMCI
	HSMCI->HSMCI_MR &= ~HSMCI_MR_PDCMODE;
  401ea6:	685e      	ldr	r6, [r3, #4]
  401ea8:	f426 4600 	bic.w	r6, r6, #32768	; 0x8000
	// Wait end of initialization command
	while (!(HSMCI->HSMCI_SR & HSMCI_SR_CMDRDY));
}

bool hsmci_send_cmd(sdmmc_cmd_def_t cmd, uint32_t arg)
{
  401eac:	460a      	mov	r2, r1
	// Disable DMA for HSMCI
	HSMCI->HSMCI_DMA = 0;
#endif
#ifdef HSMCI_MR_PDCMODE
	// Disable PDC for HSMCI
	HSMCI->HSMCI_MR &= ~HSMCI_MR_PDCMODE;
  401eae:	605e      	str	r6, [r3, #4]
#endif
	HSMCI->HSMCI_BLKR = 0;
	return hsmci_send_cmd_execute(0, cmd, arg);
  401eb0:	4601      	mov	r1, r0
#endif
#ifdef HSMCI_MR_PDCMODE
	// Disable PDC for HSMCI
	HSMCI->HSMCI_MR &= ~HSMCI_MR_PDCMODE;
#endif
	HSMCI->HSMCI_BLKR = 0;
  401eb2:	619c      	str	r4, [r3, #24]
	return hsmci_send_cmd_execute(0, cmd, arg);
  401eb4:	4620      	mov	r0, r4
  401eb6:	47a8      	blx	r5
}
  401eb8:	bd70      	pop	{r4, r5, r6, pc}
  401eba:	bf00      	nop
  401ebc:	00401cd1 	.word	0x00401cd1

00401ec0 <hsmci_get_response>:

uint32_t hsmci_get_response(void)
{
	return HSMCI->HSMCI_RSPR[0];
  401ec0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  401ec4:	6a18      	ldr	r0, [r3, #32]
}
  401ec6:	4770      	bx	lr

00401ec8 <hsmci_get_response_128>:

void hsmci_get_response_128(uint8_t* response)
{
  401ec8:	b430      	push	{r4, r5}
  401eca:	f100 0510 	add.w	r5, r0, #16
	uint32_t response_32;

	for (uint8_t i = 0; i < 4; i++) {
		response_32 = HSMCI->HSMCI_RSPR[0];
  401ece:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
  401ed2:	6a23      	ldr	r3, [r4, #32]
		response++;
		*response = (response_32 >> 16) & 0xFF;
		response++;
		*response = (response_32 >>  8) & 0xFF;
		response++;
		*response = (response_32 >>  0) & 0xFF;
  401ed4:	70c3      	strb	r3, [r0, #3]
{
	uint32_t response_32;

	for (uint8_t i = 0; i < 4; i++) {
		response_32 = HSMCI->HSMCI_RSPR[0];
		*response = (response_32 >> 24) & 0xFF;
  401ed6:	0e19      	lsrs	r1, r3, #24
		response++;
		*response = (response_32 >> 16) & 0xFF;
  401ed8:	0c1a      	lsrs	r2, r3, #16
		response++;
		*response = (response_32 >>  8) & 0xFF;
  401eda:	0a1b      	lsrs	r3, r3, #8
{
	uint32_t response_32;

	for (uint8_t i = 0; i < 4; i++) {
		response_32 = HSMCI->HSMCI_RSPR[0];
		*response = (response_32 >> 24) & 0xFF;
  401edc:	7001      	strb	r1, [r0, #0]
		response++;
		*response = (response_32 >> 16) & 0xFF;
  401ede:	7042      	strb	r2, [r0, #1]
		response++;
		*response = (response_32 >>  8) & 0xFF;
  401ee0:	7083      	strb	r3, [r0, #2]
  401ee2:	3004      	adds	r0, #4

void hsmci_get_response_128(uint8_t* response)
{
	uint32_t response_32;

	for (uint8_t i = 0; i < 4; i++) {
  401ee4:	42a8      	cmp	r0, r5
  401ee6:	d1f4      	bne.n	401ed2 <hsmci_get_response_128+0xa>
		*response = (response_32 >>  8) & 0xFF;
		response++;
		*response = (response_32 >>  0) & 0xFF;
		response++;
	}
}
  401ee8:	bc30      	pop	{r4, r5}
  401eea:	4770      	bx	lr

00401eec <hsmci_adtc_start>:

bool hsmci_adtc_start(sdmmc_cmd_def_t cmd, uint32_t arg, uint16_t block_size, uint16_t nb_block, bool access_block)
{
  401eec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  401eee:	460e      	mov	r6, r1
  401ef0:	f89d 5018 	ldrb.w	r5, [sp, #24]
#endif

#ifdef HSMCI_MR_PDCMODE
	if (access_block) {
		// Enable PDC for HSMCI
		HSMCI->HSMCI_MR |= HSMCI_MR_PDCMODE;
  401ef4:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
		response++;
	}
}

bool hsmci_adtc_start(sdmmc_cmd_def_t cmd, uint32_t arg, uint16_t block_size, uint16_t nb_block, bool access_block)
{
  401ef8:	4604      	mov	r4, r0
#endif

#ifdef HSMCI_MR_PDCMODE
	if (access_block) {
		// Enable PDC for HSMCI
		HSMCI->HSMCI_MR |= HSMCI_MR_PDCMODE;
  401efa:	6848      	ldr	r0, [r1, #4]
		HSMCI->HSMCI_DMA = 0;
	}
#endif

#ifdef HSMCI_MR_PDCMODE
	if (access_block) {
  401efc:	b34d      	cbz	r5, 401f52 <hsmci_adtc_start+0x66>
		// Enable PDC for HSMCI
		HSMCI->HSMCI_MR |= HSMCI_MR_PDCMODE;
  401efe:	f440 4000 	orr.w	r0, r0, #32768	; 0x8000
  401f02:	6048      	str	r0, [r1, #4]
#endif

	// Enabling Read/Write Proof allows to stop the HSMCI Clock during
	// read/write  access if the internal FIFO is full.
	// This will guarantee data integrity, not bandwidth.
	HSMCI->HSMCI_MR |= HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF;
  401f04:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
	// Force byte transfer if needed
	if (block_size & 0x3) {
  401f08:	0797      	lsls	r7, r2, #30
#endif

	// Enabling Read/Write Proof allows to stop the HSMCI Clock during
	// read/write  access if the internal FIFO is full.
	// This will guarantee data integrity, not bandwidth.
	HSMCI->HSMCI_MR |= HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF;
  401f0a:	6841      	ldr	r1, [r0, #4]
  401f0c:	f441 51c0 	orr.w	r1, r1, #6144	; 0x1800
  401f10:	6041      	str	r1, [r0, #4]
	// Force byte transfer if needed
	if (block_size & 0x3) {
		HSMCI->HSMCI_MR |= HSMCI_MR_FBYTE;
  401f12:	6841      	ldr	r1, [r0, #4]
  401f14:	bf14      	ite	ne
  401f16:	f441 5100 	orrne.w	r1, r1, #8192	; 0x2000
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
  401f1a:	f421 5100 	biceq.w	r1, r1, #8192	; 0x2000
	}

	if (cmd & SDMMC_CMD_WRITE) {
		cmdr = HSMCI_CMDR_TRCMD_START_DATA | HSMCI_CMDR_TRDIR_WRITE;
  401f1e:	f414 4f00 	tst.w	r4, #32768	; 0x8000
	HSMCI->HSMCI_MR |= HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF;
	// Force byte transfer if needed
	if (block_size & 0x3) {
		HSMCI->HSMCI_MR |= HSMCI_MR_FBYTE;
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
  401f22:	6041      	str	r1, [r0, #4]
	}

	if (cmd & SDMMC_CMD_WRITE) {
		cmdr = HSMCI_CMDR_TRCMD_START_DATA | HSMCI_CMDR_TRDIR_WRITE;
  401f24:	bf0c      	ite	eq
  401f26:	f44f 20a0 	moveq.w	r0, #327680	; 0x50000
  401f2a:	f44f 3080 	movne.w	r0, #65536	; 0x10000
	} else {
		cmdr = HSMCI_CMDR_TRCMD_START_DATA | HSMCI_CMDR_TRDIR_READ;
	}

	if (cmd & SDMMC_CMD_SDIO_BYTE) {
  401f2e:	03e5      	lsls	r5, r4, #15
			cmdr |= HSMCI_CMDR_TRTYP_BYTE;
			// Value 0 corresponds to a 512-byte transfer
			HSMCI->HSMCI_BLKR = ((block_size % 512) << HSMCI_BLKR_BCNT_Pos);
  401f30:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
		cmdr = HSMCI_CMDR_TRCMD_START_DATA | HSMCI_CMDR_TRDIR_WRITE;
	} else {
		cmdr = HSMCI_CMDR_TRCMD_START_DATA | HSMCI_CMDR_TRDIR_READ;
	}

	if (cmd & SDMMC_CMD_SDIO_BYTE) {
  401f34:	d421      	bmi.n	401f7a <hsmci_adtc_start+0x8e>
			cmdr |= HSMCI_CMDR_TRTYP_BYTE;
			// Value 0 corresponds to a 512-byte transfer
			HSMCI->HSMCI_BLKR = ((block_size % 512) << HSMCI_BLKR_BCNT_Pos);
	} else {
		HSMCI->HSMCI_BLKR = (block_size << HSMCI_BLKR_BLKLEN_Pos) |
  401f36:	ea43 4502 	orr.w	r5, r3, r2, lsl #16
  401f3a:	618d      	str	r5, [r1, #24]
				(nb_block << HSMCI_BLKR_BCNT_Pos);
		if (cmd & SDMMC_CMD_SDIO_BLOCK) {
  401f3c:	03a1      	lsls	r1, r4, #14
  401f3e:	d40c      	bmi.n	401f5a <hsmci_adtc_start+0x6e>
			cmdr |= HSMCI_CMDR_TRTYP_BLOCK;
		} else if (cmd & SDMMC_CMD_STREAM) {
  401f40:	0367      	lsls	r7, r4, #13
  401f42:	d420      	bmi.n	401f86 <hsmci_adtc_start+0x9a>
			cmdr |= HSMCI_CMDR_TRTYP_STREAM;
		} else if (cmd & SDMMC_CMD_SINGLE_BLOCK) {
  401f44:	0325      	lsls	r5, r4, #12
  401f46:	d40a      	bmi.n	401f5e <hsmci_adtc_start+0x72>
			cmdr |= HSMCI_CMDR_TRTYP_SINGLE;
		} else if (cmd & SDMMC_CMD_MULTI_BLOCK) {
  401f48:	02e1      	lsls	r1, r4, #11
			cmdr |= HSMCI_CMDR_TRTYP_MULTIPLE;
  401f4a:	bf48      	it	mi
  401f4c:	f440 2000 	orrmi.w	r0, r0, #524288	; 0x80000
  401f50:	e005      	b.n	401f5e <hsmci_adtc_start+0x72>
	if (access_block) {
		// Enable PDC for HSMCI
		HSMCI->HSMCI_MR |= HSMCI_MR_PDCMODE;
	} else {
		// Disable PDC for HSMCI
		HSMCI->HSMCI_MR &= ~HSMCI_MR_PDCMODE;
  401f52:	f420 4000 	bic.w	r0, r0, #32768	; 0x8000
  401f56:	6048      	str	r0, [r1, #4]
  401f58:	e7d4      	b.n	401f04 <hsmci_adtc_start+0x18>
			HSMCI->HSMCI_BLKR = ((block_size % 512) << HSMCI_BLKR_BCNT_Pos);
	} else {
		HSMCI->HSMCI_BLKR = (block_size << HSMCI_BLKR_BLKLEN_Pos) |
				(nb_block << HSMCI_BLKR_BCNT_Pos);
		if (cmd & SDMMC_CMD_SDIO_BLOCK) {
			cmdr |= HSMCI_CMDR_TRTYP_BLOCK;
  401f5a:	f440 1020 	orr.w	r0, r0, #2621440	; 0x280000
		} else {
			Assert(false); // Incorrect flags
		}
	}
	hsmci_transfert_pos = 0;
	hsmci_block_size = block_size;
  401f5e:	490b      	ldr	r1, [pc, #44]	; (401f8c <hsmci_adtc_start+0xa0>)
			cmdr |= HSMCI_CMDR_TRTYP_MULTIPLE;
		} else {
			Assert(false); // Incorrect flags
		}
	}
	hsmci_transfert_pos = 0;
  401f60:	f8df e034 	ldr.w	lr, [pc, #52]	; 401f98 <hsmci_adtc_start+0xac>
	hsmci_block_size = block_size;
	hsmci_nb_block = nb_block;
  401f64:	4f0a      	ldr	r7, [pc, #40]	; (401f90 <hsmci_adtc_start+0xa4>)
		} else {
			Assert(false); // Incorrect flags
		}
	}
	hsmci_transfert_pos = 0;
	hsmci_block_size = block_size;
  401f66:	800a      	strh	r2, [r1, #0]
	hsmci_nb_block = nb_block;

	return hsmci_send_cmd_execute(cmdr, cmd, arg);
  401f68:	4d0a      	ldr	r5, [pc, #40]	; (401f94 <hsmci_adtc_start+0xa8>)
			Assert(false); // Incorrect flags
		}
	}
	hsmci_transfert_pos = 0;
	hsmci_block_size = block_size;
	hsmci_nb_block = nb_block;
  401f6a:	803b      	strh	r3, [r7, #0]

	return hsmci_send_cmd_execute(cmdr, cmd, arg);
  401f6c:	4621      	mov	r1, r4
  401f6e:	4632      	mov	r2, r6
			cmdr |= HSMCI_CMDR_TRTYP_MULTIPLE;
		} else {
			Assert(false); // Incorrect flags
		}
	}
	hsmci_transfert_pos = 0;
  401f70:	2400      	movs	r4, #0
  401f72:	f8ce 4000 	str.w	r4, [lr]
	hsmci_block_size = block_size;
	hsmci_nb_block = nb_block;

	return hsmci_send_cmd_execute(cmdr, cmd, arg);
  401f76:	47a8      	blx	r5
}
  401f78:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	}

	if (cmd & SDMMC_CMD_SDIO_BYTE) {
			cmdr |= HSMCI_CMDR_TRTYP_BYTE;
			// Value 0 corresponds to a 512-byte transfer
			HSMCI->HSMCI_BLKR = ((block_size % 512) << HSMCI_BLKR_BCNT_Pos);
  401f7a:	f3c2 0508 	ubfx	r5, r2, #0, #9
	} else {
		cmdr = HSMCI_CMDR_TRCMD_START_DATA | HSMCI_CMDR_TRDIR_READ;
	}

	if (cmd & SDMMC_CMD_SDIO_BYTE) {
			cmdr |= HSMCI_CMDR_TRTYP_BYTE;
  401f7e:	f440 1000 	orr.w	r0, r0, #2097152	; 0x200000
			// Value 0 corresponds to a 512-byte transfer
			HSMCI->HSMCI_BLKR = ((block_size % 512) << HSMCI_BLKR_BCNT_Pos);
  401f82:	618d      	str	r5, [r1, #24]
  401f84:	e7eb      	b.n	401f5e <hsmci_adtc_start+0x72>
		HSMCI->HSMCI_BLKR = (block_size << HSMCI_BLKR_BLKLEN_Pos) |
				(nb_block << HSMCI_BLKR_BCNT_Pos);
		if (cmd & SDMMC_CMD_SDIO_BLOCK) {
			cmdr |= HSMCI_CMDR_TRTYP_BLOCK;
		} else if (cmd & SDMMC_CMD_STREAM) {
			cmdr |= HSMCI_CMDR_TRTYP_STREAM;
  401f86:	f440 1080 	orr.w	r0, r0, #1048576	; 0x100000
  401f8a:	e7e8      	b.n	401f5e <hsmci_adtc_start+0x72>
  401f8c:	20000f5c 	.word	0x20000f5c
  401f90:	20000f5e 	.word	0x20000f5e
  401f94:	00401cd1 	.word	0x00401cd1
  401f98:	20000f60 	.word	0x20000f60

00401f9c <hsmci_read_word>:
{
	return hsmci_send_cmd_execute(HSMCI_CMDR_TRCMD_STOP_DATA, cmd, arg);
}

bool hsmci_read_word(uint32_t* value)
{
  401f9c:	b4f0      	push	{r4, r5, r6, r7}

	Assert(((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos);

	// Wait data available
	do {
		sr = HSMCI->HSMCI_SR;
  401f9e:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
  401fa2:	e001      	b.n	401fa8 <hsmci_read_word+0xc>
			hsmci_debug("%s: DMA sr 0x%08x error\n\r",
					__func__, sr);
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_RXRDY));
  401fa4:	0792      	lsls	r2, r2, #30
  401fa6:	d417      	bmi.n	401fd8 <hsmci_read_word+0x3c>

	Assert(((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos);

	// Wait data available
	do {
		sr = HSMCI->HSMCI_SR;
  401fa8:	6c22      	ldr	r2, [r4, #64]	; 0x40
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  401faa:	4b21      	ldr	r3, [pc, #132]	; (402030 <hsmci_read_word+0x94>)
  401fac:	4013      	ands	r3, r2

	Assert(((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos);

	// Wait data available
	do {
		sr = HSMCI->HSMCI_SR;
  401fae:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  401fb2:	2b00      	cmp	r3, #0
  401fb4:	d0f6      	beq.n	401fa4 <hsmci_read_word+0x8>
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  401fb6:	684f      	ldr	r7, [r1, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  401fb8:	688e      	ldr	r6, [r1, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  401fba:	68cd      	ldr	r5, [r1, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  401fbc:	69cc      	ldr	r4, [r1, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  401fbe:	6d4a      	ldr	r2, [r1, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401fc0:	2080      	movs	r0, #128	; 0x80
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  401fc2:	2305      	movs	r3, #5
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401fc4:	6008      	str	r0, [r1, #0]
	HSMCI->HSMCI_MR = mr;
  401fc6:	604f      	str	r7, [r1, #4]
	HSMCI->HSMCI_DTOR = dtor;
  401fc8:	608e      	str	r6, [r1, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  401fca:	60cd      	str	r5, [r1, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  401fcc:	61cc      	str	r4, [r1, #28]
	HSMCI->HSMCI_CFG = cfg;
  401fce:	654a      	str	r2, [r1, #84]	; 0x54
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  401fd0:	600b      	str	r3, [r1, #0]
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: DMA sr 0x%08x error\n\r",
					__func__, sr);
			hsmci_reset();
			return false;
  401fd2:	2000      	movs	r0, #0
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
	return true;
}
  401fd4:	bcf0      	pop	{r4, r5, r6, r7}
  401fd6:	4770      	bx	lr
		}
	} while (!(sr & HSMCI_SR_RXRDY));

	// Read data
	*value = HSMCI->HSMCI_RDR;
	hsmci_transfert_pos += 4;
  401fd8:	4a16      	ldr	r2, [pc, #88]	; (402034 <hsmci_read_word+0x98>)
	if (((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos) {
  401fda:	4c17      	ldr	r4, [pc, #92]	; (402038 <hsmci_read_word+0x9c>)
  401fdc:	4d17      	ldr	r5, [pc, #92]	; (40203c <hsmci_read_word+0xa0>)
		}
	} while (!(sr & HSMCI_SR_RXRDY));

	// Read data
	*value = HSMCI->HSMCI_RDR;
	hsmci_transfert_pos += 4;
  401fde:	6813      	ldr	r3, [r2, #0]
	if (((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos) {
  401fe0:	8826      	ldrh	r6, [r4, #0]
  401fe2:	882d      	ldrh	r5, [r5, #0]
			return false;
		}
	} while (!(sr & HSMCI_SR_RXRDY));

	// Read data
	*value = HSMCI->HSMCI_RDR;
  401fe4:	6b0c      	ldr	r4, [r1, #48]	; 0x30
  401fe6:	6004      	str	r4, [r0, #0]
	hsmci_transfert_pos += 4;
  401fe8:	3304      	adds	r3, #4
	if (((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos) {
  401fea:	fb06 f005 	mul.w	r0, r6, r5
  401fee:	4283      	cmp	r3, r0
		}
	} while (!(sr & HSMCI_SR_RXRDY));

	// Read data
	*value = HSMCI->HSMCI_RDR;
	hsmci_transfert_pos += 4;
  401ff0:	6013      	str	r3, [r2, #0]
	if (((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos) {
  401ff2:	d202      	bcs.n	401ffa <hsmci_read_word+0x5e>
  401ff4:	e019      	b.n	40202a <hsmci_read_word+0x8e>
			hsmci_debug("%s: DMA sr 0x%08x error\n\r",
					__func__, sr);
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
  401ff6:	0113      	lsls	r3, r2, #4
  401ff8:	d417      	bmi.n	40202a <hsmci_read_word+0x8e>
	}

	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI
	do {
		sr = HSMCI->HSMCI_SR;
  401ffa:	6c0a      	ldr	r2, [r1, #64]	; 0x40
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  401ffc:	4b0c      	ldr	r3, [pc, #48]	; (402030 <hsmci_read_word+0x94>)
  401ffe:	4013      	ands	r3, r2
	}

	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI
	do {
		sr = HSMCI->HSMCI_SR;
  402000:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  402004:	2b00      	cmp	r3, #0
  402006:	d0f6      	beq.n	401ff6 <hsmci_read_word+0x5a>
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  402008:	6867      	ldr	r7, [r4, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  40200a:	68a6      	ldr	r6, [r4, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  40200c:	68e5      	ldr	r5, [r4, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  40200e:	69e1      	ldr	r1, [r4, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  402010:	6d62      	ldr	r2, [r4, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  402012:	2080      	movs	r0, #128	; 0x80
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  402014:	2305      	movs	r3, #5
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  402016:	6020      	str	r0, [r4, #0]
	HSMCI->HSMCI_MR = mr;
  402018:	6067      	str	r7, [r4, #4]
	HSMCI->HSMCI_DTOR = dtor;
  40201a:	60a6      	str	r6, [r4, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  40201c:	60e5      	str	r5, [r4, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  40201e:	61e1      	str	r1, [r4, #28]
	HSMCI->HSMCI_CFG = cfg;
  402020:	6562      	str	r2, [r4, #84]	; 0x54
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  402022:	6023      	str	r3, [r4, #0]
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: DMA sr 0x%08x error\n\r",
					__func__, sr);
			hsmci_reset();
			return false;
  402024:	2000      	movs	r0, #0
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
	return true;
}
  402026:	bcf0      	pop	{r4, r5, r6, r7}
  402028:	4770      	bx	lr

	// Read data
	*value = HSMCI->HSMCI_RDR;
	hsmci_transfert_pos += 4;
	if (((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos) {
		return true;
  40202a:	2001      	movs	r0, #1
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
	return true;
}
  40202c:	bcf0      	pop	{r4, r5, r6, r7}
  40202e:	4770      	bx	lr
  402030:	c0600000 	.word	0xc0600000
  402034:	20000f60 	.word	0x20000f60
  402038:	20000f5c 	.word	0x20000f5c
  40203c:	20000f5e 	.word	0x20000f5e

00402040 <hsmci_start_read_blocks>:
}
#endif // HSMCI_SR_DMADONE

#ifdef HSMCI_MR_PDCMODE
bool hsmci_start_read_blocks(void *dest, uint16_t nb_block)
{
  402040:	b430      	push	{r4, r5}
	uint32_t nb_data;

	nb_data = nb_block * hsmci_block_size;
  402042:	4b17      	ldr	r3, [pc, #92]	; (4020a0 <hsmci_start_read_blocks+0x60>)
  402044:	881b      	ldrh	r3, [r3, #0]
	Assert(nb_data <= (((uint32_t)hsmci_block_size * hsmci_nb_block) - hsmci_transfert_pos));
	Assert(nb_data <= (PERIPH_RCR_RXCTR_Msk >> PERIPH_RCR_RXCTR_Pos));

	// Handle unaligned memory address
	if (((uint32_t)dest & 0x3) || (hsmci_block_size & 0x3)) {
  402046:	0784      	lsls	r4, r0, #30
#ifdef HSMCI_MR_PDCMODE
bool hsmci_start_read_blocks(void *dest, uint16_t nb_block)
{
	uint32_t nb_data;

	nb_data = nb_block * hsmci_block_size;
  402048:	fb03 f101 	mul.w	r1, r3, r1
	Assert(nb_data <= (((uint32_t)hsmci_block_size * hsmci_nb_block) - hsmci_transfert_pos));
	Assert(nb_data <= (PERIPH_RCR_RXCTR_Msk >> PERIPH_RCR_RXCTR_Pos));

	// Handle unaligned memory address
	if (((uint32_t)dest & 0x3) || (hsmci_block_size & 0x3)) {
  40204c:	d101      	bne.n	402052 <hsmci_start_read_blocks+0x12>
  40204e:	079a      	lsls	r2, r3, #30
  402050:	d01e      	beq.n	402090 <hsmci_start_read_blocks+0x50>
		HSMCI->HSMCI_MR |= HSMCI_MR_FBYTE;
  402052:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  402056:	685a      	ldr	r2, [r3, #4]
  402058:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
  40205c:	605a      	str	r2, [r3, #4]
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
	}

	// Configure PDC transfer
	HSMCI->HSMCI_RPR = (uint32_t)dest;
  40205e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
	HSMCI->HSMCI_RCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
			nb_data : nb_data / 4;
	HSMCI->HSMCI_RNCR = 0;
  402062:	2400      	movs	r4, #0
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
	}

	// Configure PDC transfer
	HSMCI->HSMCI_RPR = (uint32_t)dest;
  402064:	f8c3 0100 	str.w	r0, [r3, #256]	; 0x100
	HSMCI->HSMCI_RCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  402068:	685b      	ldr	r3, [r3, #4]
			nb_data : nb_data / 4;
	HSMCI->HSMCI_RNCR = 0;
	// Start transfer
	HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTEN;
	hsmci_transfert_pos += nb_data;
  40206a:	4a0e      	ldr	r2, [pc, #56]	; (4020a4 <hsmci_start_read_blocks+0x64>)
	}

	// Configure PDC transfer
	HSMCI->HSMCI_RPR = (uint32_t)dest;
	HSMCI->HSMCI_RCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
			nb_data : nb_data / 4;
  40206c:	049b      	lsls	r3, r3, #18
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
	}

	// Configure PDC transfer
	HSMCI->HSMCI_RPR = (uint32_t)dest;
	HSMCI->HSMCI_RCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  40206e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
			nb_data : nb_data / 4;
  402072:	bf54      	ite	pl
  402074:	088d      	lsrpl	r5, r1, #2
  402076:	460d      	movmi	r5, r1
	HSMCI->HSMCI_RNCR = 0;
	// Start transfer
	HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTEN;
  402078:	2001      	movs	r0, #1
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
	}

	// Configure PDC transfer
	HSMCI->HSMCI_RPR = (uint32_t)dest;
	HSMCI->HSMCI_RCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  40207a:	f8c3 5104 	str.w	r5, [r3, #260]	; 0x104
			nb_data : nb_data / 4;
	HSMCI->HSMCI_RNCR = 0;
  40207e:	f8c3 4114 	str.w	r4, [r3, #276]	; 0x114
	// Start transfer
	HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTEN;
  402082:	f8c3 0120 	str.w	r0, [r3, #288]	; 0x120
	hsmci_transfert_pos += nb_data;
  402086:	6813      	ldr	r3, [r2, #0]
  402088:	4419      	add	r1, r3
  40208a:	6011      	str	r1, [r2, #0]
	return true;
}
  40208c:	bc30      	pop	{r4, r5}
  40208e:	4770      	bx	lr

	// Handle unaligned memory address
	if (((uint32_t)dest & 0x3) || (hsmci_block_size & 0x3)) {
		HSMCI->HSMCI_MR |= HSMCI_MR_FBYTE;
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
  402090:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  402094:	685a      	ldr	r2, [r3, #4]
  402096:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
  40209a:	605a      	str	r2, [r3, #4]
  40209c:	e7df      	b.n	40205e <hsmci_start_read_blocks+0x1e>
  40209e:	bf00      	nop
  4020a0:	20000f5c 	.word	0x20000f5c
  4020a4:	20000f60 	.word	0x20000f60

004020a8 <hsmci_wait_end_of_read_blocks>:
	hsmci_transfert_pos += nb_data;
	return true;
}

bool hsmci_wait_end_of_read_blocks(void)
{
  4020a8:	b4f0      	push	{r4, r5, r6, r7}
	uint32_t sr;
	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  4020aa:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
  4020ae:	e001      	b.n	4020b4 <hsmci_wait_end_of_read_blocks+0xc>
			HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTDIS | HSMCI_PTCR_TXTDIS;
			hsmci_reset();
			return false;
		}

	} while (!(sr & HSMCI_SR_RXBUFF));
  4020b0:	0452      	lsls	r2, r2, #17
  4020b2:	d41b      	bmi.n	4020ec <hsmci_wait_end_of_read_blocks+0x44>
{
	uint32_t sr;
	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  4020b4:	6c02      	ldr	r2, [r0, #64]	; 0x40
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  4020b6:	4b21      	ldr	r3, [pc, #132]	; (40213c <hsmci_wait_end_of_read_blocks+0x94>)
  4020b8:	4013      	ands	r3, r2
{
	uint32_t sr;
	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  4020ba:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  4020be:	2b00      	cmp	r3, #0
  4020c0:	d0f6      	beq.n	4020b0 <hsmci_wait_end_of_read_blocks+0x8>
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: PDC sr 0x%08x error\n\r",
					__func__, sr);
			HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTDIS | HSMCI_PTCR_TXTDIS;
  4020c2:	f240 2302 	movw	r3, #514	; 0x202
  4020c6:	f8c1 3120 	str.w	r3, [r1, #288]	; 0x120
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  4020ca:	684f      	ldr	r7, [r1, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  4020cc:	688e      	ldr	r6, [r1, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  4020ce:	68cd      	ldr	r5, [r1, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  4020d0:	69cc      	ldr	r4, [r1, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  4020d2:	6d4a      	ldr	r2, [r1, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  4020d4:	2080      	movs	r0, #128	; 0x80
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  4020d6:	2305      	movs	r3, #5
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  4020d8:	6008      	str	r0, [r1, #0]
	HSMCI->HSMCI_MR = mr;
  4020da:	604f      	str	r7, [r1, #4]
	HSMCI->HSMCI_DTOR = dtor;
  4020dc:	608e      	str	r6, [r1, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  4020de:	60cd      	str	r5, [r1, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  4020e0:	61cc      	str	r4, [r1, #28]
	HSMCI->HSMCI_CFG = cfg;
  4020e2:	654a      	str	r2, [r1, #84]	; 0x54
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  4020e4:	600b      	str	r3, [r1, #0]
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: PDC sr 0x%08x error\n\r",
					__func__, sr);
			HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTDIS | HSMCI_PTCR_TXTDIS;
			hsmci_reset();
			return false;
  4020e6:	2000      	movs	r0, #0
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
	return true;
}
  4020e8:	bcf0      	pop	{r4, r5, r6, r7}
  4020ea:	4770      	bx	lr
			return false;
		}

	} while (!(sr & HSMCI_SR_RXBUFF));

	if (hsmci_transfert_pos < ((uint32_t)hsmci_block_size * hsmci_nb_block)) {
  4020ec:	4a14      	ldr	r2, [pc, #80]	; (402140 <hsmci_wait_end_of_read_blocks+0x98>)
  4020ee:	4815      	ldr	r0, [pc, #84]	; (402144 <hsmci_wait_end_of_read_blocks+0x9c>)
  4020f0:	4b15      	ldr	r3, [pc, #84]	; (402148 <hsmci_wait_end_of_read_blocks+0xa0>)
  4020f2:	8812      	ldrh	r2, [r2, #0]
  4020f4:	8800      	ldrh	r0, [r0, #0]
  4020f6:	681b      	ldr	r3, [r3, #0]
  4020f8:	fb00 f202 	mul.w	r2, r0, r2
  4020fc:	429a      	cmp	r2, r3
  4020fe:	d902      	bls.n	402106 <hsmci_wait_end_of_read_blocks+0x5e>
  402100:	e019      	b.n	402136 <hsmci_wait_end_of_read_blocks+0x8e>
			hsmci_debug("%s: PDC sr 0x%08x last transfer error\n\r",
					__func__, sr);
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
  402102:	0113      	lsls	r3, r2, #4
  402104:	d417      	bmi.n	402136 <hsmci_wait_end_of_read_blocks+0x8e>
		return true;
	}
	// It is the last transfer, then wait command completed
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  402106:	6c0a      	ldr	r2, [r1, #64]	; 0x40
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  402108:	4b0c      	ldr	r3, [pc, #48]	; (40213c <hsmci_wait_end_of_read_blocks+0x94>)
  40210a:	4013      	ands	r3, r2
		return true;
	}
	// It is the last transfer, then wait command completed
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  40210c:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  402110:	2b00      	cmp	r3, #0
  402112:	d0f6      	beq.n	402102 <hsmci_wait_end_of_read_blocks+0x5a>
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  402114:	6867      	ldr	r7, [r4, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  402116:	68a6      	ldr	r6, [r4, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  402118:	68e5      	ldr	r5, [r4, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  40211a:	69e1      	ldr	r1, [r4, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  40211c:	6d62      	ldr	r2, [r4, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  40211e:	2080      	movs	r0, #128	; 0x80
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  402120:	2305      	movs	r3, #5
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  402122:	6020      	str	r0, [r4, #0]
	HSMCI->HSMCI_MR = mr;
  402124:	6067      	str	r7, [r4, #4]
	HSMCI->HSMCI_DTOR = dtor;
  402126:	60a6      	str	r6, [r4, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  402128:	60e5      	str	r5, [r4, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  40212a:	61e1      	str	r1, [r4, #28]
	HSMCI->HSMCI_CFG = cfg;
  40212c:	6562      	str	r2, [r4, #84]	; 0x54
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  40212e:	6023      	str	r3, [r4, #0]
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: PDC sr 0x%08x last transfer error\n\r",
					__func__, sr);
			hsmci_reset();
			return false;
  402130:	2000      	movs	r0, #0
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
	return true;
}
  402132:	bcf0      	pop	{r4, r5, r6, r7}
  402134:	4770      	bx	lr
		}

	} while (!(sr & HSMCI_SR_RXBUFF));

	if (hsmci_transfert_pos < ((uint32_t)hsmci_block_size * hsmci_nb_block)) {
		return true;
  402136:	2001      	movs	r0, #1
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
	return true;
}
  402138:	bcf0      	pop	{r4, r5, r6, r7}
  40213a:	4770      	bx	lr
  40213c:	c0600000 	.word	0xc0600000
  402140:	20000f5e 	.word	0x20000f5e
  402144:	20000f5c 	.word	0x20000f5c
  402148:	20000f60 	.word	0x20000f60

0040214c <hsmci_start_write_blocks>:

bool hsmci_start_write_blocks(const void *src, uint16_t nb_block)
{
  40214c:	b430      	push	{r4, r5}
	uint32_t nb_data;

	nb_data = nb_block * hsmci_block_size;
  40214e:	4b18      	ldr	r3, [pc, #96]	; (4021b0 <hsmci_start_write_blocks+0x64>)
  402150:	881b      	ldrh	r3, [r3, #0]
	Assert(nb_data <= (((uint32_t)hsmci_block_size * hsmci_nb_block) - hsmci_transfert_pos));
	Assert(nb_data <= (PERIPH_TCR_TXCTR_Msk >> PERIPH_TCR_TXCTR_Pos));

	// Handle unaligned memory address
	if (((uint32_t)src & 0x3) || (hsmci_block_size & 0x3)) {
  402152:	0784      	lsls	r4, r0, #30

bool hsmci_start_write_blocks(const void *src, uint16_t nb_block)
{
	uint32_t nb_data;

	nb_data = nb_block * hsmci_block_size;
  402154:	fb03 f101 	mul.w	r1, r3, r1
	Assert(nb_data <= (((uint32_t)hsmci_block_size * hsmci_nb_block) - hsmci_transfert_pos));
	Assert(nb_data <= (PERIPH_TCR_TXCTR_Msk >> PERIPH_TCR_TXCTR_Pos));

	// Handle unaligned memory address
	if (((uint32_t)src & 0x3) || (hsmci_block_size & 0x3)) {
  402158:	d101      	bne.n	40215e <hsmci_start_write_blocks+0x12>
  40215a:	079a      	lsls	r2, r3, #30
  40215c:	d020      	beq.n	4021a0 <hsmci_start_write_blocks+0x54>
		HSMCI->HSMCI_MR |= HSMCI_MR_FBYTE;
  40215e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  402162:	685a      	ldr	r2, [r3, #4]
  402164:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
  402168:	605a      	str	r2, [r3, #4]
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
	}

	// Configure PDC transfer
	HSMCI->HSMCI_TPR = (uint32_t)src;
  40216a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
	HSMCI->HSMCI_TCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
			nb_data : nb_data / 4;
	HSMCI->HSMCI_TNCR = 0;
  40216e:	2400      	movs	r4, #0
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
	}

	// Configure PDC transfer
	HSMCI->HSMCI_TPR = (uint32_t)src;
  402170:	f8c3 0108 	str.w	r0, [r3, #264]	; 0x108
	HSMCI->HSMCI_TCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  402174:	685b      	ldr	r3, [r3, #4]
			nb_data : nb_data / 4;
	HSMCI->HSMCI_TNCR = 0;
	// Start transfer
	HSMCI->HSMCI_PTCR = HSMCI_PTCR_TXTEN;
	hsmci_transfert_pos += nb_data;
  402176:	4a0f      	ldr	r2, [pc, #60]	; (4021b4 <hsmci_start_write_blocks+0x68>)
	}

	// Configure PDC transfer
	HSMCI->HSMCI_TPR = (uint32_t)src;
	HSMCI->HSMCI_TCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
			nb_data : nb_data / 4;
  402178:	049b      	lsls	r3, r3, #18
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
	}

	// Configure PDC transfer
	HSMCI->HSMCI_TPR = (uint32_t)src;
	HSMCI->HSMCI_TCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  40217a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
			nb_data : nb_data / 4;
  40217e:	bf54      	ite	pl
  402180:	088d      	lsrpl	r5, r1, #2
  402182:	460d      	movmi	r5, r1
	HSMCI->HSMCI_TNCR = 0;
	// Start transfer
	HSMCI->HSMCI_PTCR = HSMCI_PTCR_TXTEN;
  402184:	f44f 7080 	mov.w	r0, #256	; 0x100
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
	}

	// Configure PDC transfer
	HSMCI->HSMCI_TPR = (uint32_t)src;
	HSMCI->HSMCI_TCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  402188:	f8c3 510c 	str.w	r5, [r3, #268]	; 0x10c
			nb_data : nb_data / 4;
	HSMCI->HSMCI_TNCR = 0;
  40218c:	f8c3 411c 	str.w	r4, [r3, #284]	; 0x11c
	// Start transfer
	HSMCI->HSMCI_PTCR = HSMCI_PTCR_TXTEN;
  402190:	f8c3 0120 	str.w	r0, [r3, #288]	; 0x120
	hsmci_transfert_pos += nb_data;
  402194:	6813      	ldr	r3, [r2, #0]
  402196:	4419      	add	r1, r3
  402198:	6011      	str	r1, [r2, #0]
	return true;
}
  40219a:	2001      	movs	r0, #1
  40219c:	bc30      	pop	{r4, r5}
  40219e:	4770      	bx	lr

	// Handle unaligned memory address
	if (((uint32_t)src & 0x3) || (hsmci_block_size & 0x3)) {
		HSMCI->HSMCI_MR |= HSMCI_MR_FBYTE;
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
  4021a0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  4021a4:	685a      	ldr	r2, [r3, #4]
  4021a6:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
  4021aa:	605a      	str	r2, [r3, #4]
  4021ac:	e7dd      	b.n	40216a <hsmci_start_write_blocks+0x1e>
  4021ae:	bf00      	nop
  4021b0:	20000f5c 	.word	0x20000f5c
  4021b4:	20000f60 	.word	0x20000f60

004021b8 <hsmci_wait_end_of_write_blocks>:
	hsmci_transfert_pos += nb_data;
	return true;
}

bool hsmci_wait_end_of_write_blocks(void)
{
  4021b8:	b4f0      	push	{r4, r5, r6, r7}
	uint32_t sr;

	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  4021ba:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
  4021be:	e001      	b.n	4021c4 <hsmci_wait_end_of_write_blocks+0xc>
					__func__, sr);
			hsmci_reset();
			HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTDIS | HSMCI_PTCR_TXTDIS;
			return false;
		}
	} while (!(sr & HSMCI_SR_TXBUFE));
  4021c0:	0412      	lsls	r2, r2, #16
  4021c2:	d41d      	bmi.n	402200 <hsmci_wait_end_of_write_blocks+0x48>
	uint32_t sr;

	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  4021c4:	6c02      	ldr	r2, [r0, #64]	; 0x40
		if (sr &
  4021c6:	4b22      	ldr	r3, [pc, #136]	; (402250 <hsmci_wait_end_of_write_blocks+0x98>)
  4021c8:	4013      	ands	r3, r2
	uint32_t sr;

	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  4021ca:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
		if (sr &
  4021ce:	2b00      	cmp	r3, #0
  4021d0:	d0f6      	beq.n	4021c0 <hsmci_wait_end_of_write_blocks+0x8>
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  4021d2:	f8d1 c004 	ldr.w	ip, [r1, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  4021d6:	688f      	ldr	r7, [r1, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  4021d8:	68ce      	ldr	r6, [r1, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  4021da:	69cd      	ldr	r5, [r1, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  4021dc:	6d4c      	ldr	r4, [r1, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  4021de:	2080      	movs	r0, #128	; 0x80
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  4021e0:	2205      	movs	r2, #5
				(HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: PDC sr 0x%08x error\n\r",
					__func__, sr);
			hsmci_reset();
			HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTDIS | HSMCI_PTCR_TXTDIS;
  4021e2:	f240 2302 	movw	r3, #514	; 0x202
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  4021e6:	6008      	str	r0, [r1, #0]
	HSMCI->HSMCI_MR = mr;
  4021e8:	f8c1 c004 	str.w	ip, [r1, #4]
	HSMCI->HSMCI_DTOR = dtor;
  4021ec:	608f      	str	r7, [r1, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  4021ee:	60ce      	str	r6, [r1, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  4021f0:	61cd      	str	r5, [r1, #28]
	HSMCI->HSMCI_CFG = cfg;
  4021f2:	654c      	str	r4, [r1, #84]	; 0x54
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  4021f4:	600a      	str	r2, [r1, #0]
				(HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: PDC sr 0x%08x error\n\r",
					__func__, sr);
			hsmci_reset();
			HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTDIS | HSMCI_PTCR_TXTDIS;
  4021f6:	f8c1 3120 	str.w	r3, [r1, #288]	; 0x120
			return false;
  4021fa:	2000      	movs	r0, #0
			return false;
		}
	} while (!(sr & HSMCI_SR_NOTBUSY));
	Assert(HSMCI->HSMCI_SR & HSMCI_SR_FIFOEMPTY);
	return true;
}
  4021fc:	bcf0      	pop	{r4, r5, r6, r7}
  4021fe:	4770      	bx	lr
			return false;
		}
	} while (!(sr & HSMCI_SR_TXBUFE));


	if (hsmci_transfert_pos < ((uint32_t)hsmci_block_size * hsmci_nb_block)) {
  402200:	4a14      	ldr	r2, [pc, #80]	; (402254 <hsmci_wait_end_of_write_blocks+0x9c>)
  402202:	4815      	ldr	r0, [pc, #84]	; (402258 <hsmci_wait_end_of_write_blocks+0xa0>)
  402204:	4b15      	ldr	r3, [pc, #84]	; (40225c <hsmci_wait_end_of_write_blocks+0xa4>)
  402206:	8812      	ldrh	r2, [r2, #0]
  402208:	8800      	ldrh	r0, [r0, #0]
  40220a:	681b      	ldr	r3, [r3, #0]
  40220c:	fb00 f202 	mul.w	r2, r0, r2
  402210:	429a      	cmp	r2, r3
  402212:	d902      	bls.n	40221a <hsmci_wait_end_of_write_blocks+0x62>
  402214:	e019      	b.n	40224a <hsmci_wait_end_of_write_blocks+0x92>
			hsmci_debug("%s: PDC sr 0x%08x last transfer error\n\r",
					__func__, sr);
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_NOTBUSY));
  402216:	0693      	lsls	r3, r2, #26
  402218:	d417      	bmi.n	40224a <hsmci_wait_end_of_write_blocks+0x92>
		return true;
	}
	// It is the last transfer, then wait command completed
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  40221a:	6c0a      	ldr	r2, [r1, #64]	; 0x40
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  40221c:	4b0c      	ldr	r3, [pc, #48]	; (402250 <hsmci_wait_end_of_write_blocks+0x98>)
  40221e:	4013      	ands	r3, r2
		return true;
	}
	// It is the last transfer, then wait command completed
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  402220:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  402224:	2b00      	cmp	r3, #0
  402226:	d0f6      	beq.n	402216 <hsmci_wait_end_of_write_blocks+0x5e>
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  402228:	6867      	ldr	r7, [r4, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  40222a:	68a6      	ldr	r6, [r4, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  40222c:	68e5      	ldr	r5, [r4, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  40222e:	69e1      	ldr	r1, [r4, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  402230:	6d62      	ldr	r2, [r4, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  402232:	2080      	movs	r0, #128	; 0x80
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  402234:	2305      	movs	r3, #5
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  402236:	6020      	str	r0, [r4, #0]
	HSMCI->HSMCI_MR = mr;
  402238:	6067      	str	r7, [r4, #4]
	HSMCI->HSMCI_DTOR = dtor;
  40223a:	60a6      	str	r6, [r4, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  40223c:	60e5      	str	r5, [r4, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  40223e:	61e1      	str	r1, [r4, #28]
	HSMCI->HSMCI_CFG = cfg;
  402240:	6562      	str	r2, [r4, #84]	; 0x54
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  402242:	6023      	str	r3, [r4, #0]
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: PDC sr 0x%08x last transfer error\n\r",
					__func__, sr);
			hsmci_reset();
			return false;
  402244:	2000      	movs	r0, #0
		}
	} while (!(sr & HSMCI_SR_NOTBUSY));
	Assert(HSMCI->HSMCI_SR & HSMCI_SR_FIFOEMPTY);
	return true;
}
  402246:	bcf0      	pop	{r4, r5, r6, r7}
  402248:	4770      	bx	lr
		}
	} while (!(sr & HSMCI_SR_TXBUFE));


	if (hsmci_transfert_pos < ((uint32_t)hsmci_block_size * hsmci_nb_block)) {
		return true;
  40224a:	2001      	movs	r0, #1
			return false;
		}
	} while (!(sr & HSMCI_SR_NOTBUSY));
	Assert(HSMCI->HSMCI_SR & HSMCI_SR_FIFOEMPTY);
	return true;
}
  40224c:	bcf0      	pop	{r4, r5, r6, r7}
  40224e:	4770      	bx	lr
  402250:	c0600000 	.word	0xc0600000
  402254:	20000f5e 	.word	0x20000f5e
  402258:	20000f5c 	.word	0x20000f5c
  40225c:	20000f60 	.word	0x20000f60

00402260 <pdc_disable_transfer>:
{
	/* Validate inputs. */
	Assert(p_pdc);
	
	p_pdc->PERIPH_PTCR =
			ul_controls & (PERIPH_PTCR_RXTDIS | PERIPH_PTCR_TXTDIS);
  402260:	f240 2302 	movw	r3, #514	; 0x202
  402264:	4019      	ands	r1, r3
		uint32_t ul_controls)
{
	/* Validate inputs. */
	Assert(p_pdc);
	
	p_pdc->PERIPH_PTCR =
  402266:	6201      	str	r1, [r0, #32]
  402268:	4770      	bx	lr
  40226a:	bf00      	nop

0040226c <rtc_set_hour_mode>:
 * \param ul_mode 1 for 12-hour mode, 0 for 24-hour mode.
 */
void rtc_set_hour_mode(Rtc *p_rtc, uint32_t ul_mode)
{
	if (ul_mode) {
		p_rtc->RTC_MR |= RTC_MR_HRMOD;
  40226c:	6843      	ldr	r3, [r0, #4]
 * \param p_rtc Pointer to an RTC instance.
 * \param ul_mode 1 for 12-hour mode, 0 for 24-hour mode.
 */
void rtc_set_hour_mode(Rtc *p_rtc, uint32_t ul_mode)
{
	if (ul_mode) {
  40226e:	b919      	cbnz	r1, 402278 <rtc_set_hour_mode+0xc>
		p_rtc->RTC_MR |= RTC_MR_HRMOD;
	} else {
		p_rtc->RTC_MR &= (~RTC_MR_HRMOD);
  402270:	f023 0301 	bic.w	r3, r3, #1
  402274:	6043      	str	r3, [r0, #4]
  402276:	4770      	bx	lr
 * \param ul_mode 1 for 12-hour mode, 0 for 24-hour mode.
 */
void rtc_set_hour_mode(Rtc *p_rtc, uint32_t ul_mode)
{
	if (ul_mode) {
		p_rtc->RTC_MR |= RTC_MR_HRMOD;
  402278:	f043 0301 	orr.w	r3, r3, #1
  40227c:	6043      	str	r3, [r0, #4]
  40227e:	4770      	bx	lr

00402280 <rtc_get_time>:
 * \param pul_minute Current minute.
 * \param pul_second Current second.
 */
void rtc_get_time(Rtc *p_rtc, uint32_t *pul_hour, uint32_t *pul_minute,
		uint32_t *pul_second)
{
  402280:	b430      	push	{r4, r5}
	uint32_t ul_time;
	uint32_t ul_temp;

	/* Get the current RTC time (multiple reads are necessary to insure a stable value). */
	ul_time = p_rtc->RTC_TIMR;
  402282:	6884      	ldr	r4, [r0, #8]
	while (ul_time != p_rtc->RTC_TIMR) {
  402284:	6885      	ldr	r5, [r0, #8]
  402286:	42ac      	cmp	r4, r5
  402288:	d003      	beq.n	402292 <rtc_get_time+0x12>
		ul_time = p_rtc->RTC_TIMR;
  40228a:	6884      	ldr	r4, [r0, #8]
	uint32_t ul_time;
	uint32_t ul_temp;

	/* Get the current RTC time (multiple reads are necessary to insure a stable value). */
	ul_time = p_rtc->RTC_TIMR;
	while (ul_time != p_rtc->RTC_TIMR) {
  40228c:	6885      	ldr	r5, [r0, #8]
  40228e:	42a5      	cmp	r5, r4
  402290:	d1fb      	bne.n	40228a <rtc_get_time+0xa>
		ul_time = p_rtc->RTC_TIMR;
	}

	/* Hour */
	if (pul_hour) {
  402292:	b161      	cbz	r1, 4022ae <rtc_get_time+0x2e>
		ul_temp = (ul_time & RTC_TIMR_HOUR_Msk) >> RTC_TIMR_HOUR_Pos;
  402294:	f404 107c 	and.w	r0, r4, #4128768	; 0x3f0000
		*pul_hour = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  402298:	0d05      	lsrs	r5, r0, #20
  40229a:	eb05 0585 	add.w	r5, r5, r5, lsl #2
  40229e:	f3c0 4003 	ubfx	r0, r0, #16, #4
  4022a2:	eb00 0045 	add.w	r0, r0, r5, lsl #1

		if ((ul_time & RTC_TIMR_AMPM) == RTC_TIMR_AMPM) {
  4022a6:	0265      	lsls	r5, r4, #9
			*pul_hour += 12;
  4022a8:	bf48      	it	mi
  4022aa:	300c      	addmi	r0, #12
  4022ac:	6008      	str	r0, [r1, #0]
		}
	}

	/* Minute */
	if (pul_minute) {
  4022ae:	b14a      	cbz	r2, 4022c4 <rtc_get_time+0x44>
		ul_temp = (ul_time & RTC_TIMR_MIN_Msk) >> RTC_TIMR_MIN_Pos;
  4022b0:	f404 41fe 	and.w	r1, r4, #32512	; 0x7f00
		*pul_minute = (ul_temp >> BCD_SHIFT) * BCD_FACTOR +  (ul_temp & BCD_MASK);
  4022b4:	0b08      	lsrs	r0, r1, #12
  4022b6:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  4022ba:	f3c1 2103 	ubfx	r1, r1, #8, #4
  4022be:	eb01 0140 	add.w	r1, r1, r0, lsl #1
  4022c2:	6011      	str	r1, [r2, #0]
	}

	/* Second */
	if (pul_second) {
  4022c4:	b143      	cbz	r3, 4022d8 <rtc_get_time+0x58>
		ul_temp = (ul_time & RTC_TIMR_SEC_Msk) >> RTC_TIMR_SEC_Pos;
		*pul_second = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  4022c6:	f3c4 1202 	ubfx	r2, r4, #4, #3
  4022ca:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  4022ce:	f004 040f 	and.w	r4, r4, #15
  4022d2:	eb04 0242 	add.w	r2, r4, r2, lsl #1
  4022d6:	601a      	str	r2, [r3, #0]
	}
}
  4022d8:	bc30      	pop	{r4, r5}
  4022da:	4770      	bx	lr

004022dc <rtc_get_date>:
 * \param pul_day Current day.
 * \param pul_week Current day in current week.
 */
void rtc_get_date(Rtc *p_rtc, uint32_t *pul_year, uint32_t *pul_month,
		uint32_t *pul_day, uint32_t *pul_week)
{
  4022dc:	b4f0      	push	{r4, r5, r6, r7}
	uint32_t ul_date;
	uint32_t ul_cent;
	uint32_t ul_temp;

	/* Get the current date (multiple reads are necessary to insure a stable value). */
	ul_date = p_rtc->RTC_CALR;
  4022de:	68c4      	ldr	r4, [r0, #12]
	while (ul_date != p_rtc->RTC_CALR) {
  4022e0:	68c5      	ldr	r5, [r0, #12]
 * \param pul_day Current day.
 * \param pul_week Current day in current week.
 */
void rtc_get_date(Rtc *p_rtc, uint32_t *pul_year, uint32_t *pul_month,
		uint32_t *pul_day, uint32_t *pul_week)
{
  4022e2:	9e04      	ldr	r6, [sp, #16]
	uint32_t ul_cent;
	uint32_t ul_temp;

	/* Get the current date (multiple reads are necessary to insure a stable value). */
	ul_date = p_rtc->RTC_CALR;
	while (ul_date != p_rtc->RTC_CALR) {
  4022e4:	42ac      	cmp	r4, r5
  4022e6:	d003      	beq.n	4022f0 <rtc_get_date+0x14>
		ul_date = p_rtc->RTC_CALR;
  4022e8:	68c4      	ldr	r4, [r0, #12]
	uint32_t ul_cent;
	uint32_t ul_temp;

	/* Get the current date (multiple reads are necessary to insure a stable value). */
	ul_date = p_rtc->RTC_CALR;
	while (ul_date != p_rtc->RTC_CALR) {
  4022ea:	68c5      	ldr	r5, [r0, #12]
  4022ec:	42a5      	cmp	r5, r4
  4022ee:	d1fb      	bne.n	4022e8 <rtc_get_date+0xc>
		ul_date = p_rtc->RTC_CALR;
	}

	/* Retrieve year */
	if (pul_year) {
  4022f0:	b1a1      	cbz	r1, 40231c <rtc_get_date+0x40>
		ul_temp = (ul_date & RTC_CALR_CENT_Msk) >> RTC_CALR_CENT_Pos;
		ul_cent = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
		ul_temp = (ul_date & RTC_CALR_YEAR_Msk) >> RTC_CALR_YEAR_Pos;
  4022f2:	f404 457f 	and.w	r5, r4, #65280	; 0xff00
		*pul_year = (ul_cent * BCD_FACTOR * BCD_FACTOR) +
				(ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  4022f6:	0b2f      	lsrs	r7, r5, #12
	}

	/* Retrieve year */
	if (pul_year) {
		ul_temp = (ul_date & RTC_CALR_CENT_Msk) >> RTC_CALR_CENT_Pos;
		ul_cent = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  4022f8:	f3c4 1002 	ubfx	r0, r4, #4, #3
		ul_temp = (ul_date & RTC_CALR_YEAR_Msk) >> RTC_CALR_YEAR_Pos;
		*pul_year = (ul_cent * BCD_FACTOR * BCD_FACTOR) +
				(ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  4022fc:	eb07 0c87 	add.w	ip, r7, r7, lsl #2
  402300:	f3c5 2503 	ubfx	r5, r5, #8, #4
	}

	/* Retrieve year */
	if (pul_year) {
		ul_temp = (ul_date & RTC_CALR_CENT_Msk) >> RTC_CALR_CENT_Pos;
		ul_cent = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  402304:	f004 070f 	and.w	r7, r4, #15
  402308:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  40230c:	eb07 0040 	add.w	r0, r7, r0, lsl #1
		ul_temp = (ul_date & RTC_CALR_YEAR_Msk) >> RTC_CALR_YEAR_Pos;
		*pul_year = (ul_cent * BCD_FACTOR * BCD_FACTOR) +
  402310:	eb05 054c 	add.w	r5, r5, ip, lsl #1
  402314:	2764      	movs	r7, #100	; 0x64
				(ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  402316:	fb07 5000 	mla	r0, r7, r0, r5
	/* Retrieve year */
	if (pul_year) {
		ul_temp = (ul_date & RTC_CALR_CENT_Msk) >> RTC_CALR_CENT_Pos;
		ul_cent = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
		ul_temp = (ul_date & RTC_CALR_YEAR_Msk) >> RTC_CALR_YEAR_Pos;
		*pul_year = (ul_cent * BCD_FACTOR * BCD_FACTOR) +
  40231a:	6008      	str	r0, [r1, #0]
				(ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
	}

	/* Retrieve month */
	if (pul_month) {
  40231c:	b14a      	cbz	r2, 402332 <rtc_get_date+0x56>
		ul_temp = (ul_date & RTC_CALR_MONTH_Msk) >> RTC_CALR_MONTH_Pos;
  40231e:	f404 10f8 	and.w	r0, r4, #2031616	; 0x1f0000
		*pul_month = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  402322:	0d01      	lsrs	r1, r0, #20
  402324:	008d      	lsls	r5, r1, #2
  402326:	f3c0 4003 	ubfx	r0, r0, #16, #4
  40232a:	4429      	add	r1, r5
  40232c:	eb00 0141 	add.w	r1, r0, r1, lsl #1
  402330:	6011      	str	r1, [r2, #0]
	}

	/* Retrieve day */
	if (pul_day) {
  402332:	b14b      	cbz	r3, 402348 <rtc_get_date+0x6c>
		ul_temp = (ul_date & RTC_CALR_DATE_Msk) >> RTC_CALR_DATE_Pos;
  402334:	f004 527c 	and.w	r2, r4, #1056964608	; 0x3f000000
		*pul_day = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  402338:	0f11      	lsrs	r1, r2, #28
  40233a:	eb01 0181 	add.w	r1, r1, r1, lsl #2
  40233e:	f3c2 6203 	ubfx	r2, r2, #24, #4
  402342:	eb02 0241 	add.w	r2, r2, r1, lsl #1
  402346:	601a      	str	r2, [r3, #0]
	}

	/* Retrieve week */
	if (pul_week) {
  402348:	b116      	cbz	r6, 402350 <rtc_get_date+0x74>
		*pul_week = ((ul_date & RTC_CALR_DAY_Msk) >> RTC_CALR_DAY_Pos);
  40234a:	f3c4 5442 	ubfx	r4, r4, #21, #3
  40234e:	6034      	str	r4, [r6, #0]
	}
}
  402350:	bcf0      	pop	{r4, r5, r6, r7}
  402352:	4770      	bx	lr

00402354 <uart_disable_interrupt>:
 * \param p_uart Pointer to a UART instance.
 *  \param ul_sources Interrupts to be disabled.
 */
void uart_disable_interrupt(Uart *p_uart, uint32_t ul_sources)
{
	p_uart->UART_IDR = ul_sources;
  402354:	60c1      	str	r1, [r0, #12]
  402356:	4770      	bx	lr

00402358 <uart_get_status>:
 *
 * \return The current UART status.
 */
uint32_t uart_get_status(Uart *p_uart)
{
	return p_uart->UART_SR;
  402358:	6940      	ldr	r0, [r0, #20]
}
  40235a:	4770      	bx	lr

0040235c <uart_write>:
 * \retval 1 I/O Failure, UART is not ready.
 */
uint32_t uart_write(Uart *p_uart, const uint8_t uc_data)
{
	/* Check if the transmitter is ready */
	if (!(p_uart->UART_SR & UART_SR_TXRDY))
  40235c:	6943      	ldr	r3, [r0, #20]
  40235e:	079b      	lsls	r3, r3, #30
		return 1;

	/* Send character */
	p_uart->UART_THR = uc_data;
  402360:	bf46      	itte	mi
  402362:	61c1      	strmi	r1, [r0, #28]
	return 0;
  402364:	2000      	movmi	r0, #0
 */
uint32_t uart_write(Uart *p_uart, const uint8_t uc_data)
{
	/* Check if the transmitter is ready */
	if (!(p_uart->UART_SR & UART_SR_TXRDY))
		return 1;
  402366:	2001      	movpl	r0, #1

	/* Send character */
	p_uart->UART_THR = uc_data;
	return 0;
}
  402368:	4770      	bx	lr
  40236a:	bf00      	nop

0040236c <usart_enable_interrupt>:
 * \param p_usart Pointer to a USART peripheral.
 * \param ul_sources Interrupt sources bit map.
 */
void usart_enable_interrupt(Usart *p_usart, uint32_t ul_sources)
{
	p_usart->US_IER = ul_sources;
  40236c:	6081      	str	r1, [r0, #8]
  40236e:	4770      	bx	lr

00402370 <usart_disable_interrupt>:
 * \param p_usart Pointer to a USART peripheral.
 * \param ul_sources Interrupt sources bit map.
 */
void usart_disable_interrupt(Usart *p_usart, uint32_t ul_sources)
{
	p_usart->US_IDR = ul_sources;
  402370:	60c1      	str	r1, [r0, #12]
  402372:	4770      	bx	lr

00402374 <usart_write>:
 * \retval 0 on success.
 * \retval 1 on failure.
 */
uint32_t usart_write(Usart *p_usart, uint32_t c)
{
	if (!(p_usart->US_CSR & US_CSR_TXRDY)) {
  402374:	6943      	ldr	r3, [r0, #20]
  402376:	079b      	lsls	r3, r3, #30
		return 1;
	}

	p_usart->US_THR = US_THR_TXCHR(c);
  402378:	bf43      	ittte	mi
  40237a:	f3c1 0108 	ubfxmi	r1, r1, #0, #9
  40237e:	61c1      	strmi	r1, [r0, #28]
	return 0;
  402380:	2000      	movmi	r0, #0
 * \retval 1 on failure.
 */
uint32_t usart_write(Usart *p_usart, uint32_t c)
{
	if (!(p_usart->US_CSR & US_CSR_TXRDY)) {
		return 1;
  402382:	2001      	movpl	r0, #1
	}

	p_usart->US_THR = US_THR_TXCHR(c);
	return 0;
}
  402384:	4770      	bx	lr
  402386:	bf00      	nop

00402388 <usart_getchar>:
 * \retval 1 on failure.
 */
uint32_t usart_getchar(Usart *p_usart, uint32_t *c)
{
	/* Wait until it's not empty or timeout has reached. */
	while (!(p_usart->US_CSR & US_CSR_RXRDY)) {
  402388:	6943      	ldr	r3, [r0, #20]
  40238a:	07db      	lsls	r3, r3, #31
  40238c:	d5fc      	bpl.n	402388 <usart_getchar>
	}

	/* Read character */
	*c = p_usart->US_RHR & US_RHR_RXCHR_Msk;
  40238e:	6983      	ldr	r3, [r0, #24]
  402390:	f3c3 0308 	ubfx	r3, r3, #0, #9
  402394:	600b      	str	r3, [r1, #0]

	return 0;
}
  402396:	2000      	movs	r0, #0
  402398:	4770      	bx	lr
  40239a:	bf00      	nop

0040239c <disk_initialize>:
 *
 * \return 0 or disk status in combination of DSTATUS bits
 *         (STA_NOINIT, STA_PROTECT).
 */
DSTATUS disk_initialize(BYTE drv)
{
  40239c:	b538      	push	{r3, r4, r5, lr}
	int i;
	Ctrl_status mem_status;

#if (SAM3S || SAM3U || SAM3N || SAM3XA || SAM4S)
	/* Default RTC configuration, 24-hour mode */
	rtc_set_hour_mode(RTC, 0);
  40239e:	2100      	movs	r1, #0
 *
 * \return 0 or disk status in combination of DSTATUS bits
 *         (STA_NOINIT, STA_PROTECT).
 */
DSTATUS disk_initialize(BYTE drv)
{
  4023a0:	4604      	mov	r4, r0
	int i;
	Ctrl_status mem_status;

#if (SAM3S || SAM3U || SAM3N || SAM3XA || SAM4S)
	/* Default RTC configuration, 24-hour mode */
	rtc_set_hour_mode(RTC, 0);
  4023a2:	4b0b      	ldr	r3, [pc, #44]	; (4023d0 <disk_initialize+0x34>)
  4023a4:	480b      	ldr	r0, [pc, #44]	; (4023d4 <disk_initialize+0x38>)
  4023a6:	4798      	blx	r3
	/* USB disk with multiple LUNs */
	if (drv > LUN_ID_USB + Lun_usb_get_lun()) {
		return STA_NOINIT;
	}
#else
	if (drv > MAX_LUN) {
  4023a8:	2c02      	cmp	r4, #2
  4023aa:	d807      	bhi.n	4023bc <disk_initialize+0x20>
		return STA_NOINIT;
	}
#endif
	/* Check LUN ready (USB disk report CTRL_BUSY then CTRL_GOOD) */
	for (i = 0; i < 2; i ++) {
		mem_status = mem_test_unit_ready(drv);
  4023ac:	4620      	mov	r0, r4
  4023ae:	4d0a      	ldr	r5, [pc, #40]	; (4023d8 <disk_initialize+0x3c>)
  4023b0:	47a8      	blx	r5
		if (CTRL_BUSY != mem_status) {
  4023b2:	2803      	cmp	r0, #3
  4023b4:	d101      	bne.n	4023ba <disk_initialize+0x1e>
		return STA_NOINIT;
	}
#endif
	/* Check LUN ready (USB disk report CTRL_BUSY then CTRL_GOOD) */
	for (i = 0; i < 2; i ++) {
		mem_status = mem_test_unit_ready(drv);
  4023b6:	4620      	mov	r0, r4
  4023b8:	47a8      	blx	r5
		if (CTRL_BUSY != mem_status) {
			break;
		}
	}
	if (mem_status != CTRL_GOOD) {
  4023ba:	b108      	cbz	r0, 4023c0 <disk_initialize+0x24>
		return STA_NOINIT;
	}
#else
	if (drv > MAX_LUN) {
		/* At least one of the LUN should be defined */
		return STA_NOINIT;
  4023bc:	2001      	movs	r0, #1
  4023be:	bd38      	pop	{r3, r4, r5, pc}
	if (mem_status != CTRL_GOOD) {
		return STA_NOINIT;
	}

	/* Check Write Protection Status */
	if (mem_wr_protect(drv)) {
  4023c0:	4620      	mov	r0, r4
  4023c2:	4b06      	ldr	r3, [pc, #24]	; (4023dc <disk_initialize+0x40>)
  4023c4:	4798      	blx	r3
  4023c6:	2800      	cmp	r0, #0
		return STA_PROTECT;
  4023c8:	bf0c      	ite	eq
  4023ca:	2000      	moveq	r0, #0
  4023cc:	2004      	movne	r0, #4
	}

	/* The memory should already be initialized */
	return 0;
}
  4023ce:	bd38      	pop	{r3, r4, r5, pc}
  4023d0:	0040226d 	.word	0x0040226d
  4023d4:	400e1460 	.word	0x400e1460
  4023d8:	00401c35 	.word	0x00401c35
  4023dc:	00401c75 	.word	0x00401c75

004023e0 <disk_status>:
 *
 * \return 0 or disk status in combination of DSTATUS bits
 *         (STA_NOINIT, STA_NODISK, STA_PROTECT).
 */
DSTATUS disk_status(BYTE drv)
{
  4023e0:	b508      	push	{r3, lr}
	switch (mem_test_unit_ready(drv)) {
  4023e2:	4b04      	ldr	r3, [pc, #16]	; (4023f4 <disk_status+0x14>)
  4023e4:	4798      	blx	r3
  4023e6:	b118      	cbz	r0, 4023f0 <disk_status+0x10>
  4023e8:	2802      	cmp	r0, #2
	case CTRL_GOOD:
		return 0;
	case CTRL_NO_PRESENT:
		return STA_NOINIT | STA_NODISK;
	default:
		return STA_NOINIT;
  4023ea:	bf0c      	ite	eq
  4023ec:	2003      	moveq	r0, #3
  4023ee:	2001      	movne	r0, #1
	}
}
  4023f0:	bd08      	pop	{r3, pc}
  4023f2:	bf00      	nop
  4023f4:	00401c35 	.word	0x00401c35

004023f8 <disk_read>:
 * \param count Number of sectors to read (1..255).
 *
 * \return RES_OK for success, otherwise DRESULT error code.
 */
DRESULT disk_read(BYTE drv, BYTE *buff, DWORD sector, BYTE count)
{
  4023f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if ACCESS_MEM_TO_RAM
	uint8_t uc_sector_size = mem_sector_size(drv);
  4023fc:	4c18      	ldr	r4, [pc, #96]	; (402460 <disk_read+0x68>)
 * \param count Number of sectors to read (1..255).
 *
 * \return RES_OK for success, otherwise DRESULT error code.
 */
DRESULT disk_read(BYTE drv, BYTE *buff, DWORD sector, BYTE count)
{
  4023fe:	b083      	sub	sp, #12
  402400:	460e      	mov	r6, r1
  402402:	4615      	mov	r5, r2
  402404:	4698      	mov	r8, r3
  402406:	4681      	mov	r9, r0
#if ACCESS_MEM_TO_RAM
	uint8_t uc_sector_size = mem_sector_size(drv);
  402408:	47a0      	blx	r4
	uint32_t i;
	uint32_t ul_last_sector_num;

	if (uc_sector_size == 0) {
  40240a:	4604      	mov	r4, r0
  40240c:	b918      	cbnz	r0, 402416 <disk_read+0x1e>
		return RES_ERROR;
  40240e:	2001      	movs	r0, #1
	return RES_OK;

#else
	return RES_ERROR;
#endif
}
  402410:	b003      	add	sp, #12
  402412:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (uc_sector_size == 0) {
		return RES_ERROR;
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
  402416:	4b13      	ldr	r3, [pc, #76]	; (402464 <disk_read+0x6c>)
  402418:	4648      	mov	r0, r9
  40241a:	a901      	add	r1, sp, #4
  40241c:	4798      	blx	r3
	if ((sector + count * uc_sector_size) >
			(ul_last_sector_num + 1) * uc_sector_size) {
  40241e:	9b01      	ldr	r3, [sp, #4]
		return RES_ERROR;
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
	if ((sector + count * uc_sector_size) >
  402420:	fb18 f204 	smulbb	r2, r8, r4
			(ul_last_sector_num + 1) * uc_sector_size) {
  402424:	fb03 4304 	mla	r3, r3, r4, r4
		return RES_ERROR;
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
	if ((sector + count * uc_sector_size) >
  402428:	442a      	add	r2, r5
  40242a:	429a      	cmp	r2, r3
  40242c:	d903      	bls.n	402436 <disk_read+0x3e>
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
  40242e:	2004      	movs	r0, #4
	return RES_OK;

#else
	return RES_ERROR;
#endif
}
  402430:	b003      	add	sp, #12
  402432:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
	}

	/* Read the data */
	for (i = 0; i < count; i++) {
  402436:	f1b8 0f00 	cmp.w	r8, #0
  40243a:	d00f      	beq.n	40245c <disk_read+0x64>
  40243c:	f8df b028 	ldr.w	fp, [pc, #40]	; 402468 <disk_read+0x70>
  402440:	ea4f 2a44 	mov.w	sl, r4, lsl #9
  402444:	2700      	movs	r7, #0
		if (memory_2_ram(drv, sector + uc_sector_size * i,
  402446:	4629      	mov	r1, r5
  402448:	4632      	mov	r2, r6
  40244a:	4648      	mov	r0, r9
  40244c:	47d8      	blx	fp
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
	}

	/* Read the data */
	for (i = 0; i < count; i++) {
  40244e:	3701      	adds	r7, #1
  402450:	4425      	add	r5, r4
  402452:	4456      	add	r6, sl
		if (memory_2_ram(drv, sector + uc_sector_size * i,
  402454:	2800      	cmp	r0, #0
  402456:	d1da      	bne.n	40240e <disk_read+0x16>
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
	}

	/* Read the data */
	for (i = 0; i < count; i++) {
  402458:	4547      	cmp	r7, r8
  40245a:	d3f4      	bcc.n	402446 <disk_read+0x4e>
				CTRL_GOOD) {
			return RES_ERROR;
		}
	}

	return RES_OK;
  40245c:	2000      	movs	r0, #0
  40245e:	e7d7      	b.n	402410 <disk_read+0x18>
  402460:	00401c69 	.word	0x00401c69
  402464:	00401c4d 	.word	0x00401c4d
  402468:	00401c91 	.word	0x00401c91

0040246c <disk_write>:
 *
 * \return RES_OK for success, otherwise DRESULT error code.
 */
#if _READONLY == 0
DRESULT disk_write(BYTE drv, BYTE const *buff, DWORD sector, BYTE count)
{
  40246c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if ACCESS_MEM_TO_RAM
	uint8_t uc_sector_size = mem_sector_size(drv);
  402470:	4c18      	ldr	r4, [pc, #96]	; (4024d4 <disk_write+0x68>)
 *
 * \return RES_OK for success, otherwise DRESULT error code.
 */
#if _READONLY == 0
DRESULT disk_write(BYTE drv, BYTE const *buff, DWORD sector, BYTE count)
{
  402472:	b083      	sub	sp, #12
  402474:	460e      	mov	r6, r1
  402476:	4615      	mov	r5, r2
  402478:	4698      	mov	r8, r3
  40247a:	4681      	mov	r9, r0
#if ACCESS_MEM_TO_RAM
	uint8_t uc_sector_size = mem_sector_size(drv);
  40247c:	47a0      	blx	r4
	uint32_t i;
	uint32_t ul_last_sector_num;

	if (uc_sector_size == 0) {
  40247e:	4604      	mov	r4, r0
  402480:	b918      	cbnz	r0, 40248a <disk_write+0x1e>
		return RES_ERROR;
  402482:	2001      	movs	r0, #1
	return RES_OK;

#else
	return RES_ERROR;
#endif
}
  402484:	b003      	add	sp, #12
  402486:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (uc_sector_size == 0) {
		return RES_ERROR;
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
  40248a:	4b13      	ldr	r3, [pc, #76]	; (4024d8 <disk_write+0x6c>)
  40248c:	4648      	mov	r0, r9
  40248e:	a901      	add	r1, sp, #4
  402490:	4798      	blx	r3
	if ((sector + count * uc_sector_size) >
			(ul_last_sector_num + 1) * uc_sector_size) {
  402492:	9b01      	ldr	r3, [sp, #4]
		return RES_ERROR;
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
	if ((sector + count * uc_sector_size) >
  402494:	fb18 f204 	smulbb	r2, r8, r4
			(ul_last_sector_num + 1) * uc_sector_size) {
  402498:	fb03 4304 	mla	r3, r3, r4, r4
		return RES_ERROR;
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
	if ((sector + count * uc_sector_size) >
  40249c:	442a      	add	r2, r5
  40249e:	429a      	cmp	r2, r3
  4024a0:	d903      	bls.n	4024aa <disk_write+0x3e>
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
  4024a2:	2004      	movs	r0, #4
	return RES_OK;

#else
	return RES_ERROR;
#endif
}
  4024a4:	b003      	add	sp, #12
  4024a6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
	}

	/* Write the data */
	for (i = 0; i < count; i++) {
  4024aa:	f1b8 0f00 	cmp.w	r8, #0
  4024ae:	d00f      	beq.n	4024d0 <disk_write+0x64>
  4024b0:	f8df b028 	ldr.w	fp, [pc, #40]	; 4024dc <disk_write+0x70>
  4024b4:	ea4f 2a44 	mov.w	sl, r4, lsl #9
  4024b8:	2700      	movs	r7, #0
		if (ram_2_memory(drv, sector + uc_sector_size * i,
  4024ba:	4629      	mov	r1, r5
  4024bc:	4632      	mov	r2, r6
  4024be:	4648      	mov	r0, r9
  4024c0:	47d8      	blx	fp
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
	}

	/* Write the data */
	for (i = 0; i < count; i++) {
  4024c2:	3701      	adds	r7, #1
  4024c4:	4425      	add	r5, r4
  4024c6:	4456      	add	r6, sl
		if (ram_2_memory(drv, sector + uc_sector_size * i,
  4024c8:	2800      	cmp	r0, #0
  4024ca:	d1da      	bne.n	402482 <disk_write+0x16>
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
	}

	/* Write the data */
	for (i = 0; i < count; i++) {
  4024cc:	4547      	cmp	r7, r8
  4024ce:	d3f4      	bcc.n	4024ba <disk_write+0x4e>
				CTRL_GOOD) {
			return RES_ERROR;
		}
	}

	return RES_OK;
  4024d0:	2000      	movs	r0, #0
  4024d2:	e7d7      	b.n	402484 <disk_write+0x18>
  4024d4:	00401c69 	.word	0x00401c69
  4024d8:	00401c4d 	.word	0x00401c4d
  4024dc:	00401cb1 	.word	0x00401cb1

004024e0 <disk_ioctl>:
 * \param buff Buffer to send/receive control data.
 *
 * \return RES_OK for success, otherwise DRESULT error code.
 */
DRESULT disk_ioctl(BYTE drv, BYTE ctrl, void *buff)
{
  4024e0:	b510      	push	{r4, lr}
  4024e2:	4614      	mov	r4, r2
  4024e4:	b082      	sub	sp, #8
	DRESULT res = RES_PARERR;

	switch (ctrl) {
  4024e6:	2903      	cmp	r1, #3
  4024e8:	d829      	bhi.n	40253e <disk_ioctl+0x5e>
  4024ea:	e8df f001 	tbb	[pc, r1]
  4024ee:	131c      	.short	0x131c
  4024f0:	0207      	.short	0x0207
	case GET_BLOCK_SIZE:
		*(DWORD *)buff = 1;
  4024f2:	2301      	movs	r3, #1
  4024f4:	6013      	str	r3, [r2, #0]
		res = RES_OK;
  4024f6:	2000      	movs	r0, #0
	default:
		res = RES_PARERR;
	}

	return res;
}
  4024f8:	b002      	add	sp, #8
  4024fa:	bd10      	pop	{r4, pc}
	break;

	/* Get sectors on the disk (WORD) */
	case GET_SECTOR_SIZE:
	{
		uint8_t uc_sector_size = mem_sector_size(drv);
  4024fc:	4b11      	ldr	r3, [pc, #68]	; (402544 <disk_ioctl+0x64>)
  4024fe:	4798      	blx	r3

		if ((uc_sector_size != SECTOR_SIZE_512) &&
  402500:	1e43      	subs	r3, r0, #1
  402502:	b2db      	uxtb	r3, r3
  402504:	2b01      	cmp	r3, #1
  402506:	d916      	bls.n	402536 <disk_ioctl+0x56>
				(uc_sector_size != SECTOR_SIZE_1024) &&
  402508:	2804      	cmp	r0, #4
  40250a:	d014      	beq.n	402536 <disk_ioctl+0x56>
				(uc_sector_size != SECTOR_SIZE_2048) &&
  40250c:	2808      	cmp	r0, #8
  40250e:	d012      	beq.n	402536 <disk_ioctl+0x56>
				(uc_sector_size != SECTOR_SIZE_4096)) {
			/* The sector size is not supported by the FatFS */
			return RES_ERROR;
  402510:	2001      	movs	r0, #1
  402512:	e7f1      	b.n	4024f8 <disk_ioctl+0x18>
	case GET_SECTOR_COUNT:
	{
		uint32_t ul_last_sector_num;

		/* Check valid address */
		mem_read_capacity(drv, &ul_last_sector_num);
  402514:	a901      	add	r1, sp, #4
  402516:	4b0c      	ldr	r3, [pc, #48]	; (402548 <disk_ioctl+0x68>)
  402518:	4798      	blx	r3

		*(DWORD *)buff = ul_last_sector_num + 1;
  40251a:	9b01      	ldr	r3, [sp, #4]

		res = RES_OK;
  40251c:	2000      	movs	r0, #0
		uint32_t ul_last_sector_num;

		/* Check valid address */
		mem_read_capacity(drv, &ul_last_sector_num);

		*(DWORD *)buff = ul_last_sector_num + 1;
  40251e:	3301      	adds	r3, #1
  402520:	6023      	str	r3, [r4, #0]
	default:
		res = RES_PARERR;
	}

	return res;
}
  402522:	b002      	add	sp, #8
  402524:	bd10      	pop	{r4, pc}
	}
	break;

	/* Make sure that data has been written */
	case CTRL_SYNC:
		if (mem_test_unit_ready(drv) == CTRL_GOOD) {
  402526:	4b09      	ldr	r3, [pc, #36]	; (40254c <disk_ioctl+0x6c>)
  402528:	4798      	blx	r3
			res = RES_OK;
  40252a:	2800      	cmp	r0, #0
  40252c:	bf14      	ite	ne
  40252e:	2003      	movne	r0, #3
  402530:	2000      	moveq	r0, #0
	default:
		res = RES_PARERR;
	}

	return res;
}
  402532:	b002      	add	sp, #8
  402534:	bd10      	pop	{r4, pc}
				(uc_sector_size != SECTOR_SIZE_4096)) {
			/* The sector size is not supported by the FatFS */
			return RES_ERROR;
		}

		*(U8 *)buff = uc_sector_size * SECTOR_SIZE_DEFAULT;
  402536:	2000      	movs	r0, #0
  402538:	7020      	strb	r0, [r4, #0]
	default:
		res = RES_PARERR;
	}

	return res;
}
  40253a:	b002      	add	sp, #8
  40253c:	bd10      	pop	{r4, pc}
			res = RES_NOTRDY;
		}
		break;

	default:
		res = RES_PARERR;
  40253e:	2004      	movs	r0, #4
  402540:	e7da      	b.n	4024f8 <disk_ioctl+0x18>
  402542:	bf00      	nop
  402544:	00401c69 	.word	0x00401c69
  402548:	00401c4d 	.word	0x00401c4d
  40254c:	00401c35 	.word	0x00401c35

00402550 <get_fattime>:
 * bit4:0    Second (0..59)
 *
 * \return Current time.
 */
uint32_t get_fattime(void)
{
  402550:	b530      	push	{r4, r5, lr}
	uint32_t ul_time;
	uint32_t ul_hour, ul_minute, ul_second;
	uint32_t ul_year, ul_month, ul_day, ul_week;

	/* Retrieve date and time */
	rtc_get_time(RTC, &ul_hour, &ul_minute, &ul_second);
  402552:	4c12      	ldr	r4, [pc, #72]	; (40259c <get_fattime+0x4c>)
  402554:	4d12      	ldr	r5, [pc, #72]	; (4025a0 <get_fattime+0x50>)
 * bit4:0    Second (0..59)
 *
 * \return Current time.
 */
uint32_t get_fattime(void)
{
  402556:	b08b      	sub	sp, #44	; 0x2c
	uint32_t ul_time;
	uint32_t ul_hour, ul_minute, ul_second;
	uint32_t ul_year, ul_month, ul_day, ul_week;

	/* Retrieve date and time */
	rtc_get_time(RTC, &ul_hour, &ul_minute, &ul_second);
  402558:	4620      	mov	r0, r4
  40255a:	a903      	add	r1, sp, #12
  40255c:	aa04      	add	r2, sp, #16
  40255e:	ab05      	add	r3, sp, #20
  402560:	47a8      	blx	r5
	rtc_get_date(RTC, &ul_year, &ul_month, &ul_day, &ul_week);
  402562:	ab09      	add	r3, sp, #36	; 0x24
  402564:	4620      	mov	r0, r4
  402566:	9300      	str	r3, [sp, #0]
  402568:	a906      	add	r1, sp, #24
  40256a:	aa07      	add	r2, sp, #28
  40256c:	ab08      	add	r3, sp, #32
  40256e:	4c0d      	ldr	r4, [pc, #52]	; (4025a4 <get_fattime+0x54>)
  402570:	47a0      	blx	r4

	ul_time = ((ul_year - 1980) << 25)
			| (ul_month << 21)
			| (ul_day << 16)
  402572:	9d08      	ldr	r5, [sp, #32]
	/* Retrieve date and time */
	rtc_get_time(RTC, &ul_hour, &ul_minute, &ul_second);
	rtc_get_date(RTC, &ul_year, &ul_month, &ul_day, &ul_week);

	ul_time = ((ul_year - 1980) << 25)
			| (ul_month << 21)
  402574:	9c07      	ldr	r4, [sp, #28]
			| (ul_day << 16)
  402576:	9805      	ldr	r0, [sp, #20]
			| (ul_hour << 11)
  402578:	9903      	ldr	r1, [sp, #12]
			| (ul_minute << 5)
  40257a:	9a04      	ldr	r2, [sp, #16]

	/* Retrieve date and time */
	rtc_get_time(RTC, &ul_hour, &ul_minute, &ul_second);
	rtc_get_date(RTC, &ul_year, &ul_month, &ul_day, &ul_week);

	ul_time = ((ul_year - 1980) << 25)
  40257c:	9b06      	ldr	r3, [sp, #24]
			| (ul_month << 21)
			| (ul_day << 16)
  40257e:	042d      	lsls	r5, r5, #16
	/* Retrieve date and time */
	rtc_get_time(RTC, &ul_hour, &ul_minute, &ul_second);
	rtc_get_date(RTC, &ul_year, &ul_month, &ul_day, &ul_week);

	ul_time = ((ul_year - 1980) << 25)
			| (ul_month << 21)
  402580:	ea45 5444 	orr.w	r4, r5, r4, lsl #21
			| (ul_day << 16)
  402584:	4320      	orrs	r0, r4
			| (ul_hour << 11)
  402586:	ea40 21c1 	orr.w	r1, r0, r1, lsl #11
			| (ul_minute << 5)
  40258a:	ea41 1042 	orr.w	r0, r1, r2, lsl #5

	/* Retrieve date and time */
	rtc_get_time(RTC, &ul_hour, &ul_minute, &ul_second);
	rtc_get_date(RTC, &ul_year, &ul_month, &ul_day, &ul_week);

	ul_time = ((ul_year - 1980) << 25)
  40258e:	f2a3 73bc 	subw	r3, r3, #1980	; 0x7bc
			| (ul_hour << 11)
			| (ul_minute << 5)
			| (ul_second << 0);

	return ul_time;
}
  402592:	ea40 6043 	orr.w	r0, r0, r3, lsl #25
  402596:	b00b      	add	sp, #44	; 0x2c
  402598:	bd30      	pop	{r4, r5, pc}
  40259a:	bf00      	nop
  40259c:	400e1460 	.word	0x400e1460
  4025a0:	00402281 	.word	0x00402281
  4025a4:	004022dd 	.word	0x004022dd

004025a8 <chk_lock>:
static
FRESULT chk_lock (	/* Check if the file can be accessed */
	DIR* dj,		/* Directory object pointing the file to be checked */
	int acc			/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
)
{
  4025a8:	b470      	push	{r4, r5, r6}
  4025aa:	4a19      	ldr	r2, [pc, #100]	; (402610 <chk_lock+0x68>)
	UINT i, be;

	/* Search file semaphore table */
	for (i = be = 0; i < _FS_SHARE; i++) {
  4025ac:	2600      	movs	r6, #0
  4025ae:	4633      	mov	r3, r6
		if (Files[i].fs) {	/* Existing entry */
  4025b0:	f852 4c08 	ldr.w	r4, [r2, #-8]
  4025b4:	b174      	cbz	r4, 4025d4 <chk_lock+0x2c>
			if (Files[i].fs == dj->fs &&	 	/* Check if the file matched with an open file */
  4025b6:	6805      	ldr	r5, [r0, #0]
  4025b8:	42ac      	cmp	r4, r5
  4025ba:	d010      	beq.n	4025de <chk_lock+0x36>
)
{
	UINT i, be;

	/* Search file semaphore table */
	for (i = be = 0; i < _FS_SHARE; i++) {
  4025bc:	3301      	adds	r3, #1
  4025be:	2b03      	cmp	r3, #3
  4025c0:	f102 020c 	add.w	r2, r2, #12
  4025c4:	d1f4      	bne.n	4025b0 <chk_lock+0x8>
		} else {			/* Blank entry */
			be++;
		}
	}
	if (i == _FS_SHARE)	/* The file is not opened */
		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new file? */
  4025c6:	b93e      	cbnz	r6, 4025d8 <chk_lock+0x30>
  4025c8:	2902      	cmp	r1, #2
  4025ca:	bf14      	ite	ne
  4025cc:	2012      	movne	r0, #18
  4025ce:	2000      	moveq	r0, #0

	/* The file has been opened. Reject any open against writing file and all write mode open */
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
}
  4025d0:	bc70      	pop	{r4, r5, r6}
  4025d2:	4770      	bx	lr
		if (Files[i].fs) {	/* Existing entry */
			if (Files[i].fs == dj->fs &&	 	/* Check if the file matched with an open file */
				Files[i].clu == dj->sclust &&
				Files[i].idx == dj->index) break;
		} else {			/* Blank entry */
			be++;
  4025d4:	3601      	adds	r6, #1
  4025d6:	e7f1      	b.n	4025bc <chk_lock+0x14>
		}
	}
	if (i == _FS_SHARE)	/* The file is not opened */
		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new file? */
  4025d8:	2000      	movs	r0, #0

	/* The file has been opened. Reject any open against writing file and all write mode open */
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
}
  4025da:	bc70      	pop	{r4, r5, r6}
  4025dc:	4770      	bx	lr
	UINT i, be;

	/* Search file semaphore table */
	for (i = be = 0; i < _FS_SHARE; i++) {
		if (Files[i].fs) {	/* Existing entry */
			if (Files[i].fs == dj->fs &&	 	/* Check if the file matched with an open file */
  4025de:	f852 5c04 	ldr.w	r5, [r2, #-4]
  4025e2:	6884      	ldr	r4, [r0, #8]
  4025e4:	42a5      	cmp	r5, r4
  4025e6:	d1e9      	bne.n	4025bc <chk_lock+0x14>
				Files[i].clu == dj->sclust &&
  4025e8:	8815      	ldrh	r5, [r2, #0]
  4025ea:	88c4      	ldrh	r4, [r0, #6]
  4025ec:	42a5      	cmp	r5, r4
  4025ee:	d1e5      	bne.n	4025bc <chk_lock+0x14>
	}
	if (i == _FS_SHARE)	/* The file is not opened */
		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new file? */

	/* The file has been opened. Reject any open against writing file and all write mode open */
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
  4025f0:	b109      	cbz	r1, 4025f6 <chk_lock+0x4e>
  4025f2:	2010      	movs	r0, #16
  4025f4:	e7ec      	b.n	4025d0 <chk_lock+0x28>
  4025f6:	4a07      	ldr	r2, [pc, #28]	; (402614 <chk_lock+0x6c>)
  4025f8:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  4025fc:	eb02 0383 	add.w	r3, r2, r3, lsl #2
}
  402600:	bc70      	pop	{r4, r5, r6}
	}
	if (i == _FS_SHARE)	/* The file is not opened */
		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new file? */

	/* The file has been opened. Reject any open against writing file and all write mode open */
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
  402602:	895b      	ldrh	r3, [r3, #10]
  402604:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  402608:	bf14      	ite	ne
  40260a:	2000      	movne	r0, #0
  40260c:	2010      	moveq	r0, #16
}
  40260e:	4770      	bx	lr
  402610:	20000f70 	.word	0x20000f70
  402614:	20000f68 	.word	0x20000f68

00402618 <move_window>:
static
FRESULT move_window (
	FATFS *fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)					/* Move to zero only writes back dirty window */
{
  402618:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	DWORD wsect;


	wsect = fs->winsect;
  40261c:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
	if (wsect != sector) {	/* Changed current window */
  40261e:	428d      	cmp	r5, r1
static
FRESULT move_window (
	FATFS *fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)					/* Move to zero only writes back dirty window */
{
  402620:	4604      	mov	r4, r0
  402622:	460e      	mov	r6, r1
	DWORD wsect;


	wsect = fs->winsect;
	if (wsect != sector) {	/* Changed current window */
  402624:	d002      	beq.n	40262c <move_window+0x14>
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
  402626:	7903      	ldrb	r3, [r0, #4]
  402628:	b973      	cbnz	r3, 402648 <move_window+0x30>
					disk_write(fs->drv, fs->win, wsect, 1);
				}
			}
		}
#endif
		if (sector) {
  40262a:	b916      	cbnz	r6, 402632 <move_window+0x1a>
				return FR_DISK_ERR;
			fs->winsect = sector;
		}
	}

	return FR_OK;
  40262c:	2000      	movs	r0, #0
  40262e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				}
			}
		}
#endif
		if (sector) {
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
  402632:	7860      	ldrb	r0, [r4, #1]
  402634:	4d17      	ldr	r5, [pc, #92]	; (402694 <move_window+0x7c>)
  402636:	f104 0130 	add.w	r1, r4, #48	; 0x30
  40263a:	4632      	mov	r2, r6
  40263c:	2301      	movs	r3, #1
  40263e:	47a8      	blx	r5
  402640:	bb20      	cbnz	r0, 40268c <move_window+0x74>
				return FR_DISK_ERR;
			fs->winsect = sector;
  402642:	62e6      	str	r6, [r4, #44]	; 0x2c
		}
	}

	return FR_OK;
}
  402644:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

	wsect = fs->winsect;
	if (wsect != sector) {	/* Changed current window */
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
  402648:	f100 0830 	add.w	r8, r0, #48	; 0x30
  40264c:	4641      	mov	r1, r8
  40264e:	7840      	ldrb	r0, [r0, #1]
  402650:	f8df 9044 	ldr.w	r9, [pc, #68]	; 402698 <move_window+0x80>
  402654:	462a      	mov	r2, r5
  402656:	2301      	movs	r3, #1
  402658:	47c8      	blx	r9
  40265a:	b9b8      	cbnz	r0, 40268c <move_window+0x74>
				return FR_DISK_ERR;
			fs->wflag = 0;
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
  40265c:	69e3      	ldr	r3, [r4, #28]
  40265e:	6a22      	ldr	r2, [r4, #32]
	if (wsect != sector) {	/* Changed current window */
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
			fs->wflag = 0;
  402660:	7120      	strb	r0, [r4, #4]
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
  402662:	441a      	add	r2, r3
  402664:	4295      	cmp	r5, r2
  402666:	d2e0      	bcs.n	40262a <move_window+0x12>
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
  402668:	78e7      	ldrb	r7, [r4, #3]
  40266a:	2f01      	cmp	r7, #1
  40266c:	d801      	bhi.n	402672 <move_window+0x5a>
  40266e:	e7dc      	b.n	40262a <move_window+0x12>
  402670:	69e3      	ldr	r3, [r4, #28]
					wsect += fs->fsize;
  402672:	441d      	add	r5, r3
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
			fs->wflag = 0;
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
  402674:	3f01      	subs	r7, #1
					wsect += fs->fsize;
					disk_write(fs->drv, fs->win, wsect, 1);
  402676:	462a      	mov	r2, r5
  402678:	7860      	ldrb	r0, [r4, #1]
  40267a:	4641      	mov	r1, r8
  40267c:	2301      	movs	r3, #1
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
			fs->wflag = 0;
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
  40267e:	b2ff      	uxtb	r7, r7
					wsect += fs->fsize;
					disk_write(fs->drv, fs->win, wsect, 1);
  402680:	47c8      	blx	r9
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
			fs->wflag = 0;
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
  402682:	2f01      	cmp	r7, #1
  402684:	d1f4      	bne.n	402670 <move_window+0x58>
					disk_write(fs->drv, fs->win, wsect, 1);
				}
			}
		}
#endif
		if (sector) {
  402686:	2e00      	cmp	r6, #0
  402688:	d0d0      	beq.n	40262c <move_window+0x14>
  40268a:	e7d2      	b.n	402632 <move_window+0x1a>
	wsect = fs->winsect;
	if (wsect != sector) {	/* Changed current window */
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
  40268c:	2001      	movs	r0, #1
  40268e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  402692:	bf00      	nop
  402694:	004023f9 	.word	0x004023f9
  402698:	0040246d 	.word	0x0040246d

0040269c <sync>:
#if !_FS_READONLY
static
FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
	FATFS *fs	/* File system object */
)
{
  40269c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	FRESULT res;


	res = move_window(fs, 0);
  4026a0:	2100      	movs	r1, #0
  4026a2:	4b31      	ldr	r3, [pc, #196]	; (402768 <sync+0xcc>)
#if !_FS_READONLY
static
FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
	FATFS *fs	/* File system object */
)
{
  4026a4:	4605      	mov	r5, r0
	FRESULT res;


	res = move_window(fs, 0);
  4026a6:	4798      	blx	r3
  4026a8:	4603      	mov	r3, r0
	if (res == FR_OK) {
  4026aa:	b950      	cbnz	r0, 4026c2 <sync+0x26>
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
  4026ac:	782b      	ldrb	r3, [r5, #0]
  4026ae:	2b03      	cmp	r3, #3
  4026b0:	d00a      	beq.n	4026c8 <sync+0x2c>
			/* Write it into the FSInfo sector */
			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
			fs->fsi_flag = 0;
		}
		/* Make sure that no pending write process in the physical drive */
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
  4026b2:	2100      	movs	r1, #0
  4026b4:	4b2d      	ldr	r3, [pc, #180]	; (40276c <sync+0xd0>)
  4026b6:	7868      	ldrb	r0, [r5, #1]
  4026b8:	460a      	mov	r2, r1
  4026ba:	4798      	blx	r3
  4026bc:	1c03      	adds	r3, r0, #0
  4026be:	bf18      	it	ne
  4026c0:	2301      	movne	r3, #1
			res = FR_DISK_ERR;
	}

	return res;
}
  4026c2:	4618      	mov	r0, r3
  4026c4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}


	res = move_window(fs, 0);
	if (res == FR_OK) {
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
  4026c8:	796b      	ldrb	r3, [r5, #5]
  4026ca:	2b00      	cmp	r3, #0
  4026cc:	d0f1      	beq.n	4026b2 <sync+0x16>
			fs->winsect = 0;
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
  4026ce:	f105 0130 	add.w	r1, r5, #48	; 0x30

	res = move_window(fs, 0);
	if (res == FR_OK) {
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
  4026d2:	62e8      	str	r0, [r5, #44]	; 0x2c
}

/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;
  4026d4:	460b      	mov	r3, r1
  4026d6:	f505 720c 	add.w	r2, r5, #560	; 0x230

	while (cnt--)
		*d++ = (BYTE)val;
  4026da:	f803 0b01 	strb.w	r0, [r3], #1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
  4026de:	4293      	cmp	r3, r2
		*d++ = (BYTE)val;
  4026e0:	f04f 0400 	mov.w	r4, #0
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
  4026e4:	d1f9      	bne.n	4026da <sync+0x3e>
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
  4026e6:	692a      	ldr	r2, [r5, #16]
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
  4026e8:	68eb      	ldr	r3, [r5, #12]
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
  4026ea:	f885 2218 	strb.w	r2, [r5, #536]	; 0x218
  4026ee:	f3c2 2b07 	ubfx	fp, r2, #8, #8
  4026f2:	ea4f 4a12 	mov.w	sl, r2, lsr #16
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
  4026f6:	ea4f 4c13 	mov.w	ip, r3, lsr #16
  4026fa:	ea4f 6e13 	mov.w	lr, r3, lsr #24
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
  4026fe:	2052      	movs	r0, #82	; 0x52
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
  402700:	ea4f 6912 	mov.w	r9, r2, lsr #24
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
  402704:	f3c3 2807 	ubfx	r8, r3, #8, #8
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
  402708:	2261      	movs	r2, #97	; 0x61
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
  40270a:	26aa      	movs	r6, #170	; 0xaa
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
  40270c:	f885 b219 	strb.w	fp, [r5, #537]	; 0x219
  402710:	f885 a21a 	strb.w	sl, [r5, #538]	; 0x21a
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
  402714:	f04f 0b41 	mov.w	fp, #65	; 0x41
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
  402718:	f04f 0a72 	mov.w	sl, #114	; 0x72
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
  40271c:	2755      	movs	r7, #85	; 0x55
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
  40271e:	f885 321c 	strb.w	r3, [r5, #540]	; 0x21c
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
  402722:	f885 622f 	strb.w	r6, [r5, #559]	; 0x22f
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
  402726:	f885 0030 	strb.w	r0, [r5, #48]	; 0x30
  40272a:	f885 0031 	strb.w	r0, [r5, #49]	; 0x31
  40272e:	f885 2032 	strb.w	r2, [r5, #50]	; 0x32
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
  402732:	f885 2217 	strb.w	r2, [r5, #535]	; 0x217
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
  402736:	f885 921b 	strb.w	r9, [r5, #539]	; 0x21b
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
  40273a:	f885 821d 	strb.w	r8, [r5, #541]	; 0x21d
  40273e:	f885 c21e 	strb.w	ip, [r5, #542]	; 0x21e
  402742:	f885 e21f 	strb.w	lr, [r5, #543]	; 0x21f
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
  402746:	f885 722e 	strb.w	r7, [r5, #558]	; 0x22e
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
  40274a:	f885 b033 	strb.w	fp, [r5, #51]	; 0x33
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
  40274e:	f885 b216 	strb.w	fp, [r5, #534]	; 0x216
  402752:	f885 a214 	strb.w	sl, [r5, #532]	; 0x214
  402756:	f885 a215 	strb.w	sl, [r5, #533]	; 0x215
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
			/* Write it into the FSInfo sector */
			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
  40275a:	7868      	ldrb	r0, [r5, #1]
  40275c:	696a      	ldr	r2, [r5, #20]
  40275e:	4e04      	ldr	r6, [pc, #16]	; (402770 <sync+0xd4>)
  402760:	2301      	movs	r3, #1
  402762:	47b0      	blx	r6
			fs->fsi_flag = 0;
  402764:	716c      	strb	r4, [r5, #5]
  402766:	e7a4      	b.n	4026b2 <sync+0x16>
  402768:	00402619 	.word	0x00402619
  40276c:	004024e1 	.word	0x004024e1
  402770:	0040246d 	.word	0x0040246d

00402774 <validate>:
static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	FATFS *fs,		/* Pointer to the file system object */
	WORD id			/* Member id of the target object to be checked */
)
{
  402774:	b508      	push	{r3, lr}
	if (!fs || !fs->fs_type || fs->id != id)
  402776:	b108      	cbz	r0, 40277c <validate+0x8>
  402778:	7803      	ldrb	r3, [r0, #0]
  40277a:	b90b      	cbnz	r3, 402780 <validate+0xc>
		return FR_INVALID_OBJECT;
  40277c:	2009      	movs	r0, #9

	if (disk_status(fs->drv) & STA_NOINIT)
		return FR_NOT_READY;

	return FR_OK;
}
  40277e:	bd08      	pop	{r3, pc}
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	FATFS *fs,		/* Pointer to the file system object */
	WORD id			/* Member id of the target object to be checked */
)
{
	if (!fs || !fs->fs_type || fs->id != id)
  402780:	88c3      	ldrh	r3, [r0, #6]
  402782:	428b      	cmp	r3, r1
  402784:	d1fa      	bne.n	40277c <validate+0x8>
		return FR_INVALID_OBJECT;

	ENTER_FF(fs);		/* Lock file system */

	if (disk_status(fs->drv) & STA_NOINIT)
  402786:	4b04      	ldr	r3, [pc, #16]	; (402798 <validate+0x24>)
  402788:	7840      	ldrb	r0, [r0, #1]
  40278a:	4798      	blx	r3
  40278c:	f010 0f01 	tst.w	r0, #1
		return FR_NOT_READY;
  402790:	bf0c      	ite	eq
  402792:	2000      	moveq	r0, #0
  402794:	2003      	movne	r0, #3
  402796:	bd08      	pop	{r3, pc}
  402798:	004023e1 	.word	0x004023e1

0040279c <check_fs>:
static
BYTE check_fs (	/* 0:FAT-VBR, 1:Valid BR but not FAT, 2:Not a BR, 3:Disk error */
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
  40279c:	b570      	push	{r4, r5, r6, lr}
  40279e:	4604      	mov	r4, r0
  4027a0:	460a      	mov	r2, r1
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
  4027a2:	7840      	ldrb	r0, [r0, #1]
  4027a4:	4d1d      	ldr	r5, [pc, #116]	; (40281c <check_fs+0x80>)
  4027a6:	f104 0130 	add.w	r1, r4, #48	; 0x30
  4027aa:	2301      	movs	r3, #1
  4027ac:	47a8      	blx	r5
  4027ae:	b108      	cbz	r0, 4027b4 <check_fs+0x18>
		return 3;
  4027b0:	2003      	movs	r0, #3
  4027b2:	bd70      	pop	{r4, r5, r6, pc}
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
  4027b4:	f894 122f 	ldrb.w	r1, [r4, #559]	; 0x22f
  4027b8:	f894 222e 	ldrb.w	r2, [r4, #558]	; 0x22e
  4027bc:	4b18      	ldr	r3, [pc, #96]	; (402820 <check_fs+0x84>)
  4027be:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  4027c2:	b212      	sxth	r2, r2
  4027c4:	429a      	cmp	r2, r3
  4027c6:	d001      	beq.n	4027cc <check_fs+0x30>
		return 2;
  4027c8:	2002      	movs	r0, #2
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
		return 0;

	return 1;
}
  4027ca:	bd70      	pop	{r4, r5, r6, pc}
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
		return 3;
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
		return 2;

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
  4027cc:	f894 2068 	ldrb.w	r2, [r4, #104]	; 0x68
  4027d0:	f894 6069 	ldrb.w	r6, [r4, #105]	; 0x69
  4027d4:	f894 5066 	ldrb.w	r5, [r4, #102]	; 0x66
  4027d8:	f894 1067 	ldrb.w	r1, [r4, #103]	; 0x67
  4027dc:	4b11      	ldr	r3, [pc, #68]	; (402824 <check_fs+0x88>)
  4027de:	0412      	lsls	r2, r2, #16
  4027e0:	ea42 6206 	orr.w	r2, r2, r6, lsl #24
  4027e4:	432a      	orrs	r2, r5
  4027e6:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  4027ea:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
  4027ee:	429a      	cmp	r2, r3
  4027f0:	d0eb      	beq.n	4027ca <check_fs+0x2e>
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
  4027f2:	f894 2084 	ldrb.w	r2, [r4, #132]	; 0x84
  4027f6:	f894 5085 	ldrb.w	r5, [r4, #133]	; 0x85
  4027fa:	f894 1082 	ldrb.w	r1, [r4, #130]	; 0x82
  4027fe:	f894 0083 	ldrb.w	r0, [r4, #131]	; 0x83
  402802:	0412      	lsls	r2, r2, #16
  402804:	ea42 6205 	orr.w	r2, r2, r5, lsl #24
  402808:	430a      	orrs	r2, r1
  40280a:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
  40280e:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
		return 0;
  402812:	1ac0      	subs	r0, r0, r3
  402814:	bf18      	it	ne
  402816:	2001      	movne	r0, #1
  402818:	bd70      	pop	{r4, r5, r6, pc}
  40281a:	bf00      	nop
  40281c:	004023f9 	.word	0x004023f9
  402820:	ffffaa55 	.word	0xffffaa55
  402824:	00544146 	.word	0x00544146

00402828 <chk_mounted>:
FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
	FATFS **rfs,		/* Pointer to pointer to the found file system object */
	BYTE chk_wp			/* !=0: Check media write protection for write access */
)
{
  402828:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	BYTE fmt, b, pi, *tbl;
	UINT vol;
	DSTATUS stat;
	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
	WORD nrsv;
	const TCHAR *p = *path;
  40282c:	6803      	ldr	r3, [r0, #0]
	FATFS *fs;

	/* Get logical drive number from the path name */
	vol = p[0] - '0';					/* Is there a drive number? */
  40282e:	781c      	ldrb	r4, [r3, #0]
  402830:	3c30      	subs	r4, #48	; 0x30
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
  402832:	2c09      	cmp	r4, #9
FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
	FATFS **rfs,		/* Pointer to pointer to the found file system object */
	BYTE chk_wp			/* !=0: Check media write protection for write access */
)
{
  402834:	4615      	mov	r5, r2
	const TCHAR *p = *path;
	FATFS *fs;

	/* Get logical drive number from the path name */
	vol = p[0] - '0';					/* Is there a drive number? */
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
  402836:	d802      	bhi.n	40283e <chk_mounted+0x16>
  402838:	785a      	ldrb	r2, [r3, #1]
  40283a:	2a3a      	cmp	r2, #58	; 0x3a
  40283c:	d015      	beq.n	40286a <chk_mounted+0x42>
	}

	/* Check if the file system object is valid or not */
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
		return FR_INVALID_DRIVE;
	*rfs = fs = FatFs[vol];				/* Return pointer to the corresponding file system object */
  40283e:	4bbd      	ldr	r3, [pc, #756]	; (402b34 <chk_mounted+0x30c>)
  402840:	681c      	ldr	r4, [r3, #0]
  402842:	600c      	str	r4, [r1, #0]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
  402844:	b174      	cbz	r4, 402864 <chk_mounted+0x3c>

	ENTER_FF(fs);						/* Lock file system */

	if (fs->fs_type) {					/* If the logical drive has been mounted */
  402846:	7823      	ldrb	r3, [r4, #0]
  402848:	b1b3      	cbz	r3, 402878 <chk_mounted+0x50>
		stat = disk_status(fs->drv);
  40284a:	4bbb      	ldr	r3, [pc, #748]	; (402b38 <chk_mounted+0x310>)
  40284c:	7860      	ldrb	r0, [r4, #1]
  40284e:	4798      	blx	r3
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
  402850:	07c3      	lsls	r3, r0, #31
  402852:	d411      	bmi.n	402878 <chk_mounted+0x50>
			if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
  402854:	b305      	cbz	r5, 402898 <chk_mounted+0x70>
				return FR_WRITE_PROTECTED;
  402856:	f010 0f04 	tst.w	r0, #4
  40285a:	bf0c      	ite	eq
  40285c:	2000      	moveq	r0, #0
  40285e:	200a      	movne	r0, #10
  402860:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

	/* Check if the file system object is valid or not */
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
		return FR_INVALID_DRIVE;
	*rfs = fs = FatFs[vol];				/* Return pointer to the corresponding file system object */
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
  402864:	200c      	movs	r0, #12
  402866:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	FATFS *fs;

	/* Get logical drive number from the path name */
	vol = p[0] - '0';					/* Is there a drive number? */
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
		p += 2; *path = p;				/* Return pointer to the path name */
  40286a:	3302      	adds	r3, #2
  40286c:	6003      	str	r3, [r0, #0]
		vol = 0;						/* Use drive 0 */
#endif
	}

	/* Check if the file system object is valid or not */
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
  40286e:	2c00      	cmp	r4, #0
  402870:	d0e5      	beq.n	40283e <chk_mounted+0x16>
		return FR_INVALID_DRIVE;
  402872:	200b      	movs	r0, #11
  402874:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
  402878:	2000      	movs	r0, #0
  40287a:	7020      	strb	r0, [r4, #0]
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
  40287c:	7060      	strb	r0, [r4, #1]
	stat = disk_initialize(fs->drv);	/* Initialize low level disk I/O layer */
  40287e:	4baf      	ldr	r3, [pc, #700]	; (402b3c <chk_mounted+0x314>)
  402880:	4798      	blx	r3
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
  402882:	07c7      	lsls	r7, r0, #31
  402884:	d502      	bpl.n	40288c <chk_mounted+0x64>
		return FR_NOT_READY;			/* Failed to initialize due to no media or hard error */
  402886:	2003      	movs	r0, #3
  402888:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check disk write protection if needed */
  40288c:	b13d      	cbz	r5, 40289e <chk_mounted+0x76>
  40288e:	0746      	lsls	r6, r0, #29
  402890:	d505      	bpl.n	40289e <chk_mounted+0x76>
		return FR_WRITE_PROTECTED;
  402892:	200a      	movs	r0, #10
  402894:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (fs->fs_type) {					/* If the logical drive has been mounted */
		stat = disk_status(fs->drv);
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
			if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
				return FR_WRITE_PROTECTED;
			return FR_OK;				/* The file system object is valid */
  402898:	4628      	mov	r0, r5
  40289a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
		return FR_DISK_ERR;
#endif
	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
  40289e:	4620      	mov	r0, r4
  4028a0:	2100      	movs	r1, #0
  4028a2:	4da7      	ldr	r5, [pc, #668]	; (402b40 <chk_mounted+0x318>)
  4028a4:	47a8      	blx	r5
	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
  4028a6:	2801      	cmp	r0, #1
  4028a8:	d007      	beq.n	4028ba <chk_mounted+0x92>
#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
		return FR_DISK_ERR;
#endif
	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
  4028aa:	2600      	movs	r6, #0
		if (tbl[4]) {						/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
  4028ac:	2803      	cmp	r0, #3
  4028ae:	f000 80bf 	beq.w	402a30 <chk_mounted+0x208>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
  4028b2:	b1c0      	cbz	r0, 4028e6 <chk_mounted+0xbe>
  4028b4:	200d      	movs	r0, #13
  4028b6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
		/* Check the partition listed in the partition table */
		pi = LD2PT(vol);
		if (pi) pi--;
		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
		if (tbl[4]) {						/* Is the partition existing? */
  4028ba:	f894 31f2 	ldrb.w	r3, [r4, #498]	; 0x1f2
  4028be:	2b00      	cmp	r3, #0
  4028c0:	d0f8      	beq.n	4028b4 <chk_mounted+0x8c>
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
  4028c2:	f894 21f8 	ldrb.w	r2, [r4, #504]	; 0x1f8
  4028c6:	f894 11f9 	ldrb.w	r1, [r4, #505]	; 0x1f9
  4028ca:	f894 31f6 	ldrb.w	r3, [r4, #502]	; 0x1f6
  4028ce:	f894 61f7 	ldrb.w	r6, [r4, #503]	; 0x1f7
  4028d2:	0412      	lsls	r2, r2, #16
  4028d4:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
  4028d8:	4313      	orrs	r3, r2
  4028da:	ea43 2606 	orr.w	r6, r3, r6, lsl #8
			fmt = check_fs(fs, bsect);		/* Check the partition */
  4028de:	4631      	mov	r1, r6
  4028e0:	4620      	mov	r0, r4
  4028e2:	47a8      	blx	r5
  4028e4:	e7e2      	b.n	4028ac <chk_mounted+0x84>
	if (fmt == 3) return FR_DISK_ERR;
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
  4028e6:	f894 203c 	ldrb.w	r2, [r4, #60]	; 0x3c
  4028ea:	f894 303b 	ldrb.w	r3, [r4, #59]	; 0x3b
  4028ee:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  4028f2:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
  4028f6:	d1dd      	bne.n	4028b4 <chk_mounted+0x8c>
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
  4028f8:	f894 1047 	ldrb.w	r1, [r4, #71]	; 0x47
  4028fc:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
  402900:	ea53 2101 	orrs.w	r1, r3, r1, lsl #8
  402904:	d10d      	bne.n	402922 <chk_mounted+0xfa>
  402906:	f894 2056 	ldrb.w	r2, [r4, #86]	; 0x56
  40290a:	f894 0057 	ldrb.w	r0, [r4, #87]	; 0x57
  40290e:	f894 3054 	ldrb.w	r3, [r4, #84]	; 0x54
  402912:	f894 1055 	ldrb.w	r1, [r4, #85]	; 0x55
  402916:	0412      	lsls	r2, r2, #16
  402918:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
  40291c:	4313      	orrs	r3, r2
  40291e:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
  402922:	f894 0040 	ldrb.w	r0, [r4, #64]	; 0x40
	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;
  402926:	61e1      	str	r1, [r4, #28]

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
  402928:	1e43      	subs	r3, r0, #1
  40292a:	2b01      	cmp	r3, #1

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
  40292c:	70e0      	strb	r0, [r4, #3]
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
  40292e:	d8c1      	bhi.n	4028b4 <chk_mounted+0x8c>
	fasize *= b;										/* Number of sectors for FAT area */

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
  402930:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
  402934:	70a3      	strb	r3, [r4, #2]
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
  402936:	2b00      	cmp	r3, #0
  402938:	d0bc      	beq.n	4028b4 <chk_mounted+0x8c>
  40293a:	1e5a      	subs	r2, r3, #1
  40293c:	421a      	tst	r2, r3
  40293e:	d1b9      	bne.n	4028b4 <chk_mounted+0x8c>

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
  402940:	f894 5042 	ldrb.w	r5, [r4, #66]	; 0x42
  402944:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
  402948:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
  40294c:	0715      	lsls	r5, r2, #28
	fasize *= b;										/* Number of sectors for FAT area */

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
  40294e:	8122      	strh	r2, [r4, #8]
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
  402950:	d1b0      	bne.n	4028b4 <chk_mounted+0x8c>

	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
  402952:	f894 7044 	ldrb.w	r7, [r4, #68]	; 0x44
  402956:	f894 5043 	ldrb.w	r5, [r4, #67]	; 0x43
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
  40295a:	ea55 2507 	orrs.w	r5, r5, r7, lsl #8
  40295e:	d10f      	bne.n	402980 <chk_mounted+0x158>
  402960:	f894 c052 	ldrb.w	ip, [r4, #82]	; 0x52
  402964:	f894 8053 	ldrb.w	r8, [r4, #83]	; 0x53
  402968:	f894 5050 	ldrb.w	r5, [r4, #80]	; 0x50
  40296c:	f894 7051 	ldrb.w	r7, [r4, #81]	; 0x51
  402970:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
  402974:	ea4c 6c08 	orr.w	ip, ip, r8, lsl #24
  402978:	ea4c 0505 	orr.w	r5, ip, r5
  40297c:	ea45 2507 	orr.w	r5, r5, r7, lsl #8

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
  402980:	f894 c03f 	ldrb.w	ip, [r4, #63]	; 0x3f
  402984:	f894 703e 	ldrb.w	r7, [r4, #62]	; 0x3e
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
  402988:	ea57 270c 	orrs.w	r7, r7, ip, lsl #8
  40298c:	d092      	beq.n	4028b4 <chk_mounted+0x8c>
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
	fasize *= b;										/* Number of sectors for FAT area */
  40298e:	fb00 fc01 	mul.w	ip, r0, r1

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
  402992:	eb07 1012 	add.w	r0, r7, r2, lsr #4
  402996:	4460      	add	r0, ip
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
  402998:	4285      	cmp	r5, r0
  40299a:	d38b      	bcc.n	4028b4 <chk_mounted+0x8c>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
  40299c:	1a2d      	subs	r5, r5, r0
  40299e:	fbb5 f3f3 	udiv	r3, r5, r3
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
  4029a2:	2b00      	cmp	r3, #0
  4029a4:	d086      	beq.n	4028b4 <chk_mounted+0x8c>
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
  4029a6:	f640 75f5 	movw	r5, #4085	; 0xff5
  4029aa:	42ab      	cmp	r3, r5
  4029ac:	f240 80c0 	bls.w	402b30 <chk_mounted+0x308>
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
  4029b0:	f64f 75f5 	movw	r5, #65525	; 0xfff5
  4029b4:	42ab      	cmp	r3, r5
  4029b6:	f200 80a0 	bhi.w	402afa <chk_mounted+0x2d2>
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
  4029ba:	2502      	movs	r5, #2
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
  4029bc:	3302      	adds	r3, #2
	fs->database = bsect + sysect;						/* Data start sector */
  4029be:	4430      	add	r0, r6
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
  4029c0:	4437      	add	r7, r6
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
  4029c2:	61a3      	str	r3, [r4, #24]
	fs->database = bsect + sysect;						/* Data start sector */
  4029c4:	62a0      	str	r0, [r4, #40]	; 0x28
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
  4029c6:	6227      	str	r7, [r4, #32]
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
  4029c8:	2a00      	cmp	r2, #0
  4029ca:	f43f af73 	beq.w	4028b4 <chk_mounted+0x8c>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
  4029ce:	4467      	add	r7, ip
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
  4029d0:	2d02      	cmp	r5, #2
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
  4029d2:	6267      	str	r7, [r4, #36]	; 0x24
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
  4029d4:	f000 808f 	beq.w	402af6 <chk_mounted+0x2ce>
  4029d8:	eb03 0243 	add.w	r2, r3, r3, lsl #1
  4029dc:	f003 0301 	and.w	r3, r3, #1
  4029e0:	eb03 0352 	add.w	r3, r3, r2, lsr #1
  4029e4:	2501      	movs	r5, #1
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
  4029e6:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
  4029ea:	ebb1 2f53 	cmp.w	r1, r3, lsr #9
  4029ee:	f4ff af61 	bcc.w	4028b4 <chk_mounted+0x8c>
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->free_clust = 0xFFFFFFFF;
  4029f2:	f04f 32ff 	mov.w	r2, #4294967295
	fs->last_clust = 0;
  4029f6:	2300      	movs	r3, #0

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
  4029f8:	2d03      	cmp	r5, #3
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->free_clust = 0xFFFFFFFF;
  4029fa:	6122      	str	r2, [r4, #16]
	fs->last_clust = 0;
  4029fc:	60e3      	str	r3, [r4, #12]

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
  4029fe:	d01a      	beq.n	402a36 <chk_mounted+0x20e>
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
	fs->id = ++Fsid;		/* File system mount ID */
  402a00:	4e50      	ldr	r6, [pc, #320]	; (402b44 <chk_mounted+0x31c>)
  402a02:	4951      	ldr	r1, [pc, #324]	; (402b48 <chk_mounted+0x320>)
  402a04:	8830      	ldrh	r0, [r6, #0]
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
  402a06:	7025      	strb	r5, [r4, #0]
	fs->id = ++Fsid;		/* File system mount ID */
  402a08:	3001      	adds	r0, #1
	fs->winsect = 0;		/* Invalidate sector cache */
  402a0a:	2200      	movs	r2, #0
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
	fs->id = ++Fsid;		/* File system mount ID */
  402a0c:	b280      	uxth	r0, r0
  402a0e:	8030      	strh	r0, [r6, #0]
  402a10:	80e0      	strh	r0, [r4, #6]
	fs->winsect = 0;		/* Invalidate sector cache */
	fs->wflag = 0;
  402a12:	4613      	mov	r3, r2
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
	fs->id = ++Fsid;		/* File system mount ID */
	fs->winsect = 0;		/* Invalidate sector cache */
  402a14:	62e2      	str	r2, [r4, #44]	; 0x2c
	fs->wflag = 0;
  402a16:	7122      	strb	r2, [r4, #4]
)
{
	UINT i;

	for (i = 0; i < _FS_SHARE; i++) {
		if (Files[i].fs == fs) Files[i].fs = 0;
  402a18:	4615      	mov	r5, r2
  402a1a:	4608      	mov	r0, r1
  402a1c:	58ca      	ldr	r2, [r1, r3]
  402a1e:	4294      	cmp	r4, r2
  402a20:	bf08      	it	eq
  402a22:	501d      	streq	r5, [r3, r0]
  402a24:	330c      	adds	r3, #12
	FATFS *fs
)
{
	UINT i;

	for (i = 0; i < _FS_SHARE; i++) {
  402a26:	2b24      	cmp	r3, #36	; 0x24
  402a28:	d1f8      	bne.n	402a1c <chk_mounted+0x1f4>
#endif
#if _FS_SHARE				/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
  402a2a:	2000      	movs	r0, #0
  402a2c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (tbl[4]) {						/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
  402a30:	2001      	movs	r0, #1
  402a32:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	fs->last_clust = 0;

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
  402a36:	f894 1061 	ldrb.w	r1, [r4, #97]	; 0x61
  402a3a:	f894 2060 	ldrb.w	r2, [r4, #96]	; 0x60
	fs->free_clust = 0xFFFFFFFF;
	fs->last_clust = 0;

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
  402a3e:	7163      	strb	r3, [r4, #5]
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
  402a40:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  402a44:	4432      	add	r2, r6
  402a46:	6162      	str	r2, [r4, #20]
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
  402a48:	7860      	ldrb	r0, [r4, #1]
  402a4a:	4e40      	ldr	r6, [pc, #256]	; (402b4c <chk_mounted+0x324>)
  402a4c:	f104 0130 	add.w	r1, r4, #48	; 0x30
  402a50:	2301      	movs	r3, #1
  402a52:	47b0      	blx	r6
  402a54:	2800      	cmp	r0, #0
  402a56:	d1d3      	bne.n	402a00 <chk_mounted+0x1d8>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
  402a58:	f894 122f 	ldrb.w	r1, [r4, #559]	; 0x22f
  402a5c:	f894 222e 	ldrb.w	r2, [r4, #558]	; 0x22e

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
  402a60:	4b3b      	ldr	r3, [pc, #236]	; (402b50 <chk_mounted+0x328>)
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
  402a62:	ea42 2201 	orr.w	r2, r2, r1, lsl #8

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
  402a66:	b212      	sxth	r2, r2
  402a68:	429a      	cmp	r2, r3
  402a6a:	d1c9      	bne.n	402a00 <chk_mounted+0x1d8>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
  402a6c:	f894 0032 	ldrb.w	r0, [r4, #50]	; 0x32
  402a70:	f894 6033 	ldrb.w	r6, [r4, #51]	; 0x33
  402a74:	f894 2030 	ldrb.w	r2, [r4, #48]	; 0x30
  402a78:	f894 1031 	ldrb.w	r1, [r4, #49]	; 0x31
	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
  402a7c:	4b35      	ldr	r3, [pc, #212]	; (402b54 <chk_mounted+0x32c>)
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
  402a7e:	0400      	lsls	r0, r0, #16
  402a80:	ea40 6006 	orr.w	r0, r0, r6, lsl #24
  402a84:	4302      	orrs	r2, r0
  402a86:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
  402a8a:	429a      	cmp	r2, r3
  402a8c:	d1b8      	bne.n	402a00 <chk_mounted+0x1d8>
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
  402a8e:	f894 0216 	ldrb.w	r0, [r4, #534]	; 0x216
  402a92:	f894 6217 	ldrb.w	r6, [r4, #535]	; 0x217
  402a96:	f894 2214 	ldrb.w	r2, [r4, #532]	; 0x214
  402a9a:	f894 1215 	ldrb.w	r1, [r4, #533]	; 0x215
  402a9e:	0400      	lsls	r0, r0, #16
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
  402aa0:	f103 53ff 	add.w	r3, r3, #534773760	; 0x1fe00000
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
  402aa4:	ea40 6006 	orr.w	r0, r0, r6, lsl #24
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
  402aa8:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
  402aac:	4302      	orrs	r2, r0
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
  402aae:	3320      	adds	r3, #32
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
  402ab0:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
  402ab4:	429a      	cmp	r2, r3
  402ab6:	d1a3      	bne.n	402a00 <chk_mounted+0x1d8>
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  402ab8:	f894 721e 	ldrb.w	r7, [r4, #542]	; 0x21e
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  402abc:	f894 621a 	ldrb.w	r6, [r4, #538]	; 0x21a
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  402ac0:	f894 821f 	ldrb.w	r8, [r4, #543]	; 0x21f
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  402ac4:	f894 c21b 	ldrb.w	ip, [r4, #539]	; 0x21b
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  402ac8:	f894 221c 	ldrb.w	r2, [r4, #540]	; 0x21c
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  402acc:	f894 3218 	ldrb.w	r3, [r4, #536]	; 0x218
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  402ad0:	f894 021d 	ldrb.w	r0, [r4, #541]	; 0x21d
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  402ad4:	f894 1219 	ldrb.w	r1, [r4, #537]	; 0x219
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  402ad8:	043f      	lsls	r7, r7, #16
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  402ada:	0436      	lsls	r6, r6, #16
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  402adc:	ea47 6708 	orr.w	r7, r7, r8, lsl #24
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  402ae0:	ea46 660c 	orr.w	r6, r6, ip, lsl #24
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  402ae4:	433a      	orrs	r2, r7
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  402ae6:	4333      	orrs	r3, r6
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  402ae8:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  402aec:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  402af0:	60e2      	str	r2, [r4, #12]
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  402af2:	6123      	str	r3, [r4, #16]
  402af4:	e784      	b.n	402a00 <chk_mounted+0x1d8>
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
  402af6:	005b      	lsls	r3, r3, #1
  402af8:	e775      	b.n	4029e6 <chk_mounted+0x1be>
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
  402afa:	3302      	adds	r3, #2
	fs->database = bsect + sysect;						/* Data start sector */
  402afc:	4430      	add	r0, r6
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
  402afe:	4437      	add	r7, r6
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
  402b00:	61a3      	str	r3, [r4, #24]
	fs->database = bsect + sysect;						/* Data start sector */
  402b02:	62a0      	str	r0, [r4, #40]	; 0x28
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
  402b04:	6227      	str	r7, [r4, #32]
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
  402b06:	2a00      	cmp	r2, #0
  402b08:	f47f aed4 	bne.w	4028b4 <chk_mounted+0x8c>
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
  402b0c:	f894 505e 	ldrb.w	r5, [r4, #94]	; 0x5e
  402b10:	f894 705f 	ldrb.w	r7, [r4, #95]	; 0x5f
  402b14:	f894 205c 	ldrb.w	r2, [r4, #92]	; 0x5c
  402b18:	f894 005d 	ldrb.w	r0, [r4, #93]	; 0x5d
  402b1c:	042d      	lsls	r5, r5, #16
  402b1e:	ea45 6507 	orr.w	r5, r5, r7, lsl #24
  402b22:	432a      	orrs	r2, r5
  402b24:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
  402b28:	009b      	lsls	r3, r3, #2
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
	fs->database = bsect + sysect;						/* Data start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
  402b2a:	6262      	str	r2, [r4, #36]	; 0x24
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
  402b2c:	2503      	movs	r5, #3
  402b2e:	e75a      	b.n	4029e6 <chk_mounted+0x1be>
	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
  402b30:	2501      	movs	r5, #1
  402b32:	e743      	b.n	4029bc <chk_mounted+0x194>
  402b34:	20000f8c 	.word	0x20000f8c
  402b38:	004023e1 	.word	0x004023e1
  402b3c:	0040239d 	.word	0x0040239d
  402b40:	0040279d 	.word	0x0040279d
  402b44:	20000f64 	.word	0x20000f64
  402b48:	20000f68 	.word	0x20000f68
  402b4c:	004023f9 	.word	0x004023f9
  402b50:	ffffaa55 	.word	0xffffaa55
  402b54:	41615252 	.word	0x41615252

00402b58 <get_fat.part.3>:
/*-----------------------------------------------------------------------*/
/* FAT access - Read value of a FAT entry                                */
/*-----------------------------------------------------------------------*/


static DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
  402b58:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
		return 1;

	switch (fs->fs_type) {
  402b5c:	7803      	ldrb	r3, [r0, #0]
  402b5e:	2b02      	cmp	r3, #2
/*-----------------------------------------------------------------------*/
/* FAT access - Read value of a FAT entry                                */
/*-----------------------------------------------------------------------*/


static DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
  402b60:	4604      	mov	r4, r0
  402b62:	460d      	mov	r5, r1


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
		return 1;

	switch (fs->fs_type) {
  402b64:	d048      	beq.n	402bf8 <get_fat.part.3+0xa0>
  402b66:	2b03      	cmp	r3, #3
  402b68:	d029      	beq.n	402bbe <get_fat.part.3+0x66>
  402b6a:	2b01      	cmp	r3, #1
  402b6c:	d003      	beq.n	402b76 <get_fat.part.3+0x1e>
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
		p = &fs->win[clst * 4 % SS(fs)];
		return LD_DWORD(p) & 0x0FFFFFFF;
	}

	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
  402b6e:	f04f 30ff 	mov.w	r0, #4294967295
}
  402b72:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return 1;

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
  402b76:	6a01      	ldr	r1, [r0, #32]
  402b78:	4f29      	ldr	r7, [pc, #164]	; (402c20 <get_fat.part.3+0xc8>)
	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
		return 1;

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
  402b7a:	eb05 0655 	add.w	r6, r5, r5, lsr #1
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
  402b7e:	eb01 2156 	add.w	r1, r1, r6, lsr #9
  402b82:	47b8      	blx	r7
  402b84:	2800      	cmp	r0, #0
  402b86:	d1f2      	bne.n	402b6e <get_fat.part.3+0x16>
		wc = fs->win[bc % SS(fs)]; bc++;
  402b88:	f3c6 0308 	ubfx	r3, r6, #0, #9
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
  402b8c:	6a21      	ldr	r1, [r4, #32]

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc = fs->win[bc % SS(fs)]; bc++;
  402b8e:	4423      	add	r3, r4
  402b90:	3601      	adds	r6, #1
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
  402b92:	eb01 2156 	add.w	r1, r1, r6, lsr #9
  402b96:	4620      	mov	r0, r4

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc = fs->win[bc % SS(fs)]; bc++;
  402b98:	f893 8030 	ldrb.w	r8, [r3, #48]	; 0x30
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
  402b9c:	47b8      	blx	r7
  402b9e:	2800      	cmp	r0, #0
  402ba0:	d1e5      	bne.n	402b6e <get_fat.part.3+0x16>
		wc |= fs->win[bc % SS(fs)] << 8;
  402ba2:	f3c6 0608 	ubfx	r6, r6, #0, #9
  402ba6:	4434      	add	r4, r6
  402ba8:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
  402bac:	ea48 2003 	orr.w	r0, r8, r3, lsl #8
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
  402bb0:	07eb      	lsls	r3, r5, #31
  402bb2:	bf4c      	ite	mi
  402bb4:	0900      	lsrmi	r0, r0, #4
  402bb6:	f3c0 000b 	ubfxpl	r0, r0, #0, #12
  402bba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
		p = &fs->win[clst * 2 % SS(fs)];
		return LD_WORD(p);

	case FS_FAT32 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
  402bbe:	6a01      	ldr	r1, [r0, #32]
  402bc0:	4b17      	ldr	r3, [pc, #92]	; (402c20 <get_fat.part.3+0xc8>)
  402bc2:	eb01 11d5 	add.w	r1, r1, r5, lsr #7
  402bc6:	4798      	blx	r3
  402bc8:	2800      	cmp	r0, #0
  402bca:	d1d0      	bne.n	402b6e <get_fat.part.3+0x16>
		p = &fs->win[clst * 4 % SS(fs)];
  402bcc:	00ad      	lsls	r5, r5, #2
  402bce:	f405 75fe 	and.w	r5, r5, #508	; 0x1fc
  402bd2:	f105 0330 	add.w	r3, r5, #48	; 0x30
  402bd6:	4423      	add	r3, r4
		return LD_DWORD(p) & 0x0FFFFFFF;
  402bd8:	442c      	add	r4, r5
  402bda:	78d8      	ldrb	r0, [r3, #3]
  402bdc:	7899      	ldrb	r1, [r3, #2]
  402bde:	785a      	ldrb	r2, [r3, #1]
  402be0:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
  402be4:	0600      	lsls	r0, r0, #24
  402be6:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
  402bea:	ea40 2002 	orr.w	r0, r0, r2, lsl #8
  402bee:	4318      	orrs	r0, r3
  402bf0:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000
  402bf4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc |= fs->win[bc % SS(fs)] << 8;
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);

	case FS_FAT16 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
  402bf8:	6a01      	ldr	r1, [r0, #32]
  402bfa:	4b09      	ldr	r3, [pc, #36]	; (402c20 <get_fat.part.3+0xc8>)
  402bfc:	eb01 2115 	add.w	r1, r1, r5, lsr #8
  402c00:	4798      	blx	r3
  402c02:	2800      	cmp	r0, #0
  402c04:	d1b3      	bne.n	402b6e <get_fat.part.3+0x16>
		p = &fs->win[clst * 2 % SS(fs)];
  402c06:	006d      	lsls	r5, r5, #1
  402c08:	f405 75ff 	and.w	r5, r5, #510	; 0x1fe
		return LD_WORD(p);
  402c0c:	1963      	adds	r3, r4, r5
  402c0e:	461c      	mov	r4, r3
  402c10:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
  402c14:	f894 0031 	ldrb.w	r0, [r4, #49]	; 0x31
  402c18:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
  402c1c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  402c20:	00402619 	.word	0x00402619

00402c24 <dir_sdi>:
static
FRESULT dir_sdi (
	DIR *dj,		/* Pointer to directory object */
	WORD idx		/* Directory index number */
)
{
  402c24:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	DWORD clst;
	WORD ic;


	dj->index = idx;
	clst = dj->sclust;
  402c26:	6883      	ldr	r3, [r0, #8]
static
FRESULT dir_sdi (
	DIR *dj,		/* Pointer to directory object */
	WORD idx		/* Directory index number */
)
{
  402c28:	4604      	mov	r4, r0
	WORD ic;


	dj->index = idx;
	clst = dj->sclust;
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
  402c2a:	2b01      	cmp	r3, #1
static
FRESULT dir_sdi (
	DIR *dj,		/* Pointer to directory object */
	WORD idx		/* Directory index number */
)
{
  402c2c:	460d      	mov	r5, r1
	DWORD clst;
	WORD ic;


	dj->index = idx;
  402c2e:	80e1      	strh	r1, [r4, #6]
	clst = dj->sclust;
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
  402c30:	d003      	beq.n	402c3a <dir_sdi+0x16>
  402c32:	6800      	ldr	r0, [r0, #0]
  402c34:	6982      	ldr	r2, [r0, #24]
  402c36:	4293      	cmp	r3, r2
  402c38:	d301      	bcc.n	402c3e <dir_sdi+0x1a>
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
  402c3a:	2002      	movs	r0, #2
  402c3c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	dj->index = idx;
	clst = dj->sclust;
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
		return FR_INT_ERR;
	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
  402c3e:	b9b3      	cbnz	r3, 402c6e <dir_sdi+0x4a>
  402c40:	7803      	ldrb	r3, [r0, #0]
  402c42:	2b03      	cmp	r3, #3
  402c44:	d010      	beq.n	402c68 <dir_sdi+0x44>
		clst = dj->fs->dirbase;

	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
		dj->clust = clst;
  402c46:	2300      	movs	r3, #0
  402c48:	60e3      	str	r3, [r4, #12]
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
  402c4a:	8903      	ldrh	r3, [r0, #8]
  402c4c:	42ab      	cmp	r3, r5
  402c4e:	d9f4      	bls.n	402c3a <dir_sdi+0x16>
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
  402c50:	6a43      	ldr	r3, [r0, #36]	; 0x24
  402c52:	eb03 1315 	add.w	r3, r3, r5, lsr #4
  402c56:	6123      	str	r3, [r4, #16]
		}
		dj->clust = clst;
		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
  402c58:	f005 050f 	and.w	r5, r5, #15
  402c5c:	eb00 1045 	add.w	r0, r0, r5, lsl #5
  402c60:	3030      	adds	r0, #48	; 0x30
  402c62:	6160      	str	r0, [r4, #20]

	return FR_OK;	/* Seek succeeded */
  402c64:	2000      	movs	r0, #0
  402c66:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	dj->index = idx;
	clst = dj->sclust;
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
		return FR_INT_ERR;
	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
		clst = dj->fs->dirbase;
  402c68:	6a43      	ldr	r3, [r0, #36]	; 0x24

	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
  402c6a:	2b00      	cmp	r3, #0
  402c6c:	d0eb      	beq.n	402c46 <dir_sdi+0x22>
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
  402c6e:	7886      	ldrb	r6, [r0, #2]
  402c70:	0136      	lsls	r6, r6, #4
		while (idx >= ic) {	/* Follow cluster chain */
  402c72:	42b5      	cmp	r5, r6
  402c74:	d319      	bcc.n	402caa <dir_sdi+0x86>
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  402c76:	2b01      	cmp	r3, #1
  402c78:	d9df      	bls.n	402c3a <dir_sdi+0x16>
  402c7a:	1bad      	subs	r5, r5, r6
  402c7c:	429a      	cmp	r2, r3
  402c7e:	b2ad      	uxth	r5, r5
  402c80:	d9db      	bls.n	402c3a <dir_sdi+0x16>
  402c82:	4f11      	ldr	r7, [pc, #68]	; (402cc8 <dir_sdi+0xa4>)
  402c84:	e008      	b.n	402c98 <dir_sdi+0x74>
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
  402c86:	2801      	cmp	r0, #1
  402c88:	d9d7      	bls.n	402c3a <dir_sdi+0x16>
  402c8a:	6820      	ldr	r0, [r4, #0]
  402c8c:	6982      	ldr	r2, [r0, #24]
  402c8e:	429a      	cmp	r2, r3
  402c90:	d9d3      	bls.n	402c3a <dir_sdi+0x16>
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
  402c92:	42ae      	cmp	r6, r5
  402c94:	d809      	bhi.n	402caa <dir_sdi+0x86>
  402c96:	460d      	mov	r5, r1
  402c98:	4619      	mov	r1, r3
  402c9a:	47b8      	blx	r7
  402c9c:	1ba9      	subs	r1, r5, r6
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
  402c9e:	1c42      	adds	r2, r0, #1
  402ca0:	4603      	mov	r3, r0
  402ca2:	b289      	uxth	r1, r1
  402ca4:	d1ef      	bne.n	402c86 <dir_sdi+0x62>
  402ca6:	2001      	movs	r0, #1
  402ca8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
			idx -= ic;
		}
		dj->clust = clst;
  402caa:	60e3      	str	r3, [r4, #12]
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  402cac:	6982      	ldr	r2, [r0, #24]
static DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
  402cae:	3b02      	subs	r3, #2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  402cb0:	3a02      	subs	r2, #2
  402cb2:	4293      	cmp	r3, r2
	return clst * fs->csize + fs->database;
  402cb4:	bf3b      	ittet	cc
  402cb6:	7881      	ldrbcc	r1, [r0, #2]
  402cb8:	6a82      	ldrcc	r2, [r0, #40]	; 0x28
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  402cba:	2300      	movcs	r3, #0
	return clst * fs->csize + fs->database;
  402cbc:	fb01 2303 	mlacc	r3, r1, r3, r2
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
			idx -= ic;
		}
		dj->clust = clst;
		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
  402cc0:	eb03 1315 	add.w	r3, r3, r5, lsr #4
  402cc4:	6123      	str	r3, [r4, #16]
  402cc6:	e7c7      	b.n	402c58 <dir_sdi+0x34>
  402cc8:	00402b59 	.word	0x00402b59

00402ccc <put_fat.part.4>:
/*-----------------------------------------------------------------------*/
/* FAT access - Change value of a FAT entry                              */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY

static FRESULT put_fat (
  402ccc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
  402cd0:	7803      	ldrb	r3, [r0, #0]
  402cd2:	2b02      	cmp	r3, #2
/*-----------------------------------------------------------------------*/
/* FAT access - Change value of a FAT entry                              */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY

static FRESULT put_fat (
  402cd4:	4604      	mov	r4, r0
  402cd6:	460d      	mov	r5, r1
  402cd8:	4616      	mov	r6, r2

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
  402cda:	d05b      	beq.n	402d94 <put_fat.part.4+0xc8>
  402cdc:	2b03      	cmp	r3, #3
  402cde:	d039      	beq.n	402d54 <put_fat.part.4+0x88>
  402ce0:	2b01      	cmp	r3, #1
  402ce2:	d004      	beq.n	402cee <put_fat.part.4+0x22>
			val |= LD_DWORD(p) & 0xF0000000;
			ST_DWORD(p, val);
			break;

		default :
			res = FR_INT_ERR;
  402ce4:	2002      	movs	r0, #2
		}
		fs->wflag = 1;
  402ce6:	2301      	movs	r3, #1
  402ce8:	7123      	strb	r3, [r4, #4]
	}

	return res;
}
  402cea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

	} else {
		switch (fs->fs_type) {
		case FS_FAT12 :
			bc = clst; bc += bc / 2;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
  402cee:	6a01      	ldr	r1, [r0, #32]
  402cf0:	f8df 80d4 	ldr.w	r8, [pc, #212]	; 402dc8 <put_fat.part.4+0xfc>
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
		case FS_FAT12 :
			bc = clst; bc += bc / 2;
  402cf4:	eb05 0755 	add.w	r7, r5, r5, lsr #1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
  402cf8:	eb01 2157 	add.w	r1, r1, r7, lsr #9
  402cfc:	47c0      	blx	r8
			if (res != FR_OK) break;
  402cfe:	2800      	cmp	r0, #0
  402d00:	d1f1      	bne.n	402ce6 <put_fat.part.4+0x1a>
			p = &fs->win[bc % SS(fs)];
  402d02:	f3c7 0308 	ubfx	r3, r7, #0, #9
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
  402d06:	f015 0501 	ands.w	r5, r5, #1
  402d0a:	4423      	add	r3, r4
  402d0c:	b2f2      	uxtb	r2, r6
  402d0e:	d006      	beq.n	402d1e <put_fat.part.4+0x52>
  402d10:	f893 1030 	ldrb.w	r1, [r3, #48]	; 0x30
  402d14:	f001 010f 	and.w	r1, r1, #15
  402d18:	ea41 1202 	orr.w	r2, r1, r2, lsl #4
  402d1c:	b2d2      	uxtb	r2, r2
  402d1e:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
			bc++;
			fs->wflag = 1;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
  402d22:	6a21      	ldr	r1, [r4, #32]
			bc = clst; bc += bc / 2;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
			if (res != FR_OK) break;
			p = &fs->win[bc % SS(fs)];
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
			bc++;
  402d24:	3701      	adds	r7, #1
			fs->wflag = 1;
  402d26:	2301      	movs	r3, #1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
  402d28:	eb01 2157 	add.w	r1, r1, r7, lsr #9
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
			if (res != FR_OK) break;
			p = &fs->win[bc % SS(fs)];
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
			bc++;
			fs->wflag = 1;
  402d2c:	7123      	strb	r3, [r4, #4]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
  402d2e:	4620      	mov	r0, r4
  402d30:	47c0      	blx	r8
			if (res != FR_OK) break;
  402d32:	2800      	cmp	r0, #0
  402d34:	d1d7      	bne.n	402ce6 <put_fat.part.4+0x1a>
			p = &fs->win[bc % SS(fs)];
  402d36:	f3c7 0708 	ubfx	r7, r7, #0, #9
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
  402d3a:	2d00      	cmp	r5, #0
  402d3c:	d13f      	bne.n	402dbe <put_fat.part.4+0xf2>
  402d3e:	4427      	add	r7, r4
  402d40:	f3c6 2603 	ubfx	r6, r6, #8, #4
  402d44:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
  402d48:	f023 030f 	bic.w	r3, r3, #15
  402d4c:	431e      	orrs	r6, r3
  402d4e:	f887 6030 	strb.w	r6, [r7, #48]	; 0x30
  402d52:	e7c8      	b.n	402ce6 <put_fat.part.4+0x1a>
			p = &fs->win[clst * 2 % SS(fs)];
			ST_WORD(p, (WORD)val);
			break;

		case FS_FAT32 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
  402d54:	6a01      	ldr	r1, [r0, #32]
  402d56:	4b1c      	ldr	r3, [pc, #112]	; (402dc8 <put_fat.part.4+0xfc>)
  402d58:	eb01 11d5 	add.w	r1, r1, r5, lsr #7
  402d5c:	4798      	blx	r3
			if (res != FR_OK) break;
  402d5e:	2800      	cmp	r0, #0
  402d60:	d1c1      	bne.n	402ce6 <put_fat.part.4+0x1a>
			p = &fs->win[clst * 4 % SS(fs)];
  402d62:	00ad      	lsls	r5, r5, #2
  402d64:	f405 75fe 	and.w	r5, r5, #508	; 0x1fc
  402d68:	f105 0330 	add.w	r3, r5, #48	; 0x30
  402d6c:	4423      	add	r3, r4
			val |= LD_DWORD(p) & 0xF0000000;
  402d6e:	4425      	add	r5, r4
  402d70:	78da      	ldrb	r2, [r3, #3]
  402d72:	0612      	lsls	r2, r2, #24
  402d74:	f002 4270 	and.w	r2, r2, #4026531840	; 0xf0000000
  402d78:	4316      	orrs	r6, r2
			ST_DWORD(p, val);
  402d7a:	f3c6 2707 	ubfx	r7, r6, #8, #8
  402d7e:	0c31      	lsrs	r1, r6, #16
  402d80:	0e32      	lsrs	r2, r6, #24
  402d82:	f885 6030 	strb.w	r6, [r5, #48]	; 0x30
  402d86:	705f      	strb	r7, [r3, #1]
  402d88:	7099      	strb	r1, [r3, #2]
  402d8a:	70da      	strb	r2, [r3, #3]
			break;

		default :
			res = FR_INT_ERR;
		}
		fs->wflag = 1;
  402d8c:	2301      	movs	r3, #1
  402d8e:	7123      	strb	r3, [r4, #4]
	}

	return res;
}
  402d90:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			p = &fs->win[bc % SS(fs)];
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
			break;

		case FS_FAT16 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
  402d94:	6a01      	ldr	r1, [r0, #32]
  402d96:	4b0c      	ldr	r3, [pc, #48]	; (402dc8 <put_fat.part.4+0xfc>)
  402d98:	eb01 2115 	add.w	r1, r1, r5, lsr #8
  402d9c:	4798      	blx	r3
			if (res != FR_OK) break;
  402d9e:	2800      	cmp	r0, #0
  402da0:	d1a1      	bne.n	402ce6 <put_fat.part.4+0x1a>
			p = &fs->win[clst * 2 % SS(fs)];
  402da2:	006d      	lsls	r5, r5, #1
  402da4:	f405 75ff 	and.w	r5, r5, #510	; 0x1fe
			ST_WORD(p, (WORD)val);
  402da8:	1962      	adds	r2, r4, r5
  402daa:	f3c6 2307 	ubfx	r3, r6, #8, #8
  402dae:	f882 3031 	strb.w	r3, [r2, #49]	; 0x31
			break;

		default :
			res = FR_INT_ERR;
		}
		fs->wflag = 1;
  402db2:	2301      	movs	r3, #1

		case FS_FAT16 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
			if (res != FR_OK) break;
			p = &fs->win[clst * 2 % SS(fs)];
			ST_WORD(p, (WORD)val);
  402db4:	f882 6030 	strb.w	r6, [r2, #48]	; 0x30
			break;

		default :
			res = FR_INT_ERR;
		}
		fs->wflag = 1;
  402db8:	7123      	strb	r3, [r4, #4]
	}

	return res;
}
  402dba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			bc++;
			fs->wflag = 1;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
			if (res != FR_OK) break;
			p = &fs->win[bc % SS(fs)];
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
  402dbe:	f3c6 1607 	ubfx	r6, r6, #4, #8
  402dc2:	4427      	add	r7, r4
  402dc4:	e7c3      	b.n	402d4e <put_fat.part.4+0x82>
  402dc6:	bf00      	nop
  402dc8:	00402619 	.word	0x00402619

00402dcc <create_chain>:
static
DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
	FATFS *fs,			/* File system object */
	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
)
{
  402dcc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  402dd0:	4605      	mov	r5, r0
	DWORD cs, ncl, scl;
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
  402dd2:	4688      	mov	r8, r1
  402dd4:	bb01      	cbnz	r1, 402e18 <create_chain+0x4c>
		scl = fs->last_clust;			/* Get suggested start point */
  402dd6:	68c6      	ldr	r6, [r0, #12]
  402dd8:	6983      	ldr	r3, [r0, #24]
		if (!scl || scl >= fs->n_fatent) scl = 1;
  402dda:	b35e      	cbz	r6, 402e34 <create_chain+0x68>
  402ddc:	429e      	cmp	r6, r3
  402dde:	bf28      	it	cs
  402de0:	2601      	movcs	r6, #1
  402de2:	4f2e      	ldr	r7, [pc, #184]	; (402e9c <create_chain+0xd0>)
  402de4:	4634      	mov	r4, r6
  402de6:	e00f      	b.n	402e08 <create_chain+0x3c>
	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
  402de8:	2e01      	cmp	r6, #1
  402dea:	d925      	bls.n	402e38 <create_chain+0x6c>
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  402dec:	2b02      	cmp	r3, #2
  402dee:	d910      	bls.n	402e12 <create_chain+0x46>

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
  402df0:	2402      	movs	r4, #2
  402df2:	4628      	mov	r0, r5
  402df4:	4621      	mov	r1, r4
  402df6:	47b8      	blx	r7
			if (ncl > scl) return 0;	/* No free cluster */
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
		if (cs == 0) break;				/* Found a free cluster */
  402df8:	b338      	cbz	r0, 402e4a <create_chain+0x7e>
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
  402dfa:	1c41      	adds	r1, r0, #1
  402dfc:	d021      	beq.n	402e42 <create_chain+0x76>
  402dfe:	2801      	cmp	r0, #1
  402e00:	d007      	beq.n	402e12 <create_chain+0x46>
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
  402e02:	42a6      	cmp	r6, r4
  402e04:	d018      	beq.n	402e38 <create_chain+0x6c>
  402e06:	69ab      	ldr	r3, [r5, #24]
		scl = clst;
	}

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
  402e08:	3401      	adds	r4, #1
		if (ncl >= fs->n_fatent) {		/* Wrap around */
  402e0a:	429c      	cmp	r4, r3
  402e0c:	d2ec      	bcs.n	402de8 <create_chain+0x1c>
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  402e0e:	2c01      	cmp	r4, #1
  402e10:	d8ef      	bhi.n	402df2 <create_chain+0x26>
		if (fs->free_clust != 0xFFFFFFFF) {
			fs->free_clust--;
			fs->fsi_flag = 1;
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
  402e12:	2001      	movs	r0, #1
	}

	return ncl;		/* Return new cluster number or error code */
}
  402e14:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  402e18:	2901      	cmp	r1, #1
  402e1a:	d9fa      	bls.n	402e12 <create_chain+0x46>
  402e1c:	6983      	ldr	r3, [r0, #24]
  402e1e:	4299      	cmp	r1, r3
  402e20:	d2f7      	bcs.n	402e12 <create_chain+0x46>
  402e22:	4b1e      	ldr	r3, [pc, #120]	; (402e9c <create_chain+0xd0>)
  402e24:	4798      	blx	r3
		scl = fs->last_clust;			/* Get suggested start point */
		if (!scl || scl >= fs->n_fatent) scl = 1;
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
		if (cs < 2) return 1;			/* It is an invalid cluster */
  402e26:	2801      	cmp	r0, #1
  402e28:	d9f3      	bls.n	402e12 <create_chain+0x46>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
  402e2a:	69ab      	ldr	r3, [r5, #24]
  402e2c:	4283      	cmp	r3, r0
  402e2e:	d8f1      	bhi.n	402e14 <create_chain+0x48>
  402e30:	4646      	mov	r6, r8
  402e32:	e7d6      	b.n	402de2 <create_chain+0x16>
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
		scl = fs->last_clust;			/* Get suggested start point */
		if (!scl || scl >= fs->n_fatent) scl = 1;
  402e34:	2601      	movs	r6, #1
  402e36:	e7d4      	b.n	402de2 <create_chain+0x16>
	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
  402e38:	2000      	movs	r0, #0
  402e3a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (fs->free_clust != 0xFFFFFFFF) {
			fs->free_clust--;
			fs->fsi_flag = 1;
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
  402e3e:	2801      	cmp	r0, #1
  402e40:	d1e7      	bne.n	402e12 <create_chain+0x46>
  402e42:	f04f 30ff 	mov.w	r0, #4294967295
  402e46:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
  402e4a:	69ab      	ldr	r3, [r5, #24]
  402e4c:	42a3      	cmp	r3, r4
  402e4e:	d9e0      	bls.n	402e12 <create_chain+0x46>
  402e50:	4628      	mov	r0, r5
  402e52:	4621      	mov	r1, r4
  402e54:	f06f 4270 	mvn.w	r2, #4026531840	; 0xf0000000
  402e58:	4e11      	ldr	r6, [pc, #68]	; (402ea0 <create_chain+0xd4>)
  402e5a:	47b0      	blx	r6
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
	}

	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
	if (res == FR_OK && clst != 0) {
  402e5c:	2800      	cmp	r0, #0
  402e5e:	d1ee      	bne.n	402e3e <create_chain+0x72>
  402e60:	f1b8 0f00 	cmp.w	r8, #0
  402e64:	d00b      	beq.n	402e7e <create_chain+0xb2>
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
  402e66:	f1b8 0f01 	cmp.w	r8, #1
  402e6a:	d9d2      	bls.n	402e12 <create_chain+0x46>
  402e6c:	69ab      	ldr	r3, [r5, #24]
  402e6e:	4598      	cmp	r8, r3
  402e70:	d2cf      	bcs.n	402e12 <create_chain+0x46>
  402e72:	4641      	mov	r1, r8
  402e74:	4628      	mov	r0, r5
  402e76:	4622      	mov	r2, r4
  402e78:	47b0      	blx	r6

	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
	if (res == FR_OK && clst != 0) {
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
	}
	if (res == FR_OK) {
  402e7a:	2800      	cmp	r0, #0
  402e7c:	d1df      	bne.n	402e3e <create_chain+0x72>
		fs->last_clust = ncl;			/* Update FSINFO */
		if (fs->free_clust != 0xFFFFFFFF) {
  402e7e:	692b      	ldr	r3, [r5, #16]
	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
	if (res == FR_OK && clst != 0) {
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
	}
	if (res == FR_OK) {
		fs->last_clust = ncl;			/* Update FSINFO */
  402e80:	60ec      	str	r4, [r5, #12]
		if (fs->free_clust != 0xFFFFFFFF) {
  402e82:	1c5a      	adds	r2, r3, #1
  402e84:	d006      	beq.n	402e94 <create_chain+0xc8>
			fs->free_clust--;
  402e86:	3b01      	subs	r3, #1
			fs->fsi_flag = 1;
  402e88:	2201      	movs	r2, #1
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
	}
	if (res == FR_OK) {
		fs->last_clust = ncl;			/* Update FSINFO */
		if (fs->free_clust != 0xFFFFFFFF) {
			fs->free_clust--;
  402e8a:	612b      	str	r3, [r5, #16]
			fs->fsi_flag = 1;
  402e8c:	716a      	strb	r2, [r5, #5]
  402e8e:	4620      	mov	r0, r4
  402e90:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  402e94:	4620      	mov	r0, r4
  402e96:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  402e9a:	bf00      	nop
  402e9c:	00402b59 	.word	0x00402b59
  402ea0:	00402ccd 	.word	0x00402ccd

00402ea4 <dir_next>:
static
FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
	DIR *dj,		/* Pointer to directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
  402ea4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	DWORD clst;
	WORD i;


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
  402ea8:	88c5      	ldrh	r5, [r0, #6]
  402eaa:	3501      	adds	r5, #1
  402eac:	b2ad      	uxth	r5, r5
static
FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
	DIR *dj,		/* Pointer to directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
  402eae:	4604      	mov	r4, r0
  402eb0:	460e      	mov	r6, r1
	WORD i;


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
  402eb2:	b915      	cbnz	r5, 402eba <dir_next+0x16>
		return FR_NO_FILE;
  402eb4:	2004      	movs	r0, #4
  402eb6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	WORD i;


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
  402eba:	6903      	ldr	r3, [r0, #16]
  402ebc:	2b00      	cmp	r3, #0
  402ebe:	d0f9      	beq.n	402eb4 <dir_next+0x10>
		return FR_NO_FILE;

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
  402ec0:	f015 070f 	ands.w	r7, r5, #15
  402ec4:	d008      	beq.n	402ed8 <dir_next+0x34>
  402ec6:	6800      	ldr	r0, [r0, #0]
			}
		}
	}

	dj->index = i;
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
  402ec8:	eb00 1347 	add.w	r3, r0, r7, lsl #5
  402ecc:	3330      	adds	r3, #48	; 0x30
  402ece:	6163      	str	r3, [r4, #20]
				dj->sect = clust2sect(dj->fs, clst);
			}
		}
	}

	dj->index = i;
  402ed0:	80e5      	strh	r5, [r4, #6]
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;

	return FR_OK;
  402ed2:	2000      	movs	r0, #0
  402ed4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return FR_NO_FILE;

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
		dj->sect++;					/* Next sector */

		if (dj->clust == 0) {	/* Static table */
  402ed8:	68c1      	ldr	r1, [r0, #12]
	i = dj->index + 1;
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
		return FR_NO_FILE;

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
		dj->sect++;					/* Next sector */
  402eda:	3301      	adds	r3, #1
  402edc:	6103      	str	r3, [r0, #16]

		if (dj->clust == 0) {	/* Static table */
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
  402ede:	6800      	ldr	r0, [r0, #0]
		return FR_NO_FILE;

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
		dj->sect++;					/* Next sector */

		if (dj->clust == 0) {	/* Static table */
  402ee0:	b161      	cbz	r1, 402efc <dir_next+0x58>
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
  402ee2:	7882      	ldrb	r2, [r0, #2]
  402ee4:	3a01      	subs	r2, #1
  402ee6:	ea12 1215 	ands.w	r2, r2, r5, lsr #4
  402eea:	d1ed      	bne.n	402ec8 <dir_next+0x24>
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  402eec:	2901      	cmp	r1, #1
  402eee:	d902      	bls.n	402ef6 <dir_next+0x52>
  402ef0:	6982      	ldr	r2, [r0, #24]
  402ef2:	4291      	cmp	r1, r2
  402ef4:	d306      	bcc.n	402f04 <dir_next+0x60>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
				if (clst <= 1) return FR_INT_ERR;
  402ef6:	2002      	movs	r0, #2
  402ef8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
		dj->sect++;					/* Next sector */

		if (dj->clust == 0) {	/* Static table */
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
  402efc:	8902      	ldrh	r2, [r0, #8]
  402efe:	42aa      	cmp	r2, r5
  402f00:	d9d8      	bls.n	402eb4 <dir_next+0x10>
  402f02:	e7e1      	b.n	402ec8 <dir_next+0x24>
  402f04:	4b34      	ldr	r3, [pc, #208]	; (402fd8 <dir_next+0x134>)
  402f06:	4798      	blx	r3
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
				if (clst <= 1) return FR_INT_ERR;
  402f08:	2801      	cmp	r0, #1
  402f0a:	4680      	mov	r8, r0
  402f0c:	d9f3      	bls.n	402ef6 <dir_next+0x52>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
  402f0e:	f1b0 3fff 	cmp.w	r0, #4294967295
  402f12:	d01c      	beq.n	402f4e <dir_next+0xaa>
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
  402f14:	6820      	ldr	r0, [r4, #0]
  402f16:	6982      	ldr	r2, [r0, #24]
  402f18:	4542      	cmp	r2, r8
  402f1a:	d90e      	bls.n	402f3a <dir_next+0x96>
  402f1c:	f1a8 0602 	sub.w	r6, r8, #2
					dj->fs->winsect -= c;						/* Rewind window address */
#else
					return FR_NO_FILE;			/* Report EOT */
#endif
				}
				dj->clust = clst;				/* Initialize data for new cluster */
  402f20:	f8c4 800c 	str.w	r8, [r4, #12]
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  402f24:	6982      	ldr	r2, [r0, #24]
  402f26:	3a02      	subs	r2, #2
  402f28:	4296      	cmp	r6, r2
	return clst * fs->csize + fs->database;
  402f2a:	bf3b      	ittet	cc
  402f2c:	7881      	ldrbcc	r1, [r0, #2]
  402f2e:	6a82      	ldrcc	r2, [r0, #40]	; 0x28
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  402f30:	2600      	movcs	r6, #0
	return clst * fs->csize + fs->database;
  402f32:	fb01 2606 	mlacc	r6, r1, r6, r2
#else
					return FR_NO_FILE;			/* Report EOT */
#endif
				}
				dj->clust = clst;				/* Initialize data for new cluster */
				dj->sect = clust2sect(dj->fs, clst);
  402f36:	6126      	str	r6, [r4, #16]
  402f38:	e7c6      	b.n	402ec8 <dir_next+0x24>
				if (clst <= 1) return FR_INT_ERR;
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
#if !_FS_READONLY
					BYTE c;
					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
  402f3a:	2e00      	cmp	r6, #0
  402f3c:	d0ba      	beq.n	402eb4 <dir_next+0x10>
					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
  402f3e:	68e1      	ldr	r1, [r4, #12]
  402f40:	4b26      	ldr	r3, [pc, #152]	; (402fdc <dir_next+0x138>)
  402f42:	4798      	blx	r3
					if (clst == 0) return FR_DENIED;			/* No free cluster */
  402f44:	4680      	mov	r8, r0
  402f46:	b928      	cbnz	r0, 402f54 <dir_next+0xb0>
  402f48:	2007      	movs	r0, #7

	dj->index = i;
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;

	return FR_OK;
}
  402f4a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
				if (clst <= 1) return FR_INT_ERR;
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
  402f4e:	2001      	movs	r0, #1
  402f50:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
#if !_FS_READONLY
					BYTE c;
					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
					if (clst == 0) return FR_DENIED;			/* No free cluster */
					if (clst == 1) return FR_INT_ERR;
  402f54:	2801      	cmp	r0, #1
  402f56:	d0ce      	beq.n	402ef6 <dir_next+0x52>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
  402f58:	f1b0 3fff 	cmp.w	r0, #4294967295
  402f5c:	d0f7      	beq.n	402f4e <dir_next+0xaa>
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
  402f5e:	6820      	ldr	r0, [r4, #0]
  402f60:	f8df 907c 	ldr.w	r9, [pc, #124]	; 402fe0 <dir_next+0x13c>
  402f64:	2100      	movs	r1, #0
  402f66:	47c8      	blx	r9
  402f68:	2800      	cmp	r0, #0
  402f6a:	d1f0      	bne.n	402f4e <dir_next+0xaa>
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
  402f6c:	6822      	ldr	r2, [r4, #0]
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
  402f6e:	4601      	mov	r1, r0
					if (clst == 0) return FR_DENIED;			/* No free cluster */
					if (clst == 1) return FR_INT_ERR;
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
  402f70:	f102 0330 	add.w	r3, r2, #48	; 0x30
  402f74:	f502 720c 	add.w	r2, r2, #560	; 0x230
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
  402f78:	f803 1b01 	strb.w	r1, [r3], #1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
  402f7c:	4293      	cmp	r3, r2
  402f7e:	d1fb      	bne.n	402f78 <dir_next+0xd4>
					if (clst == 1) return FR_INT_ERR;
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
  402f80:	6823      	ldr	r3, [r4, #0]
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  402f82:	699a      	ldr	r2, [r3, #24]
static DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
  402f84:	f1a8 0602 	sub.w	r6, r8, #2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  402f88:	3a02      	subs	r2, #2
  402f8a:	4296      	cmp	r6, r2
	return clst * fs->csize + fs->database;
  402f8c:	bf3b      	ittet	cc
  402f8e:	6a9a      	ldrcc	r2, [r3, #40]	; 0x28
  402f90:	7899      	ldrbcc	r1, [r3, #2]
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  402f92:	2200      	movcs	r2, #0
	return clst * fs->csize + fs->database;
  402f94:	fb01 2206 	mlacc	r2, r1, r6, r2
					if (clst == 1) return FR_INT_ERR;
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
  402f98:	62da      	str	r2, [r3, #44]	; 0x2c
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
  402f9a:	f04f 0a00 	mov.w	sl, #0
						dj->fs->wflag = 1;
  402f9e:	f04f 0b01 	mov.w	fp, #1
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
  402fa2:	e00b      	b.n	402fbc <dir_next+0x118>
						dj->fs->wflag = 1;
  402fa4:	f883 b004 	strb.w	fp, [r3, #4]
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
  402fa8:	6820      	ldr	r0, [r4, #0]
  402faa:	47c8      	blx	r9
  402fac:	f10a 0a01 	add.w	sl, sl, #1
  402fb0:	2800      	cmp	r0, #0
  402fb2:	d1cc      	bne.n	402f4e <dir_next+0xaa>
						dj->fs->winsect++;
  402fb4:	6823      	ldr	r3, [r4, #0]
  402fb6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  402fb8:	3201      	adds	r2, #1
  402fba:	62da      	str	r2, [r3, #44]	; 0x2c
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
  402fbc:	6823      	ldr	r3, [r4, #0]
  402fbe:	7898      	ldrb	r0, [r3, #2]
  402fc0:	fa5f f28a 	uxtb.w	r2, sl
  402fc4:	4290      	cmp	r0, r2
						dj->fs->wflag = 1;
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
  402fc6:	f04f 0100 	mov.w	r1, #0
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
  402fca:	d8eb      	bhi.n	402fa4 <dir_next+0x100>
						dj->fs->wflag = 1;
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
						dj->fs->winsect++;
					}
					dj->fs->winsect -= c;						/* Rewind window address */
  402fcc:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
  402fce:	1a8a      	subs	r2, r1, r2
  402fd0:	62da      	str	r2, [r3, #44]	; 0x2c
  402fd2:	6820      	ldr	r0, [r4, #0]
  402fd4:	e7a4      	b.n	402f20 <dir_next+0x7c>
  402fd6:	bf00      	nop
  402fd8:	00402b59 	.word	0x00402b59
  402fdc:	00402dcd 	.word	0x00402dcd
  402fe0:	00402619 	.word	0x00402619

00402fe4 <dir_find.part.5>:
/*-----------------------------------------------------------------------*/
/* Directory handling - Find an object in the directory                  */
/*-----------------------------------------------------------------------*/

static
FRESULT dir_find (
  402fe4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  402fe8:	f04f 08ff 	mov.w	r8, #255	; 0xff
  402fec:	b085      	sub	sp, #20
  402fee:	4f52      	ldr	r7, [pc, #328]	; (403138 <dir_find.part.5+0x154>)
  402ff0:	f8df 914c 	ldr.w	r9, [pc, #332]	; 403140 <dir_find.part.5+0x15c>
	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
		if (wc) {	/* Last char has not been processed */
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
  402ff4:	f8df a14c 	ldr.w	sl, [pc, #332]	; 403144 <dir_find.part.5+0x160>
/*-----------------------------------------------------------------------*/
/* Directory handling - Find an object in the directory                  */
/*-----------------------------------------------------------------------*/

static
FRESULT dir_find (
  402ff8:	4605      	mov	r5, r0
  402ffa:	4646      	mov	r6, r8
  402ffc:	e008      	b.n	403010 <dir_find.part.5+0x2c>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
  402ffe:	290f      	cmp	r1, #15
  403000:	d03e      	beq.n	403080 <dir_find.part.5+0x9c>
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
  403002:	26ff      	movs	r6, #255	; 0xff
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
			break;
#endif
		res = dir_next(dj, 0);		/* Next entry */
  403004:	4628      	mov	r0, r5
  403006:	2100      	movs	r1, #0
  403008:	4b4c      	ldr	r3, [pc, #304]	; (40313c <dir_find.part.5+0x158>)
  40300a:	4798      	blx	r3
	} while (res == FR_OK);
  40300c:	2800      	cmp	r0, #0
  40300e:	d134      	bne.n	40307a <dir_find.part.5+0x96>

#if _USE_LFN
	ord = sum = 0xFF;
#endif
	do {
		res = move_window(dj->fs, dj->sect);
  403010:	6828      	ldr	r0, [r5, #0]
  403012:	6929      	ldr	r1, [r5, #16]
  403014:	47b8      	blx	r7
		if (res != FR_OK) break;
  403016:	bb80      	cbnz	r0, 40307a <dir_find.part.5+0x96>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
  403018:	696c      	ldr	r4, [r5, #20]
		c = dir[DIR_Name];
  40301a:	7822      	ldrb	r2, [r4, #0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
  40301c:	2a00      	cmp	r2, #0
  40301e:	d078      	beq.n	403112 <dir_find.part.5+0x12e>
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
  403020:	7ae3      	ldrb	r3, [r4, #11]
		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
  403022:	2ae5      	cmp	r2, #229	; 0xe5
		if (res != FR_OK) break;
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
  403024:	f003 013f 	and.w	r1, r3, #63	; 0x3f
		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
  403028:	d0eb      	beq.n	403002 <dir_find.part.5+0x1e>
  40302a:	071b      	lsls	r3, r3, #28
  40302c:	d4e7      	bmi.n	402ffe <dir_find.part.5+0x1a>
			ord = 0xFF;
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
  40302e:	290f      	cmp	r1, #15
  403030:	d026      	beq.n	403080 <dir_find.part.5+0x9c>
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
  403032:	b98e      	cbnz	r6, 403058 <dir_find.part.5+0x74>
  403034:	4694      	mov	ip, r2
  403036:	f104 060a 	add.w	r6, r4, #10
  40303a:	4622      	mov	r2, r4
  40303c:	4603      	mov	r3, r0
  40303e:	e001      	b.n	403044 <dir_find.part.5+0x60>
  403040:	f812 cf01 	ldrb.w	ip, [r2, #1]!
)
{
	BYTE sum = 0;
	UINT n = 11;

	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
  403044:	01d9      	lsls	r1, r3, #7
  403046:	ea41 0353 	orr.w	r3, r1, r3, lsr #1
  40304a:	fa5c f383 	uxtab	r3, ip, r3
  40304e:	42b2      	cmp	r2, r6
  403050:	b2db      	uxtb	r3, r3
  403052:	d1f5      	bne.n	403040 <dir_find.part.5+0x5c>
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
  403054:	4543      	cmp	r3, r8
  403056:	d010      	beq.n	40307a <dir_find.part.5+0x96>
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
  403058:	f64f 72ff 	movw	r2, #65535	; 0xffff
				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
  40305c:	69ab      	ldr	r3, [r5, #24]
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
  40305e:	842a      	strh	r2, [r5, #32]
				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
  403060:	7ada      	ldrb	r2, [r3, #11]
  403062:	07d2      	lsls	r2, r2, #31
  403064:	d4cd      	bmi.n	403002 <dir_find.part.5+0x1e>
  403066:	f104 060b 	add.w	r6, r4, #11
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
	int r = 0;

	while (cnt-- && (r = *d++ - *s++) == 0) ;
  40306a:	f814 1b01 	ldrb.w	r1, [r4], #1
  40306e:	f813 2b01 	ldrb.w	r2, [r3], #1
  403072:	4291      	cmp	r1, r2
  403074:	d1c5      	bne.n	403002 <dir_find.part.5+0x1e>
  403076:	42b4      	cmp	r4, r6
  403078:	d1f7      	bne.n	40306a <dir_find.part.5+0x86>
#endif
		res = dir_next(dj, 0);		/* Next entry */
	} while (res == FR_OK);

	return res;
}
  40307a:	b005      	add	sp, #20
  40307c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		a = dir[DIR_Attr] & AM_MASK;
		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
			ord = 0xFF;
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
				if (dj->lfn) {
  403080:	69eb      	ldr	r3, [r5, #28]
  403082:	2b00      	cmp	r3, #0
  403084:	d0be      	beq.n	403004 <dir_find.part.5+0x20>
					if (c & LLE) {		/* Is it start of LFN sequence? */
  403086:	0651      	lsls	r1, r2, #25
  403088:	d53f      	bpl.n	40310a <dir_find.part.5+0x126>
						sum = dir[LDIR_Chksum];
						c &= ~LLE; ord = c;	/* LFN start order */
						dj->lfn_idx = dj->index;
  40308a:	88e9      	ldrh	r1, [r5, #6]
			ord = 0xFF;
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
				if (dj->lfn) {
					if (c & LLE) {		/* Is it start of LFN sequence? */
						sum = dir[LDIR_Chksum];
  40308c:	f894 800d 	ldrb.w	r8, [r4, #13]
						c &= ~LLE; ord = c;	/* LFN start order */
						dj->lfn_idx = dj->index;
  403090:	8429      	strh	r1, [r5, #32]
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
				if (dj->lfn) {
					if (c & LLE) {		/* Is it start of LFN sequence? */
						sum = dir[LDIR_Chksum];
						c &= ~LLE; ord = c;	/* LFN start order */
  403092:	f002 06bf 	and.w	r6, r2, #191	; 0xbf
						dj->lfn_idx = dj->index;
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
  403096:	7b61      	ldrb	r1, [r4, #13]
  403098:	4541      	cmp	r1, r8
  40309a:	d1b2      	bne.n	403002 <dir_find.part.5+0x1e>
{
	UINT i, s;
	WCHAR wc, uc;


	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
  40309c:	7822      	ldrb	r2, [r4, #0]
  40309e:	f8df b0a8 	ldr.w	fp, [pc, #168]	; 403148 <dir_find.part.5+0x164>
  4030a2:	f022 0240 	bic.w	r2, r2, #64	; 0x40
  4030a6:	3a01      	subs	r2, #1
  4030a8:	eb02 0c42 	add.w	ip, r2, r2, lsl #1
  4030ac:	eb02 0c8c 	add.w	ip, r2, ip, lsl #2
		if (wc) {	/* Last char has not been processed */
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
				return 0;				/* Not matched */
		} else {
			if (uc != 0xFFFF) return 0;	/* Check filler */
  4030b0:	f64f 78ff 	movw	r8, #65535	; 0xffff
	UINT i, s;
	WCHAR wc, uc;


	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
	s = 0; wc = 1;
  4030b4:	2201      	movs	r2, #1
  4030b6:	e003      	b.n	4030c0 <dir_find.part.5+0xdc>
		if (wc) {	/* Last char has not been processed */
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
				return 0;				/* Not matched */
		} else {
			if (uc != 0xFFFF) return 0;	/* Check filler */
  4030b8:	4540      	cmp	r0, r8
  4030ba:	d135      	bne.n	403128 <dir_find.part.5+0x144>
		}
	} while (++s < 13);				/* Repeat until all chars in the entry are checked */
  4030bc:	45cb      	cmp	fp, r9
  4030be:	d02c      	beq.n	40311a <dir_find.part.5+0x136>


	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
  4030c0:	f81b 0f01 	ldrb.w	r0, [fp, #1]!
  4030c4:	eb04 0e00 	add.w	lr, r4, r0
  4030c8:	5c20      	ldrb	r0, [r4, r0]
  4030ca:	f89e e001 	ldrb.w	lr, [lr, #1]
  4030ce:	ea40 200e 	orr.w	r0, r0, lr, lsl #8
		if (wc) {	/* Last char has not been processed */
  4030d2:	2a00      	cmp	r2, #0
  4030d4:	d0f0      	beq.n	4030b8 <dir_find.part.5+0xd4>
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
  4030d6:	f10c 0201 	add.w	r2, ip, #1
	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
		if (wc) {	/* Last char has not been processed */
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
  4030da:	e88d 100a 	stmia.w	sp, {r1, r3, ip}
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
  4030de:	9203      	str	r2, [sp, #12]
	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
		if (wc) {	/* Last char has not been processed */
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
  4030e0:	47d0      	blx	sl
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
  4030e2:	f8dd c008 	ldr.w	ip, [sp, #8]
  4030e6:	f1bc 0ffe 	cmp.w	ip, #254	; 0xfe
	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
		if (wc) {	/* Last char has not been processed */
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
  4030ea:	4602      	mov	r2, r0
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
  4030ec:	e89d 000a 	ldmia.w	sp, {r1, r3}
  4030f0:	d81a      	bhi.n	403128 <dir_find.part.5+0x144>
  4030f2:	f833 001c 	ldrh.w	r0, [r3, ip, lsl #1]
  4030f6:	9202      	str	r2, [sp, #8]
  4030f8:	47d0      	blx	sl
  4030fa:	9a02      	ldr	r2, [sp, #8]
  4030fc:	4282      	cmp	r2, r0
  4030fe:	e89d 000a 	ldmia.w	sp, {r1, r3}
  403102:	d111      	bne.n	403128 <dir_find.part.5+0x144>
  403104:	f8dd c00c 	ldr.w	ip, [sp, #12]
  403108:	e7d8      	b.n	4030bc <dir_find.part.5+0xd8>
						sum = dir[LDIR_Chksum];
						c &= ~LLE; ord = c;	/* LFN start order */
						dj->lfn_idx = dj->index;
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
  40310a:	42b2      	cmp	r2, r6
  40310c:	f47f af79 	bne.w	403002 <dir_find.part.5+0x1e>
  403110:	e7c1      	b.n	403096 <dir_find.part.5+0xb2>
	do {
		res = move_window(dj->fs, dj->sect);
		if (res != FR_OK) break;
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
  403112:	2004      	movs	r0, #4
#endif
		res = dir_next(dj, 0);		/* Next entry */
	} while (res == FR_OK);

	return res;
}
  403114:	b005      	add	sp, #20
  403116:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		} else {
			if (uc != 0xFFFF) return 0;	/* Check filler */
		}
	} while (++s < 13);				/* Repeat until all chars in the entry are checked */

	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i])	/* Last segment matched but different length */
  40311a:	7820      	ldrb	r0, [r4, #0]
  40311c:	0640      	lsls	r0, r0, #25
  40311e:	d506      	bpl.n	40312e <dir_find.part.5+0x14a>
  403120:	b12a      	cbz	r2, 40312e <dir_find.part.5+0x14a>
  403122:	f833 301c 	ldrh.w	r3, [r3, ip, lsl #1]
  403126:	b113      	cbz	r3, 40312e <dir_find.part.5+0x14a>
						sum = dir[LDIR_Chksum];
						c &= ~LLE; ord = c;	/* LFN start order */
						dj->lfn_idx = dj->index;
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
  403128:	4688      	mov	r8, r1
  40312a:	26ff      	movs	r6, #255	; 0xff
  40312c:	e76a      	b.n	403004 <dir_find.part.5+0x20>
  40312e:	3e01      	subs	r6, #1
  403130:	b2f6      	uxtb	r6, r6
  403132:	4688      	mov	r8, r1
  403134:	e766      	b.n	403004 <dir_find.part.5+0x20>
  403136:	bf00      	nop
  403138:	00402619 	.word	0x00402619
  40313c:	00402ea5 	.word	0x00402ea5
  403140:	00406be0 	.word	0x00406be0
  403144:	00403d85 	.word	0x00403d85
  403148:	00406bd3 	.word	0x00406bd3

0040314c <dir_register>:
#if !_FS_READONLY
static
FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
	DIR *dj				/* Target directory with object name to be created */
)
{
  40314c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	WORD n, ne, is;
	BYTE sn[12], *fn, sum;
	WCHAR *lfn;


	fn = dj->fn; lfn = dj->lfn;
  403150:	f8d0 a018 	ldr.w	sl, [r0, #24]
  403154:	69c5      	ldr	r5, [r0, #28]
#if !_FS_READONLY
static
FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
	DIR *dj				/* Target directory with object name to be created */
)
{
  403156:	b089      	sub	sp, #36	; 0x24
  403158:	f10a 36ff 	add.w	r6, sl, #4294967295
  40315c:	4604      	mov	r4, r0
	WORD n, ne, is;
	BYTE sn[12], *fn, sum;
	WCHAR *lfn;


	fn = dj->fn; lfn = dj->lfn;
  40315e:	4632      	mov	r2, r6
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
	BYTE *d = (BYTE*)dst;
  403160:	ab05      	add	r3, sp, #20
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
  403162:	f812 1f01 	ldrb.w	r1, [r2, #1]!
  403166:	f803 1b01 	strb.w	r1, [r3], #1
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
  40316a:	a908      	add	r1, sp, #32
  40316c:	428b      	cmp	r3, r1
  40316e:	d1f8      	bne.n	403162 <dir_register+0x16>
	mem_cpy(sn, fn, 12);

	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
		return FR_INVALID_NAME;

	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
  403170:	f89d 301f 	ldrb.w	r3, [sp, #31]
  403174:	9301      	str	r3, [sp, #4]
  403176:	07da      	lsls	r2, r3, #31
  403178:	d456      	bmi.n	403228 <dir_register+0xdc>
  40317a:	4fb1      	ldr	r7, [pc, #708]	; (403440 <dir_register+0x2f4>)
		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
		fn[NS] = sn[NS]; dj->lfn = lfn;
	}

	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, reserve an SFN + LFN entries. */
  40317c:	9b01      	ldr	r3, [sp, #4]
  40317e:	079b      	lsls	r3, r3, #30
  403180:	f100 80c2 	bmi.w	403308 <dir_register+0x1bc>
		for (ne = 0; lfn[ne]; ne++) ;
		ne = (ne + 25) / 13;
	} else {						/* Otherwise reserve only an SFN entry. */
		ne = 1;
  403184:	f04f 0901 	mov.w	r9, #1
	}

	/* Reserve contiguous entries */
	res = dir_sdi(dj, 0);
  403188:	4620      	mov	r0, r4
  40318a:	2100      	movs	r1, #0
  40318c:	47b8      	blx	r7
	if (res != FR_OK) return res;
  40318e:	2800      	cmp	r0, #0
  403190:	d147      	bne.n	403222 <dir_register+0xd6>
  403192:	4682      	mov	sl, r0
  403194:	4eab      	ldr	r6, [pc, #684]	; (403444 <dir_register+0x2f8>)
			if (n == 0) is = dj->index;	/* First index of the contiguous entry */
			if (++n == ne) break;	/* A contiguous entry that required count is found */
		} else {
			n = 0;					/* Not a blank entry. Restart to search */
		}
		res = dir_next(dj, 1);		/* Next entry with table stretch */
  403196:	f8df 82b4 	ldr.w	r8, [pc, #692]	; 40344c <dir_register+0x300>
		ne = 1;
	}

	/* Reserve contiguous entries */
	res = dir_sdi(dj, 0);
	if (res != FR_OK) return res;
  40319a:	4605      	mov	r5, r0
  40319c:	e005      	b.n	4031aa <dir_register+0x5e>
		c = *dj->dir;				/* Check the entry status */
		if (c == DDE || c == 0) {	/* Is it a blank entry? */
			if (n == 0) is = dj->index;	/* First index of the contiguous entry */
			if (++n == ne) break;	/* A contiguous entry that required count is found */
		} else {
			n = 0;					/* Not a blank entry. Restart to search */
  40319e:	461d      	mov	r5, r3
		}
		res = dir_next(dj, 1);		/* Next entry with table stretch */
  4031a0:	47c0      	blx	r8
	} while (res == FR_OK);
  4031a2:	4603      	mov	r3, r0
  4031a4:	2800      	cmp	r0, #0
  4031a6:	f040 80ce 	bne.w	403346 <dir_register+0x1fa>
	/* Reserve contiguous entries */
	res = dir_sdi(dj, 0);
	if (res != FR_OK) return res;
	n = is = 0;
	do {
		res = move_window(dj->fs, dj->sect);
  4031aa:	6921      	ldr	r1, [r4, #16]
  4031ac:	6820      	ldr	r0, [r4, #0]
  4031ae:	47b0      	blx	r6
		if (res != FR_OK) break;
  4031b0:	4603      	mov	r3, r0
		c = *dj->dir;				/* Check the entry status */
		if (c == DDE || c == 0) {	/* Is it a blank entry? */
			if (n == 0) is = dj->index;	/* First index of the contiguous entry */
			if (++n == ne) break;	/* A contiguous entry that required count is found */
  4031b2:	f105 0c01 	add.w	ip, r5, #1
		} else {
			n = 0;					/* Not a blank entry. Restart to search */
		}
		res = dir_next(dj, 1);		/* Next entry with table stretch */
  4031b6:	4620      	mov	r0, r4
  4031b8:	2101      	movs	r1, #1
	res = dir_sdi(dj, 0);
	if (res != FR_OK) return res;
	n = is = 0;
	do {
		res = move_window(dj->fs, dj->sect);
		if (res != FR_OK) break;
  4031ba:	2b00      	cmp	r3, #0
  4031bc:	f040 80c3 	bne.w	403346 <dir_register+0x1fa>
		c = *dj->dir;				/* Check the entry status */
  4031c0:	6962      	ldr	r2, [r4, #20]
  4031c2:	7812      	ldrb	r2, [r2, #0]
		if (c == DDE || c == 0) {	/* Is it a blank entry? */
  4031c4:	2ae5      	cmp	r2, #229	; 0xe5
  4031c6:	d001      	beq.n	4031cc <dir_register+0x80>
  4031c8:	2a00      	cmp	r2, #0
  4031ca:	d1e8      	bne.n	40319e <dir_register+0x52>
			if (n == 0) is = dj->index;	/* First index of the contiguous entry */
  4031cc:	b90d      	cbnz	r5, 4031d2 <dir_register+0x86>
  4031ce:	f8b4 a006 	ldrh.w	sl, [r4, #6]
			if (++n == ne) break;	/* A contiguous entry that required count is found */
  4031d2:	fa1f f58c 	uxth.w	r5, ip
  4031d6:	454d      	cmp	r5, r9
  4031d8:	d1e2      	bne.n	4031a0 <dir_register+0x54>
			n = 0;					/* Not a blank entry. Restart to search */
		}
		res = dir_next(dj, 1);		/* Next entry with table stretch */
	} while (res == FR_OK);

	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
  4031da:	f1b9 0f01 	cmp.w	r9, #1
  4031de:	f040 80b6 	bne.w	40334e <dir_register+0x202>
		} while (res == FR_OK);
	}
#endif

	if (res == FR_OK) {		/* Initialize the SFN entry */
		res = move_window(dj->fs, dj->sect);
  4031e2:	6820      	ldr	r0, [r4, #0]
  4031e4:	6921      	ldr	r1, [r4, #16]
  4031e6:	47b0      	blx	r6
		if (res == FR_OK) {
  4031e8:	b9d8      	cbnz	r0, 403222 <dir_register+0xd6>
			dir = dj->dir;
  4031ea:	6965      	ldr	r5, [r4, #20]
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
  4031ec:	4601      	mov	r1, r0
  4031ee:	f105 0220 	add.w	r2, r5, #32
}

/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;
  4031f2:	462b      	mov	r3, r5

	while (cnt--)
		*d++ = (BYTE)val;
  4031f4:	f803 1b01 	strb.w	r1, [r3], #1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
  4031f8:	4293      	cmp	r3, r2
  4031fa:	d1fb      	bne.n	4031f4 <dir_register+0xa8>
	if (res == FR_OK) {		/* Initialize the SFN entry */
		res = move_window(dj->fs, dj->sect);
		if (res == FR_OK) {
			dir = dj->dir;
			mem_set(dir, 0, SZ_DIR);	/* Clean the entry */
			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
  4031fc:	69a2      	ldr	r2, [r4, #24]
  4031fe:	f105 000b 	add.w	r0, r5, #11
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
	BYTE *d = (BYTE*)dst;
  403202:	462b      	mov	r3, r5
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
  403204:	f812 1b01 	ldrb.w	r1, [r2], #1
  403208:	f803 1b01 	strb.w	r1, [r3], #1
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
  40320c:	4283      	cmp	r3, r0
  40320e:	d1f9      	bne.n	403204 <dir_register+0xb8>
		if (res == FR_OK) {
			dir = dj->dir;
			mem_set(dir, 0, SZ_DIR);	/* Clean the entry */
			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
#if _USE_LFN
			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
  403210:	69a3      	ldr	r3, [r4, #24]
  403212:	7adb      	ldrb	r3, [r3, #11]
  403214:	f003 0318 	and.w	r3, r3, #24
  403218:	732b      	strb	r3, [r5, #12]
#endif
			dj->fs->wflag = 1;
  40321a:	6823      	ldr	r3, [r4, #0]
  40321c:	2201      	movs	r2, #1
  40321e:	711a      	strb	r2, [r3, #4]
  403220:	2000      	movs	r0, #0
		}
	}

	return res;
}
  403222:	b009      	add	sp, #36	; 0x24
  403224:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
		return FR_INVALID_NAME;

	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
  403228:	2300      	movs	r3, #0
  40322a:	4f85      	ldr	r7, [pc, #532]	; (403440 <dir_register+0x2f4>)
  40322c:	f8df 8220 	ldr.w	r8, [pc, #544]	; 403450 <dir_register+0x304>
  403230:	f88a 300b 	strb.w	r3, [sl, #11]
		for (n = 1; n < 100; n++) {
  403234:	f04f 0901 	mov.w	r9, #1

	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
		return FR_INVALID_NAME;

	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
  403238:	61e3      	str	r3, [r4, #28]
  40323a:	f10d 0b1f 	add.w	fp, sp, #31
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
	BYTE *d = (BYTE*)dst;
  40323e:	4632      	mov	r2, r6
  403240:	ab05      	add	r3, sp, #20
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
  403242:	f813 1b01 	ldrb.w	r1, [r3], #1
  403246:	f802 1f01 	strb.w	r1, [r2, #1]!
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
  40324a:	455b      	cmp	r3, fp
  40324c:	d1f9      	bne.n	403242 <dir_register+0xf6>
	UINT i, j;


	mem_cpy(dst, src, 11);

	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
  40324e:	f1b9 0f05 	cmp.w	r9, #5
  403252:	d957      	bls.n	403304 <dir_register+0x1b8>
  403254:	8828      	ldrh	r0, [r5, #0]
  403256:	4629      	mov	r1, r5
  403258:	464a      	mov	r2, r9
  40325a:	e000      	b.n	40325e <dir_register+0x112>
		do seq = (seq >> 1) + (seq << 15) + (WORD)*lfn++; while (*lfn);
  40325c:	4618      	mov	r0, r3
  40325e:	03d3      	lsls	r3, r2, #15
  403260:	ea43 0252 	orr.w	r2, r3, r2, lsr #1
  403264:	f831 3f02 	ldrh.w	r3, [r1, #2]!
  403268:	fa10 f282 	uxtah	r2, r0, r2
  40326c:	b292      	uxth	r2, r2
  40326e:	2b00      	cmp	r3, #0
  403270:	d1f4      	bne.n	40325c <dir_register+0x110>
	UINT i, j;


	mem_cpy(dst, src, 11);

	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
  403272:	2307      	movs	r3, #7
	}

	/* itoa (hexdecimal) */
	i = 7;
	do {
		c = (seq % 16) + '0';
  403274:	f002 000f 	and.w	r0, r2, #15
  403278:	f100 0130 	add.w	r1, r0, #48	; 0x30
		if (c > '9') c += 7;
  40327c:	2939      	cmp	r1, #57	; 0x39
  40327e:	bf88      	it	hi
  403280:	f100 0137 	addhi.w	r1, r0, #55	; 0x37
		ns[i--] = c;
  403284:	3b01      	subs	r3, #1
  403286:	a803      	add	r0, sp, #12
  403288:	4418      	add	r0, r3
		seq /= 16;
  40328a:	f3c2 120f 	ubfx	r2, r2, #4, #16
	/* itoa (hexdecimal) */
	i = 7;
	do {
		c = (seq % 16) + '0';
		if (c > '9') c += 7;
		ns[i--] = c;
  40328e:	7041      	strb	r1, [r0, #1]
		seq /= 16;
	} while (seq);
  403290:	2a00      	cmp	r2, #0
  403292:	d1ef      	bne.n	403274 <dir_register+0x128>
	ns[i] = '~';
  403294:	a908      	add	r1, sp, #32
  403296:	4419      	add	r1, r3
  403298:	207e      	movs	r0, #126	; 0x7e
  40329a:	f801 0c14 	strb.w	r0, [r1, #-20]

	/* Append the number */
	for (j = 0; j < i && dst[j] != ' '; j++) {
  40329e:	2b00      	cmp	r3, #0
  4032a0:	d04f      	beq.n	403342 <dir_register+0x1f6>
  4032a2:	f89a 1000 	ldrb.w	r1, [sl]
  4032a6:	2920      	cmp	r1, #32
  4032a8:	d014      	beq.n	4032d4 <dir_register+0x188>
  4032aa:	4651      	mov	r1, sl
  4032ac:	e003      	b.n	4032b6 <dir_register+0x16a>
  4032ae:	f811 0f01 	ldrb.w	r0, [r1, #1]!
  4032b2:	2820      	cmp	r0, #32
  4032b4:	d00e      	beq.n	4032d4 <dir_register+0x188>
  4032b6:	3201      	adds	r2, #1
  4032b8:	429a      	cmp	r2, r3
  4032ba:	d1f8      	bne.n	4032ae <dir_register+0x162>
			if (j == i - 1) break;
			j++;
		}
	}
	do {
		dst[j++] = (i < 8) ? ns[i++] : ' ';
  4032bc:	2b07      	cmp	r3, #7
  4032be:	d80b      	bhi.n	4032d8 <dir_register+0x18c>
  4032c0:	a908      	add	r1, sp, #32
  4032c2:	4419      	add	r1, r3
  4032c4:	3301      	adds	r3, #1
  4032c6:	f811 1c14 	ldrb.w	r1, [r1, #-20]
  4032ca:	f80a 1002 	strb.w	r1, [sl, r2]
  4032ce:	3201      	adds	r2, #1
	} while (j < 8);
  4032d0:	2a07      	cmp	r2, #7
  4032d2:	d807      	bhi.n	4032e4 <dir_register+0x198>
			if (j == i - 1) break;
			j++;
		}
	}
	do {
		dst[j++] = (i < 8) ? ns[i++] : ' ';
  4032d4:	2b07      	cmp	r3, #7
  4032d6:	d9f3      	bls.n	4032c0 <dir_register+0x174>
  4032d8:	2120      	movs	r1, #32
  4032da:	f80a 1002 	strb.w	r1, [sl, r2]
  4032de:	3201      	adds	r2, #1
	} while (j < 8);
  4032e0:	2a07      	cmp	r2, #7
  4032e2:	d9f7      	bls.n	4032d4 <dir_register+0x188>
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dj, 0);			/* Rewind directory object */
  4032e4:	4620      	mov	r0, r4
  4032e6:	2100      	movs	r1, #0
  4032e8:	47b8      	blx	r7
	if (res != FR_OK) return res;
  4032ea:	bb10      	cbnz	r0, 403332 <dir_register+0x1e6>
  4032ec:	4620      	mov	r0, r4
  4032ee:	47c0      	blx	r8
	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
		for (n = 1; n < 100; n++) {
			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
			res = dir_find(dj);				/* Check if the name collides with existing SFN */
			if (res != FR_OK) break;
  4032f0:	b9f8      	cbnz	r0, 403332 <dir_register+0x1e6>
	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
		return FR_INVALID_NAME;

	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
		for (n = 1; n < 100; n++) {
  4032f2:	f109 0901 	add.w	r9, r9, #1
  4032f6:	fa1f f989 	uxth.w	r9, r9
  4032fa:	f1b9 0f64 	cmp.w	r9, #100	; 0x64
  4032fe:	d19e      	bne.n	40323e <dir_register+0xf2>
			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
			res = dir_find(dj);				/* Check if the name collides with existing SFN */
			if (res != FR_OK) break;
		}
		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
  403300:	2007      	movs	r0, #7
  403302:	e78e      	b.n	403222 <dir_register+0xd6>
	UINT i, j;


	mem_cpy(dst, src, 11);

	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
  403304:	464a      	mov	r2, r9
  403306:	e7b4      	b.n	403272 <dir_register+0x126>
		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
		fn[NS] = sn[NS]; dj->lfn = lfn;
	}

	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, reserve an SFN + LFN entries. */
		for (ne = 0; lfn[ne]; ne++) ;
  403308:	882b      	ldrh	r3, [r5, #0]
  40330a:	2b00      	cmp	r3, #0
  40330c:	f43f af3a 	beq.w	403184 <dir_register+0x38>
  403310:	2300      	movs	r3, #0
  403312:	3301      	adds	r3, #1
  403314:	b29b      	uxth	r3, r3
  403316:	f835 2013 	ldrh.w	r2, [r5, r3, lsl #1]
  40331a:	2a00      	cmp	r2, #0
  40331c:	d1f9      	bne.n	403312 <dir_register+0x1c6>
  40331e:	4a4a      	ldr	r2, [pc, #296]	; (403448 <dir_register+0x2fc>)
  403320:	3319      	adds	r3, #25
  403322:	fb82 1903 	smull	r1, r9, r2, r3
  403326:	17db      	asrs	r3, r3, #31
  403328:	ebc3 09a9 	rsb	r9, r3, r9, asr #2
  40332c:	fa1f f989 	uxth.w	r9, r9
  403330:	e72a      	b.n	403188 <dir_register+0x3c>
			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
			res = dir_find(dj);				/* Check if the name collides with existing SFN */
			if (res != FR_OK) break;
		}
		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
  403332:	2804      	cmp	r0, #4
  403334:	f47f af75 	bne.w	403222 <dir_register+0xd6>
		fn[NS] = sn[NS]; dj->lfn = lfn;
  403338:	9b01      	ldr	r3, [sp, #4]
  40333a:	f88a 300b 	strb.w	r3, [sl, #11]
  40333e:	61e5      	str	r5, [r4, #28]
  403340:	e71c      	b.n	40317c <dir_register+0x30>
		seq /= 16;
	} while (seq);
	ns[i] = '~';

	/* Append the number */
	for (j = 0; j < i && dst[j] != ' '; j++) {
  403342:	461a      	mov	r2, r3
  403344:	e7c6      	b.n	4032d4 <dir_register+0x188>
  403346:	4618      	mov	r0, r3
			dj->fs->wflag = 1;
		}
	}

	return res;
}
  403348:	b009      	add	sp, #36	; 0x24
  40334a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		}
		res = dir_next(dj, 1);		/* Next entry with table stretch */
	} while (res == FR_OK);

	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
		res = dir_sdi(dj, is);
  40334e:	4651      	mov	r1, sl
  403350:	4620      	mov	r0, r4
  403352:	47b8      	blx	r7
		if (res == FR_OK) {
  403354:	4603      	mov	r3, r0
  403356:	2800      	cmp	r0, #0
  403358:	d1f5      	bne.n	403346 <dir_register+0x1fa>
			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
  40335a:	69a2      	ldr	r2, [r4, #24]
static
BYTE sum_sfn (
	const BYTE *dir		/* Ptr to directory entry */
)
{
	BYTE sum = 0;
  40335c:	4683      	mov	fp, r0
  40335e:	f102 000b 	add.w	r0, r2, #11
	UINT n = 11;

	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
  403362:	f812 3b01 	ldrb.w	r3, [r2], #1
  403366:	ea4f 11cb 	mov.w	r1, fp, lsl #7
  40336a:	ea41 0b5b 	orr.w	fp, r1, fp, lsr #1
  40336e:	fa53 fb8b 	uxtab	fp, r3, fp
  403372:	4282      	cmp	r2, r0
  403374:	fa5f fb8b 	uxtb.w	fp, fp
  403378:	d1f3      	bne.n	403362 <dir_register+0x216>

	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
		res = dir_sdi(dj, is);
		if (res == FR_OK) {
			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
			ne--;
  40337a:	f109 39ff 	add.w	r9, r9, #4294967295
  40337e:	fa1f f989 	uxth.w	r9, r9
  403382:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 403454 <dir_register+0x308>
  403386:	f8cd b000 	str.w	fp, [sp]
  40338a:	46cb      	mov	fp, r9
			do {					/* Store LFN entries in bottom first */
				res = move_window(dj->fs, dj->sect);
  40338c:	6820      	ldr	r0, [r4, #0]
  40338e:	6921      	ldr	r1, [r4, #16]
  403390:	47b0      	blx	r6
  403392:	4603      	mov	r3, r0
				if (res != FR_OK) break;
  403394:	2800      	cmp	r0, #0
  403396:	d1d6      	bne.n	403346 <dir_register+0x1fa>
				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
  403398:	fa5f fa8b 	uxtb.w	sl, fp
  40339c:	6965      	ldr	r5, [r4, #20]
{
	UINT i, s;
	WCHAR wc;


	dir[LDIR_Chksum] = sum;			/* Set check sum */
  40339e:	9b00      	ldr	r3, [sp, #0]
			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
			ne--;
			do {					/* Store LFN entries in bottom first */
				res = move_window(dj->fs, dj->sect);
				if (res != FR_OK) break;
				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
  4033a0:	f8d4 901c 	ldr.w	r9, [r4, #28]
{
	UINT i, s;
	WCHAR wc;


	dir[LDIR_Chksum] = sum;			/* Set check sum */
  4033a4:	736b      	strb	r3, [r5, #13]
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
	dir[LDIR_Type] = 0;
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
  4033a6:	f10a 32ff 	add.w	r2, sl, #4294967295
  4033aa:	eb02 0142 	add.w	r1, r2, r2, lsl #1
	UINT i, s;
	WCHAR wc;


	dir[LDIR_Chksum] = sum;			/* Set check sum */
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
  4033ae:	270f      	movs	r7, #15
	dir[LDIR_Type] = 0;
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
  4033b0:	4603      	mov	r3, r0
	dir[LDIR_Chksum] = sum;			/* Set check sum */
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
	dir[LDIR_Type] = 0;
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
  4033b2:	eb02 0181 	add.w	r1, r2, r1, lsl #2
	UINT i, s;
	WCHAR wc;


	dir[LDIR_Chksum] = sum;			/* Set check sum */
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
  4033b6:	72ef      	strb	r7, [r5, #11]
	dir[LDIR_Type] = 0;
  4033b8:	7328      	strb	r0, [r5, #12]
	ST_WORD(dir+LDIR_FstClusLO, 0);
  4033ba:	76a8      	strb	r0, [r5, #26]
  4033bc:	76e8      	strb	r0, [r5, #27]

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
  4033be:	4602      	mov	r2, r0
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
  4033c0:	f64f 77ff 	movw	r7, #65535	; 0xffff
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
  4033c4:	20ff      	movs	r0, #255	; 0xff
  4033c6:	e010      	b.n	4033ea <dir_register+0x29e>
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
  4033c8:	f839 3011 	ldrh.w	r3, [r9, r1, lsl #1]
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
  4033cc:	f805 300e 	strb.w	r3, [r5, lr]
		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
	} while (++s < 13);
  4033d0:	3201      	adds	r2, #1

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
  4033d2:	44ae      	add	lr, r5
  4033d4:	ea4f 2c13 	mov.w	ip, r3, lsr #8
		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
  4033d8:	2b00      	cmp	r3, #0
  4033da:	bf08      	it	eq
  4033dc:	463b      	moveq	r3, r7
	} while (++s < 13);
  4033de:	2a0d      	cmp	r2, #13
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
  4033e0:	f101 0101 	add.w	r1, r1, #1
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
  4033e4:	f88e c001 	strb.w	ip, [lr, #1]
		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
	} while (++s < 13);
  4033e8:	d00c      	beq.n	403404 <dir_register+0x2b8>
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
  4033ea:	42bb      	cmp	r3, r7
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
  4033ec:	f818 e002 	ldrb.w	lr, [r8, r2]
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
  4033f0:	d1ea      	bne.n	4033c8 <dir_register+0x27c>
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
  4033f2:	eb05 0c0e 	add.w	ip, r5, lr
		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
	} while (++s < 13);
  4033f6:	3201      	adds	r2, #1
  4033f8:	2a0d      	cmp	r2, #13

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
  4033fa:	f805 000e 	strb.w	r0, [r5, lr]
  4033fe:	f88c 0001 	strb.w	r0, [ip, #1]
		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
	} while (++s < 13);
  403402:	d1f2      	bne.n	4033ea <dir_register+0x29e>
	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLE;	/* Bottom LFN part is the start of LFN sequence */
  403404:	f64f 72ff 	movw	r2, #65535	; 0xffff
  403408:	4293      	cmp	r3, r2
  40340a:	d002      	beq.n	403412 <dir_register+0x2c6>
  40340c:	f839 3011 	ldrh.w	r3, [r9, r1, lsl #1]
  403410:	b90b      	cbnz	r3, 403416 <dir_register+0x2ca>
  403412:	f04a 0a40 	orr.w	sl, sl, #64	; 0x40
	dir[LDIR_Ord] = ord;			/* Set the LFN order */
  403416:	f885 a000 	strb.w	sl, [r5]
			ne--;
			do {					/* Store LFN entries in bottom first */
				res = move_window(dj->fs, dj->sect);
				if (res != FR_OK) break;
				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
				dj->fs->wflag = 1;
  40341a:	6823      	ldr	r3, [r4, #0]
				res = dir_next(dj, 0);	/* Next entry */
  40341c:	4a0b      	ldr	r2, [pc, #44]	; (40344c <dir_register+0x300>)
			ne--;
			do {					/* Store LFN entries in bottom first */
				res = move_window(dj->fs, dj->sect);
				if (res != FR_OK) break;
				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
				dj->fs->wflag = 1;
  40341e:	2101      	movs	r1, #1
  403420:	7119      	strb	r1, [r3, #4]
				res = dir_next(dj, 0);	/* Next entry */
  403422:	4620      	mov	r0, r4
  403424:	2100      	movs	r1, #0
  403426:	4790      	blx	r2
			} while (res == FR_OK && --ne);
  403428:	4603      	mov	r3, r0
  40342a:	2800      	cmp	r0, #0
  40342c:	d18b      	bne.n	403346 <dir_register+0x1fa>
  40342e:	f10b 3bff 	add.w	fp, fp, #4294967295
  403432:	fa1f fb8b 	uxth.w	fp, fp
  403436:	f1bb 0f00 	cmp.w	fp, #0
  40343a:	d1a7      	bne.n	40338c <dir_register+0x240>
  40343c:	e6d1      	b.n	4031e2 <dir_register+0x96>
  40343e:	bf00      	nop
  403440:	00402c25 	.word	0x00402c25
  403444:	00402619 	.word	0x00402619
  403448:	4ec4ec4f 	.word	0x4ec4ec4f
  40344c:	00402ea5 	.word	0x00402ea5
  403450:	00402fe5 	.word	0x00402fe5
  403454:	00406bd4 	.word	0x00406bd4

00403458 <remove_chain.part.6>:
/*-----------------------------------------------------------------------*/
/* FAT handling - Remove a cluster chain                                 */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY
static
FRESULT remove_chain (
  403458:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  40345c:	4604      	mov	r4, r0
  40345e:	460d      	mov	r5, r1
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
  403460:	69a3      	ldr	r3, [r4, #24]
  403462:	4f16      	ldr	r7, [pc, #88]	; (4034bc <remove_chain.part.6+0x64>)
  403464:	f8df 8058 	ldr.w	r8, [pc, #88]	; 4034c0 <remove_chain.part.6+0x68>
  403468:	429d      	cmp	r5, r3
  40346a:	d220      	bcs.n	4034ae <remove_chain.part.6+0x56>
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  40346c:	2d01      	cmp	r5, #1
  40346e:	d90b      	bls.n	403488 <remove_chain.part.6+0x30>
  403470:	4620      	mov	r0, r4
  403472:	4629      	mov	r1, r5
  403474:	47b8      	blx	r7

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
  403476:	4606      	mov	r6, r0
  403478:	b1c8      	cbz	r0, 4034ae <remove_chain.part.6+0x56>
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
  40347a:	2801      	cmp	r0, #1
  40347c:	d004      	beq.n	403488 <remove_chain.part.6+0x30>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
  40347e:	3001      	adds	r0, #1
  403480:	d018      	beq.n	4034b4 <remove_chain.part.6+0x5c>
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
  403482:	69a3      	ldr	r3, [r4, #24]
  403484:	429d      	cmp	r5, r3
  403486:	d302      	bcc.n	40348e <remove_chain.part.6+0x36>
	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
  403488:	2002      	movs	r0, #2
  40348a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40348e:	2200      	movs	r2, #0
  403490:	4629      	mov	r1, r5
  403492:	4620      	mov	r0, r4
  403494:	47c0      	blx	r8
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
			if (res != FR_OK) break;
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
				fs->free_clust++;
				fs->fsi_flag = 1;
  403496:	2201      	movs	r2, #1
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
			if (res != FR_OK) break;
  403498:	b968      	cbnz	r0, 4034b6 <remove_chain.part.6+0x5e>
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
  40349a:	6923      	ldr	r3, [r4, #16]
  40349c:	1c59      	adds	r1, r3, #1
  40349e:	d002      	beq.n	4034a6 <remove_chain.part.6+0x4e>
				fs->free_clust++;
  4034a0:	4413      	add	r3, r2
  4034a2:	6123      	str	r3, [r4, #16]
				fs->fsi_flag = 1;
  4034a4:	7162      	strb	r2, [r4, #5]
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
  4034a6:	69a3      	ldr	r3, [r4, #24]
/*-----------------------------------------------------------------------*/
/* FAT handling - Remove a cluster chain                                 */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY
static
FRESULT remove_chain (
  4034a8:	4635      	mov	r5, r6
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
  4034aa:	429d      	cmp	r5, r3
  4034ac:	d3de      	bcc.n	40346c <remove_chain.part.6+0x14>
/*-----------------------------------------------------------------------*/
/* FAT handling - Remove a cluster chain                                 */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY
static
FRESULT remove_chain (
  4034ae:	2000      	movs	r0, #0
  4034b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
  4034b4:	2001      	movs	r0, #1
			clst = nxt;	/* Next cluster */
		}
	}

	return res;
}
  4034b6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4034ba:	bf00      	nop
  4034bc:	00402b59 	.word	0x00402b59
  4034c0:	00402ccd 	.word	0x00402ccd

004034c4 <follow_path>:
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR *dj,			/* Directory object to return last directory and found object */
	const TCHAR *path	/* Full-path string to find a file or directory */
)
{
  4034c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
	} else {							/* No heading separator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
	}
#else
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
  4034c8:	780b      	ldrb	r3, [r1, #0]
  4034ca:	2b2f      	cmp	r3, #47	; 0x2f
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR *dj,			/* Directory object to return last directory and found object */
	const TCHAR *path	/* Full-path string to find a file or directory */
)
{
  4034cc:	b083      	sub	sp, #12
  4034ce:	4689      	mov	r9, r1
  4034d0:	4606      	mov	r6, r0
		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
	} else {							/* No heading separator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
	}
#else
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
  4034d2:	f000 8133 	beq.w	40373c <follow_path+0x278>
  4034d6:	2b5c      	cmp	r3, #92	; 0x5c
  4034d8:	f000 8130 	beq.w	40373c <follow_path+0x278>
		path++;
	dj->sclust = 0;						/* Start from the root dir */
  4034dc:	2400      	movs	r4, #0
  4034de:	60b4      	str	r4, [r6, #8]
#endif

	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
  4034e0:	f899 0000 	ldrb.w	r0, [r9]
  4034e4:	281f      	cmp	r0, #31
  4034e6:	f240 8132 	bls.w	40374e <follow_path+0x28a>
  4034ea:	4da7      	ldr	r5, [pc, #668]	; (403788 <follow_path+0x2c4>)
  4034ec:	e001      	b.n	4034f2 <follow_path+0x2e>
  4034ee:	f819 0f01 	ldrb.w	r0, [r9, #1]!
	WCHAR w, *lfn;
	UINT i, ni, si, di;
	const TCHAR *p;

	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
  4034f2:	282f      	cmp	r0, #47	; 0x2f
  4034f4:	d0fb      	beq.n	4034ee <follow_path+0x2a>
  4034f6:	285c      	cmp	r0, #92	; 0x5c
  4034f8:	d0f9      	beq.n	4034ee <follow_path+0x2a>
	lfn = dj->lfn;
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
  4034fa:	281f      	cmp	r0, #31
	UINT i, ni, si, di;
	const TCHAR *p;

	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
  4034fc:	69f7      	ldr	r7, [r6, #28]
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
  4034fe:	f240 80ec 	bls.w	4036da <follow_path+0x216>
  403502:	282f      	cmp	r0, #47	; 0x2f
  403504:	d02d      	beq.n	403562 <follow_path+0x9e>
  403506:	285c      	cmp	r0, #92	; 0x5c
  403508:	d02b      	beq.n	403562 <follow_path+0x9e>
			b = (BYTE)p[si++];			/* Get 2nd byte */
			if (!IsDBCS2(b))
				return FR_INVALID_NAME;	/* Reject invalid sequence */
			w = (w << 8) + b;			/* Create a DBC */
		}
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
  40350a:	2101      	movs	r1, #1
  40350c:	f1a7 0b02 	sub.w	fp, r7, #2
  403510:	46ca      	mov	sl, r9
	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
  403512:	2401      	movs	r4, #1
			b = (BYTE)p[si++];			/* Get 2nd byte */
			if (!IsDBCS2(b))
				return FR_INVALID_NAME;	/* Reject invalid sequence */
			w = (w << 8) + b;			/* Create a DBC */
		}
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
  403514:	47a8      	blx	r5
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
  403516:	b300      	cbz	r0, 40355a <follow_path+0x96>
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
  403518:	287f      	cmp	r0, #127	; 0x7f
  40351a:	d809      	bhi.n	403530 <follow_path+0x6c>
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
  40351c:	2822      	cmp	r0, #34	; 0x22
  40351e:	d01c      	beq.n	40355a <follow_path+0x96>
  403520:	4a9a      	ldr	r2, [pc, #616]	; (40378c <follow_path+0x2c8>)
  403522:	e001      	b.n	403528 <follow_path+0x64>
  403524:	4298      	cmp	r0, r3
  403526:	d018      	beq.n	40355a <follow_path+0x96>
  403528:	f812 3f01 	ldrb.w	r3, [r2, #1]!
  40352c:	2b00      	cmp	r3, #0
  40352e:	d1f9      	bne.n	403524 <follow_path+0x60>
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
			return FR_INVALID_NAME;
		lfn[di++] = w;					/* Store the Unicode char */
  403530:	f82b 0f02 	strh.w	r0, [fp, #2]!
	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
  403534:	f81a 0f01 	ldrb.w	r0, [sl, #1]!
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
  403538:	281f      	cmp	r0, #31
	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
  40353a:	f104 0301 	add.w	r3, r4, #1
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
  40353e:	f240 80ce 	bls.w	4036de <follow_path+0x21a>
  403542:	282f      	cmp	r0, #47	; 0x2f
  403544:	d00f      	beq.n	403566 <follow_path+0xa2>
  403546:	285c      	cmp	r0, #92	; 0x5c
  403548:	d00d      	beq.n	403566 <follow_path+0xa2>
		if (di >= _MAX_LFN)				/* Reject too long name */
  40354a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  40354e:	d004      	beq.n	40355a <follow_path+0x96>
			b = (BYTE)p[si++];			/* Get 2nd byte */
			if (!IsDBCS2(b))
				return FR_INVALID_NAME;	/* Reject invalid sequence */
			w = (w << 8) + b;			/* Create a DBC */
		}
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
  403550:	2101      	movs	r1, #1
	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
  403552:	461c      	mov	r4, r3
			b = (BYTE)p[si++];			/* Get 2nd byte */
			if (!IsDBCS2(b))
				return FR_INVALID_NAME;	/* Reject invalid sequence */
			w = (w << 8) + b;			/* Create a DBC */
		}
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
  403554:	47a8      	blx	r5
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
  403556:	2800      	cmp	r0, #0
  403558:	d1de      	bne.n	403518 <follow_path+0x54>
		if (i >= ni || si == di) {		/* Extension or end of SFN */
			if (ni == 11) {				/* Long extension */
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
			if (si > di) break;			/* No extension */
  40355a:	2006      	movs	r0, #6
			dj->sclust = LD_CLUST(dir);
		}
	}

	return res;
}
  40355c:	b003      	add	sp, #12
  40355e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	const TCHAR *p;

	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
  403562:	2400      	movs	r4, #0
	for (;;) {
		w = p[si++];					/* Get a character */
  403564:	2301      	movs	r3, #1
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
			return FR_INVALID_NAME;
		lfn[di++] = w;					/* Store the Unicode char */
	}
	*path = &p[si];						/* Return pointer to the next segment */
  403566:	4499      	add	r9, r3
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
  403568:	f04f 0b00 	mov.w	fp, #0
			dj->fn[i] = (i < di) ? '.' : ' ';
		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
		return FR_OK;
	}
#endif
	while (di) {						/* Strip trailing spaces and dots */
  40356c:	2c00      	cmp	r4, #0
  40356e:	d0f4      	beq.n	40355a <follow_path+0x96>
  403570:	eb07 0044 	add.w	r0, r7, r4, lsl #1
		w = lfn[di-1];
  403574:	f830 2d02 	ldrh.w	r2, [r0, #-2]!
		if (w != ' ' && w != '.') break;
  403578:	2a20      	cmp	r2, #32
  40357a:	d001      	beq.n	403580 <follow_path+0xbc>
  40357c:	2a2e      	cmp	r2, #46	; 0x2e
  40357e:	d102      	bne.n	403586 <follow_path+0xc2>
			dj->fn[i] = (i < di) ? '.' : ' ';
		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
		return FR_OK;
	}
#endif
	while (di) {						/* Strip trailing spaces and dots */
  403580:	3c01      	subs	r4, #1
  403582:	d1f7      	bne.n	403574 <follow_path+0xb0>
  403584:	e7e9      	b.n	40355a <follow_path+0x96>
		if (w != ' ' && w != '.') break;
		di--;
	}
	if (!di) return FR_INVALID_NAME;	/* Reject nul string */

	lfn[di] = 0;						/* LFN is created */
  403586:	2300      	movs	r3, #0
  403588:	f827 3014 	strh.w	r3, [r7, r4, lsl #1]

	/* Create SFN in directory form */
	mem_set(dj->fn, ' ', 11);
  40358c:	69b3      	ldr	r3, [r6, #24]
		if (w != ' ' && w != '.') break;
		di--;
	}
	if (!di) return FR_INVALID_NAME;	/* Reject nul string */

	lfn[di] = 0;						/* LFN is created */
  40358e:	eb07 0044 	add.w	r0, r7, r4, lsl #1
  403592:	f103 010b 	add.w	r1, r3, #11
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
  403596:	2220      	movs	r2, #32
  403598:	f803 2b01 	strb.w	r2, [r3], #1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
  40359c:	428b      	cmp	r3, r1
  40359e:	d1fb      	bne.n	403598 <follow_path+0xd4>
  4035a0:	1ebb      	subs	r3, r7, #2
  4035a2:	f04f 0a00 	mov.w	sl, #0
  4035a6:	e001      	b.n	4035ac <follow_path+0xe8>

	lfn[di] = 0;						/* LFN is created */

	/* Create SFN in directory form */
	mem_set(dj->fn, ' ', 11);
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
  4035a8:	f10a 0a01 	add.w	sl, sl, #1
  4035ac:	f833 2f02 	ldrh.w	r2, [r3, #2]!
  4035b0:	2a20      	cmp	r2, #32
  4035b2:	d0f9      	beq.n	4035a8 <follow_path+0xe4>
  4035b4:	2a2e      	cmp	r2, #46	; 0x2e
  4035b6:	d0f7      	beq.n	4035a8 <follow_path+0xe4>
	if (si) cf |= NS_LOSS | NS_LFN;
  4035b8:	f1ba 0f00 	cmp.w	sl, #0
  4035bc:	d001      	beq.n	4035c2 <follow_path+0xfe>
  4035be:	f04b 0b03 	orr.w	fp, fp, #3
  4035c2:	4603      	mov	r3, r0
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
  4035c4:	f833 1d02 	ldrh.w	r1, [r3, #-2]!
  4035c8:	292e      	cmp	r1, #46	; 0x2e
  4035ca:	d001      	beq.n	4035d0 <follow_path+0x10c>
  4035cc:	3c01      	subs	r4, #1
  4035ce:	d1f9      	bne.n	4035c4 <follow_path+0x100>

	lfn[di] = 0;						/* LFN is created */

	/* Create SFN in directory form */
	mem_set(dj->fn, ' ', 11);
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
  4035d0:	f04f 0c00 	mov.w	ip, #0
  4035d4:	4610      	mov	r0, r2
  4035d6:	46e0      	mov	r8, ip
  4035d8:	2308      	movs	r3, #8
	if (si) cf |= NS_LOSS | NS_LFN;
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */

	b = i = 0; ni = 8;
	for (;;) {
		w = lfn[si++];					/* Get an LFN char */
  4035da:	f10a 0a01 	add.w	sl, sl, #1
		if (!w) break;					/* Break on end of the LFN */
  4035de:	b378      	cbz	r0, 403640 <follow_path+0x17c>
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
  4035e0:	2820      	cmp	r0, #32
  4035e2:	d01f      	beq.n	403624 <follow_path+0x160>
  4035e4:	282e      	cmp	r0, #46	; 0x2e
  4035e6:	d01b      	beq.n	403620 <follow_path+0x15c>
			cf |= NS_LOSS | NS_LFN; continue;
		}

		if (i >= ni || si == di) {		/* Extension or end of SFN */
  4035e8:	459c      	cmp	ip, r3
  4035ea:	d220      	bcs.n	40362e <follow_path+0x16a>
  4035ec:	4554      	cmp	r4, sl
  4035ee:	d07a      	beq.n	4036e6 <follow_path+0x222>
			if (si > di) break;			/* No extension */
			si = di; i = 8; ni = 11;	/* Enter extension section */
			b <<= 2; continue;
		}

		if (w >= 0x80) {				/* Non ASCII char */
  4035f0:	287f      	cmp	r0, #127	; 0x7f
  4035f2:	f200 8083 	bhi.w	4036fc <follow_path+0x238>
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
  4035f6:	282b      	cmp	r0, #43	; 0x2b
  4035f8:	f000 8090 	beq.w	40371c <follow_path+0x258>
  4035fc:	4a64      	ldr	r2, [pc, #400]	; (403790 <follow_path+0x2cc>)
  4035fe:	e002      	b.n	403606 <follow_path+0x142>
  403600:	4288      	cmp	r0, r1
  403602:	f000 808b 	beq.w	40371c <follow_path+0x258>
  403606:	f812 1f01 	ldrb.w	r1, [r2, #1]!
  40360a:	2900      	cmp	r1, #0
  40360c:	d1f8      	bne.n	403600 <follow_path+0x13c>
			dj->fn[i++] = (BYTE)(w >> 8);
		} else {						/* Single byte char */
			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
			} else {
				if (IsUpper(w)) {		/* ASCII large capital */
  40360e:	f1a0 0141 	sub.w	r1, r0, #65	; 0x41
  403612:	2919      	cmp	r1, #25
  403614:	f200 80a6 	bhi.w	403764 <follow_path+0x2a0>
					b |= 2;
  403618:	f048 0802 	orr.w	r8, r8, #2
  40361c:	b2c0      	uxtb	r0, r0
  40361e:	e080      	b.n	403722 <follow_path+0x25e>

	b = i = 0; ni = 8;
	for (;;) {
		w = lfn[si++];					/* Get an LFN char */
		if (!w) break;					/* Break on end of the LFN */
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
  403620:	4554      	cmp	r4, sl
  403622:	d060      	beq.n	4036e6 <follow_path+0x222>
			cf |= NS_LOSS | NS_LFN; continue;
  403624:	f04b 0b03 	orr.w	fp, fp, #3
  403628:	f837 001a 	ldrh.w	r0, [r7, sl, lsl #1]
  40362c:	e7d5      	b.n	4035da <follow_path+0x116>
		}

		if (i >= ni || si == di) {		/* Extension or end of SFN */
			if (ni == 11) {				/* Long extension */
  40362e:	2b0b      	cmp	r3, #11
  403630:	f000 80a6 	beq.w	403780 <follow_path+0x2bc>
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
  403634:	4554      	cmp	r4, sl
  403636:	d058      	beq.n	4036ea <follow_path+0x226>
			if (si > di) break;			/* No extension */
  403638:	45a2      	cmp	sl, r4

		if (i >= ni || si == di) {		/* Extension or end of SFN */
			if (ni == 11) {				/* Long extension */
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
  40363a:	f04b 0b03 	orr.w	fp, fp, #3
			if (si > di) break;			/* No extension */
  40363e:	d954      	bls.n	4036ea <follow_path+0x226>
			}
		}
		dj->fn[i++] = (BYTE)w;
	}

	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */
  403640:	69b1      	ldr	r1, [r6, #24]
  403642:	7808      	ldrb	r0, [r1, #0]
  403644:	28e5      	cmp	r0, #229	; 0xe5
  403646:	d075      	beq.n	403734 <follow_path+0x270>

	if (ni == 8) b <<= 2;
  403648:	2b08      	cmp	r3, #8
  40364a:	bf04      	itt	eq
  40364c:	ea4f 0288 	moveq.w	r2, r8, lsl #2
  403650:	fa5f f882 	uxtbeq.w	r8, r2
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
  403654:	f008 030c 	and.w	r3, r8, #12
  403658:	2b0c      	cmp	r3, #12
  40365a:	d068      	beq.n	40372e <follow_path+0x26a>
  40365c:	f008 0003 	and.w	r0, r8, #3
  403660:	2803      	cmp	r0, #3
  403662:	d064      	beq.n	40372e <follow_path+0x26a>
		cf |= NS_LFN;
	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended char, NT flags are created */
  403664:	f01b 0f02 	tst.w	fp, #2
  403668:	d109      	bne.n	40367e <follow_path+0x1ba>
		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
  40366a:	f008 0203 	and.w	r2, r8, #3
  40366e:	2a01      	cmp	r2, #1
  403670:	bf08      	it	eq
  403672:	f04b 0b10 	orreq.w	fp, fp, #16
		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
  403676:	2b04      	cmp	r3, #4
  403678:	bf08      	it	eq
  40367a:	f04b 0b08 	orreq.w	fp, fp, #8
	}

	dj->fn[NS] = cf;	/* SFN is created */
  40367e:	f881 b00b 	strb.w	fp, [r1, #11]
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dj, 0);			/* Rewind directory object */
  403682:	4630      	mov	r0, r6
  403684:	2100      	movs	r1, #0
  403686:	4b43      	ldr	r3, [pc, #268]	; (403794 <follow_path+0x2d0>)
  403688:	4798      	blx	r3
	if (res != FR_OK) return res;
  40368a:	b9d0      	cbnz	r0, 4036c2 <follow_path+0x1fe>
  40368c:	4b42      	ldr	r3, [pc, #264]	; (403798 <follow_path+0x2d4>)
  40368e:	4630      	mov	r0, r6
  403690:	4798      	blx	r3
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			ns = *(dj->fn+NS);
  403692:	69b3      	ldr	r3, [r6, #24]
  403694:	7adb      	ldrb	r3, [r3, #11]
			if (res != FR_OK) {				/* Failed to find the object */
  403696:	b9b0      	cbnz	r0, 4036c6 <follow_path+0x202>
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
  403698:	0759      	lsls	r1, r3, #29
  40369a:	f53f af5f 	bmi.w	40355c <follow_path+0x98>
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
  40369e:	6973      	ldr	r3, [r6, #20]
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
  4036a0:	7ada      	ldrb	r2, [r3, #11]
  4036a2:	06d2      	lsls	r2, r2, #27
  4036a4:	d568      	bpl.n	403778 <follow_path+0x2b4>
				res = FR_NO_PATH; break;
			}
			dj->sclust = LD_CLUST(dir);
  4036a6:	7d5c      	ldrb	r4, [r3, #21]
  4036a8:	7d1a      	ldrb	r2, [r3, #20]
  4036aa:	7ed8      	ldrb	r0, [r3, #27]
  4036ac:	7e99      	ldrb	r1, [r3, #26]
  4036ae:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
  4036b2:	ea41 2300 	orr.w	r3, r1, r0, lsl #8
  4036b6:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  4036ba:	60b3      	str	r3, [r6, #8]
  4036bc:	f899 0000 	ldrb.w	r0, [r9]
		}
  4036c0:	e717      	b.n	4034f2 <follow_path+0x2e>
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			ns = *(dj->fn+NS);
  4036c2:	69b3      	ldr	r3, [r6, #24]
  4036c4:	7adb      	ldrb	r3, [r3, #11]
			if (res != FR_OK) {				/* Failed to find the object */
				if (res != FR_NO_FILE) break;	/* Abort if any hard error occured */
  4036c6:	2804      	cmp	r0, #4
  4036c8:	f47f af48 	bne.w	40355c <follow_path+0x98>
				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
					res = FR_OK;
					if (!(ns & NS_LAST)) continue;
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
  4036cc:	f013 0f04 	tst.w	r3, #4
  4036d0:	bf08      	it	eq
  4036d2:	2005      	moveq	r0, #5
			dj->sclust = LD_CLUST(dir);
		}
	}

	return res;
}
  4036d4:	b003      	add	sp, #12
  4036d6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	const TCHAR *p;

	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
  4036da:	2400      	movs	r4, #0
	for (;;) {
		w = p[si++];					/* Get a character */
  4036dc:	2301      	movs	r3, #1
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
			return FR_INVALID_NAME;
		lfn[di++] = w;					/* Store the Unicode char */
	}
	*path = &p[si];						/* Return pointer to the next segment */
  4036de:	4499      	add	r9, r3
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
  4036e0:	f04f 0b04 	mov.w	fp, #4
  4036e4:	e742      	b.n	40356c <follow_path+0xa8>
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
			cf |= NS_LOSS | NS_LFN; continue;
		}

		if (i >= ni || si == di) {		/* Extension or end of SFN */
			if (ni == 11) {				/* Long extension */
  4036e6:	2b0b      	cmp	r3, #11
  4036e8:	d04a      	beq.n	403780 <follow_path+0x2bc>
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
			if (si > di) break;			/* No extension */
			si = di; i = 8; ni = 11;	/* Enter extension section */
			b <<= 2; continue;
  4036ea:	ea4f 0288 	mov.w	r2, r8, lsl #2
  4036ee:	fa5f f882 	uxtb.w	r8, r2
  4036f2:	46a2      	mov	sl, r4
			if (ni == 11) {				/* Long extension */
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
			if (si > di) break;			/* No extension */
			si = di; i = 8; ni = 11;	/* Enter extension section */
  4036f4:	230b      	movs	r3, #11
  4036f6:	f04f 0c08 	mov.w	ip, #8
  4036fa:	e795      	b.n	403628 <follow_path+0x164>
			b <<= 2; continue;
		}

		if (w >= 0x80) {				/* Non ASCII char */
#ifdef _EXCVT
			w = ff_convert(w, 0);		/* Unicode -> OEM code */
  4036fc:	2100      	movs	r1, #0
  4036fe:	e88d 1008 	stmia.w	sp, {r3, ip}
  403702:	47a8      	blx	r5
			if (w) w = excvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
  403704:	e89d 1008 	ldmia.w	sp, {r3, ip}
  403708:	b348      	cbz	r0, 40375e <follow_path+0x29a>
  40370a:	4a24      	ldr	r2, [pc, #144]	; (40379c <follow_path+0x2d8>)
  40370c:	4410      	add	r0, r2
#else
			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
#endif
			cf |= NS_LFN;				/* Force create LFN entry */
  40370e:	f04b 0b02 	orr.w	fp, fp, #2
		}

		if (w >= 0x80) {				/* Non ASCII char */
#ifdef _EXCVT
			w = ff_convert(w, 0);		/* Unicode -> OEM code */
			if (w) w = excvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
  403712:	f810 0c80 	ldrb.w	r0, [r0, #-128]
			if (i >= ni - 1) {
				cf |= NS_LOSS | NS_LFN; i = ni; continue;
			}
			dj->fn[i++] = (BYTE)(w >> 8);
		} else {						/* Single byte char */
			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
  403716:	2800      	cmp	r0, #0
  403718:	f47f af6d 	bne.w	4035f6 <follow_path+0x132>
				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
  40371c:	f04b 0b03 	orr.w	fp, fp, #3
  403720:	205f      	movs	r0, #95	; 0x5f
						b |= 1; w -= 0x20;
					}
				}
			}
		}
		dj->fn[i++] = (BYTE)w;
  403722:	69b1      	ldr	r1, [r6, #24]
  403724:	f801 000c 	strb.w	r0, [r1, ip]
  403728:	f10c 0c01 	add.w	ip, ip, #1
  40372c:	e77c      	b.n	403628 <follow_path+0x164>

	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */

	if (ni == 8) b <<= 2;
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
		cf |= NS_LFN;
  40372e:	f04b 0b02 	orr.w	fp, fp, #2
  403732:	e797      	b.n	403664 <follow_path+0x1a0>
			}
		}
		dj->fn[i++] = (BYTE)w;
	}

	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */
  403734:	2005      	movs	r0, #5
  403736:	7008      	strb	r0, [r1, #0]
  403738:	69b1      	ldr	r1, [r6, #24]
  40373a:	e785      	b.n	403648 <follow_path+0x184>
	} else {							/* No heading separator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
	}
#else
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
		path++;
  40373c:	f109 0901 	add.w	r9, r9, #1
	dj->sclust = 0;						/* Start from the root dir */
  403740:	2400      	movs	r4, #0
  403742:	60b4      	str	r4, [r6, #8]
#endif

	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
  403744:	f899 0000 	ldrb.w	r0, [r9]
  403748:	281f      	cmp	r0, #31
  40374a:	f63f aece 	bhi.w	4034ea <follow_path+0x26>
		res = dir_sdi(dj, 0);
  40374e:	4630      	mov	r0, r6
  403750:	4621      	mov	r1, r4
  403752:	4b10      	ldr	r3, [pc, #64]	; (403794 <follow_path+0x2d0>)
  403754:	4798      	blx	r3
		dj->dir = 0;
  403756:	6174      	str	r4, [r6, #20]
			dj->sclust = LD_CLUST(dir);
		}
	}

	return res;
}
  403758:	b003      	add	sp, #12
  40375a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			w = ff_convert(w, 0);		/* Unicode -> OEM code */
			if (w) w = excvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
#else
			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
#endif
			cf |= NS_LFN;				/* Force create LFN entry */
  40375e:	f04b 0b02 	orr.w	fp, fp, #2
  403762:	e7db      	b.n	40371c <follow_path+0x258>
				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
			} else {
				if (IsUpper(w)) {		/* ASCII large capital */
					b |= 2;
				} else {
					if (IsLower(w)) {	/* ASCII small capital */
  403764:	f1a0 0161 	sub.w	r1, r0, #97	; 0x61
  403768:	2919      	cmp	r1, #25
						b |= 1; w -= 0x20;
  40376a:	bf97      	itett	ls
  40376c:	3820      	subls	r0, #32
  40376e:	b2c0      	uxtbhi	r0, r0
  403770:	b2c0      	uxtbls	r0, r0
  403772:	f048 0801 	orrls.w	r8, r8, #1
  403776:	e7d4      	b.n	403722 <follow_path+0x25e>
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
				res = FR_NO_PATH; break;
  403778:	2005      	movs	r0, #5
			dj->sclust = LD_CLUST(dir);
		}
	}

	return res;
}
  40377a:	b003      	add	sp, #12
  40377c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			cf |= NS_LOSS | NS_LFN; continue;
		}

		if (i >= ni || si == di) {		/* Extension or end of SFN */
			if (ni == 11) {				/* Long extension */
				cf |= NS_LOSS | NS_LFN; break;
  403780:	f04b 0b03 	orr.w	fp, fp, #3
  403784:	230b      	movs	r3, #11
  403786:	e75b      	b.n	403640 <follow_path+0x17c>
  403788:	00403d39 	.word	0x00403d39
  40378c:	00406bc0 	.word	0x00406bc0
  403790:	00406bcc 	.word	0x00406bcc
  403794:	00402c25 	.word	0x00402c25
  403798:	00402fe5 	.word	0x00402fe5
  40379c:	00406b40 	.word	0x00406b40

004037a0 <f_mount>:

FRESULT f_mount (
	BYTE vol,		/* Logical drive number to be mounted/unmounted */
	FATFS *fs		/* Pointer to new file system object (NULL for unmount)*/
)
{
  4037a0:	b4f0      	push	{r4, r5, r6, r7}
	FATFS *rfs;


	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
  4037a2:	b110      	cbz	r0, 4037aa <f_mount+0xa>
		return FR_INVALID_DRIVE;
  4037a4:	200b      	movs	r0, #11
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */

	return FR_OK;
}
  4037a6:	bcf0      	pop	{r4, r5, r6, r7}
  4037a8:	4770      	bx	lr
	FATFS *rfs;


	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
		return FR_INVALID_DRIVE;
	rfs = FatFs[vol];			/* Get current fs object */
  4037aa:	4d0b      	ldr	r5, [pc, #44]	; (4037d8 <f_mount+0x38>)
  4037ac:	682b      	ldr	r3, [r5, #0]

	if (rfs) {
  4037ae:	b15b      	cbz	r3, 4037c8 <f_mount+0x28>
  4037b0:	4c0a      	ldr	r4, [pc, #40]	; (4037dc <f_mount+0x3c>)
)
{
	UINT i;

	for (i = 0; i < _FS_SHARE; i++) {
		if (Files[i].fs == fs) Files[i].fs = 0;
  4037b2:	4607      	mov	r7, r0
  4037b4:	4626      	mov	r6, r4
  4037b6:	5822      	ldr	r2, [r4, r0]
  4037b8:	4293      	cmp	r3, r2
  4037ba:	bf08      	it	eq
  4037bc:	5187      	streq	r7, [r0, r6]
  4037be:	300c      	adds	r0, #12
	FATFS *fs
)
{
	UINT i;

	for (i = 0; i < _FS_SHARE; i++) {
  4037c0:	2824      	cmp	r0, #36	; 0x24
  4037c2:	d1f8      	bne.n	4037b6 <f_mount+0x16>
		clear_lock(rfs);
#endif
#if _FS_REENTRANT				/* Discard sync object of the current volume */
		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
#endif
		rfs->fs_type = 0;		/* Clear old fs object */
  4037c4:	2200      	movs	r2, #0
  4037c6:	701a      	strb	r2, [r3, #0]
	}

	if (fs) {
  4037c8:	b109      	cbz	r1, 4037ce <f_mount+0x2e>
		fs->fs_type = 0;		/* Clear new fs object */
  4037ca:	2300      	movs	r3, #0
  4037cc:	700b      	strb	r3, [r1, #0]
#if _FS_REENTRANT				/* Create sync object for the new volume */
		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */
  4037ce:	6029      	str	r1, [r5, #0]

	return FR_OK;
  4037d0:	2000      	movs	r0, #0
}
  4037d2:	bcf0      	pop	{r4, r5, r6, r7}
  4037d4:	4770      	bx	lr
  4037d6:	bf00      	nop
  4037d8:	20000f8c 	.word	0x20000f8c
  4037dc:	20000f68 	.word	0x20000f68

004037e0 <f_open>:
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const TCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
  4037e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4037e4:	f5ad 7d0f 	sub.w	sp, sp, #572	; 0x23c
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	fp->fs = 0;			/* Clear file object */
  4037e8:	2300      	movs	r3, #0
  4037ea:	6003      	str	r3, [r0, #0]
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const TCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
  4037ec:	4616      	mov	r6, r2
  4037ee:	9101      	str	r1, [sp, #4]

	fp->fs = 0;			/* Clear file object */

#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
  4037f0:	f002 021e 	and.w	r2, r2, #30
  4037f4:	4b9a      	ldr	r3, [pc, #616]	; (403a60 <f_open+0x280>)
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const TCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
  4037f6:	4604      	mov	r4, r0

	fp->fs = 0;			/* Clear file object */

#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
  4037f8:	a905      	add	r1, sp, #20
  4037fa:	a801      	add	r0, sp, #4
  4037fc:	4798      	blx	r3
#else
	mode &= FA_READ;
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	INIT_BUF(dj);
  4037fe:	ab02      	add	r3, sp, #8
  403800:	aa0e      	add	r2, sp, #56	; 0x38
  403802:	930b      	str	r3, [sp, #44]	; 0x2c
  403804:	920c      	str	r2, [sp, #48]	; 0x30


	fp->fs = 0;			/* Clear file object */

#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
  403806:	f006 071f 	and.w	r7, r6, #31
#else
	mode &= FA_READ;
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	INIT_BUF(dj);
	if (res == FR_OK)
  40380a:	b130      	cbz	r0, 40381a <f_open+0x3a>
		else
			res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
#endif
	}
	/* Create or Open a file */
	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
  40380c:	f016 0f1c 	tst.w	r6, #28
  403810:	d11a      	bne.n	403848 <f_open+0x68>
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
	}

	LEAVE_FF(dj.fs, res);
}
  403812:	f50d 7d0f 	add.w	sp, sp, #572	; 0x23c
  403816:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	mode &= FA_READ;
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	INIT_BUF(dj);
	if (res == FR_OK)
		res = follow_path(&dj, path);	/* Follow the file path */
  40381a:	9901      	ldr	r1, [sp, #4]
  40381c:	4b91      	ldr	r3, [pc, #580]	; (403a64 <f_open+0x284>)
  40381e:	a805      	add	r0, sp, #20
  403820:	4798      	blx	r3
	dir = dj.dir;
  403822:	9d0a      	ldr	r5, [sp, #40]	; 0x28

#if !_FS_READONLY	/* R/W configuration */
	if (res == FR_OK) {
  403824:	2800      	cmp	r0, #0
  403826:	d1f1      	bne.n	40380c <f_open+0x2c>
		if (!dir)	/* Current dir itself */
  403828:	2d00      	cmp	r5, #0
  40382a:	f000 80ab 	beq.w	403984 <f_open+0x1a4>
			res = FR_INVALID_NAME;
#if _FS_SHARE
		else
			res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
  40382e:	f037 0801 	bics.w	r8, r7, #1
  403832:	bf0c      	ite	eq
  403834:	2100      	moveq	r1, #0
  403836:	2101      	movne	r1, #1
  403838:	a805      	add	r0, sp, #20
  40383a:	4b8b      	ldr	r3, [pc, #556]	; (403a68 <f_open+0x288>)
  40383c:	4798      	blx	r3
#endif
	}
	/* Create or Open a file */
	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
  40383e:	f016 0f1c 	tst.w	r6, #28
  403842:	d01b      	beq.n	40387c <f_open+0x9c>
		DWORD dw, cl;

		if (res != FR_OK) {					/* No file, create new */
  403844:	2800      	cmp	r0, #0
  403846:	d050      	beq.n	4038ea <f_open+0x10a>
			if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
  403848:	2804      	cmp	r0, #4
  40384a:	d1e2      	bne.n	403812 <f_open+0x32>
static
int enq_lock (void)	/* Check if an entry is available for a new file */
{
	UINT i;

	for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
  40384c:	4b87      	ldr	r3, [pc, #540]	; (403a6c <f_open+0x28c>)
  40384e:	681a      	ldr	r2, [r3, #0]
  403850:	b12a      	cbz	r2, 40385e <f_open+0x7e>
  403852:	68da      	ldr	r2, [r3, #12]
  403854:	b11a      	cbz	r2, 40385e <f_open+0x7e>
  403856:	699b      	ldr	r3, [r3, #24]
		DWORD dw, cl;

		if (res != FR_OK) {					/* No file, create new */
			if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
#if _FS_SHARE
				res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
  403858:	2012      	movs	r0, #18
static
int enq_lock (void)	/* Check if an entry is available for a new file */
{
	UINT i;

	for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
  40385a:	2b00      	cmp	r3, #0
  40385c:	d1d9      	bne.n	403812 <f_open+0x32>
		DWORD dw, cl;

		if (res != FR_OK) {					/* No file, create new */
			if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
#if _FS_SHARE
				res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
  40385e:	a805      	add	r0, sp, #20
  403860:	4b83      	ldr	r3, [pc, #524]	; (403a70 <f_open+0x290>)
  403862:	4798      	blx	r3
#else
				res = dir_register(&dj);
#endif
			mode |= FA_CREATE_ALWAYS;		/* File is created */
  403864:	f047 0708 	orr.w	r7, r7, #8
			dir = dj.dir;					/* New entry */
  403868:	9d0a      	ldr	r5, [sp, #40]	; 0x28
			} else {
				if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
					res = FR_EXIST;
			}
		}
		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
  40386a:	2800      	cmp	r0, #0
  40386c:	d1d1      	bne.n	403812 <f_open+0x32>
  40386e:	0738      	lsls	r0, r7, #28
  403870:	f100 808a 	bmi.w	403988 <f_open+0x1a8>
  403874:	9e05      	ldr	r6, [sp, #20]
  403876:	f027 0801 	bic.w	r8, r7, #1
  40387a:	e011      	b.n	4038a0 <f_open+0xc0>
				}
			}
		}
	}
	else {	/* Open an existing file */
		if (res == FR_OK) {						/* Follow succeeded */
  40387c:	2800      	cmp	r0, #0
  40387e:	d1c8      	bne.n	403812 <f_open+0x32>
			if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
  403880:	7aeb      	ldrb	r3, [r5, #11]
  403882:	06d9      	lsls	r1, r3, #27
  403884:	d43e      	bmi.n	403904 <f_open+0x124>
				res = FR_NO_FILE;
			} else {
				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
  403886:	07b2      	lsls	r2, r6, #30
  403888:	d501      	bpl.n	40388e <f_open+0xae>
  40388a:	07db      	lsls	r3, r3, #31
  40388c:	d435      	bmi.n	4038fa <f_open+0x11a>
  40388e:	f006 0308 	and.w	r3, r6, #8
  403892:	b2db      	uxtb	r3, r3
  403894:	9e05      	ldr	r6, [sp, #20]
					res = FR_DENIED;
			}
		}
	}
	if (res == FR_OK) {
		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
  403896:	b11b      	cbz	r3, 4038a0 <f_open+0xc0>
			mode |= FA__WRITTEN;
  403898:	f047 0720 	orr.w	r7, r7, #32
  40389c:	f027 0801 	bic.w	r8, r7, #1
		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
  4038a0:	6af3      	ldr	r3, [r6, #44]	; 0x2c
	UINT i;


	for (i = 0; i < _FS_SHARE; i++) {	/* Find the file */
		if (Files[i].fs == dj->fs &&
			Files[i].clu == dj->sclust &&
  4038a2:	9807      	ldr	r0, [sp, #28]
			Files[i].idx == dj->index) break;
  4038a4:	f8bd c01a 	ldrh.w	ip, [sp, #26]
  4038a8:	4a72      	ldr	r2, [pc, #456]	; (403a74 <f_open+0x294>)
		}
	}
	if (res == FR_OK) {
		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
			mode |= FA__WRITTEN;
		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
  4038aa:	61e3      	str	r3, [r4, #28]
		fp->dir_ptr = dir;
  4038ac:	6225      	str	r5, [r4, #32]
)
{
	UINT i;


	for (i = 0; i < _FS_SHARE; i++) {	/* Find the file */
  4038ae:	2300      	movs	r3, #0
		if (Files[i].fs == dj->fs &&
  4038b0:	f852 1c08 	ldr.w	r1, [r2, #-8]
  4038b4:	42b1      	cmp	r1, r6
  4038b6:	d02a      	beq.n	40390e <f_open+0x12e>
)
{
	UINT i;


	for (i = 0; i < _FS_SHARE; i++) {	/* Find the file */
  4038b8:	3301      	adds	r3, #1
  4038ba:	2b03      	cmp	r3, #3
  4038bc:	f102 020c 	add.w	r2, r2, #12
  4038c0:	d1f6      	bne.n	4038b0 <f_open+0xd0>
			Files[i].clu == dj->sclust &&
			Files[i].idx == dj->index) break;
	}

	if (i == _FS_SHARE) {				/* Not opened. Register it as new. */
		for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
  4038c2:	4a6a      	ldr	r2, [pc, #424]	; (403a6c <f_open+0x28c>)
  4038c4:	6813      	ldr	r3, [r2, #0]
  4038c6:	2b00      	cmp	r3, #0
  4038c8:	f000 809a 	beq.w	403a00 <f_open+0x220>
  4038cc:	68d3      	ldr	r3, [r2, #12]
  4038ce:	2b00      	cmp	r3, #0
  4038d0:	f000 8095 	beq.w	4039fe <f_open+0x21e>
  4038d4:	6993      	ldr	r3, [r2, #24]
  4038d6:	2b00      	cmp	r3, #0
  4038d8:	f000 80ac 	beq.w	403a34 <f_open+0x254>
		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
			mode |= FA__WRITTEN;
		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
		fp->dir_ptr = dir;
#if _FS_SHARE
		fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
  4038dc:	2300      	movs	r3, #0
		if (!fp->lockid) res = FR_INT_ERR;
  4038de:	2002      	movs	r0, #2
		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
			mode |= FA__WRITTEN;
		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
		fp->dir_ptr = dir;
#if _FS_SHARE
		fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
  4038e0:	6263      	str	r3, [r4, #36]	; 0x24
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
	}

	LEAVE_FF(dj.fs, res);
}
  4038e2:	f50d 7d0f 	add.w	sp, sp, #572	; 0x23c
  4038e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
#endif
			mode |= FA_CREATE_ALWAYS;		/* File is created */
			dir = dj.dir;					/* New entry */
		}
		else {								/* Any object is already existing */
			if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
  4038ea:	7aeb      	ldrb	r3, [r5, #11]
  4038ec:	f013 0f11 	tst.w	r3, #17
  4038f0:	d103      	bne.n	4038fa <f_open+0x11a>
				res = FR_DENIED;
			} else {
				if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
  4038f2:	0776      	lsls	r6, r6, #29
  4038f4:	d5bb      	bpl.n	40386e <f_open+0x8e>
					res = FR_EXIST;
  4038f6:	2008      	movs	r0, #8
  4038f8:	e78b      	b.n	403812 <f_open+0x32>
		if (res == FR_OK) {						/* Follow succeeded */
			if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
				res = FR_NO_FILE;
			} else {
				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
					res = FR_DENIED;
  4038fa:	2007      	movs	r0, #7
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
	}

	LEAVE_FF(dj.fs, res);
}
  4038fc:	f50d 7d0f 	add.w	sp, sp, #572	; 0x23c
  403900:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		}
	}
	else {	/* Open an existing file */
		if (res == FR_OK) {						/* Follow succeeded */
			if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
				res = FR_NO_FILE;
  403904:	2004      	movs	r0, #4
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
	}

	LEAVE_FF(dj.fs, res);
}
  403906:	f50d 7d0f 	add.w	sp, sp, #572	; 0x23c
  40390a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
{
	UINT i;


	for (i = 0; i < _FS_SHARE; i++) {	/* Find the file */
		if (Files[i].fs == dj->fs &&
  40390e:	f852 1c04 	ldr.w	r1, [r2, #-4]
  403912:	4281      	cmp	r1, r0
  403914:	d1d0      	bne.n	4038b8 <f_open+0xd8>
			Files[i].clu == dj->sclust &&
  403916:	8811      	ldrh	r1, [r2, #0]
  403918:	4561      	cmp	r1, ip
  40391a:	d1cd      	bne.n	4038b8 <f_open+0xd8>
  40391c:	0059      	lsls	r1, r3, #1
  40391e:	4a53      	ldr	r2, [pc, #332]	; (403a6c <f_open+0x28c>)
  403920:	18c8      	adds	r0, r1, r3
  403922:	eb02 0080 	add.w	r0, r2, r0, lsl #2
  403926:	8940      	ldrh	r0, [r0, #10]
		Files[i].clu = dj->sclust;
		Files[i].idx = dj->index;
		Files[i].ctr = 0;
	}

	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
  403928:	f1b8 0f00 	cmp.w	r8, #0
  40392c:	d161      	bne.n	4039f2 <f_open+0x212>

	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
  40392e:	3001      	adds	r0, #1
  403930:	b280      	uxth	r0, r0
  403932:	4419      	add	r1, r3
  403934:	eb02 0281 	add.w	r2, r2, r1, lsl #2

	return i + 1;
  403938:	3301      	adds	r3, #1
		Files[i].ctr = 0;
	}

	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */

	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
  40393a:	8150      	strh	r0, [r2, #10]
		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
			mode |= FA__WRITTEN;
		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
		fp->dir_ptr = dir;
#if _FS_SHARE
		fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
  40393c:	6263      	str	r3, [r4, #36]	; 0x24
		if (!fp->lockid) res = FR_INT_ERR;
  40393e:	2b00      	cmp	r3, #0
  403940:	d052      	beq.n	4039e8 <f_open+0x208>
	}
#endif
	FREE_BUF();

	if (res == FR_OK) {
		fp->flag = mode;					/* File access mode */
  403942:	71a7      	strb	r7, [r4, #6]
		fp->sclust = LD_CLUST(dir);			/* File start cluster */
  403944:	7d68      	ldrb	r0, [r5, #21]
  403946:	7ea9      	ldrb	r1, [r5, #26]
  403948:	7d2a      	ldrb	r2, [r5, #20]
  40394a:	7eeb      	ldrb	r3, [r5, #27]
  40394c:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
  403950:	ea41 2303 	orr.w	r3, r1, r3, lsl #8
  403954:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  403958:	6123      	str	r3, [r4, #16]
		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
  40395a:	7fab      	ldrb	r3, [r5, #30]
  40395c:	7fe8      	ldrb	r0, [r5, #31]
  40395e:	7f29      	ldrb	r1, [r5, #28]
  403960:	7f6a      	ldrb	r2, [r5, #29]
		fp->fptr = 0;						/* File pointer */
		fp->dsect = 0;
#if _USE_FASTSEEK
		fp->cltbl = 0;						/* Normal seek mode */
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
  403962:	6026      	str	r6, [r4, #0]
	FREE_BUF();

	if (res == FR_OK) {
		fp->flag = mode;					/* File access mode */
		fp->sclust = LD_CLUST(dir);			/* File start cluster */
		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
  403964:	041b      	lsls	r3, r3, #16
  403966:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
  40396a:	430b      	orrs	r3, r1
		fp->fptr = 0;						/* File pointer */
  40396c:	2000      	movs	r0, #0
	FREE_BUF();

	if (res == FR_OK) {
		fp->flag = mode;					/* File access mode */
		fp->sclust = LD_CLUST(dir);			/* File start cluster */
		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
  40396e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  403972:	60e3      	str	r3, [r4, #12]
		fp->fptr = 0;						/* File pointer */
  403974:	60a0      	str	r0, [r4, #8]
		fp->dsect = 0;
  403976:	61a0      	str	r0, [r4, #24]
#if _USE_FASTSEEK
		fp->cltbl = 0;						/* Normal seek mode */
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
  403978:	88f3      	ldrh	r3, [r6, #6]
  40397a:	80a3      	strh	r3, [r4, #4]
	}

	LEAVE_FF(dj.fs, res);
}
  40397c:	f50d 7d0f 	add.w	sp, sp, #572	; 0x23c
  403980:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	dir = dj.dir;

#if !_FS_READONLY	/* R/W configuration */
	if (res == FR_OK) {
		if (!dir)	/* Current dir itself */
			res = FR_INVALID_NAME;
  403984:	2006      	movs	r0, #6
  403986:	e741      	b.n	40380c <f_open+0x2c>
				if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
					res = FR_EXIST;
			}
		}
		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
			dw = get_fattime();					/* Created time */
  403988:	4b3b      	ldr	r3, [pc, #236]	; (403a78 <f_open+0x298>)
  40398a:	4798      	blx	r3
			ST_DWORD(dir+DIR_CrtTime, dw);
			dir[DIR_Attr] = 0;					/* Reset attribute */
			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
			cl = LD_CLUST(dir);					/* Get start cluster */
  40398c:	f895 c015 	ldrb.w	ip, [r5, #21]
  403990:	7eab      	ldrb	r3, [r5, #26]
  403992:	7d29      	ldrb	r1, [r5, #20]
  403994:	7eea      	ldrb	r2, [r5, #27]
			ST_CLUST(dir, 0);					/* cluster = 0 */
			dj.fs->wflag = 1;
  403996:	9e05      	ldr	r6, [sp, #20]
					res = FR_EXIST;
			}
		}
		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
			dw = get_fattime();					/* Created time */
			ST_DWORD(dir+DIR_CrtTime, dw);
  403998:	73a8      	strb	r0, [r5, #14]
  40399a:	ea4f 4810 	mov.w	r8, r0, lsr #16
			dir[DIR_Attr] = 0;					/* Reset attribute */
			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
			cl = LD_CLUST(dir);					/* Get start cluster */
  40399e:	ea41 210c 	orr.w	r1, r1, ip, lsl #8
  4039a2:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
					res = FR_EXIST;
			}
		}
		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
			dw = get_fattime();					/* Created time */
			ST_DWORD(dir+DIR_CrtTime, dw);
  4039a6:	f3c0 2907 	ubfx	r9, r0, #8, #8
			dir[DIR_Attr] = 0;					/* Reset attribute */
  4039aa:	2300      	movs	r3, #0
					res = FR_EXIST;
			}
		}
		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
			dw = get_fattime();					/* Created time */
			ST_DWORD(dir+DIR_CrtTime, dw);
  4039ac:	f885 8010 	strb.w	r8, [r5, #16]
  4039b0:	0e00      	lsrs	r0, r0, #24
			dir[DIR_Attr] = 0;					/* Reset attribute */
			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
			cl = LD_CLUST(dir);					/* Get start cluster */
			ST_CLUST(dir, 0);					/* cluster = 0 */
			dj.fs->wflag = 1;
  4039b2:	f04f 0c01 	mov.w	ip, #1
			if (cl) {							/* Remove the cluster chain if exist */
  4039b6:	ea52 4801 	orrs.w	r8, r2, r1, lsl #16
					res = FR_EXIST;
			}
		}
		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
			dw = get_fattime();					/* Created time */
			ST_DWORD(dir+DIR_CrtTime, dw);
  4039ba:	f885 900f 	strb.w	r9, [r5, #15]
  4039be:	7468      	strb	r0, [r5, #17]
			dir[DIR_Attr] = 0;					/* Reset attribute */
  4039c0:	72eb      	strb	r3, [r5, #11]
			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
  4039c2:	772b      	strb	r3, [r5, #28]
  4039c4:	776b      	strb	r3, [r5, #29]
  4039c6:	77ab      	strb	r3, [r5, #30]
  4039c8:	77eb      	strb	r3, [r5, #31]
			cl = LD_CLUST(dir);					/* Get start cluster */
			ST_CLUST(dir, 0);					/* cluster = 0 */
  4039ca:	76ab      	strb	r3, [r5, #26]
  4039cc:	76eb      	strb	r3, [r5, #27]
  4039ce:	752b      	strb	r3, [r5, #20]
  4039d0:	756b      	strb	r3, [r5, #21]
			dj.fs->wflag = 1;
  4039d2:	f886 c004 	strb.w	ip, [r6, #4]
			if (cl) {							/* Remove the cluster chain if exist */
  4039d6:	f43f af5f 	beq.w	403898 <f_open+0xb8>
	DWORD nxt;
#if _USE_ERASE
	DWORD scl = clst, ecl = clst, resion[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
  4039da:	45e0      	cmp	r8, ip
			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
			cl = LD_CLUST(dir);					/* Get start cluster */
			ST_CLUST(dir, 0);					/* cluster = 0 */
			dj.fs->wflag = 1;
			if (cl) {							/* Remove the cluster chain if exist */
				dw = dj.fs->winsect;
  4039dc:	f8d6 902c 	ldr.w	r9, [r6, #44]	; 0x2c
	DWORD nxt;
#if _USE_ERASE
	DWORD scl = clst, ecl = clst, resion[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
  4039e0:	d002      	beq.n	4039e8 <f_open+0x208>
  4039e2:	69b3      	ldr	r3, [r6, #24]
  4039e4:	4598      	cmp	r8, r3
  4039e6:	d327      	bcc.n	403a38 <f_open+0x258>
			mode |= FA__WRITTEN;
		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
		fp->dir_ptr = dir;
#if _FS_SHARE
		fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
		if (!fp->lockid) res = FR_INT_ERR;
  4039e8:	2002      	movs	r0, #2
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
	}

	LEAVE_FF(dj.fs, res);
}
  4039ea:	f50d 7d0f 	add.w	sp, sp, #572	; 0x23c
  4039ee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		Files[i].clu = dj->sclust;
		Files[i].idx = dj->index;
		Files[i].ctr = 0;
	}

	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
  4039f2:	2800      	cmp	r0, #0
  4039f4:	f47f af72 	bne.w	4038dc <f_open+0xfc>

	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
  4039f8:	f44f 7080 	mov.w	r0, #256	; 0x100
  4039fc:	e799      	b.n	403932 <f_open+0x152>
			Files[i].clu == dj->sclust &&
			Files[i].idx == dj->index) break;
	}

	if (i == _FS_SHARE) {				/* Not opened. Register it as new. */
		for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
  4039fe:	2301      	movs	r3, #1
		if (i == _FS_SHARE) return 0;	/* No space to register (int err) */
		Files[i].fs = dj->fs;
  403a00:	0059      	lsls	r1, r3, #1
  403a02:	eb01 0c03 	add.w	ip, r1, r3
  403a06:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
  403a0a:	eb02 000c 	add.w	r0, r2, ip
  403a0e:	f842 600c 	str.w	r6, [r2, ip]
		Files[i].clu = dj->sclust;
  403a12:	f8dd b01c 	ldr.w	fp, [sp, #28]
		Files[i].idx = dj->index;
  403a16:	f8bd a01a 	ldrh.w	sl, [sp, #26]

	if (i == _FS_SHARE) {				/* Not opened. Register it as new. */
		for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
		if (i == _FS_SHARE) return 0;	/* No space to register (int err) */
		Files[i].fs = dj->fs;
		Files[i].clu = dj->sclust;
  403a1a:	f8c0 b004 	str.w	fp, [r0, #4]
		Files[i].idx = dj->index;
		Files[i].ctr = 0;
  403a1e:	f04f 0c00 	mov.w	ip, #0
	if (i == _FS_SHARE) {				/* Not opened. Register it as new. */
		for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
		if (i == _FS_SHARE) return 0;	/* No space to register (int err) */
		Files[i].fs = dj->fs;
		Files[i].clu = dj->sclust;
		Files[i].idx = dj->index;
  403a22:	f8a0 a008 	strh.w	sl, [r0, #8]
		Files[i].ctr = 0;
  403a26:	f8a0 c00a 	strh.w	ip, [r0, #10]
	}

	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
  403a2a:	f1b8 0f00 	cmp.w	r8, #0
  403a2e:	d1e3      	bne.n	4039f8 <f_open+0x218>
  403a30:	4640      	mov	r0, r8
  403a32:	e77c      	b.n	40392e <f_open+0x14e>
			Files[i].clu == dj->sclust &&
			Files[i].idx == dj->index) break;
	}

	if (i == _FS_SHARE) {				/* Not opened. Register it as new. */
		for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
  403a34:	2302      	movs	r3, #2
  403a36:	e7e3      	b.n	403a00 <f_open+0x220>
  403a38:	4630      	mov	r0, r6
  403a3a:	4641      	mov	r1, r8
  403a3c:	4b0f      	ldr	r3, [pc, #60]	; (403a7c <f_open+0x29c>)
  403a3e:	4798      	blx	r3
			ST_CLUST(dir, 0);					/* cluster = 0 */
			dj.fs->wflag = 1;
			if (cl) {							/* Remove the cluster chain if exist */
				dw = dj.fs->winsect;
				res = remove_chain(dj.fs, cl);
				if (res == FR_OK) {
  403a40:	2800      	cmp	r0, #0
  403a42:	f47f aee6 	bne.w	403812 <f_open+0x32>
					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
  403a46:	9805      	ldr	r0, [sp, #20]
					res = move_window(dj.fs, dw);
  403a48:	4b0d      	ldr	r3, [pc, #52]	; (403a80 <f_open+0x2a0>)
			dj.fs->wflag = 1;
			if (cl) {							/* Remove the cluster chain if exist */
				dw = dj.fs->winsect;
				res = remove_chain(dj.fs, cl);
				if (res == FR_OK) {
					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
  403a4a:	f108 32ff 	add.w	r2, r8, #4294967295
					res = move_window(dj.fs, dw);
  403a4e:	4649      	mov	r1, r9
			dj.fs->wflag = 1;
			if (cl) {							/* Remove the cluster chain if exist */
				dw = dj.fs->winsect;
				res = remove_chain(dj.fs, cl);
				if (res == FR_OK) {
					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
  403a50:	60c2      	str	r2, [r0, #12]
					res = move_window(dj.fs, dw);
  403a52:	4798      	blx	r3
				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
					res = FR_DENIED;
			}
		}
	}
	if (res == FR_OK) {
  403a54:	2800      	cmp	r0, #0
  403a56:	f47f aedc 	bne.w	403812 <f_open+0x32>
  403a5a:	9e05      	ldr	r6, [sp, #20]
  403a5c:	e71c      	b.n	403898 <f_open+0xb8>
  403a5e:	bf00      	nop
  403a60:	00402829 	.word	0x00402829
  403a64:	004034c5 	.word	0x004034c5
  403a68:	004025a9 	.word	0x004025a9
  403a6c:	20000f68 	.word	0x20000f68
  403a70:	0040314d 	.word	0x0040314d
  403a74:	20000f70 	.word	0x20000f70
  403a78:	00402551 	.word	0x00402551
  403a7c:	00403459 	.word	0x00403459
  403a80:	00402619 	.word	0x00402619

00403a84 <f_read>:
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
  403a84:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  403a88:	469b      	mov	fp, r3
  403a8a:	4606      	mov	r6, r0
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE csect, *rbuff = buff;


	*br = 0;	/* Initialize byte counter */
  403a8c:	2300      	movs	r3, #0
  403a8e:	f8cb 3000 	str.w	r3, [fp]
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
  403a92:	b083      	sub	sp, #12
  403a94:	460d      	mov	r5, r1
	BYTE csect, *rbuff = buff;


	*br = 0;	/* Initialize byte counter */

	res = validate(fp->fs, fp->id);				/* Check validity */
  403a96:	6800      	ldr	r0, [r0, #0]
  403a98:	88b1      	ldrh	r1, [r6, #4]
  403a9a:	4b62      	ldr	r3, [pc, #392]	; (403c24 <f_read+0x1a0>)
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
  403a9c:	4614      	mov	r4, r2
	BYTE csect, *rbuff = buff;


	*br = 0;	/* Initialize byte counter */

	res = validate(fp->fs, fp->id);				/* Check validity */
  403a9e:	4798      	blx	r3
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
  403aa0:	b928      	cbnz	r0, 403aae <f_read+0x2a>
	if (fp->flag & FA__ERROR)					/* Aborted file? */
  403aa2:	79b3      	ldrb	r3, [r6, #6]
  403aa4:	061f      	lsls	r7, r3, #24
  403aa6:	d405      	bmi.n	403ab4 <f_read+0x30>
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
  403aa8:	07d8      	lsls	r0, r3, #31
  403aaa:	d407      	bmi.n	403abc <f_read+0x38>
		LEAVE_FF(fp->fs, FR_DENIED);
  403aac:	2007      	movs	r0, #7
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
}
  403aae:	b003      	add	sp, #12
  403ab0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	*br = 0;	/* Initialize byte counter */

	res = validate(fp->fs, fp->id);				/* Check validity */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)					/* Aborted file? */
		LEAVE_FF(fp->fs, FR_INT_ERR);
  403ab4:	2002      	movs	r0, #2
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
}
  403ab6:	b003      	add	sp, #12
  403ab8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)					/* Aborted file? */
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
  403abc:	68b1      	ldr	r1, [r6, #8]
  403abe:	68f7      	ldr	r7, [r6, #12]
  403ac0:	1a7f      	subs	r7, r7, r1
  403ac2:	42bc      	cmp	r4, r7
  403ac4:	bf38      	it	cc
  403ac6:	4627      	movcc	r7, r4
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
  403ac8:	2f00      	cmp	r7, #0
  403aca:	f000 80a8 	beq.w	403c1e <f_read+0x19a>
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
  403ace:	f3c1 0308 	ubfx	r3, r1, #0, #9
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
					fp->flag &= ~FA__DIRTY;
				}
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
  403ad2:	f8df 8158 	ldr.w	r8, [pc, #344]	; 403c2c <f_read+0x1a8>
			}
#if !_FS_TINY
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
#if !_FS_READONLY
				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
  403ad6:	f8df 9158 	ldr.w	r9, [pc, #344]	; 403c30 <f_read+0x1ac>
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
  403ada:	2b00      	cmp	r3, #0
  403adc:	d13e      	bne.n	403b5c <f_read+0xd8>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
  403ade:	6830      	ldr	r0, [r6, #0]
  403ae0:	7883      	ldrb	r3, [r0, #2]
  403ae2:	3b01      	subs	r3, #1
  403ae4:	ea03 2351 	and.w	r3, r3, r1, lsr #9
			if (!csect) {						/* On the cluster boundary? */
  403ae8:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
  403aec:	d04b      	beq.n	403b86 <f_read+0x102>
  403aee:	6972      	ldr	r2, [r6, #20]
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  403af0:	6981      	ldr	r1, [r0, #24]
static DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
  403af2:	f1a2 0c02 	sub.w	ip, r2, #2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  403af6:	3902      	subs	r1, #2
  403af8:	458c      	cmp	ip, r1
  403afa:	d271      	bcs.n	403be0 <f_read+0x15c>
	return clst * fs->csize + fs->database;
  403afc:	7882      	ldrb	r2, [r0, #2]
  403afe:	6a81      	ldr	r1, [r0, #40]	; 0x28
  403b00:	fb02 110c 	mla	r1, r2, ip, r1
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
				fp->clust = clst;				/* Update current cluster */
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
  403b04:	2900      	cmp	r1, #0
  403b06:	d06b      	beq.n	403be0 <f_read+0x15c>
			sect += csect;
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
			if (cc) {							/* Read maximum contiguous sectors directly */
  403b08:	0a7c      	lsrs	r4, r7, #9
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
				fp->clust = clst;				/* Update current cluster */
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
			sect += csect;
  403b0a:	eb01 0a03 	add.w	sl, r1, r3
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
			if (cc) {							/* Read maximum contiguous sectors directly */
  403b0e:	d043      	beq.n	403b98 <f_read+0x114>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
  403b10:	1919      	adds	r1, r3, r4
  403b12:	4291      	cmp	r1, r2
					cc = fp->fs->csize - csect;
  403b14:	bf88      	it	hi
  403b16:	ebc3 0402 	rsbhi	r4, r3, r2
				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
  403b1a:	b2e3      	uxtb	r3, r4
  403b1c:	7840      	ldrb	r0, [r0, #1]
  403b1e:	4629      	mov	r1, r5
  403b20:	4652      	mov	r2, sl
  403b22:	47c0      	blx	r8
					ABORT(fp->fs, FR_DISK_ERR);
  403b24:	79b3      	ldrb	r3, [r6, #6]
			sect += csect;
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
			if (cc) {							/* Read maximum contiguous sectors directly */
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
					cc = fp->fs->csize - csect;
				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
  403b26:	2800      	cmp	r0, #0
  403b28:	d161      	bne.n	403bee <f_read+0x16a>
#if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
#if _FS_TINY
				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
  403b2a:	065a      	lsls	r2, r3, #25
  403b2c:	d504      	bpl.n	403b38 <f_read+0xb4>
  403b2e:	69b3      	ldr	r3, [r6, #24]
  403b30:	ebca 0303 	rsb	r3, sl, r3
  403b34:	429c      	cmp	r4, r3
  403b36:	d85f      	bhi.n	403bf8 <f_read+0x174>
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
#endif
#endif
				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
  403b38:	0262      	lsls	r2, r4, #9
  403b3a:	68b1      	ldr	r1, [r6, #8]
  403b3c:	18ab      	adds	r3, r5, r2
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
  403b3e:	4411      	add	r1, r2
  403b40:	60b1      	str	r1, [r6, #8]
  403b42:	f8db 1000 	ldr.w	r1, [fp]
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
  403b46:	1abf      	subs	r7, r7, r2
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
  403b48:	4411      	add	r1, r2
  403b4a:	461d      	mov	r5, r3
  403b4c:	f8cb 1000 	str.w	r1, [fp]
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
  403b50:	d065      	beq.n	403c1e <f_read+0x19a>
  403b52:	68b1      	ldr	r1, [r6, #8]
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
  403b54:	f3c1 0308 	ubfx	r3, r1, #0, #9
  403b58:	2b00      	cmp	r3, #0
  403b5a:	d0c0      	beq.n	403ade <f_read+0x5a>
					ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
		}
		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
  403b5c:	f5c3 7200 	rsb	r2, r3, #512	; 0x200
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#else
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
  403b60:	f103 0428 	add.w	r4, r3, #40	; 0x28
  403b64:	42ba      	cmp	r2, r7
  403b66:	bf28      	it	cs
  403b68:	463a      	movcs	r2, r7
  403b6a:	4434      	add	r4, r6
  403b6c:	462b      	mov	r3, r5
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
  403b6e:	2a00      	cmp	r2, #0
  403b70:	d0e5      	beq.n	403b3e <f_read+0xba>
  403b72:	18ab      	adds	r3, r5, r2
  403b74:	4629      	mov	r1, r5
		*d++ = *s++;
  403b76:	f814 5b01 	ldrb.w	r5, [r4], #1
  403b7a:	f801 5b01 	strb.w	r5, [r1], #1
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
  403b7e:	4299      	cmp	r1, r3
  403b80:	d1f9      	bne.n	403b76 <f_read+0xf2>
  403b82:	68b1      	ldr	r1, [r6, #8]
  403b84:	e7db      	b.n	403b3e <f_read+0xba>
	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
			if (!csect) {						/* On the cluster boundary? */
				if (fp->fptr == 0) {			/* On the top of the file? */
  403b86:	bb29      	cbnz	r1, 403bd4 <f_read+0x150>
					clst = fp->sclust;			/* Follow from the origin */
  403b88:	6932      	ldr	r2, [r6, #16]
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
				}
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
  403b8a:	2a01      	cmp	r2, #1
  403b8c:	d928      	bls.n	403be0 <f_read+0x15c>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
  403b8e:	1c51      	adds	r1, r2, #1
  403b90:	d02c      	beq.n	403bec <f_read+0x168>
  403b92:	6830      	ldr	r0, [r6, #0]
				fp->clust = clst;				/* Update current cluster */
  403b94:	6172      	str	r2, [r6, #20]
  403b96:	e7ab      	b.n	403af0 <f_read+0x6c>
#endif
				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
				continue;
			}
#if !_FS_TINY
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
  403b98:	69b2      	ldr	r2, [r6, #24]
  403b9a:	4552      	cmp	r2, sl
  403b9c:	d014      	beq.n	403bc8 <f_read+0x144>
#if !_FS_READONLY
				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
  403b9e:	79b3      	ldrb	r3, [r6, #6]
  403ba0:	065b      	lsls	r3, r3, #25
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
  403ba2:	f106 0428 	add.w	r4, r6, #40	; 0x28
				continue;
			}
#if !_FS_TINY
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
#if !_FS_READONLY
				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
  403ba6:	d509      	bpl.n	403bbc <f_read+0x138>
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
  403ba8:	2301      	movs	r3, #1
  403baa:	7840      	ldrb	r0, [r0, #1]
  403bac:	4621      	mov	r1, r4
  403bae:	47c8      	blx	r9
						ABORT(fp->fs, FR_DISK_ERR);
  403bb0:	79b3      	ldrb	r3, [r6, #6]
			}
#if !_FS_TINY
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
#if !_FS_READONLY
				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
  403bb2:	b9e0      	cbnz	r0, 403bee <f_read+0x16a>
						ABORT(fp->fs, FR_DISK_ERR);
					fp->flag &= ~FA__DIRTY;
  403bb4:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  403bb8:	6830      	ldr	r0, [r6, #0]
  403bba:	71b3      	strb	r3, [r6, #6]
				}
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
  403bbc:	7840      	ldrb	r0, [r0, #1]
  403bbe:	4621      	mov	r1, r4
  403bc0:	4652      	mov	r2, sl
  403bc2:	2301      	movs	r3, #1
  403bc4:	47c0      	blx	r8
  403bc6:	b988      	cbnz	r0, 403bec <f_read+0x168>
  403bc8:	68b1      	ldr	r1, [r6, #8]
					ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
  403bca:	f8c6 a018 	str.w	sl, [r6, #24]
  403bce:	f3c1 0308 	ubfx	r3, r1, #0, #9
  403bd2:	e7c3      	b.n	403b5c <f_read+0xd8>
#if _USE_FASTSEEK
					if (fp->cltbl)
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
  403bd4:	6971      	ldr	r1, [r6, #20]
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  403bd6:	2901      	cmp	r1, #1
  403bd8:	d902      	bls.n	403be0 <f_read+0x15c>
  403bda:	6982      	ldr	r2, [r0, #24]
  403bdc:	4291      	cmp	r1, r2
  403bde:	d318      	bcc.n	403c12 <f_read+0x18e>
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
				fp->clust = clst;				/* Update current cluster */
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
  403be0:	79b3      	ldrb	r3, [r6, #6]
  403be2:	f063 037f 	orn	r3, r3, #127	; 0x7f
  403be6:	71b3      	strb	r3, [r6, #6]
  403be8:	2002      	movs	r0, #2
  403bea:	e760      	b.n	403aae <f_read+0x2a>
						ABORT(fp->fs, FR_DISK_ERR);
					fp->flag &= ~FA__DIRTY;
				}
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
					ABORT(fp->fs, FR_DISK_ERR);
  403bec:	79b3      	ldrb	r3, [r6, #6]
  403bee:	f063 037f 	orn	r3, r3, #127	; 0x7f
  403bf2:	71b3      	strb	r3, [r6, #6]
  403bf4:	2001      	movs	r0, #1
  403bf6:	e75a      	b.n	403aae <f_read+0x2a>
#if _FS_TINY
				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
  403bf8:	eb05 2343 	add.w	r3, r5, r3, lsl #9
  403bfc:	f503 7000 	add.w	r0, r3, #512	; 0x200
  403c00:	f106 0228 	add.w	r2, r6, #40	; 0x28
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
  403c04:	f812 1b01 	ldrb.w	r1, [r2], #1
  403c08:	f803 1b01 	strb.w	r1, [r3], #1
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
  403c0c:	4283      	cmp	r3, r0
  403c0e:	d1f9      	bne.n	403c04 <f_read+0x180>
  403c10:	e792      	b.n	403b38 <f_read+0xb4>
  403c12:	9301      	str	r3, [sp, #4]
  403c14:	4a04      	ldr	r2, [pc, #16]	; (403c28 <f_read+0x1a4>)
  403c16:	4790      	blx	r2
  403c18:	9b01      	ldr	r3, [sp, #4]
  403c1a:	4602      	mov	r2, r0
  403c1c:	e7b5      	b.n	403b8a <f_read+0x106>
#else
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
  403c1e:	2000      	movs	r0, #0
  403c20:	e745      	b.n	403aae <f_read+0x2a>
  403c22:	bf00      	nop
  403c24:	00402775 	.word	0x00402775
  403c28:	00402b59 	.word	0x00402b59
  403c2c:	004023f9 	.word	0x004023f9
  403c30:	0040246d 	.word	0x0040246d

00403c34 <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL *fp		/* Pointer to the file object */
)
{
  403c34:	b538      	push	{r3, r4, r5, lr}
  403c36:	4604      	mov	r4, r0
	FRESULT res;
	DWORD tim;
	BYTE *dir;


	res = validate(fp->fs, fp->id);		/* Check validity of the object */
  403c38:	4b27      	ldr	r3, [pc, #156]	; (403cd8 <f_sync+0xa4>)
  403c3a:	6800      	ldr	r0, [r0, #0]
  403c3c:	88a1      	ldrh	r1, [r4, #4]
  403c3e:	4798      	blx	r3
	if (res == FR_OK) {
  403c40:	b9d0      	cbnz	r0, 403c78 <f_sync+0x44>
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
  403c42:	79a2      	ldrb	r2, [r4, #6]
  403c44:	f002 0320 	and.w	r3, r2, #32
  403c48:	f003 00ff 	and.w	r0, r3, #255	; 0xff
  403c4c:	b1a3      	cbz	r3, 403c78 <f_sync+0x44>
#if !_FS_TINY	/* Write-back dirty buffer */
			if (fp->flag & FA__DIRTY) {
  403c4e:	0653      	lsls	r3, r2, #25
  403c50:	d50d      	bpl.n	403c6e <f_sync+0x3a>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
  403c52:	4621      	mov	r1, r4
  403c54:	69a2      	ldr	r2, [r4, #24]
  403c56:	f851 3b28 	ldr.w	r3, [r1], #40
  403c5a:	4d20      	ldr	r5, [pc, #128]	; (403cdc <f_sync+0xa8>)
  403c5c:	7858      	ldrb	r0, [r3, #1]
  403c5e:	2301      	movs	r3, #1
  403c60:	47a8      	blx	r5
  403c62:	2800      	cmp	r0, #0
  403c64:	d136      	bne.n	403cd4 <f_sync+0xa0>
					LEAVE_FF(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
  403c66:	79a3      	ldrb	r3, [r4, #6]
  403c68:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  403c6c:	71a3      	strb	r3, [r4, #6]
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
  403c6e:	6820      	ldr	r0, [r4, #0]
  403c70:	69e1      	ldr	r1, [r4, #28]
  403c72:	4b1b      	ldr	r3, [pc, #108]	; (403ce0 <f_sync+0xac>)
  403c74:	4798      	blx	r3
			if (res == FR_OK) {
  403c76:	b100      	cbz	r0, 403c7a <f_sync+0x46>
			}
		}
	}

	LEAVE_FF(fp->fs, res);
}
  403c78:	bd38      	pop	{r3, r4, r5, pc}
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
			if (res == FR_OK) {
				dir = fp->dir_ptr;
  403c7a:	6a25      	ldr	r5, [r4, #32]
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
				ST_CLUST(dir, fp->sclust);					/* Update start cluster */
				tim = get_fattime();						/* Update updated time */
  403c7c:	4a19      	ldr	r2, [pc, #100]	; (403ce4 <f_sync+0xb0>)
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
			if (res == FR_OK) {
				dir = fp->dir_ptr;
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
  403c7e:	7aeb      	ldrb	r3, [r5, #11]
  403c80:	f043 0320 	orr.w	r3, r3, #32
  403c84:	72eb      	strb	r3, [r5, #11]
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
  403c86:	68e3      	ldr	r3, [r4, #12]
  403c88:	772b      	strb	r3, [r5, #28]
  403c8a:	89a3      	ldrh	r3, [r4, #12]
  403c8c:	0a1b      	lsrs	r3, r3, #8
  403c8e:	776b      	strb	r3, [r5, #29]
  403c90:	89e3      	ldrh	r3, [r4, #14]
  403c92:	77ab      	strb	r3, [r5, #30]
  403c94:	7be3      	ldrb	r3, [r4, #15]
  403c96:	77eb      	strb	r3, [r5, #31]
				ST_CLUST(dir, fp->sclust);					/* Update start cluster */
  403c98:	6923      	ldr	r3, [r4, #16]
  403c9a:	76ab      	strb	r3, [r5, #26]
  403c9c:	8a23      	ldrh	r3, [r4, #16]
  403c9e:	0a1b      	lsrs	r3, r3, #8
  403ca0:	76eb      	strb	r3, [r5, #27]
  403ca2:	8a63      	ldrh	r3, [r4, #18]
  403ca4:	752b      	strb	r3, [r5, #20]
  403ca6:	8a63      	ldrh	r3, [r4, #18]
  403ca8:	0a1b      	lsrs	r3, r3, #8
  403caa:	756b      	strb	r3, [r5, #21]
				tim = get_fattime();						/* Update updated time */
  403cac:	4790      	blx	r2
				ST_DWORD(dir+DIR_WrtTime, tim);
  403cae:	f3c0 2107 	ubfx	r1, r0, #8, #8
  403cb2:	0c02      	lsrs	r2, r0, #16
  403cb4:	0e03      	lsrs	r3, r0, #24
  403cb6:	75e9      	strb	r1, [r5, #23]
  403cb8:	762a      	strb	r2, [r5, #24]
  403cba:	75a8      	strb	r0, [r5, #22]
  403cbc:	766b      	strb	r3, [r5, #25]
				fp->flag &= ~FA__WRITTEN;
  403cbe:	79a0      	ldrb	r0, [r4, #6]
				fp->fs->wflag = 1;
  403cc0:	6823      	ldr	r3, [r4, #0]
				res = sync(fp->fs);
  403cc2:	4a09      	ldr	r2, [pc, #36]	; (403ce8 <f_sync+0xb4>)
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
				ST_CLUST(dir, fp->sclust);					/* Update start cluster */
				tim = get_fattime();						/* Update updated time */
				ST_DWORD(dir+DIR_WrtTime, tim);
				fp->flag &= ~FA__WRITTEN;
  403cc4:	f020 0020 	bic.w	r0, r0, #32
				fp->fs->wflag = 1;
  403cc8:	2101      	movs	r1, #1
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
				ST_CLUST(dir, fp->sclust);					/* Update start cluster */
				tim = get_fattime();						/* Update updated time */
				ST_DWORD(dir+DIR_WrtTime, tim);
				fp->flag &= ~FA__WRITTEN;
  403cca:	71a0      	strb	r0, [r4, #6]
				fp->fs->wflag = 1;
  403ccc:	7119      	strb	r1, [r3, #4]
				res = sync(fp->fs);
  403cce:	6820      	ldr	r0, [r4, #0]
  403cd0:	4790      	blx	r2
  403cd2:	bd38      	pop	{r3, r4, r5, pc}
	if (res == FR_OK) {
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
#if !_FS_TINY	/* Write-back dirty buffer */
			if (fp->flag & FA__DIRTY) {
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
					LEAVE_FF(fp->fs, FR_DISK_ERR);
  403cd4:	2001      	movs	r0, #1
  403cd6:	e7cf      	b.n	403c78 <f_sync+0x44>
  403cd8:	00402775 	.word	0x00402775
  403cdc:	0040246d 	.word	0x0040246d
  403ce0:	00402619 	.word	0x00402619
  403ce4:	00402551 	.word	0x00402551
  403ce8:	0040269d 	.word	0x0040269d

00403cec <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
  403cec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	res = validate(fs, fp->id);
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
	LEAVE_FF(fs, res);

#else
	res = f_sync(fp);		/* Flush cached data */
  403cee:	4b10      	ldr	r3, [pc, #64]	; (403d30 <f_close+0x44>)
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
  403cf0:	4604      	mov	r4, r0
	res = validate(fs, fp->id);
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
	LEAVE_FF(fs, res);

#else
	res = f_sync(fp);		/* Flush cached data */
  403cf2:	4798      	blx	r3
#if _FS_SHARE
	if (res == FR_OK) {		/* Decrement open counter */
  403cf4:	b998      	cbnz	r0, 403d1e <f_close+0x32>
{
	WORD n;
	FRESULT res;


	if (--i < _FS_SHARE) {
  403cf6:	6a63      	ldr	r3, [r4, #36]	; 0x24
  403cf8:	3b01      	subs	r3, #1
  403cfa:	2b02      	cmp	r3, #2
  403cfc:	d810      	bhi.n	403d20 <f_close+0x34>
		n = Files[i].ctr;
  403cfe:	005d      	lsls	r5, r3, #1
  403d00:	490c      	ldr	r1, [pc, #48]	; (403d34 <f_close+0x48>)
  403d02:	18ea      	adds	r2, r5, r3
  403d04:	eb01 0282 	add.w	r2, r1, r2, lsl #2
  403d08:	3208      	adds	r2, #8
  403d0a:	8856      	ldrh	r6, [r2, #2]
		if (n == 0x100) n = 0;
		if (n) n--;
  403d0c:	f426 7780 	bic.w	r7, r6, #256	; 0x100
  403d10:	b147      	cbz	r7, 403d24 <f_close+0x38>
  403d12:	3e01      	subs	r6, #1
  403d14:	b2b6      	uxth	r6, r6
		Files[i].ctr = n;
  403d16:	8056      	strh	r6, [r2, #2]
		if (!n) Files[i].fs = 0;
  403d18:	b12e      	cbz	r6, 403d26 <f_close+0x3a>
#else
		res = dec_lock(fp->lockid);
#endif
	}
#endif
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
  403d1a:	2300      	movs	r3, #0
  403d1c:	6023      	str	r3, [r4, #0]
	return res;
#endif
}
  403d1e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (n) n--;
		Files[i].ctr = n;
		if (!n) Files[i].fs = 0;
		res = FR_OK;
	} else {
		res = FR_INT_ERR;
  403d20:	2002      	movs	r0, #2
  403d22:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	if (--i < _FS_SHARE) {
		n = Files[i].ctr;
		if (n == 0x100) n = 0;
		if (n) n--;
		Files[i].ctr = n;
  403d24:	8050      	strh	r0, [r2, #2]
		if (!n) Files[i].fs = 0;
  403d26:	442b      	add	r3, r5
  403d28:	009b      	lsls	r3, r3, #2
  403d2a:	2200      	movs	r2, #0
  403d2c:	50ca      	str	r2, [r1, r3]
  403d2e:	e7f4      	b.n	403d1a <f_close+0x2e>
  403d30:	00403c35 	.word	0x00403c35
  403d34:	20000f68 	.word	0x20000f68

00403d38 <ff_convert>:
)
{
	WCHAR c;


	if (src < 0x80) {	/* ASCII */
  403d38:	287f      	cmp	r0, #127	; 0x7f

WCHAR ff_convert (	/* Converted character, Returns zero on error */
	WCHAR	src,	/* Character code to be converted */
	UINT	dir		/* 0: Unicode to OEMCP, 1: OEMCP to Unicode */
)
{
  403d3a:	b410      	push	{r4}
	WCHAR c;


	if (src < 0x80) {	/* ASCII */
  403d3c:	d90e      	bls.n	403d5c <ff_convert+0x24>
		c = src;

	} else {
		if (dir) {		/* OEMCP to Unicode */
  403d3e:	b981      	cbnz	r1, 403d62 <ff_convert+0x2a>
  403d40:	4b0e      	ldr	r3, [pc, #56]	; (403d7c <ff_convert+0x44>)
  403d42:	e001      	b.n	403d48 <ff_convert+0x10>
			c = (src >= 0x100) ? 0 : Tbl[src - 0x80];

		} else {		/* Unicode to OEMCP */
			for (c = 0; c < 0x80; c++) {
  403d44:	2980      	cmp	r1, #128	; 0x80
  403d46:	d015      	beq.n	403d74 <ff_convert+0x3c>
				if (src == Tbl[c]) break;
  403d48:	f833 2f02 	ldrh.w	r2, [r3, #2]!
  403d4c:	4282      	cmp	r2, r0
  403d4e:	b28c      	uxth	r4, r1
  403d50:	f101 0101 	add.w	r1, r1, #1
  403d54:	d1f6      	bne.n	403d44 <ff_convert+0xc>
  403d56:	f104 0080 	add.w	r0, r4, #128	; 0x80
  403d5a:	b280      	uxth	r0, r0
			c = (c + 0x80) & 0xFF;
		}
	}

	return c;
}
  403d5c:	f85d 4b04 	ldr.w	r4, [sp], #4
  403d60:	4770      	bx	lr
	if (src < 0x80) {	/* ASCII */
		c = src;

	} else {
		if (dir) {		/* OEMCP to Unicode */
			c = (src >= 0x100) ? 0 : Tbl[src - 0x80];
  403d62:	28ff      	cmp	r0, #255	; 0xff
  403d64:	d806      	bhi.n	403d74 <ff_convert+0x3c>
  403d66:	3880      	subs	r0, #128	; 0x80
  403d68:	4b05      	ldr	r3, [pc, #20]	; (403d80 <ff_convert+0x48>)
			c = (c + 0x80) & 0xFF;
		}
	}

	return c;
}
  403d6a:	f85d 4b04 	ldr.w	r4, [sp], #4
	if (src < 0x80) {	/* ASCII */
		c = src;

	} else {
		if (dir) {		/* OEMCP to Unicode */
			c = (src >= 0x100) ? 0 : Tbl[src - 0x80];
  403d6e:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
			c = (c + 0x80) & 0xFF;
		}
	}

	return c;
}
  403d72:	4770      	bx	lr
	if (src < 0x80) {	/* ASCII */
		c = src;

	} else {
		if (dir) {		/* OEMCP to Unicode */
			c = (src >= 0x100) ? 0 : Tbl[src - 0x80];
  403d74:	2000      	movs	r0, #0
			c = (c + 0x80) & 0xFF;
		}
	}

	return c;
}
  403d76:	f85d 4b04 	ldr.w	r4, [sp], #4
  403d7a:	4770      	bx	lr
  403d7c:	00406dc2 	.word	0x00406dc2
  403d80:	00406dc4 	.word	0x00406dc4

00403d84 <ff_wtoupper>:
	static const WCHAR tbl_lower[] = { 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0xA1, 0x00A2, 0x00A3, 0x00A5, 0x00AC, 0x00AF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0x0FF, 0x101, 0x103, 0x105, 0x107, 0x109, 0x10B, 0x10D, 0x10F, 0x111, 0x113, 0x115, 0x117, 0x119, 0x11B, 0x11D, 0x11F, 0x121, 0x123, 0x125, 0x127, 0x129, 0x12B, 0x12D, 0x12F, 0x131, 0x133, 0x135, 0x137, 0x13A, 0x13C, 0x13E, 0x140, 0x142, 0x144, 0x146, 0x148, 0x14B, 0x14D, 0x14F, 0x151, 0x153, 0x155, 0x157, 0x159, 0x15B, 0x15D, 0x15F, 0x161, 0x163, 0x165, 0x167, 0x169, 0x16B, 0x16D, 0x16F, 0x171, 0x173, 0x175, 0x177, 0x17A, 0x17C, 0x17E, 0x192, 0x3B1, 0x3B2, 0x3B3, 0x3B4, 0x3B5, 0x3B6, 0x3B7, 0x3B8, 0x3B9, 0x3BA, 0x3BB, 0x3BC, 0x3BD, 0x3BE, 0x3BF, 0x3C0, 0x3C1, 0x3C3, 0x3C4, 0x3C5, 0x3C6, 0x3C7, 0x3C8, 0x3C9, 0x3CA, 0x430, 0x431, 0x432, 0x433, 0x434, 0x435, 0x436, 0x437, 0x438, 0x439, 0x43A, 0x43B, 0x43C, 0x43D, 0x43E, 0x43F, 0x440, 0x441, 0x442, 0x443, 0x444, 0x445, 0x446, 0x447, 0x448, 0x449, 0x44A, 0x44B, 0x44C, 0x44D, 0x44E, 0x44F, 0x451, 0x452, 0x453, 0x454, 0x455, 0x456, 0x457, 0x458, 0x459, 0x45A, 0x45B, 0x45C, 0x45E, 0x45F, 0x2170, 0x2171, 0x2172, 0x2173, 0x2174, 0x2175, 0x2176, 0x2177, 0x2178, 0x2179, 0x217A, 0x217B, 0x217C, 0x217D, 0x217E, 0x217F, 0xFF41, 0xFF42, 0xFF43, 0xFF44, 0xFF45, 0xFF46, 0xFF47, 0xFF48, 0xFF49, 0xFF4A, 0xFF4B, 0xFF4C, 0xFF4D, 0xFF4E, 0xFF4F, 0xFF50, 0xFF51, 0xFF52, 0xFF53, 0xFF54, 0xFF55, 0xFF56, 0xFF57, 0xFF58, 0xFF59, 0xFF5A, 0 };
	static const WCHAR tbl_upper[] = { 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x21, 0xFFE0, 0xFFE1, 0xFFE5, 0xFFE2, 0xFFE3, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0x178, 0x100, 0x102, 0x104, 0x106, 0x108, 0x10A, 0x10C, 0x10E, 0x110, 0x112, 0x114, 0x116, 0x118, 0x11A, 0x11C, 0x11E, 0x120, 0x122, 0x124, 0x126, 0x128, 0x12A, 0x12C, 0x12E, 0x130, 0x132, 0x134, 0x136, 0x139, 0x13B, 0x13D, 0x13F, 0x141, 0x143, 0x145, 0x147, 0x14A, 0x14C, 0x14E, 0x150, 0x152, 0x154, 0x156, 0x158, 0x15A, 0x15C, 0x15E, 0x160, 0x162, 0x164, 0x166, 0x168, 0x16A, 0x16C, 0x16E, 0x170, 0x172, 0x174, 0x176, 0x179, 0x17B, 0x17D, 0x191, 0x391, 0x392, 0x393, 0x394, 0x395, 0x396, 0x397, 0x398, 0x399, 0x39A, 0x39B, 0x39C, 0x39D, 0x39E, 0x39F, 0x3A0, 0x3A1, 0x3A3, 0x3A4, 0x3A5, 0x3A6, 0x3A7, 0x3A8, 0x3A9, 0x3AA, 0x410, 0x411, 0x412, 0x413, 0x414, 0x415, 0x416, 0x417, 0x418, 0x419, 0x41A, 0x41B, 0x41C, 0x41D, 0x41E, 0x41F, 0x420, 0x421, 0x422, 0x423, 0x424, 0x425, 0x426, 0x427, 0x428, 0x429, 0x42A, 0x42B, 0x42C, 0x42D, 0x42E, 0x42F, 0x401, 0x402, 0x403, 0x404, 0x405, 0x406, 0x407, 0x408, 0x409, 0x40A, 0x40B, 0x40C, 0x40E, 0x40F, 0x2160, 0x2161, 0x2162, 0x2163, 0x2164, 0x2165, 0x2166, 0x2167, 0x2168, 0x2169, 0x216A, 0x216B, 0x216C, 0x216D, 0x216E, 0x216F, 0xFF21, 0xFF22, 0xFF23, 0xFF24, 0xFF25, 0xFF26, 0xFF27, 0xFF28, 0xFF29, 0xFF2A, 0xFF2B, 0xFF2C, 0xFF2D, 0xFF2E, 0xFF2F, 0xFF30, 0xFF31, 0xFF32, 0xFF33, 0xFF34, 0xFF35, 0xFF36, 0xFF37, 0xFF38, 0xFF39, 0xFF3A, 0 };
	int i;


	for (i = 0; tbl_lower[i] && chr != tbl_lower[i]; i++) ;
  403d84:	2861      	cmp	r0, #97	; 0x61
  403d86:	d00a      	beq.n	403d9e <ff_wtoupper+0x1a>
  403d88:	4907      	ldr	r1, [pc, #28]	; (403da8 <ff_wtoupper+0x24>)
  403d8a:	2200      	movs	r2, #0
  403d8c:	e001      	b.n	403d92 <ff_wtoupper+0xe>
  403d8e:	4283      	cmp	r3, r0
  403d90:	d006      	beq.n	403da0 <ff_wtoupper+0x1c>
  403d92:	f831 3f02 	ldrh.w	r3, [r1, #2]!
  403d96:	3201      	adds	r2, #1
  403d98:	2b00      	cmp	r3, #0
  403d9a:	d1f8      	bne.n	403d8e <ff_wtoupper+0xa>

	return tbl_lower[i] ? tbl_upper[i] : chr;
}
  403d9c:	4770      	bx	lr
	static const WCHAR tbl_lower[] = { 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0xA1, 0x00A2, 0x00A3, 0x00A5, 0x00AC, 0x00AF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0x0FF, 0x101, 0x103, 0x105, 0x107, 0x109, 0x10B, 0x10D, 0x10F, 0x111, 0x113, 0x115, 0x117, 0x119, 0x11B, 0x11D, 0x11F, 0x121, 0x123, 0x125, 0x127, 0x129, 0x12B, 0x12D, 0x12F, 0x131, 0x133, 0x135, 0x137, 0x13A, 0x13C, 0x13E, 0x140, 0x142, 0x144, 0x146, 0x148, 0x14B, 0x14D, 0x14F, 0x151, 0x153, 0x155, 0x157, 0x159, 0x15B, 0x15D, 0x15F, 0x161, 0x163, 0x165, 0x167, 0x169, 0x16B, 0x16D, 0x16F, 0x171, 0x173, 0x175, 0x177, 0x17A, 0x17C, 0x17E, 0x192, 0x3B1, 0x3B2, 0x3B3, 0x3B4, 0x3B5, 0x3B6, 0x3B7, 0x3B8, 0x3B9, 0x3BA, 0x3BB, 0x3BC, 0x3BD, 0x3BE, 0x3BF, 0x3C0, 0x3C1, 0x3C3, 0x3C4, 0x3C5, 0x3C6, 0x3C7, 0x3C8, 0x3C9, 0x3CA, 0x430, 0x431, 0x432, 0x433, 0x434, 0x435, 0x436, 0x437, 0x438, 0x439, 0x43A, 0x43B, 0x43C, 0x43D, 0x43E, 0x43F, 0x440, 0x441, 0x442, 0x443, 0x444, 0x445, 0x446, 0x447, 0x448, 0x449, 0x44A, 0x44B, 0x44C, 0x44D, 0x44E, 0x44F, 0x451, 0x452, 0x453, 0x454, 0x455, 0x456, 0x457, 0x458, 0x459, 0x45A, 0x45B, 0x45C, 0x45E, 0x45F, 0x2170, 0x2171, 0x2172, 0x2173, 0x2174, 0x2175, 0x2176, 0x2177, 0x2178, 0x2179, 0x217A, 0x217B, 0x217C, 0x217D, 0x217E, 0x217F, 0xFF41, 0xFF42, 0xFF43, 0xFF44, 0xFF45, 0xFF46, 0xFF47, 0xFF48, 0xFF49, 0xFF4A, 0xFF4B, 0xFF4C, 0xFF4D, 0xFF4E, 0xFF4F, 0xFF50, 0xFF51, 0xFF52, 0xFF53, 0xFF54, 0xFF55, 0xFF56, 0xFF57, 0xFF58, 0xFF59, 0xFF5A, 0 };
	static const WCHAR tbl_upper[] = { 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x21, 0xFFE0, 0xFFE1, 0xFFE5, 0xFFE2, 0xFFE3, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0x178, 0x100, 0x102, 0x104, 0x106, 0x108, 0x10A, 0x10C, 0x10E, 0x110, 0x112, 0x114, 0x116, 0x118, 0x11A, 0x11C, 0x11E, 0x120, 0x122, 0x124, 0x126, 0x128, 0x12A, 0x12C, 0x12E, 0x130, 0x132, 0x134, 0x136, 0x139, 0x13B, 0x13D, 0x13F, 0x141, 0x143, 0x145, 0x147, 0x14A, 0x14C, 0x14E, 0x150, 0x152, 0x154, 0x156, 0x158, 0x15A, 0x15C, 0x15E, 0x160, 0x162, 0x164, 0x166, 0x168, 0x16A, 0x16C, 0x16E, 0x170, 0x172, 0x174, 0x176, 0x179, 0x17B, 0x17D, 0x191, 0x391, 0x392, 0x393, 0x394, 0x395, 0x396, 0x397, 0x398, 0x399, 0x39A, 0x39B, 0x39C, 0x39D, 0x39E, 0x39F, 0x3A0, 0x3A1, 0x3A3, 0x3A4, 0x3A5, 0x3A6, 0x3A7, 0x3A8, 0x3A9, 0x3AA, 0x410, 0x411, 0x412, 0x413, 0x414, 0x415, 0x416, 0x417, 0x418, 0x419, 0x41A, 0x41B, 0x41C, 0x41D, 0x41E, 0x41F, 0x420, 0x421, 0x422, 0x423, 0x424, 0x425, 0x426, 0x427, 0x428, 0x429, 0x42A, 0x42B, 0x42C, 0x42D, 0x42E, 0x42F, 0x401, 0x402, 0x403, 0x404, 0x405, 0x406, 0x407, 0x408, 0x409, 0x40A, 0x40B, 0x40C, 0x40E, 0x40F, 0x2160, 0x2161, 0x2162, 0x2163, 0x2164, 0x2165, 0x2166, 0x2167, 0x2168, 0x2169, 0x216A, 0x216B, 0x216C, 0x216D, 0x216E, 0x216F, 0xFF21, 0xFF22, 0xFF23, 0xFF24, 0xFF25, 0xFF26, 0xFF27, 0xFF28, 0xFF29, 0xFF2A, 0xFF2B, 0xFF2C, 0xFF2D, 0xFF2E, 0xFF2F, 0xFF30, 0xFF31, 0xFF32, 0xFF33, 0xFF34, 0xFF35, 0xFF36, 0xFF37, 0xFF38, 0xFF39, 0xFF3A, 0 };
	int i;


	for (i = 0; tbl_lower[i] && chr != tbl_lower[i]; i++) ;
  403d9e:	2200      	movs	r2, #0

	return tbl_lower[i] ? tbl_upper[i] : chr;
  403da0:	4b02      	ldr	r3, [pc, #8]	; (403dac <ff_wtoupper+0x28>)
  403da2:	f833 0012 	ldrh.w	r0, [r3, r2, lsl #1]
}
  403da6:	4770      	bx	lr
  403da8:	00406be4 	.word	0x00406be4
  403dac:	00406ec4 	.word	0x00406ec4

00403db0 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
  403db0:	6843      	ldr	r3, [r0, #4]

	pxNewListItem->pxNext = pxIndex->pxNext;
  403db2:	685a      	ldr	r2, [r3, #4]
  403db4:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxPrevious = pxList->pxIndex;
  403db6:	6842      	ldr	r2, [r0, #4]
  403db8:	608a      	str	r2, [r1, #8]
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
  403dba:	685a      	ldr	r2, [r3, #4]
  403dbc:	6091      	str	r1, [r2, #8]
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
  403dbe:	6059      	str	r1, [r3, #4]
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
  403dc0:	6041      	str	r1, [r0, #4]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
  403dc2:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
  403dc4:	6803      	ldr	r3, [r0, #0]
  403dc6:	3301      	adds	r3, #1
  403dc8:	6003      	str	r3, [r0, #0]
  403dca:	4770      	bx	lr

00403dcc <vListInsert>:
}
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
  403dcc:	b410      	push	{r4}
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
  403dce:	680c      	ldr	r4, [r1, #0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
  403dd0:	1c63      	adds	r3, r4, #1
  403dd2:	d016      	beq.n	403e02 <vListInsert+0x36>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
  403dd4:	68c3      	ldr	r3, [r0, #12]
  403dd6:	681a      	ldr	r2, [r3, #0]
  403dd8:	4294      	cmp	r4, r2
  403dda:	f100 0308 	add.w	r3, r0, #8
  403dde:	d304      	bcc.n	403dea <vListInsert+0x1e>
  403de0:	685b      	ldr	r3, [r3, #4]
  403de2:	685a      	ldr	r2, [r3, #4]
  403de4:	6812      	ldr	r2, [r2, #0]
  403de6:	4294      	cmp	r4, r2
  403de8:	d2fa      	bcs.n	403de0 <vListInsert+0x14>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
  403dea:	685a      	ldr	r2, [r3, #4]
  403dec:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
  403dee:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious = pxIterator;
  403df0:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
  403df2:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
  403df4:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
  403df6:	6803      	ldr	r3, [r0, #0]
}
  403df8:	f85d 4b04 	ldr.w	r4, [sp], #4

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
  403dfc:	3301      	adds	r3, #1
  403dfe:	6003      	str	r3, [r0, #0]
}
  403e00:	4770      	bx	lr
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
	{
		pxIterator = pxList->xListEnd.pxPrevious;
  403e02:	6903      	ldr	r3, [r0, #16]
  403e04:	e7f1      	b.n	403dea <vListInsert+0x1e>
  403e06:	bf00      	nop

00403e08 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
  403e08:	6843      	ldr	r3, [r0, #4]
  403e0a:	6882      	ldr	r2, [r0, #8]
  403e0c:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
  403e0e:	6883      	ldr	r3, [r0, #8]
  403e10:	6842      	ldr	r2, [r0, #4]
  403e12:	605a      	str	r2, [r3, #4]

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
  403e14:	6903      	ldr	r3, [r0, #16]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
  403e16:	685a      	ldr	r2, [r3, #4]
  403e18:	4282      	cmp	r2, r0
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
  403e1a:	bf04      	itt	eq
  403e1c:	6882      	ldreq	r2, [r0, #8]
  403e1e:	605a      	streq	r2, [r3, #4]
	}

	pxItemToRemove->pvContainer = NULL;
  403e20:	2200      	movs	r2, #0
  403e22:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
  403e24:	681a      	ldr	r2, [r3, #0]
  403e26:	3a01      	subs	r2, #1
  403e28:	601a      	str	r2, [r3, #0]
  403e2a:	4770      	bx	lr

00403e2c <SVC_Handler>:
/**
 * \brief Handler for Sytem supervisor call.
 */
void vPortSVCHandler(void)
{
	__asm volatile (" ldr r3, pxCurrentTCBConst2  \n"  /* Restore the context. */
  403e2c:	4b06      	ldr	r3, [pc, #24]	; (403e48 <pxCurrentTCBConst2>)
  403e2e:	6819      	ldr	r1, [r3, #0]
  403e30:	6808      	ldr	r0, [r1, #0]
  403e32:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
  403e36:	f380 8809 	msr	PSP, r0
  403e3a:	f04f 0000 	mov.w	r0, #0
  403e3e:	f380 8811 	msr	BASEPRI, r0
  403e42:	f04e 0e0d 	orr.w	lr, lr, #13
  403e46:	4770      	bx	lr

00403e48 <pxCurrentTCBConst2>:
  403e48:	20001064 	.word	0x20001064

00403e4c <vPortYieldFromISR>:
 * \brief Yield PendSV to request a context switch.
 */
void vPortYieldFromISR(void)
{
	/* Set a PendSV to request a context switch. */
	*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
  403e4c:	4b02      	ldr	r3, [pc, #8]	; (403e58 <vPortYieldFromISR+0xc>)
  403e4e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  403e52:	601a      	str	r2, [r3, #0]
  403e54:	4770      	bx	lr
  403e56:	bf00      	nop
  403e58:	e000ed04 	.word	0xe000ed04

00403e5c <vPortEnterCritical>:
/**
 * \brief Enter Critical code.
 */
void vPortEnterCritical(void)
{
	portDISABLE_INTERRUPTS();
  403e5c:	f04f 0000 	mov.w	r0, #0
  403e60:	f380 8811 	msr	BASEPRI, r0
	uxCriticalNesting++;
  403e64:	4b02      	ldr	r3, [pc, #8]	; (403e70 <vPortEnterCritical+0x14>)
  403e66:	681a      	ldr	r2, [r3, #0]
  403e68:	3201      	adds	r2, #1
  403e6a:	601a      	str	r2, [r3, #0]
  403e6c:	4770      	bx	lr
  403e6e:	bf00      	nop
  403e70:	200000b4 	.word	0x200000b4

00403e74 <vPortExitCritical>:
/**
 * \brief Exit Critical code.
 */
void vPortExitCritical(void)
{
	uxCriticalNesting--;
  403e74:	4a04      	ldr	r2, [pc, #16]	; (403e88 <vPortExitCritical+0x14>)
  403e76:	6813      	ldr	r3, [r2, #0]
  403e78:	3b01      	subs	r3, #1
  403e7a:	6013      	str	r3, [r2, #0]
	if (uxCriticalNesting == 0) {
  403e7c:	b91b      	cbnz	r3, 403e86 <vPortExitCritical+0x12>
		portENABLE_INTERRUPTS();
  403e7e:	f04f 0000 	mov.w	r0, #0
  403e82:	f380 8811 	msr	BASEPRI, r0
  403e86:	4770      	bx	lr
  403e88:	200000b4 	.word	0x200000b4

00403e8c <PendSV_Handler>:
 * \brief Handler for Sytem interrupt-driven request.
 */
void xPortPendSVHandler(void)
{
	/* This is a naked function. */
	__asm volatile (" mrs r0, psp      \n"
  403e8c:	f3ef 8009 	mrs	r0, PSP
  403e90:	4b0c      	ldr	r3, [pc, #48]	; (403ec4 <pxCurrentTCBConst>)
  403e92:	681a      	ldr	r2, [r3, #0]
  403e94:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
  403e98:	6010      	str	r0, [r2, #0]
  403e9a:	e92d 4008 	stmdb	sp!, {r3, lr}
  403e9e:	f04f 0000 	mov.w	r0, #0
  403ea2:	f380 8811 	msr	BASEPRI, r0
  403ea6:	f000 fb63 	bl	404570 <vTaskSwitchContext>
  403eaa:	f04f 0000 	mov.w	r0, #0
  403eae:	f380 8811 	msr	BASEPRI, r0
  403eb2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  403eb6:	6819      	ldr	r1, [r3, #0]
  403eb8:	6808      	ldr	r0, [r1, #0]
  403eba:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
  403ebe:	f380 8809 	msr	PSP, r0
  403ec2:	4770      	bx	lr

00403ec4 <pxCurrentTCBConst>:
  403ec4:	20001064 	.word	0x20001064

00403ec8 <xPortSysTickHandler>:

/**
 * \brief Handler for Sytem Tick interrupt.
 */
void xPortSysTickHandler(void)
{
  403ec8:	b508      	push	{r3, lr}
	unsigned portLONG ulDummy;

	/* If using preemption, also force a context switch. */
#if configUSE_PREEMPTION == 1
	*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
  403eca:	4b07      	ldr	r3, [pc, #28]	; (403ee8 <xPortSysTickHandler+0x20>)
  403ecc:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  403ed0:	601a      	str	r2, [r3, #0]
#endif

	ulDummy = portSET_INTERRUPT_MASK_FROM_ISR();
  403ed2:	f04f 0000 	mov.w	r0, #0
  403ed6:	f380 8811 	msr	BASEPRI, r0
	{
		vTaskIncrementTick();
  403eda:	4b04      	ldr	r3, [pc, #16]	; (403eec <xPortSysTickHandler+0x24>)
  403edc:	4798      	blx	r3
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR(ulDummy);
  403ede:	f04f 0000 	mov.w	r0, #0
  403ee2:	f380 8811 	msr	BASEPRI, r0
  403ee6:	bd08      	pop	{r3, pc}
  403ee8:	e000ed04 	.word	0xe000ed04
  403eec:	00404351 	.word	0x00404351

00403ef0 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
  403ef0:	b538      	push	{r3, r4, r5, lr}
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
  403ef2:	6c03      	ldr	r3, [r0, #64]	; 0x40
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
  403ef4:	4604      	mov	r4, r0
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
  403ef6:	b933      	cbnz	r3, 403f06 <prvCopyDataToQueue+0x16>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  403ef8:	6805      	ldr	r5, [r0, #0]
  403efa:	2d00      	cmp	r5, #0
  403efc:	d028      	beq.n	403f50 <prvCopyDataToQueue+0x60>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
		}
	}

	++( pxQueue->uxMessagesWaiting );
  403efe:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  403f00:	3301      	adds	r3, #1
  403f02:	63a3      	str	r3, [r4, #56]	; 0x38
  403f04:	bd38      	pop	{r3, r4, r5, pc}
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
  403f06:	b982      	cbnz	r2, 403f2a <prvCopyDataToQueue+0x3a>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
  403f08:	461a      	mov	r2, r3
  403f0a:	6880      	ldr	r0, [r0, #8]
  403f0c:	4b13      	ldr	r3, [pc, #76]	; (403f5c <prvCopyDataToQueue+0x6c>)
  403f0e:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
  403f10:	68a1      	ldr	r1, [r4, #8]
  403f12:	6c23      	ldr	r3, [r4, #64]	; 0x40
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
  403f14:	6862      	ldr	r2, [r4, #4]
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
  403f16:	440b      	add	r3, r1
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
  403f18:	4293      	cmp	r3, r2
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
  403f1a:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
  403f1c:	d3ef      	bcc.n	403efe <prvCopyDataToQueue+0xe>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
  403f1e:	6823      	ldr	r3, [r4, #0]
  403f20:	60a3      	str	r3, [r4, #8]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
		}
	}

	++( pxQueue->uxMessagesWaiting );
  403f22:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  403f24:	3301      	adds	r3, #1
  403f26:	63a3      	str	r3, [r4, #56]	; 0x38
  403f28:	bd38      	pop	{r3, r4, r5, pc}
			pxQueue->pcWriteTo = pxQueue->pcHead;
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
  403f2a:	461a      	mov	r2, r3
  403f2c:	68c0      	ldr	r0, [r0, #12]
  403f2e:	4b0b      	ldr	r3, [pc, #44]	; (403f5c <prvCopyDataToQueue+0x6c>)
  403f30:	4798      	blx	r3
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
  403f32:	6c22      	ldr	r2, [r4, #64]	; 0x40
  403f34:	68e3      	ldr	r3, [r4, #12]
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
  403f36:	6821      	ldr	r1, [r4, #0]
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
  403f38:	4252      	negs	r2, r2
  403f3a:	4413      	add	r3, r2
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
  403f3c:	428b      	cmp	r3, r1
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
  403f3e:	60e3      	str	r3, [r4, #12]
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
  403f40:	d2dd      	bcs.n	403efe <prvCopyDataToQueue+0xe>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
  403f42:	6863      	ldr	r3, [r4, #4]
  403f44:	441a      	add	r2, r3
		}
	}

	++( pxQueue->uxMessagesWaiting );
  403f46:	6ba3      	ldr	r3, [r4, #56]	; 0x38
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
  403f48:	60e2      	str	r2, [r4, #12]
		}
	}

	++( pxQueue->uxMessagesWaiting );
  403f4a:	3301      	adds	r3, #1
  403f4c:	63a3      	str	r3, [r4, #56]	; 0x38
  403f4e:	bd38      	pop	{r3, r4, r5, pc}
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
  403f50:	6840      	ldr	r0, [r0, #4]
  403f52:	4b03      	ldr	r3, [pc, #12]	; (403f60 <prvCopyDataToQueue+0x70>)
  403f54:	4798      	blx	r3
				pxQueue->pxMutexHolder = NULL;
  403f56:	6065      	str	r5, [r4, #4]
  403f58:	e7d1      	b.n	403efe <prvCopyDataToQueue+0xe>
  403f5a:	bf00      	nop
  403f5c:	0040641d 	.word	0x0040641d
  403f60:	0040481d 	.word	0x0040481d

00403f64 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
  403f64:	b538      	push	{r3, r4, r5, lr}
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
  403f66:	6804      	ldr	r4, [r0, #0]
  403f68:	b164      	cbz	r4, 403f84 <prvCopyDataFromQueue+0x20>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
  403f6a:	68c3      	ldr	r3, [r0, #12]
  403f6c:	6c02      	ldr	r2, [r0, #64]	; 0x40
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
  403f6e:	6845      	ldr	r5, [r0, #4]

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
  403f70:	4413      	add	r3, r2
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
  403f72:	42ab      	cmp	r3, r5

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
  403f74:	60c3      	str	r3, [r0, #12]
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
  403f76:	bf24      	itt	cs
  403f78:	4623      	movcs	r3, r4
  403f7a:	60c4      	strcs	r4, [r0, #12]
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
  403f7c:	4608      	mov	r0, r1
  403f7e:	4619      	mov	r1, r3
  403f80:	4b01      	ldr	r3, [pc, #4]	; (403f88 <prvCopyDataFromQueue+0x24>)
  403f82:	4798      	blx	r3
  403f84:	bd38      	pop	{r3, r4, r5, pc}
  403f86:	bf00      	nop
  403f88:	0040641d 	.word	0x0040641d

00403f8c <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
  403f8c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  403f90:	4604      	mov	r4, r0

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
  403f92:	4f23      	ldr	r7, [pc, #140]	; (404020 <prvUnlockQueue+0x94>)
  403f94:	47b8      	blx	r7
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
  403f96:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  403f98:	2b00      	cmp	r3, #0
  403f9a:	dd18      	ble.n	403fce <prvUnlockQueue+0x42>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  403f9c:	6a63      	ldr	r3, [r4, #36]	; 0x24
  403f9e:	b1b3      	cbz	r3, 403fce <prvUnlockQueue+0x42>
  403fa0:	f104 0624 	add.w	r6, r4, #36	; 0x24
  403fa4:	4d1f      	ldr	r5, [pc, #124]	; (404024 <prvUnlockQueue+0x98>)
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
  403fa6:	f8df 8080 	ldr.w	r8, [pc, #128]	; 404028 <prvUnlockQueue+0x9c>
  403faa:	e006      	b.n	403fba <prvUnlockQueue+0x2e>
				}

				--( pxQueue->xTxLock );
  403fac:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  403fae:	3b01      	subs	r3, #1
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
  403fb0:	2b00      	cmp	r3, #0
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
				}

				--( pxQueue->xTxLock );
  403fb2:	64a3      	str	r3, [r4, #72]	; 0x48
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
  403fb4:	dd0b      	ble.n	403fce <prvUnlockQueue+0x42>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  403fb6:	6a63      	ldr	r3, [r4, #36]	; 0x24
  403fb8:	b14b      	cbz	r3, 403fce <prvUnlockQueue+0x42>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  403fba:	4630      	mov	r0, r6
  403fbc:	47a8      	blx	r5
  403fbe:	2800      	cmp	r0, #0
  403fc0:	d0f4      	beq.n	403fac <prvUnlockQueue+0x20>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
  403fc2:	47c0      	blx	r8
				}

				--( pxQueue->xTxLock );
  403fc4:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  403fc6:	3b01      	subs	r3, #1
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
  403fc8:	2b00      	cmp	r3, #0
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
				}

				--( pxQueue->xTxLock );
  403fca:	64a3      	str	r3, [r4, #72]	; 0x48
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
  403fcc:	dcf3      	bgt.n	403fb6 <prvUnlockQueue+0x2a>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
  403fce:	f04f 33ff 	mov.w	r3, #4294967295
  403fd2:	64a3      	str	r3, [r4, #72]	; 0x48
	}
	taskEXIT_CRITICAL();
  403fd4:	f8df 8054 	ldr.w	r8, [pc, #84]	; 40402c <prvUnlockQueue+0xa0>
  403fd8:	47c0      	blx	r8

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
  403fda:	47b8      	blx	r7
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
  403fdc:	6c63      	ldr	r3, [r4, #68]	; 0x44
  403fde:	2b00      	cmp	r3, #0
  403fe0:	dd17      	ble.n	404012 <prvUnlockQueue+0x86>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  403fe2:	6923      	ldr	r3, [r4, #16]
  403fe4:	b1ab      	cbz	r3, 404012 <prvUnlockQueue+0x86>
  403fe6:	f104 0610 	add.w	r6, r4, #16
  403fea:	4d0e      	ldr	r5, [pc, #56]	; (404024 <prvUnlockQueue+0x98>)
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
				{
					vTaskMissedYield();
  403fec:	4f0e      	ldr	r7, [pc, #56]	; (404028 <prvUnlockQueue+0x9c>)
  403fee:	e006      	b.n	403ffe <prvUnlockQueue+0x72>
				}

				--( pxQueue->xRxLock );
  403ff0:	6c63      	ldr	r3, [r4, #68]	; 0x44
  403ff2:	3b01      	subs	r3, #1
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
  403ff4:	2b00      	cmp	r3, #0
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
				{
					vTaskMissedYield();
				}

				--( pxQueue->xRxLock );
  403ff6:	6463      	str	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
  403ff8:	dd0b      	ble.n	404012 <prvUnlockQueue+0x86>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  403ffa:	6923      	ldr	r3, [r4, #16]
  403ffc:	b14b      	cbz	r3, 404012 <prvUnlockQueue+0x86>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  403ffe:	4630      	mov	r0, r6
  404000:	47a8      	blx	r5
  404002:	2800      	cmp	r0, #0
  404004:	d0f4      	beq.n	403ff0 <prvUnlockQueue+0x64>
				{
					vTaskMissedYield();
  404006:	47b8      	blx	r7
				}

				--( pxQueue->xRxLock );
  404008:	6c63      	ldr	r3, [r4, #68]	; 0x44
  40400a:	3b01      	subs	r3, #1
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
  40400c:	2b00      	cmp	r3, #0
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
				{
					vTaskMissedYield();
				}

				--( pxQueue->xRxLock );
  40400e:	6463      	str	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
  404010:	dcf3      	bgt.n	403ffa <prvUnlockQueue+0x6e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
  404012:	f04f 33ff 	mov.w	r3, #4294967295
  404016:	6463      	str	r3, [r4, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
  404018:	47c0      	blx	r8
  40401a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40401e:	bf00      	nop
  404020:	00403e5d 	.word	0x00403e5d
  404024:	00404691 	.word	0x00404691
  404028:	00404795 	.word	0x00404795
  40402c:	00403e75 	.word	0x00403e75

00404030 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
  404030:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  404034:	4f37      	ldr	r7, [pc, #220]	; (404114 <xQueueGenericSend+0xe4>)
  404036:	4d38      	ldr	r5, [pc, #224]	; (404118 <xQueueGenericSend+0xe8>)
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
  404038:	f8df a0fc 	ldr.w	sl, [pc, #252]	; 404138 <xQueueGenericSend+0x108>
		taskEXIT_CRITICAL();

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
  40403c:	f8df 80fc 	ldr.w	r8, [pc, #252]	; 40413c <xQueueGenericSend+0x10c>

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
  404040:	b087      	sub	sp, #28
  404042:	4604      	mov	r4, r0
  404044:	9203      	str	r2, [sp, #12]
  404046:	9101      	str	r1, [sp, #4]
  404048:	9302      	str	r3, [sp, #8]

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
  40404a:	46b9      	mov	r9, r7
#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
  40404c:	2600      	movs	r6, #0
  40404e:	e021      	b.n	404094 <xQueueGenericSend+0x64>
  404050:	ae04      	add	r6, sp, #16
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
  404052:	47b8      	blx	r7

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
  404054:	47c0      	blx	r8
		prvLockQueue( pxQueue );
  404056:	47a8      	blx	r5
  404058:	6c63      	ldr	r3, [r4, #68]	; 0x44
  40405a:	3301      	adds	r3, #1
  40405c:	bf04      	itt	eq
  40405e:	2300      	moveq	r3, #0
  404060:	6463      	streq	r3, [r4, #68]	; 0x44
  404062:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  404064:	3301      	adds	r3, #1
  404066:	bf04      	itt	eq
  404068:	2300      	moveq	r3, #0
  40406a:	64a3      	streq	r3, [r4, #72]	; 0x48
  40406c:	47b8      	blx	r7

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  40406e:	4630      	mov	r0, r6
  404070:	a903      	add	r1, sp, #12
  404072:	4b2a      	ldr	r3, [pc, #168]	; (40411c <xQueueGenericSend+0xec>)
  404074:	4798      	blx	r3
  404076:	2800      	cmp	r0, #0
  404078:	d13a      	bne.n	4040f0 <xQueueGenericSend+0xc0>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
  40407a:	47a8      	blx	r5
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
  40407c:	f8d4 b038 	ldr.w	fp, [r4, #56]	; 0x38
  404080:	6be6      	ldr	r6, [r4, #60]	; 0x3c
	taskEXIT_CRITICAL();
  404082:	47c8      	blx	r9
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
  404084:	45b3      	cmp	fp, r6
  404086:	d012      	beq.n	4040ae <xQueueGenericSend+0x7e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
  404088:	4b25      	ldr	r3, [pc, #148]	; (404120 <xQueueGenericSend+0xf0>)
  40408a:	4620      	mov	r0, r4
  40408c:	4798      	blx	r3
				( void ) xTaskResumeAll();
  40408e:	4b25      	ldr	r3, [pc, #148]	; (404124 <xQueueGenericSend+0xf4>)
  404090:	4798      	blx	r3
  404092:	2601      	movs	r6, #1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
  404094:	47a8      	blx	r5
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
  404096:	6ba2      	ldr	r2, [r4, #56]	; 0x38
  404098:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  40409a:	429a      	cmp	r2, r3
  40409c:	d316      	bcc.n	4040cc <xQueueGenericSend+0x9c>
				function. */
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
  40409e:	9803      	ldr	r0, [sp, #12]
  4040a0:	b300      	cbz	r0, 4040e4 <xQueueGenericSend+0xb4>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
  4040a2:	2e00      	cmp	r6, #0
  4040a4:	d1d4      	bne.n	404050 <xQueueGenericSend+0x20>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
  4040a6:	ae04      	add	r6, sp, #16
  4040a8:	4630      	mov	r0, r6
  4040aa:	47d0      	blx	sl
  4040ac:	e7d1      	b.n	404052 <xQueueGenericSend+0x22>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
  4040ae:	f104 0010 	add.w	r0, r4, #16
  4040b2:	9903      	ldr	r1, [sp, #12]
  4040b4:	4b1c      	ldr	r3, [pc, #112]	; (404128 <xQueueGenericSend+0xf8>)
  4040b6:	4798      	blx	r3
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
  4040b8:	4b19      	ldr	r3, [pc, #100]	; (404120 <xQueueGenericSend+0xf0>)
  4040ba:	4620      	mov	r0, r4
  4040bc:	4798      	blx	r3
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
  4040be:	4b19      	ldr	r3, [pc, #100]	; (404124 <xQueueGenericSend+0xf4>)
  4040c0:	4798      	blx	r3
  4040c2:	2800      	cmp	r0, #0
  4040c4:	d1e5      	bne.n	404092 <xQueueGenericSend+0x62>
				{
					portYIELD_WITHIN_API();
  4040c6:	4b19      	ldr	r3, [pc, #100]	; (40412c <xQueueGenericSend+0xfc>)
  4040c8:	4798      	blx	r3
  4040ca:	e7e2      	b.n	404092 <xQueueGenericSend+0x62>
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  4040cc:	4b18      	ldr	r3, [pc, #96]	; (404130 <xQueueGenericSend+0x100>)
  4040ce:	9901      	ldr	r1, [sp, #4]
  4040d0:	9a02      	ldr	r2, [sp, #8]
  4040d2:	4620      	mov	r0, r4
  4040d4:	4798      	blx	r3

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  4040d6:	6a63      	ldr	r3, [r4, #36]	; 0x24
  4040d8:	b99b      	cbnz	r3, 404102 <xQueueGenericSend+0xd2>
						takes care of that. */
						portYIELD_WITHIN_API();
					}
				}

				taskEXIT_CRITICAL();
  4040da:	47b8      	blx	r7

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
  4040dc:	2001      	movs	r0, #1
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
  4040de:	b007      	add	sp, #28
  4040e0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			{
				if( xTicksToWait == ( portTickType ) 0 )
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
  4040e4:	9000      	str	r0, [sp, #0]
  4040e6:	47b8      	blx	r7

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
  4040e8:	9800      	ldr	r0, [sp, #0]
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
  4040ea:	b007      	add	sp, #28
  4040ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
  4040f0:	4620      	mov	r0, r4
  4040f2:	4b0b      	ldr	r3, [pc, #44]	; (404120 <xQueueGenericSend+0xf0>)
  4040f4:	4798      	blx	r3
			( void ) xTaskResumeAll();
  4040f6:	4b0b      	ldr	r3, [pc, #44]	; (404124 <xQueueGenericSend+0xf4>)
  4040f8:	4798      	blx	r3

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
  4040fa:	2000      	movs	r0, #0
		}
	}
}
  4040fc:	b007      	add	sp, #28
  4040fe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
  404102:	f104 0024 	add.w	r0, r4, #36	; 0x24
  404106:	4b0b      	ldr	r3, [pc, #44]	; (404134 <xQueueGenericSend+0x104>)
  404108:	4798      	blx	r3
  40410a:	2801      	cmp	r0, #1
  40410c:	d1e5      	bne.n	4040da <xQueueGenericSend+0xaa>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
  40410e:	4b07      	ldr	r3, [pc, #28]	; (40412c <xQueueGenericSend+0xfc>)
  404110:	4798      	blx	r3
  404112:	e7e2      	b.n	4040da <xQueueGenericSend+0xaa>
  404114:	00403e75 	.word	0x00403e75
  404118:	00403e5d 	.word	0x00403e5d
  40411c:	00404719 	.word	0x00404719
  404120:	00403f8d 	.word	0x00403f8d
  404124:	0040447d 	.word	0x0040447d
  404128:	00404641 	.word	0x00404641
  40412c:	00403e4d 	.word	0x00403e4d
  404130:	00403ef1 	.word	0x00403ef1
  404134:	00404691 	.word	0x00404691
  404138:	00404701 	.word	0x00404701
  40413c:	00404341 	.word	0x00404341

00404140 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
  404140:	b570      	push	{r4, r5, r6, lr}
  404142:	4604      	mov	r4, r0
  404144:	4616      	mov	r6, r2
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  404146:	f04f 0000 	mov.w	r0, #0
  40414a:	f380 8811 	msr	BASEPRI, r0
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
  40414e:	6ba5      	ldr	r5, [r4, #56]	; 0x38
  404150:	6be0      	ldr	r0, [r4, #60]	; 0x3c
  404152:	4285      	cmp	r5, r0
  404154:	d306      	bcc.n	404164 <xQueueGenericSendFromISR+0x24>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
  404156:	2300      	movs	r3, #0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
  404158:	f04f 0000 	mov.w	r0, #0
  40415c:	f380 8811 	msr	BASEPRI, r0

	return xReturn;
}
  404160:	4618      	mov	r0, r3
  404162:	bd70      	pop	{r4, r5, r6, pc}
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  404164:	461a      	mov	r2, r3
  404166:	4620      	mov	r0, r4
  404168:	4b0a      	ldr	r3, [pc, #40]	; (404194 <xQueueGenericSendFromISR+0x54>)
  40416a:	4798      	blx	r3

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
  40416c:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  40416e:	1c5a      	adds	r2, r3, #1
  404170:	d003      	beq.n	40417a <xQueueGenericSendFromISR+0x3a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
  404172:	3301      	adds	r3, #1
  404174:	64a3      	str	r3, [r4, #72]	; 0x48
			}

			xReturn = pdPASS;
  404176:	2301      	movs	r3, #1
  404178:	e7ee      	b.n	404158 <xQueueGenericSendFromISR+0x18>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  40417a:	6a63      	ldr	r3, [r4, #36]	; 0x24
  40417c:	2b00      	cmp	r3, #0
  40417e:	d0fa      	beq.n	404176 <xQueueGenericSendFromISR+0x36>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  404180:	f104 0024 	add.w	r0, r4, #36	; 0x24
  404184:	4b04      	ldr	r3, [pc, #16]	; (404198 <xQueueGenericSendFromISR+0x58>)
  404186:	4798      	blx	r3
  404188:	2800      	cmp	r0, #0
  40418a:	d0f4      	beq.n	404176 <xQueueGenericSendFromISR+0x36>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
  40418c:	2301      	movs	r3, #1
  40418e:	6033      	str	r3, [r6, #0]
  404190:	e7e2      	b.n	404158 <xQueueGenericSendFromISR+0x18>
  404192:	bf00      	nop
  404194:	00403ef1 	.word	0x00403ef1
  404198:	00404691 	.word	0x00404691

0040419c <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
  40419c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4041a0:	4f46      	ldr	r7, [pc, #280]	; (4042bc <xQueueGenericReceive+0x120>)
  4041a2:	4d47      	ldr	r5, [pc, #284]	; (4042c0 <xQueueGenericReceive+0x124>)
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
  4041a4:	f8df a140 	ldr.w	sl, [pc, #320]	; 4042e8 <xQueueGenericReceive+0x14c>
		taskEXIT_CRITICAL();

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
  4041a8:	f8df 9140 	ldr.w	r9, [pc, #320]	; 4042ec <xQueueGenericReceive+0x150>
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
  4041ac:	b087      	sub	sp, #28
  4041ae:	4604      	mov	r4, r0
  4041b0:	9203      	str	r2, [sp, #12]
  4041b2:	9101      	str	r1, [sp, #4]
  4041b4:	9302      	str	r3, [sp, #8]

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
  4041b6:	46b8      	mov	r8, r7
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
  4041b8:	2600      	movs	r6, #0
  4041ba:	e02a      	b.n	404212 <xQueueGenericReceive+0x76>
  4041bc:	ae04      	add	r6, sp, #16
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
  4041be:	47b8      	blx	r7

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
  4041c0:	47c8      	blx	r9
		prvLockQueue( pxQueue );
  4041c2:	47a8      	blx	r5
  4041c4:	6c63      	ldr	r3, [r4, #68]	; 0x44
  4041c6:	3301      	adds	r3, #1
  4041c8:	bf04      	itt	eq
  4041ca:	2300      	moveq	r3, #0
  4041cc:	6463      	streq	r3, [r4, #68]	; 0x44
  4041ce:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  4041d0:	3301      	adds	r3, #1
  4041d2:	bf04      	itt	eq
  4041d4:	2300      	moveq	r3, #0
  4041d6:	64a3      	streq	r3, [r4, #72]	; 0x48
  4041d8:	47b8      	blx	r7

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  4041da:	4630      	mov	r0, r6
  4041dc:	a903      	add	r1, sp, #12
  4041de:	4b39      	ldr	r3, [pc, #228]	; (4042c4 <xQueueGenericReceive+0x128>)
  4041e0:	4798      	blx	r3
  4041e2:	2800      	cmp	r0, #0
  4041e4:	d14d      	bne.n	404282 <xQueueGenericReceive+0xe6>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
  4041e6:	47a8      	blx	r5
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
  4041e8:	f8d4 b038 	ldr.w	fp, [r4, #56]	; 0x38

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
  4041ec:	4e34      	ldr	r6, [pc, #208]	; (4042c0 <xQueueGenericReceive+0x124>)
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
	taskEXIT_CRITICAL();
  4041ee:	47c0      	blx	r8
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
  4041f0:	f1bb 0f00 	cmp.w	fp, #0
  4041f4:	d119      	bne.n	40422a <xQueueGenericReceive+0x8e>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  4041f6:	6823      	ldr	r3, [r4, #0]
  4041f8:	b303      	cbz	r3, 40423c <xQueueGenericReceive+0xa0>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
  4041fa:	f104 0024 	add.w	r0, r4, #36	; 0x24
  4041fe:	9903      	ldr	r1, [sp, #12]
  404200:	4b31      	ldr	r3, [pc, #196]	; (4042c8 <xQueueGenericReceive+0x12c>)
  404202:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
  404204:	4b31      	ldr	r3, [pc, #196]	; (4042cc <xQueueGenericReceive+0x130>)
  404206:	4620      	mov	r0, r4
  404208:	4798      	blx	r3
				if( !xTaskResumeAll() )
  40420a:	4b31      	ldr	r3, [pc, #196]	; (4042d0 <xQueueGenericReceive+0x134>)
  40420c:	4798      	blx	r3
  40420e:	b190      	cbz	r0, 404236 <xQueueGenericReceive+0x9a>
  404210:	2601      	movs	r6, #1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
  404212:	47a8      	blx	r5
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
  404214:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  404216:	b9bb      	cbnz	r3, 404248 <xQueueGenericReceive+0xac>
				taskEXIT_CRITICAL();
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
  404218:	9803      	ldr	r0, [sp, #12]
  40421a:	2800      	cmp	r0, #0
  40421c:	d02b      	beq.n	404276 <xQueueGenericReceive+0xda>
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
  40421e:	2e00      	cmp	r6, #0
  404220:	d1cc      	bne.n	4041bc <xQueueGenericReceive+0x20>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
  404222:	ae04      	add	r6, sp, #16
  404224:	4630      	mov	r0, r6
  404226:	47d0      	blx	sl
  404228:	e7c9      	b.n	4041be <xQueueGenericReceive+0x22>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
  40422a:	4620      	mov	r0, r4
  40422c:	4b27      	ldr	r3, [pc, #156]	; (4042cc <xQueueGenericReceive+0x130>)
  40422e:	4798      	blx	r3
				( void ) xTaskResumeAll();
  404230:	4b27      	ldr	r3, [pc, #156]	; (4042d0 <xQueueGenericReceive+0x134>)
  404232:	4798      	blx	r3
  404234:	e7ec      	b.n	404210 <xQueueGenericReceive+0x74>

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
				prvUnlockQueue( pxQueue );
				if( !xTaskResumeAll() )
				{
					portYIELD_WITHIN_API();
  404236:	4b27      	ldr	r3, [pc, #156]	; (4042d4 <xQueueGenericReceive+0x138>)
  404238:	4798      	blx	r3
  40423a:	e7e9      	b.n	404210 <xQueueGenericReceive+0x74>

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
					{
						portENTER_CRITICAL();
  40423c:	47b0      	blx	r6
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
  40423e:	6860      	ldr	r0, [r4, #4]
  404240:	4b25      	ldr	r3, [pc, #148]	; (4042d8 <xQueueGenericReceive+0x13c>)
  404242:	4798      	blx	r3
						}
						portEXIT_CRITICAL();
  404244:	47c0      	blx	r8
  404246:	e7d8      	b.n	4041fa <xQueueGenericReceive+0x5e>
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );
  404248:	4b24      	ldr	r3, [pc, #144]	; (4042dc <xQueueGenericReceive+0x140>)
  40424a:	9901      	ldr	r1, [sp, #4]
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
  40424c:	68e5      	ldr	r5, [r4, #12]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
  40424e:	4620      	mov	r0, r4
  404250:	4798      	blx	r3

				if( xJustPeeking == pdFALSE )
  404252:	9b02      	ldr	r3, [sp, #8]
  404254:	b9f3      	cbnz	r3, 404294 <xQueueGenericReceive+0xf8>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
  404256:	6ba2      	ldr	r2, [r4, #56]	; 0x38

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  404258:	6823      	ldr	r3, [r4, #0]
				if( xJustPeeking == pdFALSE )
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
  40425a:	3a01      	subs	r2, #1
  40425c:	63a2      	str	r2, [r4, #56]	; 0x38

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  40425e:	b343      	cbz	r3, 4042b2 <xQueueGenericReceive+0x116>
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  404260:	6923      	ldr	r3, [r4, #16]
  404262:	b1d3      	cbz	r3, 40429a <xQueueGenericReceive+0xfe>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
  404264:	f104 0010 	add.w	r0, r4, #16
  404268:	4b1d      	ldr	r3, [pc, #116]	; (4042e0 <xQueueGenericReceive+0x144>)
  40426a:	4798      	blx	r3
  40426c:	2801      	cmp	r0, #1
  40426e:	d114      	bne.n	40429a <xQueueGenericReceive+0xfe>
						{
							portYIELD_WITHIN_API();
  404270:	4b18      	ldr	r3, [pc, #96]	; (4042d4 <xQueueGenericReceive+0x138>)
  404272:	4798      	blx	r3
  404274:	e011      	b.n	40429a <xQueueGenericReceive+0xfe>
			{
				if( xTicksToWait == ( portTickType ) 0 )
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
  404276:	9000      	str	r0, [sp, #0]
  404278:	47b8      	blx	r7
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
  40427a:	9800      	ldr	r0, [sp, #0]
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
  40427c:	b007      	add	sp, #28
  40427e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
  404282:	4620      	mov	r0, r4
  404284:	4b11      	ldr	r3, [pc, #68]	; (4042cc <xQueueGenericReceive+0x130>)
  404286:	4798      	blx	r3
			( void ) xTaskResumeAll();
  404288:	4b11      	ldr	r3, [pc, #68]	; (4042d0 <xQueueGenericReceive+0x134>)
  40428a:	4798      	blx	r3
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
  40428c:	2000      	movs	r0, #0
		}
	}
}
  40428e:	b007      	add	sp, #28
  404290:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  404294:	6a63      	ldr	r3, [r4, #36]	; 0x24
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
  404296:	60e5      	str	r5, [r4, #12]

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  404298:	b923      	cbnz	r3, 4042a4 <xQueueGenericReceive+0x108>
						}
					}

				}

				taskEXIT_CRITICAL();
  40429a:	47b8      	blx	r7
				return pdPASS;
  40429c:	2001      	movs	r0, #1
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
  40429e:	b007      	add	sp, #28
  4042a0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  4042a4:	f104 0024 	add.w	r0, r4, #36	; 0x24
  4042a8:	4b0d      	ldr	r3, [pc, #52]	; (4042e0 <xQueueGenericReceive+0x144>)
  4042aa:	4798      	blx	r3
  4042ac:	2800      	cmp	r0, #0
  4042ae:	d0f4      	beq.n	40429a <xQueueGenericReceive+0xfe>
  4042b0:	e7de      	b.n	404270 <xQueueGenericReceive+0xd4>
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
  4042b2:	4b0c      	ldr	r3, [pc, #48]	; (4042e4 <xQueueGenericReceive+0x148>)
  4042b4:	4798      	blx	r3
  4042b6:	6060      	str	r0, [r4, #4]
  4042b8:	e7d2      	b.n	404260 <xQueueGenericReceive+0xc4>
  4042ba:	bf00      	nop
  4042bc:	00403e75 	.word	0x00403e75
  4042c0:	00403e5d 	.word	0x00403e5d
  4042c4:	00404719 	.word	0x00404719
  4042c8:	00404641 	.word	0x00404641
  4042cc:	00403f8d 	.word	0x00403f8d
  4042d0:	0040447d 	.word	0x0040447d
  4042d4:	00403e4d 	.word	0x00403e4d
  4042d8:	004047ad 	.word	0x004047ad
  4042dc:	00403f65 	.word	0x00403f65
  4042e0:	00404691 	.word	0x00404691
  4042e4:	004047a1 	.word	0x004047a1
  4042e8:	00404701 	.word	0x00404701
  4042ec:	00404341 	.word	0x00404341

004042f0 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
  4042f0:	b510      	push	{r4, lr}
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
  4042f2:	4b0d      	ldr	r3, [pc, #52]	; (404328 <prvAddCurrentTaskToDelayedList+0x38>)

	if( xTimeToWake < xTickCount )
  4042f4:	4a0d      	ldr	r2, [pc, #52]	; (40432c <prvAddCurrentTaskToDelayedList+0x3c>)
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
  4042f6:	6819      	ldr	r1, [r3, #0]

	if( xTimeToWake < xTickCount )
  4042f8:	6812      	ldr	r2, [r2, #0]
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
  4042fa:	6048      	str	r0, [r1, #4]

	if( xTimeToWake < xTickCount )
  4042fc:	4290      	cmp	r0, r2
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
  4042fe:	4604      	mov	r4, r0
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
  404300:	d30b      	bcc.n	40431a <prvAddCurrentTaskToDelayedList+0x2a>
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  404302:	490b      	ldr	r1, [pc, #44]	; (404330 <prvAddCurrentTaskToDelayedList+0x40>)
  404304:	4a0b      	ldr	r2, [pc, #44]	; (404334 <prvAddCurrentTaskToDelayedList+0x44>)
  404306:	6808      	ldr	r0, [r1, #0]
  404308:	6819      	ldr	r1, [r3, #0]
  40430a:	3104      	adds	r1, #4
  40430c:	4790      	blx	r2

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
  40430e:	4b0a      	ldr	r3, [pc, #40]	; (404338 <prvAddCurrentTaskToDelayedList+0x48>)
  404310:	681a      	ldr	r2, [r3, #0]
  404312:	4294      	cmp	r4, r2
		{
			xNextTaskUnblockTime = xTimeToWake;
  404314:	bf38      	it	cc
  404316:	601c      	strcc	r4, [r3, #0]
  404318:	bd10      	pop	{r4, pc}
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  40431a:	4908      	ldr	r1, [pc, #32]	; (40433c <prvAddCurrentTaskToDelayedList+0x4c>)
  40431c:	4a05      	ldr	r2, [pc, #20]	; (404334 <prvAddCurrentTaskToDelayedList+0x44>)
  40431e:	6808      	ldr	r0, [r1, #0]
  404320:	6819      	ldr	r1, [r3, #0]
  404322:	3104      	adds	r1, #4
  404324:	4790      	blx	r2
  404326:	bd10      	pop	{r4, pc}
  404328:	20001064 	.word	0x20001064
  40432c:	20000f94 	.word	0x20000f94
  404330:	20001040 	.word	0x20001040
  404334:	00403dcd 	.word	0x00403dcd
  404338:	200000bc 	.word	0x200000bc
  40433c:	20001038 	.word	0x20001038

00404340 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
  404340:	4b02      	ldr	r3, [pc, #8]	; (40434c <vTaskSuspendAll+0xc>)
  404342:	681a      	ldr	r2, [r3, #0]
  404344:	3201      	adds	r2, #1
  404346:	601a      	str	r2, [r3, #0]
  404348:	4770      	bx	lr
  40434a:	bf00      	nop
  40434c:	2000107c 	.word	0x2000107c

00404350 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
  404350:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  404354:	4b3e      	ldr	r3, [pc, #248]	; (404450 <vTaskIncrementTick+0x100>)
  404356:	681b      	ldr	r3, [r3, #0]
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
  404358:	b083      	sub	sp, #12
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  40435a:	2b00      	cmp	r3, #0
  40435c:	d150      	bne.n	404400 <vTaskIncrementTick+0xb0>
	{
		++xTickCount;
  40435e:	4c3d      	ldr	r4, [pc, #244]	; (404454 <vTaskIncrementTick+0x104>)
  404360:	6823      	ldr	r3, [r4, #0]
  404362:	3301      	adds	r3, #1
  404364:	6023      	str	r3, [r4, #0]
		if( xTickCount == ( portTickType ) 0 )
  404366:	6823      	ldr	r3, [r4, #0]
  404368:	2b00      	cmp	r3, #0
  40436a:	d050      	beq.n	40440e <vTaskIncrementTick+0xbe>
  40436c:	4a3a      	ldr	r2, [pc, #232]	; (404458 <vTaskIncrementTick+0x108>)
  40436e:	9201      	str	r2, [sp, #4]
  404370:	6813      	ldr	r3, [r2, #0]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
  404372:	6822      	ldr	r2, [r4, #0]
  404374:	4937      	ldr	r1, [pc, #220]	; (404454 <vTaskIncrementTick+0x104>)
  404376:	429a      	cmp	r2, r3
  404378:	d346      	bcc.n	404408 <vTaskIncrementTick+0xb8>
  40437a:	4d38      	ldr	r5, [pc, #224]	; (40445c <vTaskIncrementTick+0x10c>)
  40437c:	682b      	ldr	r3, [r5, #0]
  40437e:	681b      	ldr	r3, [r3, #0]
  404380:	2b00      	cmp	r3, #0
  404382:	d036      	beq.n	4043f2 <vTaskIncrementTick+0xa2>
  404384:	682b      	ldr	r3, [r5, #0]
  404386:	68db      	ldr	r3, [r3, #12]
  404388:	f8d3 b00c 	ldr.w	fp, [r3, #12]
  40438c:	6809      	ldr	r1, [r1, #0]
  40438e:	f8db 2004 	ldr.w	r2, [fp, #4]
  404392:	428a      	cmp	r2, r1
  404394:	d857      	bhi.n	404446 <vTaskIncrementTick+0xf6>
  404396:	4f32      	ldr	r7, [pc, #200]	; (404460 <vTaskIncrementTick+0x110>)
  404398:	4e32      	ldr	r6, [pc, #200]	; (404464 <vTaskIncrementTick+0x114>)
  40439a:	f8df 90d8 	ldr.w	r9, [pc, #216]	; 404474 <vTaskIncrementTick+0x124>
  40439e:	f8df 80d8 	ldr.w	r8, [pc, #216]	; 404478 <vTaskIncrementTick+0x128>
  4043a2:	e009      	b.n	4043b8 <vTaskIncrementTick+0x68>
  4043a4:	4a2d      	ldr	r2, [pc, #180]	; (40445c <vTaskIncrementTick+0x10c>)
  4043a6:	6813      	ldr	r3, [r2, #0]
  4043a8:	68db      	ldr	r3, [r3, #12]
  4043aa:	f8d3 b00c 	ldr.w	fp, [r3, #12]
  4043ae:	6821      	ldr	r1, [r4, #0]
  4043b0:	f8db 2004 	ldr.w	r2, [fp, #4]
  4043b4:	428a      	cmp	r2, r1
  4043b6:	d846      	bhi.n	404446 <vTaskIncrementTick+0xf6>
  4043b8:	f10b 0a04 	add.w	sl, fp, #4
  4043bc:	4650      	mov	r0, sl
  4043be:	47b8      	blx	r7
  4043c0:	f8db 2028 	ldr.w	r2, [fp, #40]	; 0x28
  4043c4:	f10b 0018 	add.w	r0, fp, #24
  4043c8:	b10a      	cbz	r2, 4043ce <vTaskIncrementTick+0x7e>
  4043ca:	4a25      	ldr	r2, [pc, #148]	; (404460 <vTaskIncrementTick+0x110>)
  4043cc:	4790      	blx	r2
  4043ce:	f8db 302c 	ldr.w	r3, [fp, #44]	; 0x2c
  4043d2:	6832      	ldr	r2, [r6, #0]
  4043d4:	4293      	cmp	r3, r2
  4043d6:	eb03 0083 	add.w	r0, r3, r3, lsl #2
  4043da:	bf88      	it	hi
  4043dc:	4a21      	ldrhi	r2, [pc, #132]	; (404464 <vTaskIncrementTick+0x114>)
  4043de:	eb09 0080 	add.w	r0, r9, r0, lsl #2
  4043e2:	4651      	mov	r1, sl
  4043e4:	bf88      	it	hi
  4043e6:	6013      	strhi	r3, [r2, #0]
  4043e8:	47c0      	blx	r8
  4043ea:	682b      	ldr	r3, [r5, #0]
  4043ec:	681b      	ldr	r3, [r3, #0]
  4043ee:	2b00      	cmp	r3, #0
  4043f0:	d1d8      	bne.n	4043a4 <vTaskIncrementTick+0x54>
  4043f2:	9a01      	ldr	r2, [sp, #4]
  4043f4:	f04f 33ff 	mov.w	r3, #4294967295
  4043f8:	6013      	str	r3, [r2, #0]
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
  4043fa:	b003      	add	sp, #12
  4043fc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
	}
	else
	{
		++uxMissedTicks;
  404400:	4b19      	ldr	r3, [pc, #100]	; (404468 <vTaskIncrementTick+0x118>)
  404402:	681a      	ldr	r2, [r3, #0]
  404404:	3201      	adds	r2, #1
  404406:	601a      	str	r2, [r3, #0]
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
  404408:	b003      	add	sp, #12
  40440a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
  40440e:	4b13      	ldr	r3, [pc, #76]	; (40445c <vTaskIncrementTick+0x10c>)
			pxDelayedTaskList = pxOverflowDelayedTaskList;
  404410:	4916      	ldr	r1, [pc, #88]	; (40446c <vTaskIncrementTick+0x11c>)
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
  404412:	6818      	ldr	r0, [r3, #0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
			pxOverflowDelayedTaskList = pxTemp;
			xNumOfOverflows++;
  404414:	4a16      	ldr	r2, [pc, #88]	; (404470 <vTaskIncrementTick+0x120>)
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
			pxDelayedTaskList = pxOverflowDelayedTaskList;
  404416:	680d      	ldr	r5, [r1, #0]
  404418:	601d      	str	r5, [r3, #0]
			pxOverflowDelayedTaskList = pxTemp;
  40441a:	6008      	str	r0, [r1, #0]
			xNumOfOverflows++;
  40441c:	6811      	ldr	r1, [r2, #0]
  40441e:	3101      	adds	r1, #1
  404420:	6011      	str	r1, [r2, #0]

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  404422:	681a      	ldr	r2, [r3, #0]
  404424:	6812      	ldr	r2, [r2, #0]
  404426:	b932      	cbnz	r2, 404436 <vTaskIncrementTick+0xe6>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
  404428:	4b0b      	ldr	r3, [pc, #44]	; (404458 <vTaskIncrementTick+0x108>)
  40442a:	4a0b      	ldr	r2, [pc, #44]	; (404458 <vTaskIncrementTick+0x108>)
  40442c:	9301      	str	r3, [sp, #4]
  40442e:	f04f 33ff 	mov.w	r3, #4294967295
  404432:	6013      	str	r3, [r2, #0]
  404434:	e79d      	b.n	404372 <vTaskIncrementTick+0x22>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
  404436:	681b      	ldr	r3, [r3, #0]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
  404438:	4a07      	ldr	r2, [pc, #28]	; (404458 <vTaskIncrementTick+0x108>)
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
  40443a:	68db      	ldr	r3, [r3, #12]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
  40443c:	9201      	str	r2, [sp, #4]
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
  40443e:	68db      	ldr	r3, [r3, #12]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
  404440:	685b      	ldr	r3, [r3, #4]
  404442:	6013      	str	r3, [r2, #0]
  404444:	e795      	b.n	404372 <vTaskIncrementTick+0x22>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
  404446:	9b01      	ldr	r3, [sp, #4]
  404448:	601a      	str	r2, [r3, #0]
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
  40444a:	b003      	add	sp, #12
  40444c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  404450:	2000107c 	.word	0x2000107c
  404454:	20000f94 	.word	0x20000f94
  404458:	200000bc 	.word	0x200000bc
  40445c:	20001040 	.word	0x20001040
  404460:	00403e09 	.word	0x00403e09
  404464:	20000f90 	.word	0x20000f90
  404468:	20001080 	.word	0x20001080
  40446c:	20001038 	.word	0x20001038
  404470:	20001088 	.word	0x20001088
  404474:	20000f98 	.word	0x20000f98
  404478:	00403db1 	.word	0x00403db1

0040447c <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
  40447c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
  404480:	4b2d      	ldr	r3, [pc, #180]	; (404538 <xTaskResumeAll+0xbc>)
  404482:	4798      	blx	r3
	{
		--uxSchedulerSuspended;
  404484:	4b2d      	ldr	r3, [pc, #180]	; (40453c <xTaskResumeAll+0xc0>)
  404486:	681a      	ldr	r2, [r3, #0]
  404488:	3a01      	subs	r2, #1
  40448a:	601a      	str	r2, [r3, #0]

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  40448c:	681e      	ldr	r6, [r3, #0]
  40448e:	2e00      	cmp	r6, #0
  404490:	d13c      	bne.n	40450c <xTaskResumeAll+0x90>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
  404492:	4b2b      	ldr	r3, [pc, #172]	; (404540 <xTaskResumeAll+0xc4>)
  404494:	681b      	ldr	r3, [r3, #0]
  404496:	2b00      	cmp	r3, #0
  404498:	d038      	beq.n	40450c <xTaskResumeAll+0x90>
  40449a:	f8df 90cc 	ldr.w	r9, [pc, #204]	; 404568 <xTaskResumeAll+0xec>
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
  40449e:	4f29      	ldr	r7, [pc, #164]	; (404544 <xTaskResumeAll+0xc8>)
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
  4044a0:	f8df 80c8 	ldr.w	r8, [pc, #200]	; 40456c <xTaskResumeAll+0xf0>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
  4044a4:	46ca      	mov	sl, r9
  4044a6:	e01e      	b.n	4044e6 <xTaskResumeAll+0x6a>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
  4044a8:	f8da 300c 	ldr.w	r3, [sl, #12]
  4044ac:	68dc      	ldr	r4, [r3, #12]
					vListRemove( &( pxTCB->xEventListItem ) );
  4044ae:	f104 0018 	add.w	r0, r4, #24
					vListRemove( &( pxTCB->xGenericListItem ) );
  4044b2:	1d25      	adds	r5, r4, #4
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
  4044b4:	47b8      	blx	r7
					vListRemove( &( pxTCB->xGenericListItem ) );
  4044b6:	4628      	mov	r0, r5
  4044b8:	47b8      	blx	r7
					prvAddTaskToReadyQueue( pxTCB );
  4044ba:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  4044bc:	f8d8 e000 	ldr.w	lr, [r8]
  4044c0:	4921      	ldr	r1, [pc, #132]	; (404548 <xTaskResumeAll+0xcc>)
  4044c2:	4a22      	ldr	r2, [pc, #136]	; (40454c <xTaskResumeAll+0xd0>)
  4044c4:	eb03 0083 	add.w	r0, r3, r3, lsl #2
  4044c8:	4573      	cmp	r3, lr
  4044ca:	eb01 0080 	add.w	r0, r1, r0, lsl #2
  4044ce:	4629      	mov	r1, r5
  4044d0:	bf88      	it	hi
  4044d2:	f8c8 3000 	strhi.w	r3, [r8]
  4044d6:	4790      	blx	r2

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  4044d8:	4b1d      	ldr	r3, [pc, #116]	; (404550 <xTaskResumeAll+0xd4>)
  4044da:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  4044dc:	681b      	ldr	r3, [r3, #0]
  4044de:	6adb      	ldr	r3, [r3, #44]	; 0x2c
					{
						xYieldRequired = pdTRUE;
  4044e0:	429a      	cmp	r2, r3
  4044e2:	bf28      	it	cs
  4044e4:	2601      	movcs	r6, #1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
  4044e6:	f8d9 3000 	ldr.w	r3, [r9]
  4044ea:	2b00      	cmp	r3, #0
  4044ec:	d1dc      	bne.n	4044a8 <xTaskResumeAll+0x2c>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
  4044ee:	4c19      	ldr	r4, [pc, #100]	; (404554 <xTaskResumeAll+0xd8>)
  4044f0:	6823      	ldr	r3, [r4, #0]
  4044f2:	b18b      	cbz	r3, 404518 <xTaskResumeAll+0x9c>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
  4044f4:	6823      	ldr	r3, [r4, #0]
  4044f6:	b13b      	cbz	r3, 404508 <xTaskResumeAll+0x8c>
  4044f8:	4d17      	ldr	r5, [pc, #92]	; (404558 <xTaskResumeAll+0xdc>)
					{
						vTaskIncrementTick();
  4044fa:	47a8      	blx	r5
						--uxMissedTicks;
  4044fc:	6823      	ldr	r3, [r4, #0]
  4044fe:	3b01      	subs	r3, #1
  404500:	6023      	str	r3, [r4, #0]
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
  404502:	6823      	ldr	r3, [r4, #0]
  404504:	2b00      	cmp	r3, #0
  404506:	d1f8      	bne.n	4044fa <xTaskResumeAll+0x7e>
  404508:	4b14      	ldr	r3, [pc, #80]	; (40455c <xTaskResumeAll+0xe0>)
  40450a:	e00b      	b.n	404524 <xTaskResumeAll+0xa8>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
  40450c:	2400      	movs	r4, #0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
  40450e:	4b14      	ldr	r3, [pc, #80]	; (404560 <xTaskResumeAll+0xe4>)
  404510:	4798      	blx	r3

	return xAlreadyYielded;
}
  404512:	4620      	mov	r0, r4
  404514:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
  404518:	2e01      	cmp	r6, #1
  40451a:	d0f5      	beq.n	404508 <xTaskResumeAll+0x8c>
  40451c:	4b0f      	ldr	r3, [pc, #60]	; (40455c <xTaskResumeAll+0xe0>)
  40451e:	681a      	ldr	r2, [r3, #0]
  404520:	2a01      	cmp	r2, #1
  404522:	d1f3      	bne.n	40450c <xTaskResumeAll+0x90>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
  404524:	2100      	movs	r1, #0
					portYIELD_WITHIN_API();
  404526:	4a0f      	ldr	r2, [pc, #60]	; (404564 <xTaskResumeAll+0xe8>)
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
  404528:	6019      	str	r1, [r3, #0]
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
  40452a:	2401      	movs	r4, #1
					xMissedYield = pdFALSE;
					portYIELD_WITHIN_API();
  40452c:	4790      	blx	r2
				}
			}
		}
	}
	taskEXIT_CRITICAL();
  40452e:	4b0c      	ldr	r3, [pc, #48]	; (404560 <xTaskResumeAll+0xe4>)
  404530:	4798      	blx	r3

	return xAlreadyYielded;
}
  404532:	4620      	mov	r0, r4
  404534:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  404538:	00403e5d 	.word	0x00403e5d
  40453c:	2000107c 	.word	0x2000107c
  404540:	20001044 	.word	0x20001044
  404544:	00403e09 	.word	0x00403e09
  404548:	20000f98 	.word	0x20000f98
  40454c:	00403db1 	.word	0x00403db1
  404550:	20001064 	.word	0x20001064
  404554:	20001080 	.word	0x20001080
  404558:	00404351 	.word	0x00404351
  40455c:	2000105c 	.word	0x2000105c
  404560:	00403e75 	.word	0x00403e75
  404564:	00403e4d 	.word	0x00403e4d
  404568:	20001048 	.word	0x20001048
  40456c:	20000f90 	.word	0x20000f90

00404570 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
  404570:	b430      	push	{r4, r5}
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
  404572:	4b29      	ldr	r3, [pc, #164]	; (404618 <vTaskSwitchContext+0xa8>)
  404574:	681b      	ldr	r3, [r3, #0]
  404576:	2b00      	cmp	r3, #0
  404578:	d134      	bne.n	4045e4 <vTaskSwitchContext+0x74>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
  40457a:	4b28      	ldr	r3, [pc, #160]	; (40461c <vTaskSwitchContext+0xac>)
  40457c:	4928      	ldr	r1, [pc, #160]	; (404620 <vTaskSwitchContext+0xb0>)
  40457e:	681a      	ldr	r2, [r3, #0]
  404580:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  404584:	0092      	lsls	r2, r2, #2
  404586:	588a      	ldr	r2, [r1, r2]
  404588:	b94a      	cbnz	r2, 40459e <vTaskSwitchContext+0x2e>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
  40458a:	681a      	ldr	r2, [r3, #0]
  40458c:	3a01      	subs	r2, #1
  40458e:	601a      	str	r2, [r3, #0]

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
  404590:	681a      	ldr	r2, [r3, #0]
  404592:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  404596:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
  40459a:	2a00      	cmp	r2, #0
  40459c:	d0f5      	beq.n	40458a <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
  40459e:	681b      	ldr	r3, [r3, #0]
  4045a0:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  4045a4:	eb01 0183 	add.w	r1, r1, r3, lsl #2
  4045a8:	f101 0208 	add.w	r2, r1, #8
  4045ac:	684b      	ldr	r3, [r1, #4]
  4045ae:	685b      	ldr	r3, [r3, #4]
  4045b0:	604b      	str	r3, [r1, #4]
  4045b2:	4293      	cmp	r3, r2
  4045b4:	d02c      	beq.n	404610 <vTaskSwitchContext+0xa0>

		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
  4045b6:	491b      	ldr	r1, [pc, #108]	; (404624 <vTaskSwitchContext+0xb4>)
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
  4045b8:	4a1b      	ldr	r2, [pc, #108]	; (404628 <vTaskSwitchContext+0xb8>)

		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
  4045ba:	6808      	ldr	r0, [r1, #0]
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
  4045bc:	68db      	ldr	r3, [r3, #12]
  4045be:	6013      	str	r3, [r2, #0]

		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
  4045c0:	b170      	cbz	r0, 4045e0 <vTaskSwitchContext+0x70>
  4045c2:	6813      	ldr	r3, [r2, #0]
  4045c4:	4819      	ldr	r0, [pc, #100]	; (40462c <vTaskSwitchContext+0xbc>)
  4045c6:	6c5c      	ldr	r4, [r3, #68]	; 0x44
  4045c8:	6803      	ldr	r3, [r0, #0]
  4045ca:	429c      	cmp	r4, r3
  4045cc:	d008      	beq.n	4045e0 <vTaskSwitchContext+0x70>
  4045ce:	4b18      	ldr	r3, [pc, #96]	; (404630 <vTaskSwitchContext+0xc0>)
  4045d0:	4d18      	ldr	r5, [pc, #96]	; (404634 <vTaskSwitchContext+0xc4>)
  4045d2:	681c      	ldr	r4, [r3, #0]
  4045d4:	682d      	ldr	r5, [r5, #0]
  4045d6:	3408      	adds	r4, #8
  4045d8:	42a5      	cmp	r5, r4
  4045da:	d808      	bhi.n	4045ee <vTaskSwitchContext+0x7e>
  4045dc:	2300      	movs	r3, #0
  4045de:	600b      	str	r3, [r1, #0]
	}
}
  4045e0:	bc30      	pop	{r4, r5}
  4045e2:	4770      	bx	lr
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
  4045e4:	4b14      	ldr	r3, [pc, #80]	; (404638 <vTaskSwitchContext+0xc8>)
  4045e6:	2201      	movs	r2, #1
  4045e8:	601a      	str	r2, [r3, #0]
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );

		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
  4045ea:	bc30      	pop	{r4, r5}
  4045ec:	4770      	bx	lr
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );

		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
  4045ee:	4913      	ldr	r1, [pc, #76]	; (40463c <vTaskSwitchContext+0xcc>)
  4045f0:	6812      	ldr	r2, [r2, #0]
  4045f2:	681c      	ldr	r4, [r3, #0]
  4045f4:	680d      	ldr	r5, [r1, #0]
  4045f6:	6819      	ldr	r1, [r3, #0]
  4045f8:	6c52      	ldr	r2, [r2, #68]	; 0x44
  4045fa:	6002      	str	r2, [r0, #0]
  4045fc:	3104      	adds	r1, #4
  4045fe:	6019      	str	r1, [r3, #0]
  404600:	6818      	ldr	r0, [r3, #0]
  404602:	6819      	ldr	r1, [r3, #0]
  404604:	6025      	str	r5, [r4, #0]
  404606:	3104      	adds	r1, #4
  404608:	6002      	str	r2, [r0, #0]
  40460a:	6019      	str	r1, [r3, #0]
	}
}
  40460c:	bc30      	pop	{r4, r5}
  40460e:	4770      	bx	lr
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
  404610:	685b      	ldr	r3, [r3, #4]
  404612:	604b      	str	r3, [r1, #4]
  404614:	e7cf      	b.n	4045b6 <vTaskSwitchContext+0x46>
  404616:	bf00      	nop
  404618:	2000107c 	.word	0x2000107c
  40461c:	20000f90 	.word	0x20000f90
  404620:	20000f98 	.word	0x20000f98
  404624:	2000103c 	.word	0x2000103c
  404628:	20001064 	.word	0x20001064
  40462c:	200000b8 	.word	0x200000b8
  404630:	20001060 	.word	0x20001060
  404634:	20001084 	.word	0x20001084
  404638:	2000105c 	.word	0x2000105c
  40463c:	20000f94 	.word	0x20000f94

00404640 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
  404640:	b538      	push	{r3, r4, r5, lr}
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
  404642:	4c0c      	ldr	r4, [pc, #48]	; (404674 <vTaskPlaceOnEventList+0x34>)
  404644:	4b0c      	ldr	r3, [pc, #48]	; (404678 <vTaskPlaceOnEventList+0x38>)
  404646:	6822      	ldr	r2, [r4, #0]
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
  404648:	460d      	mov	r5, r1
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
  40464a:	f102 0118 	add.w	r1, r2, #24
  40464e:	4798      	blx	r3

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  404650:	6820      	ldr	r0, [r4, #0]
  404652:	4b0a      	ldr	r3, [pc, #40]	; (40467c <vTaskPlaceOnEventList+0x3c>)
  404654:	3004      	adds	r0, #4
  404656:	4798      	blx	r3


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
  404658:	1c6b      	adds	r3, r5, #1
  40465a:	d005      	beq.n	404668 <vTaskPlaceOnEventList+0x28>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
  40465c:	4a08      	ldr	r2, [pc, #32]	; (404680 <vTaskPlaceOnEventList+0x40>)
			prvAddCurrentTaskToDelayedList( xTimeToWake );
  40465e:	4b09      	ldr	r3, [pc, #36]	; (404684 <vTaskPlaceOnEventList+0x44>)
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
  404660:	6810      	ldr	r0, [r2, #0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
  404662:	4428      	add	r0, r5
  404664:	4798      	blx	r3
  404666:	bd38      	pop	{r3, r4, r5, pc}
		if( xTicksToWait == portMAX_DELAY )
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  404668:	6821      	ldr	r1, [r4, #0]
  40466a:	4807      	ldr	r0, [pc, #28]	; (404688 <vTaskPlaceOnEventList+0x48>)
  40466c:	4b07      	ldr	r3, [pc, #28]	; (40468c <vTaskPlaceOnEventList+0x4c>)
  40466e:	3104      	adds	r1, #4
  404670:	4798      	blx	r3
  404672:	bd38      	pop	{r3, r4, r5, pc}
  404674:	20001064 	.word	0x20001064
  404678:	00403dcd 	.word	0x00403dcd
  40467c:	00403e09 	.word	0x00403e09
  404680:	20000f94 	.word	0x20000f94
  404684:	004042f1 	.word	0x004042f1
  404688:	20001068 	.word	0x20001068
  40468c:	00403db1 	.word	0x00403db1

00404690 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
  404690:	b570      	push	{r4, r5, r6, lr}
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
  404692:	68c3      	ldr	r3, [r0, #12]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
  404694:	4e13      	ldr	r6, [pc, #76]	; (4046e4 <xTaskRemoveFromEventList+0x54>)
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
  404696:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
  404698:	f104 0518 	add.w	r5, r4, #24
  40469c:	4628      	mov	r0, r5
  40469e:	47b0      	blx	r6

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  4046a0:	4b11      	ldr	r3, [pc, #68]	; (4046e8 <xTaskRemoveFromEventList+0x58>)
  4046a2:	681b      	ldr	r3, [r3, #0]
  4046a4:	b9cb      	cbnz	r3, 4046da <xTaskRemoveFromEventList+0x4a>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
  4046a6:	1d25      	adds	r5, r4, #4
  4046a8:	4628      	mov	r0, r5
  4046aa:	47b0      	blx	r6
		prvAddTaskToReadyQueue( pxUnblockedTCB );
  4046ac:	4a0f      	ldr	r2, [pc, #60]	; (4046ec <xTaskRemoveFromEventList+0x5c>)
  4046ae:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  4046b0:	6811      	ldr	r1, [r2, #0]
  4046b2:	480f      	ldr	r0, [pc, #60]	; (4046f0 <xTaskRemoveFromEventList+0x60>)
  4046b4:	428b      	cmp	r3, r1
  4046b6:	bf88      	it	hi
  4046b8:	6013      	strhi	r3, [r2, #0]
  4046ba:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  4046be:	4a0d      	ldr	r2, [pc, #52]	; (4046f4 <xTaskRemoveFromEventList+0x64>)
  4046c0:	4629      	mov	r1, r5
  4046c2:	eb00 0083 	add.w	r0, r0, r3, lsl #2
  4046c6:	4790      	blx	r2
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
  4046c8:	4b0b      	ldr	r3, [pc, #44]	; (4046f8 <xTaskRemoveFromEventList+0x68>)
  4046ca:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
  4046cc:	681b      	ldr	r3, [r3, #0]
  4046ce:	6adb      	ldr	r3, [r3, #44]	; 0x2c
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
  4046d0:	4298      	cmp	r0, r3
  4046d2:	bf34      	ite	cc
  4046d4:	2000      	movcc	r0, #0
  4046d6:	2001      	movcs	r0, #1
  4046d8:	bd70      	pop	{r4, r5, r6, pc}
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
  4046da:	4629      	mov	r1, r5
  4046dc:	4807      	ldr	r0, [pc, #28]	; (4046fc <xTaskRemoveFromEventList+0x6c>)
  4046de:	4b05      	ldr	r3, [pc, #20]	; (4046f4 <xTaskRemoveFromEventList+0x64>)
  4046e0:	4798      	blx	r3
  4046e2:	e7f1      	b.n	4046c8 <xTaskRemoveFromEventList+0x38>
  4046e4:	00403e09 	.word	0x00403e09
  4046e8:	2000107c 	.word	0x2000107c
  4046ec:	20000f90 	.word	0x20000f90
  4046f0:	20000f98 	.word	0x20000f98
  4046f4:	00403db1 	.word	0x00403db1
  4046f8:	20001064 	.word	0x20001064
  4046fc:	20001048 	.word	0x20001048

00404700 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
  404700:	4a03      	ldr	r2, [pc, #12]	; (404710 <vTaskSetTimeOutState+0x10>)
	pxTimeOut->xTimeOnEntering = xTickCount;
  404702:	4b04      	ldr	r3, [pc, #16]	; (404714 <vTaskSetTimeOutState+0x14>)
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
  404704:	6812      	ldr	r2, [r2, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
  404706:	681b      	ldr	r3, [r3, #0]
  404708:	e880 000c 	stmia.w	r0, {r2, r3}
  40470c:	4770      	bx	lr
  40470e:	bf00      	nop
  404710:	20001088 	.word	0x20001088
  404714:	20000f94 	.word	0x20000f94

00404718 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
  404718:	b570      	push	{r4, r5, r6, lr}
  40471a:	460d      	mov	r5, r1
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
  40471c:	4b19      	ldr	r3, [pc, #100]	; (404784 <xTaskCheckForTimeOut+0x6c>)
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
  40471e:	4604      	mov	r4, r0
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
  404720:	4798      	blx	r3
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
  404722:	682b      	ldr	r3, [r5, #0]
  404724:	1c5a      	adds	r2, r3, #1
  404726:	d028      	beq.n	40477a <xTaskCheckForTimeOut+0x62>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
  404728:	4817      	ldr	r0, [pc, #92]	; (404788 <xTaskCheckForTimeOut+0x70>)
  40472a:	6822      	ldr	r2, [r4, #0]
  40472c:	6801      	ldr	r1, [r0, #0]
  40472e:	428a      	cmp	r2, r1
  404730:	d01b      	beq.n	40476a <xTaskCheckForTimeOut+0x52>
  404732:	4916      	ldr	r1, [pc, #88]	; (40478c <xTaskCheckForTimeOut+0x74>)
  404734:	6862      	ldr	r2, [r4, #4]
  404736:	680e      	ldr	r6, [r1, #0]
  404738:	42b2      	cmp	r2, r6
  40473a:	d911      	bls.n	404760 <xTaskCheckForTimeOut+0x48>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
  40473c:	680e      	ldr	r6, [r1, #0]
  40473e:	4913      	ldr	r1, [pc, #76]	; (40478c <xTaskCheckForTimeOut+0x74>)
  404740:	1ab6      	subs	r6, r6, r2
  404742:	42b3      	cmp	r3, r6
  404744:	d90c      	bls.n	404760 <xTaskCheckForTimeOut+0x48>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
  404746:	680e      	ldr	r6, [r1, #0]
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
  404748:	6800      	ldr	r0, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
  40474a:	6809      	ldr	r1, [r1, #0]
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
  40474c:	1b9b      	subs	r3, r3, r6
  40474e:	441a      	add	r2, r3
  404750:	602a      	str	r2, [r5, #0]
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
  404752:	4b0f      	ldr	r3, [pc, #60]	; (404790 <xTaskCheckForTimeOut+0x78>)

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
	pxTimeOut->xTimeOnEntering = xTickCount;
  404754:	e884 0003 	stmia.w	r4, {r0, r1}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
  404758:	2500      	movs	r5, #0
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
  40475a:	4798      	blx	r3

	return xReturn;
}
  40475c:	4628      	mov	r0, r5
  40475e:	bd70      	pop	{r4, r5, r6, pc}
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
  404760:	2501      	movs	r5, #1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
  404762:	4b0b      	ldr	r3, [pc, #44]	; (404790 <xTaskCheckForTimeOut+0x78>)
  404764:	4798      	blx	r3

	return xReturn;
}
  404766:	4628      	mov	r0, r5
  404768:	bd70      	pop	{r4, r5, r6, pc}
  40476a:	4908      	ldr	r1, [pc, #32]	; (40478c <xTaskCheckForTimeOut+0x74>)
  40476c:	6862      	ldr	r2, [r4, #4]
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
  40476e:	680e      	ldr	r6, [r1, #0]
  404770:	4906      	ldr	r1, [pc, #24]	; (40478c <xTaskCheckForTimeOut+0x74>)
  404772:	1ab6      	subs	r6, r6, r2
  404774:	42b3      	cmp	r3, r6
  404776:	d8e6      	bhi.n	404746 <xTaskCheckForTimeOut+0x2e>
  404778:	e7f2      	b.n	404760 <xTaskCheckForTimeOut+0x48>
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
			{
				xReturn = pdFALSE;
  40477a:	2500      	movs	r5, #0
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
  40477c:	4b04      	ldr	r3, [pc, #16]	; (404790 <xTaskCheckForTimeOut+0x78>)
  40477e:	4798      	blx	r3

	return xReturn;
}
  404780:	4628      	mov	r0, r5
  404782:	bd70      	pop	{r4, r5, r6, pc}
  404784:	00403e5d 	.word	0x00403e5d
  404788:	20001088 	.word	0x20001088
  40478c:	20000f94 	.word	0x20000f94
  404790:	00403e75 	.word	0x00403e75

00404794 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
  404794:	4b01      	ldr	r3, [pc, #4]	; (40479c <vTaskMissedYield+0x8>)
  404796:	2201      	movs	r2, #1
  404798:	601a      	str	r2, [r3, #0]
  40479a:	4770      	bx	lr
  40479c:	2000105c 	.word	0x2000105c

004047a0 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
  4047a0:	4b01      	ldr	r3, [pc, #4]	; (4047a8 <xTaskGetCurrentTaskHandle+0x8>)
  4047a2:	6818      	ldr	r0, [r3, #0]

		return xReturn;
	}
  4047a4:	4770      	bx	lr
  4047a6:	bf00      	nop
  4047a8:	20001064 	.word	0x20001064

004047ac <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
  4047ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
  4047ae:	4d16      	ldr	r5, [pc, #88]	; (404808 <vTaskPriorityInherit+0x5c>)
  4047b0:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  4047b2:	682a      	ldr	r2, [r5, #0]
  4047b4:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
  4047b6:	4293      	cmp	r3, r2
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
  4047b8:	4604      	mov	r4, r0
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
  4047ba:	d20f      	bcs.n	4047dc <vTaskPriorityInherit+0x30>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
  4047bc:	682a      	ldr	r2, [r5, #0]

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
  4047be:	4e13      	ldr	r6, [pc, #76]	; (40480c <vTaskPriorityInherit+0x60>)
		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
  4047c0:	6ad1      	ldr	r1, [r2, #44]	; 0x2c

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
  4047c2:	6942      	ldr	r2, [r0, #20]
  4047c4:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  4047c8:	eb06 0383 	add.w	r3, r6, r3, lsl #2
		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
  4047cc:	f1c1 0108 	rsb	r1, r1, #8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
  4047d0:	429a      	cmp	r2, r3
		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
  4047d2:	6181      	str	r1, [r0, #24]

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
  4047d4:	d003      	beq.n	4047de <vTaskPriorityInherit+0x32>
				prvAddTaskToReadyQueue( pxTCB );
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  4047d6:	682b      	ldr	r3, [r5, #0]
  4047d8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  4047da:	62c3      	str	r3, [r0, #44]	; 0x2c
  4047dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
  4047de:	1d07      	adds	r7, r0, #4
  4047e0:	4638      	mov	r0, r7
  4047e2:	4b0b      	ldr	r3, [pc, #44]	; (404810 <vTaskPriorityInherit+0x64>)
  4047e4:	4798      	blx	r3

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  4047e6:	682b      	ldr	r3, [r5, #0]
				prvAddTaskToReadyQueue( pxTCB );
  4047e8:	4a0a      	ldr	r2, [pc, #40]	; (404814 <vTaskPriorityInherit+0x68>)
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
			{
				vListRemove( &( pxTCB->xGenericListItem ) );

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  4047ea:	6adb      	ldr	r3, [r3, #44]	; 0x2c
				prvAddTaskToReadyQueue( pxTCB );
  4047ec:	6811      	ldr	r1, [r2, #0]
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
			{
				vListRemove( &( pxTCB->xGenericListItem ) );

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  4047ee:	62e3      	str	r3, [r4, #44]	; 0x2c
				prvAddTaskToReadyQueue( pxTCB );
  4047f0:	428b      	cmp	r3, r1
  4047f2:	eb03 0083 	add.w	r0, r3, r3, lsl #2
  4047f6:	bf88      	it	hi
  4047f8:	6013      	strhi	r3, [r2, #0]
  4047fa:	eb06 0080 	add.w	r0, r6, r0, lsl #2
  4047fe:	4639      	mov	r1, r7
  404800:	4b05      	ldr	r3, [pc, #20]	; (404818 <vTaskPriorityInherit+0x6c>)
  404802:	4798      	blx	r3
  404804:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  404806:	bf00      	nop
  404808:	20001064 	.word	0x20001064
  40480c:	20000f98 	.word	0x20000f98
  404810:	00403e09 	.word	0x00403e09
  404814:	20000f90 	.word	0x20000f90
  404818:	00403db1 	.word	0x00403db1

0040481c <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
  40481c:	b538      	push	{r3, r4, r5, lr}
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
  40481e:	4604      	mov	r4, r0
  404820:	b1c8      	cbz	r0, 404856 <vTaskPriorityDisinherit+0x3a>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
  404822:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
  404824:	6c83      	ldr	r3, [r0, #72]	; 0x48
  404826:	429a      	cmp	r2, r3
  404828:	d015      	beq.n	404856 <vTaskPriorityDisinherit+0x3a>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
  40482a:	1d05      	adds	r5, r0, #4
  40482c:	4628      	mov	r0, r5
  40482e:	4b0a      	ldr	r3, [pc, #40]	; (404858 <vTaskPriorityDisinherit+0x3c>)
  404830:	4798      	blx	r3

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
				prvAddTaskToReadyQueue( pxTCB );
  404832:	4a0a      	ldr	r2, [pc, #40]	; (40485c <vTaskPriorityDisinherit+0x40>)
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
  404834:	6ca3      	ldr	r3, [r4, #72]	; 0x48
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
				prvAddTaskToReadyQueue( pxTCB );
  404836:	6811      	ldr	r1, [r2, #0]
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
  404838:	62e3      	str	r3, [r4, #44]	; 0x2c
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
  40483a:	f1c3 0008 	rsb	r0, r3, #8
				prvAddTaskToReadyQueue( pxTCB );
  40483e:	428b      	cmp	r3, r1
				vListRemove( &( pxTCB->xGenericListItem ) );

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
  404840:	61a0      	str	r0, [r4, #24]
				prvAddTaskToReadyQueue( pxTCB );
  404842:	4807      	ldr	r0, [pc, #28]	; (404860 <vTaskPriorityDisinherit+0x44>)
  404844:	bf88      	it	hi
  404846:	6013      	strhi	r3, [r2, #0]
  404848:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  40484c:	4a05      	ldr	r2, [pc, #20]	; (404864 <vTaskPriorityDisinherit+0x48>)
  40484e:	4629      	mov	r1, r5
  404850:	eb00 0083 	add.w	r0, r0, r3, lsl #2
  404854:	4790      	blx	r2
  404856:	bd38      	pop	{r3, r4, r5, pc}
  404858:	00403e09 	.word	0x00403e09
  40485c:	20000f90 	.word	0x20000f90
  404860:	20000f98 	.word	0x20000f98
  404864:	00403db1 	.word	0x00403db1

00404868 <WDT_Handler>:

/**
 *  \brief Handler for watchdog interrupt.
 */
void WDT_Handler(void)
{
  404868:	b508      	push	{r3, lr}

	/* Clear status bit to acknowledge interrupt by dummy read. */
	wdt_get_status(WDT);
  40486a:	4803      	ldr	r0, [pc, #12]	; (404878 <WDT_Handler+0x10>)
  40486c:	4b03      	ldr	r3, [pc, #12]	; (40487c <WDT_Handler+0x14>)
  40486e:	4798      	blx	r3

	debugPrintString("Restarting system!!!\r");
  404870:	4803      	ldr	r0, [pc, #12]	; (404880 <WDT_Handler+0x18>)
  404872:	4b04      	ldr	r3, [pc, #16]	; (404884 <WDT_Handler+0x1c>)
  404874:	4798      	blx	r3
  404876:	bd08      	pop	{r3, pc}
  404878:	400e1450 	.word	0x400e1450
  40487c:	00405669 	.word	0x00405669
  404880:	004070a4 	.word	0x004070a4
  404884:	00400e3d 	.word	0x00400e3d

00404888 <itoa>:
 *  Author: sean
 * Copyright Heddoko(TM) 2015, all rights reserved
 */ 

int itoa(int value, char* sp, int radix)
{
  404888:	b4f0      	push	{r4, r5, r6, r7}
	 char tmp[16];		// be careful with the length of the buffer
	 char *tp = tmp;
	 int i;
	 unsigned v;

	 int sign = (radix == 10 && value < 0);
  40488a:	2a0a      	cmp	r2, #10
 *  Author: sean
 * Copyright Heddoko(TM) 2015, all rights reserved
 */ 

int itoa(int value, char* sp, int radix)
{
  40488c:	b084      	sub	sp, #16
	 char tmp[16];		// be careful with the length of the buffer
	 char *tp = tmp;
	 int i;
	 unsigned v;

	 int sign = (radix == 10 && value < 0);
  40488e:	d028      	beq.n	4048e2 <itoa+0x5a>
	 if (sign)
		 v = -value;
	 else
		v = (unsigned)value;
  404890:	2700      	movs	r7, #0
	 while (v || tp == tmp)
	 {
		 i = v % radix;
		 v /= radix;	// v/=radix uses less CPU clocks than v=v/radix does
		 if (i < 10)
			*tp++ = i+'0';
  404892:	466e      	mov	r6, sp
  404894:	466b      	mov	r3, sp
	 if (sign)
		 v = -value;
	 else
		v = (unsigned)value;

	 while (v || tp == tmp)
  404896:	b938      	cbnz	r0, 4048a8 <itoa+0x20>
  404898:	42b3      	cmp	r3, r6
  40489a:	d110      	bne.n	4048be <itoa+0x36>
	 {
		 i = v % radix;
  40489c:	4604      	mov	r4, r0
		 v /= radix;	// v/=radix uses less CPU clocks than v=v/radix does
		 if (i < 10)
			*tp++ = i+'0';
  40489e:	3430      	adds	r4, #48	; 0x30
  4048a0:	701c      	strb	r4, [r3, #0]
  4048a2:	3301      	adds	r3, #1
	 if (sign)
		 v = -value;
	 else
		v = (unsigned)value;

	 while (v || tp == tmp)
  4048a4:	2800      	cmp	r0, #0
  4048a6:	d0f7      	beq.n	404898 <itoa+0x10>
	 {
		 i = v % radix;
  4048a8:	fbb0 f5f2 	udiv	r5, r0, r2
  4048ac:	fb02 0415 	mls	r4, r2, r5, r0
		 v /= radix;	// v/=radix uses less CPU clocks than v=v/radix does
		 if (i < 10)
  4048b0:	2c09      	cmp	r4, #9
		v = (unsigned)value;

	 while (v || tp == tmp)
	 {
		 i = v % radix;
		 v /= radix;	// v/=radix uses less CPU clocks than v=v/radix does
  4048b2:	4628      	mov	r0, r5
		 if (i < 10)
  4048b4:	ddf3      	ble.n	40489e <itoa+0x16>
			*tp++ = i+'0';
		 else
			*tp++ = i + 'a' - 10;
  4048b6:	3457      	adds	r4, #87	; 0x57
  4048b8:	701c      	strb	r4, [r3, #0]
  4048ba:	3301      	adds	r3, #1
  4048bc:	e7eb      	b.n	404896 <itoa+0xe>
	 }

	 int len = tp - tmp;
  4048be:	1b98      	subs	r0, r3, r6

	 if (sign)
  4048c0:	b11f      	cbz	r7, 4048ca <itoa+0x42>
	 {
		 *sp++ = '-';
  4048c2:	222d      	movs	r2, #45	; 0x2d
  4048c4:	700a      	strb	r2, [r1, #0]
		 len++;
  4048c6:	3001      	adds	r0, #1

	 int len = tp - tmp;

	 if (sign)
	 {
		 *sp++ = '-';
  4048c8:	3101      	adds	r1, #1
		 len++;
	 }

	 while (tp > tmp)
  4048ca:	42b3      	cmp	r3, r6
  4048cc:	d906      	bls.n	4048dc <itoa+0x54>
  4048ce:	3901      	subs	r1, #1
	 *sp++ = *--tp;
  4048d0:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
  4048d4:	f801 2f01 	strb.w	r2, [r1, #1]!
	 {
		 *sp++ = '-';
		 len++;
	 }

	 while (tp > tmp)
  4048d8:	42b3      	cmp	r3, r6
  4048da:	d1f9      	bne.n	4048d0 <itoa+0x48>
	 *sp++ = *--tp;

	 return len;
  4048dc:	b004      	add	sp, #16
  4048de:	bcf0      	pop	{r4, r5, r6, r7}
  4048e0:	4770      	bx	lr
	 char tmp[16];		// be careful with the length of the buffer
	 char *tp = tmp;
	 int i;
	 unsigned v;

	 int sign = (radix == 10 && value < 0);
  4048e2:	2800      	cmp	r0, #0
  4048e4:	dad4      	bge.n	404890 <itoa+0x8>
	 if (sign)
		 v = -value;
  4048e6:	4240      	negs	r0, r0
	 char tmp[16];		// be careful with the length of the buffer
	 char *tp = tmp;
	 int i;
	 unsigned v;

	 int sign = (radix == 10 && value < 0);
  4048e8:	2701      	movs	r7, #1
  4048ea:	e7d2      	b.n	404892 <itoa+0xa>

004048ec <drv_gpio_int_cd>:
 * @brief Interrupt routine for SD Card Detect
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_cd(uint32_t ul_id, uint32_t ul_mask)
{
  4048ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_SD_CD].pinId);
  4048ee:	4e0b      	ldr	r6, [pc, #44]	; (40491c <drv_gpio_int_cd+0x30>)
  4048f0:	4b0b      	ldr	r3, [pc, #44]	; (404920 <drv_gpio_int_cd+0x34>)
  4048f2:	f8d6 0100 	ldr.w	r0, [r6, #256]	; 0x100
	pio_disable_interrupt(PIOB, PinMask);
  4048f6:	4d0b      	ldr	r5, [pc, #44]	; (404924 <drv_gpio_int_cd+0x38>)
 * @brief Interrupt routine for SD Card Detect
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_cd(uint32_t ul_id, uint32_t ul_mask)
{
  4048f8:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_SD_CD].pinId);
  4048fa:	4798      	blx	r3
	pio_disable_interrupt(PIOB, PinMask);
  4048fc:	4b0a      	ldr	r3, [pc, #40]	; (404928 <drv_gpio_int_cd+0x3c>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_cd(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_SD_CD].pinId);
  4048fe:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOB, PinMask);
  404900:	4601      	mov	r1, r0
  404902:	4628      	mov	r0, r5
  404904:	4798      	blx	r3
	uint32_t ReadIsr = PIOB->PIO_ISR;
	if (PinMask == ul_mask)
  404906:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_cd(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_SD_CD].pinId);
	pio_disable_interrupt(PIOB, PinMask);
	uint32_t ReadIsr = PIOB->PIO_ISR;
  404908:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_SD_CD].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOB, PinMask);
  40490a:	4806      	ldr	r0, [pc, #24]	; (404924 <drv_gpio_int_cd+0x38>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_SD_CD].pinId);
	pio_disable_interrupt(PIOB, PinMask);
	uint32_t ReadIsr = PIOB->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_SD_CD].gpioSetFlag = 1;
  40490c:	bf04      	itt	eq
  40490e:	2301      	moveq	r3, #1
  404910:	f886 310e 	strbeq.w	r3, [r6, #270]	; 0x10e
	}
	pio_enable_interrupt(PIOB, PinMask);
  404914:	4621      	mov	r1, r4
  404916:	4b05      	ldr	r3, [pc, #20]	; (40492c <drv_gpio_int_cd+0x40>)
  404918:	4798      	blx	r3
  40491a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  40491c:	20000178 	.word	0x20000178
  404920:	00405445 	.word	0x00405445
  404924:	400e1000 	.word	0x400e1000
  404928:	00405281 	.word	0x00405281
  40492c:	00405279 	.word	0x00405279

00404930 <drv_gpio_int_lbo>:
 * @brief Interrupt routine for Low Battery Out
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_lbo(uint32_t ul_id, uint32_t ul_mask)
{
  404930:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_LBO].pinId);
  404932:	4e0b      	ldr	r6, [pc, #44]	; (404960 <drv_gpio_int_lbo+0x30>)
  404934:	4b0b      	ldr	r3, [pc, #44]	; (404964 <drv_gpio_int_lbo+0x34>)
  404936:	f8d6 00f0 	ldr.w	r0, [r6, #240]	; 0xf0
	pio_disable_interrupt(PIOA, PinMask);
  40493a:	4d0b      	ldr	r5, [pc, #44]	; (404968 <drv_gpio_int_lbo+0x38>)
 * @brief Interrupt routine for Low Battery Out
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_lbo(uint32_t ul_id, uint32_t ul_mask)
{
  40493c:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_LBO].pinId);
  40493e:	4798      	blx	r3
	pio_disable_interrupt(PIOA, PinMask);
  404940:	4b0a      	ldr	r3, [pc, #40]	; (40496c <drv_gpio_int_lbo+0x3c>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_lbo(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_LBO].pinId);
  404942:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOA, PinMask);
  404944:	4601      	mov	r1, r0
  404946:	4628      	mov	r0, r5
  404948:	4798      	blx	r3
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
  40494a:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_lbo(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_LBO].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
  40494c:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_LBO].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOA, PinMask);
  40494e:	4806      	ldr	r0, [pc, #24]	; (404968 <drv_gpio_int_lbo+0x38>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_LBO].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_LBO].gpioSetFlag = 1;
  404950:	bf04      	itt	eq
  404952:	2301      	moveq	r3, #1
  404954:	f886 30fe 	strbeq.w	r3, [r6, #254]	; 0xfe
	}
	pio_enable_interrupt(PIOA, PinMask);
  404958:	4621      	mov	r1, r4
  40495a:	4b05      	ldr	r3, [pc, #20]	; (404970 <drv_gpio_int_lbo+0x40>)
  40495c:	4798      	blx	r3
  40495e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  404960:	20000178 	.word	0x20000178
  404964:	00405445 	.word	0x00405445
  404968:	400e0e00 	.word	0x400e0e00
  40496c:	00405281 	.word	0x00405281
  404970:	00405279 	.word	0x00405279

00404974 <drv_gpio_int_dc2>:
 * @brief Interrupt routine for Jack-2 Detect
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_dc2(uint32_t ul_id, uint32_t ul_mask)
{
  404974:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC2].pinId);
  404976:	4e0b      	ldr	r6, [pc, #44]	; (4049a4 <drv_gpio_int_dc2+0x30>)
  404978:	4b0b      	ldr	r3, [pc, #44]	; (4049a8 <drv_gpio_int_dc2+0x34>)
  40497a:	6e30      	ldr	r0, [r6, #96]	; 0x60
	pio_disable_interrupt(PIOA, PinMask);
  40497c:	4d0b      	ldr	r5, [pc, #44]	; (4049ac <drv_gpio_int_dc2+0x38>)
 * @brief Interrupt routine for Jack-2 Detect
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_dc2(uint32_t ul_id, uint32_t ul_mask)
{
  40497e:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC2].pinId);
  404980:	4798      	blx	r3
	pio_disable_interrupt(PIOA, PinMask);
  404982:	4b0b      	ldr	r3, [pc, #44]	; (4049b0 <drv_gpio_int_dc2+0x3c>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_dc2(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC2].pinId);
  404984:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOA, PinMask);
  404986:	4601      	mov	r1, r0
  404988:	4628      	mov	r0, r5
  40498a:	4798      	blx	r3
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
  40498c:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_dc2(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC2].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
  40498e:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_JC_DC2].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOA, PinMask);
  404990:	4806      	ldr	r0, [pc, #24]	; (4049ac <drv_gpio_int_dc2+0x38>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC2].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_JC_DC2].gpioSetFlag = 1;
  404992:	bf04      	itt	eq
  404994:	2301      	moveq	r3, #1
  404996:	f886 306e 	strbeq.w	r3, [r6, #110]	; 0x6e
	}
	pio_enable_interrupt(PIOA, PinMask);
  40499a:	4621      	mov	r1, r4
  40499c:	4b05      	ldr	r3, [pc, #20]	; (4049b4 <drv_gpio_int_dc2+0x40>)
  40499e:	4798      	blx	r3
  4049a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  4049a2:	bf00      	nop
  4049a4:	20000178 	.word	0x20000178
  4049a8:	00405445 	.word	0x00405445
  4049ac:	400e0e00 	.word	0x400e0e00
  4049b0:	00405281 	.word	0x00405281
  4049b4:	00405279 	.word	0x00405279

004049b8 <drv_gpio_int_dc1>:
 * @brief Interrupt routine for Jack-1 Detect
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_dc1(uint32_t ul_id, uint32_t ul_mask)
{
  4049b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC1].pinId);
  4049ba:	4e0b      	ldr	r6, [pc, #44]	; (4049e8 <drv_gpio_int_dc1+0x30>)
  4049bc:	4b0b      	ldr	r3, [pc, #44]	; (4049ec <drv_gpio_int_dc1+0x34>)
  4049be:	6d30      	ldr	r0, [r6, #80]	; 0x50
	pio_disable_interrupt(PIOA, PinMask);
  4049c0:	4d0b      	ldr	r5, [pc, #44]	; (4049f0 <drv_gpio_int_dc1+0x38>)
 * @brief Interrupt routine for Jack-1 Detect
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_dc1(uint32_t ul_id, uint32_t ul_mask)
{
  4049c2:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC1].pinId);
  4049c4:	4798      	blx	r3
	pio_disable_interrupt(PIOA, PinMask);
  4049c6:	4b0b      	ldr	r3, [pc, #44]	; (4049f4 <drv_gpio_int_dc1+0x3c>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_dc1(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC1].pinId);
  4049c8:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOA, PinMask);
  4049ca:	4601      	mov	r1, r0
  4049cc:	4628      	mov	r0, r5
  4049ce:	4798      	blx	r3
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
  4049d0:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_dc1(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC1].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
  4049d2:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_JC_DC1].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOA, PinMask);
  4049d4:	4806      	ldr	r0, [pc, #24]	; (4049f0 <drv_gpio_int_dc1+0x38>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC1].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_JC_DC1].gpioSetFlag = 1;
  4049d6:	bf04      	itt	eq
  4049d8:	2301      	moveq	r3, #1
  4049da:	f886 305e 	strbeq.w	r3, [r6, #94]	; 0x5e
	}
	pio_enable_interrupt(PIOA, PinMask);
  4049de:	4621      	mov	r1, r4
  4049e0:	4b05      	ldr	r3, [pc, #20]	; (4049f8 <drv_gpio_int_dc1+0x40>)
  4049e2:	4798      	blx	r3
  4049e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  4049e6:	bf00      	nop
  4049e8:	20000178 	.word	0x20000178
  4049ec:	00405445 	.word	0x00405445
  4049f0:	400e0e00 	.word	0x400e0e00
  4049f4:	00405281 	.word	0x00405281
  4049f8:	00405279 	.word	0x00405279

004049fc <drv_gpio_int_oc2>:
 * @brief Interrupt routine for Jack-2 Over Current
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_oc2(uint32_t ul_id, uint32_t ul_mask)
{
  4049fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC2].pinId);
  4049fe:	4e0b      	ldr	r6, [pc, #44]	; (404a2c <drv_gpio_int_oc2+0x30>)
  404a00:	4b0b      	ldr	r3, [pc, #44]	; (404a30 <drv_gpio_int_oc2+0x34>)
  404a02:	6c30      	ldr	r0, [r6, #64]	; 0x40
	pio_disable_interrupt(PIOA, PinMask);
  404a04:	4d0b      	ldr	r5, [pc, #44]	; (404a34 <drv_gpio_int_oc2+0x38>)
 * @brief Interrupt routine for Jack-2 Over Current
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_oc2(uint32_t ul_id, uint32_t ul_mask)
{
  404a06:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC2].pinId);
  404a08:	4798      	blx	r3
	pio_disable_interrupt(PIOA, PinMask);
  404a0a:	4b0b      	ldr	r3, [pc, #44]	; (404a38 <drv_gpio_int_oc2+0x3c>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_oc2(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC2].pinId);
  404a0c:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOA, PinMask);
  404a0e:	4601      	mov	r1, r0
  404a10:	4628      	mov	r0, r5
  404a12:	4798      	blx	r3
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
  404a14:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_oc2(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC2].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
  404a16:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_JC_OC2].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOA, PinMask);
  404a18:	4806      	ldr	r0, [pc, #24]	; (404a34 <drv_gpio_int_oc2+0x38>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC2].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_JC_OC2].gpioSetFlag = 1;
  404a1a:	bf04      	itt	eq
  404a1c:	2301      	moveq	r3, #1
  404a1e:	f886 304e 	strbeq.w	r3, [r6, #78]	; 0x4e
	}
	pio_enable_interrupt(PIOA, PinMask);
  404a22:	4621      	mov	r1, r4
  404a24:	4b05      	ldr	r3, [pc, #20]	; (404a3c <drv_gpio_int_oc2+0x40>)
  404a26:	4798      	blx	r3
  404a28:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  404a2a:	bf00      	nop
  404a2c:	20000178 	.word	0x20000178
  404a30:	00405445 	.word	0x00405445
  404a34:	400e0e00 	.word	0x400e0e00
  404a38:	00405281 	.word	0x00405281
  404a3c:	00405279 	.word	0x00405279

00404a40 <drv_gpio_int_oc1>:
 * @brief Interrupt routine for Jack-1 Over Current
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_oc1(uint32_t ul_id, uint32_t ul_mask)
{
  404a40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC1].pinId);
  404a42:	4e0b      	ldr	r6, [pc, #44]	; (404a70 <drv_gpio_int_oc1+0x30>)
  404a44:	4b0b      	ldr	r3, [pc, #44]	; (404a74 <drv_gpio_int_oc1+0x34>)
  404a46:	6b30      	ldr	r0, [r6, #48]	; 0x30
	pio_disable_interrupt(PIOA, PinMask);
  404a48:	4d0b      	ldr	r5, [pc, #44]	; (404a78 <drv_gpio_int_oc1+0x38>)
 * @brief Interrupt routine for Jack-1 Over Current
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_oc1(uint32_t ul_id, uint32_t ul_mask)
{
  404a4a:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC1].pinId);
  404a4c:	4798      	blx	r3
	pio_disable_interrupt(PIOA, PinMask);
  404a4e:	4b0b      	ldr	r3, [pc, #44]	; (404a7c <drv_gpio_int_oc1+0x3c>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_oc1(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC1].pinId);
  404a50:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOA, PinMask);
  404a52:	4601      	mov	r1, r0
  404a54:	4628      	mov	r0, r5
  404a56:	4798      	blx	r3
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
  404a58:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_oc1(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC1].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
  404a5a:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_JC_OC1].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOA, PinMask);
  404a5c:	4806      	ldr	r0, [pc, #24]	; (404a78 <drv_gpio_int_oc1+0x38>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC1].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_JC_OC1].gpioSetFlag = 1;
  404a5e:	bf04      	itt	eq
  404a60:	2301      	moveq	r3, #1
  404a62:	f886 303e 	strbeq.w	r3, [r6, #62]	; 0x3e
	}
	pio_enable_interrupt(PIOA, PinMask);
  404a66:	4621      	mov	r1, r4
  404a68:	4b05      	ldr	r3, [pc, #20]	; (404a80 <drv_gpio_int_oc1+0x40>)
  404a6a:	4798      	blx	r3
  404a6c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  404a6e:	bf00      	nop
  404a70:	20000178 	.word	0x20000178
  404a74:	00405445 	.word	0x00405445
  404a78:	400e0e00 	.word	0x400e0e00
  404a7c:	00405281 	.word	0x00405281
  404a80:	00405279 	.word	0x00405279

00404a84 <drv_gpio_int_sw2>:
 * @brief Interrupt routine for Action Switch-2
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_sw2(uint32_t ul_id, uint32_t ul_mask)
{
  404a84:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW2].pinId);
  404a86:	4e0b      	ldr	r6, [pc, #44]	; (404ab4 <drv_gpio_int_sw2+0x30>)
  404a88:	4b0b      	ldr	r3, [pc, #44]	; (404ab8 <drv_gpio_int_sw2+0x34>)
  404a8a:	6a30      	ldr	r0, [r6, #32]
	pio_disable_interrupt(PIOA, PinMask);
  404a8c:	4d0b      	ldr	r5, [pc, #44]	; (404abc <drv_gpio_int_sw2+0x38>)
 * @brief Interrupt routine for Action Switch-2
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_sw2(uint32_t ul_id, uint32_t ul_mask)
{
  404a8e:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW2].pinId);
  404a90:	4798      	blx	r3
	pio_disable_interrupt(PIOA, PinMask);
  404a92:	4b0b      	ldr	r3, [pc, #44]	; (404ac0 <drv_gpio_int_sw2+0x3c>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_sw2(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW2].pinId);
  404a94:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOA, PinMask);
  404a96:	4601      	mov	r1, r0
  404a98:	4628      	mov	r0, r5
  404a9a:	4798      	blx	r3
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
  404a9c:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_sw2(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW2].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
  404a9e:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_AC_SW2].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOA, PinMask);
  404aa0:	4806      	ldr	r0, [pc, #24]	; (404abc <drv_gpio_int_sw2+0x38>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW2].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_AC_SW2].gpioSetFlag = 1;
  404aa2:	bf04      	itt	eq
  404aa4:	2301      	moveq	r3, #1
  404aa6:	f886 302e 	strbeq.w	r3, [r6, #46]	; 0x2e
	}
	pio_enable_interrupt(PIOA, PinMask);
  404aaa:	4621      	mov	r1, r4
  404aac:	4b05      	ldr	r3, [pc, #20]	; (404ac4 <drv_gpio_int_sw2+0x40>)
  404aae:	4798      	blx	r3
  404ab0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  404ab2:	bf00      	nop
  404ab4:	20000178 	.word	0x20000178
  404ab8:	00405445 	.word	0x00405445
  404abc:	400e0e00 	.word	0x400e0e00
  404ac0:	00405281 	.word	0x00405281
  404ac4:	00405279 	.word	0x00405279

00404ac8 <drv_gpio_int_sw1>:
 * @brief Interrupt routine for Action Switch-1
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_sw1(uint32_t ul_id, uint32_t ul_mask)
{
  404ac8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW1].pinId);
  404aca:	4e0a      	ldr	r6, [pc, #40]	; (404af4 <drv_gpio_int_sw1+0x2c>)
  404acc:	4b0a      	ldr	r3, [pc, #40]	; (404af8 <drv_gpio_int_sw1+0x30>)
  404ace:	6930      	ldr	r0, [r6, #16]
	pio_disable_interrupt(PIOA, PinMask);
  404ad0:	4d0a      	ldr	r5, [pc, #40]	; (404afc <drv_gpio_int_sw1+0x34>)
 * @brief Interrupt routine for Action Switch-1
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_sw1(uint32_t ul_id, uint32_t ul_mask)
{
  404ad2:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW1].pinId);
  404ad4:	4798      	blx	r3
	pio_disable_interrupt(PIOA, PinMask);
  404ad6:	4b0a      	ldr	r3, [pc, #40]	; (404b00 <drv_gpio_int_sw1+0x38>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_sw1(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW1].pinId);
  404ad8:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOA, PinMask);
  404ada:	4601      	mov	r1, r0
  404adc:	4628      	mov	r0, r5
  404ade:	4798      	blx	r3
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
  404ae0:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_sw1(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW1].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
  404ae2:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_AC_SW1].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOA, PinMask);
  404ae4:	4805      	ldr	r0, [pc, #20]	; (404afc <drv_gpio_int_sw1+0x34>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW1].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_AC_SW1].gpioSetFlag = 1;
  404ae6:	bf04      	itt	eq
  404ae8:	2301      	moveq	r3, #1
  404aea:	77b3      	strbeq	r3, [r6, #30]
	}
	pio_enable_interrupt(PIOA, PinMask);
  404aec:	4621      	mov	r1, r4
  404aee:	4b05      	ldr	r3, [pc, #20]	; (404b04 <drv_gpio_int_sw1+0x3c>)
  404af0:	4798      	blx	r3
  404af2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  404af4:	20000178 	.word	0x20000178
  404af8:	00405445 	.word	0x00405445
  404afc:	400e0e00 	.word	0x400e0e00
  404b00:	00405281 	.word	0x00405281
  404b04:	00405279 	.word	0x00405279

00404b08 <drv_gpio_int_pw>:
 * @brief Interrupt routine for Power Switch
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_pw(uint32_t ul_id, uint32_t ul_mask)
{
  404b08:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_PW_SW].pinId);
  404b0a:	4e0a      	ldr	r6, [pc, #40]	; (404b34 <drv_gpio_int_pw+0x2c>)
  404b0c:	4b0a      	ldr	r3, [pc, #40]	; (404b38 <drv_gpio_int_pw+0x30>)
  404b0e:	6830      	ldr	r0, [r6, #0]
	pio_disable_interrupt(PIOA, PinMask);
  404b10:	4d0a      	ldr	r5, [pc, #40]	; (404b3c <drv_gpio_int_pw+0x34>)
 * @brief Interrupt routine for Power Switch
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_pw(uint32_t ul_id, uint32_t ul_mask)
{
  404b12:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_PW_SW].pinId);
  404b14:	4798      	blx	r3
	pio_disable_interrupt(PIOA, PinMask);
  404b16:	4b0a      	ldr	r3, [pc, #40]	; (404b40 <drv_gpio_int_pw+0x38>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_pw(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_PW_SW].pinId);
  404b18:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOA, PinMask);
  404b1a:	4601      	mov	r1, r0
  404b1c:	4628      	mov	r0, r5
  404b1e:	4798      	blx	r3
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
  404b20:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_pw(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_PW_SW].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
  404b22:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_PW_SW].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOA, PinMask);
  404b24:	4805      	ldr	r0, [pc, #20]	; (404b3c <drv_gpio_int_pw+0x34>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_PW_SW].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_PW_SW].gpioSetFlag = 1;
  404b26:	bf04      	itt	eq
  404b28:	2301      	moveq	r3, #1
  404b2a:	73b3      	strbeq	r3, [r6, #14]
	}
	pio_enable_interrupt(PIOA, PinMask);
  404b2c:	4621      	mov	r1, r4
  404b2e:	4b05      	ldr	r3, [pc, #20]	; (404b44 <drv_gpio_int_pw+0x3c>)
  404b30:	4798      	blx	r3
  404b32:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  404b34:	20000178 	.word	0x20000178
  404b38:	00405445 	.word	0x00405445
  404b3c:	400e0e00 	.word	0x400e0e00
  404b40:	00405281 	.word	0x00405281
  404b44:	00405279 	.word	0x00405279

00404b48 <drv_gpio_config>:
 * @brief Set and configure all GPIOs
 * @param drv_gpio_config_t* gpioConfig
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t drv_gpio_config(drv_gpio_config_t* gpioConfig)
{
  404b48:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	status_t status = STATUS_PASS;
	unsigned long PinFlag = 0;	
	if(gpioConfig->pinMode == DRV_GPIO_PIN_MODE_INPUT)	//Check if input or output
  404b4c:	7903      	ldrb	r3, [r0, #4]
  404b4e:	2b01      	cmp	r3, #1
 * @brief Set and configure all GPIOs
 * @param drv_gpio_config_t* gpioConfig
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t drv_gpio_config(drv_gpio_config_t* gpioConfig)
{
  404b50:	b082      	sub	sp, #8
  404b52:	4604      	mov	r4, r0
	status_t status = STATUS_PASS;
	unsigned long PinFlag = 0;	
	if(gpioConfig->pinMode == DRV_GPIO_PIN_MODE_INPUT)	//Check if input or output
  404b54:	d011      	beq.n	404b7a <drv_gpio_config+0x32>
		p_pio->PIO_PPDDR |= PinMask; 
		
	}
	else	//The pin is output
	{
		if (gpioConfig->initialPinState == DRV_GPIO_PIN_STATE_HIGH)
  404b56:	7942      	ldrb	r2, [r0, #5]
		else
		{
			PinFlag |= PIO_TYPE_PIO_OUTPUT_0;	//set default pin state
		}
		
		pmc_enable_periph_clk(gpioConfig->pinId);
  404b58:	4b36      	ldr	r3, [pc, #216]	; (404c34 <drv_gpio_config+0xec>)
  404b5a:	6800      	ldr	r0, [r0, #0]
	}
	else	//The pin is output
	{
		if (gpioConfig->initialPinState == DRV_GPIO_PIN_STATE_HIGH)
		{
			PinFlag |= PIO_TYPE_PIO_OUTPUT_1;	//set default pin state
  404b5c:	2a01      	cmp	r2, #1
  404b5e:	bf14      	ite	ne
  404b60:	f04f 5540 	movne.w	r5, #805306368	; 0x30000000
  404b64:	f04f 5560 	moveq.w	r5, #939524096	; 0x38000000
		else
		{
			PinFlag |= PIO_TYPE_PIO_OUTPUT_0;	//set default pin state
		}
		
		pmc_enable_periph_clk(gpioConfig->pinId);
  404b68:	4798      	blx	r3
		pio_configure_pin(gpioConfig->pinId, PinFlag);
  404b6a:	4629      	mov	r1, r5
  404b6c:	6820      	ldr	r0, [r4, #0]
  404b6e:	4b32      	ldr	r3, [pc, #200]	; (404c38 <drv_gpio_config+0xf0>)
  404b70:	4798      	blx	r3
	}
	
	return status;
}
  404b72:	2000      	movs	r0, #0
  404b74:	b002      	add	sp, #8
  404b76:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	status_t status = STATUS_PASS;
	unsigned long PinFlag = 0;	
	if(gpioConfig->pinMode == DRV_GPIO_PIN_MODE_INPUT)	//Check if input or output
	{
		PinFlag |= PIO_TYPE_PIO_INPUT;	//Set as input
		if (gpioConfig->pullUpEnabled == TRUE)
  404b7a:	7b02      	ldrb	r2, [r0, #12]
{
	status_t status = STATUS_PASS;
	unsigned long PinFlag = 0;	
	if(gpioConfig->pinMode == DRV_GPIO_PIN_MODE_INPUT)	//Check if input or output
	{
		PinFlag |= PIO_TYPE_PIO_INPUT;	//Set as input
  404b7c:	4f2f      	ldr	r7, [pc, #188]	; (404c3c <drv_gpio_config+0xf4>)
		if (gpioConfig->pullUpEnabled == TRUE)
		{
			PinFlag |= PIO_PULLUP;	//enable the pull up
		}
		
		if (gpioConfig->debounceEnabled == TRUE)
  404b7e:	7b43      	ldrb	r3, [r0, #13]
{
	status_t status = STATUS_PASS;
	unsigned long PinFlag = 0;	
	if(gpioConfig->pinMode == DRV_GPIO_PIN_MODE_INPUT)	//Check if input or output
	{
		PinFlag |= PIO_TYPE_PIO_INPUT;	//Set as input
  404b80:	2a01      	cmp	r2, #1
  404b82:	bf18      	it	ne
  404b84:	f04f 5720 	movne.w	r7, #671088640	; 0x28000000
		if (gpioConfig->pullUpEnabled == TRUE)
		{
			PinFlag |= PIO_PULLUP;	//enable the pull up
		}
		
		if (gpioConfig->debounceEnabled == TRUE)
  404b88:	2b01      	cmp	r3, #1
  404b8a:	d03c      	beq.n	404c06 <drv_gpio_config+0xbe>
  404b8c:	4d2c      	ldr	r5, [pc, #176]	; (404c40 <drv_gpio_config+0xf8>)
  404b8e:	4e2d      	ldr	r6, [pc, #180]	; (404c44 <drv_gpio_config+0xfc>)
			Pio *p_pio = pio_get_pin_group(gpioConfig->pinId);
			uint32_t PinMask = pio_get_pin_group_mask(gpioConfig->pinId);	//PinMask
			pio_set_debounce_filter(p_pio, PinMask, DEBOUNCE_PERIOD);
		}
		
		pmc_enable_periph_clk(gpioConfig->pinId);	
  404b90:	4b28      	ldr	r3, [pc, #160]	; (404c34 <drv_gpio_config+0xec>)
  404b92:	6820      	ldr	r0, [r4, #0]
  404b94:	4798      	blx	r3
		pio_configure_pin(gpioConfig->pinId, PinFlag);
  404b96:	4b28      	ldr	r3, [pc, #160]	; (404c38 <drv_gpio_config+0xf0>)
  404b98:	6820      	ldr	r0, [r4, #0]
  404b9a:	4639      	mov	r1, r7
  404b9c:	4798      	blx	r3
		 
		PinFlag = 0;	//Reset the PinFlag to use it to configure interrupt
		switch(gpioConfig->interruptType)	//set interrupt configuration flag
  404b9e:	79a3      	ldrb	r3, [r4, #6]
  404ba0:	2b03      	cmp	r3, #3
  404ba2:	d829      	bhi.n	404bf8 <drv_gpio_config+0xb0>
  404ba4:	4a28      	ldr	r2, [pc, #160]	; (404c48 <drv_gpio_config+0x100>)
				break;
			case DRV_GPIO_INTERRUPT_NONE :
			default:
				break;
		}
		Pio *p_pio = pio_get_pin_group(gpioConfig->pinId);	//peripheral ID
  404ba6:	6820      	ldr	r0, [r4, #0]
  404ba8:	f852 7023 	ldr.w	r7, [r2, r3, lsl #2]
  404bac:	47a8      	blx	r5
  404bae:	4605      	mov	r5, r0
		uint32_t PinMask = pio_get_pin_group_mask(gpioConfig->pinId);	//PinMask
  404bb0:	6820      	ldr	r0, [r4, #0]
  404bb2:	47b0      	blx	r6
		if (PinFlag & (PIO_IT_RISE_EDGE | PIO_IT_FALL_EDGE | PIO_IT_HIGH_LEVEL | PIO_IT_LOW_LEVEL))	//if set as interrupt, enable and configure it
  404bb4:	f017 0f70 	tst.w	r7, #112	; 0x70
			case DRV_GPIO_INTERRUPT_NONE :
			default:
				break;
		}
		Pio *p_pio = pio_get_pin_group(gpioConfig->pinId);	//peripheral ID
		uint32_t PinMask = pio_get_pin_group_mask(gpioConfig->pinId);	//PinMask
  404bb8:	4606      	mov	r6, r0
		if (PinFlag & (PIO_IT_RISE_EDGE | PIO_IT_FALL_EDGE | PIO_IT_HIGH_LEVEL | PIO_IT_LOW_LEVEL))	//if set as interrupt, enable and configure it
  404bba:	d014      	beq.n	404be6 <drv_gpio_config+0x9e>
		{			
			uint32_t PinPio = pio_get_pin_group_id(gpioConfig->pinId);	//Pin ID
  404bbc:	6820      	ldr	r0, [r4, #0]
  404bbe:	4b23      	ldr	r3, [pc, #140]	; (404c4c <drv_gpio_config+0x104>)
  404bc0:	4798      	blx	r3
			pio_handler_set(p_pio, PinPio, PinMask, PinFlag, gpioConfig->interruptHandler);
  404bc2:	68a3      	ldr	r3, [r4, #8]
  404bc4:	9300      	str	r3, [sp, #0]
		}
		Pio *p_pio = pio_get_pin_group(gpioConfig->pinId);	//peripheral ID
		uint32_t PinMask = pio_get_pin_group_mask(gpioConfig->pinId);	//PinMask
		if (PinFlag & (PIO_IT_RISE_EDGE | PIO_IT_FALL_EDGE | PIO_IT_HIGH_LEVEL | PIO_IT_LOW_LEVEL))	//if set as interrupt, enable and configure it
		{			
			uint32_t PinPio = pio_get_pin_group_id(gpioConfig->pinId);	//Pin ID
  404bc6:	4601      	mov	r1, r0
			pio_handler_set(p_pio, PinPio, PinMask, PinFlag, gpioConfig->interruptHandler);
  404bc8:	463b      	mov	r3, r7
  404bca:	4632      	mov	r2, r6
  404bcc:	4628      	mov	r0, r5
  404bce:	4c20      	ldr	r4, [pc, #128]	; (404c50 <drv_gpio_config+0x108>)
  404bd0:	47a0      	blx	r4
			pio_enable_interrupt(p_pio, PinMask);
  404bd2:	4b20      	ldr	r3, [pc, #128]	; (404c54 <drv_gpio_config+0x10c>)
  404bd4:	4628      	mov	r0, r5
  404bd6:	4631      	mov	r1, r6
  404bd8:	4798      	blx	r3
			if (p_pio == PIOA)
  404bda:	4b1f      	ldr	r3, [pc, #124]	; (404c58 <drv_gpio_config+0x110>)
  404bdc:	429d      	cmp	r5, r3
  404bde:	d024      	beq.n	404c2a <drv_gpio_config+0xe2>
			{
				NVIC_EnableIRQ(PIOA_IRQn);
			}
			else if (p_pio == PIOB)
  404be0:	4b1e      	ldr	r3, [pc, #120]	; (404c5c <drv_gpio_config+0x114>)
  404be2:	429d      	cmp	r5, r3
  404be4:	d01c      	beq.n	404c20 <drv_gpio_config+0xd8>
			{
				NVIC_EnableIRQ(PIOB_IRQn);
			}
		}
		//turn off any pulldown resistors
		p_pio->PIO_PPDDR |= PinMask; 
  404be6:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
		pmc_enable_periph_clk(gpioConfig->pinId);
		pio_configure_pin(gpioConfig->pinId, PinFlag);
	}
	
	return status;
}
  404bea:	2000      	movs	r0, #0
			{
				NVIC_EnableIRQ(PIOB_IRQn);
			}
		}
		//turn off any pulldown resistors
		p_pio->PIO_PPDDR |= PinMask; 
  404bec:	431e      	orrs	r6, r3
  404bee:	f8c5 6090 	str.w	r6, [r5, #144]	; 0x90
		pmc_enable_periph_clk(gpioConfig->pinId);
		pio_configure_pin(gpioConfig->pinId, PinFlag);
	}
	
	return status;
}
  404bf2:	b002      	add	sp, #8
  404bf4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				break;
			case DRV_GPIO_INTERRUPT_NONE :
			default:
				break;
		}
		Pio *p_pio = pio_get_pin_group(gpioConfig->pinId);	//peripheral ID
  404bf8:	6820      	ldr	r0, [r4, #0]
  404bfa:	47a8      	blx	r5
  404bfc:	4605      	mov	r5, r0
		uint32_t PinMask = pio_get_pin_group_mask(gpioConfig->pinId);	//PinMask
  404bfe:	6820      	ldr	r0, [r4, #0]
  404c00:	47b0      	blx	r6
  404c02:	4606      	mov	r6, r0
  404c04:	e7ef      	b.n	404be6 <drv_gpio_config+0x9e>
		}
		
		if (gpioConfig->debounceEnabled == TRUE)
		{
			//PinFlag |= PIO_DEBOUNCE;	//enable debounce filter
			Pio *p_pio = pio_get_pin_group(gpioConfig->pinId);
  404c06:	4d0e      	ldr	r5, [pc, #56]	; (404c40 <drv_gpio_config+0xf8>)
  404c08:	6800      	ldr	r0, [r0, #0]
			uint32_t PinMask = pio_get_pin_group_mask(gpioConfig->pinId);	//PinMask
  404c0a:	4e0e      	ldr	r6, [pc, #56]	; (404c44 <drv_gpio_config+0xfc>)
		}
		
		if (gpioConfig->debounceEnabled == TRUE)
		{
			//PinFlag |= PIO_DEBOUNCE;	//enable debounce filter
			Pio *p_pio = pio_get_pin_group(gpioConfig->pinId);
  404c0c:	47a8      	blx	r5
  404c0e:	4680      	mov	r8, r0
			uint32_t PinMask = pio_get_pin_group_mask(gpioConfig->pinId);	//PinMask
  404c10:	6820      	ldr	r0, [r4, #0]
  404c12:	47b0      	blx	r6
			pio_set_debounce_filter(p_pio, PinMask, DEBOUNCE_PERIOD);
  404c14:	2205      	movs	r2, #5
		
		if (gpioConfig->debounceEnabled == TRUE)
		{
			//PinFlag |= PIO_DEBOUNCE;	//enable debounce filter
			Pio *p_pio = pio_get_pin_group(gpioConfig->pinId);
			uint32_t PinMask = pio_get_pin_group_mask(gpioConfig->pinId);	//PinMask
  404c16:	4601      	mov	r1, r0
			pio_set_debounce_filter(p_pio, PinMask, DEBOUNCE_PERIOD);
  404c18:	4b11      	ldr	r3, [pc, #68]	; (404c60 <drv_gpio_config+0x118>)
  404c1a:	4640      	mov	r0, r8
  404c1c:	4798      	blx	r3
  404c1e:	e7b7      	b.n	404b90 <drv_gpio_config+0x48>
    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
  404c20:	4b10      	ldr	r3, [pc, #64]	; (404c64 <drv_gpio_config+0x11c>)
  404c22:	f44f 5280 	mov.w	r2, #4096	; 0x1000
  404c26:	601a      	str	r2, [r3, #0]
  404c28:	e7dd      	b.n	404be6 <drv_gpio_config+0x9e>
  404c2a:	4b0e      	ldr	r3, [pc, #56]	; (404c64 <drv_gpio_config+0x11c>)
  404c2c:	f44f 6200 	mov.w	r2, #2048	; 0x800
  404c30:	601a      	str	r2, [r3, #0]
  404c32:	e7d8      	b.n	404be6 <drv_gpio_config+0x9e>
  404c34:	0040561d 	.word	0x0040561d
  404c38:	004052e9 	.word	0x004052e9
  404c3c:	28000001 	.word	0x28000001
  404c40:	0040542d 	.word	0x0040542d
  404c44:	00405445 	.word	0x00405445
  404c48:	004070bc 	.word	0x004070bc
  404c4c:	0040543d 	.word	0x0040543d
  404c50:	004054c9 	.word	0x004054c9
  404c54:	00405279 	.word	0x00405279
  404c58:	400e0e00 	.word	0x400e0e00
  404c5c:	400e1000 	.word	0x400e1000
  404c60:	00405175 	.word	0x00405175
  404c64:	e000e100 	.word	0xe000e100

00404c68 <drv_gpio_initializeAll>:
 * @brief initialize all GPIO
 * @param 
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/	
status_t drv_gpio_initializeAll(void)
{
  404c68:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	status_t status = STATUS_PASS; 
	int numGpio = sizeof(gpioConfig)/sizeof(drv_gpio_config_t); 
	int i = 0; 
	//Change the PB10 and PB11 to be configured as GPIO and not USB DDM and DDP 
	MATRIX->CCFG_SYSIO |= CCFG_SYSIO_SYSIO10 | CCFG_SYSIO_SYSIO11;	
  404c6a:	4b0b      	ldr	r3, [pc, #44]	; (404c98 <drv_gpio_initializeAll+0x30>)
  404c6c:	4c0b      	ldr	r4, [pc, #44]	; (404c9c <drv_gpio_initializeAll+0x34>)
  404c6e:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
  404c72:	4f0b      	ldr	r7, [pc, #44]	; (404ca0 <drv_gpio_initializeAll+0x38>)
  404c74:	f442 6240 	orr.w	r2, r2, #3072	; 0xc00
  404c78:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
  404c7c:	f504 7698 	add.w	r6, r4, #304	; 0x130
 * @param 
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/	
status_t drv_gpio_initializeAll(void)
{
	status_t status = STATUS_PASS; 
  404c80:	2500      	movs	r5, #0
	int i = 0; 
	//Change the PB10 and PB11 to be configured as GPIO and not USB DDM and DDP 
	MATRIX->CCFG_SYSIO |= CCFG_SYSIO_SYSIO10 | CCFG_SYSIO_SYSIO11;	
	for(i = 0; i < numGpio ; i++)
	{
		if(drv_gpio_config(&gpioConfig[i]) != STATUS_PASS)
  404c82:	4620      	mov	r0, r4
  404c84:	47b8      	blx	r7
  404c86:	3410      	adds	r4, #16
		{
			//printf("failed to initialize GPIO at index %d", i);
			status |= STATUS_FAIL;
  404c88:	2800      	cmp	r0, #0
  404c8a:	bf18      	it	ne
  404c8c:	2501      	movne	r5, #1
	status_t status = STATUS_PASS; 
	int numGpio = sizeof(gpioConfig)/sizeof(drv_gpio_config_t); 
	int i = 0; 
	//Change the PB10 and PB11 to be configured as GPIO and not USB DDM and DDP 
	MATRIX->CCFG_SYSIO |= CCFG_SYSIO_SYSIO10 | CCFG_SYSIO_SYSIO11;	
	for(i = 0; i < numGpio ; i++)
  404c8e:	42b4      	cmp	r4, r6
  404c90:	d1f7      	bne.n	404c82 <drv_gpio_initializeAll+0x1a>
	//drv_gpio_config(&gpioConfig[DRV_GPIO_PIN_BLE_RST2]);
	//drv_gpio_config(&gpioConfig[DRV_GPIO_PIN_BLE_RST3]);
	
	
	return status; 
}
  404c92:	4628      	mov	r0, r5
  404c94:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  404c96:	bf00      	nop
  404c98:	400e0200 	.word	0x400e0200
  404c9c:	20000178 	.word	0x20000178
  404ca0:	00404b49 	.word	0x00404b49

00404ca4 <drv_gpio_setPinState>:
 * @brief Set a GPIO to HIGH or LOW
 * @param drv_gpio_pins_t pin, drv_gpio_pin_state_t state
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t drv_gpio_setPinState(drv_gpio_pins_t pin, drv_gpio_pin_state_t state)
{
  404ca4:	b538      	push	{r3, r4, r5, lr}
	status_t status = STATUS_PASS;
	uint32_t pinFlag = 0x00; 
	if(gpioConfig[pin].pinMode != DRV_GPIO_PIN_MODE_OUTPUT)
  404ca6:	4c18      	ldr	r4, [pc, #96]	; (404d08 <drv_gpio_setPinState+0x64>)
  404ca8:	0105      	lsls	r5, r0, #4
  404caa:	1963      	adds	r3, r4, r5
  404cac:	791a      	ldrb	r2, [r3, #4]
  404cae:	b972      	cbnz	r2, 404cce <drv_gpio_setPinState+0x2a>
	{
		return STATUS_FAIL;
	}
	if(gpioConfig[pin].currentPinState == DRV_GPIO_PIN_STATE_PULLED_HIGH || gpioConfig[pin].currentPinState == DRV_GPIO_PIN_STATE_PULLED_LOW)
  404cb0:	7bdb      	ldrb	r3, [r3, #15]
  404cb2:	3b02      	subs	r3, #2
  404cb4:	2b01      	cmp	r3, #1
  404cb6:	d90c      	bls.n	404cd2 <drv_gpio_setPinState+0x2e>
			pio_configure_pin(gpioConfig->pinId, pinFlag);			
		}
	}
	//the output should be in the right state. 
	
	switch(state)
  404cb8:	2901      	cmp	r1, #1
  404cba:	d01f      	beq.n	404cfc <drv_gpio_setPinState+0x58>
  404cbc:	d312      	bcc.n	404ce4 <drv_gpio_setPinState+0x40>
  404cbe:	2902      	cmp	r1, #2
  404cc0:	d115      	bne.n	404cee <drv_gpio_setPinState+0x4a>
		case DRV_GPIO_PIN_STATE_LOW:
			pio_set_pin_low(gpioConfig[pin].pinId);
		break;
		case DRV_GPIO_PIN_STATE_PULLED_HIGH:
			pinFlag |= PIO_TYPE_PIO_INPUT | PIO_PULLUP;	//Set as input with pull up. 
			pio_configure_pin(gpioConfig->pinId, pinFlag);
  404cc2:	6820      	ldr	r0, [r4, #0]
  404cc4:	4911      	ldr	r1, [pc, #68]	; (404d0c <drv_gpio_setPinState+0x68>)
  404cc6:	4b12      	ldr	r3, [pc, #72]	; (404d10 <drv_gpio_setPinState+0x6c>)
  404cc8:	4798      	blx	r3
	}
	
	


	return status;
  404cca:	2000      	movs	r0, #0
			pio_set_pin_low(gpioConfig[pin].pinId);
		break;
		case DRV_GPIO_PIN_STATE_PULLED_HIGH:
			pinFlag |= PIO_TYPE_PIO_INPUT | PIO_PULLUP;	//Set as input with pull up. 
			pio_configure_pin(gpioConfig->pinId, pinFlag);
		break;
  404ccc:	bd38      	pop	{r3, r4, r5, pc}
{
	status_t status = STATUS_PASS;
	uint32_t pinFlag = 0x00; 
	if(gpioConfig[pin].pinMode != DRV_GPIO_PIN_MODE_OUTPUT)
	{
		return STATUS_FAIL;
  404cce:	2001      	movs	r0, #1
  404cd0:	bd38      	pop	{r3, r4, r5, pc}
	}
	if(gpioConfig[pin].currentPinState == DRV_GPIO_PIN_STATE_PULLED_HIGH || gpioConfig[pin].currentPinState == DRV_GPIO_PIN_STATE_PULLED_LOW)
	{
		if(state == DRV_GPIO_PIN_STATE_HIGH )
  404cd2:	2901      	cmp	r1, #1
  404cd4:	d00d      	beq.n	404cf2 <drv_gpio_setPinState+0x4e>
		{
			//we have to set the pin back to an output
			pinFlag |= PIO_TYPE_PIO_OUTPUT_1;
			pio_configure_pin(gpioConfig->pinId, pinFlag);
		}
		else if(state == DRV_GPIO_PIN_STATE_LOW)
  404cd6:	2900      	cmp	r1, #0
  404cd8:	d1ee      	bne.n	404cb8 <drv_gpio_setPinState+0x14>
		{
			pinFlag |= PIO_TYPE_PIO_OUTPUT_0;
			pio_configure_pin(gpioConfig->pinId, pinFlag);			
  404cda:	6820      	ldr	r0, [r4, #0]
  404cdc:	4b0c      	ldr	r3, [pc, #48]	; (404d10 <drv_gpio_setPinState+0x6c>)
  404cde:	f04f 5140 	mov.w	r1, #805306368	; 0x30000000
  404ce2:	4798      	blx	r3
	{
		case DRV_GPIO_PIN_STATE_HIGH:
			pio_set_pin_high(gpioConfig[pin].pinId);
		break;
		case DRV_GPIO_PIN_STATE_LOW:
			pio_set_pin_low(gpioConfig[pin].pinId);
  404ce4:	5960      	ldr	r0, [r4, r5]
  404ce6:	4b0b      	ldr	r3, [pc, #44]	; (404d14 <drv_gpio_setPinState+0x70>)
  404ce8:	4798      	blx	r3
	}
	
	


	return status;
  404cea:	2000      	movs	r0, #0
		case DRV_GPIO_PIN_STATE_HIGH:
			pio_set_pin_high(gpioConfig[pin].pinId);
		break;
		case DRV_GPIO_PIN_STATE_LOW:
			pio_set_pin_low(gpioConfig[pin].pinId);
		break;
  404cec:	bd38      	pop	{r3, r4, r5, pc}
	}
	
	


	return status;
  404cee:	2000      	movs	r0, #0
}
  404cf0:	bd38      	pop	{r3, r4, r5, pc}
	{
		if(state == DRV_GPIO_PIN_STATE_HIGH )
		{
			//we have to set the pin back to an output
			pinFlag |= PIO_TYPE_PIO_OUTPUT_1;
			pio_configure_pin(gpioConfig->pinId, pinFlag);
  404cf2:	6820      	ldr	r0, [r4, #0]
  404cf4:	4b06      	ldr	r3, [pc, #24]	; (404d10 <drv_gpio_setPinState+0x6c>)
  404cf6:	f04f 5160 	mov.w	r1, #939524096	; 0x38000000
  404cfa:	4798      	blx	r3
	//the output should be in the right state. 
	
	switch(state)
	{
		case DRV_GPIO_PIN_STATE_HIGH:
			pio_set_pin_high(gpioConfig[pin].pinId);
  404cfc:	5960      	ldr	r0, [r4, r5]
  404cfe:	4b06      	ldr	r3, [pc, #24]	; (404d18 <drv_gpio_setPinState+0x74>)
  404d00:	4798      	blx	r3
	}
	
	


	return status;
  404d02:	2000      	movs	r0, #0
	
	switch(state)
	{
		case DRV_GPIO_PIN_STATE_HIGH:
			pio_set_pin_high(gpioConfig[pin].pinId);
		break;
  404d04:	bd38      	pop	{r3, r4, r5, pc}
  404d06:	bf00      	nop
  404d08:	20000178 	.word	0x20000178
  404d0c:	28000001 	.word	0x28000001
  404d10:	004052e9 	.word	0x004052e9
  404d14:	004052a9 	.word	0x004052a9
  404d18:	0040528d 	.word	0x0040528d

00404d1c <drv_gpio_getPinState>:
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t drv_gpio_getPinState(drv_gpio_pins_t pin, drv_gpio_pin_state_t* state)
{
	status_t status = STATUS_PASS;
	bool value = ioport_get_pin_level(gpioConfig[pin].pinId);
  404d1c:	4b0a      	ldr	r3, [pc, #40]	; (404d48 <drv_gpio_getPinState+0x2c>)
  404d1e:	0100      	lsls	r0, r0, #4
  404d20:	5818      	ldr	r0, [r3, r0]
typedef uint32_t ioport_port_t;
typedef uint32_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 5;
  404d22:	0943      	lsrs	r3, r0, #5
	} else {
		return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
		       (IOPORT_PIO_OFFSET * port));
	}
#else
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  404d24:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  404d28:	f203 7307 	addw	r3, r3, #1799	; 0x707
  404d2c:	025b      	lsls	r3, r3, #9
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
  404d2e:	f000 001f 	and.w	r0, r0, #31
	base->PIO_CODR = mask & ~level;
}

__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	return arch_ioport_pin_to_base(pin)->PIO_PDSR & arch_ioport_pin_to_mask(pin);
  404d32:	6bda      	ldr	r2, [r3, #60]	; 0x3c
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
  404d34:	2301      	movs	r3, #1
  404d36:	fa03 f000 	lsl.w	r0, r3, r0
	if (value == false)
  404d3a:	4002      	ands	r2, r0
	{
		*state = DRV_GPIO_PIN_STATE_LOW;
  404d3c:	bf08      	it	eq
  404d3e:	4613      	moveq	r3, r2
  404d40:	700b      	strb	r3, [r1, #0]
	else
	{
		*state = DRV_GPIO_PIN_STATE_HIGH;
	}
	return status;
}
  404d42:	2000      	movs	r0, #0
  404d44:	4770      	bx	lr
  404d46:	bf00      	nop
  404d48:	20000178 	.word	0x20000178

00404d4c <drv_gpio_togglePin>:
 * @brief Toggle a GPIO level
 * @param drv_gpio_pins_t pin
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t drv_gpio_togglePin(drv_gpio_pins_t pin)
{
  404d4c:	b508      	push	{r3, lr}
	status_t status = STATUS_PASS;
	pio_toggle_pin(gpioConfig[pin].pinId);
  404d4e:	4a03      	ldr	r2, [pc, #12]	; (404d5c <drv_gpio_togglePin+0x10>)
  404d50:	4b03      	ldr	r3, [pc, #12]	; (404d60 <drv_gpio_togglePin+0x14>)
  404d52:	0100      	lsls	r0, r0, #4
  404d54:	5810      	ldr	r0, [r2, r0]
  404d56:	4798      	blx	r3
	return status;
}
  404d58:	2000      	movs	r0, #0
  404d5a:	bd08      	pop	{r3, pc}
  404d5c:	20000178 	.word	0x20000178
  404d60:	004052c5 	.word	0x004052c5

00404d64 <uart_process_byte>:
	}		
	return status;
}

static void uart_process_byte(Usart *p_usart, drv_uart_memory_buf_t* memBuf)
{
  404d64:	b510      	push	{r4, lr}
	uint32_t val = 0;
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
  404d66:	f8b1 3204 	ldrh.w	r3, [r1, #516]	; 0x204
	}		
	return status;
}

static void uart_process_byte(Usart *p_usart, drv_uart_memory_buf_t* memBuf)
{
  404d6a:	b082      	sub	sp, #8
	uint32_t val = 0;
  404d6c:	2200      	movs	r2, #0
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
  404d6e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
	}		
	return status;
}

static void uart_process_byte(Usart *p_usart, drv_uart_memory_buf_t* memBuf)
{
  404d72:	460c      	mov	r4, r1
	uint32_t val = 0;
  404d74:	9201      	str	r2, [sp, #4]
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
  404d76:	d028      	beq.n	404dca <uart_process_byte+0x66>
		memBuf->uart_rx_fifo_ovf_flag = 1;                     // set the overflow flag
		//the buffer is full, but we have to clear the interrupt
		memBuf->uart_rx_fifo_dropped_bytes++; //our data stream will be out of sync now...
		usart_getchar(p_usart,&val);		
	}
	else if(memBuf->rx_fifo.num_bytes < FIFO_BUFFER_SIZE)  // if there's room in the sw buffer
  404d78:	d30c      	bcc.n	404d94 <uart_process_byte+0x30>
	}
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE)
	{      // if sw buffer just filled up
		memBuf->uart_rx_fifo_full_flag = 1;                    // set the RX FIFO full flag
	}
	if(memBuf->rx_fifo.i_last == FIFO_BUFFER_SIZE)
  404d7a:	f8b4 3202 	ldrh.w	r3, [r4, #514]	; 0x202
  404d7e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
	{         // if the index has reached the end of the buffer,
		memBuf->rx_fifo.i_last = 0;                            // roll over the index counter
  404d82:	bf04      	itt	eq
  404d84:	2300      	moveq	r3, #0
  404d86:	f8a4 3202 	strheq.w	r3, [r4, #514]	; 0x202
	}
	memBuf->uart_rx_fifo_not_empty_flag = 1;                 // set received-data flag	
  404d8a:	2301      	movs	r3, #1
  404d8c:	f884 3207 	strb.w	r3, [r4, #519]	; 0x207
}
  404d90:	b002      	add	sp, #8
  404d92:	bd10      	pop	{r4, pc}
		usart_getchar(p_usart,&val);		
	}
	else if(memBuf->rx_fifo.num_bytes < FIFO_BUFFER_SIZE)  // if there's room in the sw buffer
	{		
		//while((UART0->UART_SR & UART_SR_RXRDY) == 0);
		if(usart_getchar(p_usart,&val) == STATUS_PASS)
  404d94:	a901      	add	r1, sp, #4
  404d96:	4b14      	ldr	r3, [pc, #80]	; (404de8 <uart_process_byte+0x84>)
  404d98:	4798      	blx	r3
  404d9a:	b140      	cbz	r0, 404dae <uart_process_byte+0x4a>
  404d9c:	f8b4 3204 	ldrh.w	r3, [r4, #516]	; 0x204
		//if(p_usart == UART1)
		//{
			//usart_putchar(UART0, val);
		//}
	}
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE)
  404da0:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
	{      // if sw buffer just filled up
		memBuf->uart_rx_fifo_full_flag = 1;                    // set the RX FIFO full flag
  404da4:	bf04      	itt	eq
  404da6:	2301      	moveq	r3, #1
  404da8:	f884 3208 	strbeq.w	r3, [r4, #520]	; 0x208
  404dac:	e7e5      	b.n	404d7a <uart_process_byte+0x16>
	else if(memBuf->rx_fifo.num_bytes < FIFO_BUFFER_SIZE)  // if there's room in the sw buffer
	{		
		//while((UART0->UART_SR & UART_SR_RXRDY) == 0);
		if(usart_getchar(p_usart,&val) == STATUS_PASS)
		{		
			memBuf->rx_fifo.data_buf[memBuf->rx_fifo.i_last] = (uint8_t)val;
  404dae:	f8b4 2202 	ldrh.w	r2, [r4, #514]	; 0x202
  404db2:	9b01      	ldr	r3, [sp, #4]
  404db4:	54a3      	strb	r3, [r4, r2]
			memBuf->rx_fifo.i_last++;                              // increment the index of the most recently added element
			memBuf->rx_fifo.num_bytes++;                           // increment the bytes counter
  404db6:	f8b4 3204 	ldrh.w	r3, [r4, #516]	; 0x204
  404dba:	3301      	adds	r3, #1
	{		
		//while((UART0->UART_SR & UART_SR_RXRDY) == 0);
		if(usart_getchar(p_usart,&val) == STATUS_PASS)
		{		
			memBuf->rx_fifo.data_buf[memBuf->rx_fifo.i_last] = (uint8_t)val;
			memBuf->rx_fifo.i_last++;                              // increment the index of the most recently added element
  404dbc:	3201      	adds	r2, #1
			memBuf->rx_fifo.num_bytes++;                           // increment the bytes counter
  404dbe:	b29b      	uxth	r3, r3
	{		
		//while((UART0->UART_SR & UART_SR_RXRDY) == 0);
		if(usart_getchar(p_usart,&val) == STATUS_PASS)
		{		
			memBuf->rx_fifo.data_buf[memBuf->rx_fifo.i_last] = (uint8_t)val;
			memBuf->rx_fifo.i_last++;                              // increment the index of the most recently added element
  404dc0:	f8a4 2202 	strh.w	r2, [r4, #514]	; 0x202
			memBuf->rx_fifo.num_bytes++;                           // increment the bytes counter
  404dc4:	f8a4 3204 	strh.w	r3, [r4, #516]	; 0x204
  404dc8:	e7ea      	b.n	404da0 <uart_process_byte+0x3c>
	uint32_t val = 0;
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
	{
		memBuf->uart_rx_fifo_ovf_flag = 1;                     // set the overflow flag
		//the buffer is full, but we have to clear the interrupt
		memBuf->uart_rx_fifo_dropped_bytes++; //our data stream will be out of sync now...
  404dca:	f8d1 320c 	ldr.w	r3, [r1, #524]	; 0x20c
		usart_getchar(p_usart,&val);		
  404dce:	4a06      	ldr	r2, [pc, #24]	; (404de8 <uart_process_byte+0x84>)
	uint32_t val = 0;
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
	{
		memBuf->uart_rx_fifo_ovf_flag = 1;                     // set the overflow flag
		//the buffer is full, but we have to clear the interrupt
		memBuf->uart_rx_fifo_dropped_bytes++; //our data stream will be out of sync now...
  404dd0:	3301      	adds	r3, #1
static void uart_process_byte(Usart *p_usart, drv_uart_memory_buf_t* memBuf)
{
	uint32_t val = 0;
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
	{
		memBuf->uart_rx_fifo_ovf_flag = 1;                     // set the overflow flag
  404dd2:	2101      	movs	r1, #1
		//the buffer is full, but we have to clear the interrupt
		memBuf->uart_rx_fifo_dropped_bytes++; //our data stream will be out of sync now...
  404dd4:	f8c4 320c 	str.w	r3, [r4, #524]	; 0x20c
static void uart_process_byte(Usart *p_usart, drv_uart_memory_buf_t* memBuf)
{
	uint32_t val = 0;
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
	{
		memBuf->uart_rx_fifo_ovf_flag = 1;                     // set the overflow flag
  404dd8:	f884 1209 	strb.w	r1, [r4, #521]	; 0x209
		//the buffer is full, but we have to clear the interrupt
		memBuf->uart_rx_fifo_dropped_bytes++; //our data stream will be out of sync now...
		usart_getchar(p_usart,&val);		
  404ddc:	a901      	add	r1, sp, #4
  404dde:	4790      	blx	r2
  404de0:	f8b4 3204 	ldrh.w	r3, [r4, #516]	; 0x204
  404de4:	e7dc      	b.n	404da0 <uart_process_byte+0x3c>
  404de6:	bf00      	nop
  404de8:	00402389 	.word	0x00402389

00404dec <uart_process_tx_byte>:
	}
	memBuf->uart_rx_fifo_not_empty_flag = 1;                 // set received-data flag	
}

static void uart_process_tx_byte(Usart *p_usart, drv_uart_memory_buf_t* memBuf)
{
  404dec:	b570      	push	{r4, r5, r6, lr}
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE)
  404dee:	f8b1 3414 	ldrh.w	r3, [r1, #1044]	; 0x414
  404df2:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
	}
	memBuf->uart_rx_fifo_not_empty_flag = 1;                 // set received-data flag	
}

static void uart_process_tx_byte(Usart *p_usart, drv_uart_memory_buf_t* memBuf)
{
  404df6:	460c      	mov	r4, r1
  404df8:	4602      	mov	r2, r0
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE)
  404dfa:	d00f      	beq.n	404e1c <uart_process_tx_byte+0x30>
	{ // if the sw buffer is full
		memBuf->uart_tx_fifo_full_flag = 0;               // clear the buffer full flag because we are about to make room
	}
	if(memBuf->tx_fifo.num_bytes > 0)
  404dfc:	b98b      	cbnz	r3, 404e22 <uart_process_tx_byte+0x36>
		memBuf->tx_fifo.i_first++;                        // increment the index of the oldest element
		memBuf->tx_fifo.num_bytes--;                      // decrement the bytes counter
	}
	else
	{   // tx sw buffer is empty
		memBuf->uart_tx_fifo_not_empty_flag = 0;          // clear the tx flag
  404dfe:	f881 3416 	strb.w	r3, [r1, #1046]	; 0x416
		uart_disable_interrupt(p_usart,UART_IER_TXEMPTY); //the buffer is empty, stop the interrupt. 
  404e02:	f44f 7100 	mov.w	r1, #512	; 0x200
  404e06:	4b23      	ldr	r3, [pc, #140]	; (404e94 <uart_process_tx_byte+0xa8>)
  404e08:	4798      	blx	r3
  404e0a:	f8b4 2410 	ldrh.w	r2, [r4, #1040]	; 0x410
	}
	if(memBuf->tx_fifo.i_first == FIFO_BUFFER_SIZE)
  404e0e:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
	{   // if the index has reached the end of the buffer,
		memBuf->tx_fifo.i_first = 0;                      // roll over the index counter
  404e12:	bf04      	itt	eq
  404e14:	2300      	moveq	r3, #0
  404e16:	f8a4 3410 	strheq.w	r3, [r4, #1040]	; 0x410
  404e1a:	bd70      	pop	{r4, r5, r6, pc}

static void uart_process_tx_byte(Usart *p_usart, drv_uart_memory_buf_t* memBuf)
{
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE)
	{ // if the sw buffer is full
		memBuf->uart_tx_fifo_full_flag = 0;               // clear the buffer full flag because we are about to make room
  404e1c:	2100      	movs	r1, #0
  404e1e:	f884 1417 	strb.w	r1, [r4, #1047]	; 0x417
	}
	if(memBuf->tx_fifo.num_bytes > 0)
	{
		// if data exists in the sw buffer
		usart_serial_putchar(p_usart,memBuf->tx_fifo.data_buf[memBuf->tx_fifo.i_first]); // send the next value from buffer
  404e22:	f8b4 1410 	ldrh.w	r1, [r4, #1040]	; 0x410
		while (uart_write((Uart*)p_usart, c)!=0);
		return 1;
	}
#else
# ifdef UART0
	if (UART0 == (Uart*)p_usart) {
  404e26:	481c      	ldr	r0, [pc, #112]	; (404e98 <uart_process_tx_byte+0xac>)
  404e28:	1865      	adds	r5, r4, r1
  404e2a:	4282      	cmp	r2, r0
  404e2c:	f895 5210 	ldrb.w	r5, [r5, #528]	; 0x210
  404e30:	d010      	beq.n	404e54 <uart_process_tx_byte+0x68>
		while (uart_write((Uart*)p_usart, c)!=0);
		return 1;
	}
# endif
# ifdef UART1
	if (UART1 == (Uart*)p_usart) {
  404e32:	481a      	ldr	r0, [pc, #104]	; (404e9c <uart_process_tx_byte+0xb0>)
  404e34:	4282      	cmp	r2, r0
  404e36:	d01f      	beq.n	404e78 <uart_process_tx_byte+0x8c>
		while (usart_write(p_usart, c)!=0);
		return 1;
	}
#else
# ifdef USART0
	if (USART0 == p_usart) {
  404e38:	4819      	ldr	r0, [pc, #100]	; (404ea0 <uart_process_tx_byte+0xb4>)
  404e3a:	4282      	cmp	r2, r0
  404e3c:	d023      	beq.n	404e86 <uart_process_tx_byte+0x9a>
		while (usart_write(p_usart, c)!=0);
		return 1;
	}
# endif
# ifdef USART1
	if (USART1 == p_usart) {
  404e3e:	4819      	ldr	r0, [pc, #100]	; (404ea4 <uart_process_tx_byte+0xb8>)
  404e40:	4282      	cmp	r2, r0
  404e42:	d012      	beq.n	404e6a <uart_process_tx_byte+0x7e>
		memBuf->tx_fifo.i_first++;                        // increment the index of the oldest element
  404e44:	1c4a      	adds	r2, r1, #1
  404e46:	b292      	uxth	r2, r2
		memBuf->tx_fifo.num_bytes--;                      // decrement the bytes counter
  404e48:	3b01      	subs	r3, #1
	}
	if(memBuf->tx_fifo.num_bytes > 0)
	{
		// if data exists in the sw buffer
		usart_serial_putchar(p_usart,memBuf->tx_fifo.data_buf[memBuf->tx_fifo.i_first]); // send the next value from buffer
		memBuf->tx_fifo.i_first++;                        // increment the index of the oldest element
  404e4a:	f8a4 2410 	strh.w	r2, [r4, #1040]	; 0x410
		memBuf->tx_fifo.num_bytes--;                      // decrement the bytes counter
  404e4e:	f8a4 3414 	strh.w	r3, [r4, #1044]	; 0x414
  404e52:	e7dc      	b.n	404e0e <uart_process_tx_byte+0x22>
  404e54:	4e14      	ldr	r6, [pc, #80]	; (404ea8 <uart_process_tx_byte+0xbc>)
		return 1;
	}
#else
# ifdef UART0
	if (UART0 == (Uart*)p_usart) {
		while (uart_write((Uart*)p_usart, c)!=0);
  404e56:	4810      	ldr	r0, [pc, #64]	; (404e98 <uart_process_tx_byte+0xac>)
  404e58:	4629      	mov	r1, r5
  404e5a:	47b0      	blx	r6
  404e5c:	2800      	cmp	r0, #0
  404e5e:	d1fa      	bne.n	404e56 <uart_process_tx_byte+0x6a>
  404e60:	f8b4 1410 	ldrh.w	r1, [r4, #1040]	; 0x410
  404e64:	f8b4 3414 	ldrh.w	r3, [r4, #1044]	; 0x414
  404e68:	e7ec      	b.n	404e44 <uart_process_tx_byte+0x58>
  404e6a:	4e10      	ldr	r6, [pc, #64]	; (404eac <uart_process_tx_byte+0xc0>)
		return 1;
	}
# endif
# ifdef USART1
	if (USART1 == p_usart) {
		while (usart_write(p_usart, c)!=0);
  404e6c:	480d      	ldr	r0, [pc, #52]	; (404ea4 <uart_process_tx_byte+0xb8>)
  404e6e:	4629      	mov	r1, r5
  404e70:	47b0      	blx	r6
  404e72:	2800      	cmp	r0, #0
  404e74:	d1fa      	bne.n	404e6c <uart_process_tx_byte+0x80>
  404e76:	e7f3      	b.n	404e60 <uart_process_tx_byte+0x74>
  404e78:	4e0b      	ldr	r6, [pc, #44]	; (404ea8 <uart_process_tx_byte+0xbc>)
		return 1;
	}
# endif
# ifdef UART1
	if (UART1 == (Uart*)p_usart) {
		while (uart_write((Uart*)p_usart, c)!=0);
  404e7a:	4808      	ldr	r0, [pc, #32]	; (404e9c <uart_process_tx_byte+0xb0>)
  404e7c:	4629      	mov	r1, r5
  404e7e:	47b0      	blx	r6
  404e80:	2800      	cmp	r0, #0
  404e82:	d1fa      	bne.n	404e7a <uart_process_tx_byte+0x8e>
  404e84:	e7ec      	b.n	404e60 <uart_process_tx_byte+0x74>
  404e86:	4e09      	ldr	r6, [pc, #36]	; (404eac <uart_process_tx_byte+0xc0>)
		return 1;
	}
#else
# ifdef USART0
	if (USART0 == p_usart) {
		while (usart_write(p_usart, c)!=0);
  404e88:	4805      	ldr	r0, [pc, #20]	; (404ea0 <uart_process_tx_byte+0xb4>)
  404e8a:	4629      	mov	r1, r5
  404e8c:	47b0      	blx	r6
  404e8e:	2800      	cmp	r0, #0
  404e90:	d1fa      	bne.n	404e88 <uart_process_tx_byte+0x9c>
  404e92:	e7e5      	b.n	404e60 <uart_process_tx_byte+0x74>
  404e94:	00402355 	.word	0x00402355
  404e98:	400e0600 	.word	0x400e0600
  404e9c:	400e0800 	.word	0x400e0800
  404ea0:	40024000 	.word	0x40024000
  404ea4:	40028000 	.word	0x40028000
  404ea8:	0040235d 	.word	0x0040235d
  404eac:	00402375 	.word	0x00402375

00404eb0 <drv_uart_putChar>:
 * the character
 * @param c, the character that will be sent through the uart. 
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/	
status_t drv_uart_putChar(drv_uart_config_t* uartConfig, char c)
{
  404eb0:	b538      	push	{r3, r4, r5, lr}
  404eb2:	4604      	mov	r4, r0
	status_t status = STATUS_PASS;
	//disable the interrupts so we don't fuck up the pointers	
	usart_disable_interrupt(uartConfig->p_usart, UART_IER_TXEMPTY);	
  404eb4:	4b1f      	ldr	r3, [pc, #124]	; (404f34 <drv_uart_putChar+0x84>)
  404eb6:	6800      	ldr	r0, [r0, #0]
 * the character
 * @param c, the character that will be sent through the uart. 
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/	
status_t drv_uart_putChar(drv_uart_config_t* uartConfig, char c)
{
  404eb8:	460d      	mov	r5, r1
	status_t status = STATUS_PASS;
	//disable the interrupts so we don't fuck up the pointers	
	usart_disable_interrupt(uartConfig->p_usart, UART_IER_TXEMPTY);	
  404eba:	f44f 7100 	mov.w	r1, #512	; 0x200
  404ebe:	4798      	blx	r3
	uint32_t val = 0;
	drv_uart_memory_buf_t* memBuf = &uartMemBuf[uartConfig->mem_index]; 
  404ec0:	6962      	ldr	r2, [r4, #20]
  404ec2:	481d      	ldr	r0, [pc, #116]	; (404f38 <drv_uart_putChar+0x88>)
  404ec4:	eb02 1242 	add.w	r2, r2, r2, lsl #5
  404ec8:	eb00 1342 	add.w	r3, r0, r2, lsl #5
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
  404ecc:	f8b3 2414 	ldrh.w	r2, [r3, #1044]	; 0x414
  404ed0:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
  404ed4:	d021      	beq.n	404f1a <drv_uart_putChar+0x6a>
	{
		memBuf->uart_tx_fifo_ovf_flag = 1;                     // set the overflow flag
		memBuf->uart_tx_fifo_dropped_bytes++; //our data stream will be out of sync now...	
	}
	else if(memBuf->tx_fifo.num_bytes < FIFO_BUFFER_SIZE)  // if there's room in the sw buffer
  404ed6:	d20e      	bcs.n	404ef6 <drv_uart_putChar+0x46>
	{
		memBuf->tx_fifo.data_buf[memBuf->tx_fifo.i_last] = c;
  404ed8:	f8b3 1412 	ldrh.w	r1, [r3, #1042]	; 0x412
		memBuf->tx_fifo.i_last++;                              // increment the index of the most recently added element
		memBuf->tx_fifo.num_bytes++;                           // increment the bytes counter
  404edc:	3201      	adds	r2, #1
		memBuf->uart_tx_fifo_ovf_flag = 1;                     // set the overflow flag
		memBuf->uart_tx_fifo_dropped_bytes++; //our data stream will be out of sync now...	
	}
	else if(memBuf->tx_fifo.num_bytes < FIFO_BUFFER_SIZE)  // if there's room in the sw buffer
	{
		memBuf->tx_fifo.data_buf[memBuf->tx_fifo.i_last] = c;
  404ede:	1858      	adds	r0, r3, r1
		memBuf->tx_fifo.i_last++;                              // increment the index of the most recently added element
		memBuf->tx_fifo.num_bytes++;                           // increment the bytes counter
  404ee0:	b292      	uxth	r2, r2
		memBuf->uart_tx_fifo_dropped_bytes++; //our data stream will be out of sync now...	
	}
	else if(memBuf->tx_fifo.num_bytes < FIFO_BUFFER_SIZE)  // if there's room in the sw buffer
	{
		memBuf->tx_fifo.data_buf[memBuf->tx_fifo.i_last] = c;
		memBuf->tx_fifo.i_last++;                              // increment the index of the most recently added element
  404ee2:	3101      	adds	r1, #1
		//if(uartConfig->p_usart == UART1)
		//{
			//usart_putchar(UART0, c);
		//}
	}
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE)
  404ee4:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
		memBuf->uart_tx_fifo_ovf_flag = 1;                     // set the overflow flag
		memBuf->uart_tx_fifo_dropped_bytes++; //our data stream will be out of sync now...	
	}
	else if(memBuf->tx_fifo.num_bytes < FIFO_BUFFER_SIZE)  // if there's room in the sw buffer
	{
		memBuf->tx_fifo.data_buf[memBuf->tx_fifo.i_last] = c;
  404ee8:	f880 5210 	strb.w	r5, [r0, #528]	; 0x210
		memBuf->tx_fifo.i_last++;                              // increment the index of the most recently added element
		memBuf->tx_fifo.num_bytes++;                           // increment the bytes counter
  404eec:	f8a3 2414 	strh.w	r2, [r3, #1044]	; 0x414
		memBuf->uart_tx_fifo_dropped_bytes++; //our data stream will be out of sync now...	
	}
	else if(memBuf->tx_fifo.num_bytes < FIFO_BUFFER_SIZE)  // if there's room in the sw buffer
	{
		memBuf->tx_fifo.data_buf[memBuf->tx_fifo.i_last] = c;
		memBuf->tx_fifo.i_last++;                              // increment the index of the most recently added element
  404ef0:	f8a3 1412 	strh.w	r1, [r3, #1042]	; 0x412
		//if(uartConfig->p_usart == UART1)
		//{
			//usart_putchar(UART0, c);
		//}
	}
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE)
  404ef4:	d019      	beq.n	404f2a <drv_uart_putChar+0x7a>
	{      // if sw buffer just filled up
		memBuf->uart_tx_fifo_full_flag = 1;                    // set the tx FIFO full flag
	}
	if(memBuf->tx_fifo.i_last == FIFO_BUFFER_SIZE)
  404ef6:	f8b3 2412 	ldrh.w	r2, [r3, #1042]	; 0x412
  404efa:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
	{         // if the index has reached the end of the buffer,
		memBuf->tx_fifo.i_last = 0;                            // roll over the index counter
  404efe:	bf04      	itt	eq
  404f00:	2200      	moveq	r2, #0
  404f02:	f8a3 2412 	strheq.w	r2, [r3, #1042]	; 0x412
	}
	memBuf->uart_tx_fifo_not_empty_flag = 1;                 // set tx-data ready flag	
  404f06:	2201      	movs	r2, #1
  404f08:	f883 2416 	strb.w	r2, [r3, #1046]	; 0x416
	//re-enable the interrupts
	usart_enable_interrupt(uartConfig->p_usart, UART_IER_TXEMPTY);		
  404f0c:	6820      	ldr	r0, [r4, #0]
  404f0e:	4b0b      	ldr	r3, [pc, #44]	; (404f3c <drv_uart_putChar+0x8c>)
  404f10:	f44f 7100 	mov.w	r1, #512	; 0x200
  404f14:	4798      	blx	r3
	return status;	
}
  404f16:	2000      	movs	r0, #0
  404f18:	bd38      	pop	{r3, r4, r5, pc}
	uint32_t val = 0;
	drv_uart_memory_buf_t* memBuf = &uartMemBuf[uartConfig->mem_index]; 
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
	{
		memBuf->uart_tx_fifo_ovf_flag = 1;                     // set the overflow flag
		memBuf->uart_tx_fifo_dropped_bytes++; //our data stream will be out of sync now...	
  404f1a:	f8d3 241c 	ldr.w	r2, [r3, #1052]	; 0x41c
	usart_disable_interrupt(uartConfig->p_usart, UART_IER_TXEMPTY);	
	uint32_t val = 0;
	drv_uart_memory_buf_t* memBuf = &uartMemBuf[uartConfig->mem_index]; 
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
	{
		memBuf->uart_tx_fifo_ovf_flag = 1;                     // set the overflow flag
  404f1e:	2101      	movs	r1, #1
		memBuf->uart_tx_fifo_dropped_bytes++; //our data stream will be out of sync now...	
  404f20:	440a      	add	r2, r1
  404f22:	f8c3 241c 	str.w	r2, [r3, #1052]	; 0x41c
	usart_disable_interrupt(uartConfig->p_usart, UART_IER_TXEMPTY);	
	uint32_t val = 0;
	drv_uart_memory_buf_t* memBuf = &uartMemBuf[uartConfig->mem_index]; 
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
	{
		memBuf->uart_tx_fifo_ovf_flag = 1;                     // set the overflow flag
  404f26:	f883 1418 	strb.w	r1, [r3, #1048]	; 0x418
			//usart_putchar(UART0, c);
		//}
	}
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE)
	{      // if sw buffer just filled up
		memBuf->uart_tx_fifo_full_flag = 1;                    // set the tx FIFO full flag
  404f2a:	2201      	movs	r2, #1
  404f2c:	f883 2417 	strb.w	r2, [r3, #1047]	; 0x417
  404f30:	e7e1      	b.n	404ef6 <drv_uart_putChar+0x46>
  404f32:	bf00      	nop
  404f34:	00402371 	.word	0x00402371
  404f38:	200013c0 	.word	0x200013c0
  404f3c:	0040236d 	.word	0x0040236d

00404f40 <drv_uart_putData>:
		}		
	}
}

void drv_uart_putData(drv_uart_config_t* uartConfig, char* str, size_t length)
{
  404f40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	int i=0;
	for (i=0;i<length;)
	{
		if(drv_uart_putChar(uartConfig, str[i]) == STATUS_PASS)
  404f44:	4f09      	ldr	r7, [pc, #36]	; (404f6c <drv_uart_putData+0x2c>)
		}		
	}
}

void drv_uart_putData(drv_uart_config_t* uartConfig, char* str, size_t length)
{
  404f46:	4606      	mov	r6, r0
  404f48:	4688      	mov	r8, r1
  404f4a:	4615      	mov	r5, r2
	int i=0;
	for (i=0;i<length;)
  404f4c:	2400      	movs	r4, #0
  404f4e:	42ac      	cmp	r4, r5
	{
		if(drv_uart_putChar(uartConfig, str[i]) == STATUS_PASS)
  404f50:	4630      	mov	r0, r6
}

void drv_uart_putData(drv_uart_config_t* uartConfig, char* str, size_t length)
{
	int i=0;
	for (i=0;i<length;)
  404f52:	d208      	bcs.n	404f66 <drv_uart_putData+0x26>
	{
		if(drv_uart_putChar(uartConfig, str[i]) == STATUS_PASS)
  404f54:	f818 1004 	ldrb.w	r1, [r8, r4]
  404f58:	47b8      	blx	r7
  404f5a:	2800      	cmp	r0, #0
  404f5c:	d1f7      	bne.n	404f4e <drv_uart_putData+0xe>
		{
			i++; //increment only if PASS is returned (it means the data has been sent)
  404f5e:	3401      	adds	r4, #1
}

void drv_uart_putData(drv_uart_config_t* uartConfig, char* str, size_t length)
{
	int i=0;
	for (i=0;i<length;)
  404f60:	42ac      	cmp	r4, r5
	{
		if(drv_uart_putChar(uartConfig, str[i]) == STATUS_PASS)
  404f62:	4630      	mov	r0, r6
}

void drv_uart_putData(drv_uart_config_t* uartConfig, char* str, size_t length)
{
	int i=0;
	for (i=0;i<length;)
  404f64:	d3f6      	bcc.n	404f54 <drv_uart_putData+0x14>
		if(drv_uart_putChar(uartConfig, str[i]) == STATUS_PASS)
		{
			i++; //increment only if PASS is returned (it means the data has been sent)
		}
	}
}
  404f66:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  404f6a:	bf00      	nop
  404f6c:	00404eb1 	.word	0x00404eb1

00404f70 <UART0_Handler>:
	}
}

// interrupt handlers
void UART0_Handler()
{	
  404f70:	b510      	push	{r4, lr}
	//if(uartMemBuf[0].isinit) //only handle the interrupt if the driver is initialized. 
	//{
		//uart_process_byte(UART0, &(uartMemBuf[0]));	
	//}
	uint32_t status = uart_get_status(UART0); 
  404f72:	480c      	ldr	r0, [pc, #48]	; (404fa4 <UART0_Handler+0x34>)
  404f74:	4b0c      	ldr	r3, [pc, #48]	; (404fa8 <UART0_Handler+0x38>)
  404f76:	4798      	blx	r3
	if(status & UART_SR_RXRDY > 0)
  404f78:	07c2      	lsls	r2, r0, #31
{	
	//if(uartMemBuf[0].isinit) //only handle the interrupt if the driver is initialized. 
	//{
		//uart_process_byte(UART0, &(uartMemBuf[0]));	
	//}
	uint32_t status = uart_get_status(UART0); 
  404f7a:	4604      	mov	r4, r0
	if(status & UART_SR_RXRDY > 0)
  404f7c:	d503      	bpl.n	404f86 <UART0_Handler+0x16>
	{	
		if(uartMemBuf[0].isinit) //only handle the interrupt if the driver is initialized.
  404f7e:	490b      	ldr	r1, [pc, #44]	; (404fac <UART0_Handler+0x3c>)
  404f80:	f891 3206 	ldrb.w	r3, [r1, #518]	; 0x206
  404f84:	b953      	cbnz	r3, 404f9c <UART0_Handler+0x2c>
		{
			uart_process_byte(UART0, &(uartMemBuf[0]));
		}
	}
	
	if(status & UART_SR_TXEMPTY)
  404f86:	05a3      	lsls	r3, r4, #22
  404f88:	d503      	bpl.n	404f92 <UART0_Handler+0x22>
	{
		if(uartMemBuf[0].isinit) //only handle the interrupt if the driver is initialized.
  404f8a:	4908      	ldr	r1, [pc, #32]	; (404fac <UART0_Handler+0x3c>)
  404f8c:	f891 3206 	ldrb.w	r3, [r1, #518]	; 0x206
  404f90:	b903      	cbnz	r3, 404f94 <UART0_Handler+0x24>
  404f92:	bd10      	pop	{r4, pc}
		{
			uart_process_tx_byte(UART0, &(uartMemBuf[0])); 	
  404f94:	4803      	ldr	r0, [pc, #12]	; (404fa4 <UART0_Handler+0x34>)
  404f96:	4b06      	ldr	r3, [pc, #24]	; (404fb0 <UART0_Handler+0x40>)
  404f98:	4798      	blx	r3
  404f9a:	bd10      	pop	{r4, pc}
	uint32_t status = uart_get_status(UART0); 
	if(status & UART_SR_RXRDY > 0)
	{	
		if(uartMemBuf[0].isinit) //only handle the interrupt if the driver is initialized.
		{
			uart_process_byte(UART0, &(uartMemBuf[0]));
  404f9c:	4801      	ldr	r0, [pc, #4]	; (404fa4 <UART0_Handler+0x34>)
  404f9e:	4b05      	ldr	r3, [pc, #20]	; (404fb4 <UART0_Handler+0x44>)
  404fa0:	4798      	blx	r3
  404fa2:	e7f0      	b.n	404f86 <UART0_Handler+0x16>
  404fa4:	400e0600 	.word	0x400e0600
  404fa8:	00402359 	.word	0x00402359
  404fac:	200013c0 	.word	0x200013c0
  404fb0:	00404ded 	.word	0x00404ded
  404fb4:	00404d65 	.word	0x00404d65

00404fb8 <UART1_Handler>:
		}
	}	
}

void UART1_Handler()
{
  404fb8:	b510      	push	{r4, lr}
	uint32_t status = uart_get_status(UART1); 
  404fba:	480e      	ldr	r0, [pc, #56]	; (404ff4 <UART1_Handler+0x3c>)
  404fbc:	4b0e      	ldr	r3, [pc, #56]	; (404ff8 <UART1_Handler+0x40>)
  404fbe:	4798      	blx	r3
	if(status & UART_SR_RXRDY > 0)
  404fc0:	07c2      	lsls	r2, r0, #31
	}	
}

void UART1_Handler()
{
	uint32_t status = uart_get_status(UART1); 
  404fc2:	4604      	mov	r4, r0
	if(status & UART_SR_RXRDY > 0)
  404fc4:	d503      	bpl.n	404fce <UART1_Handler+0x16>
	{	
		if(uartMemBuf[1].isinit) //only handle the interrupt if the driver is initialized.
  404fc6:	490d      	ldr	r1, [pc, #52]	; (404ffc <UART1_Handler+0x44>)
  404fc8:	f891 3626 	ldrb.w	r3, [r1, #1574]	; 0x626
  404fcc:	b963      	cbnz	r3, 404fe8 <UART1_Handler+0x30>
		{
			uart_process_byte(UART1, &(uartMemBuf[1]));
		}
	}
	
	if(status & UART_SR_TXEMPTY)
  404fce:	05a3      	lsls	r3, r4, #22
  404fd0:	d503      	bpl.n	404fda <UART1_Handler+0x22>
	{
		if(uartMemBuf[1].isinit) //only handle the interrupt if the driver is initialized.
  404fd2:	490a      	ldr	r1, [pc, #40]	; (404ffc <UART1_Handler+0x44>)
  404fd4:	f891 3626 	ldrb.w	r3, [r1, #1574]	; 0x626
  404fd8:	b903      	cbnz	r3, 404fdc <UART1_Handler+0x24>
  404fda:	bd10      	pop	{r4, pc}
		{
			uart_process_tx_byte(UART1, &(uartMemBuf[1])); 	
  404fdc:	f501 6184 	add.w	r1, r1, #1056	; 0x420
  404fe0:	4804      	ldr	r0, [pc, #16]	; (404ff4 <UART1_Handler+0x3c>)
  404fe2:	4b07      	ldr	r3, [pc, #28]	; (405000 <UART1_Handler+0x48>)
  404fe4:	4798      	blx	r3
  404fe6:	bd10      	pop	{r4, pc}
	uint32_t status = uart_get_status(UART1); 
	if(status & UART_SR_RXRDY > 0)
	{	
		if(uartMemBuf[1].isinit) //only handle the interrupt if the driver is initialized.
		{
			uart_process_byte(UART1, &(uartMemBuf[1]));
  404fe8:	f501 6184 	add.w	r1, r1, #1056	; 0x420
  404fec:	4801      	ldr	r0, [pc, #4]	; (404ff4 <UART1_Handler+0x3c>)
  404fee:	4b05      	ldr	r3, [pc, #20]	; (405004 <UART1_Handler+0x4c>)
  404ff0:	4798      	blx	r3
  404ff2:	e7ec      	b.n	404fce <UART1_Handler+0x16>
  404ff4:	400e0800 	.word	0x400e0800
  404ff8:	00402359 	.word	0x00402359
  404ffc:	200013c0 	.word	0x200013c0
  405000:	00404ded 	.word	0x00404ded
  405004:	00404d65 	.word	0x00404d65

00405008 <USART0_Handler>:
		}
	}
}

void USART0_Handler()
{
  405008:	b510      	push	{r4, lr}
	//if(uartMemBuf[2].isinit) //only handle the interrupt if the driver is initialized.
	//{
		//uart_process_byte(USART0, &(uartMemBuf[2]));
	//}
	uint32_t status = uart_get_status(USART0); 
  40500a:	480e      	ldr	r0, [pc, #56]	; (405044 <USART0_Handler+0x3c>)
  40500c:	4b0e      	ldr	r3, [pc, #56]	; (405048 <USART0_Handler+0x40>)
  40500e:	4798      	blx	r3
	if(status & UART_SR_RXRDY > 0)
  405010:	07c2      	lsls	r2, r0, #31
{
	//if(uartMemBuf[2].isinit) //only handle the interrupt if the driver is initialized.
	//{
		//uart_process_byte(USART0, &(uartMemBuf[2]));
	//}
	uint32_t status = uart_get_status(USART0); 
  405012:	4604      	mov	r4, r0
	if(status & UART_SR_RXRDY > 0)
  405014:	d503      	bpl.n	40501e <USART0_Handler+0x16>
	{	
		if(uartMemBuf[2].isinit) //only handle the interrupt if the driver is initialized.
  405016:	490d      	ldr	r1, [pc, #52]	; (40504c <USART0_Handler+0x44>)
  405018:	f891 3a46 	ldrb.w	r3, [r1, #2630]	; 0xa46
  40501c:	b963      	cbnz	r3, 405038 <USART0_Handler+0x30>
		{
			uart_process_byte(USART0, &(uartMemBuf[2]));
		}
	}
	
	if(status & UART_SR_TXEMPTY)
  40501e:	05a3      	lsls	r3, r4, #22
  405020:	d503      	bpl.n	40502a <USART0_Handler+0x22>
	{
		if(uartMemBuf[2].isinit) //only handle the interrupt if the driver is initialized.
  405022:	490a      	ldr	r1, [pc, #40]	; (40504c <USART0_Handler+0x44>)
  405024:	f891 3a46 	ldrb.w	r3, [r1, #2630]	; 0xa46
  405028:	b903      	cbnz	r3, 40502c <USART0_Handler+0x24>
  40502a:	bd10      	pop	{r4, pc}
		{
			uart_process_tx_byte(USART0, &(uartMemBuf[2])); 	
  40502c:	f501 6104 	add.w	r1, r1, #2112	; 0x840
  405030:	4804      	ldr	r0, [pc, #16]	; (405044 <USART0_Handler+0x3c>)
  405032:	4b07      	ldr	r3, [pc, #28]	; (405050 <USART0_Handler+0x48>)
  405034:	4798      	blx	r3
  405036:	bd10      	pop	{r4, pc}
	uint32_t status = uart_get_status(USART0); 
	if(status & UART_SR_RXRDY > 0)
	{	
		if(uartMemBuf[2].isinit) //only handle the interrupt if the driver is initialized.
		{
			uart_process_byte(USART0, &(uartMemBuf[2]));
  405038:	f501 6104 	add.w	r1, r1, #2112	; 0x840
  40503c:	4801      	ldr	r0, [pc, #4]	; (405044 <USART0_Handler+0x3c>)
  40503e:	4b05      	ldr	r3, [pc, #20]	; (405054 <USART0_Handler+0x4c>)
  405040:	4798      	blx	r3
  405042:	e7ec      	b.n	40501e <USART0_Handler+0x16>
  405044:	40024000 	.word	0x40024000
  405048:	00402359 	.word	0x00402359
  40504c:	200013c0 	.word	0x200013c0
  405050:	00404ded 	.word	0x00404ded
  405054:	00404d65 	.word	0x00404d65

00405058 <USART1_Handler>:
		}
	}	
}

void USART1_Handler()
{
  405058:	b510      	push	{r4, lr}
	//if(uartMemBuf[3].isinit) //only handle the interrupt if the driver is initialized.
	//{
		//uart_process_byte(USART1, &(uartMemBuf[3]));
	//}
	uint32_t status = uart_get_status(USART1); 
  40505a:	480e      	ldr	r0, [pc, #56]	; (405094 <USART1_Handler+0x3c>)
  40505c:	4b0e      	ldr	r3, [pc, #56]	; (405098 <USART1_Handler+0x40>)
  40505e:	4798      	blx	r3
	if(status & UART_SR_RXRDY > 0)
  405060:	07c2      	lsls	r2, r0, #31
{
	//if(uartMemBuf[3].isinit) //only handle the interrupt if the driver is initialized.
	//{
		//uart_process_byte(USART1, &(uartMemBuf[3]));
	//}
	uint32_t status = uart_get_status(USART1); 
  405062:	4604      	mov	r4, r0
	if(status & UART_SR_RXRDY > 0)
  405064:	d503      	bpl.n	40506e <USART1_Handler+0x16>
	{	
		if(uartMemBuf[3].isinit) //only handle the interrupt if the driver is initialized.
  405066:	490d      	ldr	r1, [pc, #52]	; (40509c <USART1_Handler+0x44>)
  405068:	f891 3e66 	ldrb.w	r3, [r1, #3686]	; 0xe66
  40506c:	b963      	cbnz	r3, 405088 <USART1_Handler+0x30>
		{
			uart_process_byte(USART1, &(uartMemBuf[3]));
		}
	}
	
	if(status & UART_SR_TXEMPTY)
  40506e:	05a3      	lsls	r3, r4, #22
  405070:	d503      	bpl.n	40507a <USART1_Handler+0x22>
	{
		if(uartMemBuf[3].isinit) //only handle the interrupt if the driver is initialized.
  405072:	490a      	ldr	r1, [pc, #40]	; (40509c <USART1_Handler+0x44>)
  405074:	f891 3e66 	ldrb.w	r3, [r1, #3686]	; 0xe66
  405078:	b903      	cbnz	r3, 40507c <USART1_Handler+0x24>
  40507a:	bd10      	pop	{r4, pc}
		{
			uart_process_tx_byte(USART1, &(uartMemBuf[3])); 	
  40507c:	f501 6146 	add.w	r1, r1, #3168	; 0xc60
  405080:	4804      	ldr	r0, [pc, #16]	; (405094 <USART1_Handler+0x3c>)
  405082:	4b07      	ldr	r3, [pc, #28]	; (4050a0 <USART1_Handler+0x48>)
  405084:	4798      	blx	r3
  405086:	bd10      	pop	{r4, pc}
	uint32_t status = uart_get_status(USART1); 
	if(status & UART_SR_RXRDY > 0)
	{	
		if(uartMemBuf[3].isinit) //only handle the interrupt if the driver is initialized.
		{
			uart_process_byte(USART1, &(uartMemBuf[3]));
  405088:	f501 6146 	add.w	r1, r1, #3168	; 0xc60
  40508c:	4801      	ldr	r0, [pc, #4]	; (405094 <USART1_Handler+0x3c>)
  40508e:	4b05      	ldr	r3, [pc, #20]	; (4050a4 <USART1_Handler+0x4c>)
  405090:	4798      	blx	r3
  405092:	e7ec      	b.n	40506e <USART1_Handler+0x16>
  405094:	40028000 	.word	0x40028000
  405098:	00402359 	.word	0x00402359
  40509c:	200013c0 	.word	0x200013c0
  4050a0:	00404ded 	.word	0x00404ded
  4050a4:	00404d65 	.word	0x00404d65

004050a8 <sysclk_init>:
	pmc_disable_udpck();
}
#endif // CONFIG_USBCLK_SOURCE

void sysclk_init(void)
{
  4050a8:	b538      	push	{r3, r4, r5, lr}
	/* Set flash wait state to max in case the below clock switching. */
	system_init_flash(CHIP_FREQ_CPU_MAX);
  4050aa:	480e      	ldr	r0, [pc, #56]	; (4050e4 <sysclk_init+0x3c>)
  4050ac:	4d0e      	ldr	r5, [pc, #56]	; (4050e8 <sysclk_init+0x40>)
  4050ae:	4c0f      	ldr	r4, [pc, #60]	; (4050ec <sysclk_init+0x44>)
  4050b0:	47a8      	blx	r5
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_12_MHz);
		break;


	case OSC_MAINCK_XTAL:
		pmc_switch_mainck_to_xtal(PMC_OSC_XTAL,
  4050b2:	2000      	movs	r0, #0
  4050b4:	213e      	movs	r1, #62	; 0x3e
  4050b6:	4b0e      	ldr	r3, [pc, #56]	; (4050f0 <sysclk_init+0x48>)
  4050b8:	4798      	blx	r3
	case OSC_MAINCK_4M_RC:
	case OSC_MAINCK_8M_RC:
	case OSC_MAINCK_12M_RC:
	case OSC_MAINCK_XTAL:
	case OSC_MAINCK_BYPASS:
		return pmc_osc_is_ready_mainck();
  4050ba:	47a0      	blx	r4
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
	while (!osc_is_ready(id)) {
  4050bc:	2800      	cmp	r0, #0
  4050be:	d0fc      	beq.n	4050ba <sysclk_init+0x12>
static inline void pll_enable(const struct pll_config *p_cfg, uint32_t ul_pll_id)
{
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
		pmc_disable_pllack(); // Always stop PLL first!
  4050c0:	4b0c      	ldr	r3, [pc, #48]	; (4050f4 <sysclk_init+0x4c>)
  4050c2:	4c0d      	ldr	r4, [pc, #52]	; (4050f8 <sysclk_init+0x50>)
  4050c4:	4798      	blx	r3
		PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | p_cfg->ctrl;
  4050c6:	4b0d      	ldr	r3, [pc, #52]	; (4050fc <sysclk_init+0x54>)
  4050c8:	4a0d      	ldr	r2, [pc, #52]	; (405100 <sysclk_init+0x58>)
  4050ca:	629a      	str	r2, [r3, #40]	; 0x28
static inline uint32_t pll_is_locked(uint32_t ul_pll_id)
{
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
		return pmc_is_locked_pllack();
  4050cc:	47a0      	blx	r4
 */
static inline int pll_wait_for_lock(unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	while (!pll_is_locked(pll_id)) {
  4050ce:	2800      	cmp	r0, #0
  4050d0:	d0fc      	beq.n	4050cc <sysclk_init+0x24>

		pll_enable_source(CONFIG_PLL0_SOURCE);
		pll_config_defaults(&pllcfg, 0);
		pll_enable(&pllcfg, 0);
		pll_wait_for_lock(0);
		pmc_switch_mck_to_pllack(CONFIG_SYSCLK_PRES);
  4050d2:	4b0c      	ldr	r3, [pc, #48]	; (405104 <sysclk_init+0x5c>)
  4050d4:	2010      	movs	r0, #16
  4050d6:	4798      	blx	r3
		pmc_switch_mck_to_pllbck(CONFIG_SYSCLK_PRES);
	}
#endif

	/* Update the SystemFrequency variable */
	SystemCoreClockUpdate();
  4050d8:	4b0b      	ldr	r3, [pc, #44]	; (405108 <sysclk_init+0x60>)
  4050da:	4798      	blx	r3

	/* Set a flash wait state depending on the new cpu frequency */
	system_init_flash(sysclk_get_cpu_hz());
  4050dc:	4801      	ldr	r0, [pc, #4]	; (4050e4 <sysclk_init+0x3c>)
  4050de:	47a8      	blx	r5
  4050e0:	bd38      	pop	{r3, r4, r5, pc}
  4050e2:	bf00      	nop
  4050e4:	07270e00 	.word	0x07270e00
  4050e8:	004057f1 	.word	0x004057f1
  4050ec:	004055ed 	.word	0x004055ed
  4050f0:	00405599 	.word	0x00405599
  4050f4:	004055fd 	.word	0x004055fd
  4050f8:	0040560d 	.word	0x0040560d
  4050fc:	400e0400 	.word	0x400e0400
  405100:	200e3f01 	.word	0x200e3f01
  405104:	00405541 	.word	0x00405541
  405108:	00405709 	.word	0x00405709

0040510c <board_init>:
 * \addtogroup sam4s_xplained_pro_group
 * @{
 */

void board_init(void)
{
  40510c:	b538      	push	{r3, r4, r5, lr}
 *
 * \param ul_id Id (number) of the peripheral clock.
 */
static inline void sysclk_enable_peripheral_clock(uint32_t ul_id)
{
	pmc_enable_periph_clk(ul_id);
  40510e:	200b      	movs	r0, #11
  405110:	4d13      	ldr	r5, [pc, #76]	; (405160 <board_init+0x54>)
// 	ioport_set_pin_level(IO1_LED3_PIN, !IO1_LED3_ACTIVE);
// 	ioport_set_pin_dir(IO1_LED3_PIN, IOPORT_DIR_OUTPUT);
	
	
	/* Configure HSMCI pins */
	gpio_configure_pin(PIN_HSMCI_MCCDA_GPIO, PIN_HSMCI_MCCDA_FLAGS);
  405112:	4c14      	ldr	r4, [pc, #80]	; (405164 <board_init+0x58>)
  405114:	47a8      	blx	r5
  405116:	200c      	movs	r0, #12
  405118:	47a8      	blx	r5
  40511a:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  40511e:	201c      	movs	r0, #28
  405120:	47a0      	blx	r4
	gpio_configure_pin(PIN_HSMCI_MCCK_GPIO, PIN_HSMCI_MCCK_FLAGS);
  405122:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  405126:	201d      	movs	r0, #29
  405128:	47a0      	blx	r4
	gpio_configure_pin(PIN_HSMCI_MCDA0_GPIO, PIN_HSMCI_MCDA0_FLAGS);
  40512a:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  40512e:	201e      	movs	r0, #30
  405130:	47a0      	blx	r4
	gpio_configure_pin(PIN_HSMCI_MCDA1_GPIO, PIN_HSMCI_MCDA1_FLAGS);
  405132:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  405136:	201f      	movs	r0, #31
  405138:	47a0      	blx	r4
	gpio_configure_pin(PIN_HSMCI_MCDA2_GPIO, PIN_HSMCI_MCDA2_FLAGS);
  40513a:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  40513e:	201a      	movs	r0, #26
  405140:	47a0      	blx	r4
	gpio_configure_pin(PIN_HSMCI_MCDA3_GPIO, PIN_HSMCI_MCDA3_FLAGS);
  405142:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  405146:	201b      	movs	r0, #27
  405148:	47a0      	blx	r4

	/* Configure SD/MMC card detect pin */
	gpio_configure_pin(SD_MMC_0_CD_GPIO, SD_MMC_0_CD_FLAGS);
  40514a:	4907      	ldr	r1, [pc, #28]	; (405168 <board_init+0x5c>)
  40514c:	202b      	movs	r0, #43	; 0x2b
  40514e:	47a0      	blx	r4

//#ifdef CONF_BOARD_UART_CONSOLE
	/* Configure UART pins */
	gpio_configure_group(PINS_UART1_PIO, PINS_UART1, PINS_UART1_FLAGS);
  405150:	4b06      	ldr	r3, [pc, #24]	; (40516c <board_init+0x60>)
  405152:	4807      	ldr	r0, [pc, #28]	; (405170 <board_init+0x64>)
  405154:	210c      	movs	r1, #12
  405156:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
  40515a:	4798      	blx	r3
  40515c:	bd38      	pop	{r3, r4, r5, pc}
  40515e:	bf00      	nop
  405160:	0040561d 	.word	0x0040561d
  405164:	004052e9 	.word	0x004052e9
  405168:	28000001 	.word	0x28000001
  40516c:	004053a1 	.word	0x004053a1
  405170:	400e1000 	.word	0x400e1000

00405174 <pio_set_debounce_filter>:
	/*
	 * The debouncing filter can filter a pulse of less than 1/2 Period of a
	 * programmable Divided Slow Clock:
	 * Tdiv_slclk = ((DIV+1)*2).Tslow_clock
	 */
	p_pio->PIO_SCDR = PIO_SCDR_DIV((FREQ_SLOW_CLOCK_EXT /
  405174:	0052      	lsls	r2, r2, #1
  405176:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  40517a:	fbb3 f2f2 	udiv	r2, r3, r2
  40517e:	3a01      	subs	r2, #1
  405180:	f3c2 020d 	ubfx	r2, r2, #0, #14
void pio_set_debounce_filter(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_cut_off)
{
#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	/* Set Debouncing, 0 bit field no effect */
	p_pio->PIO_IFSCER = ul_mask;
  405184:	f8c0 1084 	str.w	r1, [r0, #132]	; 0x84
	/*
	 * The debouncing filter can filter a pulse of less than 1/2 Period of a
	 * programmable Divided Slow Clock:
	 * Tdiv_slclk = ((DIV+1)*2).Tslow_clock
	 */
	p_pio->PIO_SCDR = PIO_SCDR_DIV((FREQ_SLOW_CLOCK_EXT /
  405188:	f8c0 208c 	str.w	r2, [r0, #140]	; 0x8c
  40518c:	4770      	bx	lr
  40518e:	bf00      	nop

00405190 <pio_set_peripheral>:

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	switch (ul_type) {
  405190:	f1b1 5fc0 	cmp.w	r1, #402653184	; 0x18000000
 * \param ul_type PIO type.
 * \param ul_mask Bitmask of one or more pin(s) to configure.
 */
void pio_set_peripheral(Pio *p_pio, const pio_type_t ul_type,
		const uint32_t ul_mask)
{
  405194:	b410      	push	{r4}
	uint32_t ul_sr;

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;
  405196:	6442      	str	r2, [r0, #68]	; 0x44

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	switch (ul_type) {
  405198:	d030      	beq.n	4051fc <pio_set_peripheral+0x6c>
  40519a:	d812      	bhi.n	4051c2 <pio_set_peripheral+0x32>
  40519c:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
  4051a0:	d020      	beq.n	4051e4 <pio_set_peripheral+0x54>
  4051a2:	f1b1 5f80 	cmp.w	r1, #268435456	; 0x10000000
  4051a6:	d11a      	bne.n	4051de <pio_set_peripheral+0x4e>

		ul_sr = p_pio->PIO_ABCDSR[1];
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
		break;
	case PIO_PERIPH_B:
		ul_sr = p_pio->PIO_ABCDSR[0];
  4051a8:	6f03      	ldr	r3, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] = (ul_mask | ul_sr);
  4051aa:	4313      	orrs	r3, r2
  4051ac:	6703      	str	r3, [r0, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  4051ae:	6f43      	ldr	r3, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  4051b0:	6f41      	ldr	r1, [r0, #116]	; 0x74
  4051b2:	400b      	ands	r3, r1
  4051b4:	ea23 0302 	bic.w	r3, r3, r2
  4051b8:	6743      	str	r3, [r0, #116]	; 0x74
#else
#error "Unsupported device"
#endif

	/* Remove the pins from under the control of PIO */
	p_pio->PIO_PDR = ul_mask;
  4051ba:	6042      	str	r2, [r0, #4]
}
  4051bc:	f85d 4b04 	ldr.w	r4, [sp], #4
  4051c0:	4770      	bx	lr

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	switch (ul_type) {
  4051c2:	f1b1 5f20 	cmp.w	r1, #671088640	; 0x28000000
  4051c6:	d0f9      	beq.n	4051bc <pio_set_peripheral+0x2c>
  4051c8:	d822      	bhi.n	405210 <pio_set_peripheral+0x80>
  4051ca:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
  4051ce:	d1f4      	bne.n	4051ba <pio_set_peripheral+0x2a>

		ul_sr = p_pio->PIO_ABCDSR[1];
		p_pio->PIO_ABCDSR[1] = (ul_mask | ul_sr);
		break;
	case PIO_PERIPH_D:
		ul_sr = p_pio->PIO_ABCDSR[0];
  4051d0:	6f03      	ldr	r3, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] = (ul_mask | ul_sr);
  4051d2:	4313      	orrs	r3, r2
  4051d4:	6703      	str	r3, [r0, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  4051d6:	6f43      	ldr	r3, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] = (ul_mask | ul_sr);
  4051d8:	4313      	orrs	r3, r2
  4051da:	6743      	str	r3, [r0, #116]	; 0x74
		break;
  4051dc:	e7ed      	b.n	4051ba <pio_set_peripheral+0x2a>

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	switch (ul_type) {
  4051de:	2900      	cmp	r1, #0
  4051e0:	d1eb      	bne.n	4051ba <pio_set_peripheral+0x2a>
  4051e2:	e7eb      	b.n	4051bc <pio_set_peripheral+0x2c>
	case PIO_PERIPH_A:
		ul_sr = p_pio->PIO_ABCDSR[0];
  4051e4:	6f01      	ldr	r1, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] &= (~ul_mask & ul_sr);
  4051e6:	6f04      	ldr	r4, [r0, #112]	; 0x70
  4051e8:	43d3      	mvns	r3, r2
  4051ea:	4021      	ands	r1, r4
  4051ec:	4019      	ands	r1, r3
  4051ee:	6701      	str	r1, [r0, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  4051f0:	6f41      	ldr	r1, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  4051f2:	6f44      	ldr	r4, [r0, #116]	; 0x74
  4051f4:	4021      	ands	r1, r4
  4051f6:	400b      	ands	r3, r1
  4051f8:	6743      	str	r3, [r0, #116]	; 0x74
		break;
  4051fa:	e7de      	b.n	4051ba <pio_set_peripheral+0x2a>
		ul_sr = p_pio->PIO_ABCDSR[1];
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
		break;
#if (!SAMG)
	case PIO_PERIPH_C:
		ul_sr = p_pio->PIO_ABCDSR[0];
  4051fc:	6f03      	ldr	r3, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] &= (~ul_mask & ul_sr);
  4051fe:	6f01      	ldr	r1, [r0, #112]	; 0x70
  405200:	400b      	ands	r3, r1
  405202:	ea23 0302 	bic.w	r3, r3, r2
  405206:	6703      	str	r3, [r0, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  405208:	6f43      	ldr	r3, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] = (ul_mask | ul_sr);
  40520a:	4313      	orrs	r3, r2
  40520c:	6743      	str	r3, [r0, #116]	; 0x74
		break;
  40520e:	e7d4      	b.n	4051ba <pio_set_peripheral+0x2a>

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	switch (ul_type) {
  405210:	f1b1 5f40 	cmp.w	r1, #805306368	; 0x30000000
  405214:	d0d2      	beq.n	4051bc <pio_set_peripheral+0x2c>
  405216:	f1b1 5f60 	cmp.w	r1, #939524096	; 0x38000000
  40521a:	d0cf      	beq.n	4051bc <pio_set_peripheral+0x2c>
  40521c:	e7cd      	b.n	4051ba <pio_set_peripheral+0x2a>
  40521e:	bf00      	nop

00405220 <pio_set_input>:
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
  405220:	07d3      	lsls	r3, r2, #31
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_disable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
	p_pio->PIO_IDR = ul_mask;
  405222:	6441      	str	r1, [r0, #68]	; 0x44
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
		p_pio->PIO_PUER = ul_mask;
  405224:	bf4c      	ite	mi
  405226:	6641      	strmi	r1, [r0, #100]	; 0x64
	} else {
		p_pio->PIO_PUDR = ul_mask;
  405228:	6601      	strpl	r1, [r0, #96]	; 0x60
{
	pio_disable_interrupt(p_pio, ul_mask);
	pio_pull_up(p_pio, ul_mask, ul_attribute & PIO_PULLUP);

	/* Enable Input Filter if necessary */
	if (ul_attribute & (PIO_DEGLITCH | PIO_DEBOUNCE)) {
  40522a:	f012 0f0a 	tst.w	r2, #10
		p_pio->PIO_IFER = ul_mask;
  40522e:	bf14      	ite	ne
  405230:	6201      	strne	r1, [r0, #32]
	} else {
		p_pio->PIO_IFDR = ul_mask;
  405232:	6241      	streq	r1, [r0, #36]	; 0x24
	}

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	/* Enable de-glitch or de-bounce if necessary */
	if (ul_attribute & PIO_DEGLITCH) {
  405234:	0793      	lsls	r3, r2, #30
  405236:	d406      	bmi.n	405246 <pio_set_input+0x26>
		p_pio->PIO_IFSCDR = ul_mask;
	} else {
		if (ul_attribute & PIO_DEBOUNCE) {
  405238:	0713      	lsls	r3, r2, #28
			p_pio->PIO_IFSCER = ul_mask;
  40523a:	bf48      	it	mi
  40523c:	f8c0 1084 	strmi.w	r1, [r0, #132]	; 0x84
#else
#error "Unsupported device"
#endif

	/* Configure pin as input */
	p_pio->PIO_ODR = ul_mask;
  405240:	6141      	str	r1, [r0, #20]
	p_pio->PIO_PER = ul_mask;
  405242:	6001      	str	r1, [r0, #0]
  405244:	4770      	bx	lr
	}

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	/* Enable de-glitch or de-bounce if necessary */
	if (ul_attribute & PIO_DEGLITCH) {
		p_pio->PIO_IFSCDR = ul_mask;
  405246:	f8c0 1080 	str.w	r1, [r0, #128]	; 0x80
#else
#error "Unsupported device"
#endif

	/* Configure pin as input */
	p_pio->PIO_ODR = ul_mask;
  40524a:	6141      	str	r1, [r0, #20]
	p_pio->PIO_PER = ul_mask;
  40524c:	6001      	str	r1, [r0, #0]
  40524e:	4770      	bx	lr

00405250 <pio_configure_interrupt>:
 */
void pio_configure_interrupt(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_attr)
{
	/* Configure additional interrupt mode registers. */
	if (ul_attr & PIO_IT_AIME) {
  405250:	06d3      	lsls	r3, r2, #27
  405252:	d50e      	bpl.n	405272 <pio_configure_interrupt+0x22>
		/* Enable additional interrupt mode. */
		p_pio->PIO_AIMER = ul_mask;

		/* If bit field of the selected pin is 1, set as
		   Rising Edge/High level detection event. */
		if (ul_attr & PIO_IT_RE_OR_HL) {
  405254:	0693      	lsls	r3, r2, #26
		const uint32_t ul_attr)
{
	/* Configure additional interrupt mode registers. */
	if (ul_attr & PIO_IT_AIME) {
		/* Enable additional interrupt mode. */
		p_pio->PIO_AIMER = ul_mask;
  405256:	f8c0 10b0 	str.w	r1, [r0, #176]	; 0xb0

		/* If bit field of the selected pin is 1, set as
		   Rising Edge/High level detection event. */
		if (ul_attr & PIO_IT_RE_OR_HL) {
			/* Rising Edge or High Level */
			p_pio->PIO_REHLSR = ul_mask;
  40525a:	bf4c      	ite	mi
  40525c:	f8c0 10d4 	strmi.w	r1, [r0, #212]	; 0xd4
		} else {
			/* Falling Edge or Low Level */
			p_pio->PIO_FELLSR = ul_mask;
  405260:	f8c0 10d0 	strpl.w	r1, [r0, #208]	; 0xd0
		}

		/* If bit field of the selected pin is 1, set as
		   edge detection source. */
		if (ul_attr & PIO_IT_EDGE) {
  405264:	0653      	lsls	r3, r2, #25
			/* Edge select */
			p_pio->PIO_ESR = ul_mask;
  405266:	bf4c      	ite	mi
  405268:	f8c0 10c0 	strmi.w	r1, [r0, #192]	; 0xc0
		} else {
			/* Level select */
			p_pio->PIO_LSR = ul_mask;
  40526c:	f8c0 10c4 	strpl.w	r1, [r0, #196]	; 0xc4
  405270:	4770      	bx	lr
		}
	} else {
		/* Disable additional interrupt mode. */
		p_pio->PIO_AIMDR = ul_mask;
  405272:	f8c0 10b4 	str.w	r1, [r0, #180]	; 0xb4
  405276:	4770      	bx	lr

00405278 <pio_enable_interrupt>:
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_enable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
	p_pio->PIO_ISR;
  405278:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
	p_pio->PIO_IER = ul_mask;
  40527a:	6401      	str	r1, [r0, #64]	; 0x40
  40527c:	4770      	bx	lr
  40527e:	bf00      	nop

00405280 <pio_disable_interrupt>:
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_disable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
	p_pio->PIO_IDR = ul_mask;
  405280:	6441      	str	r1, [r0, #68]	; 0x44
  405282:	4770      	bx	lr

00405284 <pio_get_interrupt_status>:
 *
 * \return The interrupt status mask value.
 */
uint32_t pio_get_interrupt_status(const Pio *p_pio)
{
	return p_pio->PIO_ISR;
  405284:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
}
  405286:	4770      	bx	lr

00405288 <pio_get_interrupt_mask>:
 *
 * \return The interrupt mask value.
 */
uint32_t pio_get_interrupt_mask(const Pio *p_pio)
{
	return p_pio->PIO_IMR;
  405288:	6c80      	ldr	r0, [r0, #72]	; 0x48
}
  40528a:	4770      	bx	lr

0040528c <pio_set_pin_high>:
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  40528c:	0943      	lsrs	r3, r0, #5
  40528e:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  405292:	f203 7307 	addw	r3, r3, #1799	; 0x707
  405296:	025b      	lsls	r3, r3, #9
void pio_set_pin_high(uint32_t ul_pin)
{
	Pio *p_pio = pio_get_pin_group(ul_pin);

	/* Value to be driven on the I/O line: 1. */
	p_pio->PIO_SODR = 1 << (ul_pin & 0x1F);
  405298:	f000 001f 	and.w	r0, r0, #31
  40529c:	2201      	movs	r2, #1
  40529e:	fa02 f000 	lsl.w	r0, r2, r0
  4052a2:	6318      	str	r0, [r3, #48]	; 0x30
  4052a4:	4770      	bx	lr
  4052a6:	bf00      	nop

004052a8 <pio_set_pin_low>:
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  4052a8:	0943      	lsrs	r3, r0, #5
  4052aa:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  4052ae:	f203 7307 	addw	r3, r3, #1799	; 0x707
  4052b2:	025b      	lsls	r3, r3, #9
void pio_set_pin_low(uint32_t ul_pin)
{
	Pio *p_pio = pio_get_pin_group(ul_pin);

	/* Value to be driven on the I/O line: 0. */
	p_pio->PIO_CODR = 1 << (ul_pin & 0x1F);
  4052b4:	f000 001f 	and.w	r0, r0, #31
  4052b8:	2201      	movs	r2, #1
  4052ba:	fa02 f000 	lsl.w	r0, r2, r0
  4052be:	6358      	str	r0, [r3, #52]	; 0x34
  4052c0:	4770      	bx	lr
  4052c2:	bf00      	nop

004052c4 <pio_toggle_pin>:
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  4052c4:	0943      	lsrs	r3, r0, #5
  4052c6:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  4052ca:	f203 7307 	addw	r3, r3, #1799	; 0x707
  4052ce:	025b      	lsls	r3, r3, #9
 */
void pio_toggle_pin(uint32_t ul_pin)
{
	Pio *p_pio = pio_get_pin_group(ul_pin);

	if (p_pio->PIO_ODSR & (1 << (ul_pin & 0x1F))) {
  4052d0:	f000 001f 	and.w	r0, r0, #31
  4052d4:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  4052d6:	2101      	movs	r1, #1
  4052d8:	fa01 f000 	lsl.w	r0, r1, r0
  4052dc:	4210      	tst	r0, r2
		/* Value to be driven on the I/O line: 0. */
		p_pio->PIO_CODR = 1 << (ul_pin & 0x1F);
  4052de:	bf14      	ite	ne
  4052e0:	6358      	strne	r0, [r3, #52]	; 0x34
	} else {
		/* Value to be driven on the I/O line: 1. */
		p_pio->PIO_SODR = 1 << (ul_pin & 0x1F);
  4052e2:	6318      	streq	r0, [r3, #48]	; 0x30
  4052e4:	4770      	bx	lr
  4052e6:	bf00      	nop

004052e8 <pio_configure_pin>:
 * \param ul_flags Pins attributes.
 *
 * \return Whether the pin(s) have been configured properly.
 */
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
  4052e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  4052ea:	0944      	lsrs	r4, r0, #5
 * \param ul_flags Pins attributes.
 *
 * \return Whether the pin(s) have been configured properly.
 */
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
  4052ec:	460d      	mov	r5, r1
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  4052ee:	f504 1400 	add.w	r4, r4, #2097152	; 0x200000
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
	Pio *p_pio = pio_get_pin_group(ul_pin);

	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  4052f2:	f001 41f0 	and.w	r1, r1, #2013265920	; 0x78000000
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  4052f6:	f204 7407 	addw	r4, r4, #1799	; 0x707
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
	Pio *p_pio = pio_get_pin_group(ul_pin);

	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  4052fa:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  4052fe:	ea4f 2444 	mov.w	r4, r4, lsl #9
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
	Pio *p_pio = pio_get_pin_group(ul_pin);

	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  405302:	d00b      	beq.n	40531c <pio_configure_pin+0x34>
  405304:	d819      	bhi.n	40533a <pio_configure_pin+0x52>
  405306:	f1b1 5f80 	cmp.w	r1, #268435456	; 0x10000000
  40530a:	d007      	beq.n	40531c <pio_configure_pin+0x34>
  40530c:	f1b1 5fc0 	cmp.w	r1, #402653184	; 0x18000000
  405310:	d004      	beq.n	40531c <pio_configure_pin+0x34>
  405312:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
  405316:	d001      	beq.n	40531c <pio_configure_pin+0x34>
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
				(ul_flags & PIO_PULLUP) ? 1 : 0);
		break;

	default:
		return 0;
  405318:	2000      	movs	r0, #0
	}

	return 1;
}
  40531a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		pio_set_peripheral(p_pio, PIO_PERIPH_C, (1 << (ul_pin & 0x1F)));
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
				(ul_flags & PIO_PULLUP));
		break;
	case PIO_TYPE_PIO_PERIPH_D:
		pio_set_peripheral(p_pio, PIO_PERIPH_D, (1 << (ul_pin & 0x1F)));
  40531c:	2601      	movs	r6, #1
  40531e:	f000 001f 	and.w	r0, r0, #31
  405322:	fa06 f700 	lsl.w	r7, r6, r0
  405326:	463a      	mov	r2, r7
  405328:	4620      	mov	r0, r4
  40532a:	4b1b      	ldr	r3, [pc, #108]	; (405398 <pio_configure_pin+0xb0>)
  40532c:	4798      	blx	r3
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
  40532e:	07ed      	lsls	r5, r5, #31
		p_pio->PIO_PUER = ul_mask;
  405330:	bf4c      	ite	mi
  405332:	6667      	strmi	r7, [r4, #100]	; 0x64
	} else {
		p_pio->PIO_PUDR = ul_mask;
  405334:	6627      	strpl	r7, [r4, #96]	; 0x60

	default:
		return 0;
	}

	return 1;
  405336:	4630      	mov	r0, r6
  405338:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
	Pio *p_pio = pio_get_pin_group(ul_pin);

	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  40533a:	f1b1 5f40 	cmp.w	r1, #805306368	; 0x30000000
  40533e:	d010      	beq.n	405362 <pio_configure_pin+0x7a>
  405340:	f1b1 5f60 	cmp.w	r1, #939524096	; 0x38000000
  405344:	d00d      	beq.n	405362 <pio_configure_pin+0x7a>
  405346:	f1b1 5f20 	cmp.w	r1, #671088640	; 0x28000000
  40534a:	d1e5      	bne.n	405318 <pio_configure_pin+0x30>
				(ul_flags & PIO_PULLUP));
		break;
//#endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, (1 << (ul_pin & 0x1F)), ul_flags);
  40534c:	2601      	movs	r6, #1
  40534e:	f000 011f 	and.w	r1, r0, #31
  405352:	462a      	mov	r2, r5
  405354:	4620      	mov	r0, r4
  405356:	fa06 f101 	lsl.w	r1, r6, r1
  40535a:	4b10      	ldr	r3, [pc, #64]	; (40539c <pio_configure_pin+0xb4>)
  40535c:	4798      	blx	r3

	default:
		return 0;
	}

	return 1;
  40535e:	4630      	mov	r0, r6
		break;
//#endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, (1 << (ul_pin & 0x1F)), ul_flags);
		break;
  405360:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, (1 << (ul_pin & 0x1F)),
  405362:	f000 001f 	and.w	r0, r0, #31
  405366:	2301      	movs	r3, #1
  405368:	4083      	lsls	r3, r0
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
				== PIO_TYPE_PIO_OUTPUT_1) ? 1 : 0,
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
  40536a:	f005 0104 	and.w	r1, r5, #4
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
  40536e:	07e8      	lsls	r0, r5, #31
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_disable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
	p_pio->PIO_IDR = ul_mask;
  405370:	6463      	str	r3, [r4, #68]	; 0x44
		break;

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, (1 << (ul_pin & 0x1F)),
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
  405372:	f005 5260 	and.w	r2, r5, #939524096	; 0x38000000
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
		p_pio->PIO_PUER = ul_mask;
  405376:	bf4c      	ite	mi
  405378:	6663      	strmi	r3, [r4, #100]	; 0x64
	} else {
		p_pio->PIO_PUDR = ul_mask;
  40537a:	6623      	strpl	r3, [r4, #96]	; 0x60
{
	pio_disable_interrupt(p_pio, ul_mask);
	pio_pull_up(p_pio, ul_mask, ul_pull_up_enable);

	/* Enable multi-drive if necessary */
	if (ul_multidrive_enable) {
  40537c:	b149      	cbz	r1, 405392 <pio_configure_pin+0xaa>
		p_pio->PIO_MDER = ul_mask;
  40537e:	6523      	str	r3, [r4, #80]	; 0x50
	} else {
		p_pio->PIO_MDDR = ul_mask;
	}

	/* Set default value */
	if (ul_default_level) {
  405380:	f1b2 5f60 	cmp.w	r2, #939524096	; 0x38000000
		p_pio->PIO_SODR = ul_mask;
  405384:	bf0c      	ite	eq
  405386:	6323      	streq	r3, [r4, #48]	; 0x30
	} else {
		p_pio->PIO_CODR = ul_mask;
  405388:	6363      	strne	r3, [r4, #52]	; 0x34
	}

	/* Configure pin(s) as output(s) */
	p_pio->PIO_OER = ul_mask;
  40538a:	6123      	str	r3, [r4, #16]
	p_pio->PIO_PER = ul_mask;
  40538c:	6023      	str	r3, [r4, #0]

	default:
		return 0;
	}

	return 1;
  40538e:	2001      	movs	r0, #1
  405390:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	/* Enable multi-drive if necessary */
	if (ul_multidrive_enable) {
		p_pio->PIO_MDER = ul_mask;
	} else {
		p_pio->PIO_MDDR = ul_mask;
  405392:	6563      	str	r3, [r4, #84]	; 0x54
  405394:	e7f4      	b.n	405380 <pio_configure_pin+0x98>
  405396:	bf00      	nop
  405398:	00405191 	.word	0x00405191
  40539c:	00405221 	.word	0x00405221

004053a0 <pio_configure_pin_group>:
 */
uint32_t pio_configure_pin_group(Pio *p_pio,
		uint32_t ul_mask, const uint32_t ul_flags)
{
	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  4053a0:	f002 43f0 	and.w	r3, r2, #2013265920	; 0x78000000
  4053a4:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 *
 * \return Whether the pin(s) have been configured properly.
 */
uint32_t pio_configure_pin_group(Pio *p_pio,
		uint32_t ul_mask, const uint32_t ul_flags)
{
  4053a8:	b570      	push	{r4, r5, r6, lr}
  4053aa:	4614      	mov	r4, r2
  4053ac:	4606      	mov	r6, r0
  4053ae:	460d      	mov	r5, r1
	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  4053b0:	d00b      	beq.n	4053ca <pio_configure_pin_group+0x2a>
  4053b2:	d814      	bhi.n	4053de <pio_configure_pin_group+0x3e>
  4053b4:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
  4053b8:	d007      	beq.n	4053ca <pio_configure_pin_group+0x2a>
  4053ba:	f1b3 5fc0 	cmp.w	r3, #402653184	; 0x18000000
  4053be:	d004      	beq.n	4053ca <pio_configure_pin_group+0x2a>
  4053c0:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
  4053c4:	d001      	beq.n	4053ca <pio_configure_pin_group+0x2a>
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
				(ul_flags & PIO_PULLUP) ? 1 : 0);
		break;

	default:
		return 0;
  4053c6:	2000      	movs	r0, #0
	}

	return 1;
}
  4053c8:	bd70      	pop	{r4, r5, r6, pc}
	case PIO_TYPE_PIO_PERIPH_C:
		pio_set_peripheral(p_pio, PIO_PERIPH_C, ul_mask);
		pio_pull_up(p_pio, ul_mask, (ul_flags & PIO_PULLUP));
		break;
	case PIO_TYPE_PIO_PERIPH_D:
		pio_set_peripheral(p_pio, PIO_PERIPH_D, ul_mask);
  4053ca:	4619      	mov	r1, r3
  4053cc:	462a      	mov	r2, r5
  4053ce:	4b15      	ldr	r3, [pc, #84]	; (405424 <pio_configure_pin_group+0x84>)
  4053d0:	4798      	blx	r3
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
  4053d2:	07e0      	lsls	r0, r4, #31
		p_pio->PIO_PUER = ul_mask;
  4053d4:	bf4c      	ite	mi
  4053d6:	6675      	strmi	r5, [r6, #100]	; 0x64
	} else {
		p_pio->PIO_PUDR = ul_mask;
  4053d8:	6635      	strpl	r5, [r6, #96]	; 0x60

	default:
		return 0;
	}

	return 1;
  4053da:	2001      	movs	r0, #1
  4053dc:	bd70      	pop	{r4, r5, r6, pc}
 */
uint32_t pio_configure_pin_group(Pio *p_pio,
		uint32_t ul_mask, const uint32_t ul_flags)
{
	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  4053de:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
  4053e2:	d009      	beq.n	4053f8 <pio_configure_pin_group+0x58>
  4053e4:	f1b3 5f60 	cmp.w	r3, #939524096	; 0x38000000
  4053e8:	d006      	beq.n	4053f8 <pio_configure_pin_group+0x58>
  4053ea:	f1b3 5f20 	cmp.w	r3, #671088640	; 0x28000000
  4053ee:	d1ea      	bne.n	4053c6 <pio_configure_pin_group+0x26>
		pio_pull_up(p_pio, ul_mask, (ul_flags & PIO_PULLUP));
		break;
#endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, ul_mask, ul_flags);
  4053f0:	4b0d      	ldr	r3, [pc, #52]	; (405428 <pio_configure_pin_group+0x88>)
  4053f2:	4798      	blx	r3

	default:
		return 0;
	}

	return 1;
  4053f4:	2001      	movs	r0, #1
		break;
#endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, ul_mask, ul_flags);
		break;
  4053f6:	bd70      	pop	{r4, r5, r6, pc}
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
  4053f8:	07e1      	lsls	r1, r4, #31
	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, ul_mask,
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
				== PIO_TYPE_PIO_OUTPUT_1) ? 1 : 0,
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
  4053fa:	f004 0204 	and.w	r2, r4, #4
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_disable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
	p_pio->PIO_IDR = ul_mask;
  4053fe:	6475      	str	r5, [r6, #68]	; 0x44
		break;

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, ul_mask,
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
  405400:	f004 5360 	and.w	r3, r4, #939524096	; 0x38000000
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
		p_pio->PIO_PUER = ul_mask;
  405404:	bf4c      	ite	mi
  405406:	6675      	strmi	r5, [r6, #100]	; 0x64
	} else {
		p_pio->PIO_PUDR = ul_mask;
  405408:	6635      	strpl	r5, [r6, #96]	; 0x60
{
	pio_disable_interrupt(p_pio, ul_mask);
	pio_pull_up(p_pio, ul_mask, ul_pull_up_enable);

	/* Enable multi-drive if necessary */
	if (ul_multidrive_enable) {
  40540a:	b14a      	cbz	r2, 405420 <pio_configure_pin_group+0x80>
		p_pio->PIO_MDER = ul_mask;
  40540c:	6535      	str	r5, [r6, #80]	; 0x50
	} else {
		p_pio->PIO_MDDR = ul_mask;
	}

	/* Set default value */
	if (ul_default_level) {
  40540e:	f1b3 5f60 	cmp.w	r3, #939524096	; 0x38000000
		p_pio->PIO_SODR = ul_mask;
  405412:	bf0c      	ite	eq
  405414:	6335      	streq	r5, [r6, #48]	; 0x30
	} else {
		p_pio->PIO_CODR = ul_mask;
  405416:	6375      	strne	r5, [r6, #52]	; 0x34
	}

	/* Configure pin(s) as output(s) */
	p_pio->PIO_OER = ul_mask;
  405418:	6135      	str	r5, [r6, #16]
	p_pio->PIO_PER = ul_mask;
  40541a:	6035      	str	r5, [r6, #0]

	default:
		return 0;
	}

	return 1;
  40541c:	2001      	movs	r0, #1
  40541e:	bd70      	pop	{r4, r5, r6, pc}

	/* Enable multi-drive if necessary */
	if (ul_multidrive_enable) {
		p_pio->PIO_MDER = ul_mask;
	} else {
		p_pio->PIO_MDDR = ul_mask;
  405420:	6575      	str	r5, [r6, #84]	; 0x54
  405422:	e7f4      	b.n	40540e <pio_configure_pin_group+0x6e>
  405424:	00405191 	.word	0x00405191
  405428:	00405221 	.word	0x00405221

0040542c <pio_get_pin_group>:
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  40542c:	0940      	lsrs	r0, r0, #5
  40542e:	f500 1000 	add.w	r0, r0, #2097152	; 0x200000
  405432:	f200 7007 	addw	r0, r0, #1799	; 0x707
#endif
	return p_pio;
}
  405436:	0240      	lsls	r0, r0, #9
  405438:	4770      	bx	lr
  40543a:	bf00      	nop

0040543c <pio_get_pin_group_id>:
		ul_id = ID_PIOC;
	} else {
		ul_id = ID_PIOA + (ul_pin >> 5);
	}
#else
	ul_id = ID_PIOA + (ul_pin >> 5);
  40543c:	0940      	lsrs	r0, r0, #5
#endif
	return ul_id;
}
  40543e:	300b      	adds	r0, #11
  405440:	4770      	bx	lr
  405442:	bf00      	nop

00405444 <pio_get_pin_group_mask>:
 *
 * \return GPIO port pin mask.
 */
uint32_t pio_get_pin_group_mask(uint32_t ul_pin)
{
	uint32_t ul_mask = 1 << (ul_pin & 0x1F);
  405444:	2301      	movs	r3, #1
  405446:	f000 001f 	and.w	r0, r0, #31
	return ul_mask;
}
  40544a:	fa03 f000 	lsl.w	r0, r3, r0
  40544e:	4770      	bx	lr

00405450 <pio_handler_process>:
 *
 * \param p_pio PIO controller base address.
 * \param ul_id PIO controller ID.
 */
void pio_handler_process(Pio *p_pio, uint32_t ul_id)
{
  405450:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint32_t status;
	uint32_t i;

	/* Read PIO controller status */
	status = pio_get_interrupt_status(p_pio);
  405454:	4b17      	ldr	r3, [pc, #92]	; (4054b4 <pio_handler_process+0x64>)
 *
 * \param p_pio PIO controller base address.
 * \param ul_id PIO controller ID.
 */
void pio_handler_process(Pio *p_pio, uint32_t ul_id)
{
  405456:	4680      	mov	r8, r0
  405458:	460e      	mov	r6, r1
	uint32_t status;
	uint32_t i;

	/* Read PIO controller status */
	status = pio_get_interrupt_status(p_pio);
  40545a:	4798      	blx	r3
	status &= pio_get_interrupt_mask(p_pio);
  40545c:	4b16      	ldr	r3, [pc, #88]	; (4054b8 <pio_handler_process+0x68>)
{
	uint32_t status;
	uint32_t i;

	/* Read PIO controller status */
	status = pio_get_interrupt_status(p_pio);
  40545e:	4605      	mov	r5, r0
	status &= pio_get_interrupt_mask(p_pio);
  405460:	4640      	mov	r0, r8
  405462:	4798      	blx	r3

	/* Check pending events */
	if (status != 0) {
  405464:	4005      	ands	r5, r0
  405466:	d018      	beq.n	40549a <pio_handler_process+0x4a>
  405468:	4c14      	ldr	r4, [pc, #80]	; (4054bc <pio_handler_process+0x6c>)
  40546a:	f104 07b0 	add.w	r7, r4, #176	; 0xb0
  40546e:	e003      	b.n	405478 <pio_handler_process+0x28>
							gs_interrupt_sources[i].mask);
					status &= ~(gs_interrupt_sources[i].mask);
				}
			}
			i++;
			if (i >= MAX_INTERRUPT_SOURCES) {
  405470:	42bc      	cmp	r4, r7
  405472:	d012      	beq.n	40549a <pio_handler_process+0x4a>
  405474:	3410      	adds	r4, #16

	/* Check pending events */
	if (status != 0) {
		/* Find triggering source */
		i = 0;
		while (status != 0) {
  405476:	b185      	cbz	r5, 40549a <pio_handler_process+0x4a>
			/* Source is configured on the same controller */
			if (gs_interrupt_sources[i].id == ul_id) {
  405478:	f854 3c0c 	ldr.w	r3, [r4, #-12]
  40547c:	42b3      	cmp	r3, r6
  40547e:	d1f7      	bne.n	405470 <pio_handler_process+0x20>
				/* Source has PIOs whose statuses have changed */
				if ((status & gs_interrupt_sources[i].mask) != 0) {
  405480:	f854 1c08 	ldr.w	r1, [r4, #-8]
  405484:	4229      	tst	r1, r5
  405486:	d0f3      	beq.n	405470 <pio_handler_process+0x20>
					gs_interrupt_sources[i].handler(gs_interrupt_sources[i].id,
  405488:	6823      	ldr	r3, [r4, #0]
  40548a:	4630      	mov	r0, r6
  40548c:	4798      	blx	r3
							gs_interrupt_sources[i].mask);
					status &= ~(gs_interrupt_sources[i].mask);
  40548e:	f854 3c08 	ldr.w	r3, [r4, #-8]
				}
			}
			i++;
			if (i >= MAX_INTERRUPT_SOURCES) {
  405492:	42bc      	cmp	r4, r7
			if (gs_interrupt_sources[i].id == ul_id) {
				/* Source has PIOs whose statuses have changed */
				if ((status & gs_interrupt_sources[i].mask) != 0) {
					gs_interrupt_sources[i].handler(gs_interrupt_sources[i].id,
							gs_interrupt_sources[i].mask);
					status &= ~(gs_interrupt_sources[i].mask);
  405494:	ea25 0503 	bic.w	r5, r5, r3
				}
			}
			i++;
			if (i >= MAX_INTERRUPT_SOURCES) {
  405498:	d1ec      	bne.n	405474 <pio_handler_process+0x24>
		}
	}

	/* Check capture events */
#if (SAM3S || SAM4S || SAM4E)
	if (pio_capture_enable_flag) {
  40549a:	4b09      	ldr	r3, [pc, #36]	; (4054c0 <pio_handler_process+0x70>)
  40549c:	681b      	ldr	r3, [r3, #0]
  40549e:	b133      	cbz	r3, 4054ae <pio_handler_process+0x5e>
		if (pio_capture_handler) {
  4054a0:	4b08      	ldr	r3, [pc, #32]	; (4054c4 <pio_handler_process+0x74>)
  4054a2:	681b      	ldr	r3, [r3, #0]
  4054a4:	b10b      	cbz	r3, 4054aa <pio_handler_process+0x5a>
			pio_capture_handler(p_pio);
  4054a6:	4640      	mov	r0, r8
  4054a8:	4798      	blx	r3
  4054aa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4054ae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4054b2:	bf00      	nop
  4054b4:	00405285 	.word	0x00405285
  4054b8:	00405289 	.word	0x00405289
  4054bc:	200010a0 	.word	0x200010a0
  4054c0:	20002440 	.word	0x20002440
  4054c4:	20001090 	.word	0x20001090

004054c8 <pio_handler_set>:
 *
 * \return 0 if successful, 1 if the maximum number of sources has been defined.
 */
uint32_t pio_handler_set(Pio *p_pio, uint32_t ul_id, uint32_t ul_mask,
		uint32_t ul_attr, void (*p_handler) (uint32_t, uint32_t))
{
  4054c8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	struct s_interrupt_source *pSource;

	if (gs_ul_nb_sources >= MAX_INTERRUPT_SOURCES)
  4054cc:	4d0f      	ldr	r5, [pc, #60]	; (40550c <pio_handler_set+0x44>)
  4054ce:	682c      	ldr	r4, [r5, #0]
  4054d0:	2c0b      	cmp	r4, #11
 *
 * \return 0 if successful, 1 if the maximum number of sources has been defined.
 */
uint32_t pio_handler_set(Pio *p_pio, uint32_t ul_id, uint32_t ul_mask,
		uint32_t ul_attr, void (*p_handler) (uint32_t, uint32_t))
{
  4054d2:	468c      	mov	ip, r1
  4054d4:	4616      	mov	r6, r2
	struct s_interrupt_source *pSource;

	if (gs_ul_nb_sources >= MAX_INTERRUPT_SOURCES)
  4054d6:	d902      	bls.n	4054de <pio_handler_set+0x16>
		return 1;
  4054d8:	2001      	movs	r0, #1

	/* Configure interrupt mode */
	pio_configure_interrupt(p_pio, ul_mask, ul_attr);

	return 0;
}
  4054da:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

	if (gs_ul_nb_sources >= MAX_INTERRUPT_SOURCES)
		return 1;

	/* Define new source */
	pSource = &(gs_interrupt_sources[gs_ul_nb_sources]);
  4054de:	f8df 8030 	ldr.w	r8, [pc, #48]	; 405510 <pio_handler_set+0x48>
	pSource->attr = ul_attr;
	pSource->handler = p_handler;
	gs_ul_nb_sources++;

	/* Configure interrupt mode */
	pio_configure_interrupt(p_pio, ul_mask, ul_attr);
  4054e2:	f8df 9030 	ldr.w	r9, [pc, #48]	; 405514 <pio_handler_set+0x4c>

	if (gs_ul_nb_sources >= MAX_INTERRUPT_SOURCES)
		return 1;

	/* Define new source */
	pSource = &(gs_interrupt_sources[gs_ul_nb_sources]);
  4054e6:	ea4f 1e04 	mov.w	lr, r4, lsl #4
  4054ea:	eb08 070e 	add.w	r7, r8, lr
	pSource->id = ul_id;
  4054ee:	f848 c00e 	str.w	ip, [r8, lr]
	pSource->attr = ul_attr;
	pSource->handler = p_handler;
	gs_ul_nb_sources++;

	/* Configure interrupt mode */
	pio_configure_interrupt(p_pio, ul_mask, ul_attr);
  4054f2:	4611      	mov	r1, r2

	/* Define new source */
	pSource = &(gs_interrupt_sources[gs_ul_nb_sources]);
	pSource->id = ul_id;
	pSource->mask = ul_mask;
	pSource->attr = ul_attr;
  4054f4:	60bb      	str	r3, [r7, #8]
	pSource->handler = p_handler;
	gs_ul_nb_sources++;

	/* Configure interrupt mode */
	pio_configure_interrupt(p_pio, ul_mask, ul_attr);
  4054f6:	461a      	mov	r2, r3
	/* Define new source */
	pSource = &(gs_interrupt_sources[gs_ul_nb_sources]);
	pSource->id = ul_id;
	pSource->mask = ul_mask;
	pSource->attr = ul_attr;
	pSource->handler = p_handler;
  4054f8:	9b08      	ldr	r3, [sp, #32]
		return 1;

	/* Define new source */
	pSource = &(gs_interrupt_sources[gs_ul_nb_sources]);
	pSource->id = ul_id;
	pSource->mask = ul_mask;
  4054fa:	607e      	str	r6, [r7, #4]
	pSource->attr = ul_attr;
	pSource->handler = p_handler;
	gs_ul_nb_sources++;
  4054fc:	3401      	adds	r4, #1
	/* Define new source */
	pSource = &(gs_interrupt_sources[gs_ul_nb_sources]);
	pSource->id = ul_id;
	pSource->mask = ul_mask;
	pSource->attr = ul_attr;
	pSource->handler = p_handler;
  4054fe:	60fb      	str	r3, [r7, #12]
	gs_ul_nb_sources++;
  405500:	602c      	str	r4, [r5, #0]

	/* Configure interrupt mode */
	pio_configure_interrupt(p_pio, ul_mask, ul_attr);
  405502:	47c8      	blx	r9

	return 0;
  405504:	2000      	movs	r0, #0
  405506:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  40550a:	bf00      	nop
  40550c:	2000108c 	.word	0x2000108c
  405510:	20001094 	.word	0x20001094
  405514:	00405251 	.word	0x00405251

00405518 <PIOA_Handler>:
/**
 * \brief Parallel IO Controller A interrupt handler.
 * Redefined PIOA interrupt handler for NVIC interrupt table.
 */
void PIOA_Handler(void)
{
  405518:	b508      	push	{r3, lr}
	pio_handler_process(PIOA, ID_PIOA);
  40551a:	4802      	ldr	r0, [pc, #8]	; (405524 <PIOA_Handler+0xc>)
  40551c:	4b02      	ldr	r3, [pc, #8]	; (405528 <PIOA_Handler+0x10>)
  40551e:	210b      	movs	r1, #11
  405520:	4798      	blx	r3
  405522:	bd08      	pop	{r3, pc}
  405524:	400e0e00 	.word	0x400e0e00
  405528:	00405451 	.word	0x00405451

0040552c <PIOB_Handler>:
/**
 * \brief Parallel IO Controller B interrupt handler
 * Redefined PIOB interrupt handler for NVIC interrupt table.
 */
void PIOB_Handler(void)
{
  40552c:	b508      	push	{r3, lr}
    pio_handler_process(PIOB, ID_PIOB);
  40552e:	4802      	ldr	r0, [pc, #8]	; (405538 <PIOB_Handler+0xc>)
  405530:	4b02      	ldr	r3, [pc, #8]	; (40553c <PIOB_Handler+0x10>)
  405532:	210c      	movs	r1, #12
  405534:	4798      	blx	r3
  405536:	bd08      	pop	{r3, pc}
  405538:	400e1000 	.word	0x400e1000
  40553c:	00405451 	.word	0x00405451

00405540 <pmc_switch_mck_to_pllack>:
 */
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
  405540:	4914      	ldr	r1, [pc, #80]	; (405594 <pmc_switch_mck_to_pllack+0x54>)
  405542:	6b0b      	ldr	r3, [r1, #48]	; 0x30
  405544:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  405548:	4318      	orrs	r0, r3
  40554a:	6308      	str	r0, [r1, #48]	; 0x30
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  40554c:	6e8b      	ldr	r3, [r1, #104]	; 0x68
  40554e:	071b      	lsls	r3, r3, #28
  405550:	d407      	bmi.n	405562 <pmc_switch_mck_to_pllack+0x22>
  405552:	f44f 6300 	mov.w	r3, #2048	; 0x800
  405556:	e001      	b.n	40555c <pmc_switch_mck_to_pllack+0x1c>
			--ul_timeout) {
		if (ul_timeout == 0) {
  405558:	3b01      	subs	r3, #1
  40555a:	d016      	beq.n	40558a <pmc_switch_mck_to_pllack+0x4a>
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  40555c:	6e8a      	ldr	r2, [r1, #104]	; 0x68
  40555e:	0710      	lsls	r0, r2, #28
  405560:	d5fa      	bpl.n	405558 <pmc_switch_mck_to_pllack+0x18>
		if (ul_timeout == 0) {
			return 1;
		}
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
  405562:	490c      	ldr	r1, [pc, #48]	; (405594 <pmc_switch_mck_to_pllack+0x54>)
  405564:	6b0b      	ldr	r3, [r1, #48]	; 0x30
  405566:	f023 0303 	bic.w	r3, r3, #3
  40556a:	f043 0302 	orr.w	r3, r3, #2
  40556e:	630b      	str	r3, [r1, #48]	; 0x30
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  405570:	6e88      	ldr	r0, [r1, #104]	; 0x68
  405572:	f010 0008 	ands.w	r0, r0, #8
  405576:	d10a      	bne.n	40558e <pmc_switch_mck_to_pllack+0x4e>
  405578:	f44f 6300 	mov.w	r3, #2048	; 0x800
  40557c:	e001      	b.n	405582 <pmc_switch_mck_to_pllack+0x42>
			--ul_timeout) {
		if (ul_timeout == 0) {
  40557e:	3b01      	subs	r3, #1
  405580:	d003      	beq.n	40558a <pmc_switch_mck_to_pllack+0x4a>
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  405582:	6e8a      	ldr	r2, [r1, #104]	; 0x68
  405584:	0712      	lsls	r2, r2, #28
  405586:	d5fa      	bpl.n	40557e <pmc_switch_mck_to_pllack+0x3e>
  405588:	4770      	bx	lr

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
			--ul_timeout) {
		if (ul_timeout == 0) {
			return 1;
  40558a:	2001      	movs	r0, #1
  40558c:	4770      	bx	lr
		if (ul_timeout == 0) {
			return 1;
		}
	}

	return 0;
  40558e:	2000      	movs	r0, #0
}
  405590:	4770      	bx	lr
  405592:	bf00      	nop
  405594:	400e0400 	.word	0x400e0400

00405598 <pmc_switch_mainck_to_xtal>:
 */
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass,
		uint32_t ul_xtal_startup_time)
{
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
  405598:	b9c8      	cbnz	r0, 4055ce <pmc_switch_mainck_to_xtal+0x36>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  40559a:	4b11      	ldr	r3, [pc, #68]	; (4055e0 <pmc_switch_mainck_to_xtal+0x48>)
  40559c:	6a1a      	ldr	r2, [r3, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
  40559e:	f422 125c 	bic.w	r2, r2, #3604480	; 0x370000
  4055a2:	f022 0203 	bic.w	r2, r2, #3
				CKGR_MOR_MOSCXTST(ul_xtal_startup_time);
  4055a6:	0209      	lsls	r1, r1, #8
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
  4055a8:	f442 125c 	orr.w	r2, r2, #3604480	; 0x370000
				CKGR_MOR_MOSCXTST(ul_xtal_startup_time);
  4055ac:	b289      	uxth	r1, r1
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
  4055ae:	f042 0201 	orr.w	r2, r2, #1
  4055b2:	430a      	orrs	r2, r1
	if (ul_bypass) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  4055b4:	621a      	str	r2, [r3, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
				CKGR_MOR_MOSCXTST(ul_xtal_startup_time);
		/* Wait the Xtal to stabilize */
		while (!(PMC->PMC_SR & PMC_SR_MOSCXTS));
  4055b6:	4619      	mov	r1, r3
  4055b8:	6e8b      	ldr	r3, [r1, #104]	; 0x68
  4055ba:	4a09      	ldr	r2, [pc, #36]	; (4055e0 <pmc_switch_mainck_to_xtal+0x48>)
  4055bc:	07db      	lsls	r3, r3, #31
  4055be:	d5fb      	bpl.n	4055b8 <pmc_switch_mainck_to_xtal+0x20>

		PMC->CKGR_MOR |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCSEL;
  4055c0:	6a13      	ldr	r3, [r2, #32]
  4055c2:	f043 739b 	orr.w	r3, r3, #20316160	; 0x1360000
  4055c6:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  4055ca:	6213      	str	r3, [r2, #32]
  4055cc:	4770      	bx	lr
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass,
		uint32_t ul_xtal_startup_time)
{
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  4055ce:	4904      	ldr	r1, [pc, #16]	; (4055e0 <pmc_switch_mainck_to_xtal+0x48>)
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
  4055d0:	4a04      	ldr	r2, [pc, #16]	; (4055e4 <pmc_switch_mainck_to_xtal+0x4c>)
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass,
		uint32_t ul_xtal_startup_time)
{
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  4055d2:	6a08      	ldr	r0, [r1, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
  4055d4:	4b04      	ldr	r3, [pc, #16]	; (4055e8 <pmc_switch_mainck_to_xtal+0x50>)
  4055d6:	4002      	ands	r2, r0
  4055d8:	4313      	orrs	r3, r2
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass,
		uint32_t ul_xtal_startup_time)
{
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  4055da:	620b      	str	r3, [r1, #32]
  4055dc:	4770      	bx	lr
  4055de:	bf00      	nop
  4055e0:	400e0400 	.word	0x400e0400
  4055e4:	fec8fffc 	.word	0xfec8fffc
  4055e8:	01370002 	.word	0x01370002

004055ec <pmc_osc_is_ready_mainck>:
 * \retval 1 Xtal is ready.
 * \retval 0 Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_mainck(void)
{
	return PMC->PMC_SR & PMC_SR_MOSCSELS;
  4055ec:	4b02      	ldr	r3, [pc, #8]	; (4055f8 <pmc_osc_is_ready_mainck+0xc>)
  4055ee:	6e98      	ldr	r0, [r3, #104]	; 0x68
}
  4055f0:	f400 3080 	and.w	r0, r0, #65536	; 0x10000
  4055f4:	4770      	bx	lr
  4055f6:	bf00      	nop
  4055f8:	400e0400 	.word	0x400e0400

004055fc <pmc_disable_pllack>:
void pmc_disable_pllack(void)
{
#if (SAM4C || SAM4CM || SAM4CP || SAMG)
	PMC->CKGR_PLLAR = CKGR_PLLAR_MULA(0);
#else
	PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | CKGR_PLLAR_MULA(0);
  4055fc:	4b02      	ldr	r3, [pc, #8]	; (405608 <pmc_disable_pllack+0xc>)
  4055fe:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
  405602:	629a      	str	r2, [r3, #40]	; 0x28
  405604:	4770      	bx	lr
  405606:	bf00      	nop
  405608:	400e0400 	.word	0x400e0400

0040560c <pmc_is_locked_pllack>:
 * \retval 0 Not locked.
 * \retval 1 Locked.
 */
uint32_t pmc_is_locked_pllack(void)
{
	return (PMC->PMC_SR & PMC_SR_LOCKA);
  40560c:	4b02      	ldr	r3, [pc, #8]	; (405618 <pmc_is_locked_pllack+0xc>)
  40560e:	6e98      	ldr	r0, [r3, #104]	; 0x68
}
  405610:	f000 0002 	and.w	r0, r0, #2
  405614:	4770      	bx	lr
  405616:	bf00      	nop
  405618:	400e0400 	.word	0x400e0400

0040561c <pmc_enable_periph_clk>:
 * \retval 0 Success.
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_enable_periph_clk(uint32_t ul_id)
{
	if (ul_id > MAX_PERIPH_ID) {
  40561c:	2822      	cmp	r0, #34	; 0x22
  40561e:	d819      	bhi.n	405654 <pmc_enable_periph_clk+0x38>
		return 1;
	}

	if (ul_id < 32) {
  405620:	281f      	cmp	r0, #31
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
  405622:	4b0e      	ldr	r3, [pc, #56]	; (40565c <pmc_enable_periph_clk+0x40>)
{
	if (ul_id > MAX_PERIPH_ID) {
		return 1;
	}

	if (ul_id < 32) {
  405624:	d809      	bhi.n	40563a <pmc_enable_periph_clk+0x1e>
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
  405626:	2101      	movs	r1, #1
  405628:	699a      	ldr	r2, [r3, #24]
  40562a:	fa01 f000 	lsl.w	r0, r1, r0
  40562e:	4002      	ands	r2, r0
  405630:	4290      	cmp	r0, r2
  405632:	d011      	beq.n	405658 <pmc_enable_periph_clk+0x3c>
			PMC->PMC_PCER0 = 1 << ul_id;
  405634:	6118      	str	r0, [r3, #16]
			PMC->PMC_PCER1 = 1 << ul_id;
		}
#endif
	}

	return 0;
  405636:	2000      	movs	r0, #0
  405638:	4770      	bx	lr
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
			PMC->PMC_PCER0 = 1 << ul_id;
		}
#if (SAM3S || SAM3XA || SAM4S || SAM4E || SAM4C || SAM4CM || SAM4CP || SAMG55 || SAMV71 || SAMV70 || SAME70 || SAMS70)
	} else {
		ul_id -= 32;
  40563a:	3820      	subs	r0, #32
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) != (1u << ul_id)) {
  40563c:	2101      	movs	r1, #1
  40563e:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
  405642:	fa01 f000 	lsl.w	r0, r1, r0
  405646:	4002      	ands	r2, r0
  405648:	4290      	cmp	r0, r2
  40564a:	d005      	beq.n	405658 <pmc_enable_periph_clk+0x3c>
			PMC->PMC_PCER1 = 1 << ul_id;
  40564c:	f8c3 0100 	str.w	r0, [r3, #256]	; 0x100
		}
#endif
	}

	return 0;
  405650:	2000      	movs	r0, #0
  405652:	4770      	bx	lr
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_enable_periph_clk(uint32_t ul_id)
{
	if (ul_id > MAX_PERIPH_ID) {
		return 1;
  405654:	2001      	movs	r0, #1
  405656:	4770      	bx	lr
			PMC->PMC_PCER1 = 1 << ul_id;
		}
#endif
	}

	return 0;
  405658:	2000      	movs	r0, #0
}
  40565a:	4770      	bx	lr
  40565c:	400e0400 	.word	0x400e0400

00405660 <wdt_disable>:
/**
 * \brief Disable the watchdog timer.
 */
void wdt_disable(Wdt *p_wdt)
{
	p_wdt->WDT_MR = WDT_MR_WDDIS;
  405660:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  405664:	6043      	str	r3, [r0, #4]
  405666:	4770      	bx	lr

00405668 <wdt_get_status>:
 *
 * \return Bitmask of watchdog timer status.
 */
uint32_t wdt_get_status(Wdt *p_wdt)
{
	return p_wdt->WDT_SR;
  405668:	6880      	ldr	r0, [r0, #8]
}
  40566a:	4770      	bx	lr

0040566c <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
  40566c:	e7fe      	b.n	40566c <Dummy_Handler>
  40566e:	bf00      	nop

00405670 <Reset_Handler>:

	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc > pDest) {
  405670:	481c      	ldr	r0, [pc, #112]	; (4056e4 <Reset_Handler+0x74>)
  405672:	4b1d      	ldr	r3, [pc, #116]	; (4056e8 <Reset_Handler+0x78>)
  405674:	4298      	cmp	r0, r3
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
  405676:	b510      	push	{r4, lr}

	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc > pDest) {
  405678:	d925      	bls.n	4056c6 <Reset_Handler+0x56>
		for (; pDest < &_erelocate;) {
  40567a:	4a1c      	ldr	r2, [pc, #112]	; (4056ec <Reset_Handler+0x7c>)
  40567c:	4293      	cmp	r3, r2
  40567e:	d20a      	bcs.n	405696 <Reset_Handler+0x26>
  405680:	43d9      	mvns	r1, r3
  405682:	440a      	add	r2, r1
  405684:	f022 0403 	bic.w	r4, r2, #3
  405688:	3404      	adds	r4, #4
  40568a:	2200      	movs	r2, #0
			*pDest++ = *pSrc++;
  40568c:	5881      	ldr	r1, [r0, r2]
  40568e:	5099      	str	r1, [r3, r2]
  405690:	3204      	adds	r2, #4
	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc > pDest) {
		for (; pDest < &_erelocate;) {
  405692:	42a2      	cmp	r2, r4
  405694:	d1fa      	bne.n	40568c <Reset_Handler+0x1c>

    No Operation does nothing. This instruction can be used for code alignment purposes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
{
  __ASM volatile ("nop");
  405696:	bf00      	nop
		}
	}
	__NOP();

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
  405698:	4b15      	ldr	r3, [pc, #84]	; (4056f0 <Reset_Handler+0x80>)
  40569a:	4a16      	ldr	r2, [pc, #88]	; (4056f4 <Reset_Handler+0x84>)
  40569c:	4293      	cmp	r3, r2
  40569e:	d20a      	bcs.n	4056b6 <Reset_Handler+0x46>
  4056a0:	43d9      	mvns	r1, r3
  4056a2:	440a      	add	r2, r1
  4056a4:	f022 0103 	bic.w	r1, r2, #3
  4056a8:	4419      	add	r1, r3
		*pDest++ = 0;
  4056aa:	2200      	movs	r2, #0
  4056ac:	3b04      	subs	r3, #4
  4056ae:	f843 2f04 	str.w	r2, [r3, #4]!
		}
	}
	__NOP();

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
  4056b2:	428b      	cmp	r3, r1
  4056b4:	d1fb      	bne.n	4056ae <Reset_Handler+0x3e>
		*pDest++ = 0;
	}

	/* Set the vector table base address */
	pSrc = (uint32_t *) & _sfixed;
	SCB->VTOR = ((uint32_t) pSrc);
  4056b6:	4b10      	ldr	r3, [pc, #64]	; (4056f8 <Reset_Handler+0x88>)
  4056b8:	4a10      	ldr	r2, [pc, #64]	; (4056fc <Reset_Handler+0x8c>)
  4056ba:	609a      	str	r2, [r3, #8]

	/* Initialize the C library */
	__libc_init_array();
  4056bc:	4b10      	ldr	r3, [pc, #64]	; (405700 <Reset_Handler+0x90>)
  4056be:	4798      	blx	r3

	/* Branch to main function */
	main();
  4056c0:	4b10      	ldr	r3, [pc, #64]	; (405704 <Reset_Handler+0x94>)
  4056c2:	4798      	blx	r3
  4056c4:	e7fe      	b.n	4056c4 <Reset_Handler+0x54>

	if (pSrc > pDest) {
		for (; pDest < &_erelocate;) {
			*pDest++ = *pSrc++;
		}
	} else if (pSrc < pDest) {
  4056c6:	d2e6      	bcs.n	405696 <Reset_Handler+0x26>
		uint32_t nb_bytes = (uint32_t)&_erelocate - (uint32_t)&_srelocate;
  4056c8:	4908      	ldr	r1, [pc, #32]	; (4056ec <Reset_Handler+0x7c>)
		pSrc = (uint32_t*)((uint32_t)pSrc + nb_bytes) - 1;
  4056ca:	3804      	subs	r0, #4
	if (pSrc > pDest) {
		for (; pDest < &_erelocate;) {
			*pDest++ = *pSrc++;
		}
	} else if (pSrc < pDest) {
		uint32_t nb_bytes = (uint32_t)&_erelocate - (uint32_t)&_srelocate;
  4056cc:	1aca      	subs	r2, r1, r3
		pSrc = (uint32_t*)((uint32_t)pSrc + nb_bytes) - 1;
  4056ce:	4410      	add	r0, r2
		pDest = (uint32_t*)((uint32_t)pDest + nb_bytes) - 1;
		for (;nb_bytes;nb_bytes -= 4) {
  4056d0:	2a00      	cmp	r2, #0
  4056d2:	d0e0      	beq.n	405696 <Reset_Handler+0x26>
  4056d4:	460a      	mov	r2, r1
  4056d6:	1a54      	subs	r4, r2, r1
			*pDest-- = *pSrc--;
  4056d8:	5824      	ldr	r4, [r4, r0]
  4056da:	f842 4d04 	str.w	r4, [r2, #-4]!
		}
	} else if (pSrc < pDest) {
		uint32_t nb_bytes = (uint32_t)&_erelocate - (uint32_t)&_srelocate;
		pSrc = (uint32_t*)((uint32_t)pSrc + nb_bytes) - 1;
		pDest = (uint32_t*)((uint32_t)pDest + nb_bytes) - 1;
		for (;nb_bytes;nb_bytes -= 4) {
  4056de:	4293      	cmp	r3, r2
  4056e0:	d1f9      	bne.n	4056d6 <Reset_Handler+0x66>
  4056e2:	e7d8      	b.n	405696 <Reset_Handler+0x26>
  4056e4:	00407100 	.word	0x00407100
  4056e8:	20000000 	.word	0x20000000
  4056ec:	20000aec 	.word	0x20000aec
  4056f0:	20000aec 	.word	0x20000aec
  4056f4:	20002448 	.word	0x20002448
  4056f8:	e000ed00 	.word	0xe000ed00
  4056fc:	00400000 	.word	0x00400000
  405700:	00405e85 	.word	0x00405e85
  405704:	004058a5 	.word	0x004058a5

00405708 <SystemCoreClockUpdate>:
 * \brief Get Core Clock Frequency.
 */
void SystemCoreClockUpdate( void )
{
	/* Determine clock frequency according to clock register values */
	switch ( PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk ) {
  405708:	4b32      	ldr	r3, [pc, #200]	; (4057d4 <SystemCoreClockUpdate+0xcc>)
  40570a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  40570c:	f002 0203 	and.w	r2, r2, #3
  405710:	2a01      	cmp	r2, #1
  405712:	d03a      	beq.n	40578a <SystemCoreClockUpdate+0x82>
  405714:	d323      	bcc.n	40575e <SystemCoreClockUpdate+0x56>
		}
		break;
		
	case PMC_MCKR_CSS_PLLA_CLK:	/* PLLA clock */
	case PMC_MCKR_CSS_PLLB_CLK:	/* PLLB clock */
			if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL ) {
  405716:	6a1a      	ldr	r2, [r3, #32]
  405718:	01d2      	lsls	r2, r2, #7
  40571a:	d547      	bpl.n	4057ac <SystemCoreClockUpdate+0xa4>
				SystemCoreClock = CHIP_FREQ_XTAL;
  40571c:	4a2e      	ldr	r2, [pc, #184]	; (4057d8 <SystemCoreClockUpdate+0xd0>)
  40571e:	482f      	ldr	r0, [pc, #188]	; (4057dc <SystemCoreClockUpdate+0xd4>)
  405720:	6010      	str	r0, [r2, #0]
				default:
					break;
				}
			}
			
			if ( (uint32_t)(PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) ==
  405722:	4b2c      	ldr	r3, [pc, #176]	; (4057d4 <SystemCoreClockUpdate+0xcc>)
  405724:	6b19      	ldr	r1, [r3, #48]	; 0x30
  405726:	f001 0103 	and.w	r1, r1, #3
  40572a:	2902      	cmp	r1, #2
					PMC_MCKR_CSS_PLLA_CLK ) {
				SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk)
  40572c:	bf0b      	itete	eq
  40572e:	6a99      	ldreq	r1, [r3, #40]	; 0x28
						>> CKGR_PLLAR_MULA_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk)
						>> CKGR_PLLAR_DIVA_Pos));
			} else {
				SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk)
  405730:	6ad9      	ldrne	r1, [r3, #44]	; 0x2c
			
			if ( (uint32_t)(PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) ==
					PMC_MCKR_CSS_PLLA_CLK ) {
				SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk)
						>> CKGR_PLLAR_MULA_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk)
  405732:	6a9b      	ldreq	r3, [r3, #40]	; 0x28
						>> CKGR_PLLAR_DIVA_Pos));
			} else {
				SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk)
						>> CKGR_PLLBR_MULB_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_DIVB_Msk)
  405734:	6adb      	ldrne	r3, [r3, #44]	; 0x2c
						>> CKGR_PLLAR_MULA_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk)
						>> CKGR_PLLAR_DIVA_Pos));
			} else {
				SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk)
						>> CKGR_PLLBR_MULB_Pos) + 1U);
  405736:	f3c1 410a 	ubfx	r1, r1, #16, #11
				SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk)
						>> CKGR_PLLAR_MULA_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk)
						>> CKGR_PLLAR_DIVA_Pos));
			} else {
				SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk)
  40573a:	fb01 0000 	mla	r0, r1, r0, r0
						>> CKGR_PLLBR_MULB_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_DIVB_Msk)
						>> CKGR_PLLBR_DIVB_Pos));
  40573e:	b2db      	uxtb	r3, r3
				SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk)
						>> CKGR_PLLAR_DIVA_Pos));
			} else {
				SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk)
						>> CKGR_PLLBR_MULB_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_DIVB_Msk)
  405740:	fbb0 f0f3 	udiv	r0, r0, r3
		
	default:
		break;
	}

	if ( (PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3 ) {
  405744:	4b23      	ldr	r3, [pc, #140]	; (4057d4 <SystemCoreClockUpdate+0xcc>)
				SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk)
						>> CKGR_PLLAR_DIVA_Pos));
			} else {
				SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk)
						>> CKGR_PLLBR_MULB_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_DIVB_Msk)
  405746:	6010      	str	r0, [r2, #0]
		
	default:
		break;
	}

	if ( (PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3 ) {
  405748:	6b19      	ldr	r1, [r3, #48]	; 0x30
  40574a:	f001 0170 	and.w	r1, r1, #112	; 0x70
  40574e:	2970      	cmp	r1, #112	; 0x70
  405750:	d115      	bne.n	40577e <SystemCoreClockUpdate+0x76>
		SystemCoreClock /= 3U;
  405752:	4b23      	ldr	r3, [pc, #140]	; (4057e0 <SystemCoreClockUpdate+0xd8>)
  405754:	fba3 1000 	umull	r1, r0, r3, r0
  405758:	0840      	lsrs	r0, r0, #1
  40575a:	6010      	str	r0, [r2, #0]
  40575c:	4770      	bx	lr
void SystemCoreClockUpdate( void )
{
	/* Determine clock frequency according to clock register values */
	switch ( PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk ) {
	case PMC_MCKR_CSS_SLOW_CLK: /* Slow clock */
			if ( SUPC->SUPC_SR & SUPC_SR_OSCSEL ) {
  40575e:	4b21      	ldr	r3, [pc, #132]	; (4057e4 <SystemCoreClockUpdate+0xdc>)
				SystemCoreClock = CHIP_FREQ_XTAL_32K;
  405760:	4a1d      	ldr	r2, [pc, #116]	; (4057d8 <SystemCoreClockUpdate+0xd0>)
void SystemCoreClockUpdate( void )
{
	/* Determine clock frequency according to clock register values */
	switch ( PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk ) {
	case PMC_MCKR_CSS_SLOW_CLK: /* Slow clock */
			if ( SUPC->SUPC_SR & SUPC_SR_OSCSEL ) {
  405762:	695b      	ldr	r3, [r3, #20]
  405764:	061b      	lsls	r3, r3, #24
				SystemCoreClock = CHIP_FREQ_XTAL_32K;
  405766:	bf4c      	ite	mi
  405768:	f44f 4000 	movmi.w	r0, #32768	; 0x8000
			} else {
				SystemCoreClock = CHIP_FREQ_SLCK_RC;
  40576c:	f44f 40fa 	movpl.w	r0, #32000	; 0x7d00
  405770:	6010      	str	r0, [r2, #0]
		
	default:
		break;
	}

	if ( (PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3 ) {
  405772:	4b18      	ldr	r3, [pc, #96]	; (4057d4 <SystemCoreClockUpdate+0xcc>)
  405774:	6b19      	ldr	r1, [r3, #48]	; 0x30
  405776:	f001 0170 	and.w	r1, r1, #112	; 0x70
  40577a:	2970      	cmp	r1, #112	; 0x70
  40577c:	d0e9      	beq.n	405752 <SystemCoreClockUpdate+0x4a>
		SystemCoreClock /= 3U;
	} else {
		SystemCoreClock >>=
			((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >> PMC_MCKR_PRES_Pos);
  40577e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  405780:	f3c3 1302 	ubfx	r3, r3, #4, #3
	}

	if ( (PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3 ) {
		SystemCoreClock /= 3U;
	} else {
		SystemCoreClock >>=
  405784:	40d8      	lsrs	r0, r3
  405786:	6010      	str	r0, [r2, #0]
  405788:	4770      	bx	lr
				SystemCoreClock = CHIP_FREQ_SLCK_RC;
			}
		break;
		
	case PMC_MCKR_CSS_MAIN_CLK: /* Main clock */
		if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL ) {
  40578a:	6a1a      	ldr	r2, [r3, #32]
  40578c:	f012 7f80 	tst.w	r2, #16777216	; 0x1000000
			SystemCoreClock = CHIP_FREQ_XTAL;
  405790:	4a11      	ldr	r2, [pc, #68]	; (4057d8 <SystemCoreClockUpdate+0xd0>)
				SystemCoreClock = CHIP_FREQ_SLCK_RC;
			}
		break;
		
	case PMC_MCKR_CSS_MAIN_CLK: /* Main clock */
		if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL ) {
  405792:	d108      	bne.n	4057a6 <SystemCoreClockUpdate+0x9e>
			SystemCoreClock = CHIP_FREQ_XTAL;
		} else {
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  405794:	4814      	ldr	r0, [pc, #80]	; (4057e8 <SystemCoreClockUpdate+0xe0>)
  405796:	6010      	str	r0, [r2, #0]
			
			switch ( PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk ) {
  405798:	6a1b      	ldr	r3, [r3, #32]
  40579a:	f003 0370 	and.w	r3, r3, #112	; 0x70
  40579e:	2b10      	cmp	r3, #16
  4057a0:	d014      	beq.n	4057cc <SystemCoreClockUpdate+0xc4>
  4057a2:	2b20      	cmp	r3, #32
  4057a4:	d1e5      	bne.n	405772 <SystemCoreClockUpdate+0x6a>
			case CKGR_MOR_MOSCRCF_8_MHz:
				SystemCoreClock = CHIP_FREQ_MAINCK_RC_8MHZ;
			break;
			
			case CKGR_MOR_MOSCRCF_12_MHz:
				SystemCoreClock = CHIP_FREQ_MAINCK_RC_12MHZ;
  4057a6:	480d      	ldr	r0, [pc, #52]	; (4057dc <SystemCoreClockUpdate+0xd4>)
  4057a8:	6010      	str	r0, [r2, #0]
			break;
  4057aa:	e7e2      	b.n	405772 <SystemCoreClockUpdate+0x6a>
	case PMC_MCKR_CSS_PLLA_CLK:	/* PLLA clock */
	case PMC_MCKR_CSS_PLLB_CLK:	/* PLLB clock */
			if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL ) {
				SystemCoreClock = CHIP_FREQ_XTAL;
			} else {
				SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  4057ac:	4a0a      	ldr	r2, [pc, #40]	; (4057d8 <SystemCoreClockUpdate+0xd0>)
  4057ae:	480e      	ldr	r0, [pc, #56]	; (4057e8 <SystemCoreClockUpdate+0xe0>)
  4057b0:	6010      	str	r0, [r2, #0]
				
				switch ( PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk ) {
  4057b2:	6a1b      	ldr	r3, [r3, #32]
  4057b4:	f003 0370 	and.w	r3, r3, #112	; 0x70
  4057b8:	2b10      	cmp	r3, #16
  4057ba:	d004      	beq.n	4057c6 <SystemCoreClockUpdate+0xbe>
  4057bc:	2b20      	cmp	r3, #32
  4057be:	d1b0      	bne.n	405722 <SystemCoreClockUpdate+0x1a>
				case CKGR_MOR_MOSCRCF_8_MHz:
					SystemCoreClock = CHIP_FREQ_MAINCK_RC_8MHZ;
					break;
				
				case CKGR_MOR_MOSCRCF_12_MHz:
					SystemCoreClock = CHIP_FREQ_MAINCK_RC_12MHZ;
  4057c0:	4806      	ldr	r0, [pc, #24]	; (4057dc <SystemCoreClockUpdate+0xd4>)
  4057c2:	6010      	str	r0, [r2, #0]
					break;
  4057c4:	e7ad      	b.n	405722 <SystemCoreClockUpdate+0x1a>
				case CKGR_MOR_MOSCRCF_4_MHz:
					SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
					break;
				
				case CKGR_MOR_MOSCRCF_8_MHz:
					SystemCoreClock = CHIP_FREQ_MAINCK_RC_8MHZ;
  4057c6:	4809      	ldr	r0, [pc, #36]	; (4057ec <SystemCoreClockUpdate+0xe4>)
  4057c8:	6010      	str	r0, [r2, #0]
					break;
  4057ca:	e7aa      	b.n	405722 <SystemCoreClockUpdate+0x1a>
			case CKGR_MOR_MOSCRCF_4_MHz:
				SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
			break;
			
			case CKGR_MOR_MOSCRCF_8_MHz:
				SystemCoreClock = CHIP_FREQ_MAINCK_RC_8MHZ;
  4057cc:	4807      	ldr	r0, [pc, #28]	; (4057ec <SystemCoreClockUpdate+0xe4>)
  4057ce:	6010      	str	r0, [r2, #0]
			break;
  4057d0:	e7cf      	b.n	405772 <SystemCoreClockUpdate+0x6a>
  4057d2:	bf00      	nop
  4057d4:	400e0400 	.word	0x400e0400
  4057d8:	200002ac 	.word	0x200002ac
  4057dc:	00b71b00 	.word	0x00b71b00
  4057e0:	aaaaaaab 	.word	0xaaaaaaab
  4057e4:	400e1410 	.word	0x400e1410
  4057e8:	003d0900 	.word	0x003d0900
  4057ec:	007a1200 	.word	0x007a1200

004057f0 <system_init_flash>:
 */
void system_init_flash( uint32_t ul_clk )
{
  /* Set FWS for embedded Flash access according to operating frequency */
#if !defined(ID_EFC1)
	if ( ul_clk < CHIP_FREQ_FWS_0 ) {
  4057f0:	4b0f      	ldr	r3, [pc, #60]	; (405830 <system_init_flash+0x40>)
  4057f2:	4298      	cmp	r0, r3
  4057f4:	d912      	bls.n	40581c <system_init_flash+0x2c>
		EFC0->EEFC_FMR = EEFC_FMR_FWS(0)|EEFC_FMR_CLOE;
	} else {
		if ( ul_clk < CHIP_FREQ_FWS_1 ) {
  4057f6:	4b0f      	ldr	r3, [pc, #60]	; (405834 <system_init_flash+0x44>)
  4057f8:	4298      	cmp	r0, r3
  4057fa:	d90b      	bls.n	405814 <system_init_flash+0x24>
			EFC0->EEFC_FMR = EEFC_FMR_FWS(1)|EEFC_FMR_CLOE;
		} else {
			if ( ul_clk < CHIP_FREQ_FWS_2 ) {
  4057fc:	4b0e      	ldr	r3, [pc, #56]	; (405838 <system_init_flash+0x48>)
  4057fe:	4298      	cmp	r0, r3
  405800:	d911      	bls.n	405826 <system_init_flash+0x36>
				EFC0->EEFC_FMR = EEFC_FMR_FWS(2)|EEFC_FMR_CLOE;
			} else {
				if ( ul_clk < CHIP_FREQ_FWS_3 ) {
					EFC0->EEFC_FMR = EEFC_FMR_FWS(3)|EEFC_FMR_CLOE;
				} else {
					if ( ul_clk < CHIP_FREQ_FWS_4 ) {
  405802:	4b0e      	ldr	r3, [pc, #56]	; (40583c <system_init_flash+0x4c>)
  405804:	4298      	cmp	r0, r3
					EFC0->EEFC_FMR = EEFC_FMR_FWS(4)|EEFC_FMR_CLOE;
  405806:	4b0e      	ldr	r3, [pc, #56]	; (405840 <system_init_flash+0x50>)
					} else {
					EFC0->EEFC_FMR = EEFC_FMR_FWS(5)|EEFC_FMR_CLOE;
  405808:	bf8c      	ite	hi
  40580a:	4a0e      	ldrhi	r2, [pc, #56]	; (405844 <system_init_flash+0x54>)
			} else {
				if ( ul_clk < CHIP_FREQ_FWS_3 ) {
					EFC0->EEFC_FMR = EEFC_FMR_FWS(3)|EEFC_FMR_CLOE;
				} else {
					if ( ul_clk < CHIP_FREQ_FWS_4 ) {
					EFC0->EEFC_FMR = EEFC_FMR_FWS(4)|EEFC_FMR_CLOE;
  40580c:	f04f 2204 	movls.w	r2, #67109888	; 0x4000400
					} else {
					EFC0->EEFC_FMR = EEFC_FMR_FWS(5)|EEFC_FMR_CLOE;
  405810:	601a      	str	r2, [r3, #0]
  405812:	4770      	bx	lr
#if !defined(ID_EFC1)
	if ( ul_clk < CHIP_FREQ_FWS_0 ) {
		EFC0->EEFC_FMR = EEFC_FMR_FWS(0)|EEFC_FMR_CLOE;
	} else {
		if ( ul_clk < CHIP_FREQ_FWS_1 ) {
			EFC0->EEFC_FMR = EEFC_FMR_FWS(1)|EEFC_FMR_CLOE;
  405814:	4b0a      	ldr	r3, [pc, #40]	; (405840 <system_init_flash+0x50>)
  405816:	4a0c      	ldr	r2, [pc, #48]	; (405848 <system_init_flash+0x58>)
  405818:	601a      	str	r2, [r3, #0]
  40581a:	4770      	bx	lr
void system_init_flash( uint32_t ul_clk )
{
  /* Set FWS for embedded Flash access according to operating frequency */
#if !defined(ID_EFC1)
	if ( ul_clk < CHIP_FREQ_FWS_0 ) {
		EFC0->EEFC_FMR = EEFC_FMR_FWS(0)|EEFC_FMR_CLOE;
  40581c:	4b08      	ldr	r3, [pc, #32]	; (405840 <system_init_flash+0x50>)
  40581e:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
  405822:	601a      	str	r2, [r3, #0]
  405824:	4770      	bx	lr
	} else {
		if ( ul_clk < CHIP_FREQ_FWS_1 ) {
			EFC0->EEFC_FMR = EEFC_FMR_FWS(1)|EEFC_FMR_CLOE;
		} else {
			if ( ul_clk < CHIP_FREQ_FWS_2 ) {
				EFC0->EEFC_FMR = EEFC_FMR_FWS(2)|EEFC_FMR_CLOE;
  405826:	4b06      	ldr	r3, [pc, #24]	; (405840 <system_init_flash+0x50>)
  405828:	4a08      	ldr	r2, [pc, #32]	; (40584c <system_init_flash+0x5c>)
  40582a:	601a      	str	r2, [r3, #0]
  40582c:	4770      	bx	lr
  40582e:	bf00      	nop
  405830:	01ba813f 	.word	0x01ba813f
  405834:	0375027f 	.word	0x0375027f
  405838:	053ec5ff 	.word	0x053ec5ff
  40583c:	07270dff 	.word	0x07270dff
  405840:	400e0a00 	.word	0x400e0a00
  405844:	04000500 	.word	0x04000500
  405848:	04000100 	.word	0x04000100
  40584c:	04000200 	.word	0x04000200

00405850 <_sbrk>:
{
	static unsigned char *heap = NULL;
	unsigned char *prev_heap;
	int ramend = (int)&__ram_end__;

	if (heap == NULL) {
  405850:	4a07      	ldr	r2, [pc, #28]	; (405870 <_sbrk+0x20>)

extern caddr_t _sbrk(int incr)
{
	static unsigned char *heap = NULL;
	unsigned char *prev_heap;
	int ramend = (int)&__ram_end__;
  405852:	4908      	ldr	r1, [pc, #32]	; (405874 <_sbrk+0x24>)

	if (heap == NULL) {
  405854:	6813      	ldr	r3, [r2, #0]
  405856:	b13b      	cbz	r3, 405868 <_sbrk+0x18>
		heap = (unsigned char *)&_end;
	}
	prev_heap = heap;

	if (((int)prev_heap + incr) > ramend) {
  405858:	4418      	add	r0, r3
  40585a:	4281      	cmp	r1, r0
		return (caddr_t) -1;	
	}

	heap += incr;
  40585c:	bfa6      	itte	ge
  40585e:	6010      	strge	r0, [r2, #0]

	return (caddr_t) prev_heap;
  405860:	4618      	movge	r0, r3
		heap = (unsigned char *)&_end;
	}
	prev_heap = heap;

	if (((int)prev_heap + incr) > ramend) {
		return (caddr_t) -1;	
  405862:	f04f 30ff 	movlt.w	r0, #4294967295
	}

	heap += incr;

	return (caddr_t) prev_heap;
}
  405866:	4770      	bx	lr
	static unsigned char *heap = NULL;
	unsigned char *prev_heap;
	int ramend = (int)&__ram_end__;

	if (heap == NULL) {
		heap = (unsigned char *)&_end;
  405868:	4b03      	ldr	r3, [pc, #12]	; (405878 <_sbrk+0x28>)
  40586a:	6013      	str	r3, [r2, #0]
  40586c:	e7f4      	b.n	405858 <_sbrk+0x8>
  40586e:	bf00      	nop
  405870:	20001154 	.word	0x20001154
  405874:	2000fffc 	.word	0x2000fffc
  405878:	20005448 	.word	0x20005448

0040587c <HardFault_Handler>:
extern drv_uart_config_t usart1Config;
extern brainSettings_t brainSettings; 
volatile unsigned long sgSysTickCount = 0;

void HardFault_Handler()
{
  40587c:	e7fe      	b.n	40587c <HardFault_Handler>
  40587e:	bf00      	nop

00405880 <MemManage_Handler>:
	while(1); 
}
void MemManage_Handler()
{
  405880:	e7fe      	b.n	405880 <MemManage_Handler>
  405882:	bf00      	nop

00405884 <BusFault_Handler>:
	while(1); 
}
void BusFault_Handler()
{
  405884:	e7fe      	b.n	405884 <BusFault_Handler>
  405886:	bf00      	nop

00405888 <UsageFault_Handler>:
	while(1); 
}
void UsageFault_Handler()
{
  405888:	e7fe      	b.n	405888 <UsageFault_Handler>
  40588a:	bf00      	nop

0040588c <SysTick_Handler>:

/**
 * \brief Handler for System Tick interrupt.
 */
void SysTick_Handler(void)
{
  40588c:	b508      	push	{r3, lr}
	sgSysTickCount++;
  40588e:	4b03      	ldr	r3, [pc, #12]	; (40589c <SysTick_Handler+0x10>)
	xPortSysTickHandler();
  405890:	4a03      	ldr	r2, [pc, #12]	; (4058a0 <SysTick_Handler+0x14>)
/**
 * \brief Handler for System Tick interrupt.
 */
void SysTick_Handler(void)
{
	sgSysTickCount++;
  405892:	6819      	ldr	r1, [r3, #0]
  405894:	3101      	adds	r1, #1
  405896:	6019      	str	r1, [r3, #0]
	xPortSysTickHandler();
  405898:	4790      	blx	r2
  40589a:	bd08      	pop	{r3, pc}
  40589c:	20001158 	.word	0x20001158
  4058a0:	00403ec9 	.word	0x00403ec9

004058a4 <main>:
}


int main (void)
{
  4058a4:	b508      	push	{r3, lr}
	irq_initialize_vectors();
	cpu_irq_enable();
  4058a6:	4b07      	ldr	r3, [pc, #28]	; (4058c4 <main+0x20>)
  4058a8:	2201      	movs	r2, #1
  4058aa:	701a      	strb	r2, [r3, #0]
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
  4058ac:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
  4058b0:	b662      	cpsie	i
	//Initialize system clock and peripherals
	sysclk_init();
  4058b2:	4b05      	ldr	r3, [pc, #20]	; (4058c8 <main+0x24>)
  4058b4:	4c05      	ldr	r4, [pc, #20]	; (4058cc <main+0x28>)
  4058b6:	4798      	blx	r3
	#ifdef COMPILE_AS_BOOTLOADER
	runBootloader(); 
  4058b8:	4b05      	ldr	r3, [pc, #20]	; (4058d0 <main+0x2c>)
  4058ba:	4798      	blx	r3
	#endif
	//we should never get here. 
	/*	Debug code */
	while (1) 
	{		
		delay_ms(1000);
  4058bc:	4805      	ldr	r0, [pc, #20]	; (4058d4 <main+0x30>)
  4058be:	47a0      	blx	r4
  4058c0:	e7fc      	b.n	4058bc <main+0x18>
  4058c2:	bf00      	nop
  4058c4:	200002a8 	.word	0x200002a8
  4058c8:	004050a9 	.word	0x004050a9
  4058cc:	20000085 	.word	0x20000085
  4058d0:	00400c25 	.word	0x00400c25
  4058d4:	0082ca25 	.word	0x0082ca25

004058d8 <__aeabi_uldivmod>:
  4058d8:	b94b      	cbnz	r3, 4058ee <__aeabi_uldivmod+0x16>
  4058da:	b942      	cbnz	r2, 4058ee <__aeabi_uldivmod+0x16>
  4058dc:	2900      	cmp	r1, #0
  4058de:	bf08      	it	eq
  4058e0:	2800      	cmpeq	r0, #0
  4058e2:	d002      	beq.n	4058ea <__aeabi_uldivmod+0x12>
  4058e4:	f04f 31ff 	mov.w	r1, #4294967295
  4058e8:	4608      	mov	r0, r1
  4058ea:	f000 b83b 	b.w	405964 <__aeabi_idiv0>
  4058ee:	b082      	sub	sp, #8
  4058f0:	46ec      	mov	ip, sp
  4058f2:	e92d 5000 	stmdb	sp!, {ip, lr}
  4058f6:	f000 f81d 	bl	405934 <__gnu_uldivmod_helper>
  4058fa:	f8dd e004 	ldr.w	lr, [sp, #4]
  4058fe:	b002      	add	sp, #8
  405900:	bc0c      	pop	{r2, r3}
  405902:	4770      	bx	lr

00405904 <__gnu_ldivmod_helper>:
  405904:	e92d 4370 	stmdb	sp!, {r4, r5, r6, r8, r9, lr}
  405908:	9e06      	ldr	r6, [sp, #24]
  40590a:	4614      	mov	r4, r2
  40590c:	461d      	mov	r5, r3
  40590e:	4680      	mov	r8, r0
  405910:	4689      	mov	r9, r1
  405912:	f000 f829 	bl	405968 <__divdi3>
  405916:	fb04 f301 	mul.w	r3, r4, r1
  40591a:	fb00 3305 	mla	r3, r0, r5, r3
  40591e:	fba4 4500 	umull	r4, r5, r4, r0
  405922:	441d      	add	r5, r3
  405924:	ebb8 0404 	subs.w	r4, r8, r4
  405928:	eb69 0505 	sbc.w	r5, r9, r5
  40592c:	e9c6 4500 	strd	r4, r5, [r6]
  405930:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}

00405934 <__gnu_uldivmod_helper>:
  405934:	e92d 4370 	stmdb	sp!, {r4, r5, r6, r8, r9, lr}
  405938:	9e06      	ldr	r6, [sp, #24]
  40593a:	4614      	mov	r4, r2
  40593c:	4680      	mov	r8, r0
  40593e:	4689      	mov	r9, r1
  405940:	461d      	mov	r5, r3
  405942:	f000 f95d 	bl	405c00 <__udivdi3>
  405946:	fb00 f505 	mul.w	r5, r0, r5
  40594a:	fb04 5301 	mla	r3, r4, r1, r5
  40594e:	fba0 4504 	umull	r4, r5, r0, r4
  405952:	441d      	add	r5, r3
  405954:	ebb8 0404 	subs.w	r4, r8, r4
  405958:	eb69 0505 	sbc.w	r5, r9, r5
  40595c:	e9c6 4500 	strd	r4, r5, [r6]
  405960:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}

00405964 <__aeabi_idiv0>:
  405964:	4770      	bx	lr
  405966:	bf00      	nop

00405968 <__divdi3>:
  405968:	2900      	cmp	r1, #0
  40596a:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  40596e:	f2c0 809f 	blt.w	405ab0 <__divdi3+0x148>
  405972:	2400      	movs	r4, #0
  405974:	2b00      	cmp	r3, #0
  405976:	f2c0 8096 	blt.w	405aa6 <__divdi3+0x13e>
  40597a:	4615      	mov	r5, r2
  40597c:	4606      	mov	r6, r0
  40597e:	460f      	mov	r7, r1
  405980:	2b00      	cmp	r3, #0
  405982:	d13e      	bne.n	405a02 <__divdi3+0x9a>
  405984:	428a      	cmp	r2, r1
  405986:	d957      	bls.n	405a38 <__divdi3+0xd0>
  405988:	fab2 f382 	clz	r3, r2
  40598c:	b14b      	cbz	r3, 4059a2 <__divdi3+0x3a>
  40598e:	f1c3 0220 	rsb	r2, r3, #32
  405992:	fa01 f703 	lsl.w	r7, r1, r3
  405996:	fa20 f202 	lsr.w	r2, r0, r2
  40599a:	409d      	lsls	r5, r3
  40599c:	4317      	orrs	r7, r2
  40599e:	fa00 f603 	lsl.w	r6, r0, r3
  4059a2:	0c29      	lsrs	r1, r5, #16
  4059a4:	fbb7 f2f1 	udiv	r2, r7, r1
  4059a8:	0c33      	lsrs	r3, r6, #16
  4059aa:	fb01 7c12 	mls	ip, r1, r2, r7
  4059ae:	b2a8      	uxth	r0, r5
  4059b0:	ea43 470c 	orr.w	r7, r3, ip, lsl #16
  4059b4:	fb00 f302 	mul.w	r3, r0, r2
  4059b8:	42bb      	cmp	r3, r7
  4059ba:	d909      	bls.n	4059d0 <__divdi3+0x68>
  4059bc:	197f      	adds	r7, r7, r5
  4059be:	f102 3cff 	add.w	ip, r2, #4294967295
  4059c2:	f080 8101 	bcs.w	405bc8 <__divdi3+0x260>
  4059c6:	42bb      	cmp	r3, r7
  4059c8:	f240 80fe 	bls.w	405bc8 <__divdi3+0x260>
  4059cc:	3a02      	subs	r2, #2
  4059ce:	442f      	add	r7, r5
  4059d0:	1aff      	subs	r7, r7, r3
  4059d2:	fbb7 f3f1 	udiv	r3, r7, r1
  4059d6:	b2b6      	uxth	r6, r6
  4059d8:	fb01 7113 	mls	r1, r1, r3, r7
  4059dc:	ea46 4101 	orr.w	r1, r6, r1, lsl #16
  4059e0:	fb00 f003 	mul.w	r0, r0, r3
  4059e4:	4288      	cmp	r0, r1
  4059e6:	d908      	bls.n	4059fa <__divdi3+0x92>
  4059e8:	1949      	adds	r1, r1, r5
  4059ea:	f103 37ff 	add.w	r7, r3, #4294967295
  4059ee:	f080 80ed 	bcs.w	405bcc <__divdi3+0x264>
  4059f2:	4288      	cmp	r0, r1
  4059f4:	f240 80ea 	bls.w	405bcc <__divdi3+0x264>
  4059f8:	3b02      	subs	r3, #2
  4059fa:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
  4059fe:	2300      	movs	r3, #0
  405a00:	e003      	b.n	405a0a <__divdi3+0xa2>
  405a02:	428b      	cmp	r3, r1
  405a04:	d90a      	bls.n	405a1c <__divdi3+0xb4>
  405a06:	2300      	movs	r3, #0
  405a08:	461a      	mov	r2, r3
  405a0a:	4610      	mov	r0, r2
  405a0c:	4619      	mov	r1, r3
  405a0e:	b114      	cbz	r4, 405a16 <__divdi3+0xae>
  405a10:	4240      	negs	r0, r0
  405a12:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  405a16:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  405a1a:	4770      	bx	lr
  405a1c:	fab3 f883 	clz	r8, r3
  405a20:	f1b8 0f00 	cmp.w	r8, #0
  405a24:	f040 8084 	bne.w	405b30 <__divdi3+0x1c8>
  405a28:	428b      	cmp	r3, r1
  405a2a:	d302      	bcc.n	405a32 <__divdi3+0xca>
  405a2c:	4282      	cmp	r2, r0
  405a2e:	f200 80de 	bhi.w	405bee <__divdi3+0x286>
  405a32:	2300      	movs	r3, #0
  405a34:	2201      	movs	r2, #1
  405a36:	e7e8      	b.n	405a0a <__divdi3+0xa2>
  405a38:	b912      	cbnz	r2, 405a40 <__divdi3+0xd8>
  405a3a:	2301      	movs	r3, #1
  405a3c:	fbb3 f5f2 	udiv	r5, r3, r2
  405a40:	fab5 f285 	clz	r2, r5
  405a44:	2a00      	cmp	r2, #0
  405a46:	d139      	bne.n	405abc <__divdi3+0x154>
  405a48:	1b7f      	subs	r7, r7, r5
  405a4a:	0c28      	lsrs	r0, r5, #16
  405a4c:	fa1f fc85 	uxth.w	ip, r5
  405a50:	2301      	movs	r3, #1
  405a52:	fbb7 f1f0 	udiv	r1, r7, r0
  405a56:	0c32      	lsrs	r2, r6, #16
  405a58:	fb00 7711 	mls	r7, r0, r1, r7
  405a5c:	ea42 4707 	orr.w	r7, r2, r7, lsl #16
  405a60:	fb0c f201 	mul.w	r2, ip, r1
  405a64:	42ba      	cmp	r2, r7
  405a66:	d907      	bls.n	405a78 <__divdi3+0x110>
  405a68:	197f      	adds	r7, r7, r5
  405a6a:	f101 38ff 	add.w	r8, r1, #4294967295
  405a6e:	d202      	bcs.n	405a76 <__divdi3+0x10e>
  405a70:	42ba      	cmp	r2, r7
  405a72:	f200 80c1 	bhi.w	405bf8 <__divdi3+0x290>
  405a76:	4641      	mov	r1, r8
  405a78:	1abf      	subs	r7, r7, r2
  405a7a:	fbb7 f2f0 	udiv	r2, r7, r0
  405a7e:	b2b6      	uxth	r6, r6
  405a80:	fb00 7012 	mls	r0, r0, r2, r7
  405a84:	ea46 4000 	orr.w	r0, r6, r0, lsl #16
  405a88:	fb0c fc02 	mul.w	ip, ip, r2
  405a8c:	4584      	cmp	ip, r0
  405a8e:	d907      	bls.n	405aa0 <__divdi3+0x138>
  405a90:	1940      	adds	r0, r0, r5
  405a92:	f102 37ff 	add.w	r7, r2, #4294967295
  405a96:	d202      	bcs.n	405a9e <__divdi3+0x136>
  405a98:	4584      	cmp	ip, r0
  405a9a:	f200 80ab 	bhi.w	405bf4 <__divdi3+0x28c>
  405a9e:	463a      	mov	r2, r7
  405aa0:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
  405aa4:	e7b1      	b.n	405a0a <__divdi3+0xa2>
  405aa6:	43e4      	mvns	r4, r4
  405aa8:	4252      	negs	r2, r2
  405aaa:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
  405aae:	e764      	b.n	40597a <__divdi3+0x12>
  405ab0:	4240      	negs	r0, r0
  405ab2:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  405ab6:	f04f 34ff 	mov.w	r4, #4294967295
  405aba:	e75b      	b.n	405974 <__divdi3+0xc>
  405abc:	4095      	lsls	r5, r2
  405abe:	f1c2 0320 	rsb	r3, r2, #32
  405ac2:	fa27 f103 	lsr.w	r1, r7, r3
  405ac6:	0c28      	lsrs	r0, r5, #16
  405ac8:	fa26 f303 	lsr.w	r3, r6, r3
  405acc:	4097      	lsls	r7, r2
  405ace:	fbb1 f8f0 	udiv	r8, r1, r0
  405ad2:	431f      	orrs	r7, r3
  405ad4:	0c3b      	lsrs	r3, r7, #16
  405ad6:	fb00 1118 	mls	r1, r0, r8, r1
  405ada:	fa1f fc85 	uxth.w	ip, r5
  405ade:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
  405ae2:	fb0c f308 	mul.w	r3, ip, r8
  405ae6:	428b      	cmp	r3, r1
  405ae8:	fa06 f602 	lsl.w	r6, r6, r2
  405aec:	d908      	bls.n	405b00 <__divdi3+0x198>
  405aee:	1949      	adds	r1, r1, r5
  405af0:	f108 32ff 	add.w	r2, r8, #4294967295
  405af4:	d279      	bcs.n	405bea <__divdi3+0x282>
  405af6:	428b      	cmp	r3, r1
  405af8:	d977      	bls.n	405bea <__divdi3+0x282>
  405afa:	f1a8 0802 	sub.w	r8, r8, #2
  405afe:	4429      	add	r1, r5
  405b00:	1ac9      	subs	r1, r1, r3
  405b02:	fbb1 f3f0 	udiv	r3, r1, r0
  405b06:	b2bf      	uxth	r7, r7
  405b08:	fb00 1113 	mls	r1, r0, r3, r1
  405b0c:	ea47 4701 	orr.w	r7, r7, r1, lsl #16
  405b10:	fb0c f203 	mul.w	r2, ip, r3
  405b14:	42ba      	cmp	r2, r7
  405b16:	d907      	bls.n	405b28 <__divdi3+0x1c0>
  405b18:	197f      	adds	r7, r7, r5
  405b1a:	f103 31ff 	add.w	r1, r3, #4294967295
  405b1e:	d260      	bcs.n	405be2 <__divdi3+0x27a>
  405b20:	42ba      	cmp	r2, r7
  405b22:	d95e      	bls.n	405be2 <__divdi3+0x27a>
  405b24:	3b02      	subs	r3, #2
  405b26:	442f      	add	r7, r5
  405b28:	1abf      	subs	r7, r7, r2
  405b2a:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
  405b2e:	e790      	b.n	405a52 <__divdi3+0xea>
  405b30:	f1c8 0220 	rsb	r2, r8, #32
  405b34:	fa03 fc08 	lsl.w	ip, r3, r8
  405b38:	fa25 f302 	lsr.w	r3, r5, r2
  405b3c:	ea43 0c0c 	orr.w	ip, r3, ip
  405b40:	ea4f 491c 	mov.w	r9, ip, lsr #16
  405b44:	fa21 f302 	lsr.w	r3, r1, r2
  405b48:	fa01 f708 	lsl.w	r7, r1, r8
  405b4c:	fa20 f202 	lsr.w	r2, r0, r2
  405b50:	fbb3 f1f9 	udiv	r1, r3, r9
  405b54:	4317      	orrs	r7, r2
  405b56:	fb09 3311 	mls	r3, r9, r1, r3
  405b5a:	0c3a      	lsrs	r2, r7, #16
  405b5c:	fa1f fb8c 	uxth.w	fp, ip
  405b60:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
  405b64:	fb0b fa01 	mul.w	sl, fp, r1
  405b68:	459a      	cmp	sl, r3
  405b6a:	fa05 f008 	lsl.w	r0, r5, r8
  405b6e:	d908      	bls.n	405b82 <__divdi3+0x21a>
  405b70:	eb13 030c 	adds.w	r3, r3, ip
  405b74:	f101 32ff 	add.w	r2, r1, #4294967295
  405b78:	d235      	bcs.n	405be6 <__divdi3+0x27e>
  405b7a:	459a      	cmp	sl, r3
  405b7c:	d933      	bls.n	405be6 <__divdi3+0x27e>
  405b7e:	3902      	subs	r1, #2
  405b80:	4463      	add	r3, ip
  405b82:	ebca 0303 	rsb	r3, sl, r3
  405b86:	fbb3 f2f9 	udiv	r2, r3, r9
  405b8a:	fb09 3312 	mls	r3, r9, r2, r3
  405b8e:	b2bf      	uxth	r7, r7
  405b90:	ea47 4703 	orr.w	r7, r7, r3, lsl #16
  405b94:	fb0b f902 	mul.w	r9, fp, r2
  405b98:	45b9      	cmp	r9, r7
  405b9a:	d908      	bls.n	405bae <__divdi3+0x246>
  405b9c:	eb17 070c 	adds.w	r7, r7, ip
  405ba0:	f102 33ff 	add.w	r3, r2, #4294967295
  405ba4:	d21b      	bcs.n	405bde <__divdi3+0x276>
  405ba6:	45b9      	cmp	r9, r7
  405ba8:	d919      	bls.n	405bde <__divdi3+0x276>
  405baa:	3a02      	subs	r2, #2
  405bac:	4467      	add	r7, ip
  405bae:	ea42 4501 	orr.w	r5, r2, r1, lsl #16
  405bb2:	fba5 0100 	umull	r0, r1, r5, r0
  405bb6:	ebc9 0707 	rsb	r7, r9, r7
  405bba:	428f      	cmp	r7, r1
  405bbc:	f04f 0300 	mov.w	r3, #0
  405bc0:	d30a      	bcc.n	405bd8 <__divdi3+0x270>
  405bc2:	d005      	beq.n	405bd0 <__divdi3+0x268>
  405bc4:	462a      	mov	r2, r5
  405bc6:	e720      	b.n	405a0a <__divdi3+0xa2>
  405bc8:	4662      	mov	r2, ip
  405bca:	e701      	b.n	4059d0 <__divdi3+0x68>
  405bcc:	463b      	mov	r3, r7
  405bce:	e714      	b.n	4059fa <__divdi3+0x92>
  405bd0:	fa06 f608 	lsl.w	r6, r6, r8
  405bd4:	4286      	cmp	r6, r0
  405bd6:	d2f5      	bcs.n	405bc4 <__divdi3+0x25c>
  405bd8:	1e6a      	subs	r2, r5, #1
  405bda:	2300      	movs	r3, #0
  405bdc:	e715      	b.n	405a0a <__divdi3+0xa2>
  405bde:	461a      	mov	r2, r3
  405be0:	e7e5      	b.n	405bae <__divdi3+0x246>
  405be2:	460b      	mov	r3, r1
  405be4:	e7a0      	b.n	405b28 <__divdi3+0x1c0>
  405be6:	4611      	mov	r1, r2
  405be8:	e7cb      	b.n	405b82 <__divdi3+0x21a>
  405bea:	4690      	mov	r8, r2
  405bec:	e788      	b.n	405b00 <__divdi3+0x198>
  405bee:	4643      	mov	r3, r8
  405bf0:	4642      	mov	r2, r8
  405bf2:	e70a      	b.n	405a0a <__divdi3+0xa2>
  405bf4:	3a02      	subs	r2, #2
  405bf6:	e753      	b.n	405aa0 <__divdi3+0x138>
  405bf8:	3902      	subs	r1, #2
  405bfa:	442f      	add	r7, r5
  405bfc:	e73c      	b.n	405a78 <__divdi3+0x110>
  405bfe:	bf00      	nop

00405c00 <__udivdi3>:
  405c00:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  405c04:	4614      	mov	r4, r2
  405c06:	4605      	mov	r5, r0
  405c08:	460e      	mov	r6, r1
  405c0a:	2b00      	cmp	r3, #0
  405c0c:	d143      	bne.n	405c96 <__udivdi3+0x96>
  405c0e:	428a      	cmp	r2, r1
  405c10:	d953      	bls.n	405cba <__udivdi3+0xba>
  405c12:	fab2 f782 	clz	r7, r2
  405c16:	b157      	cbz	r7, 405c2e <__udivdi3+0x2e>
  405c18:	f1c7 0620 	rsb	r6, r7, #32
  405c1c:	fa20 f606 	lsr.w	r6, r0, r6
  405c20:	fa01 f307 	lsl.w	r3, r1, r7
  405c24:	fa02 f407 	lsl.w	r4, r2, r7
  405c28:	431e      	orrs	r6, r3
  405c2a:	fa00 f507 	lsl.w	r5, r0, r7
  405c2e:	0c21      	lsrs	r1, r4, #16
  405c30:	fbb6 f2f1 	udiv	r2, r6, r1
  405c34:	0c2b      	lsrs	r3, r5, #16
  405c36:	fb01 6712 	mls	r7, r1, r2, r6
  405c3a:	b2a0      	uxth	r0, r4
  405c3c:	ea43 4607 	orr.w	r6, r3, r7, lsl #16
  405c40:	fb00 f302 	mul.w	r3, r0, r2
  405c44:	42b3      	cmp	r3, r6
  405c46:	d909      	bls.n	405c5c <__udivdi3+0x5c>
  405c48:	1936      	adds	r6, r6, r4
  405c4a:	f102 37ff 	add.w	r7, r2, #4294967295
  405c4e:	f080 80f6 	bcs.w	405e3e <__udivdi3+0x23e>
  405c52:	42b3      	cmp	r3, r6
  405c54:	f240 80f3 	bls.w	405e3e <__udivdi3+0x23e>
  405c58:	3a02      	subs	r2, #2
  405c5a:	4426      	add	r6, r4
  405c5c:	1af6      	subs	r6, r6, r3
  405c5e:	fbb6 f3f1 	udiv	r3, r6, r1
  405c62:	b2ad      	uxth	r5, r5
  405c64:	fb01 6113 	mls	r1, r1, r3, r6
  405c68:	ea45 4101 	orr.w	r1, r5, r1, lsl #16
  405c6c:	fb00 f003 	mul.w	r0, r0, r3
  405c70:	4288      	cmp	r0, r1
  405c72:	d908      	bls.n	405c86 <__udivdi3+0x86>
  405c74:	1909      	adds	r1, r1, r4
  405c76:	f103 36ff 	add.w	r6, r3, #4294967295
  405c7a:	f080 80e2 	bcs.w	405e42 <__udivdi3+0x242>
  405c7e:	4288      	cmp	r0, r1
  405c80:	f240 80df 	bls.w	405e42 <__udivdi3+0x242>
  405c84:	3b02      	subs	r3, #2
  405c86:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
  405c8a:	2300      	movs	r3, #0
  405c8c:	4610      	mov	r0, r2
  405c8e:	4619      	mov	r1, r3
  405c90:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  405c94:	4770      	bx	lr
  405c96:	428b      	cmp	r3, r1
  405c98:	d84a      	bhi.n	405d30 <__udivdi3+0x130>
  405c9a:	fab3 f683 	clz	r6, r3
  405c9e:	2e00      	cmp	r6, #0
  405ca0:	d14d      	bne.n	405d3e <__udivdi3+0x13e>
  405ca2:	428b      	cmp	r3, r1
  405ca4:	d302      	bcc.n	405cac <__udivdi3+0xac>
  405ca6:	4282      	cmp	r2, r0
  405ca8:	f200 80d6 	bhi.w	405e58 <__udivdi3+0x258>
  405cac:	2300      	movs	r3, #0
  405cae:	2201      	movs	r2, #1
  405cb0:	4610      	mov	r0, r2
  405cb2:	4619      	mov	r1, r3
  405cb4:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  405cb8:	4770      	bx	lr
  405cba:	b912      	cbnz	r2, 405cc2 <__udivdi3+0xc2>
  405cbc:	2401      	movs	r4, #1
  405cbe:	fbb4 f4f2 	udiv	r4, r4, r2
  405cc2:	fab4 f284 	clz	r2, r4
  405cc6:	2a00      	cmp	r2, #0
  405cc8:	d17c      	bne.n	405dc4 <__udivdi3+0x1c4>
  405cca:	1b09      	subs	r1, r1, r4
  405ccc:	0c26      	lsrs	r6, r4, #16
  405cce:	b2a7      	uxth	r7, r4
  405cd0:	2301      	movs	r3, #1
  405cd2:	fbb1 f0f6 	udiv	r0, r1, r6
  405cd6:	0c2a      	lsrs	r2, r5, #16
  405cd8:	fb06 1110 	mls	r1, r6, r0, r1
  405cdc:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
  405ce0:	fb07 f200 	mul.w	r2, r7, r0
  405ce4:	428a      	cmp	r2, r1
  405ce6:	d907      	bls.n	405cf8 <__udivdi3+0xf8>
  405ce8:	1909      	adds	r1, r1, r4
  405cea:	f100 3cff 	add.w	ip, r0, #4294967295
  405cee:	d202      	bcs.n	405cf6 <__udivdi3+0xf6>
  405cf0:	428a      	cmp	r2, r1
  405cf2:	f200 80c3 	bhi.w	405e7c <__udivdi3+0x27c>
  405cf6:	4660      	mov	r0, ip
  405cf8:	1a89      	subs	r1, r1, r2
  405cfa:	fbb1 f2f6 	udiv	r2, r1, r6
  405cfe:	b2ad      	uxth	r5, r5
  405d00:	fb06 1112 	mls	r1, r6, r2, r1
  405d04:	ea45 4501 	orr.w	r5, r5, r1, lsl #16
  405d08:	fb07 f702 	mul.w	r7, r7, r2
  405d0c:	42af      	cmp	r7, r5
  405d0e:	d908      	bls.n	405d22 <__udivdi3+0x122>
  405d10:	192c      	adds	r4, r5, r4
  405d12:	f102 31ff 	add.w	r1, r2, #4294967295
  405d16:	f080 8096 	bcs.w	405e46 <__udivdi3+0x246>
  405d1a:	42a7      	cmp	r7, r4
  405d1c:	f240 8093 	bls.w	405e46 <__udivdi3+0x246>
  405d20:	3a02      	subs	r2, #2
  405d22:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
  405d26:	4610      	mov	r0, r2
  405d28:	4619      	mov	r1, r3
  405d2a:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  405d2e:	4770      	bx	lr
  405d30:	2300      	movs	r3, #0
  405d32:	461a      	mov	r2, r3
  405d34:	4610      	mov	r0, r2
  405d36:	4619      	mov	r1, r3
  405d38:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  405d3c:	4770      	bx	lr
  405d3e:	f1c6 0520 	rsb	r5, r6, #32
  405d42:	fa22 f405 	lsr.w	r4, r2, r5
  405d46:	40b3      	lsls	r3, r6
  405d48:	431c      	orrs	r4, r3
  405d4a:	ea4f 4814 	mov.w	r8, r4, lsr #16
  405d4e:	fa21 f305 	lsr.w	r3, r1, r5
  405d52:	fa01 f706 	lsl.w	r7, r1, r6
  405d56:	fa20 f505 	lsr.w	r5, r0, r5
  405d5a:	fbb3 fcf8 	udiv	ip, r3, r8
  405d5e:	432f      	orrs	r7, r5
  405d60:	fb08 331c 	mls	r3, r8, ip, r3
  405d64:	0c3d      	lsrs	r5, r7, #16
  405d66:	fa1f fa84 	uxth.w	sl, r4
  405d6a:	ea45 4303 	orr.w	r3, r5, r3, lsl #16
  405d6e:	fb0a f90c 	mul.w	r9, sl, ip
  405d72:	4599      	cmp	r9, r3
  405d74:	fa02 fb06 	lsl.w	fp, r2, r6
  405d78:	d904      	bls.n	405d84 <__udivdi3+0x184>
  405d7a:	191b      	adds	r3, r3, r4
  405d7c:	f10c 32ff 	add.w	r2, ip, #4294967295
  405d80:	d36d      	bcc.n	405e5e <__udivdi3+0x25e>
  405d82:	4694      	mov	ip, r2
  405d84:	ebc9 0303 	rsb	r3, r9, r3
  405d88:	fbb3 f5f8 	udiv	r5, r3, r8
  405d8c:	fb08 3315 	mls	r3, r8, r5, r3
  405d90:	b2bf      	uxth	r7, r7
  405d92:	ea47 4703 	orr.w	r7, r7, r3, lsl #16
  405d96:	fb0a f805 	mul.w	r8, sl, r5
  405d9a:	45b8      	cmp	r8, r7
  405d9c:	d904      	bls.n	405da8 <__udivdi3+0x1a8>
  405d9e:	193f      	adds	r7, r7, r4
  405da0:	f105 33ff 	add.w	r3, r5, #4294967295
  405da4:	d361      	bcc.n	405e6a <__udivdi3+0x26a>
  405da6:	461d      	mov	r5, r3
  405da8:	ea45 4c0c 	orr.w	ip, r5, ip, lsl #16
  405dac:	fbac 230b 	umull	r2, r3, ip, fp
  405db0:	ebc8 0707 	rsb	r7, r8, r7
  405db4:	429f      	cmp	r7, r3
  405db6:	f04f 0500 	mov.w	r5, #0
  405dba:	d349      	bcc.n	405e50 <__udivdi3+0x250>
  405dbc:	d045      	beq.n	405e4a <__udivdi3+0x24a>
  405dbe:	4662      	mov	r2, ip
  405dc0:	462b      	mov	r3, r5
  405dc2:	e763      	b.n	405c8c <__udivdi3+0x8c>
  405dc4:	4094      	lsls	r4, r2
  405dc6:	f1c2 0320 	rsb	r3, r2, #32
  405dca:	fa21 fc03 	lsr.w	ip, r1, r3
  405dce:	0c26      	lsrs	r6, r4, #16
  405dd0:	fa20 f303 	lsr.w	r3, r0, r3
  405dd4:	fa01 f502 	lsl.w	r5, r1, r2
  405dd8:	fbbc f8f6 	udiv	r8, ip, r6
  405ddc:	ea43 0105 	orr.w	r1, r3, r5
  405de0:	0c0b      	lsrs	r3, r1, #16
  405de2:	fb06 cc18 	mls	ip, r6, r8, ip
  405de6:	b2a7      	uxth	r7, r4
  405de8:	ea43 4c0c 	orr.w	ip, r3, ip, lsl #16
  405dec:	fb07 f308 	mul.w	r3, r7, r8
  405df0:	4563      	cmp	r3, ip
  405df2:	fa00 f502 	lsl.w	r5, r0, r2
  405df6:	d909      	bls.n	405e0c <__udivdi3+0x20c>
  405df8:	eb1c 0c04 	adds.w	ip, ip, r4
  405dfc:	f108 32ff 	add.w	r2, r8, #4294967295
  405e00:	d23a      	bcs.n	405e78 <__udivdi3+0x278>
  405e02:	4563      	cmp	r3, ip
  405e04:	d938      	bls.n	405e78 <__udivdi3+0x278>
  405e06:	f1a8 0802 	sub.w	r8, r8, #2
  405e0a:	44a4      	add	ip, r4
  405e0c:	ebc3 0c0c 	rsb	ip, r3, ip
  405e10:	fbbc f3f6 	udiv	r3, ip, r6
  405e14:	b289      	uxth	r1, r1
  405e16:	fb06 cc13 	mls	ip, r6, r3, ip
  405e1a:	ea41 410c 	orr.w	r1, r1, ip, lsl #16
  405e1e:	fb07 f203 	mul.w	r2, r7, r3
  405e22:	428a      	cmp	r2, r1
  405e24:	d907      	bls.n	405e36 <__udivdi3+0x236>
  405e26:	1909      	adds	r1, r1, r4
  405e28:	f103 30ff 	add.w	r0, r3, #4294967295
  405e2c:	d222      	bcs.n	405e74 <__udivdi3+0x274>
  405e2e:	428a      	cmp	r2, r1
  405e30:	d920      	bls.n	405e74 <__udivdi3+0x274>
  405e32:	3b02      	subs	r3, #2
  405e34:	4421      	add	r1, r4
  405e36:	1a89      	subs	r1, r1, r2
  405e38:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
  405e3c:	e749      	b.n	405cd2 <__udivdi3+0xd2>
  405e3e:	463a      	mov	r2, r7
  405e40:	e70c      	b.n	405c5c <__udivdi3+0x5c>
  405e42:	4633      	mov	r3, r6
  405e44:	e71f      	b.n	405c86 <__udivdi3+0x86>
  405e46:	460a      	mov	r2, r1
  405e48:	e76b      	b.n	405d22 <__udivdi3+0x122>
  405e4a:	40b0      	lsls	r0, r6
  405e4c:	4290      	cmp	r0, r2
  405e4e:	d2b6      	bcs.n	405dbe <__udivdi3+0x1be>
  405e50:	f10c 32ff 	add.w	r2, ip, #4294967295
  405e54:	2300      	movs	r3, #0
  405e56:	e719      	b.n	405c8c <__udivdi3+0x8c>
  405e58:	4633      	mov	r3, r6
  405e5a:	4632      	mov	r2, r6
  405e5c:	e716      	b.n	405c8c <__udivdi3+0x8c>
  405e5e:	4599      	cmp	r9, r3
  405e60:	d98f      	bls.n	405d82 <__udivdi3+0x182>
  405e62:	f1ac 0c02 	sub.w	ip, ip, #2
  405e66:	4423      	add	r3, r4
  405e68:	e78c      	b.n	405d84 <__udivdi3+0x184>
  405e6a:	45b8      	cmp	r8, r7
  405e6c:	d99b      	bls.n	405da6 <__udivdi3+0x1a6>
  405e6e:	3d02      	subs	r5, #2
  405e70:	4427      	add	r7, r4
  405e72:	e799      	b.n	405da8 <__udivdi3+0x1a8>
  405e74:	4603      	mov	r3, r0
  405e76:	e7de      	b.n	405e36 <__udivdi3+0x236>
  405e78:	4690      	mov	r8, r2
  405e7a:	e7c7      	b.n	405e0c <__udivdi3+0x20c>
  405e7c:	3802      	subs	r0, #2
  405e7e:	4421      	add	r1, r4
  405e80:	e73a      	b.n	405cf8 <__udivdi3+0xf8>
  405e82:	bf00      	nop

00405e84 <__libc_init_array>:
  405e84:	b570      	push	{r4, r5, r6, lr}
  405e86:	4e0f      	ldr	r6, [pc, #60]	; (405ec4 <__libc_init_array+0x40>)
  405e88:	4d0f      	ldr	r5, [pc, #60]	; (405ec8 <__libc_init_array+0x44>)
  405e8a:	1b76      	subs	r6, r6, r5
  405e8c:	10b6      	asrs	r6, r6, #2
  405e8e:	d007      	beq.n	405ea0 <__libc_init_array+0x1c>
  405e90:	3d04      	subs	r5, #4
  405e92:	2400      	movs	r4, #0
  405e94:	3401      	adds	r4, #1
  405e96:	f855 3f04 	ldr.w	r3, [r5, #4]!
  405e9a:	4798      	blx	r3
  405e9c:	42a6      	cmp	r6, r4
  405e9e:	d1f9      	bne.n	405e94 <__libc_init_array+0x10>
  405ea0:	4e0a      	ldr	r6, [pc, #40]	; (405ecc <__libc_init_array+0x48>)
  405ea2:	4d0b      	ldr	r5, [pc, #44]	; (405ed0 <__libc_init_array+0x4c>)
  405ea4:	1b76      	subs	r6, r6, r5
  405ea6:	f001 f915 	bl	4070d4 <_init>
  405eaa:	10b6      	asrs	r6, r6, #2
  405eac:	d008      	beq.n	405ec0 <__libc_init_array+0x3c>
  405eae:	3d04      	subs	r5, #4
  405eb0:	2400      	movs	r4, #0
  405eb2:	3401      	adds	r4, #1
  405eb4:	f855 3f04 	ldr.w	r3, [r5, #4]!
  405eb8:	4798      	blx	r3
  405eba:	42a6      	cmp	r6, r4
  405ebc:	d1f9      	bne.n	405eb2 <__libc_init_array+0x2e>
  405ebe:	bd70      	pop	{r4, r5, r6, pc}
  405ec0:	bd70      	pop	{r4, r5, r6, pc}
  405ec2:	bf00      	nop
  405ec4:	004070e0 	.word	0x004070e0
  405ec8:	004070e0 	.word	0x004070e0
  405ecc:	004070e8 	.word	0x004070e8
  405ed0:	004070e0 	.word	0x004070e0

00405ed4 <malloc>:
  405ed4:	4b02      	ldr	r3, [pc, #8]	; (405ee0 <malloc+0xc>)
  405ed6:	4601      	mov	r1, r0
  405ed8:	6818      	ldr	r0, [r3, #0]
  405eda:	f000 b803 	b.w	405ee4 <_malloc_r>
  405ede:	bf00      	nop
  405ee0:	200006d8 	.word	0x200006d8

00405ee4 <_malloc_r>:
  405ee4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  405ee8:	f101 050b 	add.w	r5, r1, #11
  405eec:	2d16      	cmp	r5, #22
  405eee:	b083      	sub	sp, #12
  405ef0:	4606      	mov	r6, r0
  405ef2:	d927      	bls.n	405f44 <_malloc_r+0x60>
  405ef4:	f035 0507 	bics.w	r5, r5, #7
  405ef8:	d427      	bmi.n	405f4a <_malloc_r+0x66>
  405efa:	42a9      	cmp	r1, r5
  405efc:	d825      	bhi.n	405f4a <_malloc_r+0x66>
  405efe:	4630      	mov	r0, r6
  405f00:	f000 fb70 	bl	4065e4 <__malloc_lock>
  405f04:	f5b5 7ffc 	cmp.w	r5, #504	; 0x1f8
  405f08:	d226      	bcs.n	405f58 <_malloc_r+0x74>
  405f0a:	4fc1      	ldr	r7, [pc, #772]	; (406210 <_malloc_r+0x32c>)
  405f0c:	ea4f 0cd5 	mov.w	ip, r5, lsr #3
  405f10:	eb07 03cc 	add.w	r3, r7, ip, lsl #3
  405f14:	68dc      	ldr	r4, [r3, #12]
  405f16:	429c      	cmp	r4, r3
  405f18:	f000 81d2 	beq.w	4062c0 <_malloc_r+0x3dc>
  405f1c:	6863      	ldr	r3, [r4, #4]
  405f1e:	68e2      	ldr	r2, [r4, #12]
  405f20:	68a1      	ldr	r1, [r4, #8]
  405f22:	f023 0303 	bic.w	r3, r3, #3
  405f26:	4423      	add	r3, r4
  405f28:	4630      	mov	r0, r6
  405f2a:	685d      	ldr	r5, [r3, #4]
  405f2c:	60ca      	str	r2, [r1, #12]
  405f2e:	f045 0501 	orr.w	r5, r5, #1
  405f32:	6091      	str	r1, [r2, #8]
  405f34:	605d      	str	r5, [r3, #4]
  405f36:	f000 fb57 	bl	4065e8 <__malloc_unlock>
  405f3a:	3408      	adds	r4, #8
  405f3c:	4620      	mov	r0, r4
  405f3e:	b003      	add	sp, #12
  405f40:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  405f44:	2510      	movs	r5, #16
  405f46:	42a9      	cmp	r1, r5
  405f48:	d9d9      	bls.n	405efe <_malloc_r+0x1a>
  405f4a:	2400      	movs	r4, #0
  405f4c:	230c      	movs	r3, #12
  405f4e:	4620      	mov	r0, r4
  405f50:	6033      	str	r3, [r6, #0]
  405f52:	b003      	add	sp, #12
  405f54:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  405f58:	ea5f 2c55 	movs.w	ip, r5, lsr #9
  405f5c:	f000 808a 	beq.w	406074 <_malloc_r+0x190>
  405f60:	f1bc 0f04 	cmp.w	ip, #4
  405f64:	f200 8160 	bhi.w	406228 <_malloc_r+0x344>
  405f68:	ea4f 1c95 	mov.w	ip, r5, lsr #6
  405f6c:	f10c 0c38 	add.w	ip, ip, #56	; 0x38
  405f70:	ea4f 014c 	mov.w	r1, ip, lsl #1
  405f74:	4fa6      	ldr	r7, [pc, #664]	; (406210 <_malloc_r+0x32c>)
  405f76:	eb07 0181 	add.w	r1, r7, r1, lsl #2
  405f7a:	68cc      	ldr	r4, [r1, #12]
  405f7c:	42a1      	cmp	r1, r4
  405f7e:	d105      	bne.n	405f8c <_malloc_r+0xa8>
  405f80:	e00c      	b.n	405f9c <_malloc_r+0xb8>
  405f82:	2b00      	cmp	r3, #0
  405f84:	da7a      	bge.n	40607c <_malloc_r+0x198>
  405f86:	68e4      	ldr	r4, [r4, #12]
  405f88:	42a1      	cmp	r1, r4
  405f8a:	d007      	beq.n	405f9c <_malloc_r+0xb8>
  405f8c:	6862      	ldr	r2, [r4, #4]
  405f8e:	f022 0203 	bic.w	r2, r2, #3
  405f92:	1b53      	subs	r3, r2, r5
  405f94:	2b0f      	cmp	r3, #15
  405f96:	ddf4      	ble.n	405f82 <_malloc_r+0x9e>
  405f98:	f10c 3cff 	add.w	ip, ip, #4294967295
  405f9c:	f10c 0c01 	add.w	ip, ip, #1
  405fa0:	4b9b      	ldr	r3, [pc, #620]	; (406210 <_malloc_r+0x32c>)
  405fa2:	693c      	ldr	r4, [r7, #16]
  405fa4:	f103 0e08 	add.w	lr, r3, #8
  405fa8:	4574      	cmp	r4, lr
  405faa:	f000 817e 	beq.w	4062aa <_malloc_r+0x3c6>
  405fae:	6861      	ldr	r1, [r4, #4]
  405fb0:	f021 0103 	bic.w	r1, r1, #3
  405fb4:	1b4a      	subs	r2, r1, r5
  405fb6:	2a0f      	cmp	r2, #15
  405fb8:	f300 8164 	bgt.w	406284 <_malloc_r+0x3a0>
  405fbc:	2a00      	cmp	r2, #0
  405fbe:	f8c3 e014 	str.w	lr, [r3, #20]
  405fc2:	f8c3 e010 	str.w	lr, [r3, #16]
  405fc6:	da6a      	bge.n	40609e <_malloc_r+0x1ba>
  405fc8:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
  405fcc:	f080 813a 	bcs.w	406244 <_malloc_r+0x360>
  405fd0:	08c9      	lsrs	r1, r1, #3
  405fd2:	eb03 00c1 	add.w	r0, r3, r1, lsl #3
  405fd6:	ea4f 08a1 	mov.w	r8, r1, asr #2
  405fda:	685a      	ldr	r2, [r3, #4]
  405fdc:	6881      	ldr	r1, [r0, #8]
  405fde:	60a1      	str	r1, [r4, #8]
  405fe0:	f04f 0901 	mov.w	r9, #1
  405fe4:	fa09 f808 	lsl.w	r8, r9, r8
  405fe8:	ea48 0202 	orr.w	r2, r8, r2
  405fec:	60e0      	str	r0, [r4, #12]
  405fee:	605a      	str	r2, [r3, #4]
  405ff0:	6084      	str	r4, [r0, #8]
  405ff2:	60cc      	str	r4, [r1, #12]
  405ff4:	ea4f 03ac 	mov.w	r3, ip, asr #2
  405ff8:	2001      	movs	r0, #1
  405ffa:	4098      	lsls	r0, r3
  405ffc:	4290      	cmp	r0, r2
  405ffe:	d85b      	bhi.n	4060b8 <_malloc_r+0x1d4>
  406000:	4202      	tst	r2, r0
  406002:	d106      	bne.n	406012 <_malloc_r+0x12e>
  406004:	f02c 0c03 	bic.w	ip, ip, #3
  406008:	0040      	lsls	r0, r0, #1
  40600a:	4202      	tst	r2, r0
  40600c:	f10c 0c04 	add.w	ip, ip, #4
  406010:	d0fa      	beq.n	406008 <_malloc_r+0x124>
  406012:	eb07 08cc 	add.w	r8, r7, ip, lsl #3
  406016:	4644      	mov	r4, r8
  406018:	46e1      	mov	r9, ip
  40601a:	68e3      	ldr	r3, [r4, #12]
  40601c:	429c      	cmp	r4, r3
  40601e:	d107      	bne.n	406030 <_malloc_r+0x14c>
  406020:	e145      	b.n	4062ae <_malloc_r+0x3ca>
  406022:	2a00      	cmp	r2, #0
  406024:	f280 8156 	bge.w	4062d4 <_malloc_r+0x3f0>
  406028:	68db      	ldr	r3, [r3, #12]
  40602a:	429c      	cmp	r4, r3
  40602c:	f000 813f 	beq.w	4062ae <_malloc_r+0x3ca>
  406030:	6859      	ldr	r1, [r3, #4]
  406032:	f021 0103 	bic.w	r1, r1, #3
  406036:	1b4a      	subs	r2, r1, r5
  406038:	2a0f      	cmp	r2, #15
  40603a:	ddf2      	ble.n	406022 <_malloc_r+0x13e>
  40603c:	461c      	mov	r4, r3
  40603e:	f8d3 c00c 	ldr.w	ip, [r3, #12]
  406042:	f854 8f08 	ldr.w	r8, [r4, #8]!
  406046:	1959      	adds	r1, r3, r5
  406048:	f045 0901 	orr.w	r9, r5, #1
  40604c:	f042 0501 	orr.w	r5, r2, #1
  406050:	f8c3 9004 	str.w	r9, [r3, #4]
  406054:	4630      	mov	r0, r6
  406056:	f8c8 c00c 	str.w	ip, [r8, #12]
  40605a:	f8cc 8008 	str.w	r8, [ip, #8]
  40605e:	6179      	str	r1, [r7, #20]
  406060:	6139      	str	r1, [r7, #16]
  406062:	f8c1 e00c 	str.w	lr, [r1, #12]
  406066:	f8c1 e008 	str.w	lr, [r1, #8]
  40606a:	604d      	str	r5, [r1, #4]
  40606c:	508a      	str	r2, [r1, r2]
  40606e:	f000 fabb 	bl	4065e8 <__malloc_unlock>
  406072:	e763      	b.n	405f3c <_malloc_r+0x58>
  406074:	217e      	movs	r1, #126	; 0x7e
  406076:	f04f 0c3f 	mov.w	ip, #63	; 0x3f
  40607a:	e77b      	b.n	405f74 <_malloc_r+0x90>
  40607c:	4422      	add	r2, r4
  40607e:	68e3      	ldr	r3, [r4, #12]
  406080:	6850      	ldr	r0, [r2, #4]
  406082:	68a1      	ldr	r1, [r4, #8]
  406084:	f040 0501 	orr.w	r5, r0, #1
  406088:	60cb      	str	r3, [r1, #12]
  40608a:	4630      	mov	r0, r6
  40608c:	6099      	str	r1, [r3, #8]
  40608e:	6055      	str	r5, [r2, #4]
  406090:	f000 faaa 	bl	4065e8 <__malloc_unlock>
  406094:	3408      	adds	r4, #8
  406096:	4620      	mov	r0, r4
  406098:	b003      	add	sp, #12
  40609a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40609e:	4421      	add	r1, r4
  4060a0:	4630      	mov	r0, r6
  4060a2:	684b      	ldr	r3, [r1, #4]
  4060a4:	f043 0301 	orr.w	r3, r3, #1
  4060a8:	604b      	str	r3, [r1, #4]
  4060aa:	f000 fa9d 	bl	4065e8 <__malloc_unlock>
  4060ae:	3408      	adds	r4, #8
  4060b0:	4620      	mov	r0, r4
  4060b2:	b003      	add	sp, #12
  4060b4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4060b8:	68bc      	ldr	r4, [r7, #8]
  4060ba:	6863      	ldr	r3, [r4, #4]
  4060bc:	f023 0903 	bic.w	r9, r3, #3
  4060c0:	45a9      	cmp	r9, r5
  4060c2:	d304      	bcc.n	4060ce <_malloc_r+0x1ea>
  4060c4:	ebc5 0309 	rsb	r3, r5, r9
  4060c8:	2b0f      	cmp	r3, #15
  4060ca:	f300 8091 	bgt.w	4061f0 <_malloc_r+0x30c>
  4060ce:	4b51      	ldr	r3, [pc, #324]	; (406214 <_malloc_r+0x330>)
  4060d0:	4a51      	ldr	r2, [pc, #324]	; (406218 <_malloc_r+0x334>)
  4060d2:	6819      	ldr	r1, [r3, #0]
  4060d4:	6813      	ldr	r3, [r2, #0]
  4060d6:	3301      	adds	r3, #1
  4060d8:	eb05 0a01 	add.w	sl, r5, r1
  4060dc:	eb04 0b09 	add.w	fp, r4, r9
  4060e0:	f000 8161 	beq.w	4063a6 <_malloc_r+0x4c2>
  4060e4:	f50a 5a80 	add.w	sl, sl, #4096	; 0x1000
  4060e8:	f10a 0a0f 	add.w	sl, sl, #15
  4060ec:	f42a 6a7f 	bic.w	sl, sl, #4080	; 0xff0
  4060f0:	f02a 0a0f 	bic.w	sl, sl, #15
  4060f4:	4630      	mov	r0, r6
  4060f6:	4651      	mov	r1, sl
  4060f8:	9201      	str	r2, [sp, #4]
  4060fa:	f000 fa77 	bl	4065ec <_sbrk_r>
  4060fe:	f1b0 3fff 	cmp.w	r0, #4294967295
  406102:	4680      	mov	r8, r0
  406104:	9a01      	ldr	r2, [sp, #4]
  406106:	f000 8100 	beq.w	40630a <_malloc_r+0x426>
  40610a:	4583      	cmp	fp, r0
  40610c:	f200 80fa 	bhi.w	406304 <_malloc_r+0x420>
  406110:	f8df c110 	ldr.w	ip, [pc, #272]	; 406224 <_malloc_r+0x340>
  406114:	f8dc 3000 	ldr.w	r3, [ip]
  406118:	45c3      	cmp	fp, r8
  40611a:	4453      	add	r3, sl
  40611c:	f8cc 3000 	str.w	r3, [ip]
  406120:	f000 814a 	beq.w	4063b8 <_malloc_r+0x4d4>
  406124:	6812      	ldr	r2, [r2, #0]
  406126:	493c      	ldr	r1, [pc, #240]	; (406218 <_malloc_r+0x334>)
  406128:	3201      	adds	r2, #1
  40612a:	bf1b      	ittet	ne
  40612c:	ebcb 0b08 	rsbne	fp, fp, r8
  406130:	445b      	addne	r3, fp
  406132:	f8c1 8000 	streq.w	r8, [r1]
  406136:	f8cc 3000 	strne.w	r3, [ip]
  40613a:	f018 0307 	ands.w	r3, r8, #7
  40613e:	f000 8113 	beq.w	406368 <_malloc_r+0x484>
  406142:	f1c3 0208 	rsb	r2, r3, #8
  406146:	f5c3 5380 	rsb	r3, r3, #4096	; 0x1000
  40614a:	4490      	add	r8, r2
  40614c:	3308      	adds	r3, #8
  40614e:	44c2      	add	sl, r8
  406150:	f3ca 0a0b 	ubfx	sl, sl, #0, #12
  406154:	ebca 0a03 	rsb	sl, sl, r3
  406158:	4651      	mov	r1, sl
  40615a:	4630      	mov	r0, r6
  40615c:	f8cd c004 	str.w	ip, [sp, #4]
  406160:	f000 fa44 	bl	4065ec <_sbrk_r>
  406164:	1c43      	adds	r3, r0, #1
  406166:	f8dd c004 	ldr.w	ip, [sp, #4]
  40616a:	f000 8135 	beq.w	4063d8 <_malloc_r+0x4f4>
  40616e:	ebc8 0200 	rsb	r2, r8, r0
  406172:	4452      	add	r2, sl
  406174:	f042 0201 	orr.w	r2, r2, #1
  406178:	f8dc 3000 	ldr.w	r3, [ip]
  40617c:	f8c7 8008 	str.w	r8, [r7, #8]
  406180:	4453      	add	r3, sl
  406182:	42bc      	cmp	r4, r7
  406184:	f8c8 2004 	str.w	r2, [r8, #4]
  406188:	f8cc 3000 	str.w	r3, [ip]
  40618c:	f8df a094 	ldr.w	sl, [pc, #148]	; 406224 <_malloc_r+0x340>
  406190:	d015      	beq.n	4061be <_malloc_r+0x2da>
  406192:	f1b9 0f0f 	cmp.w	r9, #15
  406196:	f240 80ea 	bls.w	40636e <_malloc_r+0x48a>
  40619a:	6861      	ldr	r1, [r4, #4]
  40619c:	f1a9 020c 	sub.w	r2, r9, #12
  4061a0:	f022 0207 	bic.w	r2, r2, #7
  4061a4:	f001 0e01 	and.w	lr, r1, #1
  4061a8:	18a1      	adds	r1, r4, r2
  4061aa:	2005      	movs	r0, #5
  4061ac:	ea42 0e0e 	orr.w	lr, r2, lr
  4061b0:	2a0f      	cmp	r2, #15
  4061b2:	f8c4 e004 	str.w	lr, [r4, #4]
  4061b6:	6048      	str	r0, [r1, #4]
  4061b8:	6088      	str	r0, [r1, #8]
  4061ba:	f200 8111 	bhi.w	4063e0 <_malloc_r+0x4fc>
  4061be:	4a17      	ldr	r2, [pc, #92]	; (40621c <_malloc_r+0x338>)
  4061c0:	68bc      	ldr	r4, [r7, #8]
  4061c2:	6811      	ldr	r1, [r2, #0]
  4061c4:	428b      	cmp	r3, r1
  4061c6:	bf88      	it	hi
  4061c8:	6013      	strhi	r3, [r2, #0]
  4061ca:	4a15      	ldr	r2, [pc, #84]	; (406220 <_malloc_r+0x33c>)
  4061cc:	6811      	ldr	r1, [r2, #0]
  4061ce:	428b      	cmp	r3, r1
  4061d0:	bf88      	it	hi
  4061d2:	6013      	strhi	r3, [r2, #0]
  4061d4:	6862      	ldr	r2, [r4, #4]
  4061d6:	f022 0203 	bic.w	r2, r2, #3
  4061da:	4295      	cmp	r5, r2
  4061dc:	ebc5 0302 	rsb	r3, r5, r2
  4061e0:	d801      	bhi.n	4061e6 <_malloc_r+0x302>
  4061e2:	2b0f      	cmp	r3, #15
  4061e4:	dc04      	bgt.n	4061f0 <_malloc_r+0x30c>
  4061e6:	4630      	mov	r0, r6
  4061e8:	f000 f9fe 	bl	4065e8 <__malloc_unlock>
  4061ec:	2400      	movs	r4, #0
  4061ee:	e6a5      	b.n	405f3c <_malloc_r+0x58>
  4061f0:	1962      	adds	r2, r4, r5
  4061f2:	f043 0301 	orr.w	r3, r3, #1
  4061f6:	f045 0501 	orr.w	r5, r5, #1
  4061fa:	6065      	str	r5, [r4, #4]
  4061fc:	4630      	mov	r0, r6
  4061fe:	60ba      	str	r2, [r7, #8]
  406200:	6053      	str	r3, [r2, #4]
  406202:	f000 f9f1 	bl	4065e8 <__malloc_unlock>
  406206:	3408      	adds	r4, #8
  406208:	4620      	mov	r0, r4
  40620a:	b003      	add	sp, #12
  40620c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  406210:	200006dc 	.word	0x200006dc
  406214:	20001164 	.word	0x20001164
  406218:	20000ae8 	.word	0x20000ae8
  40621c:	20001160 	.word	0x20001160
  406220:	2000115c 	.word	0x2000115c
  406224:	20001168 	.word	0x20001168
  406228:	f1bc 0f14 	cmp.w	ip, #20
  40622c:	d961      	bls.n	4062f2 <_malloc_r+0x40e>
  40622e:	f1bc 0f54 	cmp.w	ip, #84	; 0x54
  406232:	f200 808f 	bhi.w	406354 <_malloc_r+0x470>
  406236:	ea4f 3c15 	mov.w	ip, r5, lsr #12
  40623a:	f10c 0c6e 	add.w	ip, ip, #110	; 0x6e
  40623e:	ea4f 014c 	mov.w	r1, ip, lsl #1
  406242:	e697      	b.n	405f74 <_malloc_r+0x90>
  406244:	0a4b      	lsrs	r3, r1, #9
  406246:	2b04      	cmp	r3, #4
  406248:	d958      	bls.n	4062fc <_malloc_r+0x418>
  40624a:	2b14      	cmp	r3, #20
  40624c:	f200 80ae 	bhi.w	4063ac <_malloc_r+0x4c8>
  406250:	f103 025b 	add.w	r2, r3, #91	; 0x5b
  406254:	0050      	lsls	r0, r2, #1
  406256:	eb07 0080 	add.w	r0, r7, r0, lsl #2
  40625a:	f8df 81bc 	ldr.w	r8, [pc, #444]	; 406418 <_malloc_r+0x534>
  40625e:	6883      	ldr	r3, [r0, #8]
  406260:	4283      	cmp	r3, r0
  406262:	f000 808a 	beq.w	40637a <_malloc_r+0x496>
  406266:	685a      	ldr	r2, [r3, #4]
  406268:	f022 0203 	bic.w	r2, r2, #3
  40626c:	4291      	cmp	r1, r2
  40626e:	d202      	bcs.n	406276 <_malloc_r+0x392>
  406270:	689b      	ldr	r3, [r3, #8]
  406272:	4298      	cmp	r0, r3
  406274:	d1f7      	bne.n	406266 <_malloc_r+0x382>
  406276:	68d9      	ldr	r1, [r3, #12]
  406278:	687a      	ldr	r2, [r7, #4]
  40627a:	60e1      	str	r1, [r4, #12]
  40627c:	60a3      	str	r3, [r4, #8]
  40627e:	608c      	str	r4, [r1, #8]
  406280:	60dc      	str	r4, [r3, #12]
  406282:	e6b7      	b.n	405ff4 <_malloc_r+0x110>
  406284:	1961      	adds	r1, r4, r5
  406286:	f042 0701 	orr.w	r7, r2, #1
  40628a:	f045 0501 	orr.w	r5, r5, #1
  40628e:	6065      	str	r5, [r4, #4]
  406290:	4630      	mov	r0, r6
  406292:	6159      	str	r1, [r3, #20]
  406294:	6119      	str	r1, [r3, #16]
  406296:	f8c1 e00c 	str.w	lr, [r1, #12]
  40629a:	f8c1 e008 	str.w	lr, [r1, #8]
  40629e:	604f      	str	r7, [r1, #4]
  4062a0:	508a      	str	r2, [r1, r2]
  4062a2:	3408      	adds	r4, #8
  4062a4:	f000 f9a0 	bl	4065e8 <__malloc_unlock>
  4062a8:	e648      	b.n	405f3c <_malloc_r+0x58>
  4062aa:	685a      	ldr	r2, [r3, #4]
  4062ac:	e6a2      	b.n	405ff4 <_malloc_r+0x110>
  4062ae:	f109 0901 	add.w	r9, r9, #1
  4062b2:	f019 0f03 	tst.w	r9, #3
  4062b6:	f104 0408 	add.w	r4, r4, #8
  4062ba:	f47f aeae 	bne.w	40601a <_malloc_r+0x136>
  4062be:	e02d      	b.n	40631c <_malloc_r+0x438>
  4062c0:	f104 0308 	add.w	r3, r4, #8
  4062c4:	6964      	ldr	r4, [r4, #20]
  4062c6:	42a3      	cmp	r3, r4
  4062c8:	bf08      	it	eq
  4062ca:	f10c 0c02 	addeq.w	ip, ip, #2
  4062ce:	f43f ae67 	beq.w	405fa0 <_malloc_r+0xbc>
  4062d2:	e623      	b.n	405f1c <_malloc_r+0x38>
  4062d4:	4419      	add	r1, r3
  4062d6:	461c      	mov	r4, r3
  4062d8:	6848      	ldr	r0, [r1, #4]
  4062da:	68db      	ldr	r3, [r3, #12]
  4062dc:	f854 2f08 	ldr.w	r2, [r4, #8]!
  4062e0:	f040 0501 	orr.w	r5, r0, #1
  4062e4:	604d      	str	r5, [r1, #4]
  4062e6:	4630      	mov	r0, r6
  4062e8:	60d3      	str	r3, [r2, #12]
  4062ea:	609a      	str	r2, [r3, #8]
  4062ec:	f000 f97c 	bl	4065e8 <__malloc_unlock>
  4062f0:	e624      	b.n	405f3c <_malloc_r+0x58>
  4062f2:	f10c 0c5b 	add.w	ip, ip, #91	; 0x5b
  4062f6:	ea4f 014c 	mov.w	r1, ip, lsl #1
  4062fa:	e63b      	b.n	405f74 <_malloc_r+0x90>
  4062fc:	098a      	lsrs	r2, r1, #6
  4062fe:	3238      	adds	r2, #56	; 0x38
  406300:	0050      	lsls	r0, r2, #1
  406302:	e7a8      	b.n	406256 <_malloc_r+0x372>
  406304:	42bc      	cmp	r4, r7
  406306:	f43f af03 	beq.w	406110 <_malloc_r+0x22c>
  40630a:	68bc      	ldr	r4, [r7, #8]
  40630c:	6862      	ldr	r2, [r4, #4]
  40630e:	f022 0203 	bic.w	r2, r2, #3
  406312:	e762      	b.n	4061da <_malloc_r+0x2f6>
  406314:	f8d8 8000 	ldr.w	r8, [r8]
  406318:	4598      	cmp	r8, r3
  40631a:	d17b      	bne.n	406414 <_malloc_r+0x530>
  40631c:	f01c 0f03 	tst.w	ip, #3
  406320:	f1a8 0308 	sub.w	r3, r8, #8
  406324:	f10c 3cff 	add.w	ip, ip, #4294967295
  406328:	d1f4      	bne.n	406314 <_malloc_r+0x430>
  40632a:	687b      	ldr	r3, [r7, #4]
  40632c:	ea23 0300 	bic.w	r3, r3, r0
  406330:	607b      	str	r3, [r7, #4]
  406332:	0040      	lsls	r0, r0, #1
  406334:	4298      	cmp	r0, r3
  406336:	f63f aebf 	bhi.w	4060b8 <_malloc_r+0x1d4>
  40633a:	2800      	cmp	r0, #0
  40633c:	f43f aebc 	beq.w	4060b8 <_malloc_r+0x1d4>
  406340:	4203      	tst	r3, r0
  406342:	46cc      	mov	ip, r9
  406344:	f47f ae65 	bne.w	406012 <_malloc_r+0x12e>
  406348:	0040      	lsls	r0, r0, #1
  40634a:	4203      	tst	r3, r0
  40634c:	f10c 0c04 	add.w	ip, ip, #4
  406350:	d0fa      	beq.n	406348 <_malloc_r+0x464>
  406352:	e65e      	b.n	406012 <_malloc_r+0x12e>
  406354:	f5bc 7faa 	cmp.w	ip, #340	; 0x154
  406358:	d81a      	bhi.n	406390 <_malloc_r+0x4ac>
  40635a:	ea4f 3cd5 	mov.w	ip, r5, lsr #15
  40635e:	f10c 0c77 	add.w	ip, ip, #119	; 0x77
  406362:	ea4f 014c 	mov.w	r1, ip, lsl #1
  406366:	e605      	b.n	405f74 <_malloc_r+0x90>
  406368:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  40636c:	e6ef      	b.n	40614e <_malloc_r+0x26a>
  40636e:	2301      	movs	r3, #1
  406370:	f8c8 3004 	str.w	r3, [r8, #4]
  406374:	4644      	mov	r4, r8
  406376:	2200      	movs	r2, #0
  406378:	e72f      	b.n	4061da <_malloc_r+0x2f6>
  40637a:	1091      	asrs	r1, r2, #2
  40637c:	2001      	movs	r0, #1
  40637e:	f8d8 2004 	ldr.w	r2, [r8, #4]
  406382:	fa00 f101 	lsl.w	r1, r0, r1
  406386:	430a      	orrs	r2, r1
  406388:	f8c8 2004 	str.w	r2, [r8, #4]
  40638c:	4619      	mov	r1, r3
  40638e:	e774      	b.n	40627a <_malloc_r+0x396>
  406390:	f240 5354 	movw	r3, #1364	; 0x554
  406394:	459c      	cmp	ip, r3
  406396:	d81b      	bhi.n	4063d0 <_malloc_r+0x4ec>
  406398:	ea4f 4c95 	mov.w	ip, r5, lsr #18
  40639c:	f10c 0c7c 	add.w	ip, ip, #124	; 0x7c
  4063a0:	ea4f 014c 	mov.w	r1, ip, lsl #1
  4063a4:	e5e6      	b.n	405f74 <_malloc_r+0x90>
  4063a6:	f10a 0a10 	add.w	sl, sl, #16
  4063aa:	e6a3      	b.n	4060f4 <_malloc_r+0x210>
  4063ac:	2b54      	cmp	r3, #84	; 0x54
  4063ae:	d81f      	bhi.n	4063f0 <_malloc_r+0x50c>
  4063b0:	0b0a      	lsrs	r2, r1, #12
  4063b2:	326e      	adds	r2, #110	; 0x6e
  4063b4:	0050      	lsls	r0, r2, #1
  4063b6:	e74e      	b.n	406256 <_malloc_r+0x372>
  4063b8:	f3cb 010b 	ubfx	r1, fp, #0, #12
  4063bc:	2900      	cmp	r1, #0
  4063be:	f47f aeb1 	bne.w	406124 <_malloc_r+0x240>
  4063c2:	eb0a 0109 	add.w	r1, sl, r9
  4063c6:	68ba      	ldr	r2, [r7, #8]
  4063c8:	f041 0101 	orr.w	r1, r1, #1
  4063cc:	6051      	str	r1, [r2, #4]
  4063ce:	e6f6      	b.n	4061be <_malloc_r+0x2da>
  4063d0:	21fc      	movs	r1, #252	; 0xfc
  4063d2:	f04f 0c7e 	mov.w	ip, #126	; 0x7e
  4063d6:	e5cd      	b.n	405f74 <_malloc_r+0x90>
  4063d8:	2201      	movs	r2, #1
  4063da:	f04f 0a00 	mov.w	sl, #0
  4063de:	e6cb      	b.n	406178 <_malloc_r+0x294>
  4063e0:	f104 0108 	add.w	r1, r4, #8
  4063e4:	4630      	mov	r0, r6
  4063e6:	f000 f9eb 	bl	4067c0 <_free_r>
  4063ea:	f8da 3000 	ldr.w	r3, [sl]
  4063ee:	e6e6      	b.n	4061be <_malloc_r+0x2da>
  4063f0:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
  4063f4:	d803      	bhi.n	4063fe <_malloc_r+0x51a>
  4063f6:	0bca      	lsrs	r2, r1, #15
  4063f8:	3277      	adds	r2, #119	; 0x77
  4063fa:	0050      	lsls	r0, r2, #1
  4063fc:	e72b      	b.n	406256 <_malloc_r+0x372>
  4063fe:	f240 5254 	movw	r2, #1364	; 0x554
  406402:	4293      	cmp	r3, r2
  406404:	d803      	bhi.n	40640e <_malloc_r+0x52a>
  406406:	0c8a      	lsrs	r2, r1, #18
  406408:	327c      	adds	r2, #124	; 0x7c
  40640a:	0050      	lsls	r0, r2, #1
  40640c:	e723      	b.n	406256 <_malloc_r+0x372>
  40640e:	20fc      	movs	r0, #252	; 0xfc
  406410:	227e      	movs	r2, #126	; 0x7e
  406412:	e720      	b.n	406256 <_malloc_r+0x372>
  406414:	687b      	ldr	r3, [r7, #4]
  406416:	e78c      	b.n	406332 <_malloc_r+0x44e>
  406418:	200006dc 	.word	0x200006dc

0040641c <memcpy>:
  40641c:	4684      	mov	ip, r0
  40641e:	ea41 0300 	orr.w	r3, r1, r0
  406422:	f013 0303 	ands.w	r3, r3, #3
  406426:	d16d      	bne.n	406504 <memcpy+0xe8>
  406428:	3a40      	subs	r2, #64	; 0x40
  40642a:	d341      	bcc.n	4064b0 <memcpy+0x94>
  40642c:	f851 3b04 	ldr.w	r3, [r1], #4
  406430:	f840 3b04 	str.w	r3, [r0], #4
  406434:	f851 3b04 	ldr.w	r3, [r1], #4
  406438:	f840 3b04 	str.w	r3, [r0], #4
  40643c:	f851 3b04 	ldr.w	r3, [r1], #4
  406440:	f840 3b04 	str.w	r3, [r0], #4
  406444:	f851 3b04 	ldr.w	r3, [r1], #4
  406448:	f840 3b04 	str.w	r3, [r0], #4
  40644c:	f851 3b04 	ldr.w	r3, [r1], #4
  406450:	f840 3b04 	str.w	r3, [r0], #4
  406454:	f851 3b04 	ldr.w	r3, [r1], #4
  406458:	f840 3b04 	str.w	r3, [r0], #4
  40645c:	f851 3b04 	ldr.w	r3, [r1], #4
  406460:	f840 3b04 	str.w	r3, [r0], #4
  406464:	f851 3b04 	ldr.w	r3, [r1], #4
  406468:	f840 3b04 	str.w	r3, [r0], #4
  40646c:	f851 3b04 	ldr.w	r3, [r1], #4
  406470:	f840 3b04 	str.w	r3, [r0], #4
  406474:	f851 3b04 	ldr.w	r3, [r1], #4
  406478:	f840 3b04 	str.w	r3, [r0], #4
  40647c:	f851 3b04 	ldr.w	r3, [r1], #4
  406480:	f840 3b04 	str.w	r3, [r0], #4
  406484:	f851 3b04 	ldr.w	r3, [r1], #4
  406488:	f840 3b04 	str.w	r3, [r0], #4
  40648c:	f851 3b04 	ldr.w	r3, [r1], #4
  406490:	f840 3b04 	str.w	r3, [r0], #4
  406494:	f851 3b04 	ldr.w	r3, [r1], #4
  406498:	f840 3b04 	str.w	r3, [r0], #4
  40649c:	f851 3b04 	ldr.w	r3, [r1], #4
  4064a0:	f840 3b04 	str.w	r3, [r0], #4
  4064a4:	f851 3b04 	ldr.w	r3, [r1], #4
  4064a8:	f840 3b04 	str.w	r3, [r0], #4
  4064ac:	3a40      	subs	r2, #64	; 0x40
  4064ae:	d2bd      	bcs.n	40642c <memcpy+0x10>
  4064b0:	3230      	adds	r2, #48	; 0x30
  4064b2:	d311      	bcc.n	4064d8 <memcpy+0xbc>
  4064b4:	f851 3b04 	ldr.w	r3, [r1], #4
  4064b8:	f840 3b04 	str.w	r3, [r0], #4
  4064bc:	f851 3b04 	ldr.w	r3, [r1], #4
  4064c0:	f840 3b04 	str.w	r3, [r0], #4
  4064c4:	f851 3b04 	ldr.w	r3, [r1], #4
  4064c8:	f840 3b04 	str.w	r3, [r0], #4
  4064cc:	f851 3b04 	ldr.w	r3, [r1], #4
  4064d0:	f840 3b04 	str.w	r3, [r0], #4
  4064d4:	3a10      	subs	r2, #16
  4064d6:	d2ed      	bcs.n	4064b4 <memcpy+0x98>
  4064d8:	320c      	adds	r2, #12
  4064da:	d305      	bcc.n	4064e8 <memcpy+0xcc>
  4064dc:	f851 3b04 	ldr.w	r3, [r1], #4
  4064e0:	f840 3b04 	str.w	r3, [r0], #4
  4064e4:	3a04      	subs	r2, #4
  4064e6:	d2f9      	bcs.n	4064dc <memcpy+0xc0>
  4064e8:	3204      	adds	r2, #4
  4064ea:	d008      	beq.n	4064fe <memcpy+0xe2>
  4064ec:	07d2      	lsls	r2, r2, #31
  4064ee:	bf1c      	itt	ne
  4064f0:	f811 3b01 	ldrbne.w	r3, [r1], #1
  4064f4:	f800 3b01 	strbne.w	r3, [r0], #1
  4064f8:	d301      	bcc.n	4064fe <memcpy+0xe2>
  4064fa:	880b      	ldrh	r3, [r1, #0]
  4064fc:	8003      	strh	r3, [r0, #0]
  4064fe:	4660      	mov	r0, ip
  406500:	4770      	bx	lr
  406502:	bf00      	nop
  406504:	2a08      	cmp	r2, #8
  406506:	d313      	bcc.n	406530 <memcpy+0x114>
  406508:	078b      	lsls	r3, r1, #30
  40650a:	d08d      	beq.n	406428 <memcpy+0xc>
  40650c:	f010 0303 	ands.w	r3, r0, #3
  406510:	d08a      	beq.n	406428 <memcpy+0xc>
  406512:	f1c3 0304 	rsb	r3, r3, #4
  406516:	1ad2      	subs	r2, r2, r3
  406518:	07db      	lsls	r3, r3, #31
  40651a:	bf1c      	itt	ne
  40651c:	f811 3b01 	ldrbne.w	r3, [r1], #1
  406520:	f800 3b01 	strbne.w	r3, [r0], #1
  406524:	d380      	bcc.n	406428 <memcpy+0xc>
  406526:	f831 3b02 	ldrh.w	r3, [r1], #2
  40652a:	f820 3b02 	strh.w	r3, [r0], #2
  40652e:	e77b      	b.n	406428 <memcpy+0xc>
  406530:	3a04      	subs	r2, #4
  406532:	d3d9      	bcc.n	4064e8 <memcpy+0xcc>
  406534:	3a01      	subs	r2, #1
  406536:	f811 3b01 	ldrb.w	r3, [r1], #1
  40653a:	f800 3b01 	strb.w	r3, [r0], #1
  40653e:	d2f9      	bcs.n	406534 <memcpy+0x118>
  406540:	780b      	ldrb	r3, [r1, #0]
  406542:	7003      	strb	r3, [r0, #0]
  406544:	784b      	ldrb	r3, [r1, #1]
  406546:	7043      	strb	r3, [r0, #1]
  406548:	788b      	ldrb	r3, [r1, #2]
  40654a:	7083      	strb	r3, [r0, #2]
  40654c:	4660      	mov	r0, ip
  40654e:	4770      	bx	lr

00406550 <memset>:
  406550:	b4f0      	push	{r4, r5, r6, r7}
  406552:	0784      	lsls	r4, r0, #30
  406554:	d043      	beq.n	4065de <memset+0x8e>
  406556:	1e54      	subs	r4, r2, #1
  406558:	2a00      	cmp	r2, #0
  40655a:	d03e      	beq.n	4065da <memset+0x8a>
  40655c:	b2cd      	uxtb	r5, r1
  40655e:	4603      	mov	r3, r0
  406560:	e003      	b.n	40656a <memset+0x1a>
  406562:	1e62      	subs	r2, r4, #1
  406564:	2c00      	cmp	r4, #0
  406566:	d038      	beq.n	4065da <memset+0x8a>
  406568:	4614      	mov	r4, r2
  40656a:	f803 5b01 	strb.w	r5, [r3], #1
  40656e:	079a      	lsls	r2, r3, #30
  406570:	d1f7      	bne.n	406562 <memset+0x12>
  406572:	2c03      	cmp	r4, #3
  406574:	d92a      	bls.n	4065cc <memset+0x7c>
  406576:	b2cd      	uxtb	r5, r1
  406578:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
  40657c:	2c0f      	cmp	r4, #15
  40657e:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
  406582:	d915      	bls.n	4065b0 <memset+0x60>
  406584:	f1a4 0710 	sub.w	r7, r4, #16
  406588:	093f      	lsrs	r7, r7, #4
  40658a:	f103 0610 	add.w	r6, r3, #16
  40658e:	eb06 1607 	add.w	r6, r6, r7, lsl #4
  406592:	461a      	mov	r2, r3
  406594:	6015      	str	r5, [r2, #0]
  406596:	6055      	str	r5, [r2, #4]
  406598:	6095      	str	r5, [r2, #8]
  40659a:	60d5      	str	r5, [r2, #12]
  40659c:	3210      	adds	r2, #16
  40659e:	42b2      	cmp	r2, r6
  4065a0:	d1f8      	bne.n	406594 <memset+0x44>
  4065a2:	f004 040f 	and.w	r4, r4, #15
  4065a6:	3701      	adds	r7, #1
  4065a8:	2c03      	cmp	r4, #3
  4065aa:	eb03 1307 	add.w	r3, r3, r7, lsl #4
  4065ae:	d90d      	bls.n	4065cc <memset+0x7c>
  4065b0:	461e      	mov	r6, r3
  4065b2:	4622      	mov	r2, r4
  4065b4:	3a04      	subs	r2, #4
  4065b6:	2a03      	cmp	r2, #3
  4065b8:	f846 5b04 	str.w	r5, [r6], #4
  4065bc:	d8fa      	bhi.n	4065b4 <memset+0x64>
  4065be:	1f22      	subs	r2, r4, #4
  4065c0:	f022 0203 	bic.w	r2, r2, #3
  4065c4:	3204      	adds	r2, #4
  4065c6:	4413      	add	r3, r2
  4065c8:	f004 0403 	and.w	r4, r4, #3
  4065cc:	b12c      	cbz	r4, 4065da <memset+0x8a>
  4065ce:	b2c9      	uxtb	r1, r1
  4065d0:	441c      	add	r4, r3
  4065d2:	f803 1b01 	strb.w	r1, [r3], #1
  4065d6:	42a3      	cmp	r3, r4
  4065d8:	d1fb      	bne.n	4065d2 <memset+0x82>
  4065da:	bcf0      	pop	{r4, r5, r6, r7}
  4065dc:	4770      	bx	lr
  4065de:	4614      	mov	r4, r2
  4065e0:	4603      	mov	r3, r0
  4065e2:	e7c6      	b.n	406572 <memset+0x22>

004065e4 <__malloc_lock>:
  4065e4:	4770      	bx	lr
  4065e6:	bf00      	nop

004065e8 <__malloc_unlock>:
  4065e8:	4770      	bx	lr
  4065ea:	bf00      	nop

004065ec <_sbrk_r>:
  4065ec:	b538      	push	{r3, r4, r5, lr}
  4065ee:	4c07      	ldr	r4, [pc, #28]	; (40660c <_sbrk_r+0x20>)
  4065f0:	2300      	movs	r3, #0
  4065f2:	4605      	mov	r5, r0
  4065f4:	4608      	mov	r0, r1
  4065f6:	6023      	str	r3, [r4, #0]
  4065f8:	f7ff f92a 	bl	405850 <_sbrk>
  4065fc:	1c43      	adds	r3, r0, #1
  4065fe:	d000      	beq.n	406602 <_sbrk_r+0x16>
  406600:	bd38      	pop	{r3, r4, r5, pc}
  406602:	6823      	ldr	r3, [r4, #0]
  406604:	2b00      	cmp	r3, #0
  406606:	d0fb      	beq.n	406600 <_sbrk_r+0x14>
  406608:	602b      	str	r3, [r5, #0]
  40660a:	bd38      	pop	{r3, r4, r5, pc}
  40660c:	20002444 	.word	0x20002444

00406610 <strlen>:
  406610:	f020 0103 	bic.w	r1, r0, #3
  406614:	f010 0003 	ands.w	r0, r0, #3
  406618:	f1c0 0000 	rsb	r0, r0, #0
  40661c:	f851 3b04 	ldr.w	r3, [r1], #4
  406620:	f100 0c04 	add.w	ip, r0, #4
  406624:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
  406628:	f06f 0200 	mvn.w	r2, #0
  40662c:	bf1c      	itt	ne
  40662e:	fa22 f20c 	lsrne.w	r2, r2, ip
  406632:	4313      	orrne	r3, r2
  406634:	f04f 0c01 	mov.w	ip, #1
  406638:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
  40663c:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
  406640:	eba3 020c 	sub.w	r2, r3, ip
  406644:	ea22 0203 	bic.w	r2, r2, r3
  406648:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
  40664c:	bf04      	itt	eq
  40664e:	f851 3b04 	ldreq.w	r3, [r1], #4
  406652:	3004      	addeq	r0, #4
  406654:	d0f4      	beq.n	406640 <strlen+0x30>
  406656:	f013 0fff 	tst.w	r3, #255	; 0xff
  40665a:	bf1f      	itttt	ne
  40665c:	3001      	addne	r0, #1
  40665e:	f413 4f7f 	tstne.w	r3, #65280	; 0xff00
  406662:	3001      	addne	r0, #1
  406664:	f413 0f7f 	tstne.w	r3, #16711680	; 0xff0000
  406668:	bf18      	it	ne
  40666a:	3001      	addne	r0, #1
  40666c:	4770      	bx	lr
  40666e:	bf00      	nop

00406670 <strncpy>:
  406670:	ea40 0301 	orr.w	r3, r0, r1
  406674:	079b      	lsls	r3, r3, #30
  406676:	b470      	push	{r4, r5, r6}
  406678:	d12a      	bne.n	4066d0 <strncpy+0x60>
  40667a:	2a03      	cmp	r2, #3
  40667c:	d928      	bls.n	4066d0 <strncpy+0x60>
  40667e:	460c      	mov	r4, r1
  406680:	4603      	mov	r3, r0
  406682:	4621      	mov	r1, r4
  406684:	f854 5b04 	ldr.w	r5, [r4], #4
  406688:	f1a5 3601 	sub.w	r6, r5, #16843009	; 0x1010101
  40668c:	ea26 0605 	bic.w	r6, r6, r5
  406690:	f016 3f80 	tst.w	r6, #2155905152	; 0x80808080
  406694:	d105      	bne.n	4066a2 <strncpy+0x32>
  406696:	3a04      	subs	r2, #4
  406698:	2a03      	cmp	r2, #3
  40669a:	f843 5b04 	str.w	r5, [r3], #4
  40669e:	4621      	mov	r1, r4
  4066a0:	d8ef      	bhi.n	406682 <strncpy+0x12>
  4066a2:	b19a      	cbz	r2, 4066cc <strncpy+0x5c>
  4066a4:	780c      	ldrb	r4, [r1, #0]
  4066a6:	701c      	strb	r4, [r3, #0]
  4066a8:	3a01      	subs	r2, #1
  4066aa:	3301      	adds	r3, #1
  4066ac:	b13c      	cbz	r4, 4066be <strncpy+0x4e>
  4066ae:	b16a      	cbz	r2, 4066cc <strncpy+0x5c>
  4066b0:	f811 4f01 	ldrb.w	r4, [r1, #1]!
  4066b4:	f803 4b01 	strb.w	r4, [r3], #1
  4066b8:	3a01      	subs	r2, #1
  4066ba:	2c00      	cmp	r4, #0
  4066bc:	d1f7      	bne.n	4066ae <strncpy+0x3e>
  4066be:	b12a      	cbz	r2, 4066cc <strncpy+0x5c>
  4066c0:	441a      	add	r2, r3
  4066c2:	2100      	movs	r1, #0
  4066c4:	f803 1b01 	strb.w	r1, [r3], #1
  4066c8:	4293      	cmp	r3, r2
  4066ca:	d1fb      	bne.n	4066c4 <strncpy+0x54>
  4066cc:	bc70      	pop	{r4, r5, r6}
  4066ce:	4770      	bx	lr
  4066d0:	4603      	mov	r3, r0
  4066d2:	e7e6      	b.n	4066a2 <strncpy+0x32>

004066d4 <register_fini>:
  4066d4:	4b02      	ldr	r3, [pc, #8]	; (4066e0 <register_fini+0xc>)
  4066d6:	b113      	cbz	r3, 4066de <register_fini+0xa>
  4066d8:	4802      	ldr	r0, [pc, #8]	; (4066e4 <register_fini+0x10>)
  4066da:	f000 b805 	b.w	4066e8 <atexit>
  4066de:	4770      	bx	lr
  4066e0:	00000000 	.word	0x00000000
  4066e4:	004066f5 	.word	0x004066f5

004066e8 <atexit>:
  4066e8:	4601      	mov	r1, r0
  4066ea:	2000      	movs	r0, #0
  4066ec:	4602      	mov	r2, r0
  4066ee:	4603      	mov	r3, r0
  4066f0:	f000 b934 	b.w	40695c <__register_exitproc>

004066f4 <__libc_fini_array>:
  4066f4:	b538      	push	{r3, r4, r5, lr}
  4066f6:	4d09      	ldr	r5, [pc, #36]	; (40671c <__libc_fini_array+0x28>)
  4066f8:	4c09      	ldr	r4, [pc, #36]	; (406720 <__libc_fini_array+0x2c>)
  4066fa:	1b64      	subs	r4, r4, r5
  4066fc:	10a4      	asrs	r4, r4, #2
  4066fe:	bf18      	it	ne
  406700:	eb05 0584 	addne.w	r5, r5, r4, lsl #2
  406704:	d005      	beq.n	406712 <__libc_fini_array+0x1e>
  406706:	3c01      	subs	r4, #1
  406708:	f855 3d04 	ldr.w	r3, [r5, #-4]!
  40670c:	4798      	blx	r3
  40670e:	2c00      	cmp	r4, #0
  406710:	d1f9      	bne.n	406706 <__libc_fini_array+0x12>
  406712:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  406716:	f000 bce7 	b.w	4070e8 <_fini>
  40671a:	bf00      	nop
  40671c:	004070f4 	.word	0x004070f4
  406720:	004070f8 	.word	0x004070f8

00406724 <_malloc_trim_r>:
  406724:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  406726:	4d23      	ldr	r5, [pc, #140]	; (4067b4 <_malloc_trim_r+0x90>)
  406728:	460f      	mov	r7, r1
  40672a:	4604      	mov	r4, r0
  40672c:	f7ff ff5a 	bl	4065e4 <__malloc_lock>
  406730:	68ab      	ldr	r3, [r5, #8]
  406732:	685e      	ldr	r6, [r3, #4]
  406734:	f026 0603 	bic.w	r6, r6, #3
  406738:	1bf1      	subs	r1, r6, r7
  40673a:	f601 71ef 	addw	r1, r1, #4079	; 0xfef
  40673e:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
  406742:	f021 010f 	bic.w	r1, r1, #15
  406746:	f5a1 5780 	sub.w	r7, r1, #4096	; 0x1000
  40674a:	f5b7 5f80 	cmp.w	r7, #4096	; 0x1000
  40674e:	db07      	blt.n	406760 <_malloc_trim_r+0x3c>
  406750:	4620      	mov	r0, r4
  406752:	2100      	movs	r1, #0
  406754:	f7ff ff4a 	bl	4065ec <_sbrk_r>
  406758:	68ab      	ldr	r3, [r5, #8]
  40675a:	4433      	add	r3, r6
  40675c:	4298      	cmp	r0, r3
  40675e:	d004      	beq.n	40676a <_malloc_trim_r+0x46>
  406760:	4620      	mov	r0, r4
  406762:	f7ff ff41 	bl	4065e8 <__malloc_unlock>
  406766:	2000      	movs	r0, #0
  406768:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  40676a:	4620      	mov	r0, r4
  40676c:	4279      	negs	r1, r7
  40676e:	f7ff ff3d 	bl	4065ec <_sbrk_r>
  406772:	3001      	adds	r0, #1
  406774:	d00d      	beq.n	406792 <_malloc_trim_r+0x6e>
  406776:	4b10      	ldr	r3, [pc, #64]	; (4067b8 <_malloc_trim_r+0x94>)
  406778:	68aa      	ldr	r2, [r5, #8]
  40677a:	6819      	ldr	r1, [r3, #0]
  40677c:	1bf6      	subs	r6, r6, r7
  40677e:	f046 0601 	orr.w	r6, r6, #1
  406782:	4620      	mov	r0, r4
  406784:	1bc9      	subs	r1, r1, r7
  406786:	6056      	str	r6, [r2, #4]
  406788:	6019      	str	r1, [r3, #0]
  40678a:	f7ff ff2d 	bl	4065e8 <__malloc_unlock>
  40678e:	2001      	movs	r0, #1
  406790:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  406792:	4620      	mov	r0, r4
  406794:	2100      	movs	r1, #0
  406796:	f7ff ff29 	bl	4065ec <_sbrk_r>
  40679a:	68ab      	ldr	r3, [r5, #8]
  40679c:	1ac2      	subs	r2, r0, r3
  40679e:	2a0f      	cmp	r2, #15
  4067a0:	ddde      	ble.n	406760 <_malloc_trim_r+0x3c>
  4067a2:	4d06      	ldr	r5, [pc, #24]	; (4067bc <_malloc_trim_r+0x98>)
  4067a4:	4904      	ldr	r1, [pc, #16]	; (4067b8 <_malloc_trim_r+0x94>)
  4067a6:	682d      	ldr	r5, [r5, #0]
  4067a8:	f042 0201 	orr.w	r2, r2, #1
  4067ac:	1b40      	subs	r0, r0, r5
  4067ae:	605a      	str	r2, [r3, #4]
  4067b0:	6008      	str	r0, [r1, #0]
  4067b2:	e7d5      	b.n	406760 <_malloc_trim_r+0x3c>
  4067b4:	200006dc 	.word	0x200006dc
  4067b8:	20001168 	.word	0x20001168
  4067bc:	20000ae8 	.word	0x20000ae8

004067c0 <_free_r>:
  4067c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  4067c4:	460d      	mov	r5, r1
  4067c6:	4606      	mov	r6, r0
  4067c8:	2900      	cmp	r1, #0
  4067ca:	d055      	beq.n	406878 <_free_r+0xb8>
  4067cc:	f7ff ff0a 	bl	4065e4 <__malloc_lock>
  4067d0:	f855 1c04 	ldr.w	r1, [r5, #-4]
  4067d4:	f8df c174 	ldr.w	ip, [pc, #372]	; 40694c <_free_r+0x18c>
  4067d8:	f021 0301 	bic.w	r3, r1, #1
  4067dc:	f1a5 0408 	sub.w	r4, r5, #8
  4067e0:	18e2      	adds	r2, r4, r3
  4067e2:	f8dc 0008 	ldr.w	r0, [ip, #8]
  4067e6:	6857      	ldr	r7, [r2, #4]
  4067e8:	4290      	cmp	r0, r2
  4067ea:	f027 0703 	bic.w	r7, r7, #3
  4067ee:	d069      	beq.n	4068c4 <_free_r+0x104>
  4067f0:	f011 0101 	ands.w	r1, r1, #1
  4067f4:	6057      	str	r7, [r2, #4]
  4067f6:	d032      	beq.n	40685e <_free_r+0x9e>
  4067f8:	2100      	movs	r1, #0
  4067fa:	19d0      	adds	r0, r2, r7
  4067fc:	6840      	ldr	r0, [r0, #4]
  4067fe:	07c0      	lsls	r0, r0, #31
  406800:	d406      	bmi.n	406810 <_free_r+0x50>
  406802:	443b      	add	r3, r7
  406804:	6890      	ldr	r0, [r2, #8]
  406806:	2900      	cmp	r1, #0
  406808:	d04e      	beq.n	4068a8 <_free_r+0xe8>
  40680a:	68d2      	ldr	r2, [r2, #12]
  40680c:	60c2      	str	r2, [r0, #12]
  40680e:	6090      	str	r0, [r2, #8]
  406810:	f043 0201 	orr.w	r2, r3, #1
  406814:	6062      	str	r2, [r4, #4]
  406816:	50e3      	str	r3, [r4, r3]
  406818:	b9e1      	cbnz	r1, 406854 <_free_r+0x94>
  40681a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
  40681e:	d32d      	bcc.n	40687c <_free_r+0xbc>
  406820:	0a5a      	lsrs	r2, r3, #9
  406822:	2a04      	cmp	r2, #4
  406824:	d86a      	bhi.n	4068fc <_free_r+0x13c>
  406826:	0998      	lsrs	r0, r3, #6
  406828:	3038      	adds	r0, #56	; 0x38
  40682a:	0041      	lsls	r1, r0, #1
  40682c:	eb0c 0c81 	add.w	ip, ip, r1, lsl #2
  406830:	4946      	ldr	r1, [pc, #280]	; (40694c <_free_r+0x18c>)
  406832:	f8dc 2008 	ldr.w	r2, [ip, #8]
  406836:	4562      	cmp	r2, ip
  406838:	d066      	beq.n	406908 <_free_r+0x148>
  40683a:	6851      	ldr	r1, [r2, #4]
  40683c:	f021 0103 	bic.w	r1, r1, #3
  406840:	428b      	cmp	r3, r1
  406842:	d202      	bcs.n	40684a <_free_r+0x8a>
  406844:	6892      	ldr	r2, [r2, #8]
  406846:	4594      	cmp	ip, r2
  406848:	d1f7      	bne.n	40683a <_free_r+0x7a>
  40684a:	68d3      	ldr	r3, [r2, #12]
  40684c:	60e3      	str	r3, [r4, #12]
  40684e:	60a2      	str	r2, [r4, #8]
  406850:	609c      	str	r4, [r3, #8]
  406852:	60d4      	str	r4, [r2, #12]
  406854:	4630      	mov	r0, r6
  406856:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  40685a:	f7ff bec5 	b.w	4065e8 <__malloc_unlock>
  40685e:	f855 5c08 	ldr.w	r5, [r5, #-8]
  406862:	1b64      	subs	r4, r4, r5
  406864:	f10c 0808 	add.w	r8, ip, #8
  406868:	68a0      	ldr	r0, [r4, #8]
  40686a:	4540      	cmp	r0, r8
  40686c:	442b      	add	r3, r5
  40686e:	d043      	beq.n	4068f8 <_free_r+0x138>
  406870:	68e5      	ldr	r5, [r4, #12]
  406872:	60c5      	str	r5, [r0, #12]
  406874:	60a8      	str	r0, [r5, #8]
  406876:	e7c0      	b.n	4067fa <_free_r+0x3a>
  406878:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40687c:	08db      	lsrs	r3, r3, #3
  40687e:	eb0c 02c3 	add.w	r2, ip, r3, lsl #3
  406882:	2501      	movs	r5, #1
  406884:	f8dc 0004 	ldr.w	r0, [ip, #4]
  406888:	6891      	ldr	r1, [r2, #8]
  40688a:	60a1      	str	r1, [r4, #8]
  40688c:	109b      	asrs	r3, r3, #2
  40688e:	fa05 f303 	lsl.w	r3, r5, r3
  406892:	4318      	orrs	r0, r3
  406894:	60e2      	str	r2, [r4, #12]
  406896:	f8cc 0004 	str.w	r0, [ip, #4]
  40689a:	6094      	str	r4, [r2, #8]
  40689c:	4630      	mov	r0, r6
  40689e:	60cc      	str	r4, [r1, #12]
  4068a0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  4068a4:	f7ff bea0 	b.w	4065e8 <__malloc_unlock>
  4068a8:	4d29      	ldr	r5, [pc, #164]	; (406950 <_free_r+0x190>)
  4068aa:	42a8      	cmp	r0, r5
  4068ac:	d1ad      	bne.n	40680a <_free_r+0x4a>
  4068ae:	f043 0201 	orr.w	r2, r3, #1
  4068b2:	f8cc 4014 	str.w	r4, [ip, #20]
  4068b6:	f8cc 4010 	str.w	r4, [ip, #16]
  4068ba:	60e0      	str	r0, [r4, #12]
  4068bc:	60a0      	str	r0, [r4, #8]
  4068be:	6062      	str	r2, [r4, #4]
  4068c0:	50e3      	str	r3, [r4, r3]
  4068c2:	e7c7      	b.n	406854 <_free_r+0x94>
  4068c4:	441f      	add	r7, r3
  4068c6:	07cb      	lsls	r3, r1, #31
  4068c8:	d407      	bmi.n	4068da <_free_r+0x11a>
  4068ca:	f855 3c08 	ldr.w	r3, [r5, #-8]
  4068ce:	1ae4      	subs	r4, r4, r3
  4068d0:	441f      	add	r7, r3
  4068d2:	68a2      	ldr	r2, [r4, #8]
  4068d4:	68e3      	ldr	r3, [r4, #12]
  4068d6:	60d3      	str	r3, [r2, #12]
  4068d8:	609a      	str	r2, [r3, #8]
  4068da:	4b1e      	ldr	r3, [pc, #120]	; (406954 <_free_r+0x194>)
  4068dc:	681b      	ldr	r3, [r3, #0]
  4068de:	f047 0201 	orr.w	r2, r7, #1
  4068e2:	429f      	cmp	r7, r3
  4068e4:	6062      	str	r2, [r4, #4]
  4068e6:	f8cc 4008 	str.w	r4, [ip, #8]
  4068ea:	d3b3      	bcc.n	406854 <_free_r+0x94>
  4068ec:	4b1a      	ldr	r3, [pc, #104]	; (406958 <_free_r+0x198>)
  4068ee:	4630      	mov	r0, r6
  4068f0:	6819      	ldr	r1, [r3, #0]
  4068f2:	f7ff ff17 	bl	406724 <_malloc_trim_r>
  4068f6:	e7ad      	b.n	406854 <_free_r+0x94>
  4068f8:	2101      	movs	r1, #1
  4068fa:	e77e      	b.n	4067fa <_free_r+0x3a>
  4068fc:	2a14      	cmp	r2, #20
  4068fe:	d80c      	bhi.n	40691a <_free_r+0x15a>
  406900:	f102 005b 	add.w	r0, r2, #91	; 0x5b
  406904:	0041      	lsls	r1, r0, #1
  406906:	e791      	b.n	40682c <_free_r+0x6c>
  406908:	684b      	ldr	r3, [r1, #4]
  40690a:	1080      	asrs	r0, r0, #2
  40690c:	2501      	movs	r5, #1
  40690e:	fa05 f000 	lsl.w	r0, r5, r0
  406912:	4303      	orrs	r3, r0
  406914:	604b      	str	r3, [r1, #4]
  406916:	4613      	mov	r3, r2
  406918:	e798      	b.n	40684c <_free_r+0x8c>
  40691a:	2a54      	cmp	r2, #84	; 0x54
  40691c:	d803      	bhi.n	406926 <_free_r+0x166>
  40691e:	0b18      	lsrs	r0, r3, #12
  406920:	306e      	adds	r0, #110	; 0x6e
  406922:	0041      	lsls	r1, r0, #1
  406924:	e782      	b.n	40682c <_free_r+0x6c>
  406926:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
  40692a:	d803      	bhi.n	406934 <_free_r+0x174>
  40692c:	0bd8      	lsrs	r0, r3, #15
  40692e:	3077      	adds	r0, #119	; 0x77
  406930:	0041      	lsls	r1, r0, #1
  406932:	e77b      	b.n	40682c <_free_r+0x6c>
  406934:	f240 5154 	movw	r1, #1364	; 0x554
  406938:	428a      	cmp	r2, r1
  40693a:	d803      	bhi.n	406944 <_free_r+0x184>
  40693c:	0c98      	lsrs	r0, r3, #18
  40693e:	307c      	adds	r0, #124	; 0x7c
  406940:	0041      	lsls	r1, r0, #1
  406942:	e773      	b.n	40682c <_free_r+0x6c>
  406944:	21fc      	movs	r1, #252	; 0xfc
  406946:	207e      	movs	r0, #126	; 0x7e
  406948:	e770      	b.n	40682c <_free_r+0x6c>
  40694a:	bf00      	nop
  40694c:	200006dc 	.word	0x200006dc
  406950:	200006e4 	.word	0x200006e4
  406954:	20000ae4 	.word	0x20000ae4
  406958:	20001164 	.word	0x20001164

0040695c <__register_exitproc>:
  40695c:	b5f0      	push	{r4, r5, r6, r7, lr}
  40695e:	4c27      	ldr	r4, [pc, #156]	; (4069fc <__register_exitproc+0xa0>)
  406960:	6826      	ldr	r6, [r4, #0]
  406962:	f8d6 4148 	ldr.w	r4, [r6, #328]	; 0x148
  406966:	b085      	sub	sp, #20
  406968:	4607      	mov	r7, r0
  40696a:	2c00      	cmp	r4, #0
  40696c:	d041      	beq.n	4069f2 <__register_exitproc+0x96>
  40696e:	6865      	ldr	r5, [r4, #4]
  406970:	2d1f      	cmp	r5, #31
  406972:	dd1e      	ble.n	4069b2 <__register_exitproc+0x56>
  406974:	4822      	ldr	r0, [pc, #136]	; (406a00 <__register_exitproc+0xa4>)
  406976:	b918      	cbnz	r0, 406980 <__register_exitproc+0x24>
  406978:	f04f 30ff 	mov.w	r0, #4294967295
  40697c:	b005      	add	sp, #20
  40697e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  406980:	f44f 70c8 	mov.w	r0, #400	; 0x190
  406984:	9103      	str	r1, [sp, #12]
  406986:	9202      	str	r2, [sp, #8]
  406988:	9301      	str	r3, [sp, #4]
  40698a:	f7ff faa3 	bl	405ed4 <malloc>
  40698e:	9903      	ldr	r1, [sp, #12]
  406990:	9a02      	ldr	r2, [sp, #8]
  406992:	9b01      	ldr	r3, [sp, #4]
  406994:	4604      	mov	r4, r0
  406996:	2800      	cmp	r0, #0
  406998:	d0ee      	beq.n	406978 <__register_exitproc+0x1c>
  40699a:	f8d6 5148 	ldr.w	r5, [r6, #328]	; 0x148
  40699e:	6025      	str	r5, [r4, #0]
  4069a0:	2000      	movs	r0, #0
  4069a2:	6060      	str	r0, [r4, #4]
  4069a4:	4605      	mov	r5, r0
  4069a6:	f8c6 4148 	str.w	r4, [r6, #328]	; 0x148
  4069aa:	f8c4 0188 	str.w	r0, [r4, #392]	; 0x188
  4069ae:	f8c4 018c 	str.w	r0, [r4, #396]	; 0x18c
  4069b2:	b93f      	cbnz	r7, 4069c4 <__register_exitproc+0x68>
  4069b4:	1cab      	adds	r3, r5, #2
  4069b6:	2000      	movs	r0, #0
  4069b8:	3501      	adds	r5, #1
  4069ba:	6065      	str	r5, [r4, #4]
  4069bc:	f844 1023 	str.w	r1, [r4, r3, lsl #2]
  4069c0:	b005      	add	sp, #20
  4069c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
  4069c4:	eb04 0085 	add.w	r0, r4, r5, lsl #2
  4069c8:	f04f 0c01 	mov.w	ip, #1
  4069cc:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
  4069d0:	f8d4 6188 	ldr.w	r6, [r4, #392]	; 0x188
  4069d4:	fa0c f205 	lsl.w	r2, ip, r5
  4069d8:	4316      	orrs	r6, r2
  4069da:	2f02      	cmp	r7, #2
  4069dc:	f8c4 6188 	str.w	r6, [r4, #392]	; 0x188
  4069e0:	f8c0 3108 	str.w	r3, [r0, #264]	; 0x108
  4069e4:	d1e6      	bne.n	4069b4 <__register_exitproc+0x58>
  4069e6:	f8d4 318c 	ldr.w	r3, [r4, #396]	; 0x18c
  4069ea:	431a      	orrs	r2, r3
  4069ec:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
  4069f0:	e7e0      	b.n	4069b4 <__register_exitproc+0x58>
  4069f2:	f506 74a6 	add.w	r4, r6, #332	; 0x14c
  4069f6:	f8c6 4148 	str.w	r4, [r6, #328]	; 0x148
  4069fa:	e7b8      	b.n	40696e <__register_exitproc+0x12>
  4069fc:	004070d0 	.word	0x004070d0
  406a00:	00405ed5 	.word	0x00405ed5

00406a04 <all_twi_definitions>:
  406a04:	40018000 40018100 00000013 00000013     ...@...@........
  406a14:	4001c000 4001c100 00000014 00000014     ...@...@........
  406a24:	69663a30 61776d72 622e6572 00006e69     0:firmware.bin..

00406a34 <sd_trans_multipliers>:
  406a34:	00000000 0000000a 0000000c 0000000d     ................
  406a44:	0000000f 00000014 00000019 0000001e     ................
  406a54:	00000023 00000028 0000002d 00000032     #...(...-...2...
  406a64:	00000037 0000003c 00000046 00000050     7...<...F...P...

00406a74 <sd_mmc_trans_units>:
  406a74:	0000000a 00000064 000003e8 00002710     ....d........'..
	...

00406a90 <mmc_trans_multipliers>:
  406a90:	00000000 0000000a 0000000c 0000000d     ................
  406aa0:	0000000f 00000014 0000001a 0000001e     ................
  406ab0:	00000023 00000028 0000002d 00000034     #...(...-...4...
  406ac0:	00000037 0000003c 00000046 00000050     7...<...F...P...

00406ad0 <lun_desc>:
  406ad0:	00401acd 00401b0d 00401b2d 00401b45     ..@...@.-.@.E.@.
  406ae0:	00401b65 00401ba9 00401c0d 00406b10     e.@...@...@..k@.
  406af0:	00401add 00401b1d 00401b39 00401b55     ..@...@.9.@.U.@.
  406b00:	00401b69 00401bbd 00401c21 00406b28     i.@...@.!.@.(k@.
  406b10:	2f445322 20434d4d 64726143 6f6c5320     "SD/MMC Card Slo
  406b20:	22302074 00000000 2f445322 20434d4d     t 0"...."SD/MMC 
  406b30:	64726143 6f6c5320 22312074 00000000     Card Slot 1"....

00406b40 <excvt.4554>:
  406b40:	b6909a80 808fb78e d8d4d3d2 8f8eded7     ................
  406b50:	e2929290 ebeae399 9d9a9959 9f9e9d9c     ........Y.......
  406b60:	e9e0d6b5 a7a6a5a5 abaaa9a8 afae21ac     .............!..
  406b70:	b3b2b1b0 b7b6b5b4 bbbab9b8 bfbebdbc     ................
  406b80:	c3c2c1c0 c7c7c5c4 cbcac9c8 cfcecdcc     ................
  406b90:	d3d2d1d0 d7d6d5d4 dbdad9d8 dfdedddc     ................
  406ba0:	e3e2e1e0 e7e6e5e5 ebeae9e7 efeeeded     ................
  406bb0:	f3f2f1f0 f7f6f5f4 fbfaf9f8 fffefdfc     ................
  406bc0:	3c3a2a22 7f7c3f3e 00000000 3d3b2c2b     "*:<>?|.....+,;=
  406bd0:	00005d5b                                []..

00406bd4 <LfnOfs>:
  406bd4:	07050301 12100e09 1c181614 0000001e     ................

00406be4 <tbl_lower.4258>:
  406be4:	00620061 00640063 00660065 00680067     a.b.c.d.e.f.g.h.
  406bf4:	006a0069 006c006b 006e006d 0070006f     i.j.k.l.m.n.o.p.
  406c04:	00720071 00740073 00760075 00780077     q.r.s.t.u.v.w.x.
  406c14:	007a0079 00a200a1 00a500a3 00af00ac     y.z.............
  406c24:	00e100e0 00e300e2 00e500e4 00e700e6     ................
  406c34:	00e900e8 00eb00ea 00ed00ec 00ef00ee     ................
  406c44:	00f100f0 00f300f2 00f500f4 00f800f6     ................
  406c54:	00fa00f9 00fc00fb 00fe00fd 010100ff     ................
  406c64:	01050103 01090107 010d010b 0111010f     ................
  406c74:	01150113 01190117 011d011b 0121011f     ..............!.
  406c84:	01250123 01290127 012d012b 0131012f     #.%.'.).+.-./.1.
  406c94:	01350133 013a0137 013e013c 01420140     3.5.7.:.<.>.@.B.
  406ca4:	01460144 014b0148 014f014d 01530151     D.F.H.K.M.O.Q.S.
  406cb4:	01570155 015b0159 015f015d 01630161     U.W.Y.[.]._.a.c.
  406cc4:	01670165 016b0169 016f016d 01730171     e.g.i.k.m.o.q.s.
  406cd4:	01770175 017c017a 0192017e 03b203b1     u.w.z.|.~.......
  406ce4:	03b403b3 03b603b5 03b803b7 03ba03b9     ................
  406cf4:	03bc03bb 03be03bd 03c003bf 03c303c1     ................
  406d04:	03c503c4 03c703c6 03c903c8 043003ca     ..............0.
  406d14:	04320431 04340433 04360435 04380437     1.2.3.4.5.6.7.8.
  406d24:	043a0439 043c043b 043e043d 0440043f     9.:.;.<.=.>.?.@.
  406d34:	04420441 04440443 04460445 04480447     A.B.C.D.E.F.G.H.
  406d44:	044a0449 044c044b 044e044d 0451044f     I.J.K.L.M.N.O.Q.
  406d54:	04530452 04550454 04570456 04590458     R.S.T.U.V.W.X.Y.
  406d64:	045b045a 045e045c 2170045f 21722171     Z.[.\.^._.p!q!r!
  406d74:	21742173 21762175 21782177 217a2179     s!t!u!v!w!x!y!z!
  406d84:	217c217b 217e217d ff41217f ff43ff42     {!|!}!~!.!A.B.C.
  406d94:	ff45ff44 ff47ff46 ff49ff48 ff4bff4a     D.E.F.G.H.I.J.K.
  406da4:	ff4dff4c ff4fff4e ff51ff50 ff53ff52     L.M.N.O.P.Q.R.S.
  406db4:	ff55ff54 ff57ff56 ff59ff58 0000ff5a     T.U.V.W.X.Y.Z...

00406dc4 <Tbl>:
  406dc4:	00fc00c7 00e200e9 00e000e4 00e700e5     ................
  406dd4:	00eb00ea 00ef00e8 00ec00ee 00c500c4     ................
  406de4:	00e600c9 00f400c6 00f200f6 00f900fb     ................
  406df4:	00d600ff 00f800dc 00d800a3 019200d7     ................
  406e04:	00ed00e1 00fa00f3 00d100f1 00ba00aa     ................
  406e14:	00ae00bf 00bd00ac 00a100bc 00bb00ab     ................
  406e24:	25922591 25022593 00c12524 00c000c2     .%.%.%.%$%......
  406e34:	256300a9 25572551 00a2255d 251000a5     ..c%Q%W%]%.....%
  406e44:	25342514 251c252c 253c2500 00c300e3     .%4%,%.%.%<%....
  406e54:	2554255a 25662569 25502560 00a4256c     Z%T%i%f%`%P%l%..
  406e64:	00d000f0 00cb00ca 013100c8 00ce00cd     ..........1.....
  406e74:	251800cf 2588250c 00a62584 258000cc     ...%.%.%.%.....%
  406e84:	00df00d3 00d200d4 00d500f5 00fe00b5     ................
  406e94:	00da00de 00d900db 00dd00fd 00b400af     ................
  406ea4:	00b100ad 00be2017 00a700b6 00b800f7     ..... ..........
  406eb4:	00a800b0 00b900b7 00b200b3 00a025a0     .............%..

00406ec4 <tbl_upper.4259>:
  406ec4:	00420041 00440043 00460045 00480047     A.B.C.D.E.F.G.H.
  406ed4:	004a0049 004c004b 004e004d 0050004f     I.J.K.L.M.N.O.P.
  406ee4:	00520051 00540053 00560055 00580057     Q.R.S.T.U.V.W.X.
  406ef4:	005a0059 ffe00021 ffe5ffe1 ffe3ffe2     Y.Z.!...........
  406f04:	00c100c0 00c300c2 00c500c4 00c700c6     ................
  406f14:	00c900c8 00cb00ca 00cd00cc 00cf00ce     ................
  406f24:	00d100d0 00d300d2 00d500d4 00d800d6     ................
  406f34:	00da00d9 00dc00db 00de00dd 01000178     ............x...
  406f44:	01040102 01080106 010c010a 0110010e     ................
  406f54:	01140112 01180116 011c011a 0120011e     .............. .
  406f64:	01240122 01280126 012c012a 0130012e     ".$.&.(.*.,...0.
  406f74:	01340132 01390136 013d013b 0141013f     2.4.6.9.;.=.?.A.
  406f84:	01450143 014a0147 014e014c 01520150     C.E.G.J.L.N.P.R.
  406f94:	01560154 015a0158 015e015c 01620160     T.V.X.Z.\.^.`.b.
  406fa4:	01660164 016a0168 016e016c 01720170     d.f.h.j.l.n.p.r.
  406fb4:	01760174 017b0179 0191017d 03920391     t.v.y.{.}.......
  406fc4:	03940393 03960395 03980397 039a0399     ................
  406fd4:	039c039b 039e039d 03a0039f 03a303a1     ................
  406fe4:	03a503a4 03a703a6 03a903a8 041003aa     ................
  406ff4:	04120411 04140413 04160415 04180417     ................
  407004:	041a0419 041c041b 041e041d 0420041f     .............. .
  407014:	04220421 04240423 04260425 04280427     !.".#.$.%.&.'.(.
  407024:	042a0429 042c042b 042e042d 0401042f     ).*.+.,.-.../...
  407034:	04030402 04050404 04070406 04090408     ................
  407044:	040b040a 040e040c 2160040f 21622161     ..........`!a!b!
  407054:	21642163 21662165 21682167 216a2169     c!d!e!f!g!h!i!j!
  407064:	216c216b 216e216d ff21216f ff23ff22     k!l!m!n!o!!.".#.
  407074:	ff25ff24 ff27ff26 ff29ff28 ff2bff2a     $.%.&.'.(.).*.+.
  407084:	ff2dff2c ff2fff2e ff31ff30 ff33ff32     ,.-.../.0.1.2.3.
  407094:	ff35ff34 ff37ff36 ff39ff38 0000ff3a     4.5.6.7.8.9.:...
  4070a4:	74736552 69747261 7320676e 65747379     Restarting syste
  4070b4:	2121216d 0000000d                       m!!!....

004070bc <CSWTCH.21>:
  4070bc:	00000070 00000050 00000030 00000010     p...P...0.......
  4070cc:	00000043                                C...

004070d0 <_global_impure_ptr>:
  4070d0:	200002b0                                ... 

004070d4 <_init>:
  4070d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  4070d6:	bf00      	nop
  4070d8:	bcf8      	pop	{r3, r4, r5, r6, r7}
  4070da:	bc08      	pop	{r3}
  4070dc:	469e      	mov	lr, r3
  4070de:	4770      	bx	lr

004070e0 <__init_array_start>:
  4070e0:	004066d5 	.word	0x004066d5

004070e4 <__frame_dummy_init_array_entry>:
  4070e4:	004000f1                                ..@.

004070e8 <_fini>:
  4070e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  4070ea:	bf00      	nop
  4070ec:	bcf8      	pop	{r3, r4, r5, r6, r7}
  4070ee:	bc08      	pop	{r3}
  4070f0:	469e      	mov	lr, r3
  4070f2:	4770      	bx	lr

004070f4 <__fini_array_start>:
  4070f4:	004000cd 	.word	0x004000cd

Disassembly of section .relocate:

20000000 <efc_perform_read_sequence>:
__no_inline
RAMFUNC
uint32_t efc_perform_read_sequence(Efc *p_efc,
		uint32_t ul_cmd_st, uint32_t ul_cmd_sp,
		uint32_t *p_ul_buf, uint32_t ul_size)
{
20000000:	b470      	push	{r4, r5, r6}
20000002:	b083      	sub	sp, #12
20000004:	9e06      	ldr	r6, [sp, #24]
	uint32_t *p_ul_data = (uint32_t *) READ_BUFF_ADDR;
#else
	return EFC_RC_NOT_SUPPORT;
#endif

	if (p_ul_buf == NULL) {
20000006:	b343      	cbz	r3, 2000005a <efc_perform_read_sequence+0x5a>
		return EFC_RC_INVALID;
	}

	p_efc->EEFC_FMR |= (0x1u << 16);
20000008:	6804      	ldr	r4, [r0, #0]

	/* Send the Start Read command */
#if (SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM)
	p_efc->EEFC_FCR = EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(0)
			| EEFC_FCR_FCMD(ul_cmd_st);
2000000a:	b2c9      	uxtb	r1, r1
2000000c:	f041 41b4 	orr.w	r1, r1, #1509949440	; 0x5a000000

	if (p_ul_buf == NULL) {
		return EFC_RC_INVALID;
	}

	p_efc->EEFC_FMR |= (0x1u << 16);
20000010:	f444 3480 	orr.w	r4, r4, #65536	; 0x10000
20000014:	6004      	str	r4, [r0, #0]

	/* Send the Start Read command */
#if (SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM)
	p_efc->EEFC_FCR = EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(0)
20000016:	6041      	str	r1, [r0, #4]
#endif
	/* Wait for the FRDY bit in the Flash Programming Status Register
	 * (EEFC_FSR) falls.
	 */
	do {
		ul_status = p_efc->EEFC_FSR;
20000018:	6881      	ldr	r1, [r0, #8]
2000001a:	9101      	str	r1, [sp, #4]
	} while ((ul_status & EEFC_FSR_FRDY) == EEFC_FSR_FRDY);
2000001c:	9901      	ldr	r1, [sp, #4]
2000001e:	f011 0101 	ands.w	r1, r1, #1
20000022:	d1f9      	bne.n	20000018 <efc_perform_read_sequence+0x18>

	/* The data is located in the first address of the Flash
	 * memory mapping.
	 */
	for (ul_cnt = 0; ul_cnt < ul_size; ul_cnt++) {
20000024:	b146      	cbz	r6, 20000038 <efc_perform_read_sequence+0x38>
20000026:	4c0f      	ldr	r4, [pc, #60]	; (20000064 <efc_perform_read_sequence+0x64>)
20000028:	eb03 0686 	add.w	r6, r3, r6, lsl #2
		p_ul_buf[ul_cnt] = p_ul_data[ul_cnt];
2000002c:	f854 5f04 	ldr.w	r5, [r4, #4]!
20000030:	f843 5b04 	str.w	r5, [r3], #4
	} while ((ul_status & EEFC_FSR_FRDY) == EEFC_FSR_FRDY);

	/* The data is located in the first address of the Flash
	 * memory mapping.
	 */
	for (ul_cnt = 0; ul_cnt < ul_size; ul_cnt++) {
20000034:	42b3      	cmp	r3, r6
20000036:	d1f9      	bne.n	2000002c <efc_perform_read_sequence+0x2c>

	/* To stop the read mode */
	p_efc->EEFC_FCR =
#if (SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM)
			EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(0) |
			EEFC_FCR_FCMD(ul_cmd_sp);
20000038:	b2d2      	uxtb	r2, r2
	}

	/* To stop the read mode */
	p_efc->EEFC_FCR =
#if (SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM)
			EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(0) |
2000003a:	f042 42b4 	orr.w	r2, r2, #1509949440	; 0x5a000000
	for (ul_cnt = 0; ul_cnt < ul_size; ul_cnt++) {
		p_ul_buf[ul_cnt] = p_ul_data[ul_cnt];
	}

	/* To stop the read mode */
	p_efc->EEFC_FCR =
2000003e:	6042      	str	r2, [r0, #4]
#endif
	/* Wait for the FRDY bit in the Flash Programming Status Register (EEFC_FSR)
	 * rises.
	 */
	do {
		ul_status = p_efc->EEFC_FSR;
20000040:	6883      	ldr	r3, [r0, #8]
20000042:	9301      	str	r3, [sp, #4]
	} while ((ul_status & EEFC_FSR_FRDY) != EEFC_FSR_FRDY);
20000044:	9b01      	ldr	r3, [sp, #4]
20000046:	07db      	lsls	r3, r3, #31
20000048:	d5fa      	bpl.n	20000040 <efc_perform_read_sequence+0x40>

	p_efc->EEFC_FMR &= ~(0x1u << 16);
2000004a:	6803      	ldr	r3, [r0, #0]
2000004c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
20000050:	6003      	str	r3, [r0, #0]

	return EFC_RC_OK;
}
20000052:	4608      	mov	r0, r1
20000054:	b003      	add	sp, #12
20000056:	bc70      	pop	{r4, r5, r6}
20000058:	4770      	bx	lr
#else
	return EFC_RC_NOT_SUPPORT;
#endif

	if (p_ul_buf == NULL) {
		return EFC_RC_INVALID;
2000005a:	2102      	movs	r1, #2
	} while ((ul_status & EEFC_FSR_FRDY) != EEFC_FSR_FRDY);

	p_efc->EEFC_FMR &= ~(0x1u << 16);

	return EFC_RC_OK;
}
2000005c:	4608      	mov	r0, r1
2000005e:	b003      	add	sp, #12
20000060:	bc70      	pop	{r4, r5, r6}
20000062:	4770      	bx	lr
20000064:	003ffffc 	.word	0x003ffffc

20000068 <efc_write_fmr>:
 */
__no_inline
RAMFUNC
void efc_write_fmr(Efc *p_efc, uint32_t ul_fmr)
{
	p_efc->EEFC_FMR = ul_fmr;
20000068:	6001      	str	r1, [r0, #0]
2000006a:	4770      	bx	lr

2000006c <efc_perform_fcr>:
 * \return The current status.
 */
__no_inline
RAMFUNC
uint32_t efc_perform_fcr(Efc *p_efc, uint32_t ul_fcr)
{
2000006c:	b082      	sub	sp, #8
	volatile uint32_t ul_status;

	p_efc->EEFC_FCR = ul_fcr;
2000006e:	6041      	str	r1, [r0, #4]
	do {
		ul_status = p_efc->EEFC_FSR;
20000070:	6883      	ldr	r3, [r0, #8]
20000072:	9301      	str	r3, [sp, #4]
	} while ((ul_status & EEFC_FSR_FRDY) != EEFC_FSR_FRDY);
20000074:	9b01      	ldr	r3, [sp, #4]
20000076:	07db      	lsls	r3, r3, #31
20000078:	d5fa      	bpl.n	20000070 <efc_perform_fcr+0x4>

	return (ul_status & EEFC_ERROR_FLAGS);
2000007a:	9801      	ldr	r0, [sp, #4]
}
2000007c:	f000 000e 	and.w	r0, r0, #14
20000080:	b002      	add	sp, #8
20000082:	4770      	bx	lr

20000084 <portable_delay_cycles>:
RAMFUNC
void portable_delay_cycles(unsigned long n)
{
	UNUSED(n);

	__asm (
20000084:	f3bf 8f5f 	dmb	sy
20000088:	3801      	subs	r0, #1
2000008a:	d1fb      	bne.n	20000084 <portable_delay_cycles>
2000008c:	4770      	bx	lr
2000008e:	bf00      	nop

20000090 <sd_mmc_cards>:
	...
20000098:	002b 0000 0000 0000 0000 0000 0000 0000     +...............
	...

200000b4 <uxCriticalNesting>:
200000b4:	aaaa aaaa                                   ....

200000b8 <uxPreviousTask>:
200000b8:	00ff 0000                                   ....

200000bc <xNextTaskUnblockTime>:
200000bc:	ffff ffff                                   ....

200000c0 <brainSettings>:
	...
2000015c:	0000 0001 0000 0000 0000 0000 0000 0000     ................
	...

20000178 <gpioConfig>:
20000178:	0000 0000 0001 0001 4b09 0040 0101 0000     .........K@.....
20000188:	0001 0000 0001 0001 4ac9 0040 0101 0000     .........J@.....
20000198:	0014 0000 0001 0001 4a85 0040 0101 0000     .........J@.....
200001a8:	0010 0000 0001 0001 4a41 0040 0101 0000     ........AJ@.....
200001b8:	000f 0000 0001 0001 49fd 0040 0101 0000     .........I@.....
200001c8:	0018 0000 0001 0001 49b9 0040 0100 0000     .........I@.....
200001d8:	0019 0000 0001 0001 4975 0040 0100 0000     ........uI@.....
200001e8:	0013 0000 0100 0004 0000 0000 0000 0100     ................
200001f8:	0017 0000 0100 0004 0000 0000 0000 0100     ................
20000208:	002a 0000 0100 0004 0000 0000 0100 0100     *...............
20000218:	0011 0000 0100 0004 0000 0000 0100 0100     ................
20000228:	0012 0000 0100 0004 0000 0000 0100 0100     ................
20000238:	002d 0000 0100 0004 0000 0000 0000 0100     -...............
20000248:	0020 0000 0100 0004 0000 0000 0000 0100      ...............
20000258:	0021 0000 0100 0004 0000 0000 0000 0100     !...............
20000268:	000b 0000 0001 0001 4931 0040 0101 0000     ........1I@.....
20000278:	002b 0000 0001 0001 48ed 0040 0101 0000     +........H@.....
20000288:	000c 0000 0000 0004 0000 0000 0000 0000     ................
20000298:	0002 0000 0000 0004 0000 0000 0000 0100     ................

200002a8 <g_interrupt_enabled>:
200002a8:	0001 0000                                   ....

200002ac <SystemCoreClock>:
200002ac:	0900 003d                                   ..=.

200002b0 <impure_data>:
200002b0:	0000 0000 059c 2000 0604 2000 066c 2000     ....... ... l.. 
	...
200002e4:	70cc 0040 0000 0000 0000 0000 0000 0000     .p@.............
	...
20000358:	0001 0000 0000 0000 330e abcd 1234 e66d     .........3..4.m.
20000368:	deec 0005 000b 0000 0000 0000 0000 0000     ................
	...

200006d8 <_impure_ptr>:
200006d8:	02b0 2000                                   ... 

200006dc <__malloc_av_>:
	...
200006e4:	06dc 2000 06dc 2000 06e4 2000 06e4 2000     ... ... ... ... 
200006f4:	06ec 2000 06ec 2000 06f4 2000 06f4 2000     ... ... ... ... 
20000704:	06fc 2000 06fc 2000 0704 2000 0704 2000     ... ... ... ... 
20000714:	070c 2000 070c 2000 0714 2000 0714 2000     ... ... ... ... 
20000724:	071c 2000 071c 2000 0724 2000 0724 2000     ... ... $.. $.. 
20000734:	072c 2000 072c 2000 0734 2000 0734 2000     ,.. ,.. 4.. 4.. 
20000744:	073c 2000 073c 2000 0744 2000 0744 2000     <.. <.. D.. D.. 
20000754:	074c 2000 074c 2000 0754 2000 0754 2000     L.. L.. T.. T.. 
20000764:	075c 2000 075c 2000 0764 2000 0764 2000     \.. \.. d.. d.. 
20000774:	076c 2000 076c 2000 0774 2000 0774 2000     l.. l.. t.. t.. 
20000784:	077c 2000 077c 2000 0784 2000 0784 2000     |.. |.. ... ... 
20000794:	078c 2000 078c 2000 0794 2000 0794 2000     ... ... ... ... 
200007a4:	079c 2000 079c 2000 07a4 2000 07a4 2000     ... ... ... ... 
200007b4:	07ac 2000 07ac 2000 07b4 2000 07b4 2000     ... ... ... ... 
200007c4:	07bc 2000 07bc 2000 07c4 2000 07c4 2000     ... ... ... ... 
200007d4:	07cc 2000 07cc 2000 07d4 2000 07d4 2000     ... ... ... ... 
200007e4:	07dc 2000 07dc 2000 07e4 2000 07e4 2000     ... ... ... ... 
200007f4:	07ec 2000 07ec 2000 07f4 2000 07f4 2000     ... ... ... ... 
20000804:	07fc 2000 07fc 2000 0804 2000 0804 2000     ... ... ... ... 
20000814:	080c 2000 080c 2000 0814 2000 0814 2000     ... ... ... ... 
20000824:	081c 2000 081c 2000 0824 2000 0824 2000     ... ... $.. $.. 
20000834:	082c 2000 082c 2000 0834 2000 0834 2000     ,.. ,.. 4.. 4.. 
20000844:	083c 2000 083c 2000 0844 2000 0844 2000     <.. <.. D.. D.. 
20000854:	084c 2000 084c 2000 0854 2000 0854 2000     L.. L.. T.. T.. 
20000864:	085c 2000 085c 2000 0864 2000 0864 2000     \.. \.. d.. d.. 
20000874:	086c 2000 086c 2000 0874 2000 0874 2000     l.. l.. t.. t.. 
20000884:	087c 2000 087c 2000 0884 2000 0884 2000     |.. |.. ... ... 
20000894:	088c 2000 088c 2000 0894 2000 0894 2000     ... ... ... ... 
200008a4:	089c 2000 089c 2000 08a4 2000 08a4 2000     ... ... ... ... 
200008b4:	08ac 2000 08ac 2000 08b4 2000 08b4 2000     ... ... ... ... 
200008c4:	08bc 2000 08bc 2000 08c4 2000 08c4 2000     ... ... ... ... 
200008d4:	08cc 2000 08cc 2000 08d4 2000 08d4 2000     ... ... ... ... 
200008e4:	08dc 2000 08dc 2000 08e4 2000 08e4 2000     ... ... ... ... 
200008f4:	08ec 2000 08ec 2000 08f4 2000 08f4 2000     ... ... ... ... 
20000904:	08fc 2000 08fc 2000 0904 2000 0904 2000     ... ... ... ... 
20000914:	090c 2000 090c 2000 0914 2000 0914 2000     ... ... ... ... 
20000924:	091c 2000 091c 2000 0924 2000 0924 2000     ... ... $.. $.. 
20000934:	092c 2000 092c 2000 0934 2000 0934 2000     ,.. ,.. 4.. 4.. 
20000944:	093c 2000 093c 2000 0944 2000 0944 2000     <.. <.. D.. D.. 
20000954:	094c 2000 094c 2000 0954 2000 0954 2000     L.. L.. T.. T.. 
20000964:	095c 2000 095c 2000 0964 2000 0964 2000     \.. \.. d.. d.. 
20000974:	096c 2000 096c 2000 0974 2000 0974 2000     l.. l.. t.. t.. 
20000984:	097c 2000 097c 2000 0984 2000 0984 2000     |.. |.. ... ... 
20000994:	098c 2000 098c 2000 0994 2000 0994 2000     ... ... ... ... 
200009a4:	099c 2000 099c 2000 09a4 2000 09a4 2000     ... ... ... ... 
200009b4:	09ac 2000 09ac 2000 09b4 2000 09b4 2000     ... ... ... ... 
200009c4:	09bc 2000 09bc 2000 09c4 2000 09c4 2000     ... ... ... ... 
200009d4:	09cc 2000 09cc 2000 09d4 2000 09d4 2000     ... ... ... ... 
200009e4:	09dc 2000 09dc 2000 09e4 2000 09e4 2000     ... ... ... ... 
200009f4:	09ec 2000 09ec 2000 09f4 2000 09f4 2000     ... ... ... ... 
20000a04:	09fc 2000 09fc 2000 0a04 2000 0a04 2000     ... ... ... ... 
20000a14:	0a0c 2000 0a0c 2000 0a14 2000 0a14 2000     ... ... ... ... 
20000a24:	0a1c 2000 0a1c 2000 0a24 2000 0a24 2000     ... ... $.. $.. 
20000a34:	0a2c 2000 0a2c 2000 0a34 2000 0a34 2000     ,.. ,.. 4.. 4.. 
20000a44:	0a3c 2000 0a3c 2000 0a44 2000 0a44 2000     <.. <.. D.. D.. 
20000a54:	0a4c 2000 0a4c 2000 0a54 2000 0a54 2000     L.. L.. T.. T.. 
20000a64:	0a5c 2000 0a5c 2000 0a64 2000 0a64 2000     \.. \.. d.. d.. 
20000a74:	0a6c 2000 0a6c 2000 0a74 2000 0a74 2000     l.. l.. t.. t.. 
20000a84:	0a7c 2000 0a7c 2000 0a84 2000 0a84 2000     |.. |.. ... ... 
20000a94:	0a8c 2000 0a8c 2000 0a94 2000 0a94 2000     ... ... ... ... 
20000aa4:	0a9c 2000 0a9c 2000 0aa4 2000 0aa4 2000     ... ... ... ... 
20000ab4:	0aac 2000 0aac 2000 0ab4 2000 0ab4 2000     ... ... ... ... 
20000ac4:	0abc 2000 0abc 2000 0ac4 2000 0ac4 2000     ... ... ... ... 
20000ad4:	0acc 2000 0acc 2000 0ad4 2000 0ad4 2000     ... ... ... ... 

20000ae4 <__malloc_trim_threshold>:
20000ae4:	0000 0002                                   ....

20000ae8 <__malloc_sbrk_base>:
20000ae8:	ffff ffff                                   ....
