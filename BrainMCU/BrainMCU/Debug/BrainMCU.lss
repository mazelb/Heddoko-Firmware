
BrainMCU.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00017294  00400000  00400000  00008000  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000008  00417294  00417294  0001f294  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .relocate     00000fac  20000000  0041729c  00020000  2**3
                  CONTENTS, ALLOC, LOAD, CODE
  3 .bss          00004094  20000fac  00418248  00020fac  2**2
                  ALLOC
  4 .stack        00003000  20005040  0041c2dc  00020fac  2**0
                  ALLOC
  5 .ARM.attributes 0000002a  00000000  00000000  00020fac  2**0
                  CONTENTS, READONLY
  6 .comment      0000005b  00000000  00000000  00020fd6  2**0
                  CONTENTS, READONLY
  7 .debug_info   00030435  00000000  00000000  00021031  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00007754  00000000  00000000  00051466  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00018174  00000000  00000000  00058bba  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 000019c0  00000000  00000000  00070d2e  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00002cb0  00000000  00000000  000726ee  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  00011a17  00000000  00000000  0007539e  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0002cbdd  00000000  00000000  00086db5  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0005e675  00000000  00000000  000b3992  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  0000542c  00000000  00000000  00112008  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00400000 <_sfixed>:
  400000:	20008040 	.word	0x20008040
  400004:	0040b2ed 	.word	0x0040b2ed
  400008:	0040b2e9 	.word	0x0040b2e9
  40000c:	0040b515 	.word	0x0040b515
  400010:	0040b519 	.word	0x0040b519
  400014:	0040b51d 	.word	0x0040b51d
  400018:	0040b521 	.word	0x0040b521
	...
  40002c:	0040665d 	.word	0x0040665d
  400030:	0040b2e9 	.word	0x0040b2e9
  400034:	00000000 	.word	0x00000000
  400038:	00406715 	.word	0x00406715
  40003c:	0040b525 	.word	0x0040b525
  400040:	0040b2e9 	.word	0x0040b2e9
  400044:	0040b2e9 	.word	0x0040b2e9
  400048:	0040b2e9 	.word	0x0040b2e9
  40004c:	0040b2e9 	.word	0x0040b2e9
  400050:	00407d49 	.word	0x00407d49
  400054:	0040b2e9 	.word	0x0040b2e9
  400058:	0040b2e9 	.word	0x0040b2e9
  40005c:	00000000 	.word	0x00000000
  400060:	00409159 	.word	0x00409159
  400064:	004091a1 	.word	0x004091a1
  400068:	00000000 	.word	0x00000000
  40006c:	0040b0ed 	.word	0x0040b0ed
  400070:	0040b101 	.word	0x0040b101
  400074:	00000000 	.word	0x00000000
  400078:	004091f1 	.word	0x004091f1
  40007c:	00409241 	.word	0x00409241
	...
  400088:	0040b2e9 	.word	0x0040b2e9
  40008c:	00400301 	.word	0x00400301
  400090:	00400311 	.word	0x00400311
  400094:	0040b2e9 	.word	0x0040b2e9
  400098:	0040b2e9 	.word	0x0040b2e9
  40009c:	0040b2e9 	.word	0x0040b2e9
  4000a0:	0040b2e9 	.word	0x0040b2e9
  4000a4:	0040b2e9 	.word	0x0040b2e9
	...
  4000b4:	0040b2e9 	.word	0x0040b2e9
  4000b8:	0040b2e9 	.word	0x0040b2e9
  4000bc:	0040b2e9 	.word	0x0040b2e9
  4000c0:	0040b2e9 	.word	0x0040b2e9
  4000c4:	0040b2e9 	.word	0x0040b2e9
  4000c8:	0040b2e9 	.word	0x0040b2e9

004000cc <__do_global_dtors_aux>:
  4000cc:	b510      	push	{r4, lr}
  4000ce:	4c05      	ldr	r4, [pc, #20]	; (4000e4 <__do_global_dtors_aux+0x18>)
  4000d0:	7823      	ldrb	r3, [r4, #0]
  4000d2:	b933      	cbnz	r3, 4000e2 <__do_global_dtors_aux+0x16>
  4000d4:	4b04      	ldr	r3, [pc, #16]	; (4000e8 <__do_global_dtors_aux+0x1c>)
  4000d6:	b113      	cbz	r3, 4000de <__do_global_dtors_aux+0x12>
  4000d8:	4804      	ldr	r0, [pc, #16]	; (4000ec <__do_global_dtors_aux+0x20>)
  4000da:	f3af 8000 	nop.w
  4000de:	2301      	movs	r3, #1
  4000e0:	7023      	strb	r3, [r4, #0]
  4000e2:	bd10      	pop	{r4, pc}
  4000e4:	20000fac 	.word	0x20000fac
  4000e8:	00000000 	.word	0x00000000
  4000ec:	0041729c 	.word	0x0041729c

004000f0 <frame_dummy>:
  4000f0:	b508      	push	{r3, lr}
  4000f2:	4b06      	ldr	r3, [pc, #24]	; (40010c <frame_dummy+0x1c>)
  4000f4:	b11b      	cbz	r3, 4000fe <frame_dummy+0xe>
  4000f6:	4806      	ldr	r0, [pc, #24]	; (400110 <frame_dummy+0x20>)
  4000f8:	4906      	ldr	r1, [pc, #24]	; (400114 <frame_dummy+0x24>)
  4000fa:	f3af 8000 	nop.w
  4000fe:	4806      	ldr	r0, [pc, #24]	; (400118 <frame_dummy+0x28>)
  400100:	6803      	ldr	r3, [r0, #0]
  400102:	b113      	cbz	r3, 40010a <frame_dummy+0x1a>
  400104:	4b05      	ldr	r3, [pc, #20]	; (40011c <frame_dummy+0x2c>)
  400106:	b103      	cbz	r3, 40010a <frame_dummy+0x1a>
  400108:	4798      	blx	r3
  40010a:	bd08      	pop	{r3, pc}
  40010c:	00000000 	.word	0x00000000
  400110:	0041729c 	.word	0x0041729c
  400114:	20000fb0 	.word	0x20000fb0
  400118:	0041729c 	.word	0x0041729c
  40011c:	00000000 	.word	0x00000000

00400120 <local_twi_handler>:
/*
 * For internal use only.
 * A common TWI interrupt handler that is called for all TWI peripherals.
 */
static void local_twi_handler(const portBASE_TYPE twi_index)
{
  400120:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	portBASE_TYPE higher_priority_task_woken = pdFALSE;
	uint32_t twi_status;
	Twi *twi_port;
	bool transfer_timeout = false;

	twi_port = all_twi_definitions[twi_index].peripheral_base_address;
  400124:	0107      	lsls	r7, r0, #4
  400126:	f8df 81d4 	ldr.w	r8, [pc, #468]	; 4002fc <local_twi_handler+0x1dc>

	twi_status = twi_get_interrupt_status(twi_port);
  40012a:	4b6b      	ldr	r3, [pc, #428]	; (4002d8 <local_twi_handler+0x1b8>)
	portBASE_TYPE higher_priority_task_woken = pdFALSE;
	uint32_t twi_status;
	Twi *twi_port;
	bool transfer_timeout = false;

	twi_port = all_twi_definitions[twi_index].peripheral_base_address;
  40012c:	f858 5007 	ldr.w	r5, [r8, r7]
/*
 * For internal use only.
 * A common TWI interrupt handler that is called for all TWI peripherals.
 */
static void local_twi_handler(const portBASE_TYPE twi_index)
{
  400130:	b083      	sub	sp, #12
  400132:	4606      	mov	r6, r0
	portBASE_TYPE higher_priority_task_woken = pdFALSE;
  400134:	2400      	movs	r4, #0
	Twi *twi_port;
	bool transfer_timeout = false;

	twi_port = all_twi_definitions[twi_index].peripheral_base_address;

	twi_status = twi_get_interrupt_status(twi_port);
  400136:	4628      	mov	r0, r5
 * For internal use only.
 * A common TWI interrupt handler that is called for all TWI peripherals.
 */
static void local_twi_handler(const portBASE_TYPE twi_index)
{
	portBASE_TYPE higher_priority_task_woken = pdFALSE;
  400138:	9401      	str	r4, [sp, #4]
	Twi *twi_port;
	bool transfer_timeout = false;

	twi_port = all_twi_definitions[twi_index].peripheral_base_address;

	twi_status = twi_get_interrupt_status(twi_port);
  40013a:	4798      	blx	r3
	twi_status &= twi_get_interrupt_mask(twi_port);
  40013c:	4b67      	ldr	r3, [pc, #412]	; (4002dc <local_twi_handler+0x1bc>)
	Twi *twi_port;
	bool transfer_timeout = false;

	twi_port = all_twi_definitions[twi_index].peripheral_base_address;

	twi_status = twi_get_interrupt_status(twi_port);
  40013e:	4682      	mov	sl, r0
	twi_status &= twi_get_interrupt_mask(twi_port);
  400140:	4628      	mov	r0, r5
  400142:	4798      	blx	r3
  400144:	ea00 0a0a 	and.w	sl, r0, sl

	/* Has the PDC completed a transmission? */
	if ((twi_status & TWI_SR_ENDTX) != 0UL) {
  400148:	f41a 5900 	ands.w	r9, sl, #8192	; 0x2000
	portBASE_TYPE higher_priority_task_woken = pdFALSE;
	uint32_t twi_status;
	Twi *twi_port;
	bool transfer_timeout = false;

	twi_port = all_twi_definitions[twi_index].peripheral_base_address;
  40014c:	eb08 0307 	add.w	r3, r8, r7

	twi_status = twi_get_interrupt_status(twi_port);
	twi_status &= twi_get_interrupt_mask(twi_port);

	/* Has the PDC completed a transmission? */
	if ((twi_status & TWI_SR_ENDTX) != 0UL) {
  400150:	d179      	bne.n	400246 <local_twi_handler+0x126>
			}
		}
	}

	/* Has the PDC completed a reception? */
	if ((twi_status & TWI_SR_ENDRX) != 0UL) {
  400152:	f41a 5f80 	tst.w	sl, #4096	; 0x1000
  400156:	d12c      	bne.n	4001b2 <local_twi_handler+0x92>
						&higher_priority_task_woken);
			}
		}
	}

	if (((twi_status & SR_ERROR_INTERRUPTS) != 0) || (transfer_timeout == true)) {
  400158:	f41a 7f50 	tst.w	sl, #832	; 0x340
  40015c:	d109      	bne.n	400172 <local_twi_handler+0x52>
  40015e:	f1b9 0f00 	cmp.w	r9, #0
  400162:	d106      	bne.n	400172 <local_twi_handler+0x52>
	has a priority equal to or higher than the currently running task (the task
	this ISR interrupted), then higher_priority_task_woken will have
	automatically been set to pdTRUE within the semaphore function.
	portEND_SWITCHING_ISR() will then ensure that this ISR returns directly to
	the higher priority unblocked task. */
	portEND_SWITCHING_ISR(higher_priority_task_woken);
  400164:	9b01      	ldr	r3, [sp, #4]
  400166:	b10b      	cbz	r3, 40016c <local_twi_handler+0x4c>
  400168:	4b5d      	ldr	r3, [pc, #372]	; (4002e0 <local_twi_handler+0x1c0>)
  40016a:	4798      	blx	r3
}
  40016c:	b003      	add	sp, #12
  40016e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		Stop the transmission, disable interrupts used by the peripheral, and
		ensure the peripheral access mutex is made available to tasks.  As this
		peripheral is half duplex, only the Tx peripheral access mutex exits.*/

		/* Stop the PDC */
		pdc_disable_transfer(all_twi_definitions[twi_index].pdc_base_address, PERIPH_PTCR_TXTDIS | PERIPH_PTCR_RXTDIS);
  400172:	4447      	add	r7, r8
  400174:	4b5b      	ldr	r3, [pc, #364]	; (4002e4 <local_twi_handler+0x1c4>)
  400176:	6878      	ldr	r0, [r7, #4]

		if (!(twi_status & TWI_SR_NACK)) {
			/* Do not send stop if NACK received. Handled by hardware */
			twi_port->TWI_CR = TWI_CR_STOP;
		}
		twi_disable_interrupt(twi_port, TWI_IDR_ENDTX);
  400178:	4c5b      	ldr	r4, [pc, #364]	; (4002e8 <local_twi_handler+0x1c8>)
		Stop the transmission, disable interrupts used by the peripheral, and
		ensure the peripheral access mutex is made available to tasks.  As this
		peripheral is half duplex, only the Tx peripheral access mutex exits.*/

		/* Stop the PDC */
		pdc_disable_transfer(all_twi_definitions[twi_index].pdc_base_address, PERIPH_PTCR_TXTDIS | PERIPH_PTCR_RXTDIS);
  40017a:	f240 2102 	movw	r1, #514	; 0x202
  40017e:	4798      	blx	r3

		if (!(twi_status & TWI_SR_NACK)) {
  400180:	f41a 7f80 	tst.w	sl, #256	; 0x100
			/* Do not send stop if NACK received. Handled by hardware */
			twi_port->TWI_CR = TWI_CR_STOP;
  400184:	bf04      	itt	eq
  400186:	2302      	moveq	r3, #2
  400188:	602b      	streq	r3, [r5, #0]
		}
		twi_disable_interrupt(twi_port, TWI_IDR_ENDTX);
  40018a:	4628      	mov	r0, r5
  40018c:	f44f 5100 	mov.w	r1, #8192	; 0x2000
  400190:	47a0      	blx	r4
		twi_disable_interrupt(twi_port, TWI_IDR_ENDRX);
  400192:	4628      	mov	r0, r5
  400194:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  400198:	47a0      	blx	r4

		if (tx_dma_control[twi_index].peripheral_access_mutex != NULL) {
  40019a:	4b54      	ldr	r3, [pc, #336]	; (4002ec <local_twi_handler+0x1cc>)
  40019c:	eb03 06c6 	add.w	r6, r3, r6, lsl #3
  4001a0:	6870      	ldr	r0, [r6, #4]
  4001a2:	2800      	cmp	r0, #0
  4001a4:	d0de      	beq.n	400164 <local_twi_handler+0x44>
			xSemaphoreGiveFromISR(
  4001a6:	2100      	movs	r1, #0
  4001a8:	460b      	mov	r3, r1
  4001aa:	aa01      	add	r2, sp, #4
  4001ac:	4c50      	ldr	r4, [pc, #320]	; (4002f0 <local_twi_handler+0x1d0>)
  4001ae:	47a0      	blx	r4
  4001b0:	e7d8      	b.n	400164 <local_twi_handler+0x44>
	if ((twi_status & TWI_SR_ENDRX) != 0UL) {
		uint32_t timeout_counter = 0;
		uint32_t status;
		/* Must handle the two last bytes */
		/* Disable PDC */
		pdc_disable_transfer(all_twi_definitions[twi_index].pdc_base_address, PERIPH_PTCR_RXTDIS);
  4001b2:	eb08 0307 	add.w	r3, r8, r7
  4001b6:	2102      	movs	r1, #2
  4001b8:	6858      	ldr	r0, [r3, #4]
  4001ba:	4b4a      	ldr	r3, [pc, #296]	; (4002e4 <local_twi_handler+0x1c4>)
  4001bc:	4798      	blx	r3

		twi_disable_interrupt(twi_port, TWI_IDR_ENDRX);
  4001be:	4628      	mov	r0, r5
  4001c0:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  4001c4:	4b48      	ldr	r3, [pc, #288]	; (4002e8 <local_twi_handler+0x1c8>)
  4001c6:	4798      	blx	r3
		}
	}

	/* Has the PDC completed a reception? */
	if ((twi_status & TWI_SR_ENDRX) != 0UL) {
		uint32_t timeout_counter = 0;
  4001c8:	2400      	movs	r4, #0
  4001ca:	e002      	b.n	4001d2 <local_twi_handler+0xb2>
			status = twi_port->TWI_SR;
			if (status & TWI_SR_RXRDY) {
				break;
			}
			/* Check timeout condition. */
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
  4001cc:	3401      	adds	r4, #1
  4001ce:	1c63      	adds	r3, r4, #1
  4001d0:	d002      	beq.n	4001d8 <local_twi_handler+0xb8>

		twi_disable_interrupt(twi_port, TWI_IDR_ENDRX);

		/* Wait for RX ready flag */
		while (1) {
			status = twi_port->TWI_SR;
  4001d2:	6a2b      	ldr	r3, [r5, #32]
			if (status & TWI_SR_RXRDY) {
  4001d4:	079a      	lsls	r2, r3, #30
  4001d6:	d5f9      	bpl.n	4001cc <local_twi_handler+0xac>
			}
		}
		/* Complete the transfer. */
		twi_port->TWI_CR = TWI_CR_STOP;
		/* Read second last data */
		twis[twi_index].buffer[(twis[twi_index].length)-2] = twi_port->TWI_RHR;
  4001d8:	4b46      	ldr	r3, [pc, #280]	; (4002f4 <local_twi_handler+0x1d4>)
  4001da:	00f2      	lsls	r2, r6, #3
  4001dc:	1899      	adds	r1, r3, r2
  4001de:	f853 0036 	ldr.w	r0, [r3, r6, lsl #3]
  4001e2:	6849      	ldr	r1, [r1, #4]
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
				break;
			}
		}
		/* Complete the transfer. */
		twi_port->TWI_CR = TWI_CR_STOP;
  4001e4:	2302      	movs	r3, #2
  4001e6:	602b      	str	r3, [r5, #0]
		/* Read second last data */
		twis[twi_index].buffer[(twis[twi_index].length)-2] = twi_port->TWI_RHR;
  4001e8:	4401      	add	r1, r0
  4001ea:	6b2b      	ldr	r3, [r5, #48]	; 0x30
  4001ec:	f801 3c02 	strb.w	r3, [r1, #-2]
  4001f0:	e002      	b.n	4001f8 <local_twi_handler+0xd8>
			status = twi_port->TWI_SR;
			if (status & TWI_SR_RXRDY) {
				break;
			}
			/* Check timeout condition. */
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
  4001f2:	3401      	adds	r4, #1
  4001f4:	1c63      	adds	r3, r4, #1
  4001f6:	d00f      	beq.n	400218 <local_twi_handler+0xf8>
		/* Read second last data */
		twis[twi_index].buffer[(twis[twi_index].length)-2] = twi_port->TWI_RHR;

		/* Wait for RX ready flag */
		while (1) {
			status = twi_port->TWI_SR;
  4001f8:	6a2b      	ldr	r3, [r5, #32]
			if (status & TWI_SR_RXRDY) {
  4001fa:	0798      	lsls	r0, r3, #30
  4001fc:	d5f9      	bpl.n	4001f2 <local_twi_handler+0xd2>
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
				break;
			}
		}

		if (!(timeout_counter >= TWI_TIMEOUT_COUNTER)) {
  4001fe:	1c60      	adds	r0, r4, #1
  400200:	d00a      	beq.n	400218 <local_twi_handler+0xf8>
			/* Read last data */
			twis[twi_index].buffer[(twis[twi_index].length)-1] = twi_port->TWI_RHR;
  400202:	6b2b      	ldr	r3, [r5, #48]	; 0x30
  400204:	f801 3c01 	strb.w	r3, [r1, #-1]
			timeout_counter = 0;
  400208:	2400      	movs	r4, #0
  40020a:	e002      	b.n	400212 <local_twi_handler+0xf2>
				status = twi_port->TWI_SR;
				if (status & TWI_SR_TXCOMP) {
					break;
				}
				/* Check timeout condition. */
				if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
  40020c:	3401      	adds	r4, #1
  40020e:	1c63      	adds	r3, r4, #1
  400210:	d05e      	beq.n	4002d0 <local_twi_handler+0x1b0>
			/* Read last data */
			twis[twi_index].buffer[(twis[twi_index].length)-1] = twi_port->TWI_RHR;
			timeout_counter = 0;
			/* Wait for TX complete flag before releasing semaphore */
			while (1) {
				status = twi_port->TWI_SR;
  400212:	6a2b      	ldr	r3, [r5, #32]
				if (status & TWI_SR_TXCOMP) {
  400214:	07d9      	lsls	r1, r3, #31
  400216:	d5f9      	bpl.n	40020c <local_twi_handler+0xec>
		}

		/* If the driver is supporting multi-threading, then return the access
		mutex.  NOTE: As the peripheral is half duplex there is only one
		access mutex, and the reception uses the tx access muted. */
		if (tx_dma_control[twi_index].peripheral_access_mutex != NULL) {
  400218:	4b34      	ldr	r3, [pc, #208]	; (4002ec <local_twi_handler+0x1cc>)
  40021a:	441a      	add	r2, r3
  40021c:	6850      	ldr	r0, [r2, #4]
  40021e:	b128      	cbz	r0, 40022c <local_twi_handler+0x10c>
			xSemaphoreGiveFromISR(
  400220:	2100      	movs	r1, #0
  400222:	460b      	mov	r3, r1
  400224:	aa01      	add	r2, sp, #4
  400226:	f8df c0c8 	ldr.w	ip, [pc, #200]	; 4002f0 <local_twi_handler+0x1d0>
  40022a:	47e0      	blx	ip
					&higher_priority_task_woken);
		}

		/* if the receiving task supplied a notification semaphore, then
		notify the task that the transmission has completed. */
		if  (!(timeout_counter >= TWI_TIMEOUT_COUNTER)) {
  40022c:	3401      	adds	r4, #1
  40022e:	d093      	beq.n	400158 <local_twi_handler+0x38>
			if (rx_dma_control[twi_index].transaction_complete_notification_semaphore != NULL) {
  400230:	4b31      	ldr	r3, [pc, #196]	; (4002f8 <local_twi_handler+0x1d8>)
  400232:	f853 0036 	ldr.w	r0, [r3, r6, lsl #3]
  400236:	2800      	cmp	r0, #0
  400238:	d08e      	beq.n	400158 <local_twi_handler+0x38>
				xSemaphoreGiveFromISR(
  40023a:	2100      	movs	r1, #0
  40023c:	460b      	mov	r3, r1
  40023e:	aa01      	add	r2, sp, #4
  400240:	4c2b      	ldr	r4, [pc, #172]	; (4002f0 <local_twi_handler+0x1d0>)
  400242:	47a0      	blx	r4
  400244:	e788      	b.n	400158 <local_twi_handler+0x38>
	twi_status &= twi_get_interrupt_mask(twi_port);

	/* Has the PDC completed a transmission? */
	if ((twi_status & TWI_SR_ENDTX) != 0UL) {
		/* Disable PDC */
		pdc_disable_transfer(all_twi_definitions[twi_index].pdc_base_address, PERIPH_PTCR_TXTDIS);
  400246:	6858      	ldr	r0, [r3, #4]
  400248:	4b26      	ldr	r3, [pc, #152]	; (4002e4 <local_twi_handler+0x1c4>)
  40024a:	f44f 7100 	mov.w	r1, #512	; 0x200
  40024e:	4798      	blx	r3
		twi_disable_interrupt(twi_port, TWI_IDR_ENDTX);
  400250:	4628      	mov	r0, r5
  400252:	f44f 5100 	mov.w	r1, #8192	; 0x2000
  400256:	4b24      	ldr	r3, [pc, #144]	; (4002e8 <local_twi_handler+0x1c8>)
  400258:	4798      	blx	r3
  40025a:	e002      	b.n	400262 <local_twi_handler+0x142>
			status = twi_port->TWI_SR;
			if (status & TWI_SR_TXRDY) {
				break;
			}
			/* Check timeout condition. */
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
  40025c:	3401      	adds	r4, #1
  40025e:	1c63      	adds	r3, r4, #1
  400260:	d033      	beq.n	4002ca <local_twi_handler+0x1aa>
		uint8_t status;
		uint32_t timeout_counter = 0;

		/* Wait for TX ready flag */
		while (1) {
			status = twi_port->TWI_SR;
  400262:	6a2b      	ldr	r3, [r5, #32]
			if (status & TWI_SR_TXRDY) {
  400264:	075a      	lsls	r2, r3, #29
  400266:	d5f9      	bpl.n	40025c <local_twi_handler+0x13c>
static void local_twi_handler(const portBASE_TYPE twi_index)
{
	portBASE_TYPE higher_priority_task_woken = pdFALSE;
	uint32_t twi_status;
	Twi *twi_port;
	bool transfer_timeout = false;
  400268:	f04f 0900 	mov.w	r9, #0
				break;
			}
		}
		/* Complete the transfer - stop and last byte */
		twi_port->TWI_CR = TWI_CR_STOP;
		twi_port->TWI_THR = twis[twi_index].buffer[twis[twi_index].length-1];
  40026c:	4b21      	ldr	r3, [pc, #132]	; (4002f4 <local_twi_handler+0x1d4>)
  40026e:	00f2      	lsls	r2, r6, #3
  400270:	1899      	adds	r1, r3, r2
  400272:	f853 0036 	ldr.w	r0, [r3, r6, lsl #3]
  400276:	684b      	ldr	r3, [r1, #4]
				transfer_timeout = true;
				break;
			}
		}
		/* Complete the transfer - stop and last byte */
		twi_port->TWI_CR = TWI_CR_STOP;
  400278:	2102      	movs	r1, #2
		twi_port->TWI_THR = twis[twi_index].buffer[twis[twi_index].length-1];
  40027a:	4403      	add	r3, r0
				transfer_timeout = true;
				break;
			}
		}
		/* Complete the transfer - stop and last byte */
		twi_port->TWI_CR = TWI_CR_STOP;
  40027c:	6029      	str	r1, [r5, #0]
		twi_port->TWI_THR = twis[twi_index].buffer[twis[twi_index].length-1];
  40027e:	f813 3c01 	ldrb.w	r3, [r3, #-1]
  400282:	636b      	str	r3, [r5, #52]	; 0x34
  400284:	e002      	b.n	40028c <local_twi_handler+0x16c>
			status = twi_port->TWI_SR;
			if (status & TWI_SR_TXCOMP) {
				break;
			}
			/* Check timeout condition. */
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
  400286:	3401      	adds	r4, #1
  400288:	1c61      	adds	r1, r4, #1
  40028a:	d01b      	beq.n	4002c4 <local_twi_handler+0x1a4>
		twi_port->TWI_CR = TWI_CR_STOP;
		twi_port->TWI_THR = twis[twi_index].buffer[twis[twi_index].length-1];

		/* Wait for TX complete flag */
		while (1) {
			status = twi_port->TWI_SR;
  40028c:	6a2b      	ldr	r3, [r5, #32]
			if (status & TWI_SR_TXCOMP) {
  40028e:	07d8      	lsls	r0, r3, #31
  400290:	d5f9      	bpl.n	400286 <local_twi_handler+0x166>
				break;
			}
		}
		/* If the driver is supporting multi-threading, then return the access
		mutex. */
		if (tx_dma_control[twi_index].peripheral_access_mutex != NULL) {
  400292:	f8df b058 	ldr.w	fp, [pc, #88]	; 4002ec <local_twi_handler+0x1cc>
  400296:	445a      	add	r2, fp
  400298:	6850      	ldr	r0, [r2, #4]
  40029a:	b128      	cbz	r0, 4002a8 <local_twi_handler+0x188>
			xSemaphoreGiveFromISR(
  40029c:	2100      	movs	r1, #0
  40029e:	460b      	mov	r3, r1
  4002a0:	aa01      	add	r2, sp, #4
  4002a2:	f8df c04c 	ldr.w	ip, [pc, #76]	; 4002f0 <local_twi_handler+0x1d0>
  4002a6:	47e0      	blx	ip
					&higher_priority_task_woken);
		}

		/* if the sending task supplied a notification semaphore, then
		notify the task that the transmission has completed. */
		if (!(timeout_counter >= TWI_TIMEOUT_COUNTER)) {
  4002a8:	3401      	adds	r4, #1
  4002aa:	f43f af52 	beq.w	400152 <local_twi_handler+0x32>
			if (tx_dma_control[twi_index]. transaction_complete_notification_semaphore != NULL) {
  4002ae:	f85b 0036 	ldr.w	r0, [fp, r6, lsl #3]
  4002b2:	2800      	cmp	r0, #0
  4002b4:	f43f af4d 	beq.w	400152 <local_twi_handler+0x32>
				xSemaphoreGiveFromISR(
  4002b8:	2100      	movs	r1, #0
  4002ba:	460b      	mov	r3, r1
  4002bc:	aa01      	add	r2, sp, #4
  4002be:	4c0c      	ldr	r4, [pc, #48]	; (4002f0 <local_twi_handler+0x1d0>)
  4002c0:	47a0      	blx	r4
  4002c2:	e746      	b.n	400152 <local_twi_handler+0x32>
			if (status & TWI_SR_TXCOMP) {
				break;
			}
			/* Check timeout condition. */
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
				transfer_timeout = true;
  4002c4:	f04f 0901 	mov.w	r9, #1
  4002c8:	e7e3      	b.n	400292 <local_twi_handler+0x172>
			if (status & TWI_SR_TXRDY) {
				break;
			}
			/* Check timeout condition. */
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
				transfer_timeout = true;
  4002ca:	f04f 0901 	mov.w	r9, #1
  4002ce:	e7cd      	b.n	40026c <local_twi_handler+0x14c>
				if (status & TWI_SR_TXCOMP) {
					break;
				}
				/* Check timeout condition. */
				if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
					transfer_timeout = true;
  4002d0:	f04f 0901 	mov.w	r9, #1
  4002d4:	e7a0      	b.n	400218 <local_twi_handler+0xf8>
  4002d6:	bf00      	nop
  4002d8:	00400401 	.word	0x00400401
  4002dc:	00400405 	.word	0x00400405
  4002e0:	004066d5 	.word	0x004066d5
  4002e4:	00403ac5 	.word	0x00403ac5
  4002e8:	004003f9 	.word	0x004003f9
  4002ec:	20000fe8 	.word	0x20000fe8
  4002f0:	00406ad9 	.word	0x00406ad9
  4002f4:	20000fd8 	.word	0x20000fd8
  4002f8:	20000fc8 	.word	0x20000fc8
  4002fc:	00415154 	.word	0x00415154

00400300 <TWI0_Handler>:
#endif /* TWI */

#ifdef TWI0

void TWI0_Handler(void)
{
  400300:	b508      	push	{r3, lr}
	local_twi_handler(0);
  400302:	2000      	movs	r0, #0
  400304:	4b01      	ldr	r3, [pc, #4]	; (40030c <TWI0_Handler+0xc>)
  400306:	4798      	blx	r3
  400308:	bd08      	pop	{r3, pc}
  40030a:	bf00      	nop
  40030c:	00400121 	.word	0x00400121

00400310 <TWI1_Handler>:
#endif

#ifdef TWI1

void TWI1_Handler(void)
{
  400310:	b508      	push	{r3, lr}
	local_twi_handler(1);
  400312:	2001      	movs	r0, #1
  400314:	4b01      	ldr	r3, [pc, #4]	; (40031c <TWI1_Handler+0xc>)
  400316:	4798      	blx	r3
  400318:	bd08      	pop	{r3, pc}
  40031a:	bf00      	nop
  40031c:	00400121 	.word	0x00400121

00400320 <efc_perform_command>:
 *
 * \return 0 if successful, otherwise returns an error code.
 */
uint32_t efc_perform_command(Efc *p_efc, uint32_t ul_command,
		uint32_t ul_argument)
{
  400320:	b508      	push	{r3, lr}
	/* Unique ID commands are not supported. */
	if (ul_command == EFC_FCMD_STUI || ul_command == EFC_FCMD_SPUI) {
  400322:	f1a1 030e 	sub.w	r3, r1, #14
  400326:	2b01      	cmp	r3, #1
  400328:	d802      	bhi.n	400330 <efc_perform_command+0x10>
		return EFC_RC_NOT_SUPPORT;
  40032a:	f04f 30ff 	mov.w	r0, #4294967295

	/* Use RAM Function. */
	return efc_perform_fcr(p_efc,
			EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(ul_argument) |
			EEFC_FCR_FCMD(ul_command));
}
  40032e:	bd08      	pop	{r3, pc}
		return EFC_RC_NOT_SUPPORT;
	}

	/* Use RAM Function. */
	return efc_perform_fcr(p_efc,
			EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(ul_argument) |
  400330:	0212      	lsls	r2, r2, #8
  400332:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
  400336:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
  40033a:	f042 42b4 	orr.w	r2, r2, #1509949440	; 0x5a000000
			EEFC_FCR_FCMD(ul_command));
  40033e:	b2c9      	uxtb	r1, r1
	if (ul_command == EFC_FCMD_STUI || ul_command == EFC_FCMD_SPUI) {
		return EFC_RC_NOT_SUPPORT;
	}

	/* Use RAM Function. */
	return efc_perform_fcr(p_efc,
  400340:	4311      	orrs	r1, r2
  400342:	4b01      	ldr	r3, [pc, #4]	; (400348 <efc_perform_command+0x28>)
  400344:	4798      	blx	r3
  400346:	bd08      	pop	{r3, pc}
  400348:	2000006d 	.word	0x2000006d

0040034c <flash_read_user_signature>:
 * \param ul_size Data buffer size in 32 bit words.
 *
 * \return 0 if successful; otherwise returns an error code.
 */
uint32_t flash_read_user_signature(uint32_t *p_data, uint32_t ul_size)
{
  40034c:	b510      	push	{r4, lr}
  40034e:	b082      	sub	sp, #8
  400350:	2980      	cmp	r1, #128	; 0x80
  400352:	bf28      	it	cs
  400354:	2180      	movcs	r1, #128	; 0x80
  400356:	4603      	mov	r3, r0
		/* Only 512 byte to store user signature */
		ul_size = FLASH_USER_SIG_SIZE / sizeof(uint32_t);
	}

	/* Send the read user signature commands */
	if (FLASH_RC_OK != efc_perform_read_sequence(EFC, EFC_FCMD_STUS,
  400358:	9100      	str	r1, [sp, #0]
  40035a:	4c05      	ldr	r4, [pc, #20]	; (400370 <flash_read_user_signature+0x24>)
  40035c:	4805      	ldr	r0, [pc, #20]	; (400374 <flash_read_user_signature+0x28>)
  40035e:	2114      	movs	r1, #20
  400360:	2215      	movs	r2, #21
  400362:	47a0      	blx	r4
			EFC_FCMD_SPUS, p_data, ul_size)) {
		return FLASH_RC_ERROR;
	}

	return FLASH_RC_OK;
}
  400364:	2800      	cmp	r0, #0
  400366:	bf14      	ite	ne
  400368:	2010      	movne	r0, #16
  40036a:	2000      	moveq	r0, #0
  40036c:	b002      	add	sp, #8
  40036e:	bd10      	pop	{r4, pc}
  400370:	20000001 	.word	0x20000001
  400374:	400e0a00 	.word	0x400e0a00

00400378 <flash_write_user_signature>:
{
	uint32_t ul_idx;
	uint32_t *p_dest;

	/* The user signature should be no longer than 512 bytes */
	if (ul_size > (IFLASH_PAGE_SIZE / sizeof(uint32_t))) {
  400378:	2980      	cmp	r1, #128	; 0x80
 * \param ul_size Data buffer size in 32 bit words.
 *
 * \return 0 if successful; otherwise returns an error code.
 */
uint32_t flash_write_user_signature(const void *p_buffer, uint32_t ul_size)
{
  40037a:	b508      	push	{r3, lr}
  40037c:	460a      	mov	r2, r1
	uint32_t ul_idx;
	uint32_t *p_dest;

	/* The user signature should be no longer than 512 bytes */
	if (ul_size > (IFLASH_PAGE_SIZE / sizeof(uint32_t))) {
  40037e:	d901      	bls.n	400384 <flash_write_user_signature+0xc>
		return FLASH_RC_INVALID;
  400380:	2011      	movs	r0, #17
	if (FLASH_RC_OK != efc_perform_command(EFC, EFC_FCMD_WUS, 0)) {
		return FLASH_RC_ERROR;
	}

	return FLASH_RC_OK;
}
  400382:	bd08      	pop	{r3, pc}
	if (ul_size > (IFLASH_PAGE_SIZE / sizeof(uint32_t))) {
		return FLASH_RC_INVALID;
	}

	/* Copy Buffer data */
	memcpy((uint8_t *) gs_ul_page_buffer, p_buffer, 
  400384:	4601      	mov	r1, r0
  400386:	4b0e      	ldr	r3, [pc, #56]	; (4003c0 <flash_write_user_signature+0x48>)
  400388:	480e      	ldr	r0, [pc, #56]	; (4003c4 <flash_write_user_signature+0x4c>)
  40038a:	0092      	lsls	r2, r2, #2
  40038c:	4798      	blx	r3
  40038e:	480d      	ldr	r0, [pc, #52]	; (4003c4 <flash_write_user_signature+0x4c>)
	/* Write page buffer.
	* Writing 8-bit and 16-bit data is not allowed and may lead to
	* unpredictable data corruption.
	*/
	p_dest = (uint32_t *)IFLASH_ADDR;
	for (ul_idx = 0; ul_idx < (IFLASH_PAGE_SIZE / sizeof(uint32_t)); 
  400390:	490d      	ldr	r1, [pc, #52]	; (4003c8 <flash_write_user_signature+0x50>)

	/* Write page buffer.
	* Writing 8-bit and 16-bit data is not allowed and may lead to
	* unpredictable data corruption.
	*/
	p_dest = (uint32_t *)IFLASH_ADDR;
  400392:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
	for (ul_idx = 0; ul_idx < (IFLASH_PAGE_SIZE / sizeof(uint32_t)); 
			ul_idx++) {
		*p_dest++ = gs_ul_page_buffer[ul_idx];
  400396:	3304      	adds	r3, #4
  400398:	181a      	adds	r2, r3, r0
  40039a:	f5a2 0280 	sub.w	r2, r2, #4194304	; 0x400000
	/* Write page buffer.
	* Writing 8-bit and 16-bit data is not allowed and may lead to
	* unpredictable data corruption.
	*/
	p_dest = (uint32_t *)IFLASH_ADDR;
	for (ul_idx = 0; ul_idx < (IFLASH_PAGE_SIZE / sizeof(uint32_t)); 
  40039e:	428b      	cmp	r3, r1
			ul_idx++) {
		*p_dest++ = gs_ul_page_buffer[ul_idx];
  4003a0:	f852 2c04 	ldr.w	r2, [r2, #-4]
  4003a4:	f843 2c04 	str.w	r2, [r3, #-4]
	/* Write page buffer.
	* Writing 8-bit and 16-bit data is not allowed and may lead to
	* unpredictable data corruption.
	*/
	p_dest = (uint32_t *)IFLASH_ADDR;
	for (ul_idx = 0; ul_idx < (IFLASH_PAGE_SIZE / sizeof(uint32_t)); 
  4003a8:	d1f5      	bne.n	400396 <flash_write_user_signature+0x1e>
			ul_idx++) {
		*p_dest++ = gs_ul_page_buffer[ul_idx];
	}

	/* Send the write signature command */
	if (FLASH_RC_OK != efc_perform_command(EFC, EFC_FCMD_WUS, 0)) {
  4003aa:	4b08      	ldr	r3, [pc, #32]	; (4003cc <flash_write_user_signature+0x54>)
  4003ac:	4808      	ldr	r0, [pc, #32]	; (4003d0 <flash_write_user_signature+0x58>)
  4003ae:	2112      	movs	r1, #18
  4003b0:	2200      	movs	r2, #0
  4003b2:	4798      	blx	r3
		return FLASH_RC_ERROR;
  4003b4:	2800      	cmp	r0, #0
  4003b6:	bf14      	ite	ne
  4003b8:	2010      	movne	r0, #16
  4003ba:	2000      	moveq	r0, #0
  4003bc:	bd08      	pop	{r3, pc}
  4003be:	bf00      	nop
  4003c0:	0040c129 	.word	0x0040c129
  4003c4:	20000ff8 	.word	0x20000ff8
  4003c8:	00400200 	.word	0x00400200
  4003cc:	00400321 	.word	0x00400321
  4003d0:	400e0a00 	.word	0x400e0a00

004003d4 <flash_erase_user_signature>:
 * \brief Erase the flash user signature.
 *
 * \return 0 if successful; otherwise returns an error code.
 */
uint32_t flash_erase_user_signature(void)
{
  4003d4:	b508      	push	{r3, lr}
	/* Perform the erase user signature command */
	return efc_perform_command(EFC, EFC_FCMD_EUS, 0);
  4003d6:	2113      	movs	r1, #19
  4003d8:	4b02      	ldr	r3, [pc, #8]	; (4003e4 <flash_erase_user_signature+0x10>)
  4003da:	4803      	ldr	r0, [pc, #12]	; (4003e8 <flash_erase_user_signature+0x14>)
  4003dc:	2200      	movs	r2, #0
  4003de:	4798      	blx	r3
}
  4003e0:	bd08      	pop	{r3, pc}
  4003e2:	bf00      	nop
  4003e4:	00400321 	.word	0x00400321
  4003e8:	400e0a00 	.word	0x400e0a00

004003ec <rstc_start_software_reset>:
 *
 * \param p_rstc Pointer to an RSTC instance.
 */
void rstc_start_software_reset(Rstc *p_rstc)
{
	p_rstc->RSTC_CR = RSTC_KEY | RSTC_CR_PROCRST | RSTC_CR_PERRST;
  4003ec:	4b01      	ldr	r3, [pc, #4]	; (4003f4 <rstc_start_software_reset+0x8>)
  4003ee:	6003      	str	r3, [r0, #0]
  4003f0:	4770      	bx	lr
  4003f2:	bf00      	nop
  4003f4:	a5000005 	.word	0xa5000005

004003f8 <twi_disable_interrupt>:
 * \param ul_sources Interrupts to be disabled.
 */
void twi_disable_interrupt(Twi *p_twi, uint32_t ul_sources)
{
	/* Disable the specified interrupts */
	p_twi->TWI_IDR = ul_sources;
  4003f8:	6281      	str	r1, [r0, #40]	; 0x28
	/* Dummy read */
	p_twi->TWI_SR;
  4003fa:	6a03      	ldr	r3, [r0, #32]
  4003fc:	4770      	bx	lr
  4003fe:	bf00      	nop

00400400 <twi_get_interrupt_status>:
 *
 * \retval TWI interrupt status.
 */
uint32_t twi_get_interrupt_status(Twi *p_twi)
{
	return p_twi->TWI_SR;
  400400:	6a00      	ldr	r0, [r0, #32]
}
  400402:	4770      	bx	lr

00400404 <twi_get_interrupt_mask>:
 *
 * \return The interrupt mask value.
 */
uint32_t twi_get_interrupt_mask(Twi *p_twi)
{
	return p_twi->TWI_IMR;
  400404:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
}
  400406:	4770      	bx	lr

00400408 <set_led_color>:

/**
 * @brief: Turn on LEDs corresponding to specified color
 **/
static void set_led_color(drv_led_color_type_t ledColor)
{
  400408:	b538      	push	{r3, r4, r5, lr}
	switch (ledColor)
  40040a:	2806      	cmp	r0, #6
  40040c:	d810      	bhi.n	400430 <set_led_color+0x28>
  40040e:	e8df f000 	tbb	[pc, r0]
  400412:	1610      	.short	0x1610
  400414:	372b221c 	.word	0x372b221c
  400418:	04          	.byte	0x04
  400419:	00          	.byte	0x00
			case DRV_LED_TURQUOISE:
				drv_gpio_setPinState(ledConfig.greenLed, DRV_GPIO_PIN_STATE_LOW);
				drv_gpio_setPinState(ledConfig.blueLed, DRV_GPIO_PIN_STATE_LOW);
				break;
			case DRV_LED_OFF:
				drv_gpio_setPinState(ledConfig.redLed, DRV_GPIO_PIN_STATE_HIGH);
  40041a:	4d1b      	ldr	r5, [pc, #108]	; (400488 <set_led_color+0x80>)
  40041c:	4c1b      	ldr	r4, [pc, #108]	; (40048c <set_led_color+0x84>)
  40041e:	7828      	ldrb	r0, [r5, #0]
  400420:	2101      	movs	r1, #1
  400422:	47a0      	blx	r4
				drv_gpio_setPinState(ledConfig.greenLed, DRV_GPIO_PIN_STATE_HIGH);
  400424:	2101      	movs	r1, #1
  400426:	78a8      	ldrb	r0, [r5, #2]
  400428:	47a0      	blx	r4
				drv_gpio_setPinState(ledConfig.blueLed, DRV_GPIO_PIN_STATE_HIGH);
  40042a:	7868      	ldrb	r0, [r5, #1]
  40042c:	2101      	movs	r1, #1
  40042e:	47a0      	blx	r4
  400430:	bd38      	pop	{r3, r4, r5, pc}
static void set_led_color(drv_led_color_type_t ledColor)
{
	switch (ledColor)
		{
			case DRV_LED_RED:
				drv_gpio_setPinState(ledConfig.redLed, DRV_GPIO_PIN_STATE_LOW);
  400432:	4a15      	ldr	r2, [pc, #84]	; (400488 <set_led_color+0x80>)
  400434:	4b15      	ldr	r3, [pc, #84]	; (40048c <set_led_color+0x84>)
  400436:	7810      	ldrb	r0, [r2, #0]
  400438:	2100      	movs	r1, #0
  40043a:	4798      	blx	r3
				break;
  40043c:	bd38      	pop	{r3, r4, r5, pc}
			case DRV_LED_BLUE:
				drv_gpio_setPinState(ledConfig.blueLed, DRV_GPIO_PIN_STATE_LOW);
  40043e:	4a12      	ldr	r2, [pc, #72]	; (400488 <set_led_color+0x80>)
  400440:	4b12      	ldr	r3, [pc, #72]	; (40048c <set_led_color+0x84>)
  400442:	7850      	ldrb	r0, [r2, #1]
  400444:	2100      	movs	r1, #0
  400446:	4798      	blx	r3
				break;
  400448:	bd38      	pop	{r3, r4, r5, pc}
			case DRV_LED_GREEN:
				drv_gpio_setPinState(ledConfig.greenLed, DRV_GPIO_PIN_STATE_LOW);
  40044a:	4a0f      	ldr	r2, [pc, #60]	; (400488 <set_led_color+0x80>)
  40044c:	4b0f      	ldr	r3, [pc, #60]	; (40048c <set_led_color+0x84>)
  40044e:	7890      	ldrb	r0, [r2, #2]
  400450:	2100      	movs	r1, #0
  400452:	4798      	blx	r3
				break;
  400454:	bd38      	pop	{r3, r4, r5, pc}
			case DRV_LED_YELLOW:
				drv_gpio_setPinState(ledConfig.redLed, DRV_GPIO_PIN_STATE_LOW);
  400456:	4d0c      	ldr	r5, [pc, #48]	; (400488 <set_led_color+0x80>)
  400458:	4c0c      	ldr	r4, [pc, #48]	; (40048c <set_led_color+0x84>)
  40045a:	7828      	ldrb	r0, [r5, #0]
  40045c:	2100      	movs	r1, #0
  40045e:	47a0      	blx	r4
				drv_gpio_setPinState(ledConfig.greenLed, DRV_GPIO_PIN_STATE_LOW);
  400460:	78a8      	ldrb	r0, [r5, #2]
  400462:	2100      	movs	r1, #0
  400464:	47a0      	blx	r4
				break;
  400466:	bd38      	pop	{r3, r4, r5, pc}
			case DRV_LED_WHITE:
				drv_gpio_setPinState(ledConfig.redLed, DRV_GPIO_PIN_STATE_LOW);
  400468:	4d07      	ldr	r5, [pc, #28]	; (400488 <set_led_color+0x80>)
  40046a:	4c08      	ldr	r4, [pc, #32]	; (40048c <set_led_color+0x84>)
  40046c:	7828      	ldrb	r0, [r5, #0]
  40046e:	2100      	movs	r1, #0
  400470:	47a0      	blx	r4
				drv_gpio_setPinState(ledConfig.greenLed, DRV_GPIO_PIN_STATE_LOW);
				drv_gpio_setPinState(ledConfig.blueLed, DRV_GPIO_PIN_STATE_LOW);
				break;
			case DRV_LED_TURQUOISE:
				drv_gpio_setPinState(ledConfig.greenLed, DRV_GPIO_PIN_STATE_LOW);
  400472:	78a8      	ldrb	r0, [r5, #2]
  400474:	2100      	movs	r1, #0
  400476:	47a0      	blx	r4
				drv_gpio_setPinState(ledConfig.blueLed, DRV_GPIO_PIN_STATE_LOW);
  400478:	7868      	ldrb	r0, [r5, #1]
  40047a:	2100      	movs	r1, #0
  40047c:	47a0      	blx	r4
				break;
  40047e:	bd38      	pop	{r3, r4, r5, pc}
				drv_gpio_setPinState(ledConfig.redLed, DRV_GPIO_PIN_STATE_LOW);
				drv_gpio_setPinState(ledConfig.greenLed, DRV_GPIO_PIN_STATE_LOW);
				drv_gpio_setPinState(ledConfig.blueLed, DRV_GPIO_PIN_STATE_LOW);
				break;
			case DRV_LED_TURQUOISE:
				drv_gpio_setPinState(ledConfig.greenLed, DRV_GPIO_PIN_STATE_LOW);
  400480:	4d01      	ldr	r5, [pc, #4]	; (400488 <set_led_color+0x80>)
  400482:	4c02      	ldr	r4, [pc, #8]	; (40048c <set_led_color+0x84>)
  400484:	e7f5      	b.n	400472 <set_led_color+0x6a>
  400486:	bf00      	nop
  400488:	200039b4 	.word	0x200039b4
  40048c:	004087b1 	.word	0x004087b1

00400490 <vLedTimerCallback>:

/**
 * @brief: Timer callback function. Used for the blink functionality of LEDs
 **/
void vLedTimerCallback( xTimerHandle xTimer )
{
  400490:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	if((vledState != DRV_LED_SOLID) && (vEnableAlternateBlink == FALSE))	//perform the action only if state is flashing
  400494:	4c61      	ldr	r4, [pc, #388]	; (40061c <vLedTimerCallback+0x18c>)
  400496:	7821      	ldrb	r1, [r4, #0]
  400498:	2901      	cmp	r1, #1

/**
 * @brief: Timer callback function. Used for the blink functionality of LEDs
 **/
void vLedTimerCallback( xTimerHandle xTimer )
{
  40049a:	b083      	sub	sp, #12
	if((vledState != DRV_LED_SOLID) && (vEnableAlternateBlink == FALSE))	//perform the action only if state is flashing
  40049c:	d01e      	beq.n	4004dc <vLedTimerCallback+0x4c>
  40049e:	4b60      	ldr	r3, [pc, #384]	; (400620 <vLedTimerCallback+0x190>)
  4004a0:	781b      	ldrb	r3, [r3, #0]
  4004a2:	b32b      	cbz	r3, 4004f0 <vLedTimerCallback+0x60>
	}
	
	//Blink two colors alternately
	else if ((vledState != DRV_LED_SOLID) && (vEnableAlternateBlink == TRUE))
	{
		ledBlinkCount--;
  4004a4:	4c5f      	ldr	r4, [pc, #380]	; (400624 <vLedTimerCallback+0x194>)
  4004a6:	7823      	ldrb	r3, [r4, #0]
  4004a8:	3b01      	subs	r3, #1
  4004aa:	b2db      	uxtb	r3, r3
		if (ledBlinkCount == 4)
  4004ac:	2b04      	cmp	r3, #4
	}
	
	//Blink two colors alternately
	else if ((vledState != DRV_LED_SOLID) && (vEnableAlternateBlink == TRUE))
	{
		ledBlinkCount--;
  4004ae:	7023      	strb	r3, [r4, #0]
		if (ledBlinkCount == 4)
  4004b0:	f000 8086 	beq.w	4005c0 <vLedTimerCallback+0x130>
		{
			set_led_color(vledColor);
		}
		else if (ledBlinkCount == 3)
  4004b4:	2b03      	cmp	r3, #3
  4004b6:	d077      	beq.n	4005a8 <vLedTimerCallback+0x118>
			//switch off all LEDs
			drv_gpio_setPinState(ledConfig.redLed, DRV_GPIO_PIN_STATE_HIGH);
			drv_gpio_setPinState(ledConfig.blueLed, DRV_GPIO_PIN_STATE_HIGH);
			drv_gpio_setPinState(ledConfig.greenLed, DRV_GPIO_PIN_STATE_HIGH);
		}
		else if (ledBlinkCount == 2)
  4004b8:	2b02      	cmp	r3, #2
  4004ba:	d051      	beq.n	400560 <vLedTimerCallback+0xd0>
			set_led_color(vAlternateColor);
		}
		else
		{
			//switch off all LEDs
			drv_gpio_setPinState(ledConfig.redLed, DRV_GPIO_PIN_STATE_HIGH);
  4004bc:	4e5a      	ldr	r6, [pc, #360]	; (400628 <vLedTimerCallback+0x198>)
  4004be:	4d5b      	ldr	r5, [pc, #364]	; (40062c <vLedTimerCallback+0x19c>)
  4004c0:	7830      	ldrb	r0, [r6, #0]
  4004c2:	2101      	movs	r1, #1
  4004c4:	47a8      	blx	r5
			drv_gpio_setPinState(ledConfig.blueLed, DRV_GPIO_PIN_STATE_HIGH);
  4004c6:	2101      	movs	r1, #1
  4004c8:	7870      	ldrb	r0, [r6, #1]
  4004ca:	47a8      	blx	r5
			drv_gpio_setPinState(ledConfig.greenLed, DRV_GPIO_PIN_STATE_HIGH);
  4004cc:	78b0      	ldrb	r0, [r6, #2]
  4004ce:	2101      	movs	r1, #1
  4004d0:	47a8      	blx	r5
			ledBlinkCount = 5;
  4004d2:	2305      	movs	r3, #5
  4004d4:	7023      	strb	r3, [r4, #0]
	{
		//usually shouldn't end up here
		//if it does the timer was not stopped while initializing led to SOLID state
		xTimerStop(LedTimer, 0);
	}
}
  4004d6:	b003      	add	sp, #12
  4004d8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	}
	else
	{
		//usually shouldn't end up here
		//if it does the timer was not stopped while initializing led to SOLID state
		xTimerStop(LedTimer, 0);
  4004dc:	4b54      	ldr	r3, [pc, #336]	; (400630 <vLedTimerCallback+0x1a0>)
  4004de:	4c55      	ldr	r4, [pc, #340]	; (400634 <vLedTimerCallback+0x1a4>)
  4004e0:	6818      	ldr	r0, [r3, #0]
  4004e2:	2300      	movs	r3, #0
  4004e4:	461a      	mov	r2, r3
  4004e6:	9300      	str	r3, [sp, #0]
  4004e8:	47a0      	blx	r4
	}
}
  4004ea:	b003      	add	sp, #12
  4004ec:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
void vLedTimerCallback( xTimerHandle xTimer )
{
	if((vledState != DRV_LED_SOLID) && (vEnableAlternateBlink == FALSE))	//perform the action only if state is flashing
	{
		//check which led color is set and toggle the pin state
		toggle_led_color(vledColor);
  4004f0:	4b51      	ldr	r3, [pc, #324]	; (400638 <vLedTimerCallback+0x1a8>)
/**
 * @brief: Toggle LEDs corresponding to specified color
 **/
static void toggle_led_color(drv_led_color_type_t ledColor)
{
	switch(ledColor)
  4004f2:	781b      	ldrb	r3, [r3, #0]
  4004f4:	2b05      	cmp	r3, #5
  4004f6:	d80b      	bhi.n	400510 <vLedTimerCallback+0x80>
  4004f8:	e8df f003 	tbb	[pc, r3]
  4004fc:	49433d37 	.word	0x49433d37
  400500:	0351      	.short	0x0351
		drv_gpio_togglePin(ledConfig.redLed);
		drv_gpio_togglePin(ledConfig.greenLed);
		drv_gpio_togglePin(ledConfig.blueLed);
		break;
		case DRV_LED_TURQUOISE:
		drv_gpio_togglePin(ledConfig.greenLed);
  400502:	4e49      	ldr	r6, [pc, #292]	; (400628 <vLedTimerCallback+0x198>)
  400504:	4d4d      	ldr	r5, [pc, #308]	; (40063c <vLedTimerCallback+0x1ac>)
  400506:	78b0      	ldrb	r0, [r6, #2]
  400508:	47a8      	blx	r5
		drv_gpio_togglePin(ledConfig.blueLed);
  40050a:	7870      	ldrb	r0, [r6, #1]
  40050c:	47a8      	blx	r5
  40050e:	7821      	ldrb	r1, [r4, #0]
	{
		//check which led color is set and toggle the pin state
		toggle_led_color(vledColor);
		
		//set multiple blink patterns here
		if ((vledState != DRV_LED_FLASH) && (vledState != DRV_LED_SOLID))
  400510:	2901      	cmp	r1, #1
  400512:	d9e0      	bls.n	4004d6 <vLedTimerCallback+0x46>
		{
			if (ledBlinkCount > 0)
  400514:	4d43      	ldr	r5, [pc, #268]	; (400624 <vLedTimerCallback+0x194>)
  400516:	782b      	ldrb	r3, [r5, #0]
  400518:	2b00      	cmp	r3, #0
  40051a:	d0dc      	beq.n	4004d6 <vLedTimerCallback+0x46>
			{
				if (vtoggleLedBlinkRate == TRUE)
  40051c:	4f48      	ldr	r7, [pc, #288]	; (400640 <vLedTimerCallback+0x1b0>)
  40051e:	783a      	ldrb	r2, [r7, #0]
  400520:	2a00      	cmp	r2, #0
  400522:	d152      	bne.n	4005ca <vLedTimerCallback+0x13a>
						xTimerStop(LedTimer, 0);
					}
					portBASE_TYPE result = xTimerChangePeriod(LedTimer, (LED_BLINK_RATE/portTICK_RATE_MS), 0);	//reconfiguring timer restarts it
					vtoggleLedBlinkRate = FALSE;
				}
				ledBlinkCount--;
  400524:	1e5e      	subs	r6, r3, #1
  400526:	b2f6      	uxtb	r6, r6
				if (ledBlinkCount == 1)
  400528:	2e01      	cmp	r6, #1
						xTimerStop(LedTimer, 0);
					}
					portBASE_TYPE result = xTimerChangePeriod(LedTimer, (LED_BLINK_RATE/portTICK_RATE_MS), 0);	//reconfiguring timer restarts it
					vtoggleLedBlinkRate = FALSE;
				}
				ledBlinkCount--;
  40052a:	702e      	strb	r6, [r5, #0]
				if (ledBlinkCount == 1)
  40052c:	d1d3      	bne.n	4004d6 <vLedTimerCallback+0x46>
				{
					if (xTimerIsTimerActive(LedTimer) != pdFALSE)	//check if timer is active or dormant
  40052e:	f8df 8100 	ldr.w	r8, [pc, #256]	; 400630 <vLedTimerCallback+0x1a0>
  400532:	4b44      	ldr	r3, [pc, #272]	; (400644 <vLedTimerCallback+0x1b4>)
  400534:	f8d8 0000 	ldr.w	r0, [r8]
  400538:	4798      	blx	r3
  40053a:	2800      	cmp	r0, #0
  40053c:	d163      	bne.n	400606 <vLedTimerCallback+0x176>
  40053e:	f8df 90f4 	ldr.w	r9, [pc, #244]	; 400634 <vLedTimerCallback+0x1a4>
					{
						//timer is active, stop it
						xTimerStop(LedTimer, 0);
					}
					portBASE_TYPE res = xTimerChangePeriod(LedTimer, (BLINK_DELAY/portTICK_RATE_MS), 0);	//reconfiguring timer restarts it
  400542:	2300      	movs	r3, #0
  400544:	9300      	str	r3, [sp, #0]
  400546:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
  40054a:	f8d8 0000 	ldr.w	r0, [r8]
  40054e:	2102      	movs	r1, #2
  400550:	47c8      	blx	r9
					vtoggleLedBlinkRate = TRUE;
					ledBlinkCount = 2*vledState +1;	//reload the ledBlinkCount
  400552:	7822      	ldrb	r2, [r4, #0]
  400554:	0052      	lsls	r2, r2, #1
  400556:	3201      	adds	r2, #1
					{
						//timer is active, stop it
						xTimerStop(LedTimer, 0);
					}
					portBASE_TYPE res = xTimerChangePeriod(LedTimer, (BLINK_DELAY/portTICK_RATE_MS), 0);	//reconfiguring timer restarts it
					vtoggleLedBlinkRate = TRUE;
  400558:	2301      	movs	r3, #1
					ledBlinkCount = 2*vledState +1;	//reload the ledBlinkCount
  40055a:	702a      	strb	r2, [r5, #0]
					{
						//timer is active, stop it
						xTimerStop(LedTimer, 0);
					}
					portBASE_TYPE res = xTimerChangePeriod(LedTimer, (BLINK_DELAY/portTICK_RATE_MS), 0);	//reconfiguring timer restarts it
					vtoggleLedBlinkRate = TRUE;
  40055c:	703b      	strb	r3, [r7, #0]
  40055e:	e7ba      	b.n	4004d6 <vLedTimerCallback+0x46>
			drv_gpio_setPinState(ledConfig.blueLed, DRV_GPIO_PIN_STATE_HIGH);
			drv_gpio_setPinState(ledConfig.greenLed, DRV_GPIO_PIN_STATE_HIGH);
		}
		else if (ledBlinkCount == 2)
		{
			set_led_color(vAlternateColor);
  400560:	4a39      	ldr	r2, [pc, #228]	; (400648 <vLedTimerCallback+0x1b8>)
  400562:	4b3a      	ldr	r3, [pc, #232]	; (40064c <vLedTimerCallback+0x1bc>)
  400564:	7810      	ldrb	r0, [r2, #0]
  400566:	4798      	blx	r3
  400568:	e7b5      	b.n	4004d6 <vLedTimerCallback+0x46>
static void toggle_led_color(drv_led_color_type_t ledColor)
{
	switch(ledColor)
	{
		case DRV_LED_RED:
		drv_gpio_togglePin(ledConfig.redLed);
  40056a:	4a2f      	ldr	r2, [pc, #188]	; (400628 <vLedTimerCallback+0x198>)
  40056c:	4b33      	ldr	r3, [pc, #204]	; (40063c <vLedTimerCallback+0x1ac>)
  40056e:	7810      	ldrb	r0, [r2, #0]
  400570:	4798      	blx	r3
  400572:	7821      	ldrb	r1, [r4, #0]
  400574:	e7cc      	b.n	400510 <vLedTimerCallback+0x80>
		break;
		case DRV_LED_BLUE:
		drv_gpio_togglePin(ledConfig.blueLed);
  400576:	4a2c      	ldr	r2, [pc, #176]	; (400628 <vLedTimerCallback+0x198>)
  400578:	4b30      	ldr	r3, [pc, #192]	; (40063c <vLedTimerCallback+0x1ac>)
  40057a:	7850      	ldrb	r0, [r2, #1]
  40057c:	4798      	blx	r3
  40057e:	7821      	ldrb	r1, [r4, #0]
  400580:	e7c6      	b.n	400510 <vLedTimerCallback+0x80>
		break;
		case DRV_LED_GREEN:
		drv_gpio_togglePin(ledConfig.greenLed);
  400582:	4a29      	ldr	r2, [pc, #164]	; (400628 <vLedTimerCallback+0x198>)
  400584:	4b2d      	ldr	r3, [pc, #180]	; (40063c <vLedTimerCallback+0x1ac>)
  400586:	7890      	ldrb	r0, [r2, #2]
  400588:	4798      	blx	r3
  40058a:	7821      	ldrb	r1, [r4, #0]
  40058c:	e7c0      	b.n	400510 <vLedTimerCallback+0x80>
		break;
		case DRV_LED_YELLOW:
		drv_gpio_togglePin(ledConfig.redLed);
  40058e:	4e26      	ldr	r6, [pc, #152]	; (400628 <vLedTimerCallback+0x198>)
  400590:	4d2a      	ldr	r5, [pc, #168]	; (40063c <vLedTimerCallback+0x1ac>)
  400592:	7830      	ldrb	r0, [r6, #0]
  400594:	47a8      	blx	r5
		drv_gpio_togglePin(ledConfig.greenLed);
  400596:	78b0      	ldrb	r0, [r6, #2]
  400598:	47a8      	blx	r5
  40059a:	7821      	ldrb	r1, [r4, #0]
  40059c:	e7b8      	b.n	400510 <vLedTimerCallback+0x80>
		break;
		case DRV_LED_WHITE:
		drv_gpio_togglePin(ledConfig.redLed);
  40059e:	4e22      	ldr	r6, [pc, #136]	; (400628 <vLedTimerCallback+0x198>)
  4005a0:	4d26      	ldr	r5, [pc, #152]	; (40063c <vLedTimerCallback+0x1ac>)
  4005a2:	7830      	ldrb	r0, [r6, #0]
  4005a4:	47a8      	blx	r5
  4005a6:	e7ae      	b.n	400506 <vLedTimerCallback+0x76>
			set_led_color(vledColor);
		}
		else if (ledBlinkCount == 3)
		{
			//switch off all LEDs
			drv_gpio_setPinState(ledConfig.redLed, DRV_GPIO_PIN_STATE_HIGH);
  4005a8:	4d1f      	ldr	r5, [pc, #124]	; (400628 <vLedTimerCallback+0x198>)
  4005aa:	4c20      	ldr	r4, [pc, #128]	; (40062c <vLedTimerCallback+0x19c>)
  4005ac:	7828      	ldrb	r0, [r5, #0]
  4005ae:	2101      	movs	r1, #1
  4005b0:	47a0      	blx	r4
			drv_gpio_setPinState(ledConfig.blueLed, DRV_GPIO_PIN_STATE_HIGH);
  4005b2:	7868      	ldrb	r0, [r5, #1]
  4005b4:	2101      	movs	r1, #1
  4005b6:	47a0      	blx	r4
			drv_gpio_setPinState(ledConfig.greenLed, DRV_GPIO_PIN_STATE_HIGH);
  4005b8:	78a8      	ldrb	r0, [r5, #2]
  4005ba:	2101      	movs	r1, #1
  4005bc:	47a0      	blx	r4
  4005be:	e78a      	b.n	4004d6 <vLedTimerCallback+0x46>
	else if ((vledState != DRV_LED_SOLID) && (vEnableAlternateBlink == TRUE))
	{
		ledBlinkCount--;
		if (ledBlinkCount == 4)
		{
			set_led_color(vledColor);
  4005c0:	4a1d      	ldr	r2, [pc, #116]	; (400638 <vLedTimerCallback+0x1a8>)
  4005c2:	4b22      	ldr	r3, [pc, #136]	; (40064c <vLedTimerCallback+0x1bc>)
  4005c4:	7810      	ldrb	r0, [r2, #0]
  4005c6:	4798      	blx	r3
  4005c8:	e785      	b.n	4004d6 <vLedTimerCallback+0x46>
		{
			if (ledBlinkCount > 0)
			{
				if (vtoggleLedBlinkRate == TRUE)
				{
					if (xTimerIsTimerActive(LedTimer) != pdFALSE)	//check if timer is active or dormant
  4005ca:	f8df 8064 	ldr.w	r8, [pc, #100]	; 400630 <vLedTimerCallback+0x1a0>
  4005ce:	4b1d      	ldr	r3, [pc, #116]	; (400644 <vLedTimerCallback+0x1b4>)
  4005d0:	f8d8 0000 	ldr.w	r0, [r8]
  4005d4:	4798      	blx	r3
  4005d6:	b960      	cbnz	r0, 4005f2 <vLedTimerCallback+0x162>
  4005d8:	f8df 9058 	ldr.w	r9, [pc, #88]	; 400634 <vLedTimerCallback+0x1a4>
					{
						//timer is active, stop it
						xTimerStop(LedTimer, 0);
					}
					portBASE_TYPE result = xTimerChangePeriod(LedTimer, (LED_BLINK_RATE/portTICK_RATE_MS), 0);	//reconfiguring timer restarts it
  4005dc:	2600      	movs	r6, #0
  4005de:	4633      	mov	r3, r6
  4005e0:	f8d8 0000 	ldr.w	r0, [r8]
  4005e4:	9600      	str	r6, [sp, #0]
  4005e6:	2102      	movs	r1, #2
  4005e8:	22fa      	movs	r2, #250	; 0xfa
  4005ea:	47c8      	blx	r9
					vtoggleLedBlinkRate = FALSE;
  4005ec:	703e      	strb	r6, [r7, #0]
  4005ee:	782b      	ldrb	r3, [r5, #0]
  4005f0:	e798      	b.n	400524 <vLedTimerCallback+0x94>
				if (vtoggleLedBlinkRate == TRUE)
				{
					if (xTimerIsTimerActive(LedTimer) != pdFALSE)	//check if timer is active or dormant
					{
						//timer is active, stop it
						xTimerStop(LedTimer, 0);
  4005f2:	2200      	movs	r2, #0
  4005f4:	f8d8 0000 	ldr.w	r0, [r8]
  4005f8:	9200      	str	r2, [sp, #0]
  4005fa:	4613      	mov	r3, r2
  4005fc:	2101      	movs	r1, #1
  4005fe:	f8df 9034 	ldr.w	r9, [pc, #52]	; 400634 <vLedTimerCallback+0x1a4>
  400602:	47c8      	blx	r9
  400604:	e7ea      	b.n	4005dc <vLedTimerCallback+0x14c>
				if (ledBlinkCount == 1)
				{
					if (xTimerIsTimerActive(LedTimer) != pdFALSE)	//check if timer is active or dormant
					{
						//timer is active, stop it
						xTimerStop(LedTimer, 0);
  400606:	2200      	movs	r2, #0
  400608:	f8d8 0000 	ldr.w	r0, [r8]
  40060c:	9200      	str	r2, [sp, #0]
  40060e:	4631      	mov	r1, r6
  400610:	4613      	mov	r3, r2
  400612:	f8df 9020 	ldr.w	r9, [pc, #32]	; 400634 <vLedTimerCallback+0x1a4>
  400616:	47c8      	blx	r9
  400618:	e793      	b.n	400542 <vLedTimerCallback+0xb2>
  40061a:	bf00      	nop
  40061c:	200039b0 	.word	0x200039b0
  400620:	200011f9 	.word	0x200011f9
  400624:	200011f8 	.word	0x200011f8
  400628:	200039b4 	.word	0x200039b4
  40062c:	004087b1 	.word	0x004087b1
  400630:	200039ac 	.word	0x200039ac
  400634:	00407949 	.word	0x00407949
  400638:	200039a8 	.word	0x200039a8
  40063c:	00408859 	.word	0x00408859
  400640:	200011fa 	.word	0x200011fa
  400644:	00407bc1 	.word	0x00407bc1
  400648:	200039b7 	.word	0x200039b7
  40064c:	00400409 	.word	0x00400409

00400650 <drv_led_init>:
 * @brief initialize LED driver and the timer
 * @param configLed, the configuration structure for the LED, contains gpio mappings.  
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t drv_led_init(drv_led_config_t* configLed)
{
  400650:	b5f0      	push	{r4, r5, r6, r7, lr}
	status_t result = STATUS_PASS;
	//store the led configuration
	ledConfig.redLed = configLed->redLed;
  400652:	4c0c      	ldr	r4, [pc, #48]	; (400684 <drv_led_init+0x34>)
  400654:	7803      	ldrb	r3, [r0, #0]
	ledConfig.blueLed = configLed->blueLed;
	ledConfig.greenLed = configLed->greenLed;
	
	//create LedTimer task
	LedTimer = xTimerCreate("Led Timer", (LED_BLINK_RATE/portTICK_RATE_MS), pdTRUE, NULL, vLedTimerCallback);
  400656:	4a0c      	ldr	r2, [pc, #48]	; (400688 <drv_led_init+0x38>)
status_t drv_led_init(drv_led_config_t* configLed)
{
	status_t result = STATUS_PASS;
	//store the led configuration
	ledConfig.redLed = configLed->redLed;
	ledConfig.blueLed = configLed->blueLed;
  400658:	7847      	ldrb	r7, [r0, #1]
	ledConfig.greenLed = configLed->greenLed;
  40065a:	7886      	ldrb	r6, [r0, #2]
 ***********************************************************************************************/
status_t drv_led_init(drv_led_config_t* configLed)
{
	status_t result = STATUS_PASS;
	//store the led configuration
	ledConfig.redLed = configLed->redLed;
  40065c:	7023      	strb	r3, [r4, #0]
 * @brief initialize LED driver and the timer
 * @param configLed, the configuration structure for the LED, contains gpio mappings.  
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t drv_led_init(drv_led_config_t* configLed)
{
  40065e:	b083      	sub	sp, #12
	ledConfig.redLed = configLed->redLed;
	ledConfig.blueLed = configLed->blueLed;
	ledConfig.greenLed = configLed->greenLed;
	
	//create LedTimer task
	LedTimer = xTimerCreate("Led Timer", (LED_BLINK_RATE/portTICK_RATE_MS), pdTRUE, NULL, vLedTimerCallback);
  400660:	4d0a      	ldr	r5, [pc, #40]	; (40068c <drv_led_init+0x3c>)
  400662:	9200      	str	r2, [sp, #0]
  400664:	21fa      	movs	r1, #250	; 0xfa
  400666:	2201      	movs	r2, #1
  400668:	2300      	movs	r3, #0
  40066a:	4809      	ldr	r0, [pc, #36]	; (400690 <drv_led_init+0x40>)
status_t drv_led_init(drv_led_config_t* configLed)
{
	status_t result = STATUS_PASS;
	//store the led configuration
	ledConfig.redLed = configLed->redLed;
	ledConfig.blueLed = configLed->blueLed;
  40066c:	7067      	strb	r7, [r4, #1]
	ledConfig.greenLed = configLed->greenLed;
  40066e:	70a6      	strb	r6, [r4, #2]
	
	//create LedTimer task
	LedTimer = xTimerCreate("Led Timer", (LED_BLINK_RATE/portTICK_RATE_MS), pdTRUE, NULL, vLedTimerCallback);
  400670:	47a8      	blx	r5
  400672:	4a08      	ldr	r2, [pc, #32]	; (400694 <drv_led_init+0x44>)
  400674:	4603      	mov	r3, r0
	if (LedTimer == NULL)
	{
		result = STATUS_FAIL;
	}
	return result;
}
  400676:	f1d0 0001 	rsbs	r0, r0, #1
  40067a:	bf38      	it	cc
  40067c:	2000      	movcc	r0, #0
	ledConfig.redLed = configLed->redLed;
	ledConfig.blueLed = configLed->blueLed;
	ledConfig.greenLed = configLed->greenLed;
	
	//create LedTimer task
	LedTimer = xTimerCreate("Led Timer", (LED_BLINK_RATE/portTICK_RATE_MS), pdTRUE, NULL, vLedTimerCallback);
  40067e:	6013      	str	r3, [r2, #0]
	if (LedTimer == NULL)
	{
		result = STATUS_FAIL;
	}
	return result;
}
  400680:	b003      	add	sp, #12
  400682:	bdf0      	pop	{r4, r5, r6, r7, pc}
  400684:	200039b4 	.word	0x200039b4
  400688:	00400491 	.word	0x00400491
  40068c:	004078fd 	.word	0x004078fd
  400690:	00415174 	.word	0x00415174
  400694:	200039ac 	.word	0x200039ac

00400698 <drv_led_set>:
 * @brief Set the LED color and blink pattern
 * @param ledColor- the color to be set, ledState- one of the states enumerated in drv_led_state_type_t   
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t drv_led_set(drv_led_color_type_t ledColor, drv_led_state_type_t ledState)
{
  400698:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	status_t result = STATUS_PASS;
	if (xTimerIsTimerActive(LedTimer) != pdFALSE)	//check if timer is active or dormant
  40069c:	4f2e      	ldr	r7, [pc, #184]	; (400758 <drv_led_set+0xc0>)
  40069e:	f8df 90e0 	ldr.w	r9, [pc, #224]	; 400780 <drv_led_set+0xe8>
 * @brief Set the LED color and blink pattern
 * @param ledColor- the color to be set, ledState- one of the states enumerated in drv_led_state_type_t   
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t drv_led_set(drv_led_color_type_t ledColor, drv_led_state_type_t ledState)
{
  4006a2:	b083      	sub	sp, #12
  4006a4:	4680      	mov	r8, r0
	status_t result = STATUS_PASS;
	if (xTimerIsTimerActive(LedTimer) != pdFALSE)	//check if timer is active or dormant
  4006a6:	6838      	ldr	r0, [r7, #0]
 * @brief Set the LED color and blink pattern
 * @param ledColor- the color to be set, ledState- one of the states enumerated in drv_led_state_type_t   
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t drv_led_set(drv_led_color_type_t ledColor, drv_led_state_type_t ledState)
{
  4006a8:	460c      	mov	r4, r1
	status_t result = STATUS_PASS;
	if (xTimerIsTimerActive(LedTimer) != pdFALSE)	//check if timer is active or dormant
  4006aa:	47c8      	blx	r9
  4006ac:	2800      	cmp	r0, #0
  4006ae:	d14a      	bne.n	400746 <drv_led_set+0xae>
	{
		ledBlinkCount = 2*ledState;
	}
	
	//switch off all LEDs
	drv_gpio_setPinState(ledConfig.redLed, DRV_GPIO_PIN_STATE_HIGH);
  4006b0:	4e2a      	ldr	r6, [pc, #168]	; (40075c <drv_led_set+0xc4>)
		xTimerStop(LedTimer, 0);		
	}
	//configure the multiple blink pattern here
	if ((ledState == DRV_LED_SOLID) || (ledState == DRV_LED_FLASH))
	{
		ledBlinkCount = 0;
  4006b2:	4b2b      	ldr	r3, [pc, #172]	; (400760 <drv_led_set+0xc8>)
	{
		ledBlinkCount = 2*ledState;
	}
	
	//switch off all LEDs
	drv_gpio_setPinState(ledConfig.redLed, DRV_GPIO_PIN_STATE_HIGH);
  4006b4:	4d2b      	ldr	r5, [pc, #172]	; (400764 <drv_led_set+0xcc>)
  4006b6:	7830      	ldrb	r0, [r6, #0]
	{
		//timer is active, stop it
		xTimerStop(LedTimer, 0);		
	}
	//configure the multiple blink pattern here
	if ((ledState == DRV_LED_SOLID) || (ledState == DRV_LED_FLASH))
  4006b8:	2c01      	cmp	r4, #1
	{
		ledBlinkCount = 0;
  4006ba:	bf94      	ite	ls
  4006bc:	2200      	movls	r2, #0
	}
	else
	{
		ledBlinkCount = 2*ledState;
  4006be:	0062      	lslhi	r2, r4, #1
	}
	
	//switch off all LEDs
	drv_gpio_setPinState(ledConfig.redLed, DRV_GPIO_PIN_STATE_HIGH);
  4006c0:	2101      	movs	r1, #1
	{
		ledBlinkCount = 0;
	}
	else
	{
		ledBlinkCount = 2*ledState;
  4006c2:	701a      	strb	r2, [r3, #0]
	}
	
	//switch off all LEDs
	drv_gpio_setPinState(ledConfig.redLed, DRV_GPIO_PIN_STATE_HIGH);
  4006c4:	47a8      	blx	r5
	drv_gpio_setPinState(ledConfig.blueLed, DRV_GPIO_PIN_STATE_HIGH);
  4006c6:	7870      	ldrb	r0, [r6, #1]
  4006c8:	2101      	movs	r1, #1
  4006ca:	47a8      	blx	r5
	drv_gpio_setPinState(ledConfig.greenLed, DRV_GPIO_PIN_STATE_HIGH);
  4006cc:	78b0      	ldrb	r0, [r6, #2]
  4006ce:	2101      	movs	r1, #1
  4006d0:	47a8      	blx	r5
	
	vEnableAlternateBlink = FALSE;	//clear the alternate blink flag
	vAlternateColor = DRV_LED_OFF;	//clear the alternate blink color
	vledColor = ledColor;	//copy the color to a global variable used in timer callback
  4006d2:	4825      	ldr	r0, [pc, #148]	; (400768 <drv_led_set+0xd0>)
	//switch off all LEDs
	drv_gpio_setPinState(ledConfig.redLed, DRV_GPIO_PIN_STATE_HIGH);
	drv_gpio_setPinState(ledConfig.blueLed, DRV_GPIO_PIN_STATE_HIGH);
	drv_gpio_setPinState(ledConfig.greenLed, DRV_GPIO_PIN_STATE_HIGH);
	
	vEnableAlternateBlink = FALSE;	//clear the alternate blink flag
  4006d4:	f8df e0ac 	ldr.w	lr, [pc, #172]	; 400784 <drv_led_set+0xec>
	vAlternateColor = DRV_LED_OFF;	//clear the alternate blink color
  4006d8:	4924      	ldr	r1, [pc, #144]	; (40076c <drv_led_set+0xd4>)
	vledColor = ledColor;	//copy the color to a global variable used in timer callback
	vledState = ledState;	//copy the state to a global variable used in timer callback
  4006da:	4a25      	ldr	r2, [pc, #148]	; (400770 <drv_led_set+0xd8>)
	drv_gpio_setPinState(ledConfig.blueLed, DRV_GPIO_PIN_STATE_HIGH);
	drv_gpio_setPinState(ledConfig.greenLed, DRV_GPIO_PIN_STATE_HIGH);
	
	vEnableAlternateBlink = FALSE;	//clear the alternate blink flag
	vAlternateColor = DRV_LED_OFF;	//clear the alternate blink color
	vledColor = ledColor;	//copy the color to a global variable used in timer callback
  4006dc:	f880 8000 	strb.w	r8, [r0]
	vledState = ledState;	//copy the state to a global variable used in timer callback
	
	set_led_color(ledColor);
  4006e0:	4b24      	ldr	r3, [pc, #144]	; (400774 <drv_led_set+0xdc>)
	drv_gpio_setPinState(ledConfig.greenLed, DRV_GPIO_PIN_STATE_HIGH);
	
	vEnableAlternateBlink = FALSE;	//clear the alternate blink flag
	vAlternateColor = DRV_LED_OFF;	//clear the alternate blink color
	vledColor = ledColor;	//copy the color to a global variable used in timer callback
	vledState = ledState;	//copy the state to a global variable used in timer callback
  4006e2:	7014      	strb	r4, [r2, #0]
	
	set_led_color(ledColor);
  4006e4:	4640      	mov	r0, r8
	//switch off all LEDs
	drv_gpio_setPinState(ledConfig.redLed, DRV_GPIO_PIN_STATE_HIGH);
	drv_gpio_setPinState(ledConfig.blueLed, DRV_GPIO_PIN_STATE_HIGH);
	drv_gpio_setPinState(ledConfig.greenLed, DRV_GPIO_PIN_STATE_HIGH);
	
	vEnableAlternateBlink = FALSE;	//clear the alternate blink flag
  4006e6:	2500      	movs	r5, #0
	vAlternateColor = DRV_LED_OFF;	//clear the alternate blink color
  4006e8:	2606      	movs	r6, #6
	//switch off all LEDs
	drv_gpio_setPinState(ledConfig.redLed, DRV_GPIO_PIN_STATE_HIGH);
	drv_gpio_setPinState(ledConfig.blueLed, DRV_GPIO_PIN_STATE_HIGH);
	drv_gpio_setPinState(ledConfig.greenLed, DRV_GPIO_PIN_STATE_HIGH);
	
	vEnableAlternateBlink = FALSE;	//clear the alternate blink flag
  4006ea:	f88e 5000 	strb.w	r5, [lr]
	vAlternateColor = DRV_LED_OFF;	//clear the alternate blink color
  4006ee:	700e      	strb	r6, [r1, #0]
	vledColor = ledColor;	//copy the color to a global variable used in timer callback
	vledState = ledState;	//copy the state to a global variable used in timer callback
	
	set_led_color(ledColor);
  4006f0:	4798      	blx	r3
	
	if ((ledState != DRV_LED_SOLID) & (ledColor != DRV_LED_OFF))
  4006f2:	2c01      	cmp	r4, #1
	{
		xTimerChangePeriod(LedTimer, (LED_BLINK_RATE/portTICK_RATE_MS), 0);
  4006f4:	6838      	ldr	r0, [r7, #0]
	vledColor = ledColor;	//copy the color to a global variable used in timer callback
	vledState = ledState;	//copy the state to a global variable used in timer callback
	
	set_led_color(ledColor);
	
	if ((ledState != DRV_LED_SOLID) & (ledColor != DRV_LED_OFF))
  4006f6:	d111      	bne.n	40071c <drv_led_set+0x84>
		xTimerReset(LedTimer, 0);
	}
	else
	{
		//stop the timer
		if (xTimerIsTimerActive(LedTimer) != pdFALSE)	//check if timer is active or dormant
  4006f8:	4c17      	ldr	r4, [pc, #92]	; (400758 <drv_led_set+0xc0>)
  4006fa:	47c8      	blx	r9
  4006fc:	b918      	cbnz	r0, 400706 <drv_led_set+0x6e>
		{
			xTimerStop(LedTimer, 0);
		}
	}
	return result;
}
  4006fe:	2000      	movs	r0, #0
  400700:	b003      	add	sp, #12
  400702:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	else
	{
		//stop the timer
		if (xTimerIsTimerActive(LedTimer) != pdFALSE)	//check if timer is active or dormant
		{
			xTimerStop(LedTimer, 0);
  400706:	2300      	movs	r3, #0
  400708:	6820      	ldr	r0, [r4, #0]
  40070a:	4c1b      	ldr	r4, [pc, #108]	; (400778 <drv_led_set+0xe0>)
  40070c:	9300      	str	r3, [sp, #0]
  40070e:	461a      	mov	r2, r3
  400710:	2101      	movs	r1, #1
  400712:	47a0      	blx	r4
		}
	}
	return result;
}
  400714:	2000      	movs	r0, #0
  400716:	b003      	add	sp, #12
  400718:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	vledColor = ledColor;	//copy the color to a global variable used in timer callback
	vledState = ledState;	//copy the state to a global variable used in timer callback
	
	set_led_color(ledColor);
	
	if ((ledState != DRV_LED_SOLID) & (ledColor != DRV_LED_OFF))
  40071c:	45b0      	cmp	r8, r6
  40071e:	d0eb      	beq.n	4006f8 <drv_led_set+0x60>
	{
		xTimerChangePeriod(LedTimer, (LED_BLINK_RATE/portTICK_RATE_MS), 0);
  400720:	2102      	movs	r1, #2
  400722:	22fa      	movs	r2, #250	; 0xfa
  400724:	462b      	mov	r3, r5
  400726:	4c14      	ldr	r4, [pc, #80]	; (400778 <drv_led_set+0xe0>)
  400728:	9500      	str	r5, [sp, #0]
  40072a:	47a0      	blx	r4
		xTimerReset(LedTimer, 0);
  40072c:	4b13      	ldr	r3, [pc, #76]	; (40077c <drv_led_set+0xe4>)
  40072e:	683e      	ldr	r6, [r7, #0]
  400730:	4798      	blx	r3
  400732:	4629      	mov	r1, r5
  400734:	4602      	mov	r2, r0
  400736:	9500      	str	r5, [sp, #0]
  400738:	4630      	mov	r0, r6
  40073a:	462b      	mov	r3, r5
  40073c:	47a0      	blx	r4
		{
			xTimerStop(LedTimer, 0);
		}
	}
	return result;
}
  40073e:	2000      	movs	r0, #0
  400740:	b003      	add	sp, #12
  400742:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
{
	status_t result = STATUS_PASS;
	if (xTimerIsTimerActive(LedTimer) != pdFALSE)	//check if timer is active or dormant
	{
		//timer is active, stop it
		xTimerStop(LedTimer, 0);		
  400746:	2200      	movs	r2, #0
  400748:	6838      	ldr	r0, [r7, #0]
  40074a:	4d0b      	ldr	r5, [pc, #44]	; (400778 <drv_led_set+0xe0>)
  40074c:	9200      	str	r2, [sp, #0]
  40074e:	4613      	mov	r3, r2
  400750:	2101      	movs	r1, #1
  400752:	47a8      	blx	r5
  400754:	e7ac      	b.n	4006b0 <drv_led_set+0x18>
  400756:	bf00      	nop
  400758:	200039ac 	.word	0x200039ac
  40075c:	200039b4 	.word	0x200039b4
  400760:	200011f8 	.word	0x200011f8
  400764:	004087b1 	.word	0x004087b1
  400768:	200039a8 	.word	0x200039a8
  40076c:	200039b7 	.word	0x200039b7
  400770:	200039b0 	.word	0x200039b0
  400774:	00400409 	.word	0x00400409
  400778:	00407949 	.word	0x00407949
  40077c:	004070a1 	.word	0x004070a1
  400780:	00407bc1 	.word	0x00407bc1
  400784:	200011f9 	.word	0x200011f9

00400788 <drv_led_activate_timer>:
 * @brief Activate or start the LED timer.
 * @param Void
 * @return Void
 ***********************************************************************************************/
void drv_led_activate_timer()
{
  400788:	b510      	push	{r4, lr}
	xTimerStart(LedTimer, 0);
  40078a:	4a07      	ldr	r2, [pc, #28]	; (4007a8 <drv_led_activate_timer+0x20>)
  40078c:	4b07      	ldr	r3, [pc, #28]	; (4007ac <drv_led_activate_timer+0x24>)
  40078e:	6814      	ldr	r4, [r2, #0]
 * @brief Activate or start the LED timer.
 * @param Void
 * @return Void
 ***********************************************************************************************/
void drv_led_activate_timer()
{
  400790:	b082      	sub	sp, #8
	xTimerStart(LedTimer, 0);
  400792:	4798      	blx	r3
  400794:	2300      	movs	r3, #0
  400796:	4602      	mov	r2, r0
  400798:	4619      	mov	r1, r3
  40079a:	4620      	mov	r0, r4
  40079c:	9300      	str	r3, [sp, #0]
  40079e:	4c04      	ldr	r4, [pc, #16]	; (4007b0 <drv_led_activate_timer+0x28>)
  4007a0:	47a0      	blx	r4
}
  4007a2:	b002      	add	sp, #8
  4007a4:	bd10      	pop	{r4, pc}
  4007a6:	bf00      	nop
  4007a8:	200039ac 	.word	0x200039ac
  4007ac:	004070a1 	.word	0x004070a1
  4007b0:	00407949 	.word	0x00407949

004007b4 <debugPrintStringInt>:
	sprintf(timeString,"%02d:%02d:%02d",hour,minute,second); 
	return timeString; 
} 

void __attribute__((optimize("O0"))) debugPrintStringInt(char* str, int number)
{
  4007b4:	b580      	push	{r7, lr}
  4007b6:	b0b6      	sub	sp, #216	; 0xd8
  4007b8:	af00      	add	r7, sp, #0
  4007ba:	6078      	str	r0, [r7, #4]
  4007bc:	6039      	str	r1, [r7, #0]
	size_t length = 0;
  4007be:	2300      	movs	r3, #0
  4007c0:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
	char timeStampedStr[MAX_DEBUG_STRING_LENGTH];
	int len = itoa(sgSysTickCount, timeStampedStr, 10);
  4007c4:	4b38      	ldr	r3, [pc, #224]	; (4008a8 <debugPrintStringInt+0xf4>)
  4007c6:	681b      	ldr	r3, [r3, #0]
  4007c8:	461a      	mov	r2, r3
  4007ca:	f107 0308 	add.w	r3, r7, #8
  4007ce:	4610      	mov	r0, r2
  4007d0:	4619      	mov	r1, r3
  4007d2:	220a      	movs	r2, #10
  4007d4:	4b35      	ldr	r3, [pc, #212]	; (4008ac <debugPrintStringInt+0xf8>)
  4007d6:	4798      	blx	r3
  4007d8:	f8c7 00d0 	str.w	r0, [r7, #208]	; 0xd0
	timeStampedStr[len++] = ',';
  4007dc:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
  4007e0:	1c5a      	adds	r2, r3, #1
  4007e2:	f8c7 20d0 	str.w	r2, [r7, #208]	; 0xd0
  4007e6:	f107 02d8 	add.w	r2, r7, #216	; 0xd8
  4007ea:	4413      	add	r3, r2
  4007ec:	222c      	movs	r2, #44	; 0x2c
  4007ee:	f803 2cd0 	strb.w	r2, [r3, #-208]
	length = len;
  4007f2:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
  4007f6:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
	len = itoa(number, timeStampedStr+length, 10);
  4007fa:	f107 0208 	add.w	r2, r7, #8
  4007fe:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
  400802:	4413      	add	r3, r2
  400804:	6838      	ldr	r0, [r7, #0]
  400806:	4619      	mov	r1, r3
  400808:	220a      	movs	r2, #10
  40080a:	4b28      	ldr	r3, [pc, #160]	; (4008ac <debugPrintStringInt+0xf8>)
  40080c:	4798      	blx	r3
  40080e:	f8c7 00d0 	str.w	r0, [r7, #208]	; 0xd0
	timeStampedStr[length+len] = ',';
  400812:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
  400816:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
  40081a:	4413      	add	r3, r2
  40081c:	f107 02d8 	add.w	r2, r7, #216	; 0xd8
  400820:	4413      	add	r3, r2
  400822:	222c      	movs	r2, #44	; 0x2c
  400824:	f803 2cd0 	strb.w	r2, [r3, #-208]
	length += len + 1;
  400828:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
  40082c:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
  400830:	4413      	add	r3, r2
  400832:	3301      	adds	r3, #1
  400834:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
	strncpy(timeStampedStr+length, str, MAX_DEBUG_STRING_LENGTH-length);
  400838:	f107 0208 	add.w	r2, r7, #8
  40083c:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
  400840:	441a      	add	r2, r3
  400842:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
  400846:	f1c3 03c8 	rsb	r3, r3, #200	; 0xc8
  40084a:	4610      	mov	r0, r2
  40084c:	6879      	ldr	r1, [r7, #4]
  40084e:	461a      	mov	r2, r3
  400850:	4b17      	ldr	r3, [pc, #92]	; (4008b0 <debugPrintStringInt+0xfc>)
  400852:	4798      	blx	r3
	length = strlen(timeStampedStr);	
  400854:	f107 0308 	add.w	r3, r7, #8
  400858:	4618      	mov	r0, r3
  40085a:	4b16      	ldr	r3, [pc, #88]	; (4008b4 <debugPrintStringInt+0x100>)
  40085c:	4798      	blx	r3
  40085e:	f8c7 00d4 	str.w	r0, [r7, #212]	; 0xd4
	//length = snprintf(timeStampedStr,200,"%08d,%s %d\r\n",sgSysTickCount,str,number);
	if(length > 0)
  400862:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
  400866:	2b00      	cmp	r3, #0
  400868:	d01a      	beq.n	4008a0 <debugPrintStringInt+0xec>
	{
		if(brainSettings.debugPrintsEnabled)
  40086a:	4b13      	ldr	r3, [pc, #76]	; (4008b8 <debugPrintStringInt+0x104>)
  40086c:	f893 309f 	ldrb.w	r3, [r3, #159]	; 0x9f
  400870:	2b00      	cmp	r3, #0
  400872:	d00e      	beq.n	400892 <debugPrintStringInt+0xde>
		{
			if(config != NULL)
  400874:	4b11      	ldr	r3, [pc, #68]	; (4008bc <debugPrintStringInt+0x108>)
  400876:	681b      	ldr	r3, [r3, #0]
  400878:	2b00      	cmp	r3, #0
  40087a:	d00a      	beq.n	400892 <debugPrintStringInt+0xde>
			{		
				drv_uart_putData((config->uart), timeStampedStr, length);
  40087c:	4b0f      	ldr	r3, [pc, #60]	; (4008bc <debugPrintStringInt+0x108>)
  40087e:	681b      	ldr	r3, [r3, #0]
  400880:	681a      	ldr	r2, [r3, #0]
  400882:	f107 0308 	add.w	r3, r7, #8
  400886:	4610      	mov	r0, r2
  400888:	4619      	mov	r1, r3
  40088a:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
  40088e:	4b0c      	ldr	r3, [pc, #48]	; (4008c0 <debugPrintStringInt+0x10c>)
  400890:	4798      	blx	r3
			}
		}
		task_debugLogWriteEntry(timeStampedStr, length);
  400892:	f107 0308 	add.w	r3, r7, #8
  400896:	4618      	mov	r0, r3
  400898:	f8d7 10d4 	ldr.w	r1, [r7, #212]	; 0xd4
  40089c:	4b09      	ldr	r3, [pc, #36]	; (4008c4 <debugPrintStringInt+0x110>)
  40089e:	4798      	blx	r3
	}
}
  4008a0:	37d8      	adds	r7, #216	; 0xd8
  4008a2:	46bd      	mov	sp, r7
  4008a4:	bd80      	pop	{r7, pc}
  4008a6:	bf00      	nop
  4008a8:	20003970 	.word	0x20003970
  4008ac:	00407ed5 	.word	0x00407ed5
  4008b0:	0040cb1d 	.word	0x0040cb1d
  4008b4:	0040c9a5 	.word	0x0040c9a5
  4008b8:	200001ac 	.word	0x200001ac
  4008bc:	200011fc 	.word	0x200011fc
  4008c0:	00409081 	.word	0x00409081
  4008c4:	0040126d 	.word	0x0040126d

004008c8 <debugPrintString>:

void __attribute__((optimize("O0"))) debugPrintString(char* str)
{
  4008c8:	b580      	push	{r7, lr}
  4008ca:	b0b6      	sub	sp, #216	; 0xd8
  4008cc:	af00      	add	r7, sp, #0
  4008ce:	6078      	str	r0, [r7, #4]
	size_t length = 0;
  4008d0:	2300      	movs	r3, #0
  4008d2:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
	char timeStampedStr[MAX_DEBUG_STRING_LENGTH];
	int len = itoa(sgSysTickCount, timeStampedStr, 10);
  4008d6:	4b27      	ldr	r3, [pc, #156]	; (400974 <debugPrintString+0xac>)
  4008d8:	681b      	ldr	r3, [r3, #0]
  4008da:	461a      	mov	r2, r3
  4008dc:	f107 0308 	add.w	r3, r7, #8
  4008e0:	4610      	mov	r0, r2
  4008e2:	4619      	mov	r1, r3
  4008e4:	220a      	movs	r2, #10
  4008e6:	4b24      	ldr	r3, [pc, #144]	; (400978 <debugPrintString+0xb0>)
  4008e8:	4798      	blx	r3
  4008ea:	f8c7 00d0 	str.w	r0, [r7, #208]	; 0xd0
	timeStampedStr[len++] = ',';
  4008ee:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
  4008f2:	1c5a      	adds	r2, r3, #1
  4008f4:	f8c7 20d0 	str.w	r2, [r7, #208]	; 0xd0
  4008f8:	f107 02d8 	add.w	r2, r7, #216	; 0xd8
  4008fc:	4413      	add	r3, r2
  4008fe:	222c      	movs	r2, #44	; 0x2c
  400900:	f803 2cd0 	strb.w	r2, [r3, #-208]
	strncpy(timeStampedStr+len, str, MAX_DEBUG_STRING_LENGTH-len);	
  400904:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
  400908:	f107 0208 	add.w	r2, r7, #8
  40090c:	441a      	add	r2, r3
  40090e:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
  400912:	f1c3 03c8 	rsb	r3, r3, #200	; 0xc8
  400916:	4610      	mov	r0, r2
  400918:	6879      	ldr	r1, [r7, #4]
  40091a:	461a      	mov	r2, r3
  40091c:	4b17      	ldr	r3, [pc, #92]	; (40097c <debugPrintString+0xb4>)
  40091e:	4798      	blx	r3
	length = strlen(timeStampedStr); 
  400920:	f107 0308 	add.w	r3, r7, #8
  400924:	4618      	mov	r0, r3
  400926:	4b16      	ldr	r3, [pc, #88]	; (400980 <debugPrintString+0xb8>)
  400928:	4798      	blx	r3
  40092a:	f8c7 00d4 	str.w	r0, [r7, #212]	; 0xd4
	if(length > 0)
  40092e:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
  400932:	2b00      	cmp	r3, #0
  400934:	d01a      	beq.n	40096c <debugPrintString+0xa4>
	{
		if(brainSettings.debugPrintsEnabled)
  400936:	4b13      	ldr	r3, [pc, #76]	; (400984 <debugPrintString+0xbc>)
  400938:	f893 309f 	ldrb.w	r3, [r3, #159]	; 0x9f
  40093c:	2b00      	cmp	r3, #0
  40093e:	d00e      	beq.n	40095e <debugPrintString+0x96>
		{
			if(config != NULL)
  400940:	4b11      	ldr	r3, [pc, #68]	; (400988 <debugPrintString+0xc0>)
  400942:	681b      	ldr	r3, [r3, #0]
  400944:	2b00      	cmp	r3, #0
  400946:	d00a      	beq.n	40095e <debugPrintString+0x96>
			{
				drv_uart_putData((config->uart), timeStampedStr, length);
  400948:	4b0f      	ldr	r3, [pc, #60]	; (400988 <debugPrintString+0xc0>)
  40094a:	681b      	ldr	r3, [r3, #0]
  40094c:	681a      	ldr	r2, [r3, #0]
  40094e:	f107 0308 	add.w	r3, r7, #8
  400952:	4610      	mov	r0, r2
  400954:	4619      	mov	r1, r3
  400956:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
  40095a:	4b0c      	ldr	r3, [pc, #48]	; (40098c <debugPrintString+0xc4>)
  40095c:	4798      	blx	r3
			}
		}
		task_debugLogWriteEntry(timeStampedStr, length);
  40095e:	f107 0308 	add.w	r3, r7, #8
  400962:	4618      	mov	r0, r3
  400964:	f8d7 10d4 	ldr.w	r1, [r7, #212]	; 0xd4
  400968:	4b09      	ldr	r3, [pc, #36]	; (400990 <debugPrintString+0xc8>)
  40096a:	4798      	blx	r3
	}
}
  40096c:	37d8      	adds	r7, #216	; 0xd8
  40096e:	46bd      	mov	sp, r7
  400970:	bd80      	pop	{r7, pc}
  400972:	bf00      	nop
  400974:	20003970 	.word	0x20003970
  400978:	00407ed5 	.word	0x00407ed5
  40097c:	0040cb1d 	.word	0x0040cb1d
  400980:	0040c9a5 	.word	0x0040c9a5
  400984:	200001ac 	.word	0x200001ac
  400988:	200011fc 	.word	0x200011fc
  40098c:	00409081 	.word	0x00409081
  400990:	0040126d 	.word	0x0040126d

00400994 <task_commandHandler>:
};	
/**
 * \brief This task, when started will loop back \r\n terminated strings
 */
void task_commandHandler(void *pvParameters)
{
  400994:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	UNUSED(pvParameters);
	int result = 0;
	char buffer[100] = {0};
	int pointer = 0;
	config = (commandProcConfig_t*)pvParameters; 
  400998:	4c83      	ldr	r4, [pc, #524]	; (400ba8 <task_commandHandler+0x214>)
 */
void task_commandHandler(void *pvParameters)
{
	UNUSED(pvParameters);
	int result = 0;
	char buffer[100] = {0};
  40099a:	4b84      	ldr	r3, [pc, #528]	; (400bac <task_commandHandler+0x218>)
  40099c:	4e84      	ldr	r6, [pc, #528]	; (400bb0 <task_commandHandler+0x21c>)
  40099e:	f8df 827c 	ldr.w	r8, [pc, #636]	; 400c1c <task_commandHandler+0x288>
  4009a2:	f8df 927c 	ldr.w	r9, [pc, #636]	; 400c20 <task_commandHandler+0x28c>
  4009a6:	4f83      	ldr	r7, [pc, #524]	; (400bb4 <task_commandHandler+0x220>)
  4009a8:	4d83      	ldr	r5, [pc, #524]	; (400bb8 <task_commandHandler+0x224>)
};	
/**
 * \brief This task, when started will loop back \r\n terminated strings
 */
void task_commandHandler(void *pvParameters)
{
  4009aa:	b0a7      	sub	sp, #156	; 0x9c
  4009ac:	4682      	mov	sl, r0
	UNUSED(pvParameters);
	int result = 0;
	char buffer[100] = {0};
  4009ae:	2100      	movs	r1, #0
  4009b0:	a80d      	add	r0, sp, #52	; 0x34
  4009b2:	2264      	movs	r2, #100	; 0x64
  4009b4:	4798      	blx	r3
	int pointer = 0;
	config = (commandProcConfig_t*)pvParameters; 
  4009b6:	f8c4 a000 	str.w	sl, [r4]
  4009ba:	4653      	mov	r3, sl
  4009bc:	e002      	b.n	4009c4 <task_commandHandler+0x30>
		if(drv_uart_getline(config->uart,buffer,sizeof(buffer)) == STATUS_PASS)
		{
			//drv_uart_putString(&uart1Config,buffer); 
			processCommand(buffer,sizeof(buffer)); 
		}		
		vTaskDelay(10); 
  4009be:	200a      	movs	r0, #10
  4009c0:	47a8      	blx	r5
  4009c2:	6823      	ldr	r3, [r4, #0]
	//drv_uart_init(config->uart);
	
	//char val = 0xA5; 
	while(1)
	{
		if(drv_uart_getline(config->uart,buffer,sizeof(buffer)) == STATUS_PASS)
  4009c4:	6818      	ldr	r0, [r3, #0]
  4009c6:	a90d      	add	r1, sp, #52	; 0x34
  4009c8:	2264      	movs	r2, #100	; 0x64
  4009ca:	47b0      	blx	r6
  4009cc:	2800      	cmp	r0, #0
  4009ce:	d1f6      	bne.n	4009be <task_commandHandler+0x2a>
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error 
 ***********************************************************************************************/
static status_t processCommand(char* command, size_t cmdSize)
{
	status_t status = STATUS_PASS; 
	if(strncmp(command, "Record\r\n",cmdSize) == 0)
  4009d0:	a80d      	add	r0, sp, #52	; 0x34
  4009d2:	497a      	ldr	r1, [pc, #488]	; (400bbc <task_commandHandler+0x228>)
  4009d4:	f8df a244 	ldr.w	sl, [pc, #580]	; 400c1c <task_commandHandler+0x288>
  4009d8:	2264      	movs	r2, #100	; 0x64
  4009da:	47c0      	blx	r8
  4009dc:	b310      	cbz	r0, 400a24 <task_commandHandler+0x90>
	{
		task_stateMachine_EnqueueEvent(SYS_EVENT_RECORD_SWITCH,0);
		printString( "ACK\r\n");
	}
	else if(strncmp(command, "Reset\r\n",cmdSize) == 0)
  4009de:	a80d      	add	r0, sp, #52	; 0x34
  4009e0:	4977      	ldr	r1, [pc, #476]	; (400bc0 <task_commandHandler+0x22c>)
  4009e2:	2264      	movs	r2, #100	; 0x64
  4009e4:	47d0      	blx	sl
  4009e6:	2800      	cmp	r0, #0
  4009e8:	d048      	beq.n	400a7c <task_commandHandler+0xe8>
	{
		task_stateMachine_EnqueueEvent(SYS_EVENT_RESET_SWITCH,0);
		printString( "ACK\r\n");
	}
	else if(strncmp(command, "Power\r\n",cmdSize) == 0)
  4009ea:	4976      	ldr	r1, [pc, #472]	; (400bc4 <task_commandHandler+0x230>)
  4009ec:	a80d      	add	r0, sp, #52	; 0x34
  4009ee:	2264      	movs	r2, #100	; 0x64
  4009f0:	47d0      	blx	sl
  4009f2:	4601      	mov	r1, r0
  4009f4:	b1c0      	cbz	r0, 400a28 <task_commandHandler+0x94>
	{
		task_stateMachine_EnqueueEvent(SYS_EVENT_POWER_SWITCH,0);
		printString( "ACK\r\n");
	}
	else if(strncmp(command, "GetState\r\n",cmdSize) == 0)
  4009f6:	a80d      	add	r0, sp, #52	; 0x34
  4009f8:	4973      	ldr	r1, [pc, #460]	; (400bc8 <task_commandHandler+0x234>)
  4009fa:	2264      	movs	r2, #100	; 0x64
  4009fc:	47d0      	blx	sl
  4009fe:	2800      	cmp	r0, #0
  400a00:	d03f      	beq.n	400a82 <task_commandHandler+0xee>
			default: 
			printString("UnDef\r\n");
			break;			
		}
	}
	else if(strncmp(command, "AutoOff",7) == 0)
  400a02:	a80d      	add	r0, sp, #52	; 0x34
  400a04:	4971      	ldr	r1, [pc, #452]	; (400bcc <task_commandHandler+0x238>)
  400a06:	2207      	movs	r2, #7
  400a08:	47d0      	blx	sl
  400a0a:	b998      	cbnz	r0, 400a34 <task_commandHandler+0xa0>
	{
		if(*(command+7) == '1')
  400a0c:	f89d 303b 	ldrb.w	r3, [sp, #59]	; 0x3b
  400a10:	2b31      	cmp	r3, #49	; 0x31
  400a12:	d078      	beq.n	400b06 <task_commandHandler+0x172>
		{
			brainSettings.autoTurnOff = true; 
		}
		else
		{
			brainSettings.autoTurnOff = false; 
  400a14:	4b6e      	ldr	r3, [pc, #440]	; (400bd0 <task_commandHandler+0x23c>)
  400a16:	f883 009e 	strb.w	r0, [r3, #158]	; 0x9e
	}
}

void printString(char* str)
{
	drv_uart_putString((config->uart), str);
  400a1a:	6823      	ldr	r3, [r4, #0]
  400a1c:	496d      	ldr	r1, [pc, #436]	; (400bd4 <task_commandHandler+0x240>)
  400a1e:	6818      	ldr	r0, [r3, #0]
  400a20:	47b8      	blx	r7
  400a22:	e7cc      	b.n	4009be <task_commandHandler+0x2a>
static status_t processCommand(char* command, size_t cmdSize)
{
	status_t status = STATUS_PASS; 
	if(strncmp(command, "Record\r\n",cmdSize) == 0)
	{
		task_stateMachine_EnqueueEvent(SYS_EVENT_RECORD_SWITCH,0);
  400a24:	4601      	mov	r1, r0
  400a26:	2002      	movs	r0, #2
		task_stateMachine_EnqueueEvent(SYS_EVENT_RESET_SWITCH,0);
		printString( "ACK\r\n");
	}
	else if(strncmp(command, "Power\r\n",cmdSize) == 0)
	{
		task_stateMachine_EnqueueEvent(SYS_EVENT_POWER_SWITCH,0);
  400a28:	47c8      	blx	r9
	}
}

void printString(char* str)
{
	drv_uart_putString((config->uart), str);
  400a2a:	6823      	ldr	r3, [r4, #0]
  400a2c:	4969      	ldr	r1, [pc, #420]	; (400bd4 <task_commandHandler+0x240>)
  400a2e:	6818      	ldr	r0, [r3, #0]
  400a30:	47b8      	blx	r7
  400a32:	e7c4      	b.n	4009be <task_commandHandler+0x2a>
		{
			brainSettings.autoTurnOff = false; 
		}
		printString( "ACK\r\n");
	}	
	else if(strncmp(command, "SetSerial",9) == 0)
  400a34:	a80d      	add	r0, sp, #52	; 0x34
  400a36:	4968      	ldr	r1, [pc, #416]	; (400bd8 <task_commandHandler+0x244>)
  400a38:	2209      	movs	r2, #9
  400a3a:	47d0      	blx	sl
  400a3c:	4683      	mov	fp, r0
	{
		//check that the size makes sense
		cmdSize = strlen(command);
  400a3e:	a80d      	add	r0, sp, #52	; 0x34
		{
			brainSettings.autoTurnOff = false; 
		}
		printString( "ACK\r\n");
	}	
	else if(strncmp(command, "SetSerial",9) == 0)
  400a40:	f1bb 0f00 	cmp.w	fp, #0
  400a44:	d13c      	bne.n	400ac0 <task_commandHandler+0x12c>
	{
		//check that the size makes sense
		cmdSize = strlen(command);
  400a46:	f8df c1b4 	ldr.w	ip, [pc, #436]	; 400bfc <task_commandHandler+0x268>
  400a4a:	47e0      	blx	ip
		if((cmdSize -9) > 3)
  400a4c:	f1a0 0309 	sub.w	r3, r0, #9
  400a50:	2b03      	cmp	r3, #3
  400a52:	d90e      	bls.n	400a72 <task_commandHandler+0xde>
		{
			//get rid of the \r\n
			command[cmdSize-2] = NULL;
  400a54:	ab26      	add	r3, sp, #152	; 0x98
  400a56:	4403      	add	r3, r0
			strncpy(nvmSettings.suitNumber, command+9, 7);	//restrict the suit number size to 6
  400a58:	f10d 013d 	add.w	r1, sp, #61	; 0x3d
		//check that the size makes sense
		cmdSize = strlen(command);
		if((cmdSize -9) > 3)
		{
			//get rid of the \r\n
			command[cmdSize-2] = NULL;
  400a5c:	f803 bc66 	strb.w	fp, [r3, #-102]
			strncpy(nvmSettings.suitNumber, command+9, 7);	//restrict the suit number size to 6
  400a60:	485e      	ldr	r0, [pc, #376]	; (400bdc <task_commandHandler+0x248>)
  400a62:	4b5f      	ldr	r3, [pc, #380]	; (400be0 <task_commandHandler+0x24c>)
  400a64:	2207      	movs	r2, #7
  400a66:	4798      	blx	r3
			if(saveNvmSettings() == STATUS_PASS)
  400a68:	f8df c194 	ldr.w	ip, [pc, #404]	; 400c00 <task_commandHandler+0x26c>
  400a6c:	47e0      	blx	ip
  400a6e:	2800      	cmp	r0, #0
  400a70:	d0d3      	beq.n	400a1a <task_commandHandler+0x86>
	}
}

void printString(char* str)
{
	drv_uart_putString((config->uart), str);
  400a72:	6823      	ldr	r3, [r4, #0]
  400a74:	495b      	ldr	r1, [pc, #364]	; (400be4 <task_commandHandler+0x250>)
  400a76:	6818      	ldr	r0, [r3, #0]
  400a78:	47b8      	blx	r7
  400a7a:	e7a0      	b.n	4009be <task_commandHandler+0x2a>
		task_stateMachine_EnqueueEvent(SYS_EVENT_RECORD_SWITCH,0);
		printString( "ACK\r\n");
	}
	else if(strncmp(command, "Reset\r\n",cmdSize) == 0)
	{
		task_stateMachine_EnqueueEvent(SYS_EVENT_RESET_SWITCH,0);
  400a7c:	4601      	mov	r1, r0
  400a7e:	2001      	movs	r0, #1
  400a80:	e7d2      	b.n	400a28 <task_commandHandler+0x94>
		task_stateMachine_EnqueueEvent(SYS_EVENT_POWER_SWITCH,0);
		printString( "ACK\r\n");
	}
	else if(strncmp(command, "GetState\r\n",cmdSize) == 0)
	{
		switch(getCurrentState())
  400a82:	f8df c1a0 	ldr.w	ip, [pc, #416]	; 400c24 <task_commandHandler+0x290>
  400a86:	47e0      	blx	ip
  400a88:	3802      	subs	r0, #2
  400a8a:	2804      	cmp	r0, #4
  400a8c:	d865      	bhi.n	400b5a <task_commandHandler+0x1c6>
  400a8e:	e8df f000 	tbb	[pc, r0]
  400a92:	0d12      	.short	0x0d12
  400a94:	0308      	.short	0x0308
  400a96:	08          	.byte	0x08
  400a97:	00          	.byte	0x00
	}
}

void printString(char* str)
{
	drv_uart_putString((config->uart), str);
  400a98:	6823      	ldr	r3, [r4, #0]
  400a9a:	4953      	ldr	r1, [pc, #332]	; (400be8 <task_commandHandler+0x254>)
  400a9c:	6818      	ldr	r0, [r3, #0]
  400a9e:	47b8      	blx	r7
  400aa0:	e78d      	b.n	4009be <task_commandHandler+0x2a>
  400aa2:	6823      	ldr	r3, [r4, #0]
  400aa4:	4951      	ldr	r1, [pc, #324]	; (400bec <task_commandHandler+0x258>)
  400aa6:	6818      	ldr	r0, [r3, #0]
  400aa8:	47b8      	blx	r7
  400aaa:	e788      	b.n	4009be <task_commandHandler+0x2a>
  400aac:	6823      	ldr	r3, [r4, #0]
  400aae:	4950      	ldr	r1, [pc, #320]	; (400bf0 <task_commandHandler+0x25c>)
  400ab0:	6818      	ldr	r0, [r3, #0]
  400ab2:	47b8      	blx	r7
  400ab4:	e783      	b.n	4009be <task_commandHandler+0x2a>
  400ab6:	6823      	ldr	r3, [r4, #0]
  400ab8:	4941      	ldr	r1, [pc, #260]	; (400bc0 <task_commandHandler+0x22c>)
  400aba:	6818      	ldr	r0, [r3, #0]
  400abc:	47b8      	blx	r7
  400abe:	e77e      	b.n	4009be <task_commandHandler+0x2a>
				return;
			}
		}
		printString( "NACK\r\n");
	}
	else if (strncmp(command, "GetSerial",9) == 0)
  400ac0:	494c      	ldr	r1, [pc, #304]	; (400bf4 <task_commandHandler+0x260>)
  400ac2:	2209      	movs	r2, #9
  400ac4:	47d0      	blx	sl
  400ac6:	2800      	cmp	r0, #0
  400ac8:	d04c      	beq.n	400b64 <task_commandHandler+0x1d0>
	{
		printString(nvmSettings.suitNumber);
		printString("\r\nACK\r\n");		
	}
	else if (strncmp(command, "EnableCSV", 9) == 0)
  400aca:	a80d      	add	r0, sp, #52	; 0x34
  400acc:	494a      	ldr	r1, [pc, #296]	; (400bf8 <task_commandHandler+0x264>)
  400ace:	2209      	movs	r2, #9
  400ad0:	47d0      	blx	sl
  400ad2:	b9e8      	cbnz	r0, 400b10 <task_commandHandler+0x17c>
	{
		cmdSize = strlen(command);
  400ad4:	a80d      	add	r0, sp, #52	; 0x34
  400ad6:	4949      	ldr	r1, [pc, #292]	; (400bfc <task_commandHandler+0x268>)
  400ad8:	4788      	blx	r1
		if ((cmdSize - 9) >= 1)
  400ada:	2809      	cmp	r0, #9
  400adc:	d0c9      	beq.n	400a72 <task_commandHandler+0xde>
		{
			command[cmdSize - 2] = NULL;
  400ade:	aa26      	add	r2, sp, #152	; 0x98
  400ae0:	4410      	add	r0, r2
  400ae2:	2200      	movs	r2, #0
  400ae4:	f800 2c66 	strb.w	r2, [r0, #-102]
			if (command[9] == '0')
  400ae8:	f89d 303d 	ldrb.w	r3, [sp, #61]	; 0x3d
  400aec:	2b30      	cmp	r3, #48	; 0x30
  400aee:	f000 80e2 	beq.w	400cb6 <task_commandHandler+0x322>
				{
					printString("ACK\r\n");
					return;
				}
			}
			else if(command[9] == '1')
  400af2:	2b31      	cmp	r3, #49	; 0x31
  400af4:	d1bd      	bne.n	400a72 <task_commandHandler+0xde>
			{
				nvmSettings.enableCsvFormat = 1;
  400af6:	4939      	ldr	r1, [pc, #228]	; (400bdc <task_commandHandler+0x248>)
				if(saveNvmSettings() == STATUS_PASS)
  400af8:	4a41      	ldr	r2, [pc, #260]	; (400c00 <task_commandHandler+0x26c>)
					return;
				}
			}
			else if(command[9] == '1')
			{
				nvmSettings.enableCsvFormat = 1;
  400afa:	2301      	movs	r3, #1
  400afc:	610b      	str	r3, [r1, #16]
				if(saveNvmSettings() == STATUS_PASS)
  400afe:	4790      	blx	r2
  400b00:	2800      	cmp	r0, #0
  400b02:	d1b6      	bne.n	400a72 <task_commandHandler+0xde>
  400b04:	e789      	b.n	400a1a <task_commandHandler+0x86>
	}
	else if(strncmp(command, "AutoOff",7) == 0)
	{
		if(*(command+7) == '1')
		{
			brainSettings.autoTurnOff = true; 
  400b06:	4a32      	ldr	r2, [pc, #200]	; (400bd0 <task_commandHandler+0x23c>)
  400b08:	2301      	movs	r3, #1
  400b0a:	f882 309e 	strb.w	r3, [r2, #158]	; 0x9e
  400b0e:	e784      	b.n	400a1a <task_commandHandler+0x86>
				}
			}
		}
		printString( "NACK\r\n");
	}
	else if (strncmp(command, "SetRecordName",13) == 0)
  400b10:	a80d      	add	r0, sp, #52	; 0x34
  400b12:	493c      	ldr	r1, [pc, #240]	; (400c04 <task_commandHandler+0x270>)
  400b14:	220d      	movs	r2, #13
  400b16:	47d0      	blx	sl
  400b18:	2800      	cmp	r0, #0
  400b1a:	d12c      	bne.n	400b76 <task_commandHandler+0x1e2>
	{
		//check if size makes sense
		cmdSize = strlen(command);
  400b1c:	4b37      	ldr	r3, [pc, #220]	; (400bfc <task_commandHandler+0x268>)
  400b1e:	a80d      	add	r0, sp, #52	; 0x34
  400b20:	4798      	blx	r3
		if (((cmdSize - 13) < MAX_FILE_NAME_LENGTH) && ((cmdSize - 13) > 0))
  400b22:	f1a0 030e 	sub.w	r3, r0, #14
  400b26:	2b4d      	cmp	r3, #77	; 0x4d
		printString( "NACK\r\n");
	}
	else if (strncmp(command, "SetRecordName",13) == 0)
	{
		//check if size makes sense
		cmdSize = strlen(command);
  400b28:	4682      	mov	sl, r0
		if (((cmdSize - 13) < MAX_FILE_NAME_LENGTH) && ((cmdSize - 13) > 0))
  400b2a:	d8a2      	bhi.n	400a72 <task_commandHandler+0xde>
		{
			//get rid of the \r\n
			command[cmdSize - 2] = NULL;
  400b2c:	aa26      	add	r2, sp, #152	; 0x98
  400b2e:	4402      	add	r2, r0
  400b30:	2300      	movs	r3, #0
			memset(brainSettings.fileName, NULL, sizeof(brainSettings.fileName));	//clear the existing name first
  400b32:	4619      	mov	r1, r3
		//check if size makes sense
		cmdSize = strlen(command);
		if (((cmdSize - 13) < MAX_FILE_NAME_LENGTH) && ((cmdSize - 13) > 0))
		{
			//get rid of the \r\n
			command[cmdSize - 2] = NULL;
  400b34:	f802 3c66 	strb.w	r3, [r2, #-102]
			memset(brainSettings.fileName, NULL, sizeof(brainSettings.fileName));	//clear the existing name first
  400b38:	f8df c070 	ldr.w	ip, [pc, #112]	; 400bac <task_commandHandler+0x218>
  400b3c:	4832      	ldr	r0, [pc, #200]	; (400c08 <task_commandHandler+0x274>)
  400b3e:	224f      	movs	r2, #79	; 0x4f
  400b40:	47e0      	blx	ip
			strncpy(brainSettings.fileName, (command + 13), (cmdSize - 13));	//write the new name to settings file
  400b42:	f10d 0141 	add.w	r1, sp, #65	; 0x41
  400b46:	f1aa 020d 	sub.w	r2, sl, #13
  400b4a:	4b25      	ldr	r3, [pc, #148]	; (400be0 <task_commandHandler+0x24c>)
  400b4c:	482e      	ldr	r0, [pc, #184]	; (400c08 <task_commandHandler+0x274>)
  400b4e:	4798      	blx	r3
	}
}

void printString(char* str)
{
	drv_uart_putString((config->uart), str);
  400b50:	6823      	ldr	r3, [r4, #0]
  400b52:	4920      	ldr	r1, [pc, #128]	; (400bd4 <task_commandHandler+0x240>)
  400b54:	6818      	ldr	r0, [r3, #0]
  400b56:	47b8      	blx	r7
  400b58:	e731      	b.n	4009be <task_commandHandler+0x2a>
  400b5a:	6823      	ldr	r3, [r4, #0]
  400b5c:	492b      	ldr	r1, [pc, #172]	; (400c0c <task_commandHandler+0x278>)
  400b5e:	6818      	ldr	r0, [r3, #0]
  400b60:	47b8      	blx	r7
  400b62:	e72c      	b.n	4009be <task_commandHandler+0x2a>
  400b64:	6823      	ldr	r3, [r4, #0]
  400b66:	491d      	ldr	r1, [pc, #116]	; (400bdc <task_commandHandler+0x248>)
  400b68:	6818      	ldr	r0, [r3, #0]
  400b6a:	47b8      	blx	r7
  400b6c:	6823      	ldr	r3, [r4, #0]
  400b6e:	4928      	ldr	r1, [pc, #160]	; (400c10 <task_commandHandler+0x27c>)
  400b70:	6818      	ldr	r0, [r3, #0]
  400b72:	47b8      	blx	r7
  400b74:	e723      	b.n	4009be <task_commandHandler+0x2a>
			printString("ACK\r\n");
			return;
		}
		printString("NACK\r\n");
	}
	else if (strncmp(command, "GetRecordName",13) == 0)
  400b76:	a80d      	add	r0, sp, #52	; 0x34
  400b78:	4926      	ldr	r1, [pc, #152]	; (400c14 <task_commandHandler+0x280>)
  400b7a:	f8df a0a0 	ldr.w	sl, [pc, #160]	; 400c1c <task_commandHandler+0x288>
  400b7e:	220d      	movs	r2, #13
  400b80:	47c0      	blx	r8
  400b82:	2800      	cmp	r0, #0
  400b84:	f000 80a0 	beq.w	400cc8 <task_commandHandler+0x334>
	{
		snprintf(stringBuf, sizeof(stringBuf), "%s\r\n",dataLogFileName);
		printString(stringBuf);
	}
	else if(strncmp(command, "DebugEn",7) == 0)
  400b88:	a80d      	add	r0, sp, #52	; 0x34
  400b8a:	4923      	ldr	r1, [pc, #140]	; (400c18 <task_commandHandler+0x284>)
  400b8c:	2207      	movs	r2, #7
  400b8e:	47d0      	blx	sl
  400b90:	2800      	cmp	r0, #0
  400b92:	d149      	bne.n	400c28 <task_commandHandler+0x294>
	{
		if(*(command+7) == '1')
  400b94:	f89d 303b 	ldrb.w	r3, [sp, #59]	; 0x3b
  400b98:	2b31      	cmp	r3, #49	; 0x31
  400b9a:	f000 80a2 	beq.w	400ce2 <task_commandHandler+0x34e>
		{
			brainSettings.debugPrintsEnabled = true; 
		}
		else
		{
			brainSettings.debugPrintsEnabled = false; 
  400b9e:	4a0c      	ldr	r2, [pc, #48]	; (400bd0 <task_commandHandler+0x23c>)
  400ba0:	f882 009f 	strb.w	r0, [r2, #159]	; 0x9f
  400ba4:	e739      	b.n	400a1a <task_commandHandler+0x86>
  400ba6:	bf00      	nop
  400ba8:	200011fc 	.word	0x200011fc
  400bac:	0040c31d 	.word	0x0040c31d
  400bb0:	00408f35 	.word	0x00408f35
  400bb4:	0040904d 	.word	0x0040904d
  400bb8:	004072ed 	.word	0x004072ed
  400bbc:	00415180 	.word	0x00415180
  400bc0:	004154a0 	.word	0x004154a0
  400bc4:	00415194 	.word	0x00415194
  400bc8:	0041519c 	.word	0x0041519c
  400bcc:	004151cc 	.word	0x004151cc
  400bd0:	200001ac 	.word	0x200001ac
  400bd4:	0041518c 	.word	0x0041518c
  400bd8:	004151d4 	.word	0x004151d4
  400bdc:	20003e14 	.word	0x20003e14
  400be0:	0040cb1d 	.word	0x0040cb1d
  400be4:	004151e0 	.word	0x004151e0
  400be8:	004151bc 	.word	0x004151bc
  400bec:	004151b0 	.word	0x004151b0
  400bf0:	004151a8 	.word	0x004151a8
  400bf4:	004151e8 	.word	0x004151e8
  400bf8:	004151fc 	.word	0x004151fc
  400bfc:	0040c9a5 	.word	0x0040c9a5
  400c00:	00407fc1 	.word	0x00407fc1
  400c04:	00415208 	.word	0x00415208
  400c08:	200001e6 	.word	0x200001e6
  400c0c:	004151c4 	.word	0x004151c4
  400c10:	004151f4 	.word	0x004151f4
  400c14:	00415218 	.word	0x00415218
  400c18:	00415230 	.word	0x00415230
  400c1c:	0040ca69 	.word	0x0040ca69
  400c20:	00401a99 	.word	0x00401a99
  400c24:	00401c29 	.word	0x00401c29
		}
		printString( "ACK\r\n");
	}				
	else if (strncmp(command, "CheckRssi\r\n",cmdSize) == 0)
  400c28:	a80d      	add	r0, sp, #52	; 0x34
  400c2a:	497f      	ldr	r1, [pc, #508]	; (400e28 <task_commandHandler+0x494>)
  400c2c:	2264      	movs	r2, #100	; 0x64
  400c2e:	47d0      	blx	sl
  400c30:	2800      	cmp	r0, #0
  400c32:	f000 80a7 	beq.w	400d84 <task_commandHandler+0x3f0>
		printString("RSSI level:\r\n");
		task_quintic_checkRssiLevel(&quinticConfig[0]);
		task_quintic_checkRssiLevel(&quinticConfig[1]);
		task_quintic_checkRssiLevel(&quinticConfig[2]);
	}	
	else if(strncmp(command, "rstBLE\r\n",cmdSize) == 0)
  400c36:	a80d      	add	r0, sp, #52	; 0x34
  400c38:	497c      	ldr	r1, [pc, #496]	; (400e2c <task_commandHandler+0x498>)
  400c3a:	2264      	movs	r2, #100	; 0x64
  400c3c:	47d0      	blx	sl
  400c3e:	4683      	mov	fp, r0
  400c40:	2800      	cmp	r0, #0
  400c42:	f000 80c3 	beq.w	400dcc <task_commandHandler+0x438>
		drv_gpio_setPinState(quinticConfig[2].resetPin, DRV_GPIO_PIN_STATE_HIGH);
		printString("Pin reset\r\n");
		enableRecording = false;
	}
		
	else if(strncmp(command, "disableUARTs\r\n",cmdSize) == 0)
  400c46:	a80d      	add	r0, sp, #52	; 0x34
  400c48:	4979      	ldr	r1, [pc, #484]	; (400e30 <task_commandHandler+0x49c>)
  400c4a:	2264      	movs	r2, #100	; 0x64
  400c4c:	47d0      	blx	sl
  400c4e:	4683      	mov	fp, r0
  400c50:	2800      	cmp	r0, #0
  400c52:	f000 80a6 	beq.w	400da2 <task_commandHandler+0x40e>
		drv_uart_deInit(&usart1Config);
		drv_gpio_ConfigureBLEForProgramming(); 
		printString("UARTs set as High impedance\r\n");
		enableRecording = false;
	}	
	else if(strncmp(command, "setTime",7) == 0)
  400c56:	a80d      	add	r0, sp, #52	; 0x34
  400c58:	4976      	ldr	r1, [pc, #472]	; (400e34 <task_commandHandler+0x4a0>)
  400c5a:	2207      	movs	r2, #7
  400c5c:	47d0      	blx	sl
  400c5e:	2800      	cmp	r0, #0
  400c60:	d144      	bne.n	400cec <task_commandHandler+0x358>
	{
		if(strlen(command) >= 24)
  400c62:	a80d      	add	r0, sp, #52	; 0x34
  400c64:	4974      	ldr	r1, [pc, #464]	; (400e38 <task_commandHandler+0x4a4>)
  400c66:	4788      	blx	r1
  400c68:	2817      	cmp	r0, #23
  400c6a:	f67f aea8 	bls.w	4009be <task_commandHandler+0x2a>

static void setTimeFromString(char* dateTime)
{
	uint32_t year, month, day, dow; //dow is day of week (1-7)
	uint32_t hour, minute, second; 
	if(sscanf(dateTime,"%d-%d-%d-%d-%d:%d:%d\r\n", &year, &month, &day, &dow, &hour, &minute, &second ) == 7)
  400c6e:	aa08      	add	r2, sp, #32
  400c70:	ab09      	add	r3, sp, #36	; 0x24
  400c72:	9200      	str	r2, [sp, #0]
  400c74:	9301      	str	r3, [sp, #4]
  400c76:	a90a      	add	r1, sp, #40	; 0x28
  400c78:	aa0b      	add	r2, sp, #44	; 0x2c
  400c7a:	ab0c      	add	r3, sp, #48	; 0x30
  400c7c:	9102      	str	r1, [sp, #8]
  400c7e:	9203      	str	r2, [sp, #12]
  400c80:	9304      	str	r3, [sp, #16]
  400c82:	f10d 003b 	add.w	r0, sp, #59	; 0x3b
  400c86:	496d      	ldr	r1, [pc, #436]	; (400e3c <task_commandHandler+0x4a8>)
  400c88:	f8df c230 	ldr.w	ip, [pc, #560]	; 400ebc <task_commandHandler+0x528>
  400c8c:	aa06      	add	r2, sp, #24
  400c8e:	ab07      	add	r3, sp, #28
  400c90:	47e0      	blx	ip
  400c92:	2807      	cmp	r0, #7
  400c94:	f47f aeed 	bne.w	400a72 <task_commandHandler+0xde>
	{
		// we successfully parsed the data, set the time and date
		rtc_set_time(RTC,hour,minute,second); 
  400c98:	a90a      	add	r1, sp, #40	; 0x28
  400c9a:	c90e      	ldmia	r1, {r1, r2, r3}
  400c9c:	f8df c220 	ldr.w	ip, [pc, #544]	; 400ec0 <task_commandHandler+0x52c>
  400ca0:	4867      	ldr	r0, [pc, #412]	; (400e40 <task_commandHandler+0x4ac>)
  400ca2:	47e0      	blx	ip
		rtc_set_date(RTC,year,month,day,dow); 
  400ca4:	9809      	ldr	r0, [sp, #36]	; 0x24
  400ca6:	f8df c21c 	ldr.w	ip, [pc, #540]	; 400ec4 <task_commandHandler+0x530>
  400caa:	a906      	add	r1, sp, #24
  400cac:	c90e      	ldmia	r1, {r1, r2, r3}
  400cae:	9000      	str	r0, [sp, #0]
  400cb0:	4863      	ldr	r0, [pc, #396]	; (400e40 <task_commandHandler+0x4ac>)
  400cb2:	47e0      	blx	ip
  400cb4:	e6b1      	b.n	400a1a <task_commandHandler+0x86>
		if ((cmdSize - 9) >= 1)
		{
			command[cmdSize - 2] = NULL;
			if (command[9] == '0')
			{
				nvmSettings.enableCsvFormat = 0;
  400cb6:	4b63      	ldr	r3, [pc, #396]	; (400e44 <task_commandHandler+0x4b0>)
				if(saveNvmSettings() == STATUS_PASS)
  400cb8:	f8df c1b8 	ldr.w	ip, [pc, #440]	; 400e74 <task_commandHandler+0x4e0>
		if ((cmdSize - 9) >= 1)
		{
			command[cmdSize - 2] = NULL;
			if (command[9] == '0')
			{
				nvmSettings.enableCsvFormat = 0;
  400cbc:	611a      	str	r2, [r3, #16]
				if(saveNvmSettings() == STATUS_PASS)
  400cbe:	47e0      	blx	ip
  400cc0:	2800      	cmp	r0, #0
  400cc2:	f47f aed6 	bne.w	400a72 <task_commandHandler+0xde>
  400cc6:	e6a8      	b.n	400a1a <task_commandHandler+0x86>
		}
		printString("NACK\r\n");
	}
	else if (strncmp(command, "GetRecordName",13) == 0)
	{
		snprintf(stringBuf, sizeof(stringBuf), "%s\r\n",dataLogFileName);
  400cc8:	4a5f      	ldr	r2, [pc, #380]	; (400e48 <task_commandHandler+0x4b4>)
  400cca:	4b60      	ldr	r3, [pc, #384]	; (400e4c <task_commandHandler+0x4b8>)
  400ccc:	f8df c1f8 	ldr.w	ip, [pc, #504]	; 400ec8 <task_commandHandler+0x534>
  400cd0:	485f      	ldr	r0, [pc, #380]	; (400e50 <task_commandHandler+0x4bc>)
  400cd2:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
  400cd6:	47e0      	blx	ip
	}
}

void printString(char* str)
{
	drv_uart_putString((config->uart), str);
  400cd8:	6823      	ldr	r3, [r4, #0]
  400cda:	495d      	ldr	r1, [pc, #372]	; (400e50 <task_commandHandler+0x4bc>)
  400cdc:	6818      	ldr	r0, [r3, #0]
  400cde:	47b8      	blx	r7
  400ce0:	e66d      	b.n	4009be <task_commandHandler+0x2a>
	}
	else if(strncmp(command, "DebugEn",7) == 0)
	{
		if(*(command+7) == '1')
		{
			brainSettings.debugPrintsEnabled = true; 
  400ce2:	495c      	ldr	r1, [pc, #368]	; (400e54 <task_commandHandler+0x4c0>)
  400ce4:	2301      	movs	r3, #1
  400ce6:	f881 309f 	strb.w	r3, [r1, #159]	; 0x9f
  400cea:	e696      	b.n	400a1a <task_commandHandler+0x86>
		if(strlen(command) >= 24)
		{
			setTimeFromString(command+7); 
		}
	}
	else if(strncmp(command, "?\r\n",3) == 0)
  400cec:	a80d      	add	r0, sp, #52	; 0x34
  400cee:	495a      	ldr	r1, [pc, #360]	; (400e58 <task_commandHandler+0x4c4>)
  400cf0:	2203      	movs	r2, #3
  400cf2:	47d0      	blx	sl
  400cf4:	2800      	cmp	r0, #0
  400cf6:	f000 816e 	beq.w	400fd6 <task_commandHandler+0x642>
		printf("HEDDOKO BRAIN PACK %s\r\n", VERSION); 
		printf("BUILD DATE: %s %s\r\n", __DATE__,__TIME__);
		printf("SUIT NUMBER: %s\r\n",brainSettings.suitNumber); 
		printf("SUIT TIME: %s \r\n",getTimeString());  		
	}
	else if(strncmp(command, "flushUarts\r\n",cmdSize) == 0)
  400cfa:	a80d      	add	r0, sp, #52	; 0x34
  400cfc:	4957      	ldr	r1, [pc, #348]	; (400e5c <task_commandHandler+0x4c8>)
  400cfe:	2264      	movs	r2, #100	; 0x64
  400d00:	47d0      	blx	sl
  400d02:	2800      	cmp	r0, #0
  400d04:	f000 815c 	beq.w	400fc0 <task_commandHandler+0x62c>
	{
		drv_uart_flushRx(&usart1Config);
		drv_uart_flushRx(&uart0Config);
		drv_uart_flushRx(&usart0Config);
	}
	else if(strncmp(command,"getStats\r\n", cmdSize) == 0)
  400d08:	a80d      	add	r0, sp, #52	; 0x34
  400d0a:	4955      	ldr	r1, [pc, #340]	; (400e60 <task_commandHandler+0x4cc>)
  400d0c:	2264      	movs	r2, #100	; 0x64
  400d0e:	47d0      	blx	sl
  400d10:	4683      	mov	fp, r0
  400d12:	2800      	cmp	r0, #0
  400d14:	f000 80dc 	beq.w	400ed0 <task_commandHandler+0x53c>
	{
		printStats(); 
	}	
	else if(strncmp(command,"HardReset\r\n", cmdSize) == 0)	
  400d18:	a80d      	add	r0, sp, #52	; 0x34
  400d1a:	4952      	ldr	r1, [pc, #328]	; (400e64 <task_commandHandler+0x4d0>)
  400d1c:	2264      	movs	r2, #100	; 0x64
  400d1e:	47d0      	blx	sl
  400d20:	2800      	cmp	r0, #0
  400d22:	d07c      	beq.n	400e1e <task_commandHandler+0x48a>
	{
		rstc_start_software_reset(RSTC);
	}
	else if (strncmp(command,"debugPackets\r\n", cmdSize) == 0)
  400d24:	a80d      	add	r0, sp, #52	; 0x34
  400d26:	4950      	ldr	r1, [pc, #320]	; (400e68 <task_commandHandler+0x4d4>)
  400d28:	f8df a1a0 	ldr.w	sl, [pc, #416]	; 400ecc <task_commandHandler+0x538>
  400d2c:	2264      	movs	r2, #100	; 0x64
  400d2e:	47c0      	blx	r8
  400d30:	2800      	cmp	r0, #0
  400d32:	d06f      	beq.n	400e14 <task_commandHandler+0x480>
	{
		//turns on the zeroing of missing packets in the output data. 
		brainSettings.debugPackets = true; 
	}
	else if (strncmp(command,"chMap ", 6) == 0)
  400d34:	a80d      	add	r0, sp, #52	; 0x34
  400d36:	494d      	ldr	r1, [pc, #308]	; (400e6c <task_commandHandler+0x4d8>)
  400d38:	2206      	movs	r2, #6
  400d3a:	47d0      	blx	sl
  400d3c:	2800      	cmp	r0, #0
  400d3e:	f000 816d 	beq.w	40101c <task_commandHandler+0x688>
		strncpy(brainSettings.channelmap, command+6, 10);
		strncpy((brainSettings.channelmap)+10, "\r\n", 2);	//Add CR+LF at the end of the srting
		printString("Received new channel map request:\r\n");
		printString(brainSettings.channelmap);
	}
	else if (strncmp(command, "setLedConfig", 12) == 0)
  400d42:	a80d      	add	r0, sp, #52	; 0x34
  400d44:	494a      	ldr	r1, [pc, #296]	; (400e70 <task_commandHandler+0x4dc>)
  400d46:	220c      	movs	r2, #12
  400d48:	47d0      	blx	sl
  400d4a:	2800      	cmp	r0, #0
  400d4c:	f040 8183 	bne.w	401056 <task_commandHandler+0x6c2>
	{
		if (*(command + 12) == '0')
  400d50:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
  400d54:	2b30      	cmp	r3, #48	; 0x30
  400d56:	f000 8176 	beq.w	401046 <task_commandHandler+0x6b2>
			nvmSettings.ledConfiguration.greenLed = DRV_GPIO_PIN_GREEN_LED;
			nvmSettings.ledConfiguration.blueLed = DRV_GPIO_PIN_BLUE_LED;
		}
		else
		{
			nvmSettings.ledConfiguration.redLed = DRV_GPIO_PIN_BLUE_LED;
  400d5a:	f8df c0e8 	ldr.w	ip, [pc, #232]	; 400e44 <task_commandHandler+0x4b0>
  400d5e:	230d      	movs	r3, #13
			nvmSettings.ledConfiguration.greenLed = DRV_GPIO_PIN_GREEN_LED;
  400d60:	220c      	movs	r2, #12
			nvmSettings.ledConfiguration.greenLed = DRV_GPIO_PIN_GREEN_LED;
			nvmSettings.ledConfiguration.blueLed = DRV_GPIO_PIN_BLUE_LED;
		}
		else
		{
			nvmSettings.ledConfiguration.redLed = DRV_GPIO_PIN_BLUE_LED;
  400d62:	f88c 3014 	strb.w	r3, [ip, #20]
			nvmSettings.ledConfiguration.greenLed = DRV_GPIO_PIN_GREEN_LED;
			nvmSettings.ledConfiguration.blueLed = DRV_GPIO_PIN_RED_LED;
  400d66:	230e      	movs	r3, #14
			nvmSettings.ledConfiguration.blueLed = DRV_GPIO_PIN_BLUE_LED;
		}
		else
		{
			nvmSettings.ledConfiguration.redLed = DRV_GPIO_PIN_BLUE_LED;
			nvmSettings.ledConfiguration.greenLed = DRV_GPIO_PIN_GREEN_LED;
  400d68:	f88c 2016 	strb.w	r2, [ip, #22]
			nvmSettings.ledConfiguration.blueLed = DRV_GPIO_PIN_RED_LED;
  400d6c:	f88c 3015 	strb.w	r3, [ip, #21]
		}
		if(saveNvmSettings() == STATUS_PASS)
  400d70:	4940      	ldr	r1, [pc, #256]	; (400e74 <task_commandHandler+0x4e0>)
  400d72:	4788      	blx	r1
	}
}

void printString(char* str)
{
	drv_uart_putString((config->uart), str);
  400d74:	6823      	ldr	r3, [r4, #0]
		{
			nvmSettings.ledConfiguration.redLed = DRV_GPIO_PIN_BLUE_LED;
			nvmSettings.ledConfiguration.greenLed = DRV_GPIO_PIN_GREEN_LED;
			nvmSettings.ledConfiguration.blueLed = DRV_GPIO_PIN_RED_LED;
		}
		if(saveNvmSettings() == STATUS_PASS)
  400d76:	2800      	cmp	r0, #0
  400d78:	f43f ae50 	beq.w	400a1c <task_commandHandler+0x88>
	}
}

void printString(char* str)
{
	drv_uart_putString((config->uart), str);
  400d7c:	493e      	ldr	r1, [pc, #248]	; (400e78 <task_commandHandler+0x4e4>)
  400d7e:	6818      	ldr	r0, [r3, #0]
  400d80:	47b8      	blx	r7
  400d82:	e61c      	b.n	4009be <task_commandHandler+0x2a>
  400d84:	6823      	ldr	r3, [r4, #0]
  400d86:	493d      	ldr	r1, [pc, #244]	; (400e7c <task_commandHandler+0x4e8>)
  400d88:	6818      	ldr	r0, [r3, #0]
  400d8a:	47b8      	blx	r7
		printString( "ACK\r\n");
	}				
	else if (strncmp(command, "CheckRssi\r\n",cmdSize) == 0)
	{
		printString("RSSI level:\r\n");
		task_quintic_checkRssiLevel(&quinticConfig[0]);
  400d8c:	4b3c      	ldr	r3, [pc, #240]	; (400e80 <task_commandHandler+0x4ec>)
  400d8e:	483d      	ldr	r0, [pc, #244]	; (400e84 <task_commandHandler+0x4f0>)
  400d90:	4798      	blx	r3
		task_quintic_checkRssiLevel(&quinticConfig[1]);
  400d92:	f8df c0ec 	ldr.w	ip, [pc, #236]	; 400e80 <task_commandHandler+0x4ec>
  400d96:	483c      	ldr	r0, [pc, #240]	; (400e88 <task_commandHandler+0x4f4>)
  400d98:	47e0      	blx	ip
		task_quintic_checkRssiLevel(&quinticConfig[2]);
  400d9a:	4939      	ldr	r1, [pc, #228]	; (400e80 <task_commandHandler+0x4ec>)
  400d9c:	483b      	ldr	r0, [pc, #236]	; (400e8c <task_commandHandler+0x4f8>)
  400d9e:	4788      	blx	r1
  400da0:	e60d      	b.n	4009be <task_commandHandler+0x2a>
		enableRecording = false;
	}
		
	else if(strncmp(command, "disableUARTs\r\n",cmdSize) == 0)
	{
		drv_uart_deInit(&uart1Config);
  400da2:	f8df c0f0 	ldr.w	ip, [pc, #240]	; 400e94 <task_commandHandler+0x500>
  400da6:	483a      	ldr	r0, [pc, #232]	; (400e90 <task_commandHandler+0x4fc>)
  400da8:	47e0      	blx	ip
		drv_uart_deInit(&usart0Config);
  400daa:	493a      	ldr	r1, [pc, #232]	; (400e94 <task_commandHandler+0x500>)
  400dac:	483a      	ldr	r0, [pc, #232]	; (400e98 <task_commandHandler+0x504>)
  400dae:	4788      	blx	r1
		drv_uart_deInit(&usart1Config);
  400db0:	4a38      	ldr	r2, [pc, #224]	; (400e94 <task_commandHandler+0x500>)
  400db2:	483a      	ldr	r0, [pc, #232]	; (400e9c <task_commandHandler+0x508>)
  400db4:	4790      	blx	r2
		drv_gpio_ConfigureBLEForProgramming(); 
  400db6:	4b3a      	ldr	r3, [pc, #232]	; (400ea0 <task_commandHandler+0x50c>)
  400db8:	4798      	blx	r3
	}
}

void printString(char* str)
{
	drv_uart_putString((config->uart), str);
  400dba:	6823      	ldr	r3, [r4, #0]
  400dbc:	4939      	ldr	r1, [pc, #228]	; (400ea4 <task_commandHandler+0x510>)
  400dbe:	6818      	ldr	r0, [r3, #0]
  400dc0:	47b8      	blx	r7
		drv_uart_deInit(&uart1Config);
		drv_uart_deInit(&usart0Config);
		drv_uart_deInit(&usart1Config);
		drv_gpio_ConfigureBLEForProgramming(); 
		printString("UARTs set as High impedance\r\n");
		enableRecording = false;
  400dc2:	f8df c0ec 	ldr.w	ip, [pc, #236]	; 400eb0 <task_commandHandler+0x51c>
  400dc6:	f88c b000 	strb.w	fp, [ip]
  400dca:	e5f8      	b.n	4009be <task_commandHandler+0x2a>
		task_quintic_checkRssiLevel(&quinticConfig[1]);
		task_quintic_checkRssiLevel(&quinticConfig[2]);
	}	
	else if(strncmp(command, "rstBLE\r\n",cmdSize) == 0)
	{
		drv_gpio_setPinState(quinticConfig[0].resetPin, DRV_GPIO_PIN_STATE_LOW);
  400dcc:	4a2d      	ldr	r2, [pc, #180]	; (400e84 <task_commandHandler+0x4f0>)
  400dce:	4b36      	ldr	r3, [pc, #216]	; (400ea8 <task_commandHandler+0x514>)
  400dd0:	f892 0020 	ldrb.w	r0, [r2, #32]
  400dd4:	4659      	mov	r1, fp
  400dd6:	4798      	blx	r3
		drv_gpio_setPinState(quinticConfig[2].resetPin, DRV_GPIO_PIN_STATE_LOW);
  400dd8:	f8df c0a8 	ldr.w	ip, [pc, #168]	; 400e84 <task_commandHandler+0x4f0>
  400ddc:	4a32      	ldr	r2, [pc, #200]	; (400ea8 <task_commandHandler+0x514>)
  400dde:	f89c 0098 	ldrb.w	r0, [ip, #152]	; 0x98
  400de2:	4659      	mov	r1, fp
  400de4:	4790      	blx	r2
		vTaskDelay(50);
  400de6:	2032      	movs	r0, #50	; 0x32
  400de8:	47a8      	blx	r5
		drv_gpio_setPinState(quinticConfig[0].resetPin, DRV_GPIO_PIN_STATE_HIGH);
  400dea:	4b26      	ldr	r3, [pc, #152]	; (400e84 <task_commandHandler+0x4f0>)
  400dec:	f8df c0b8 	ldr.w	ip, [pc, #184]	; 400ea8 <task_commandHandler+0x514>
  400df0:	f893 0020 	ldrb.w	r0, [r3, #32]
  400df4:	2101      	movs	r1, #1
  400df6:	47e0      	blx	ip
		drv_gpio_setPinState(quinticConfig[2].resetPin, DRV_GPIO_PIN_STATE_HIGH);
  400df8:	4922      	ldr	r1, [pc, #136]	; (400e84 <task_commandHandler+0x4f0>)
  400dfa:	4a2b      	ldr	r2, [pc, #172]	; (400ea8 <task_commandHandler+0x514>)
  400dfc:	f891 0098 	ldrb.w	r0, [r1, #152]	; 0x98
  400e00:	2101      	movs	r1, #1
  400e02:	4790      	blx	r2
	}
}

void printString(char* str)
{
	drv_uart_putString((config->uart), str);
  400e04:	6823      	ldr	r3, [r4, #0]
  400e06:	4929      	ldr	r1, [pc, #164]	; (400eac <task_commandHandler+0x518>)
  400e08:	6818      	ldr	r0, [r3, #0]
  400e0a:	47b8      	blx	r7
		drv_gpio_setPinState(quinticConfig[2].resetPin, DRV_GPIO_PIN_STATE_LOW);
		vTaskDelay(50);
		drv_gpio_setPinState(quinticConfig[0].resetPin, DRV_GPIO_PIN_STATE_HIGH);
		drv_gpio_setPinState(quinticConfig[2].resetPin, DRV_GPIO_PIN_STATE_HIGH);
		printString("Pin reset\r\n");
		enableRecording = false;
  400e0c:	4b28      	ldr	r3, [pc, #160]	; (400eb0 <task_commandHandler+0x51c>)
  400e0e:	f883 b000 	strb.w	fp, [r3]
  400e12:	e5d4      	b.n	4009be <task_commandHandler+0x2a>
		rstc_start_software_reset(RSTC);
	}
	else if (strncmp(command,"debugPackets\r\n", cmdSize) == 0)
	{
		//turns on the zeroing of missing packets in the output data. 
		brainSettings.debugPackets = true; 
  400e14:	4a0f      	ldr	r2, [pc, #60]	; (400e54 <task_commandHandler+0x4c0>)
  400e16:	2301      	movs	r3, #1
  400e18:	f882 309d 	strb.w	r3, [r2, #157]	; 0x9d
  400e1c:	e5cf      	b.n	4009be <task_commandHandler+0x2a>
	{
		printStats(); 
	}	
	else if(strncmp(command,"HardReset\r\n", cmdSize) == 0)	
	{
		rstc_start_software_reset(RSTC);
  400e1e:	4825      	ldr	r0, [pc, #148]	; (400eb4 <task_commandHandler+0x520>)
  400e20:	4925      	ldr	r1, [pc, #148]	; (400eb8 <task_commandHandler+0x524>)
  400e22:	4788      	blx	r1
  400e24:	e5cb      	b.n	4009be <task_commandHandler+0x2a>
  400e26:	bf00      	nop
  400e28:	00415238 	.word	0x00415238
  400e2c:	00415254 	.word	0x00415254
  400e30:	0041526c 	.word	0x0041526c
  400e34:	0041529c 	.word	0x0041529c
  400e38:	0040c9a5 	.word	0x0040c9a5
  400e3c:	004152a4 	.word	0x004152a4
  400e40:	400e1460 	.word	0x400e1460
  400e44:	20003e14 	.word	0x20003e14
  400e48:	00415228 	.word	0x00415228
  400e4c:	2000227c 	.word	0x2000227c
  400e50:	20001268 	.word	0x20001268
  400e54:	200001ac 	.word	0x200001ac
  400e58:	004152bc 	.word	0x004152bc
  400e5c:	00415344 	.word	0x00415344
  400e60:	00415354 	.word	0x00415354
  400e64:	0041549c 	.word	0x0041549c
  400e68:	004154a8 	.word	0x004154a8
  400e6c:	004154b8 	.word	0x004154b8
  400e70:	004154e4 	.word	0x004154e4
  400e74:	00407fc1 	.word	0x00407fc1
  400e78:	004151e0 	.word	0x004151e0
  400e7c:	00415244 	.word	0x00415244
  400e80:	0040ab9d 	.word	0x0040ab9d
  400e84:	20000264 	.word	0x20000264
  400e88:	200002a0 	.word	0x200002a0
  400e8c:	200002dc 	.word	0x200002dc
  400e90:	20000188 	.word	0x20000188
  400e94:	00408ed1 	.word	0x00408ed1
  400e98:	2000016c 	.word	0x2000016c
  400e9c:	2000013c 	.word	0x2000013c
  400ea0:	00408789 	.word	0x00408789
  400ea4:	0041527c 	.word	0x0041527c
  400ea8:	004087b1 	.word	0x004087b1
  400eac:	00415260 	.word	0x00415260
  400eb0:	20001200 	.word	0x20001200
  400eb4:	400e1400 	.word	0x400e1400
  400eb8:	004003ed 	.word	0x004003ed
  400ebc:	0040c5a1 	.word	0x0040c5a1
  400ec0:	00403b41 	.word	0x00403b41
  400ec4:	00403c4d 	.word	0x00403c4d
  400ec8:	0040c4ed 	.word	0x0040c4ed
  400ecc:	0040ca69 	.word	0x0040ca69
	}
}

void printString(char* str)
{
	drv_uart_putString((config->uart), str);
  400ed0:	6823      	ldr	r3, [r4, #0]
  400ed2:	4975      	ldr	r1, [pc, #468]	; (4010a8 <task_commandHandler+0x714>)
  400ed4:	6818      	ldr	r0, [r3, #0]
  400ed6:	f8df a290 	ldr.w	sl, [pc, #656]	; 401168 <task_commandHandler+0x7d4>
  400eda:	47b8      	blx	r7
	size_t numberOfImus = 9;//sizeof(imuConfig) / sizeof(imuConfiguration_t);
	size_t numberOfQuintics = 3;//sizeof(quinticConfig) / sizeof(quinticConfiguration_t); 	
	printString("QUINTIC STATS \r\n");
	for(i = 0; i < numberOfQuintics; i++)
	{
		printf("Q%d:\r\n", i);
  400edc:	4a73      	ldr	r2, [pc, #460]	; (4010ac <task_commandHandler+0x718>)
  400ede:	4874      	ldr	r0, [pc, #464]	; (4010b0 <task_commandHandler+0x71c>)
  400ee0:	4659      	mov	r1, fp
  400ee2:	4790      	blx	r2
		printf("	Corrupt Packets: %d\r\n", quinticConfig[i].corruptPacketCnt);
  400ee4:	f8da 101c 	ldr.w	r1, [sl, #28]
  400ee8:	4b70      	ldr	r3, [pc, #448]	; (4010ac <task_commandHandler+0x718>)
  400eea:	4872      	ldr	r0, [pc, #456]	; (4010b4 <task_commandHandler+0x720>)
  400eec:	4798      	blx	r3
		printf("	Dropped Bytes:   %d\r\n", drv_uart_getDroppedBytes(quinticConfig[i].uartDevice));
  400eee:	f8df c27c 	ldr.w	ip, [pc, #636]	; 40116c <task_commandHandler+0x7d8>
  400ef2:	f8da 0014 	ldr.w	r0, [sl, #20]
  400ef6:	47e0      	blx	ip
  400ef8:	4a6c      	ldr	r2, [pc, #432]	; (4010ac <task_commandHandler+0x718>)
  400efa:	4601      	mov	r1, r0
  400efc:	486e      	ldr	r0, [pc, #440]	; (4010b8 <task_commandHandler+0x724>)
  400efe:	4790      	blx	r2
{
	int i = 0; 
	size_t numberOfImus = 9;//sizeof(imuConfig) / sizeof(imuConfiguration_t);
	size_t numberOfQuintics = 3;//sizeof(quinticConfig) / sizeof(quinticConfiguration_t); 	
	printString("QUINTIC STATS \r\n");
	for(i = 0; i < numberOfQuintics; i++)
  400f00:	f10b 0b01 	add.w	fp, fp, #1
	{
		printf("Q%d:\r\n", i);
		printf("	Corrupt Packets: %d\r\n", quinticConfig[i].corruptPacketCnt);
		printf("	Dropped Bytes:   %d\r\n", drv_uart_getDroppedBytes(quinticConfig[i].uartDevice));
		vTaskDelay(1);
  400f04:	2001      	movs	r0, #1
  400f06:	47a8      	blx	r5
{
	int i = 0; 
	size_t numberOfImus = 9;//sizeof(imuConfig) / sizeof(imuConfiguration_t);
	size_t numberOfQuintics = 3;//sizeof(quinticConfig) / sizeof(quinticConfiguration_t); 	
	printString("QUINTIC STATS \r\n");
	for(i = 0; i < numberOfQuintics; i++)
  400f08:	f1bb 0f03 	cmp.w	fp, #3
  400f0c:	f10a 0a3c 	add.w	sl, sl, #60	; 0x3c
  400f10:	d1e4      	bne.n	400edc <task_commandHandler+0x548>
	}
}

void printString(char* str)
{
	drv_uart_putString((config->uart), str);
  400f12:	6823      	ldr	r3, [r4, #0]
  400f14:	4969      	ldr	r1, [pc, #420]	; (4010bc <task_commandHandler+0x728>)
  400f16:	6818      	ldr	r0, [r3, #0]
  400f18:	f8df a254 	ldr.w	sl, [pc, #596]	; 401170 <task_commandHandler+0x7dc>
  400f1c:	47b8      	blx	r7
		vTaskDelay(1);
	}
	printString("IMU STATS \r\n");
	for(i = 0; i < numberOfImus; i++)
	{		
		printf("IMU%d:\r\n", imuConfig[i].imuId);
  400f1e:	4b63      	ldr	r3, [pc, #396]	; (4010ac <task_commandHandler+0x718>)
  400f20:	f8da 1000 	ldr.w	r1, [sl]
  400f24:	4866      	ldr	r0, [pc, #408]	; (4010c0 <task_commandHandler+0x72c>)
		printf("	IMU Present: %d\r\n", imuConfig[i].imuPresent);
		printf("	IMU Connected: %d\r\n", imuConfig[i].imuConnected);
		vTaskDelay(1);
  400f26:	f8df b24c 	ldr.w	fp, [pc, #588]	; 401174 <task_commandHandler+0x7e0>
		vTaskDelay(1);
	}
	printString("IMU STATS \r\n");
	for(i = 0; i < numberOfImus; i++)
	{		
		printf("IMU%d:\r\n", imuConfig[i].imuId);
  400f2a:	4798      	blx	r3
		printf("	IMU Present: %d\r\n", imuConfig[i].imuPresent);
  400f2c:	f8df c17c 	ldr.w	ip, [pc, #380]	; 4010ac <task_commandHandler+0x718>
  400f30:	f8da 101c 	ldr.w	r1, [sl, #28]
  400f34:	4863      	ldr	r0, [pc, #396]	; (4010c4 <task_commandHandler+0x730>)
  400f36:	47e0      	blx	ip
		printf("	IMU Connected: %d\r\n", imuConfig[i].imuConnected);
  400f38:	f8da 1020 	ldr.w	r1, [sl, #32]
  400f3c:	4a5b      	ldr	r2, [pc, #364]	; (4010ac <task_commandHandler+0x718>)
  400f3e:	4862      	ldr	r0, [pc, #392]	; (4010c8 <task_commandHandler+0x734>)
  400f40:	4790      	blx	r2
		vTaskDelay(1);
  400f42:	2001      	movs	r0, #1
  400f44:	47a8      	blx	r5
		printf("	Dropped Packets: %d\r\n", imuConfig[i].stats.droppedPackets);
  400f46:	4b59      	ldr	r3, [pc, #356]	; (4010ac <task_commandHandler+0x718>)
  400f48:	f8da 1028 	ldr.w	r1, [sl, #40]	; 0x28
  400f4c:	485f      	ldr	r0, [pc, #380]	; (4010cc <task_commandHandler+0x738>)
  400f4e:	4798      	blx	r3
		printf("	Average Rx interval(ticks): %d\r\n",imuConfig[i].stats.avgPacketTime);
  400f50:	f8da 1034 	ldr.w	r1, [sl, #52]	; 0x34
  400f54:	f8df c154 	ldr.w	ip, [pc, #340]	; 4010ac <task_commandHandler+0x718>
  400f58:	485d      	ldr	r0, [pc, #372]	; (4010d0 <task_commandHandler+0x73c>)
  400f5a:	47e0      	blx	ip
		printf("	Packet Rx Count:   %d\r\n", imuConfig[i].stats.packetCnt);
  400f5c:	f8da 1024 	ldr.w	r1, [sl, #36]	; 0x24
  400f60:	4a52      	ldr	r2, [pc, #328]	; (4010ac <task_commandHandler+0x718>)
  400f62:	485c      	ldr	r0, [pc, #368]	; (4010d4 <task_commandHandler+0x740>)
  400f64:	4790      	blx	r2
		vTaskDelay(1);
  400f66:	2001      	movs	r0, #1
  400f68:	47a8      	blx	r5
		printf("	Corrupt Packets: %d\r\n", quinticConfig[i].corruptPacketCnt);
		printf("	Dropped Bytes:   %d\r\n", drv_uart_getDroppedBytes(quinticConfig[i].uartDevice));
		vTaskDelay(1);
	}
	printString("IMU STATS \r\n");
	for(i = 0; i < numberOfImus; i++)
  400f6a:	4b5b      	ldr	r3, [pc, #364]	; (4010d8 <task_commandHandler+0x744>)
  400f6c:	f10a 0a38 	add.w	sl, sl, #56	; 0x38
  400f70:	459a      	cmp	sl, r3
  400f72:	d1d4      	bne.n	400f1e <task_commandHandler+0x58a>
		printf("	Dropped Packets: %d\r\n", imuConfig[i].stats.droppedPackets);
		printf("	Average Rx interval(ticks): %d\r\n",imuConfig[i].stats.avgPacketTime);
		printf("	Packet Rx Count:   %d\r\n", imuConfig[i].stats.packetCnt);
		vTaskDelay(1);
	}
	printf("Total Bytes Written: %d\r\n", totalBytesWritten); 
  400f74:	f8df c200 	ldr.w	ip, [pc, #512]	; 401178 <task_commandHandler+0x7e4>
  400f78:	4a4c      	ldr	r2, [pc, #304]	; (4010ac <task_commandHandler+0x718>)
  400f7a:	f8dc 1000 	ldr.w	r1, [ip]
  400f7e:	4857      	ldr	r0, [pc, #348]	; (4010dc <task_commandHandler+0x748>)
  400f80:	4790      	blx	r2
	vTaskDelay(1);
  400f82:	2001      	movs	r0, #1
  400f84:	47d8      	blx	fp
	printf("Total Frames Written: %d \r\n", totalFramesWritten); 
  400f86:	4b56      	ldr	r3, [pc, #344]	; (4010e0 <task_commandHandler+0x74c>)
  400f88:	f8df c120 	ldr.w	ip, [pc, #288]	; 4010ac <task_commandHandler+0x718>
  400f8c:	6819      	ldr	r1, [r3, #0]
  400f8e:	4855      	ldr	r0, [pc, #340]	; (4010e4 <task_commandHandler+0x750>)
  400f90:	47e0      	blx	ip
	int queuedMessages = uxQueueMessagesWaiting(queue_dataHandler);
  400f92:	4955      	ldr	r1, [pc, #340]	; (4010e8 <task_commandHandler+0x754>)
  400f94:	4a55      	ldr	r2, [pc, #340]	; (4010ec <task_commandHandler+0x758>)
  400f96:	6808      	ldr	r0, [r1, #0]
  400f98:	4790      	blx	r2
	printf("Queued Messages: %d\r\n", queuedMessages); 
  400f9a:	4b44      	ldr	r3, [pc, #272]	; (4010ac <task_commandHandler+0x718>)
		vTaskDelay(1);
	}
	printf("Total Bytes Written: %d\r\n", totalBytesWritten); 
	vTaskDelay(1);
	printf("Total Frames Written: %d \r\n", totalFramesWritten); 
	int queuedMessages = uxQueueMessagesWaiting(queue_dataHandler);
  400f9c:	4601      	mov	r1, r0
	printf("Queued Messages: %d\r\n", queuedMessages); 
  400f9e:	4854      	ldr	r0, [pc, #336]	; (4010f0 <task_commandHandler+0x75c>)
  400fa0:	4798      	blx	r3
	printf("--- task ## %u", (unsigned int)uxTaskGetNumberOfTasks());	
  400fa2:	f8df c1d8 	ldr.w	ip, [pc, #472]	; 40117c <task_commandHandler+0x7e8>
  400fa6:	47e0      	blx	ip
  400fa8:	4a40      	ldr	r2, [pc, #256]	; (4010ac <task_commandHandler+0x718>)
  400faa:	4601      	mov	r1, r0
  400fac:	4851      	ldr	r0, [pc, #324]	; (4010f4 <task_commandHandler+0x760>)
  400fae:	4790      	blx	r2
	vTaskList((signed portCHAR *)stringBuf);
  400fb0:	4851      	ldr	r0, [pc, #324]	; (4010f8 <task_commandHandler+0x764>)
  400fb2:	4b52      	ldr	r3, [pc, #328]	; (4010fc <task_commandHandler+0x768>)
  400fb4:	4798      	blx	r3
	printf(stringBuf);
  400fb6:	f8df c0f4 	ldr.w	ip, [pc, #244]	; 4010ac <task_commandHandler+0x718>
  400fba:	484f      	ldr	r0, [pc, #316]	; (4010f8 <task_commandHandler+0x764>)
  400fbc:	47e0      	blx	ip
  400fbe:	e4fe      	b.n	4009be <task_commandHandler+0x2a>
		printf("SUIT NUMBER: %s\r\n",brainSettings.suitNumber); 
		printf("SUIT TIME: %s \r\n",getTimeString());  		
	}
	else if(strncmp(command, "flushUarts\r\n",cmdSize) == 0)
	{
		drv_uart_flushRx(&usart1Config);
  400fc0:	4b4f      	ldr	r3, [pc, #316]	; (401100 <task_commandHandler+0x76c>)
  400fc2:	4850      	ldr	r0, [pc, #320]	; (401104 <task_commandHandler+0x770>)
  400fc4:	4798      	blx	r3
		drv_uart_flushRx(&uart0Config);
  400fc6:	4850      	ldr	r0, [pc, #320]	; (401108 <task_commandHandler+0x774>)
  400fc8:	f8df c134 	ldr.w	ip, [pc, #308]	; 401100 <task_commandHandler+0x76c>
  400fcc:	47e0      	blx	ip
		drv_uart_flushRx(&usart0Config);
  400fce:	484f      	ldr	r0, [pc, #316]	; (40110c <task_commandHandler+0x778>)
  400fd0:	494b      	ldr	r1, [pc, #300]	; (401100 <task_commandHandler+0x76c>)
  400fd2:	4788      	blx	r1
  400fd4:	e4f3      	b.n	4009be <task_commandHandler+0x2a>
			setTimeFromString(command+7); 
		}
	}
	else if(strncmp(command, "?\r\n",3) == 0)
	{
		printf("HEDDOKO BRAIN PACK %s\r\n", VERSION); 
  400fd6:	494e      	ldr	r1, [pc, #312]	; (401110 <task_commandHandler+0x77c>)
  400fd8:	4a34      	ldr	r2, [pc, #208]	; (4010ac <task_commandHandler+0x718>)
  400fda:	484e      	ldr	r0, [pc, #312]	; (401114 <task_commandHandler+0x780>)
  400fdc:	4790      	blx	r2
		printf("BUILD DATE: %s %s\r\n", __DATE__,__TIME__);
  400fde:	4a4e      	ldr	r2, [pc, #312]	; (401118 <task_commandHandler+0x784>)
  400fe0:	4b32      	ldr	r3, [pc, #200]	; (4010ac <task_commandHandler+0x718>)
  400fe2:	494e      	ldr	r1, [pc, #312]	; (40111c <task_commandHandler+0x788>)
  400fe4:	484e      	ldr	r0, [pc, #312]	; (401120 <task_commandHandler+0x78c>)
  400fe6:	4798      	blx	r3
		printf("SUIT NUMBER: %s\r\n",brainSettings.suitNumber); 
  400fe8:	494e      	ldr	r1, [pc, #312]	; (401124 <task_commandHandler+0x790>)
  400fea:	f8df c0c0 	ldr.w	ip, [pc, #192]	; 4010ac <task_commandHandler+0x718>
  400fee:	484e      	ldr	r0, [pc, #312]	; (401128 <task_commandHandler+0x794>)
  400ff0:	47e0      	blx	ip
}
char timeString[100] = {0}; 
static char* getTimeString()
{
	uint32_t hour, minute, second; 
	rtc_get_time(RTC,&hour,&minute,&second); 
  400ff2:	a90a      	add	r1, sp, #40	; 0x28
  400ff4:	aa0b      	add	r2, sp, #44	; 0x2c
  400ff6:	ab0c      	add	r3, sp, #48	; 0x30
  400ff8:	484c      	ldr	r0, [pc, #304]	; (40112c <task_commandHandler+0x798>)
  400ffa:	f8df c184 	ldr.w	ip, [pc, #388]	; 401180 <task_commandHandler+0x7ec>
  400ffe:	47e0      	blx	ip
	sprintf(timeString,"%02d:%02d:%02d",hour,minute,second); 
  401000:	990c      	ldr	r1, [sp, #48]	; 0x30
  401002:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  401004:	9100      	str	r1, [sp, #0]
  401006:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  401008:	4949      	ldr	r1, [pc, #292]	; (401130 <task_commandHandler+0x79c>)
  40100a:	f8df c178 	ldr.w	ip, [pc, #376]	; 401184 <task_commandHandler+0x7f0>
  40100e:	4849      	ldr	r0, [pc, #292]	; (401134 <task_commandHandler+0x7a0>)
  401010:	47e0      	blx	ip
	else if(strncmp(command, "?\r\n",3) == 0)
	{
		printf("HEDDOKO BRAIN PACK %s\r\n", VERSION); 
		printf("BUILD DATE: %s %s\r\n", __DATE__,__TIME__);
		printf("SUIT NUMBER: %s\r\n",brainSettings.suitNumber); 
		printf("SUIT TIME: %s \r\n",getTimeString());  		
  401012:	4948      	ldr	r1, [pc, #288]	; (401134 <task_commandHandler+0x7a0>)
  401014:	4a25      	ldr	r2, [pc, #148]	; (4010ac <task_commandHandler+0x718>)
  401016:	4848      	ldr	r0, [pc, #288]	; (401138 <task_commandHandler+0x7a4>)
  401018:	4790      	blx	r2
  40101a:	e4d0      	b.n	4009be <task_commandHandler+0x2a>
		brainSettings.debugPackets = true; 
	}
	else if (strncmp(command,"chMap ", 6) == 0)
	{
		// Save the received channel map to settings.
		strncpy(brainSettings.channelmap, command+6, 10);
  40101c:	f10d 013a 	add.w	r1, sp, #58	; 0x3a
  401020:	220a      	movs	r2, #10
  401022:	4b46      	ldr	r3, [pc, #280]	; (40113c <task_commandHandler+0x7a8>)
  401024:	4846      	ldr	r0, [pc, #280]	; (401140 <task_commandHandler+0x7ac>)
  401026:	4798      	blx	r3
		strncpy((brainSettings.channelmap)+10, "\r\n", 2);	//Add CR+LF at the end of the srting
  401028:	f8df c15c 	ldr.w	ip, [pc, #348]	; 401188 <task_commandHandler+0x7f4>
	}
}

void printString(char* str)
{
	drv_uart_putString((config->uart), str);
  40102c:	6823      	ldr	r3, [r4, #0]
  40102e:	4945      	ldr	r1, [pc, #276]	; (401144 <task_commandHandler+0x7b0>)
	}
	else if (strncmp(command,"chMap ", 6) == 0)
	{
		// Save the received channel map to settings.
		strncpy(brainSettings.channelmap, command+6, 10);
		strncpy((brainSettings.channelmap)+10, "\r\n", 2);	//Add CR+LF at the end of the srting
  401030:	f640 220d 	movw	r2, #2573	; 0xa0d
  401034:	f8ac 2000 	strh.w	r2, [ip]
	}
}

void printString(char* str)
{
	drv_uart_putString((config->uart), str);
  401038:	6818      	ldr	r0, [r3, #0]
  40103a:	47b8      	blx	r7
  40103c:	6823      	ldr	r3, [r4, #0]
  40103e:	4940      	ldr	r1, [pc, #256]	; (401140 <task_commandHandler+0x7ac>)
  401040:	6818      	ldr	r0, [r3, #0]
  401042:	47b8      	blx	r7
  401044:	e4bb      	b.n	4009be <task_commandHandler+0x2a>
	}
	else if (strncmp(command, "setLedConfig", 12) == 0)
	{
		if (*(command + 12) == '0')
		{
			nvmSettings.ledConfiguration.redLed = DRV_GPIO_PIN_RED_LED;
  401046:	4940      	ldr	r1, [pc, #256]	; (401148 <task_commandHandler+0x7b4>)
  401048:	230e      	movs	r3, #14
			nvmSettings.ledConfiguration.greenLed = DRV_GPIO_PIN_GREEN_LED;
  40104a:	220c      	movs	r2, #12
	}
	else if (strncmp(command, "setLedConfig", 12) == 0)
	{
		if (*(command + 12) == '0')
		{
			nvmSettings.ledConfiguration.redLed = DRV_GPIO_PIN_RED_LED;
  40104c:	750b      	strb	r3, [r1, #20]
			nvmSettings.ledConfiguration.greenLed = DRV_GPIO_PIN_GREEN_LED;
			nvmSettings.ledConfiguration.blueLed = DRV_GPIO_PIN_BLUE_LED;
  40104e:	230d      	movs	r3, #13
	else if (strncmp(command, "setLedConfig", 12) == 0)
	{
		if (*(command + 12) == '0')
		{
			nvmSettings.ledConfiguration.redLed = DRV_GPIO_PIN_RED_LED;
			nvmSettings.ledConfiguration.greenLed = DRV_GPIO_PIN_GREEN_LED;
  401050:	758a      	strb	r2, [r1, #22]
			nvmSettings.ledConfiguration.blueLed = DRV_GPIO_PIN_BLUE_LED;
  401052:	754b      	strb	r3, [r1, #21]
  401054:	e68c      	b.n	400d70 <task_commandHandler+0x3dc>
			printString("ACK\r\n");
			return;
		}
		printString("NACK\r\n");
	}
	else if (strncmp(command, "getSdCdValue", 12) == 0)
  401056:	a80d      	add	r0, sp, #52	; 0x34
  401058:	493c      	ldr	r1, [pc, #240]	; (40114c <task_commandHandler+0x7b8>)
  40105a:	220c      	movs	r2, #12
  40105c:	47d0      	blx	sl
  40105e:	b170      	cbz	r0, 40107e <task_commandHandler+0x6ea>
		else if (sdCdPinState == DRV_GPIO_PIN_STATE_LOW)
		{
			printString("Low\r\n");
		}
	}
	else if (strncmp(command, "LowBattery", 10) == 0)
  401060:	a80d      	add	r0, sp, #52	; 0x34
  401062:	493b      	ldr	r1, [pc, #236]	; (401150 <task_commandHandler+0x7bc>)
  401064:	220a      	movs	r2, #10
  401066:	47d0      	blx	sl
  401068:	4682      	mov	sl, r0
  40106a:	2800      	cmp	r0, #0
  40106c:	f47f aca7 	bne.w	4009be <task_commandHandler+0x2a>
	{
		//this message is sent from the power board to indicate that the battery is low
		debugPrintString("Low Battery\r\n");		
  401070:	4838      	ldr	r0, [pc, #224]	; (401154 <task_commandHandler+0x7c0>)
  401072:	4b39      	ldr	r3, [pc, #228]	; (401158 <task_commandHandler+0x7c4>)
  401074:	4798      	blx	r3
		task_stateMachine_EnqueueEvent(SYS_EVENT_LOW_BATTERY,0);		
  401076:	4651      	mov	r1, sl
  401078:	2009      	movs	r0, #9
  40107a:	47c8      	blx	r9
  40107c:	e49f      	b.n	4009be <task_commandHandler+0x2a>
		printString("NACK\r\n");
	}
	else if (strncmp(command, "getSdCdValue", 12) == 0)
	{
		drv_gpio_pin_state_t sdCdPinState;
		drv_gpio_getPinState(DRV_GPIO_PIN_SD_CD, &sdCdPinState);
  40107e:	2010      	movs	r0, #16
  401080:	a90c      	add	r1, sp, #48	; 0x30
  401082:	4a36      	ldr	r2, [pc, #216]	; (40115c <task_commandHandler+0x7c8>)
  401084:	4790      	blx	r2
		if (sdCdPinState == DRV_GPIO_PIN_STATE_HIGH)
  401086:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
  40108a:	2b01      	cmp	r3, #1
  40108c:	d007      	beq.n	40109e <task_commandHandler+0x70a>
		{
			printString("High\r\n");
		}
		else if (sdCdPinState == DRV_GPIO_PIN_STATE_LOW)
  40108e:	2b00      	cmp	r3, #0
  401090:	f47f ac95 	bne.w	4009be <task_commandHandler+0x2a>
	}
}

void printString(char* str)
{
	drv_uart_putString((config->uart), str);
  401094:	6823      	ldr	r3, [r4, #0]
  401096:	4932      	ldr	r1, [pc, #200]	; (401160 <task_commandHandler+0x7cc>)
  401098:	6818      	ldr	r0, [r3, #0]
  40109a:	47b8      	blx	r7
  40109c:	e48f      	b.n	4009be <task_commandHandler+0x2a>
  40109e:	6823      	ldr	r3, [r4, #0]
  4010a0:	4930      	ldr	r1, [pc, #192]	; (401164 <task_commandHandler+0x7d0>)
  4010a2:	6818      	ldr	r0, [r3, #0]
  4010a4:	47b8      	blx	r7
  4010a6:	e48a      	b.n	4009be <task_commandHandler+0x2a>
  4010a8:	00415360 	.word	0x00415360
  4010ac:	0040bba9 	.word	0x0040bba9
  4010b0:	00415374 	.word	0x00415374
  4010b4:	0041537c 	.word	0x0041537c
  4010b8:	00415394 	.word	0x00415394
  4010bc:	00415530 	.word	0x00415530
  4010c0:	004153ac 	.word	0x004153ac
  4010c4:	004153b8 	.word	0x004153b8
  4010c8:	004153cc 	.word	0x004153cc
  4010cc:	004153e4 	.word	0x004153e4
  4010d0:	004153fc 	.word	0x004153fc
  4010d4:	00415420 	.word	0x00415420
  4010d8:	20000514 	.word	0x20000514
  4010dc:	0041543c 	.word	0x0041543c
  4010e0:	20003880 	.word	0x20003880
  4010e4:	00415458 	.word	0x00415458
  4010e8:	20003874 	.word	0x20003874
  4010ec:	00406c89 	.word	0x00406c89
  4010f0:	00415474 	.word	0x00415474
  4010f4:	0041548c 	.word	0x0041548c
  4010f8:	20001268 	.word	0x20001268
  4010fc:	004073e5 	.word	0x004073e5
  401100:	004090b1 	.word	0x004090b1
  401104:	2000013c 	.word	0x2000013c
  401108:	20000154 	.word	0x20000154
  40110c:	2000016c 	.word	0x2000016c
  401110:	004152d8 	.word	0x004152d8
  401114:	004152c0 	.word	0x004152c0
  401118:	00415300 	.word	0x00415300
  40111c:	004152f4 	.word	0x004152f4
  401120:	004152e0 	.word	0x004152e0
  401124:	200001b4 	.word	0x200001b4
  401128:	0041530c 	.word	0x0041530c
  40112c:	400e1460 	.word	0x400e1460
  401130:	00415320 	.word	0x00415320
  401134:	20001204 	.word	0x20001204
  401138:	00415330 	.word	0x00415330
  40113c:	0040cb1d 	.word	0x0040cb1d
  401140:	2000024c 	.word	0x2000024c
  401144:	004154c0 	.word	0x004154c0
  401148:	20003e14 	.word	0x20003e14
  40114c:	004154f4 	.word	0x004154f4
  401150:	00415514 	.word	0x00415514
  401154:	00415520 	.word	0x00415520
  401158:	004008c9 	.word	0x004008c9
  40115c:	00408829 	.word	0x00408829
  401160:	0041550c 	.word	0x0041550c
  401164:	00415504 	.word	0x00415504
  401168:	20000264 	.word	0x20000264
  40116c:	00408f1d 	.word	0x00408f1d
  401170:	2000031c 	.word	0x2000031c
  401174:	004072ed 	.word	0x004072ed
  401178:	2000206c 	.word	0x2000206c
  40117c:	004070c1 	.word	0x004070c1
  401180:	00403ae5 	.word	0x00403ae5
  401184:	0040c555 	.word	0x0040c555
  401188:	20000256 	.word	0x20000256

0040118c <sendPacket>:
}

void sendPacket(char* buf, size_t length)
{
  40118c:	b510      	push	{r4, lr}
	drv_uart_putData((config->uart), buf, length);
  40118e:	4a04      	ldr	r2, [pc, #16]	; (4011a0 <sendPacket+0x14>)
  401190:	4b04      	ldr	r3, [pc, #16]	; (4011a4 <sendPacket+0x18>)
  401192:	6814      	ldr	r4, [r2, #0]
{
	drv_uart_putString((config->uart), str);
}

void sendPacket(char* buf, size_t length)
{
  401194:	460a      	mov	r2, r1
	drv_uart_putData((config->uart), buf, length);
  401196:	4601      	mov	r1, r0
  401198:	6820      	ldr	r0, [r4, #0]
  40119a:	4798      	blx	r3
  40119c:	bd10      	pop	{r4, pc}
  40119e:	bf00      	nop
  4011a0:	200011fc 	.word	0x200011fc
  4011a4:	00409081 	.word	0x00409081

004011a8 <task_sdCardWriteEntry>:
		
		
	}
}
status_t task_sdCardWriteEntry(char* entry, size_t length)
{
  4011a8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	status_t status = STATUS_PASS; 
	
	//take the semaphore	
	if(xSemaphoreTake(semaphore_sdCardWrite,5) == true)
  4011ac:	f8df 80b8 	ldr.w	r8, [pc, #184]	; 401268 <task_sdCardWriteEntry+0xc0>
  4011b0:	4c24      	ldr	r4, [pc, #144]	; (401244 <task_sdCardWriteEntry+0x9c>)
		
		
	}
}
status_t task_sdCardWriteEntry(char* entry, size_t length)
{
  4011b2:	460d      	mov	r5, r1
	status_t status = STATUS_PASS; 
	
	//take the semaphore	
	if(xSemaphoreTake(semaphore_sdCardWrite,5) == true)
  4011b4:	2100      	movs	r1, #0
		
		
	}
}
status_t task_sdCardWriteEntry(char* entry, size_t length)
{
  4011b6:	4607      	mov	r7, r0
	status_t status = STATUS_PASS; 
	
	//take the semaphore	
	if(xSemaphoreTake(semaphore_sdCardWrite,5) == true)
  4011b8:	460b      	mov	r3, r1
  4011ba:	f8d8 0000 	ldr.w	r0, [r8]
  4011be:	2205      	movs	r2, #5
  4011c0:	47a0      	blx	r4
  4011c2:	2801      	cmp	r0, #1
  4011c4:	4604      	mov	r4, r0
  4011c6:	d005      	beq.n	4011d4 <task_sdCardWriteEntry+0x2c>
		}
	}
	else
	{		
		status = STATUS_FAIL; 
		debugPrintString("Write failed: semaphore locked\r\n");
  4011c8:	481f      	ldr	r0, [pc, #124]	; (401248 <task_sdCardWriteEntry+0xa0>)
  4011ca:	4b20      	ldr	r3, [pc, #128]	; (40124c <task_sdCardWriteEntry+0xa4>)
  4011cc:	4798      	blx	r3
			debugPrintString("Write failed: Buffer full\r\n");
		}
	}
	else
	{		
		status = STATUS_FAIL; 
  4011ce:	2001      	movs	r0, #1
  4011d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	
	//take the semaphore	
	if(xSemaphoreTake(semaphore_sdCardWrite,5) == true)
	{
		//copy data to sdCard buffer, make sure we have room first
		if(sdCardBufferPointer + length < SD_CARD_BUFFER_SIZE)
  4011d4:	4e1e      	ldr	r6, [pc, #120]	; (401250 <task_sdCardWriteEntry+0xa8>)
  4011d6:	6833      	ldr	r3, [r6, #0]
  4011d8:	442b      	add	r3, r5
  4011da:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
  4011de:	d21c      	bcs.n	40121a <task_sdCardWriteEntry+0x72>
		{
			if(nvmSettings.enableCsvFormat == 0)
  4011e0:	4b1c      	ldr	r3, [pc, #112]	; (401254 <task_sdCardWriteEntry+0xac>)
  4011e2:	691c      	ldr	r4, [r3, #16]
  4011e4:	bb34      	cbnz	r4, 401234 <task_sdCardWriteEntry+0x8c>
			{
				int i = 0;
				for(i=0; i<length; i++)
  4011e6:	b15d      	cbz	r5, 401200 <task_sdCardWriteEntry+0x58>
  4011e8:	481b      	ldr	r0, [pc, #108]	; (401258 <task_sdCardWriteEntry+0xb0>)
  4011ea:	4623      	mov	r3, r4
				{
					(sdCardBuffer+sdCardBufferPointer)[i] = entry[i] + 0x80; //add 128 to make it not ascii
  4011ec:	6831      	ldr	r1, [r6, #0]
  4011ee:	5d3a      	ldrb	r2, [r7, r4]
		if(sdCardBufferPointer + length < SD_CARD_BUFFER_SIZE)
		{
			if(nvmSettings.enableCsvFormat == 0)
			{
				int i = 0;
				for(i=0; i<length; i++)
  4011f0:	3301      	adds	r3, #1
				{
					(sdCardBuffer+sdCardBufferPointer)[i] = entry[i] + 0x80; //add 128 to make it not ascii
  4011f2:	440c      	add	r4, r1
  4011f4:	f082 0280 	eor.w	r2, r2, #128	; 0x80
		if(sdCardBufferPointer + length < SD_CARD_BUFFER_SIZE)
		{
			if(nvmSettings.enableCsvFormat == 0)
			{
				int i = 0;
				for(i=0; i<length; i++)
  4011f8:	42ab      	cmp	r3, r5
				{
					(sdCardBuffer+sdCardBufferPointer)[i] = entry[i] + 0x80; //add 128 to make it not ascii
  4011fa:	5502      	strb	r2, [r0, r4]
		if(sdCardBufferPointer + length < SD_CARD_BUFFER_SIZE)
		{
			if(nvmSettings.enableCsvFormat == 0)
			{
				int i = 0;
				for(i=0; i<length; i++)
  4011fc:	461c      	mov	r4, r3
  4011fe:	d1f5      	bne.n	4011ec <task_sdCardWriteEntry+0x44>
			}
			else
			{
				memcpy(sdCardBuffer+sdCardBufferPointer,entry,length);
			}
			sdCardBufferPointer += length;
  401200:	6833      	ldr	r3, [r6, #0]
		else
		{
			status = STATUS_FAIL;
			
		}
		xSemaphoreGive(semaphore_sdCardWrite);
  401202:	f8d8 0000 	ldr.w	r0, [r8]
  401206:	4c15      	ldr	r4, [pc, #84]	; (40125c <task_sdCardWriteEntry+0xb4>)
  401208:	2100      	movs	r1, #0
			}
			else
			{
				memcpy(sdCardBuffer+sdCardBufferPointer,entry,length);
			}
			sdCardBufferPointer += length;
  40120a:	441d      	add	r5, r3
		else
		{
			status = STATUS_FAIL;
			
		}
		xSemaphoreGive(semaphore_sdCardWrite);
  40120c:	460a      	mov	r2, r1
  40120e:	460b      	mov	r3, r1
			}
			else
			{
				memcpy(sdCardBuffer+sdCardBufferPointer,entry,length);
			}
			sdCardBufferPointer += length;
  401210:	6035      	str	r5, [r6, #0]
		else
		{
			status = STATUS_FAIL;
			
		}
		xSemaphoreGive(semaphore_sdCardWrite);
  401212:	47a0      	blx	r4
  401214:	2000      	movs	r0, #0
  401216:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40121a:	2100      	movs	r1, #0
  40121c:	460b      	mov	r3, r1
  40121e:	460a      	mov	r2, r1
  401220:	f8d8 0000 	ldr.w	r0, [r8]
  401224:	4d0d      	ldr	r5, [pc, #52]	; (40125c <task_sdCardWriteEntry+0xb4>)
  401226:	47a8      	blx	r5
		if(status == STATUS_FAIL)
		{
			debugPrintString("Write failed: Buffer full\r\n");
  401228:	480d      	ldr	r0, [pc, #52]	; (401260 <task_sdCardWriteEntry+0xb8>)
  40122a:	4b08      	ldr	r3, [pc, #32]	; (40124c <task_sdCardWriteEntry+0xa4>)
  40122c:	4798      	blx	r3
  40122e:	4620      	mov	r0, r4
		status = STATUS_FAIL; 
		debugPrintString("Write failed: semaphore locked\r\n");
	}	

	return status; 
}
  401230:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
					(sdCardBuffer+sdCardBufferPointer)[i] = entry[i] + 0x80; //add 128 to make it not ascii
				}
			}
			else
			{
				memcpy(sdCardBuffer+sdCardBufferPointer,entry,length);
  401234:	6832      	ldr	r2, [r6, #0]
  401236:	4808      	ldr	r0, [pc, #32]	; (401258 <task_sdCardWriteEntry+0xb0>)
  401238:	4b0a      	ldr	r3, [pc, #40]	; (401264 <task_sdCardWriteEntry+0xbc>)
  40123a:	4639      	mov	r1, r7
  40123c:	4410      	add	r0, r2
  40123e:	462a      	mov	r2, r5
  401240:	4798      	blx	r3
  401242:	e7dd      	b.n	401200 <task_sdCardWriteEntry+0x58>
  401244:	00406b35 	.word	0x00406b35
  401248:	00415670 	.word	0x00415670
  40124c:	004008c9 	.word	0x004008c9
  401250:	20002074 	.word	0x20002074
  401254:	20003e14 	.word	0x20003e14
  401258:	2000231c 	.word	0x2000231c
  40125c:	00406979 	.word	0x00406979
  401260:	00415694 	.word	0x00415694
  401264:	0040c129 	.word	0x0040c129
  401268:	20001460 	.word	0x20001460

0040126c <task_debugLogWriteEntry>:

	return status; 
}

status_t task_debugLogWriteEntry(char* entry, size_t length)
{
  40126c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	status_t status = STATUS_PASS;
	//take the semaphore
	if(semaphore_sdCardWrite == NULL)
  40126e:	4c15      	ldr	r4, [pc, #84]	; (4012c4 <task_debugLogWriteEntry+0x58>)
  401270:	6823      	ldr	r3, [r4, #0]

	return status; 
}

status_t task_debugLogWriteEntry(char* entry, size_t length)
{
  401272:	4607      	mov	r7, r0
  401274:	460e      	mov	r6, r1
	status_t status = STATUS_PASS;
	//take the semaphore
	if(semaphore_sdCardWrite == NULL)
  401276:	b13b      	cbz	r3, 401288 <task_debugLogWriteEntry+0x1c>
	{
		return STATUS_FAIL; 
	}	
	if(xSemaphoreTake(semaphore_sdCardWrite,5) == true)
  401278:	2100      	movs	r1, #0
  40127a:	4618      	mov	r0, r3
  40127c:	2205      	movs	r2, #5
  40127e:	460b      	mov	r3, r1
  401280:	4d11      	ldr	r5, [pc, #68]	; (4012c8 <task_debugLogWriteEntry+0x5c>)
  401282:	47a8      	blx	r5
  401284:	2801      	cmp	r0, #1
  401286:	d001      	beq.n	40128c <task_debugLogWriteEntry+0x20>
{
	status_t status = STATUS_PASS;
	//take the semaphore
	if(semaphore_sdCardWrite == NULL)
	{
		return STATUS_FAIL; 
  401288:	2001      	movs	r0, #1
  40128a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	}	
	if(xSemaphoreTake(semaphore_sdCardWrite,5) == true)
	{
		//copy data to sdCard buffer, make sure we have room first
		if(debugLogBufferPointer + length < DEBUG_LOG_BUFFER_SIZE)
  40128c:	4d0f      	ldr	r5, [pc, #60]	; (4012cc <task_debugLogWriteEntry+0x60>)
  40128e:	682a      	ldr	r2, [r5, #0]
  401290:	4432      	add	r2, r6
  401292:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
  401296:	d308      	bcc.n	4012aa <task_debugLogWriteEntry+0x3e>
			memcpy(debugLogBuffer+debugLogBufferPointer,entry,length);
			debugLogBufferPointer += length;
		}
		else
		{
			status = STATUS_FAIL;
  401298:	4605      	mov	r5, r0
		}
		xSemaphoreGive(semaphore_sdCardWrite);
  40129a:	2100      	movs	r1, #0
  40129c:	6820      	ldr	r0, [r4, #0]
  40129e:	4c0c      	ldr	r4, [pc, #48]	; (4012d0 <task_debugLogWriteEntry+0x64>)
  4012a0:	460a      	mov	r2, r1
  4012a2:	460b      	mov	r3, r1
  4012a4:	47a0      	blx	r4
  4012a6:	4628      	mov	r0, r5
	{
		status = STATUS_FAIL;
	}	
	return status;
	
}
  4012a8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if(xSemaphoreTake(semaphore_sdCardWrite,5) == true)
	{
		//copy data to sdCard buffer, make sure we have room first
		if(debugLogBufferPointer + length < DEBUG_LOG_BUFFER_SIZE)
		{
			memcpy(debugLogBuffer+debugLogBufferPointer,entry,length);
  4012aa:	682a      	ldr	r2, [r5, #0]
  4012ac:	4809      	ldr	r0, [pc, #36]	; (4012d4 <task_debugLogWriteEntry+0x68>)
  4012ae:	4b0a      	ldr	r3, [pc, #40]	; (4012d8 <task_debugLogWriteEntry+0x6c>)
  4012b0:	4410      	add	r0, r2
  4012b2:	4639      	mov	r1, r7
  4012b4:	4632      	mov	r2, r6
  4012b6:	4798      	blx	r3
			debugLogBufferPointer += length;
  4012b8:	682b      	ldr	r3, [r5, #0]
  4012ba:	441e      	add	r6, r3
  4012bc:	602e      	str	r6, [r5, #0]
	return status; 
}

status_t task_debugLogWriteEntry(char* entry, size_t length)
{
	status_t status = STATUS_PASS;
  4012be:	2500      	movs	r5, #0
  4012c0:	e7eb      	b.n	40129a <task_debugLogWriteEntry+0x2e>
  4012c2:	bf00      	nop
  4012c4:	20001460 	.word	0x20001460
  4012c8:	00406b35 	.word	0x00406b35
  4012cc:	2000311c 	.word	0x2000311c
  4012d0:	00406979 	.word	0x00406979
  4012d4:	2000207c 	.word	0x2000207c
  4012d8:	0040c129 	.word	0x0040c129

004012dc <task_sdCard_OpenNewFile>:
	return status;
	
}

status_t task_sdCard_OpenNewFile()
{
  4012dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint8_t data_buffer[100], vFileIndexAlgoCount = 0;
	char fileIndexLog[SD_CARD_FILENAME_LENGTH] = "0:logIndex.dat";
  4012e0:	4d81      	ldr	r5, [pc, #516]	; (4014e8 <task_sdCard_OpenNewFile+0x20c>)
  4012e2:	4e82      	ldr	r6, [pc, #520]	; (4014ec <task_sdCard_OpenNewFile+0x210>)
	FILINFO vDataLogFileInfo;
	bool exitFileSearchLoop = FALSE;
	status_t status = STATUS_PASS; 
	int avg_time = 0;
	//if the log file is open, then return an error
	if(dataLogFileOpen == true)
  4012e4:	4f82      	ldr	r7, [pc, #520]	; (4014f0 <task_sdCard_OpenNewFile+0x214>)
}

status_t task_sdCard_OpenNewFile()
{
	uint8_t data_buffer[100], vFileIndexAlgoCount = 0;
	char fileIndexLog[SD_CARD_FILENAME_LENGTH] = "0:logIndex.dat";
  4012e6:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
	return status;
	
}

status_t task_sdCard_OpenNewFile()
{
  4012ea:	f2ad 5d34 	subw	sp, sp, #1332	; 0x534
	uint8_t data_buffer[100], vFileIndexAlgoCount = 0;
	char fileIndexLog[SD_CARD_FILENAME_LENGTH] = "0:logIndex.dat";
  4012ee:	ac29      	add	r4, sp, #164	; 0xa4
  4012f0:	c407      	stmia	r4!, {r0, r1, r2}
  4012f2:	f824 3b02 	strh.w	r3, [r4], #2
  4012f6:	2100      	movs	r1, #0
  4012f8:	0c1b      	lsrs	r3, r3, #16
  4012fa:	2287      	movs	r2, #135	; 0x87
  4012fc:	f10d 00b3 	add.w	r0, sp, #179	; 0xb3
	char dirName[SD_CARD_FILENAME_LENGTH] = "0:MovementLog"; 
  401300:	3598      	adds	r5, #152	; 0x98
}

status_t task_sdCard_OpenNewFile()
{
	uint8_t data_buffer[100], vFileIndexAlgoCount = 0;
	char fileIndexLog[SD_CARD_FILENAME_LENGTH] = "0:logIndex.dat";
  401302:	7023      	strb	r3, [r4, #0]
  401304:	47b0      	blx	r6
	char dirName[SD_CARD_FILENAME_LENGTH] = "0:MovementLog"; 
  401306:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
  40130a:	ac4f      	add	r4, sp, #316	; 0x13c
  40130c:	c407      	stmia	r4!, {r0, r1, r2}
  40130e:	2100      	movs	r1, #0
  401310:	2288      	movs	r2, #136	; 0x88
  401312:	f50d 70a5 	add.w	r0, sp, #330	; 0x14a
  401316:	8023      	strh	r3, [r4, #0]
  401318:	47b0      	blx	r6
	char dirPath[] = "0:MovementLog/";
	DIR dir;
	char logFileName[SD_CARD_FILENAME_LENGTH] = {0};
  40131a:	2100      	movs	r1, #0
  40131c:	2296      	movs	r2, #150	; 0x96
  40131e:	a875      	add	r0, sp, #468	; 0x1d4
  401320:	47b0      	blx	r6
	char temp[153] = {0}; 
  401322:	2100      	movs	r1, #0
  401324:	a89b      	add	r0, sp, #620	; 0x26c
  401326:	2299      	movs	r2, #153	; 0x99
  401328:	47b0      	blx	r6
	FILINFO vDataLogFileInfo;
	bool exitFileSearchLoop = FALSE;
	status_t status = STATUS_PASS; 
	int avg_time = 0;
	//if the log file is open, then return an error
	if(dataLogFileOpen == true)
  40132a:	7838      	ldrb	r0, [r7, #0]
  40132c:	b2c0      	uxtb	r0, r0
	DIR dir;
	char logFileName[SD_CARD_FILENAME_LENGTH] = {0};
	char temp[153] = {0}; 
	uint32_t byte_to_read, byte_read, bytes_written;
	FRESULT res;
	uint32_t fileIndexNumber = 0, maxFileIndex = 0, fileIndexJumpCount = 0, sgSysTickCountOld = 0; 
  40132e:	2100      	movs	r1, #0
	FILINFO vDataLogFileInfo;
	bool exitFileSearchLoop = FALSE;
	status_t status = STATUS_PASS; 
	int avg_time = 0;
	//if the log file is open, then return an error
	if(dataLogFileOpen == true)
  401330:	2801      	cmp	r0, #1
	DIR dir;
	char logFileName[SD_CARD_FILENAME_LENGTH] = {0};
	char temp[153] = {0}; 
	uint32_t byte_to_read, byte_read, bytes_written;
	FRESULT res;
	uint32_t fileIndexNumber = 0, maxFileIndex = 0, fileIndexJumpCount = 0, sgSysTickCountOld = 0; 
  401332:	9106      	str	r1, [sp, #24]
	FILINFO vDataLogFileInfo;
	bool exitFileSearchLoop = FALSE;
	status_t status = STATUS_PASS; 
	int avg_time = 0;
	//if the log file is open, then return an error
	if(dataLogFileOpen == true)
  401334:	d00b      	beq.n	40134e <task_sdCard_OpenNewFile+0x72>
	{
		status = STATUS_FAIL; 
		return status; 
	}	
	if (xSemaphoreTake(semaphore_fatFsAccess, 100) == true)
  401336:	4c6f      	ldr	r4, [pc, #444]	; (4014f4 <task_sdCard_OpenNewFile+0x218>)
  401338:	4d6f      	ldr	r5, [pc, #444]	; (4014f8 <task_sdCard_OpenNewFile+0x21c>)
  40133a:	6820      	ldr	r0, [r4, #0]
  40133c:	460b      	mov	r3, r1
  40133e:	2264      	movs	r2, #100	; 0x64
  401340:	47a8      	blx	r5
  401342:	2801      	cmp	r0, #1
  401344:	d007      	beq.n	401356 <task_sdCard_OpenNewFile+0x7a>
		}
		xSemaphoreGive(semaphore_fatFsAccess);
	}
	else
	{
		debugPrintString("Can't get semaphore to open log file\r\n");
  401346:	486d      	ldr	r0, [pc, #436]	; (4014fc <task_sdCard_OpenNewFile+0x220>)
  401348:	4b6d      	ldr	r3, [pc, #436]	; (401500 <task_sdCard_OpenNewFile+0x224>)
  40134a:	4798      	blx	r3
		status = STATUS_FAIL;
  40134c:	2001      	movs	r0, #1
	}
	return status; 
}
  40134e:	f20d 5d34 	addw	sp, sp, #1332	; 0x534
  401352:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		}
		avg_time = sgSysTickCount - sgSysTickCountOld;
		//latest index calculation complete
		
		#else
		snprintf(dirName, SD_CARD_FILENAME_LENGTH, "0:%s", brainSettings.fileName);
  401356:	2196      	movs	r1, #150	; 0x96
  401358:	4a6a      	ldr	r2, [pc, #424]	; (401504 <task_sdCard_OpenNewFile+0x228>)
  40135a:	4b6b      	ldr	r3, [pc, #428]	; (401508 <task_sdCard_OpenNewFile+0x22c>)
  40135c:	4d6b      	ldr	r5, [pc, #428]	; (40150c <task_sdCard_OpenNewFile+0x230>)
  40135e:	a84f      	add	r0, sp, #316	; 0x13c
  401360:	47a8      	blx	r5
		res = f_opendir(&dir, &dirName);	//open the specified directory
  401362:	a807      	add	r0, sp, #28
  401364:	a94f      	add	r1, sp, #316	; 0x13c
  401366:	4b6a      	ldr	r3, [pc, #424]	; (401510 <task_sdCard_OpenNewFile+0x234>)
  401368:	4798      	blx	r3
		if (res == FR_NO_PATH)
  40136a:	2805      	cmp	r0, #5
  40136c:	f000 809c 	beq.w	4014a8 <task_sdCard_OpenNewFile+0x1cc>
			{
				status = STATUS_FAIL;
				debugPrintString("Failed on creating new movement log directory\r\n");
			}
		}
		snprintf(logFileName, SD_CARD_FILENAME_LENGTH, "%s/%s", dirName, &fileIndexLog[2]);
  401370:	f10d 03a6 	add.w	r3, sp, #166	; 0xa6
  401374:	9300      	str	r3, [sp, #0]
  401376:	2196      	movs	r1, #150	; 0x96
  401378:	4a66      	ldr	r2, [pc, #408]	; (401514 <task_sdCard_OpenNewFile+0x238>)
		strncpy(fileIndexLog, logFileName, sizeof(logFileName));
  40137a:	f8df 81e8 	ldr.w	r8, [pc, #488]	; 401564 <task_sdCard_OpenNewFile+0x288>
		res = f_open(&indexFile_obj, (char const *)fileIndexLog, FA_OPEN_ALWAYS | FA_WRITE | FA_READ);
  40137e:	4e66      	ldr	r6, [pc, #408]	; (401518 <task_sdCard_OpenNewFile+0x23c>)
			{
				status = STATUS_FAIL;
				debugPrintString("Failed on creating new movement log directory\r\n");
			}
		}
		snprintf(logFileName, SD_CARD_FILENAME_LENGTH, "%s/%s", dirName, &fileIndexLog[2]);
  401380:	ab4f      	add	r3, sp, #316	; 0x13c
  401382:	a875      	add	r0, sp, #468	; 0x1d4
  401384:	47a8      	blx	r5
		strncpy(fileIndexLog, logFileName, sizeof(logFileName));
  401386:	a975      	add	r1, sp, #468	; 0x1d4
  401388:	2296      	movs	r2, #150	; 0x96
  40138a:	a829      	add	r0, sp, #164	; 0xa4
  40138c:	47c0      	blx	r8
		res = f_open(&indexFile_obj, (char const *)fileIndexLog, FA_OPEN_ALWAYS | FA_WRITE | FA_READ);
  40138e:	a929      	add	r1, sp, #164	; 0xa4
  401390:	a8c2      	add	r0, sp, #776	; 0x308
  401392:	2213      	movs	r2, #19
  401394:	47b0      	blx	r6
		if (res != FR_OK)
  401396:	2800      	cmp	r0, #0
  401398:	d15e      	bne.n	401458 <task_sdCard_OpenNewFile+0x17c>
			debugPrintString("Failed on creating new movement log file\r\n");
		}
		if(status == STATUS_PASS)
		{
			//if the filesize is 0, it means it's never been created, set index to 1.
			if(indexFile_obj.fsize == 0)
  40139a:	9bc5      	ldr	r3, [sp, #788]	; 0x314
  40139c:	2b00      	cmp	r3, #0
  40139e:	d16f      	bne.n	401480 <task_sdCard_OpenNewFile+0x1a4>
			{
				fileIndexNumber = 1;
  4013a0:	2201      	movs	r2, #1
  4013a2:	9206      	str	r2, [sp, #24]
  4013a4:	f10d 0940 	add.w	r9, sp, #64	; 0x40
			}
		}
		if(status == STATUS_PASS)
		{
			//write the update index back to the file.
			sprintf(data_buffer, "%05d\r\n", fileIndexNumber);
  4013a8:	4b5c      	ldr	r3, [pc, #368]	; (40151c <task_sdCard_OpenNewFile+0x240>)
  4013aa:	495d      	ldr	r1, [pc, #372]	; (401520 <task_sdCard_OpenNewFile+0x244>)
			f_lseek(&indexFile_obj,0);
  4013ac:	f8df a1b8 	ldr.w	sl, [pc, #440]	; 401568 <task_sdCard_OpenNewFile+0x28c>
			if(f_write(&indexFile_obj, (void*)data_buffer,strlen(data_buffer),&bytes_written) != FR_OK)
  4013b0:	f8df b1b8 	ldr.w	fp, [pc, #440]	; 40156c <task_sdCard_OpenNewFile+0x290>
			}
		}
		if(status == STATUS_PASS)
		{
			//write the update index back to the file.
			sprintf(data_buffer, "%05d\r\n", fileIndexNumber);
  4013b4:	4648      	mov	r0, r9
  4013b6:	4798      	blx	r3
			f_lseek(&indexFile_obj,0);
  4013b8:	2100      	movs	r1, #0
  4013ba:	a8c2      	add	r0, sp, #776	; 0x308
  4013bc:	47d0      	blx	sl
			if(f_write(&indexFile_obj, (void*)data_buffer,strlen(data_buffer),&bytes_written) != FR_OK)
  4013be:	4648      	mov	r0, r9
  4013c0:	47d8      	blx	fp
  4013c2:	4649      	mov	r1, r9
  4013c4:	4602      	mov	r2, r0
  4013c6:	ab05      	add	r3, sp, #20
  4013c8:	a8c2      	add	r0, sp, #776	; 0x308
  4013ca:	f8df c1a4 	ldr.w	ip, [pc, #420]	; 401570 <task_sdCard_OpenNewFile+0x294>
  4013ce:	47e0      	blx	ip
  4013d0:	b158      	cbz	r0, 4013ea <task_sdCard_OpenNewFile+0x10e>
				dataLogFileOpen = true;
			}
			else
			{
				debugPrintString("log failed to open\r\n");
				status = STATUS_FAIL; 
  4013d2:	2501      	movs	r5, #1
			}
		}
		xSemaphoreGive(semaphore_fatFsAccess);
  4013d4:	2100      	movs	r1, #0
  4013d6:	6820      	ldr	r0, [r4, #0]
  4013d8:	4c52      	ldr	r4, [pc, #328]	; (401524 <task_sdCard_OpenNewFile+0x248>)
  4013da:	460a      	mov	r2, r1
  4013dc:	460b      	mov	r3, r1
  4013de:	47a0      	blx	r4
  4013e0:	4628      	mov	r0, r5
	{
		debugPrintString("Can't get semaphore to open log file\r\n");
		status = STATUS_FAIL;
	}
	return status; 
}
  4013e2:	f20d 5d34 	addw	sp, sp, #1332	; 0x534
  4013e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			{
				status = STATUS_FAIL;
			}
			else
			{
				f_close(&indexFile_obj);
  4013ea:	4b4f      	ldr	r3, [pc, #316]	; (401528 <task_sdCard_OpenNewFile+0x24c>)
  4013ec:	a8c2      	add	r0, sp, #776	; 0x308
  4013ee:	4798      	blx	r3
		#endif
		
		if(status == STATUS_PASS)
		{
			//create the filename
			if(nvmSettings.enableCsvFormat == 0)
  4013f0:	4b4e      	ldr	r3, [pc, #312]	; (40152c <task_sdCard_OpenNewFile+0x250>)
			{
				snprintf(dataLogFileName, SD_CARD_FILENAME_LENGTH, "%s/%s_%s%05d.dat",dirName, brainSettings.suitNumber, brainSettings.fileName, fileIndexNumber); 
  4013f2:	4a4f      	ldr	r2, [pc, #316]	; (401530 <task_sdCard_OpenNewFile+0x254>)
		#endif
		
		if(status == STATUS_PASS)
		{
			//create the filename
			if(nvmSettings.enableCsvFormat == 0)
  4013f4:	691b      	ldr	r3, [r3, #16]
  4013f6:	2b00      	cmp	r3, #0
  4013f8:	d136      	bne.n	401468 <task_sdCard_OpenNewFile+0x18c>
			{
				snprintf(dataLogFileName, SD_CARD_FILENAME_LENGTH, "%s/%s_%s%05d.dat",dirName, brainSettings.suitNumber, brainSettings.fileName, fileIndexNumber); 
  4013fa:	f102 0132 	add.w	r1, r2, #50	; 0x32
  4013fe:	9b06      	ldr	r3, [sp, #24]
  401400:	9302      	str	r3, [sp, #8]
  401402:	9200      	str	r2, [sp, #0]
  401404:	9101      	str	r1, [sp, #4]
  401406:	ab4f      	add	r3, sp, #316	; 0x13c
  401408:	484a      	ldr	r0, [pc, #296]	; (401534 <task_sdCard_OpenNewFile+0x258>)
  40140a:	4a4b      	ldr	r2, [pc, #300]	; (401538 <task_sdCard_OpenNewFile+0x25c>)
  40140c:	2196      	movs	r1, #150	; 0x96
  40140e:	47a8      	blx	r5
			else
			{
				snprintf(dataLogFileName, SD_CARD_FILENAME_LENGTH, "%s/%s_%s%05d.csv",dirName, brainSettings.suitNumber, brainSettings.fileName, fileIndexNumber); 
			}
			
			if (f_open(&dataLogFile_obj, (char const *)dataLogFileName, FA_OPEN_ALWAYS | FA_WRITE) == FR_OK)
  401410:	4d4a      	ldr	r5, [pc, #296]	; (40153c <task_sdCard_OpenNewFile+0x260>)
  401412:	4948      	ldr	r1, [pc, #288]	; (401534 <task_sdCard_OpenNewFile+0x258>)
  401414:	4628      	mov	r0, r5
  401416:	2212      	movs	r2, #18
  401418:	47b0      	blx	r6
  40141a:	4606      	mov	r6, r0
  40141c:	bb00      	cbnz	r0, 401460 <task_sdCard_OpenNewFile+0x184>
			{
				debugPrintString(brainSettings.imuSet);
  40141e:	4848      	ldr	r0, [pc, #288]	; (401540 <task_sdCard_OpenNewFile+0x264>)
  401420:	f8df 90dc 	ldr.w	r9, [pc, #220]	; 401500 <task_sdCard_OpenNewFile+0x224>
  401424:	47c8      	blx	r9
				strncpy(temp, dataLogFileName, sizeof(dataLogFileName));
  401426:	4943      	ldr	r1, [pc, #268]	; (401534 <task_sdCard_OpenNewFile+0x258>)
  401428:	2296      	movs	r2, #150	; 0x96
  40142a:	a89b      	add	r0, sp, #620	; 0x26c
  40142c:	47c0      	blx	r8
				strncat(temp, "\r\n", 2);
  40142e:	a89b      	add	r0, sp, #620	; 0x26c
  401430:	47d8      	blx	fp
  401432:	4b44      	ldr	r3, [pc, #272]	; (401544 <task_sdCard_OpenNewFile+0x268>)
  401434:	aa9b      	add	r2, sp, #620	; 0x26c
  401436:	4402      	add	r2, r0
  401438:	f50d 7e1b 	add.w	lr, sp, #620	; 0x26c
  40143c:	8819      	ldrh	r1, [r3, #0]
  40143e:	789b      	ldrb	r3, [r3, #2]
  401440:	f82e 1000 	strh.w	r1, [lr, r0]
				debugPrintString(temp);
  401444:	4670      	mov	r0, lr
			
			if (f_open(&dataLogFile_obj, (char const *)dataLogFileName, FA_OPEN_ALWAYS | FA_WRITE) == FR_OK)
			{
				debugPrintString(brainSettings.imuSet);
				strncpy(temp, dataLogFileName, sizeof(dataLogFileName));
				strncat(temp, "\r\n", 2);
  401446:	7093      	strb	r3, [r2, #2]
				debugPrintString(temp);
  401448:	47c8      	blx	r9
				res = f_lseek(&dataLogFile_obj, dataLogFile_obj.fsize);
  40144a:	4628      	mov	r0, r5
  40144c:	4635      	mov	r5, r6
  40144e:	68c1      	ldr	r1, [r0, #12]
  401450:	47d0      	blx	sl
				dataLogFileOpen = true;
  401452:	2301      	movs	r3, #1
  401454:	703b      	strb	r3, [r7, #0]
  401456:	e7bd      	b.n	4013d4 <task_sdCard_OpenNewFile+0xf8>
  401458:	4e29      	ldr	r6, [pc, #164]	; (401500 <task_sdCard_OpenNewFile+0x224>)
		strncpy(fileIndexLog, logFileName, sizeof(logFileName));
		res = f_open(&indexFile_obj, (char const *)fileIndexLog, FA_OPEN_ALWAYS | FA_WRITE | FA_READ);
		if (res != FR_OK)
		{
			status = STATUS_FAIL;
			debugPrintString("Failed on creating new movement log file\r\n");
  40145a:	483b      	ldr	r0, [pc, #236]	; (401548 <task_sdCard_OpenNewFile+0x26c>)
  40145c:	47b0      	blx	r6
  40145e:	e7b8      	b.n	4013d2 <task_sdCard_OpenNewFile+0xf6>
				res = f_lseek(&dataLogFile_obj, dataLogFile_obj.fsize);
				dataLogFileOpen = true;
			}
			else
			{
				debugPrintString("log failed to open\r\n");
  401460:	483a      	ldr	r0, [pc, #232]	; (40154c <task_sdCard_OpenNewFile+0x270>)
  401462:	4b27      	ldr	r3, [pc, #156]	; (401500 <task_sdCard_OpenNewFile+0x224>)
  401464:	4798      	blx	r3
  401466:	e7b4      	b.n	4013d2 <task_sdCard_OpenNewFile+0xf6>
			{
				snprintf(dataLogFileName, SD_CARD_FILENAME_LENGTH, "%s/%s_%s%05d.dat",dirName, brainSettings.suitNumber, brainSettings.fileName, fileIndexNumber); 
			}
			else
			{
				snprintf(dataLogFileName, SD_CARD_FILENAME_LENGTH, "%s/%s_%s%05d.csv",dirName, brainSettings.suitNumber, brainSettings.fileName, fileIndexNumber); 
  401468:	9b06      	ldr	r3, [sp, #24]
  40146a:	9302      	str	r3, [sp, #8]
  40146c:	f102 0132 	add.w	r1, r2, #50	; 0x32
  401470:	9200      	str	r2, [sp, #0]
  401472:	9101      	str	r1, [sp, #4]
  401474:	ab4f      	add	r3, sp, #316	; 0x13c
  401476:	4a36      	ldr	r2, [pc, #216]	; (401550 <task_sdCard_OpenNewFile+0x274>)
  401478:	482e      	ldr	r0, [pc, #184]	; (401534 <task_sdCard_OpenNewFile+0x258>)
  40147a:	2196      	movs	r1, #150	; 0x96
  40147c:	47a8      	blx	r5
  40147e:	e7c7      	b.n	401410 <task_sdCard_OpenNewFile+0x134>
			{
				fileIndexNumber = 1;
			}
			else
			{
				if(f_read(&indexFile_obj, (void*)data_buffer, 100, &byte_read) != FR_OK)
  401480:	f10d 0940 	add.w	r9, sp, #64	; 0x40
  401484:	4649      	mov	r1, r9
  401486:	a8c2      	add	r0, sp, #776	; 0x308
  401488:	2264      	movs	r2, #100	; 0x64
  40148a:	ab04      	add	r3, sp, #16
  40148c:	f8df c0e4 	ldr.w	ip, [pc, #228]	; 401574 <task_sdCard_OpenNewFile+0x298>
  401490:	47e0      	blx	ip
  401492:	2800      	cmp	r0, #0
  401494:	d19d      	bne.n	4013d2 <task_sdCard_OpenNewFile+0xf6>
				{
					status = STATUS_FAIL;
				}
				if(status == STATUS_PASS)
				{
					sscanf(data_buffer,"%d\r\n",&fileIndexNumber);
  401496:	aa06      	add	r2, sp, #24
  401498:	4648      	mov	r0, r9
  40149a:	492e      	ldr	r1, [pc, #184]	; (401554 <task_sdCard_OpenNewFile+0x278>)
  40149c:	4b2e      	ldr	r3, [pc, #184]	; (401558 <task_sdCard_OpenNewFile+0x27c>)
  40149e:	4798      	blx	r3
					fileIndexNumber++;
  4014a0:	9a06      	ldr	r2, [sp, #24]
  4014a2:	3201      	adds	r2, #1
  4014a4:	9206      	str	r2, [sp, #24]
  4014a6:	e77f      	b.n	4013a8 <task_sdCard_OpenNewFile+0xcc>
		#else
		snprintf(dirName, SD_CARD_FILENAME_LENGTH, "0:%s", brainSettings.fileName);
		res = f_opendir(&dir, &dirName);	//open the specified directory
		if (res == FR_NO_PATH)
		{
			res = f_mkdir(&dirName);	//the requested directory doesn't exist, create new one
  4014a8:	a84f      	add	r0, sp, #316	; 0x13c
  4014aa:	4b2c      	ldr	r3, [pc, #176]	; (40155c <task_sdCard_OpenNewFile+0x280>)
  4014ac:	4798      	blx	r3
			if (res != FR_OK)
  4014ae:	2800      	cmp	r0, #0
  4014b0:	f43f af5e 	beq.w	401370 <task_sdCard_OpenNewFile+0x94>
			{
				status = STATUS_FAIL;
				debugPrintString("Failed on creating new movement log directory\r\n");
  4014b4:	482a      	ldr	r0, [pc, #168]	; (401560 <task_sdCard_OpenNewFile+0x284>)
  4014b6:	4e12      	ldr	r6, [pc, #72]	; (401500 <task_sdCard_OpenNewFile+0x224>)
  4014b8:	47b0      	blx	r6
			}
		}
		snprintf(logFileName, SD_CARD_FILENAME_LENGTH, "%s/%s", dirName, &fileIndexLog[2]);
  4014ba:	f10d 02a6 	add.w	r2, sp, #166	; 0xa6
  4014be:	ab4f      	add	r3, sp, #316	; 0x13c
  4014c0:	9200      	str	r2, [sp, #0]
  4014c2:	2196      	movs	r1, #150	; 0x96
  4014c4:	4a13      	ldr	r2, [pc, #76]	; (401514 <task_sdCard_OpenNewFile+0x238>)
  4014c6:	a875      	add	r0, sp, #468	; 0x1d4
  4014c8:	47a8      	blx	r5
		strncpy(fileIndexLog, logFileName, sizeof(logFileName));
  4014ca:	a975      	add	r1, sp, #468	; 0x1d4
  4014cc:	2296      	movs	r2, #150	; 0x96
  4014ce:	4b25      	ldr	r3, [pc, #148]	; (401564 <task_sdCard_OpenNewFile+0x288>)
  4014d0:	a829      	add	r0, sp, #164	; 0xa4
  4014d2:	4798      	blx	r3
		res = f_open(&indexFile_obj, (char const *)fileIndexLog, FA_OPEN_ALWAYS | FA_WRITE | FA_READ);
  4014d4:	a929      	add	r1, sp, #164	; 0xa4
  4014d6:	a8c2      	add	r0, sp, #776	; 0x308
  4014d8:	2213      	movs	r2, #19
  4014da:	4b0f      	ldr	r3, [pc, #60]	; (401518 <task_sdCard_OpenNewFile+0x23c>)
  4014dc:	4798      	blx	r3
		if (res != FR_OK)
  4014de:	2800      	cmp	r0, #0
  4014e0:	f43f af77 	beq.w	4013d2 <task_sdCard_OpenNewFile+0xf6>
  4014e4:	e7b9      	b.n	40145a <task_sdCard_OpenNewFile+0x17e>
  4014e6:	bf00      	nop
  4014e8:	00415540 	.word	0x00415540
  4014ec:	0040c31d 	.word	0x0040c31d
  4014f0:	20002318 	.word	0x20002318
  4014f4:	20001464 	.word	0x20001464
  4014f8:	00406b35 	.word	0x00406b35
  4014fc:	0041575c 	.word	0x0041575c
  401500:	004008c9 	.word	0x004008c9
  401504:	004156b0 	.word	0x004156b0
  401508:	200001e6 	.word	0x200001e6
  40150c:	0040c4ed 	.word	0x0040c4ed
  401510:	00405e8d 	.word	0x00405e8d
  401514:	004156b8 	.word	0x004156b8
  401518:	00405599 	.word	0x00405599
  40151c:	0040c555 	.word	0x0040c555
  401520:	00415784 	.word	0x00415784
  401524:	00406979 	.word	0x00406979
  401528:	00405c85 	.word	0x00405c85
  40152c:	20003e14 	.word	0x20003e14
  401530:	200001b4 	.word	0x200001b4
  401534:	2000227c 	.word	0x2000227c
  401538:	0041571c 	.word	0x0041571c
  40153c:	20003be0 	.word	0x20003be0
  401540:	20000235 	.word	0x20000235
  401544:	00415bf0 	.word	0x00415bf0
  401548:	004156f0 	.word	0x004156f0
  40154c:	00415744 	.word	0x00415744
  401550:	00415730 	.word	0x00415730
  401554:	00415434 	.word	0x00415434
  401558:	0040c5a1 	.word	0x0040c5a1
  40155c:	00406191 	.word	0x00406191
  401560:	004156c0 	.word	0x004156c0
  401564:	0040cb1d 	.word	0x0040cb1d
  401568:	00405cd1 	.word	0x00405cd1
  40156c:	0040c9a5 	.word	0x0040c9a5
  401570:	004059ed 	.word	0x004059ed
  401574:	0040583d 	.word	0x0040583d

00401578 <task_sdCard_CloseFile>:
	}
	return status; 
}

status_t task_sdCard_CloseFile()
{
  401578:	b538      	push	{r3, r4, r5, lr}
	status_t status = STATUS_PASS; 
	//if the filelog is not open, return and error
	if(dataLogFileOpen == false)
  40157a:	4b0c      	ldr	r3, [pc, #48]	; (4015ac <task_sdCard_CloseFile+0x34>)
  40157c:	781b      	ldrb	r3, [r3, #0]
  40157e:	b90b      	cbnz	r3, 401584 <task_sdCard_CloseFile+0xc>
	{
		return STATUS_FAIL;
  401580:	2001      	movs	r0, #1
  401582:	bd38      	pop	{r3, r4, r5, pc}
	}		
	if(xSemaphoreTake(semaphore_fatFsAccess,200) == true)
  401584:	4c0a      	ldr	r4, [pc, #40]	; (4015b0 <task_sdCard_CloseFile+0x38>)
  401586:	4d0b      	ldr	r5, [pc, #44]	; (4015b4 <task_sdCard_CloseFile+0x3c>)
  401588:	6820      	ldr	r0, [r4, #0]
  40158a:	2100      	movs	r1, #0
  40158c:	460b      	mov	r3, r1
  40158e:	22c8      	movs	r2, #200	; 0xc8
  401590:	47a8      	blx	r5
  401592:	2801      	cmp	r0, #1
  401594:	4603      	mov	r3, r0
  401596:	d1f3      	bne.n	401580 <task_sdCard_CloseFile+0x8>
	{
		//set the flag to have the main sd card thread close the file. 
		//we don't want to close the file in the middle of a write. 
		closeLogFileFlag = 1; 
  401598:	4a07      	ldr	r2, [pc, #28]	; (4015b8 <task_sdCard_CloseFile+0x40>)
		xSemaphoreGive(semaphore_fatFsAccess);
  40159a:	6820      	ldr	r0, [r4, #0]
	}		
	if(xSemaphoreTake(semaphore_fatFsAccess,200) == true)
	{
		//set the flag to have the main sd card thread close the file. 
		//we don't want to close the file in the middle of a write. 
		closeLogFileFlag = 1; 
  40159c:	7013      	strb	r3, [r2, #0]
		xSemaphoreGive(semaphore_fatFsAccess);
  40159e:	2100      	movs	r1, #0
  4015a0:	4c06      	ldr	r4, [pc, #24]	; (4015bc <task_sdCard_CloseFile+0x44>)
  4015a2:	460a      	mov	r2, r1
  4015a4:	460b      	mov	r3, r1
  4015a6:	47a0      	blx	r4
	return status; 
}

status_t task_sdCard_CloseFile()
{
	status_t status = STATUS_PASS; 
  4015a8:	2000      	movs	r0, #0
	else
	{		
		status = STATUS_FAIL;
	}
	return status; 	
}
  4015aa:	bd38      	pop	{r3, r4, r5, pc}
  4015ac:	20002318 	.word	0x20002318
  4015b0:	20001464 	.word	0x20001464
  4015b4:	00406b35 	.word	0x00406b35
  4015b8:	20001468 	.word	0x20001468
  4015bc:	00406979 	.word	0x00406979

004015c0 <task_debugLog_CloseFile>:

status_t task_debugLog_CloseFile()
{
  4015c0:	b538      	push	{r3, r4, r5, lr}
	status_t status = STATUS_PASS; 
	//if DebugLog file is not open, return error
	if (debugLogFileOpen == false)
  4015c2:	4b0e      	ldr	r3, [pc, #56]	; (4015fc <task_debugLog_CloseFile+0x3c>)
  4015c4:	781b      	ldrb	r3, [r3, #0]
  4015c6:	b90b      	cbnz	r3, 4015cc <task_debugLog_CloseFile+0xc>
	{
		return STATUS_FAIL;
  4015c8:	2001      	movs	r0, #1
  4015ca:	bd38      	pop	{r3, r4, r5, pc}
	}
	vTaskDelay(200);	//wait to write everything before closing the file
  4015cc:	20c8      	movs	r0, #200	; 0xc8
  4015ce:	4b0c      	ldr	r3, [pc, #48]	; (401600 <task_debugLog_CloseFile+0x40>)
	if (xSemaphoreTake(semaphore_fatFsAccess, 100) == true)
  4015d0:	4c0c      	ldr	r4, [pc, #48]	; (401604 <task_debugLog_CloseFile+0x44>)
  4015d2:	4d0d      	ldr	r5, [pc, #52]	; (401608 <task_debugLog_CloseFile+0x48>)
	//if DebugLog file is not open, return error
	if (debugLogFileOpen == false)
	{
		return STATUS_FAIL;
	}
	vTaskDelay(200);	//wait to write everything before closing the file
  4015d4:	4798      	blx	r3
	if (xSemaphoreTake(semaphore_fatFsAccess, 100) == true)
  4015d6:	2100      	movs	r1, #0
  4015d8:	460b      	mov	r3, r1
  4015da:	6820      	ldr	r0, [r4, #0]
  4015dc:	2264      	movs	r2, #100	; 0x64
  4015de:	47a8      	blx	r5
  4015e0:	2801      	cmp	r0, #1
  4015e2:	4603      	mov	r3, r0
  4015e4:	d1f0      	bne.n	4015c8 <task_debugLog_CloseFile+0x8>
	{
		//set the flag to have the main sd card thread close the file
		//we don't want to close the file in the middle of a write
		closeDebugLogFileFlag = 1;
  4015e6:	4a09      	ldr	r2, [pc, #36]	; (40160c <task_debugLog_CloseFile+0x4c>)
		xSemaphoreGive(semaphore_fatFsAccess);
  4015e8:	6820      	ldr	r0, [r4, #0]
	vTaskDelay(200);	//wait to write everything before closing the file
	if (xSemaphoreTake(semaphore_fatFsAccess, 100) == true)
	{
		//set the flag to have the main sd card thread close the file
		//we don't want to close the file in the middle of a write
		closeDebugLogFileFlag = 1;
  4015ea:	7013      	strb	r3, [r2, #0]
		xSemaphoreGive(semaphore_fatFsAccess);
  4015ec:	2100      	movs	r1, #0
  4015ee:	4c08      	ldr	r4, [pc, #32]	; (401610 <task_debugLog_CloseFile+0x50>)
  4015f0:	460a      	mov	r2, r1
  4015f2:	460b      	mov	r3, r1
  4015f4:	47a0      	blx	r4
	return status; 	
}

status_t task_debugLog_CloseFile()
{
	status_t status = STATUS_PASS; 
  4015f6:	2000      	movs	r0, #0
	{		
		status = STATUS_FAIL;
	}
	return status; 
	
}
  4015f8:	bd38      	pop	{r3, r4, r5, pc}
  4015fa:	bf00      	nop
  4015fc:	20002078 	.word	0x20002078
  401600:	004072ed 	.word	0x004072ed
  401604:	20001464 	.word	0x20001464
  401608:	00406b35 	.word	0x00406b35
  40160c:	20002070 	.word	0x20002070
  401610:	00406979 	.word	0x00406979

00401614 <task_debugLog_ChangeFile>:

status_t task_debugLog_ChangeFile()
{	
  401614:	b500      	push	{lr}
  401616:	b089      	sub	sp, #36	; 0x24
	//it is assumed that this file is only called when the file system semaphore is taken. 
	FRESULT res;
	FILINFO vDebugLogFileInfo;
	status_t status = STATUS_PASS;
	//check if the old file exits
	res = f_stat(debugLogOldFileName, &vDebugLogFileInfo);
  401618:	480a      	ldr	r0, [pc, #40]	; (401644 <task_debugLog_ChangeFile+0x30>)
  40161a:	4b0b      	ldr	r3, [pc, #44]	; (401648 <task_debugLog_ChangeFile+0x34>)
  40161c:	4669      	mov	r1, sp
  40161e:	4798      	blx	r3
	if (res == FR_OK)
  401620:	b158      	cbz	r0, 40163a <task_debugLog_ChangeFile+0x26>
		//delete the old file before renaming the current file
		f_unlink(debugLogOldFileName);
	}
	//TODO can you really change the file name without closing it first?
	//rename the current file to the name of old file
	res = f_rename(&debugLogNewFileName[2], &debugLogOldFileName[2]);
  401622:	480a      	ldr	r0, [pc, #40]	; (40164c <task_debugLog_ChangeFile+0x38>)
  401624:	490a      	ldr	r1, [pc, #40]	; (401650 <task_debugLog_ChangeFile+0x3c>)
  401626:	4b0b      	ldr	r3, [pc, #44]	; (401654 <task_debugLog_ChangeFile+0x40>)
  401628:	4798      	blx	r3
	if (res != FR_OK)
  40162a:	b118      	cbz	r0, 401634 <task_debugLog_ChangeFile+0x20>
	{
		debugPrintString("Rename of Debug Log file failed\r\n");
  40162c:	480a      	ldr	r0, [pc, #40]	; (401658 <task_debugLog_ChangeFile+0x44>)
  40162e:	4b0b      	ldr	r3, [pc, #44]	; (40165c <task_debugLog_ChangeFile+0x48>)
  401630:	4798      	blx	r3
		status = STATUS_FAIL;
  401632:	2001      	movs	r0, #1
	}
	return status;
}
  401634:	b009      	add	sp, #36	; 0x24
  401636:	f85d fb04 	ldr.w	pc, [sp], #4
	//check if the old file exits
	res = f_stat(debugLogOldFileName, &vDebugLogFileInfo);
	if (res == FR_OK)
	{
		//delete the old file before renaming the current file
		f_unlink(debugLogOldFileName);
  40163a:	4b09      	ldr	r3, [pc, #36]	; (401660 <task_debugLog_ChangeFile+0x4c>)
  40163c:	4801      	ldr	r0, [pc, #4]	; (401644 <task_debugLog_ChangeFile+0x30>)
  40163e:	4798      	blx	r3
  401640:	e7ef      	b.n	401622 <task_debugLog_ChangeFile+0xe>
  401642:	bf00      	nop
  401644:	20000090 	.word	0x20000090
  401648:	00405f05 	.word	0x00405f05
  40164c:	200000a6 	.word	0x200000a6
  401650:	20000092 	.word	0x20000092
  401654:	004063cd 	.word	0x004063cd
  401658:	0041578c 	.word	0x0041578c
  40165c:	004008c9 	.word	0x004008c9
  401660:	004060a5 	.word	0x004060a5

00401664 <task_debugLog_OpenFile>:
	}
	return status; 
}

status_t task_debugLog_OpenFile()
{
  401664:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	FRESULT res;
	FILINFO vDebugLogFileInfo;
	status_t status = STATUS_PASS;
	
	//if the log file is open, then return an error
	if(debugLogFileOpen == true)
  401668:	4c26      	ldr	r4, [pc, #152]	; (401704 <task_debugLog_OpenFile+0xa0>)
  40166a:	7820      	ldrb	r0, [r4, #0]
  40166c:	b2c0      	uxtb	r0, r0
  40166e:	2801      	cmp	r0, #1
	}
	return status; 
}

status_t task_debugLog_OpenFile()
{
  401670:	b088      	sub	sp, #32
	FRESULT res;
	FILINFO vDebugLogFileInfo;
	status_t status = STATUS_PASS;
	
	//if the log file is open, then return an error
	if(debugLogFileOpen == true)
  401672:	d00c      	beq.n	40168e <task_debugLog_OpenFile+0x2a>
	{
		status = STATUS_FAIL;
		return status;
	}	
	if(xSemaphoreTake(semaphore_fatFsAccess, 100) == true)
  401674:	4d24      	ldr	r5, [pc, #144]	; (401708 <task_debugLog_OpenFile+0xa4>)
  401676:	4e25      	ldr	r6, [pc, #148]	; (40170c <task_debugLog_OpenFile+0xa8>)
  401678:	6828      	ldr	r0, [r5, #0]
  40167a:	2100      	movs	r1, #0
  40167c:	460b      	mov	r3, r1
  40167e:	2264      	movs	r2, #100	; 0x64
  401680:	47b0      	blx	r6
  401682:	2801      	cmp	r0, #1
  401684:	d006      	beq.n	401694 <task_debugLog_OpenFile+0x30>
		}
		xSemaphoreGive(semaphore_fatFsAccess);	
	}
	else
	{
		debugPrintString("Can't get semaphore to open DebugLog file\r\n");
  401686:	4822      	ldr	r0, [pc, #136]	; (401710 <task_debugLog_OpenFile+0xac>)
  401688:	4b22      	ldr	r3, [pc, #136]	; (401714 <task_debugLog_OpenFile+0xb0>)
  40168a:	4798      	blx	r3
		status = STATUS_FAIL; 
  40168c:	2001      	movs	r0, #1
	}
	return status; 
}
  40168e:	b008      	add	sp, #32
  401690:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		status = STATUS_FAIL;
		return status;
	}	
	if(xSemaphoreTake(semaphore_fatFsAccess, 100) == true)
	{
		res = f_stat(debugLogNewFileName, &vDebugLogFileInfo);
  401694:	4820      	ldr	r0, [pc, #128]	; (401718 <task_debugLog_OpenFile+0xb4>)
  401696:	4b21      	ldr	r3, [pc, #132]	; (40171c <task_debugLog_OpenFile+0xb8>)
  401698:	4669      	mov	r1, sp
  40169a:	4798      	blx	r3
		if (res == FR_OK)
  40169c:	bb08      	cbnz	r0, 4016e2 <task_debugLog_OpenFile+0x7e>
		{
			//file exist, do a check on size
			if (vDebugLogFileInfo.fsize >= DEBUG_LOG_MAX_FILE_SIZE)
  40169e:	4a20      	ldr	r2, [pc, #128]	; (401720 <task_debugLog_OpenFile+0xbc>)
  4016a0:	9b00      	ldr	r3, [sp, #0]
  4016a2:	4293      	cmp	r3, r2
  4016a4:	d825      	bhi.n	4016f2 <task_debugLog_OpenFile+0x8e>
  4016a6:	f8df 806c 	ldr.w	r8, [pc, #108]	; 401714 <task_debugLog_OpenFile+0xb0>
			debugPrintString("DebugLog file open failed\r\n");
		}
		if(status == STATUS_PASS)
		{
			//Open the Log file DebugLog.txt
			res = f_open(&debugLogFile_Obj, (char const *)debugLogNewFileName, FA_OPEN_ALWAYS | FA_WRITE);
  4016aa:	4f1e      	ldr	r7, [pc, #120]	; (401724 <task_debugLog_OpenFile+0xc0>)
  4016ac:	491a      	ldr	r1, [pc, #104]	; (401718 <task_debugLog_OpenFile+0xb4>)
  4016ae:	4b1e      	ldr	r3, [pc, #120]	; (401728 <task_debugLog_OpenFile+0xc4>)
  4016b0:	4638      	mov	r0, r7
  4016b2:	2212      	movs	r2, #18
  4016b4:	4798      	blx	r3
			if (res == FR_OK)
  4016b6:	4606      	mov	r6, r0
  4016b8:	bb08      	cbnz	r0, 4016fe <task_debugLog_OpenFile+0x9a>
			{
				debugPrintString("\r\n\r\n\r\nProgram start Brain Pack " VERSION " \r\n");
  4016ba:	481c      	ldr	r0, [pc, #112]	; (40172c <task_debugLog_OpenFile+0xc8>)
  4016bc:	47c0      	blx	r8
				debugPrintString("DebugLog open\r\n");
  4016be:	481c      	ldr	r0, [pc, #112]	; (401730 <task_debugLog_OpenFile+0xcc>)
  4016c0:	47c0      	blx	r8
				status = STATUS_FAIL;
			}			
		}
		if(status == STATUS_PASS)
		{
			res = f_lseek(&debugLogFile_Obj, debugLogFile_Obj.fsize);
  4016c2:	4b1c      	ldr	r3, [pc, #112]	; (401734 <task_debugLog_OpenFile+0xd0>)
  4016c4:	68f9      	ldr	r1, [r7, #12]
  4016c6:	4638      	mov	r0, r7
  4016c8:	4798      	blx	r3
			debugLogFileOpen = true;
  4016ca:	2301      	movs	r3, #1
  4016cc:	7023      	strb	r3, [r4, #0]
			//the file is open and we're good to go, the status should be PASS here. 	
		}
		xSemaphoreGive(semaphore_fatFsAccess);	
  4016ce:	2100      	movs	r1, #0
  4016d0:	6828      	ldr	r0, [r5, #0]
  4016d2:	4c19      	ldr	r4, [pc, #100]	; (401738 <task_debugLog_OpenFile+0xd4>)
  4016d4:	460a      	mov	r2, r1
  4016d6:	460b      	mov	r3, r1
  4016d8:	47a0      	blx	r4
  4016da:	4630      	mov	r0, r6
	{
		debugPrintString("Can't get semaphore to open DebugLog file\r\n");
		status = STATUS_FAIL; 
	}
	return status; 
}
  4016dc:	b008      	add	sp, #32
  4016de:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				{
					status = STATUS_FAIL;
				}
			}
		}
		else if (res == FR_NO_FILE)
  4016e2:	2804      	cmp	r0, #4
		{
			debugPrintString("File does not exist, creating new file\r\n");
  4016e4:	bf0c      	ite	eq
  4016e6:	4815      	ldreq	r0, [pc, #84]	; (40173c <task_debugLog_OpenFile+0xd8>)
		}
		else
		{			
			debugPrintString("DebugLog file open failed\r\n");
  4016e8:	4815      	ldrne	r0, [pc, #84]	; (401740 <task_debugLog_OpenFile+0xdc>)
  4016ea:	f8df 8028 	ldr.w	r8, [pc, #40]	; 401714 <task_debugLog_OpenFile+0xb0>
  4016ee:	47c0      	blx	r8
  4016f0:	e7db      	b.n	4016aa <task_debugLog_OpenFile+0x46>
		if (res == FR_OK)
		{
			//file exist, do a check on size
			if (vDebugLogFileInfo.fsize >= DEBUG_LOG_MAX_FILE_SIZE)
			{
				if(task_debugLog_ChangeFile() != STATUS_PASS)
  4016f2:	4b14      	ldr	r3, [pc, #80]	; (401744 <task_debugLog_OpenFile+0xe0>)
  4016f4:	4798      	blx	r3
  4016f6:	2800      	cmp	r0, #0
  4016f8:	d0d5      	beq.n	4016a6 <task_debugLog_OpenFile+0x42>
	}
	return status; 
}

status_t task_debugLog_OpenFile()
{
  4016fa:	2601      	movs	r6, #1
  4016fc:	e7e7      	b.n	4016ce <task_debugLog_OpenFile+0x6a>
				debugPrintString("\r\n\r\n\r\nProgram start Brain Pack " VERSION " \r\n");
				debugPrintString("DebugLog open\r\n");
			}
			else
			{
				debugPrintString("DebugLog failed to open\r\n");
  4016fe:	4812      	ldr	r0, [pc, #72]	; (401748 <task_debugLog_OpenFile+0xe4>)
  401700:	47c0      	blx	r8
  401702:	e7fa      	b.n	4016fa <task_debugLog_OpenFile+0x96>
  401704:	20002078 	.word	0x20002078
  401708:	20001464 	.word	0x20001464
  40170c:	00406b35 	.word	0x00406b35
  401710:	0041584c 	.word	0x0041584c
  401714:	004008c9 	.word	0x004008c9
  401718:	200000a4 	.word	0x200000a4
  40171c:	00405f05 	.word	0x00405f05
  401720:	001e847f 	.word	0x001e847f
  401724:	200039b8 	.word	0x200039b8
  401728:	00405599 	.word	0x00405599
  40172c:	004157f8 	.word	0x004157f8
  401730:	00415820 	.word	0x00415820
  401734:	00405cd1 	.word	0x00405cd1
  401738:	00406979 	.word	0x00406979
  40173c:	004157b0 	.word	0x004157b0
  401740:	004157dc 	.word	0x004157dc
  401744:	00401615 	.word	0x00401615
  401748:	00415830 	.word	0x00415830

0040174c <task_sdCardHandler>:
volatile char dataLogFileName[SD_CARD_FILENAME_LENGTH] = {0};
	
char debugLogNewFileName[] = "0:DebugLog.txt", debugLogOldFileName[] = "0:DebugLog_old.txt";
	
void task_sdCardHandler(void *pvParameters)
{
  40174c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  401750:	b085      	sub	sp, #20
	
	uint32_t numBytesToWrite = 0, numBytesWritten = 0;
	uint32_t debugNumBytesToWrite = 0, debugNumBytesWritten = 0;
	uint32_t numBytes = 0, debugNumBytes = 0;
  401752:	2400      	movs	r4, #0
	semaphore_sdCardWrite = xSemaphoreCreateMutex();
  401754:	4da1      	ldr	r5, [pc, #644]	; (4019dc <task_sdCardHandler+0x290>)
void task_sdCardHandler(void *pvParameters)
{
	
	uint32_t numBytesToWrite = 0, numBytesWritten = 0;
	uint32_t debugNumBytesToWrite = 0, debugNumBytesWritten = 0;
	uint32_t numBytes = 0, debugNumBytes = 0;
  401756:	9402      	str	r4, [sp, #8]
  401758:	9403      	str	r4, [sp, #12]
	semaphore_sdCardWrite = xSemaphoreCreateMutex();
  40175a:	47a8      	blx	r5
  40175c:	49a0      	ldr	r1, [pc, #640]	; (4019e0 <task_sdCardHandler+0x294>)
	semaphore_fatFsAccess = xSemaphoreCreateMutex();
  40175e:	4ea1      	ldr	r6, [pc, #644]	; (4019e4 <task_sdCardHandler+0x298>)
{
	
	uint32_t numBytesToWrite = 0, numBytesWritten = 0;
	uint32_t debugNumBytesToWrite = 0, debugNumBytesWritten = 0;
	uint32_t numBytes = 0, debugNumBytes = 0;
	semaphore_sdCardWrite = xSemaphoreCreateMutex();
  401760:	6008      	str	r0, [r1, #0]
	semaphore_fatFsAccess = xSemaphoreCreateMutex();
  401762:	47a8      	blx	r5
  401764:	4aa0      	ldr	r2, [pc, #640]	; (4019e8 <task_sdCardHandler+0x29c>)
	static FRESULT res = FR_OK;
	uint32_t writeStart = 0;
	uint32_t maxWriteTime = 0; 
	dataLogFileName[0] = LUN_ID_SD_MMC_0_MEM + '0';
  401766:	4ba1      	ldr	r3, [pc, #644]	; (4019ec <task_sdCardHandler+0x2a0>)
  401768:	f8d2 a000 	ldr.w	sl, [r2]
  40176c:	f8df 82f8 	ldr.w	r8, [pc, #760]	; 401a68 <task_sdCardHandler+0x31c>
  401770:	f8df 92f8 	ldr.w	r9, [pc, #760]	; 401a6c <task_sdCardHandler+0x320>
  401774:	4f9e      	ldr	r7, [pc, #632]	; (4019f0 <task_sdCardHandler+0x2a4>)
  401776:	f8df b2f8 	ldr.w	fp, [pc, #760]	; 401a70 <task_sdCardHandler+0x324>
	
	uint32_t numBytesToWrite = 0, numBytesWritten = 0;
	uint32_t debugNumBytesToWrite = 0, debugNumBytesWritten = 0;
	uint32_t numBytes = 0, debugNumBytes = 0;
	semaphore_sdCardWrite = xSemaphoreCreateMutex();
	semaphore_fatFsAccess = xSemaphoreCreateMutex();
  40177a:	6030      	str	r0, [r6, #0]
	static FRESULT res = FR_OK;
	uint32_t writeStart = 0;
	uint32_t maxWriteTime = 0; 
	dataLogFileName[0] = LUN_ID_SD_MMC_0_MEM + '0';
  40177c:	2230      	movs	r2, #48	; 0x30
	uint32_t numBytes = 0, debugNumBytes = 0;
	semaphore_sdCardWrite = xSemaphoreCreateMutex();
	semaphore_fatFsAccess = xSemaphoreCreateMutex();
	static FRESULT res = FR_OK;
	uint32_t writeStart = 0;
	uint32_t maxWriteTime = 0; 
  40177e:	9401      	str	r4, [sp, #4]
	
void task_sdCardHandler(void *pvParameters)
{
	
	uint32_t numBytesToWrite = 0, numBytesWritten = 0;
	uint32_t debugNumBytesToWrite = 0, debugNumBytesWritten = 0;
  401780:	4625      	mov	r5, r4
	semaphore_sdCardWrite = xSemaphoreCreateMutex();
	semaphore_fatFsAccess = xSemaphoreCreateMutex();
	static FRESULT res = FR_OK;
	uint32_t writeStart = 0;
	uint32_t maxWriteTime = 0; 
	dataLogFileName[0] = LUN_ID_SD_MMC_0_MEM + '0';
  401782:	701a      	strb	r2, [r3, #0]
	while(1)
	{
		//take semaphore and copy data to a temporary buffer.
		writeStart = sgSysTickCount;
		if(xSemaphoreTake(semaphore_sdCardWrite,10) == true)
  401784:	f8df c258 	ldr.w	ip, [pc, #600]	; 4019e0 <task_sdCardHandler+0x294>
  401788:	4e9a      	ldr	r6, [pc, #616]	; (4019f4 <task_sdCardHandler+0x2a8>)
  40178a:	f8dc 0000 	ldr.w	r0, [ip]
  40178e:	2100      	movs	r1, #0
  401790:	460b      	mov	r3, r1
  401792:	220a      	movs	r2, #10
  401794:	47b0      	blx	r6
  401796:	2801      	cmp	r0, #1
  401798:	f000 80ab 	beq.w	4018f2 <task_sdCardHandler+0x1a6>
				debugLogBufferPointer = 0;
			}
			xSemaphoreGive(semaphore_sdCardWrite);
		}
		//if the close file flag is set, close the file. 
		if(closeLogFileFlag == 1)
  40179c:	f8df c2d4 	ldr.w	ip, [pc, #724]	; 401a74 <task_sdCardHandler+0x328>
  4017a0:	f89c 3000 	ldrb.w	r3, [ip]
  4017a4:	2b01      	cmp	r3, #1
  4017a6:	4666      	mov	r6, ip
  4017a8:	f000 80c8 	beq.w	40193c <task_sdCardHandler+0x1f0>
			f_close(&dataLogFile_obj); 
			dataLogFileOpen = false; 
			//clear the flag. 
			closeLogFileFlag = 0;
		}
		if(closeDebugLogFileFlag == 1)
  4017ac:	4e92      	ldr	r6, [pc, #584]	; (4019f8 <task_sdCardHandler+0x2ac>)
  4017ae:	7833      	ldrb	r3, [r6, #0]
  4017b0:	2b01      	cmp	r3, #1
  4017b2:	f000 80cf 	beq.w	401954 <task_sdCardHandler+0x208>
			debugLogFileOpen = false;
			//clear the flag
			closeDebugLogFileFlag = 0;
		}
		
		if (debugLogFile_Obj.fsize >= DEBUG_LOG_MAX_FILE_SIZE)	//Check if the file is above its size limit
  4017b6:	4e91      	ldr	r6, [pc, #580]	; (4019fc <task_sdCardHandler+0x2b0>)
  4017b8:	4a91      	ldr	r2, [pc, #580]	; (401a00 <task_sdCardHandler+0x2b4>)
  4017ba:	68f3      	ldr	r3, [r6, #12]
  4017bc:	4293      	cmp	r3, r2
  4017be:	f200 808e 	bhi.w	4018de <task_sdCardHandler+0x192>
			debugLogFileOpen = false;
			//Rename and switch the file
			task_debugLog_OpenFile();
		}
		
		if (xSemaphoreTake(semaphore_fatFsAccess, 1) == true)
  4017c2:	4e88      	ldr	r6, [pc, #544]	; (4019e4 <task_sdCardHandler+0x298>)
  4017c4:	f8df c22c 	ldr.w	ip, [pc, #556]	; 4019f4 <task_sdCardHandler+0x2a8>
  4017c8:	6830      	ldr	r0, [r6, #0]
  4017ca:	2100      	movs	r1, #0
  4017cc:	460b      	mov	r3, r1
  4017ce:	2201      	movs	r2, #1
  4017d0:	47e0      	blx	ip
  4017d2:	2801      	cmp	r0, #1
  4017d4:	d16e      	bne.n	4018b4 <task_sdCardHandler+0x168>
		{
			//if the data file is open, then write to log
			if(dataLogFileOpen)
  4017d6:	498b      	ldr	r1, [pc, #556]	; (401a04 <task_sdCardHandler+0x2b8>)
  4017d8:	780b      	ldrb	r3, [r1, #0]
  4017da:	b32b      	cbz	r3, 401828 <task_sdCardHandler+0xdc>
			{	
				if(numBytesToWrite > 0)
  4017dc:	b324      	cbz	r4, 401828 <task_sdCardHandler+0xdc>
  4017de:	2600      	movs	r6, #0
				{
					numBytesWritten = 0;			
					while(numBytesToWrite > 0)
					{			
						res = f_write(&dataLogFile_obj,  (void*)(tempBuf+numBytesWritten), numBytesToWrite, &numBytes);
  4017e0:	4989      	ldr	r1, [pc, #548]	; (401a08 <task_sdCardHandler+0x2bc>)
  4017e2:	488a      	ldr	r0, [pc, #552]	; (401a0c <task_sdCardHandler+0x2c0>)
  4017e4:	f8df c290 	ldr.w	ip, [pc, #656]	; 401a78 <task_sdCardHandler+0x32c>
  4017e8:	ab02      	add	r3, sp, #8
  4017ea:	4431      	add	r1, r6
  4017ec:	4622      	mov	r2, r4
  4017ee:	47e0      	blx	ip
  4017f0:	4603      	mov	r3, r0
  4017f2:	f888 3000 	strb.w	r3, [r8]
							break; 
						}				
						numBytesToWrite -= numBytes;
						numBytesWritten += numBytes;
						totalBytesWritten += numBytes;
						vTaskDelay(1);
  4017f6:	2001      	movs	r0, #1
				{
					numBytesWritten = 0;			
					while(numBytesToWrite > 0)
					{			
						res = f_write(&dataLogFile_obj,  (void*)(tempBuf+numBytesWritten), numBytesToWrite, &numBytes);
						if (res != FR_OK)
  4017f8:	2b00      	cmp	r3, #0
  4017fa:	f040 80c0 	bne.w	40197e <task_sdCardHandler+0x232>
								debugPrintString("Write to log file failed\r\n");	
							}
							//this is a serious error, break the loop. 								
							break; 
						}				
						numBytesToWrite -= numBytes;
  4017fe:	9b02      	ldr	r3, [sp, #8]
						numBytesWritten += numBytes;
						totalBytesWritten += numBytes;
  401800:	f8d9 2000 	ldr.w	r2, [r9]
								debugPrintString("Write to log file failed\r\n");	
							}
							//this is a serious error, break the loop. 								
							break; 
						}				
						numBytesToWrite -= numBytes;
  401804:	1ae4      	subs	r4, r4, r3
						numBytesWritten += numBytes;
						totalBytesWritten += numBytes;
  401806:	441a      	add	r2, r3
							}
							//this is a serious error, break the loop. 								
							break; 
						}				
						numBytesToWrite -= numBytes;
						numBytesWritten += numBytes;
  401808:	441e      	add	r6, r3
						totalBytesWritten += numBytes;
  40180a:	f8c9 2000 	str.w	r2, [r9]
						vTaskDelay(1);
  40180e:	47b8      	blx	r7
			if(dataLogFileOpen)
			{	
				if(numBytesToWrite > 0)
				{
					numBytesWritten = 0;			
					while(numBytesToWrite > 0)
  401810:	2c00      	cmp	r4, #0
  401812:	d1e5      	bne.n	4017e0 <task_sdCardHandler+0x94>
						numBytesToWrite -= numBytes;
						numBytesWritten += numBytes;
						totalBytesWritten += numBytes;
						vTaskDelay(1);
					}
					res = f_sync(&dataLogFile_obj); //sync the file
  401814:	487d      	ldr	r0, [pc, #500]	; (401a0c <task_sdCardHandler+0x2c0>)
  401816:	4b7e      	ldr	r3, [pc, #504]	; (401a10 <task_sdCardHandler+0x2c4>)
  401818:	4798      	blx	r3
  40181a:	f888 0000 	strb.w	r0, [r8]
					if(res != FR_OK)
  40181e:	2800      	cmp	r0, #0
  401820:	f040 80d4 	bne.w	4019cc <task_sdCardHandler+0x280>
					{
						debugPrintString("file sync failed\r\n");
					}
					vTaskDelay(1);
  401824:	2001      	movs	r0, #1
  401826:	47b8      	blx	r7
				}
			}
		
			if(debugLogFileOpen)
  401828:	f8df c1f8 	ldr.w	ip, [pc, #504]	; 401a24 <task_sdCardHandler+0x2d8>
  40182c:	f89c 3000 	ldrb.w	r3, [ip]
  401830:	b32b      	cbz	r3, 40187e <task_sdCardHandler+0x132>
			{
				if(debugNumBytesToWrite > 0)
  401832:	b325      	cbz	r5, 40187e <task_sdCardHandler+0x132>
  401834:	2600      	movs	r6, #0
				{
					debugNumBytesWritten = 0;
					while(debugNumBytesToWrite > 0)
					{
						res = f_write(&debugLogFile_Obj,  (void*)(debugLogTempBuf+debugNumBytesWritten), debugNumBytesToWrite, &debugNumBytes);
  401836:	4977      	ldr	r1, [pc, #476]	; (401a14 <task_sdCardHandler+0x2c8>)
  401838:	4870      	ldr	r0, [pc, #448]	; (4019fc <task_sdCardHandler+0x2b0>)
  40183a:	f8df c23c 	ldr.w	ip, [pc, #572]	; 401a78 <task_sdCardHandler+0x32c>
  40183e:	ab03      	add	r3, sp, #12
  401840:	4431      	add	r1, r6
  401842:	462a      	mov	r2, r5
  401844:	47e0      	blx	ip
  401846:	4603      	mov	r3, r0
  401848:	f888 3000 	strb.w	r3, [r8]
							break; 
						}					
						debugNumBytesToWrite -= debugNumBytes;
						debugNumBytesWritten += debugNumBytes;
						debugLogTotalBytesWritten += debugNumBytes;
						vTaskDelay(1);
  40184c:	2001      	movs	r0, #1
				{
					debugNumBytesWritten = 0;
					while(debugNumBytesToWrite > 0)
					{
						res = f_write(&debugLogFile_Obj,  (void*)(debugLogTempBuf+debugNumBytesWritten), debugNumBytesToWrite, &debugNumBytes);
						if (res != FR_OK)
  40184e:	2b00      	cmp	r3, #0
  401850:	f040 809b 	bne.w	40198a <task_sdCardHandler+0x23e>
								debugPrintString("Write to debug log file failed\r\n");	
							}
							//this is a serious error, break the loop. 								
							break; 
						}					
						debugNumBytesToWrite -= debugNumBytes;
  401854:	9b03      	ldr	r3, [sp, #12]
						debugNumBytesWritten += debugNumBytes;
						debugLogTotalBytesWritten += debugNumBytes;
  401856:	f8db 2000 	ldr.w	r2, [fp]
								debugPrintString("Write to debug log file failed\r\n");	
							}
							//this is a serious error, break the loop. 								
							break; 
						}					
						debugNumBytesToWrite -= debugNumBytes;
  40185a:	1aed      	subs	r5, r5, r3
						debugNumBytesWritten += debugNumBytes;
						debugLogTotalBytesWritten += debugNumBytes;
  40185c:	441a      	add	r2, r3
							}
							//this is a serious error, break the loop. 								
							break; 
						}					
						debugNumBytesToWrite -= debugNumBytes;
						debugNumBytesWritten += debugNumBytes;
  40185e:	441e      	add	r6, r3
						debugLogTotalBytesWritten += debugNumBytes;
  401860:	f8cb 2000 	str.w	r2, [fp]
						vTaskDelay(1);
  401864:	47b8      	blx	r7
			if(debugLogFileOpen)
			{
				if(debugNumBytesToWrite > 0)
				{
					debugNumBytesWritten = 0;
					while(debugNumBytesToWrite > 0)
  401866:	2d00      	cmp	r5, #0
  401868:	d1e5      	bne.n	401836 <task_sdCardHandler+0xea>
						debugNumBytesToWrite -= debugNumBytes;
						debugNumBytesWritten += debugNumBytes;
						debugLogTotalBytesWritten += debugNumBytes;
						vTaskDelay(1);
					}
					res = f_sync(&debugLogFile_Obj); //sync the file
  40186a:	4864      	ldr	r0, [pc, #400]	; (4019fc <task_sdCardHandler+0x2b0>)
  40186c:	4b68      	ldr	r3, [pc, #416]	; (401a10 <task_sdCardHandler+0x2c4>)
  40186e:	4798      	blx	r3
  401870:	f888 0000 	strb.w	r0, [r8]
					if(res != FR_OK)
  401874:	2800      	cmp	r0, #0
  401876:	f040 80a4 	bne.w	4019c2 <task_sdCardHandler+0x276>
					{
						printf("debug sync failed with code %d\r\n", res);
					}
					vTaskDelay(1);
  40187a:	2001      	movs	r0, #1
  40187c:	47b8      	blx	r7
				}
			}
			xSemaphoreGive(semaphore_fatFsAccess);
  40187e:	f8df c164 	ldr.w	ip, [pc, #356]	; 4019e4 <task_sdCardHandler+0x298>
  401882:	4e65      	ldr	r6, [pc, #404]	; (401a18 <task_sdCardHandler+0x2cc>)
  401884:	f8dc 0000 	ldr.w	r0, [ip]
  401888:	2100      	movs	r1, #0
  40188a:	460b      	mov	r3, r1
  40188c:	460a      	mov	r2, r1
  40188e:	47b0      	blx	r6
		}
		else
		{
			debugPrintString("Waiting for semaphore to write to SD-card\r\n");
		}
		if(brainSettings.debugPrintsEnabled)
  401890:	4962      	ldr	r1, [pc, #392]	; (401a1c <task_sdCardHandler+0x2d0>)
  401892:	f891 309f 	ldrb.w	r3, [r1, #159]	; 0x9f
  401896:	b9b3      	cbnz	r3, 4018c6 <task_sdCardHandler+0x17a>
  401898:	4a53      	ldr	r2, [pc, #332]	; (4019e8 <task_sdCardHandler+0x29c>)
  40189a:	6813      	ldr	r3, [r2, #0]
  40189c:	ebca 0103 	rsb	r1, sl, r3
  4018a0:	469a      	mov	sl, r3
				maxWriteTime = sgSysTickCount - writeStart; 
				debugPrintStringInt("new max write Time\r\n",maxWriteTime);
			}
		}
		//only delay if the write time was less than 200, or else we'll get a buffer error. 
		if((sgSysTickCount - writeStart) < 200)
  4018a2:	29c7      	cmp	r1, #199	; 0xc7
  4018a4:	f63f af6e 	bhi.w	401784 <task_sdCardHandler+0x38>
  4018a8:	4e4f      	ldr	r6, [pc, #316]	; (4019e8 <task_sdCardHandler+0x29c>)
		{
			vTaskDelay(100);
  4018aa:	2064      	movs	r0, #100	; 0x64
  4018ac:	47b8      	blx	r7
  4018ae:	f8d6 a000 	ldr.w	sl, [r6]
  4018b2:	e767      	b.n	401784 <task_sdCardHandler+0x38>
			}
			xSemaphoreGive(semaphore_fatFsAccess);
		}
		else
		{
			debugPrintString("Waiting for semaphore to write to SD-card\r\n");
  4018b4:	485a      	ldr	r0, [pc, #360]	; (401a20 <task_sdCardHandler+0x2d4>)
  4018b6:	f8df c184 	ldr.w	ip, [pc, #388]	; 401a3c <task_sdCardHandler+0x2f0>
  4018ba:	47e0      	blx	ip
		}
		if(brainSettings.debugPrintsEnabled)
  4018bc:	4957      	ldr	r1, [pc, #348]	; (401a1c <task_sdCardHandler+0x2d0>)
  4018be:	f891 309f 	ldrb.w	r3, [r1, #159]	; 0x9f
  4018c2:	2b00      	cmp	r3, #0
  4018c4:	d0e8      	beq.n	401898 <task_sdCardHandler+0x14c>
		{		
			if((sgSysTickCount - writeStart) > maxWriteTime)
  4018c6:	4e48      	ldr	r6, [pc, #288]	; (4019e8 <task_sdCardHandler+0x29c>)
  4018c8:	f8dd c004 	ldr.w	ip, [sp, #4]
  4018cc:	6833      	ldr	r3, [r6, #0]
  4018ce:	4632      	mov	r2, r6
  4018d0:	ebca 0603 	rsb	r6, sl, r3
  4018d4:	45b4      	cmp	ip, r6
  4018d6:	d346      	bcc.n	401966 <task_sdCardHandler+0x21a>
  4018d8:	4631      	mov	r1, r6
  4018da:	469a      	mov	sl, r3
  4018dc:	e7e1      	b.n	4018a2 <task_sdCardHandler+0x156>
		}
		
		if (debugLogFile_Obj.fsize >= DEBUG_LOG_MAX_FILE_SIZE)	//Check if the file is above its size limit
		{
			//Close the current file
			f_close(&debugLogFile_Obj);
  4018de:	4630      	mov	r0, r6
  4018e0:	f8df c148 	ldr.w	ip, [pc, #328]	; 401a2c <task_sdCardHandler+0x2e0>
  4018e4:	47e0      	blx	ip
			debugLogFileOpen = false;
  4018e6:	494f      	ldr	r1, [pc, #316]	; (401a24 <task_sdCardHandler+0x2d8>)
			//Rename and switch the file
			task_debugLog_OpenFile();
  4018e8:	4a4f      	ldr	r2, [pc, #316]	; (401a28 <task_sdCardHandler+0x2dc>)
		
		if (debugLogFile_Obj.fsize >= DEBUG_LOG_MAX_FILE_SIZE)	//Check if the file is above its size limit
		{
			//Close the current file
			f_close(&debugLogFile_Obj);
			debugLogFileOpen = false;
  4018ea:	2300      	movs	r3, #0
  4018ec:	700b      	strb	r3, [r1, #0]
			//Rename and switch the file
			task_debugLog_OpenFile();
  4018ee:	4790      	blx	r2
  4018f0:	e767      	b.n	4017c2 <task_sdCardHandler+0x76>
	{
		//take semaphore and copy data to a temporary buffer.
		writeStart = sgSysTickCount;
		if(xSemaphoreTake(semaphore_sdCardWrite,10) == true)
		{
			if(sdCardBufferPointer > 0 && sdCardBufferPointer <= SD_CARD_BUFFER_SIZE)
  4018f2:	f8df c15c 	ldr.w	ip, [pc, #348]	; 401a50 <task_sdCardHandler+0x304>
  4018f6:	f8dc 3000 	ldr.w	r3, [ip]
  4018fa:	b123      	cbz	r3, 401906 <task_sdCardHandler+0x1ba>
  4018fc:	f8dc 3000 	ldr.w	r3, [ip]
  401900:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
  401904:	d952      	bls.n	4019ac <task_sdCardHandler+0x260>
				memcpy(tempBuf,sdCardBuffer,sdCardBufferPointer);
				numBytesToWrite = sdCardBufferPointer;
				sdCardBufferPointer = 0;
			}
			
			if (debugLogBufferPointer > 0 && debugLogBufferPointer <= DEBUG_LOG_BUFFER_SIZE)
  401906:	f8df c140 	ldr.w	ip, [pc, #320]	; 401a48 <task_sdCardHandler+0x2fc>
  40190a:	f8dc 3000 	ldr.w	r3, [ip]
  40190e:	b123      	cbz	r3, 40191a <task_sdCardHandler+0x1ce>
  401910:	f8dc 3000 	ldr.w	r3, [ip]
  401914:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
  401918:	d93d      	bls.n	401996 <task_sdCardHandler+0x24a>
			{
				memcpy(debugLogTempBuf, debugLogBuffer, debugLogBufferPointer);
				debugNumBytesToWrite = debugLogBufferPointer;
				debugLogBufferPointer = 0;
			}
			xSemaphoreGive(semaphore_sdCardWrite);
  40191a:	f8df c0c4 	ldr.w	ip, [pc, #196]	; 4019e0 <task_sdCardHandler+0x294>
  40191e:	4e3e      	ldr	r6, [pc, #248]	; (401a18 <task_sdCardHandler+0x2cc>)
  401920:	f8dc 0000 	ldr.w	r0, [ip]
  401924:	2100      	movs	r1, #0
  401926:	460b      	mov	r3, r1
  401928:	460a      	mov	r2, r1
  40192a:	47b0      	blx	r6
		}
		//if the close file flag is set, close the file. 
		if(closeLogFileFlag == 1)
  40192c:	f8df c144 	ldr.w	ip, [pc, #324]	; 401a74 <task_sdCardHandler+0x328>
  401930:	f89c 3000 	ldrb.w	r3, [ip]
  401934:	2b01      	cmp	r3, #1
  401936:	4666      	mov	r6, ip
  401938:	f47f af38 	bne.w	4017ac <task_sdCardHandler+0x60>
		{
			f_close(&dataLogFile_obj); 
  40193c:	4833      	ldr	r0, [pc, #204]	; (401a0c <task_sdCardHandler+0x2c0>)
  40193e:	493b      	ldr	r1, [pc, #236]	; (401a2c <task_sdCardHandler+0x2e0>)
  401940:	4788      	blx	r1
			dataLogFileOpen = false; 
  401942:	2300      	movs	r3, #0
			//clear the flag. 
			closeLogFileFlag = 0;
  401944:	7033      	strb	r3, [r6, #0]
		}
		//if the close file flag is set, close the file. 
		if(closeLogFileFlag == 1)
		{
			f_close(&dataLogFile_obj); 
			dataLogFileOpen = false; 
  401946:	4a2f      	ldr	r2, [pc, #188]	; (401a04 <task_sdCardHandler+0x2b8>)
			//clear the flag. 
			closeLogFileFlag = 0;
		}
		if(closeDebugLogFileFlag == 1)
  401948:	4e2b      	ldr	r6, [pc, #172]	; (4019f8 <task_sdCardHandler+0x2ac>)
		}
		//if the close file flag is set, close the file. 
		if(closeLogFileFlag == 1)
		{
			f_close(&dataLogFile_obj); 
			dataLogFileOpen = false; 
  40194a:	7013      	strb	r3, [r2, #0]
			//clear the flag. 
			closeLogFileFlag = 0;
		}
		if(closeDebugLogFileFlag == 1)
  40194c:	7833      	ldrb	r3, [r6, #0]
  40194e:	2b01      	cmp	r3, #1
  401950:	f47f af31 	bne.w	4017b6 <task_sdCardHandler+0x6a>
		{
			f_close(&debugLogFile_Obj);
  401954:	4829      	ldr	r0, [pc, #164]	; (4019fc <task_sdCardHandler+0x2b0>)
  401956:	f8df c0d4 	ldr.w	ip, [pc, #212]	; 401a2c <task_sdCardHandler+0x2e0>
  40195a:	47e0      	blx	ip
			debugLogFileOpen = false;
  40195c:	4931      	ldr	r1, [pc, #196]	; (401a24 <task_sdCardHandler+0x2d8>)
  40195e:	2300      	movs	r3, #0
  401960:	700b      	strb	r3, [r1, #0]
			//clear the flag
			closeDebugLogFileFlag = 0;
  401962:	7033      	strb	r3, [r6, #0]
  401964:	e727      	b.n	4017b6 <task_sdCardHandler+0x6a>
		if(brainSettings.debugPrintsEnabled)
		{		
			if((sgSysTickCount - writeStart) > maxWriteTime)
			{
				maxWriteTime = sgSysTickCount - writeStart; 
				debugPrintStringInt("new max write Time\r\n",maxWriteTime);
  401966:	4631      	mov	r1, r6
  401968:	9200      	str	r2, [sp, #0]
  40196a:	4b31      	ldr	r3, [pc, #196]	; (401a30 <task_sdCardHandler+0x2e4>)
  40196c:	4831      	ldr	r0, [pc, #196]	; (401a34 <task_sdCardHandler+0x2e8>)
  40196e:	4798      	blx	r3
  401970:	9a00      	ldr	r2, [sp, #0]
  401972:	9601      	str	r6, [sp, #4]
  401974:	6813      	ldr	r3, [r2, #0]
  401976:	ebca 0103 	rsb	r1, sl, r3
  40197a:	469a      	mov	sl, r3
  40197c:	e791      	b.n	4018a2 <task_sdCardHandler+0x156>
					while(numBytesToWrite > 0)
					{			
						res = f_write(&dataLogFile_obj,  (void*)(tempBuf+numBytesWritten), numBytesToWrite, &numBytes);
						if (res != FR_OK)
						{								
							if(res == FR_DISK_ERR)
  40197e:	4283      	cmp	r3, r0
  401980:	d07c      	beq.n	401a7c <task_sdCardHandler+0x330>
							{
								debugPrintString("Write to log file failed: Disk Error\r\n");	
							}
							else
							{
								debugPrintString("Write to log file failed\r\n");	
  401982:	482d      	ldr	r0, [pc, #180]	; (401a38 <task_sdCardHandler+0x2ec>)
  401984:	4a2d      	ldr	r2, [pc, #180]	; (401a3c <task_sdCardHandler+0x2f0>)
  401986:	4790      	blx	r2
  401988:	e744      	b.n	401814 <task_sdCardHandler+0xc8>
					while(debugNumBytesToWrite > 0)
					{
						res = f_write(&debugLogFile_Obj,  (void*)(debugLogTempBuf+debugNumBytesWritten), debugNumBytesToWrite, &debugNumBytes);
						if (res != FR_OK)
						{								
							if(res == FR_DISK_ERR)
  40198a:	4283      	cmp	r3, r0
  40198c:	d022      	beq.n	4019d4 <task_sdCardHandler+0x288>
							{
								debugPrintString("Write to debug log file failed: Disk Error\r\n");	
							}
							else
							{
								debugPrintString("Write to debug log file failed\r\n");	
  40198e:	482c      	ldr	r0, [pc, #176]	; (401a40 <task_sdCardHandler+0x2f4>)
  401990:	4a2a      	ldr	r2, [pc, #168]	; (401a3c <task_sdCardHandler+0x2f0>)
  401992:	4790      	blx	r2
  401994:	e769      	b.n	40186a <task_sdCardHandler+0x11e>
				sdCardBufferPointer = 0;
			}
			
			if (debugLogBufferPointer > 0 && debugLogBufferPointer <= DEBUG_LOG_BUFFER_SIZE)
			{
				memcpy(debugLogTempBuf, debugLogBuffer, debugLogBufferPointer);
  401996:	4b2b      	ldr	r3, [pc, #172]	; (401a44 <task_sdCardHandler+0x2f8>)
				debugNumBytesToWrite = debugLogBufferPointer;
  401998:	4e2b      	ldr	r6, [pc, #172]	; (401a48 <task_sdCardHandler+0x2fc>)
				sdCardBufferPointer = 0;
			}
			
			if (debugLogBufferPointer > 0 && debugLogBufferPointer <= DEBUG_LOG_BUFFER_SIZE)
			{
				memcpy(debugLogTempBuf, debugLogBuffer, debugLogBufferPointer);
  40199a:	f8dc 2000 	ldr.w	r2, [ip]
  40199e:	481d      	ldr	r0, [pc, #116]	; (401a14 <task_sdCardHandler+0x2c8>)
  4019a0:	492a      	ldr	r1, [pc, #168]	; (401a4c <task_sdCardHandler+0x300>)
  4019a2:	4798      	blx	r3
				debugNumBytesToWrite = debugLogBufferPointer;
				debugLogBufferPointer = 0;
  4019a4:	2300      	movs	r3, #0
			}
			
			if (debugLogBufferPointer > 0 && debugLogBufferPointer <= DEBUG_LOG_BUFFER_SIZE)
			{
				memcpy(debugLogTempBuf, debugLogBuffer, debugLogBufferPointer);
				debugNumBytesToWrite = debugLogBufferPointer;
  4019a6:	6835      	ldr	r5, [r6, #0]
				debugLogBufferPointer = 0;
  4019a8:	6033      	str	r3, [r6, #0]
  4019aa:	e7b6      	b.n	40191a <task_sdCardHandler+0x1ce>
		writeStart = sgSysTickCount;
		if(xSemaphoreTake(semaphore_sdCardWrite,10) == true)
		{
			if(sdCardBufferPointer > 0 && sdCardBufferPointer <= SD_CARD_BUFFER_SIZE)
			{
				memcpy(tempBuf,sdCardBuffer,sdCardBufferPointer);
  4019ac:	4b25      	ldr	r3, [pc, #148]	; (401a44 <task_sdCardHandler+0x2f8>)
				numBytesToWrite = sdCardBufferPointer;
  4019ae:	4e28      	ldr	r6, [pc, #160]	; (401a50 <task_sdCardHandler+0x304>)
		writeStart = sgSysTickCount;
		if(xSemaphoreTake(semaphore_sdCardWrite,10) == true)
		{
			if(sdCardBufferPointer > 0 && sdCardBufferPointer <= SD_CARD_BUFFER_SIZE)
			{
				memcpy(tempBuf,sdCardBuffer,sdCardBufferPointer);
  4019b0:	f8dc 2000 	ldr.w	r2, [ip]
  4019b4:	4814      	ldr	r0, [pc, #80]	; (401a08 <task_sdCardHandler+0x2bc>)
  4019b6:	4927      	ldr	r1, [pc, #156]	; (401a54 <task_sdCardHandler+0x308>)
  4019b8:	4798      	blx	r3
				numBytesToWrite = sdCardBufferPointer;
				sdCardBufferPointer = 0;
  4019ba:	2300      	movs	r3, #0
		if(xSemaphoreTake(semaphore_sdCardWrite,10) == true)
		{
			if(sdCardBufferPointer > 0 && sdCardBufferPointer <= SD_CARD_BUFFER_SIZE)
			{
				memcpy(tempBuf,sdCardBuffer,sdCardBufferPointer);
				numBytesToWrite = sdCardBufferPointer;
  4019bc:	6834      	ldr	r4, [r6, #0]
				sdCardBufferPointer = 0;
  4019be:	6033      	str	r3, [r6, #0]
  4019c0:	e7a1      	b.n	401906 <task_sdCardHandler+0x1ba>
						vTaskDelay(1);
					}
					res = f_sync(&debugLogFile_Obj); //sync the file
					if(res != FR_OK)
					{
						printf("debug sync failed with code %d\r\n", res);
  4019c2:	4601      	mov	r1, r0
  4019c4:	4e24      	ldr	r6, [pc, #144]	; (401a58 <task_sdCardHandler+0x30c>)
  4019c6:	4825      	ldr	r0, [pc, #148]	; (401a5c <task_sdCardHandler+0x310>)
  4019c8:	47b0      	blx	r6
  4019ca:	e756      	b.n	40187a <task_sdCardHandler+0x12e>
						vTaskDelay(1);
					}
					res = f_sync(&dataLogFile_obj); //sync the file
					if(res != FR_OK)
					{
						debugPrintString("file sync failed\r\n");
  4019cc:	4824      	ldr	r0, [pc, #144]	; (401a60 <task_sdCardHandler+0x314>)
  4019ce:	4e1b      	ldr	r6, [pc, #108]	; (401a3c <task_sdCardHandler+0x2f0>)
  4019d0:	47b0      	blx	r6
  4019d2:	e727      	b.n	401824 <task_sdCardHandler+0xd8>
						res = f_write(&debugLogFile_Obj,  (void*)(debugLogTempBuf+debugNumBytesWritten), debugNumBytesToWrite, &debugNumBytes);
						if (res != FR_OK)
						{								
							if(res == FR_DISK_ERR)
							{
								debugPrintString("Write to debug log file failed: Disk Error\r\n");	
  4019d4:	4823      	ldr	r0, [pc, #140]	; (401a64 <task_sdCardHandler+0x318>)
  4019d6:	4919      	ldr	r1, [pc, #100]	; (401a3c <task_sdCardHandler+0x2f0>)
  4019d8:	4788      	blx	r1
  4019da:	e746      	b.n	40186a <task_sdCardHandler+0x11e>
  4019dc:	00406a89 	.word	0x00406a89
  4019e0:	20001460 	.word	0x20001460
  4019e4:	20001464 	.word	0x20001464
  4019e8:	20003970 	.word	0x20003970
  4019ec:	2000227c 	.word	0x2000227c
  4019f0:	004072ed 	.word	0x004072ed
  4019f4:	00406b35 	.word	0x00406b35
  4019f8:	20002070 	.word	0x20002070
  4019fc:	200039b8 	.word	0x200039b8
  401a00:	001e847f 	.word	0x001e847f
  401a04:	20002318 	.word	0x20002318
  401a08:	2000146c 	.word	0x2000146c
  401a0c:	20003be0 	.word	0x20003be0
  401a10:	00405bcd 	.word	0x00405bcd
  401a14:	20002f1c 	.word	0x20002f1c
  401a18:	00406979 	.word	0x00406979
  401a1c:	200001ac 	.word	0x200001ac
  401a20:	00415948 	.word	0x00415948
  401a24:	20002078 	.word	0x20002078
  401a28:	00401665 	.word	0x00401665
  401a2c:	00405c85 	.word	0x00405c85
  401a30:	004007b5 	.word	0x004007b5
  401a34:	00415974 	.word	0x00415974
  401a38:	004158a0 	.word	0x004158a0
  401a3c:	004008c9 	.word	0x004008c9
  401a40:	00415900 	.word	0x00415900
  401a44:	0040c129 	.word	0x0040c129
  401a48:	2000311c 	.word	0x2000311c
  401a4c:	2000207c 	.word	0x2000207c
  401a50:	20002074 	.word	0x20002074
  401a54:	2000231c 	.word	0x2000231c
  401a58:	0040bba9 	.word	0x0040bba9
  401a5c:	00415924 	.word	0x00415924
  401a60:	004158bc 	.word	0x004158bc
  401a64:	004158d0 	.word	0x004158d0
  401a68:	2000145c 	.word	0x2000145c
  401a6c:	2000206c 	.word	0x2000206c
  401a70:	20002314 	.word	0x20002314
  401a74:	20001468 	.word	0x20001468
  401a78:	004059ed 	.word	0x004059ed
						res = f_write(&dataLogFile_obj,  (void*)(tempBuf+numBytesWritten), numBytesToWrite, &numBytes);
						if (res != FR_OK)
						{								
							if(res == FR_DISK_ERR)
							{
								debugPrintString("Write to log file failed: Disk Error\r\n");	
  401a7c:	4801      	ldr	r0, [pc, #4]	; (401a84 <task_sdCardHandler+0x338>)
  401a7e:	4902      	ldr	r1, [pc, #8]	; (401a88 <task_sdCardHandler+0x33c>)
  401a80:	4788      	blx	r1
  401a82:	e6c7      	b.n	401814 <task_sdCardHandler+0xc8>
  401a84:	00415878 	.word	0x00415878
  401a88:	004008c9 	.word	0x004008c9

00401a8c <vSdTimeOutTimerCallback>:
	}
}

void vSdTimeOutTimerCallback( xTimerHandle xTimer )
{
	sdInsertWaitTimeoutFlag = TRUE;
  401a8c:	4b01      	ldr	r3, [pc, #4]	; (401a94 <vSdTimeOutTimerCallback+0x8>)
  401a8e:	2201      	movs	r2, #1
  401a90:	701a      	strb	r2, [r3, #0]
  401a92:	4770      	bx	lr
  401a94:	20003370 	.word	0x20003370

00401a98 <task_stateMachine_EnqueueEvent>:
		vTaskDelay(50); 	
	}		
}

status_t task_stateMachine_EnqueueEvent(systemEvents_t eventType, uint16_t data)
{
  401a98:	b510      	push	{r4, lr}
  401a9a:	4603      	mov	r3, r0
	status_t status = STATUS_PASS; 
	eventMessage_t msg; 
	msg.sysEvent = eventType; 
	msg.data = data; 
	debugPrintString(systemEventNameString[eventType]);
  401a9c:	480b      	ldr	r0, [pc, #44]	; (401acc <task_stateMachine_EnqueueEvent+0x34>)
  401a9e:	4a0c      	ldr	r2, [pc, #48]	; (401ad0 <task_stateMachine_EnqueueEvent+0x38>)
  401aa0:	f850 0023 	ldr.w	r0, [r0, r3, lsl #2]
		vTaskDelay(50); 	
	}		
}

status_t task_stateMachine_EnqueueEvent(systemEvents_t eventType, uint16_t data)
{
  401aa4:	b082      	sub	sp, #8
	status_t status = STATUS_PASS; 
	eventMessage_t msg; 
	msg.sysEvent = eventType; 
  401aa6:	f88d 3004 	strb.w	r3, [sp, #4]
	msg.data = data; 
  401aaa:	f8ad 1006 	strh.w	r1, [sp, #6]
	debugPrintString(systemEventNameString[eventType]);
  401aae:	4790      	blx	r2
	if(queue_stateMachineEvents != NULL)
  401ab0:	4b08      	ldr	r3, [pc, #32]	; (401ad4 <task_stateMachine_EnqueueEvent+0x3c>)
  401ab2:	6818      	ldr	r0, [r3, #0]
  401ab4:	b140      	cbz	r0, 401ac8 <task_stateMachine_EnqueueEvent+0x30>
	{
		if(xQueueSendToBack( queue_stateMachineEvents,( void * ) &msg,5) != TRUE)
  401ab6:	a901      	add	r1, sp, #4
  401ab8:	2205      	movs	r2, #5
  401aba:	2300      	movs	r3, #0
  401abc:	4c06      	ldr	r4, [pc, #24]	; (401ad8 <task_stateMachine_EnqueueEvent+0x40>)
  401abe:	47a0      	blx	r4
	}		
}

status_t task_stateMachine_EnqueueEvent(systemEvents_t eventType, uint16_t data)
{
	status_t status = STATUS_PASS; 
  401ac0:	f110 30ff 	adds.w	r0, r0, #4294967295
  401ac4:	bf18      	it	ne
  401ac6:	2001      	movne	r0, #1
		{
			status = STATUS_FAIL; 
		}
	}
	return status; 
}
  401ac8:	b002      	add	sp, #8
  401aca:	bd10      	pop	{r4, pc}
  401acc:	200000b8 	.word	0x200000b8
  401ad0:	004008c9 	.word	0x004008c9
  401ad4:	20003374 	.word	0x20003374
  401ad8:	00406979 	.word	0x00406979

00401adc <vTimeOutTimerCallback>:

xTimerHandle TimeOutTimer = NULL, sdTimeOutTimer = NULL;
volatile bool sdInsertWaitTimeoutFlag = FALSE;

void vTimeOutTimerCallback( xTimerHandle xTimer )
{
  401adc:	b508      	push	{r3, lr}
	//if auto off is enabled. 
	if(brainSettings.autoTurnOff)
  401ade:	4b04      	ldr	r3, [pc, #16]	; (401af0 <vTimeOutTimerCallback+0x14>)
  401ae0:	f893 309e 	ldrb.w	r3, [r3, #158]	; 0x9e
  401ae4:	b11b      	cbz	r3, 401aee <vTimeOutTimerCallback+0x12>
	{
		#ifdef USES_NEW_POWER_BOARD 
		//if we use the new power board, set the PB_GPIO low to indicate that we need to power down
		drv_gpio_setPinState(DRV_GPIO_PIN_PB_GPIO, DRV_GPIO_PIN_STATE_LOW); 
		#else
		 task_stateMachine_EnqueueEvent(SYS_EVENT_POWER_SWITCH, 0x00);
  401ae6:	2000      	movs	r0, #0
  401ae8:	4601      	mov	r1, r0
  401aea:	4b02      	ldr	r3, [pc, #8]	; (401af4 <vTimeOutTimerCallback+0x18>)
  401aec:	4798      	blx	r3
  401aee:	bd08      	pop	{r3, pc}
  401af0:	200001ac 	.word	0x200001ac
  401af4:	00401a99 	.word	0x00401a99

00401af8 <CheckInitQuintic>:
 * @brief This creates quintic initializing task for the next  quintic
 * @param void
 * @return void
 ***********************************************************************************************/
static void CheckInitQuintic()
{
  401af8:	b570      	push	{r4, r5, r6, lr}
	switch(QResetCount)
  401afa:	4c3f      	ldr	r4, [pc, #252]	; (401bf8 <CheckInitQuintic+0x100>)
  401afc:	7823      	ldrb	r3, [r4, #0]
  401afe:	2b01      	cmp	r3, #1
 * @brief This creates quintic initializing task for the next  quintic
 * @param void
 * @return void
 ***********************************************************************************************/
static void CheckInitQuintic()
{
  401b00:	b084      	sub	sp, #16
	switch(QResetCount)
  401b02:	d044      	beq.n	401b8e <CheckInitQuintic+0x96>
  401b04:	d322      	bcc.n	401b4c <CheckInitQuintic+0x54>
  401b06:	2b02      	cmp	r3, #2
  401b08:	d13f      	bne.n	401b8a <CheckInitQuintic+0x92>
				task_stateMachine_EnqueueEvent(SYS_EVENT_RESET_COMPLETE, 0xff);
			}
			QResetCount = 2;	//the init task has been spawned, move to next quintic.
		break;
		case 2:
			if ((quinticConfig[2].isinit) && (quinticConfig[2].expectedNumberOfNods > 0))
  401b0a:	4b3c      	ldr	r3, [pc, #240]	; (401bfc <CheckInitQuintic+0x104>)
  401b0c:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
  401b10:	2a00      	cmp	r2, #0
  401b12:	d068      	beq.n	401be6 <CheckInitQuintic+0xee>
  401b14:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
  401b18:	2a00      	cmp	r2, #0
  401b1a:	dd64      	ble.n	401be6 <CheckInitQuintic+0xee>
			{
				int retCode = xTaskCreate(task_quintic_initializeImus, "Qi", TASK_IMU_INIT_STACK_SIZE, (void*)&quinticConfig[2], TASK_IMU_INIT_PRIORITY, &ResetHandle );
  401b1c:	2107      	movs	r1, #7
  401b1e:	4a38      	ldr	r2, [pc, #224]	; (401c00 <CheckInitQuintic+0x108>)
  401b20:	9100      	str	r1, [sp, #0]
  401b22:	2500      	movs	r5, #0
  401b24:	9201      	str	r2, [sp, #4]
  401b26:	3378      	adds	r3, #120	; 0x78
  401b28:	9502      	str	r5, [sp, #8]
  401b2a:	9503      	str	r5, [sp, #12]
  401b2c:	4835      	ldr	r0, [pc, #212]	; (401c04 <CheckInitQuintic+0x10c>)
  401b2e:	4936      	ldr	r1, [pc, #216]	; (401c08 <CheckInitQuintic+0x110>)
  401b30:	4e36      	ldr	r6, [pc, #216]	; (401c0c <CheckInitQuintic+0x114>)
  401b32:	f44f 7280 	mov.w	r2, #256	; 0x100
  401b36:	47b0      	blx	r6
				if (retCode != pdPASS)
  401b38:	2801      	cmp	r0, #1
  401b3a:	d058      	beq.n	401bee <CheckInitQuintic+0xf6>
				{
					debugPrintString("Failed to create Q2 init task \r\n");
  401b3c:	4834      	ldr	r0, [pc, #208]	; (401c10 <CheckInitQuintic+0x118>)
  401b3e:	4b35      	ldr	r3, [pc, #212]	; (401c14 <CheckInitQuintic+0x11c>)
  401b40:	4798      	blx	r3
					task_stateMachine_EnqueueEvent(SYS_EVENT_RESET_FAILED, 0x00);
  401b42:	4629      	mov	r1, r5
  401b44:	4b34      	ldr	r3, [pc, #208]	; (401c18 <CheckInitQuintic+0x120>)
  401b46:	200b      	movs	r0, #11
  401b48:	4798      	blx	r3
  401b4a:	e050      	b.n	401bee <CheckInitQuintic+0xf6>
{
	switch(QResetCount)
	{
		//Check if the specific Quintic task is spawned and any IMUs are assigned to it.
		case 0:
			if((quinticConfig[0].isinit) && (quinticConfig[0].expectedNumberOfNods > 0))
  401b4c:	4b2b      	ldr	r3, [pc, #172]	; (401bfc <CheckInitQuintic+0x104>)
  401b4e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  401b50:	2a00      	cmp	r2, #0
  401b52:	d043      	beq.n	401bdc <CheckInitQuintic+0xe4>
  401b54:	699a      	ldr	r2, [r3, #24]
  401b56:	2a00      	cmp	r2, #0
  401b58:	dd40      	ble.n	401bdc <CheckInitQuintic+0xe4>
			{
				//status |= task_quintic_initializeImus(&quinticConfig[i]);
				int retCode = xTaskCreate(task_quintic_initializeImus, "Qi", TASK_IMU_INIT_STACK_SIZE, (void*)&quinticConfig[0], TASK_IMU_INIT_PRIORITY, &ResetHandle );
  401b5a:	2107      	movs	r1, #7
  401b5c:	4a28      	ldr	r2, [pc, #160]	; (401c00 <CheckInitQuintic+0x108>)
  401b5e:	9100      	str	r1, [sp, #0]
  401b60:	2500      	movs	r5, #0
  401b62:	9201      	str	r2, [sp, #4]
  401b64:	9502      	str	r5, [sp, #8]
  401b66:	9503      	str	r5, [sp, #12]
  401b68:	4826      	ldr	r0, [pc, #152]	; (401c04 <CheckInitQuintic+0x10c>)
  401b6a:	4927      	ldr	r1, [pc, #156]	; (401c08 <CheckInitQuintic+0x110>)
  401b6c:	4e27      	ldr	r6, [pc, #156]	; (401c0c <CheckInitQuintic+0x114>)
  401b6e:	f44f 7280 	mov.w	r2, #256	; 0x100
  401b72:	47b0      	blx	r6
				if (retCode != pdPASS)
  401b74:	2801      	cmp	r0, #1
  401b76:	d006      	beq.n	401b86 <CheckInitQuintic+0x8e>
				{
					debugPrintString("Failed to create Q0 init task \r\n");
  401b78:	4828      	ldr	r0, [pc, #160]	; (401c1c <CheckInitQuintic+0x124>)
  401b7a:	4b26      	ldr	r3, [pc, #152]	; (401c14 <CheckInitQuintic+0x11c>)
  401b7c:	4798      	blx	r3
					task_stateMachine_EnqueueEvent(SYS_EVENT_RESET_FAILED, 0x00);
  401b7e:	4629      	mov	r1, r5
  401b80:	200b      	movs	r0, #11
  401b82:	4b25      	ldr	r3, [pc, #148]	; (401c18 <CheckInitQuintic+0x120>)
  401b84:	4798      	blx	r3
			else
			{
				//the quintic is absent in the settings file, send an event 
				task_stateMachine_EnqueueEvent(SYS_EVENT_RESET_COMPLETE, 0xff);
			}
			QResetCount = 1;	//the init task has been spawned, move to next quintic.
  401b86:	2301      	movs	r3, #1
  401b88:	7023      	strb	r3, [r4, #0]
		default:
		// do nothing, should never reach here.
		break;
	}

}
  401b8a:	b004      	add	sp, #16
  401b8c:	bd70      	pop	{r4, r5, r6, pc}
				task_stateMachine_EnqueueEvent(SYS_EVENT_RESET_COMPLETE, 0xff);
			}
			QResetCount = 1;	//the init task has been spawned, move to next quintic.
		break;
		case 1:
			if ((quinticConfig[1].isinit) && (quinticConfig[1].expectedNumberOfNods > 0))
  401b8e:	4b1b      	ldr	r3, [pc, #108]	; (401bfc <CheckInitQuintic+0x104>)
  401b90:	6e1a      	ldr	r2, [r3, #96]	; 0x60
  401b92:	b1f2      	cbz	r2, 401bd2 <CheckInitQuintic+0xda>
  401b94:	6d5a      	ldr	r2, [r3, #84]	; 0x54
  401b96:	2a00      	cmp	r2, #0
  401b98:	dd1b      	ble.n	401bd2 <CheckInitQuintic+0xda>
			{
				int retCode = xTaskCreate(task_quintic_initializeImus, "Qi", TASK_IMU_INIT_STACK_SIZE, (void*)&quinticConfig[1], TASK_IMU_INIT_PRIORITY, &ResetHandle );
  401b9a:	2107      	movs	r1, #7
  401b9c:	4a18      	ldr	r2, [pc, #96]	; (401c00 <CheckInitQuintic+0x108>)
  401b9e:	9100      	str	r1, [sp, #0]
  401ba0:	2500      	movs	r5, #0
  401ba2:	9201      	str	r2, [sp, #4]
  401ba4:	333c      	adds	r3, #60	; 0x3c
  401ba6:	9502      	str	r5, [sp, #8]
  401ba8:	9503      	str	r5, [sp, #12]
  401baa:	4816      	ldr	r0, [pc, #88]	; (401c04 <CheckInitQuintic+0x10c>)
  401bac:	4916      	ldr	r1, [pc, #88]	; (401c08 <CheckInitQuintic+0x110>)
  401bae:	4e17      	ldr	r6, [pc, #92]	; (401c0c <CheckInitQuintic+0x114>)
  401bb0:	f44f 7280 	mov.w	r2, #256	; 0x100
  401bb4:	47b0      	blx	r6
				if (retCode != pdPASS)
  401bb6:	2801      	cmp	r0, #1
  401bb8:	d007      	beq.n	401bca <CheckInitQuintic+0xd2>
				{
					debugPrintStringInt("Failed to create Q1 init task \r\n", retCode);
  401bba:	4601      	mov	r1, r0
  401bbc:	4b18      	ldr	r3, [pc, #96]	; (401c20 <CheckInitQuintic+0x128>)
  401bbe:	4819      	ldr	r0, [pc, #100]	; (401c24 <CheckInitQuintic+0x12c>)
  401bc0:	4798      	blx	r3
					task_stateMachine_EnqueueEvent(SYS_EVENT_RESET_FAILED, 0x00);
  401bc2:	4629      	mov	r1, r5
  401bc4:	200b      	movs	r0, #11
  401bc6:	4b14      	ldr	r3, [pc, #80]	; (401c18 <CheckInitQuintic+0x120>)
  401bc8:	4798      	blx	r3
			else
			{
				//the quintic is absent in the settings file, send an event
				task_stateMachine_EnqueueEvent(SYS_EVENT_RESET_COMPLETE, 0xff);
			}
			QResetCount = 2;	//the init task has been spawned, move to next quintic.
  401bca:	2302      	movs	r3, #2
  401bcc:	7023      	strb	r3, [r4, #0]
		default:
		// do nothing, should never reach here.
		break;
	}

}
  401bce:	b004      	add	sp, #16
  401bd0:	bd70      	pop	{r4, r5, r6, pc}
				}
			}
			else
			{
				//the quintic is absent in the settings file, send an event
				task_stateMachine_EnqueueEvent(SYS_EVENT_RESET_COMPLETE, 0xff);
  401bd2:	21ff      	movs	r1, #255	; 0xff
  401bd4:	4b10      	ldr	r3, [pc, #64]	; (401c18 <CheckInitQuintic+0x120>)
  401bd6:	200a      	movs	r0, #10
  401bd8:	4798      	blx	r3
  401bda:	e7f6      	b.n	401bca <CheckInitQuintic+0xd2>
				}
			}
			else
			{
				//the quintic is absent in the settings file, send an event 
				task_stateMachine_EnqueueEvent(SYS_EVENT_RESET_COMPLETE, 0xff);
  401bdc:	21ff      	movs	r1, #255	; 0xff
  401bde:	4b0e      	ldr	r3, [pc, #56]	; (401c18 <CheckInitQuintic+0x120>)
  401be0:	200a      	movs	r0, #10
  401be2:	4798      	blx	r3
  401be4:	e7cf      	b.n	401b86 <CheckInitQuintic+0x8e>
				}
			}
			else
			{
				//the quintic is absent in the settings file, send an event
				task_stateMachine_EnqueueEvent(SYS_EVENT_RESET_COMPLETE, 0xff);
  401be6:	200a      	movs	r0, #10
  401be8:	21ff      	movs	r1, #255	; 0xff
  401bea:	4b0b      	ldr	r3, [pc, #44]	; (401c18 <CheckInitQuintic+0x120>)
  401bec:	4798      	blx	r3
			}
			QResetCount = 3;	//the init task has been spawned, move to next quintic.
  401bee:	2303      	movs	r3, #3
  401bf0:	7023      	strb	r3, [r4, #0]
		default:
		// do nothing, should never reach here.
		break;
	}

}
  401bf2:	b004      	add	sp, #16
  401bf4:	bd70      	pop	{r4, r5, r6, pc}
  401bf6:	bf00      	nop
  401bf8:	2000336a 	.word	0x2000336a
  401bfc:	20000264 	.word	0x20000264
  401c00:	20003378 	.word	0x20003378
  401c04:	0040a801 	.word	0x0040a801
  401c08:	00415a94 	.word	0x00415a94
  401c0c:	00406dcd 	.word	0x00406dcd
  401c10:	00415ae0 	.word	0x00415ae0
  401c14:	004008c9 	.word	0x004008c9
  401c18:	00401a99 	.word	0x00401a99
  401c1c:	00415a98 	.word	0x00415a98
  401c20:	004007b5 	.word	0x004007b5
  401c24:	00415abc 	.word	0x00415abc

00401c28 <getCurrentState>:
	}
	return status; 
}
systemStates_t getCurrentState()
{
	return currentSystemState;
  401c28:	4b01      	ldr	r3, [pc, #4]	; (401c30 <getCurrentState+0x8>)
}
  401c2a:	7818      	ldrb	r0, [r3, #0]
  401c2c:	4770      	bx	lr
  401c2e:	bf00      	nop
  401c30:	2000336b 	.word	0x2000336b

00401c34 <stateEntry_Reset>:
 * @param void
 * @return void
 ***********************************************************************************************/
//reset entry
void stateEntry_Reset()
{
  401c34:	b538      	push	{r3, r4, r5, lr}
 * @return void
 ***********************************************************************************************/
static void setCurrentSystemState(systemStates_t state)
{
	currentSystemState = state; 
	debugPrintString(systemStateNameString[currentSystemState]);	
  401c36:	4a0e      	ldr	r2, [pc, #56]	; (401c70 <stateEntry_Reset+0x3c>)
 ***********************************************************************************************/
//reset entry
void stateEntry_Reset()
{
	status_t status = STATUS_PASS; 
	ResetStatus = 0;
  401c38:	490e      	ldr	r1, [pc, #56]	; (401c74 <stateEntry_Reset+0x40>)
 * @param systemStates_t state
 * @return void
 ***********************************************************************************************/
static void setCurrentSystemState(systemStates_t state)
{
	currentSystemState = state; 
  401c3a:	4b0f      	ldr	r3, [pc, #60]	; (401c78 <stateEntry_Reset+0x44>)
	debugPrintString(systemStateNameString[currentSystemState]);	
  401c3c:	6890      	ldr	r0, [r2, #8]
  401c3e:	4d0f      	ldr	r5, [pc, #60]	; (401c7c <stateEntry_Reset+0x48>)
 * @param systemStates_t state
 * @return void
 ***********************************************************************************************/
static void setCurrentSystemState(systemStates_t state)
{
	currentSystemState = state; 
  401c40:	2202      	movs	r2, #2
 ***********************************************************************************************/
//reset entry
void stateEntry_Reset()
{
	status_t status = STATUS_PASS; 
	ResetStatus = 0;
  401c42:	2400      	movs	r4, #0
 * @param systemStates_t state
 * @return void
 ***********************************************************************************************/
static void setCurrentSystemState(systemStates_t state)
{
	currentSystemState = state; 
  401c44:	701a      	strb	r2, [r3, #0]
 ***********************************************************************************************/
//reset entry
void stateEntry_Reset()
{
	status_t status = STATUS_PASS; 
	ResetStatus = 0;
  401c46:	700c      	strb	r4, [r1, #0]
 * @return void
 ***********************************************************************************************/
static void setCurrentSystemState(systemStates_t state)
{
	currentSystemState = state; 
	debugPrintString(systemStateNameString[currentSystemState]);	
  401c48:	47a8      	blx	r5
	ResetStatus = 0;
	eventMessage_t msg = {.sysEvent = SYS_EVENT_RESET_COMPLETE, .data = 0};
	//set current state to reset.
	setCurrentSystemState(SYS_STATE_RESET);
	//set LED to blue
	drv_led_set(DRV_LED_BLUE, DRV_LED_FLASH);
  401c4a:	4621      	mov	r1, r4
  401c4c:	4b0c      	ldr	r3, [pc, #48]	; (401c80 <stateEntry_Reset+0x4c>)
  401c4e:	2001      	movs	r0, #1
  401c50:	4798      	blx	r3
	QResetCount = 0;
  401c52:	4a0c      	ldr	r2, [pc, #48]	; (401c84 <stateEntry_Reset+0x50>)
	toggleJackEnables(DRV_GPIO_PIN_STATE_LOW);
	vTaskDelay(100); 
	#endif
	
	//Reset/init Qn
	CheckInitQuintic();
  401c54:	4b0c      	ldr	r3, [pc, #48]	; (401c88 <stateEntry_Reset+0x54>)
	eventMessage_t msg = {.sysEvent = SYS_EVENT_RESET_COMPLETE, .data = 0};
	//set current state to reset.
	setCurrentSystemState(SYS_STATE_RESET);
	//set LED to blue
	drv_led_set(DRV_LED_BLUE, DRV_LED_FLASH);
	QResetCount = 0;
  401c56:	7014      	strb	r4, [r2, #0]
	toggleJackEnables(DRV_GPIO_PIN_STATE_LOW);
	vTaskDelay(100); 
	#endif
	
	//Reset/init Qn
	CheckInitQuintic();
  401c58:	4798      	blx	r3
	
	//initialize fabric sense module
	status |= task_fabSense_init(&fsConfig); 
  401c5a:	480c      	ldr	r0, [pc, #48]	; (401c8c <stateEntry_Reset+0x58>)
  401c5c:	4b0c      	ldr	r3, [pc, #48]	; (401c90 <stateEntry_Reset+0x5c>)
  401c5e:	4798      	blx	r3
	if(status != STATUS_PASS)
  401c60:	b128      	cbz	r0, 401c6e <stateEntry_Reset+0x3a>
	{
		debugPrintString("FabSense initialization failed\r\n");
  401c62:	480c      	ldr	r0, [pc, #48]	; (401c94 <stateEntry_Reset+0x60>)
  401c64:	47a8      	blx	r5
		task_stateMachine_EnqueueEvent(SYS_EVENT_RESET_FAILED, 0x00);  		
  401c66:	4621      	mov	r1, r4
  401c68:	200b      	movs	r0, #11
  401c6a:	4b0b      	ldr	r3, [pc, #44]	; (401c98 <stateEntry_Reset+0x64>)
  401c6c:	4798      	blx	r3
  401c6e:	bd38      	pop	{r3, r4, r5, pc}
  401c70:	200000f0 	.word	0x200000f0
  401c74:	20003371 	.word	0x20003371
  401c78:	2000336b 	.word	0x2000336b
  401c7c:	004008c9 	.word	0x004008c9
  401c80:	00400699 	.word	0x00400699
  401c84:	2000336a 	.word	0x2000336a
  401c88:	00401af9 	.word	0x00401af9
  401c8c:	200001a0 	.word	0x200001a0
  401c90:	00409a41 	.word	0x00409a41
  401c94:	00415b04 	.word	0x00415b04
  401c98:	00401a99 	.word	0x00401a99

00401c9c <stateEntry_Recording>:
 * @param void
 * @return void
 ***********************************************************************************************/
//recording entry
void stateEntry_Recording()
{
  401c9c:	b538      	push	{r3, r4, r5, lr}
 * @return void
 ***********************************************************************************************/
static void setCurrentSystemState(systemStates_t state)
{
	currentSystemState = state; 
	debugPrintString(systemStateNameString[currentSystemState]);	
  401c9e:	4b0b      	ldr	r3, [pc, #44]	; (401ccc <stateEntry_Recording+0x30>)
 * @param systemStates_t state
 * @return void
 ***********************************************************************************************/
static void setCurrentSystemState(systemStates_t state)
{
	currentSystemState = state; 
  401ca0:	4a0b      	ldr	r2, [pc, #44]	; (401cd0 <stateEntry_Recording+0x34>)
	debugPrintString(systemStateNameString[currentSystemState]);	
  401ca2:	6918      	ldr	r0, [r3, #16]
{
	status_t status;
	setCurrentSystemState(SYS_STATE_RECORDING);
	task_dataProcessor_startRecording();
	//send start command to quintics and fabric sense
	task_quintic_startRecording(&quinticConfig[0]);
  401ca4:	4d0b      	ldr	r5, [pc, #44]	; (401cd4 <stateEntry_Recording+0x38>)
 * @return void
 ***********************************************************************************************/
static void setCurrentSystemState(systemStates_t state)
{
	currentSystemState = state; 
	debugPrintString(systemStateNameString[currentSystemState]);	
  401ca6:	4b0c      	ldr	r3, [pc, #48]	; (401cd8 <stateEntry_Recording+0x3c>)
{
	status_t status;
	setCurrentSystemState(SYS_STATE_RECORDING);
	task_dataProcessor_startRecording();
	//send start command to quintics and fabric sense
	task_quintic_startRecording(&quinticConfig[0]);
  401ca8:	4c0c      	ldr	r4, [pc, #48]	; (401cdc <stateEntry_Recording+0x40>)
 * @param systemStates_t state
 * @return void
 ***********************************************************************************************/
static void setCurrentSystemState(systemStates_t state)
{
	currentSystemState = state; 
  401caa:	2104      	movs	r1, #4
  401cac:	7011      	strb	r1, [r2, #0]
	debugPrintString(systemStateNameString[currentSystemState]);	
  401cae:	4798      	blx	r3
//recording entry
void stateEntry_Recording()
{
	status_t status;
	setCurrentSystemState(SYS_STATE_RECORDING);
	task_dataProcessor_startRecording();
  401cb0:	4b0b      	ldr	r3, [pc, #44]	; (401ce0 <stateEntry_Recording+0x44>)
  401cb2:	4798      	blx	r3
	//send start command to quintics and fabric sense
	task_quintic_startRecording(&quinticConfig[0]);
  401cb4:	4628      	mov	r0, r5
  401cb6:	47a0      	blx	r4
	task_quintic_startRecording(&quinticConfig[1]);
  401cb8:	f105 003c 	add.w	r0, r5, #60	; 0x3c
  401cbc:	47a0      	blx	r4
	task_quintic_startRecording(&quinticConfig[2]);
  401cbe:	f105 0078 	add.w	r0, r5, #120	; 0x78
  401cc2:	47a0      	blx	r4
	task_fabSense_start(&fsConfig);				
  401cc4:	4b07      	ldr	r3, [pc, #28]	; (401ce4 <stateEntry_Recording+0x48>)
  401cc6:	4808      	ldr	r0, [pc, #32]	; (401ce8 <stateEntry_Recording+0x4c>)
  401cc8:	4798      	blx	r3
  401cca:	bd38      	pop	{r3, r4, r5, pc}
  401ccc:	200000f0 	.word	0x200000f0
  401cd0:	2000336b 	.word	0x2000336b
  401cd4:	20000264 	.word	0x20000264
  401cd8:	004008c9 	.word	0x004008c9
  401cdc:	0040ab45 	.word	0x0040ab45
  401ce0:	004098e5 	.word	0x004098e5
  401ce4:	00409a45 	.word	0x00409a45
  401ce8:	200001a0 	.word	0x200001a0

00401cec <stateExit_Recording>:
 * @param void
 * @return void
 ***********************************************************************************************/
//recording exit
void stateExit_Recording()
{
  401cec:	b538      	push	{r3, r4, r5, lr}
	//send stop command to quintics and fabric sense
	task_quintic_stopRecording(&quinticConfig[0]);
  401cee:	4d09      	ldr	r5, [pc, #36]	; (401d14 <stateExit_Recording+0x28>)
  401cf0:	4c09      	ldr	r4, [pc, #36]	; (401d18 <stateExit_Recording+0x2c>)
  401cf2:	4628      	mov	r0, r5
  401cf4:	47a0      	blx	r4
	task_quintic_stopRecording(&quinticConfig[1]);
  401cf6:	f105 003c 	add.w	r0, r5, #60	; 0x3c
  401cfa:	47a0      	blx	r4
	task_quintic_stopRecording(&quinticConfig[2]);
  401cfc:	f105 0078 	add.w	r0, r5, #120	; 0x78
  401d00:	47a0      	blx	r4
	task_fabSense_stop(&fsConfig);	
  401d02:	4b06      	ldr	r3, [pc, #24]	; (401d1c <stateExit_Recording+0x30>)
  401d04:	4806      	ldr	r0, [pc, #24]	; (401d20 <stateExit_Recording+0x34>)
  401d06:	4798      	blx	r3
	//wait for a bit for the data to be processed.
	vTaskDelay(100);
  401d08:	4b06      	ldr	r3, [pc, #24]	; (401d24 <stateExit_Recording+0x38>)
  401d0a:	2064      	movs	r0, #100	; 0x64
  401d0c:	4798      	blx	r3
	//close the data file for the current recording
	task_sdCard_CloseFile();	
  401d0e:	4b06      	ldr	r3, [pc, #24]	; (401d28 <stateExit_Recording+0x3c>)
  401d10:	4798      	blx	r3
  401d12:	bd38      	pop	{r3, r4, r5, pc}
  401d14:	20000264 	.word	0x20000264
  401d18:	0040ab65 	.word	0x0040ab65
  401d1c:	00409a61 	.word	0x00409a61
  401d20:	200001a0 	.word	0x200001a0
  401d24:	004072ed 	.word	0x004072ed
  401d28:	00401579 	.word	0x00401579

00401d2c <stateEntry_Idle>:
 * @param void
 * @return void
 ***********************************************************************************************/
//idle entry
void stateEntry_Idle()
{
  401d2c:	b510      	push	{r4, lr}
 * @return void
 ***********************************************************************************************/
static void setCurrentSystemState(systemStates_t state)
{
	currentSystemState = state; 
	debugPrintString(systemStateNameString[currentSystemState]);	
  401d2e:	4b0c      	ldr	r3, [pc, #48]	; (401d60 <stateEntry_Idle+0x34>)
 * @param systemStates_t state
 * @return void
 ***********************************************************************************************/
static void setCurrentSystemState(systemStates_t state)
{
	currentSystemState = state; 
  401d30:	4a0c      	ldr	r2, [pc, #48]	; (401d64 <stateEntry_Idle+0x38>)
	debugPrintString(systemStateNameString[currentSystemState]);	
  401d32:	68d8      	ldr	r0, [r3, #12]
  401d34:	4b0c      	ldr	r3, [pc, #48]	; (401d68 <stateEntry_Idle+0x3c>)
 * @param void
 * @return void
 ***********************************************************************************************/
//idle entry
void stateEntry_Idle()
{
  401d36:	b082      	sub	sp, #8
 * @param systemStates_t state
 * @return void
 ***********************************************************************************************/
static void setCurrentSystemState(systemStates_t state)
{
	currentSystemState = state; 
  401d38:	2103      	movs	r1, #3
  401d3a:	7011      	strb	r1, [r2, #0]
	debugPrintString(systemStateNameString[currentSystemState]);	
  401d3c:	4798      	blx	r3
 ***********************************************************************************************/
//idle entry
void stateEntry_Idle()
{
	setCurrentSystemState(SYS_STATE_IDLE);
	xTimerReset(TimeOutTimer, 0); 
  401d3e:	4a0b      	ldr	r2, [pc, #44]	; (401d6c <stateEntry_Idle+0x40>)
  401d40:	4b0b      	ldr	r3, [pc, #44]	; (401d70 <stateEntry_Idle+0x44>)
  401d42:	6814      	ldr	r4, [r2, #0]
  401d44:	4798      	blx	r3
  401d46:	2300      	movs	r3, #0
  401d48:	4602      	mov	r2, r0
  401d4a:	4619      	mov	r1, r3
  401d4c:	9300      	str	r3, [sp, #0]
  401d4e:	4620      	mov	r0, r4
  401d50:	4c08      	ldr	r4, [pc, #32]	; (401d74 <stateEntry_Idle+0x48>)
  401d52:	47a0      	blx	r4
	drv_led_set(DRV_LED_GREEN, DRV_LED_SOLID);
  401d54:	2101      	movs	r1, #1
  401d56:	4b08      	ldr	r3, [pc, #32]	; (401d78 <stateEntry_Idle+0x4c>)
  401d58:	2002      	movs	r0, #2
  401d5a:	4798      	blx	r3
}
  401d5c:	b002      	add	sp, #8
  401d5e:	bd10      	pop	{r4, pc}
  401d60:	200000f0 	.word	0x200000f0
  401d64:	2000336b 	.word	0x2000336b
  401d68:	004008c9 	.word	0x004008c9
  401d6c:	2000336c 	.word	0x2000336c
  401d70:	004070a1 	.word	0x004070a1
  401d74:	00407949 	.word	0x00407949
  401d78:	00400699 	.word	0x00400699

00401d7c <stateExit_Idle>:
 * @param void
 * @return void
 ***********************************************************************************************/
//idle exit
void stateExit_Idle()
{
  401d7c:	b510      	push	{r4, lr}
	xTimerStop(TimeOutTimer, 0); 
  401d7e:	4b05      	ldr	r3, [pc, #20]	; (401d94 <stateExit_Idle+0x18>)
  401d80:	4c05      	ldr	r4, [pc, #20]	; (401d98 <stateExit_Idle+0x1c>)
  401d82:	6818      	ldr	r0, [r3, #0]
 * @param void
 * @return void
 ***********************************************************************************************/
//idle exit
void stateExit_Idle()
{
  401d84:	b082      	sub	sp, #8
	xTimerStop(TimeOutTimer, 0); 
  401d86:	2300      	movs	r3, #0
  401d88:	461a      	mov	r2, r3
  401d8a:	9300      	str	r3, [sp, #0]
  401d8c:	2101      	movs	r1, #1
  401d8e:	47a0      	blx	r4
}
  401d90:	b002      	add	sp, #8
  401d92:	bd10      	pop	{r4, pc}
  401d94:	2000336c 	.word	0x2000336c
  401d98:	00407949 	.word	0x00407949

00401d9c <stateEntry_Error>:
 * @param void
 * @return void
 ***********************************************************************************************/
//Error state entry
void stateEntry_Error()
{
  401d9c:	b570      	push	{r4, r5, r6, lr}
 * @return void
 ***********************************************************************************************/
static void setCurrentSystemState(systemStates_t state)
{
	currentSystemState = state; 
	debugPrintString(systemStateNameString[currentSystemState]);	
  401d9e:	4d0f      	ldr	r5, [pc, #60]	; (401ddc <stateEntry_Error+0x40>)
 * @param systemStates_t state
 * @return void
 ***********************************************************************************************/
static void setCurrentSystemState(systemStates_t state)
{
	currentSystemState = state; 
  401da0:	4e0f      	ldr	r6, [pc, #60]	; (401de0 <stateEntry_Error+0x44>)
	debugPrintString(systemStateNameString[currentSystemState]);	
  401da2:	6968      	ldr	r0, [r5, #20]
  401da4:	4c0f      	ldr	r4, [pc, #60]	; (401de4 <stateEntry_Error+0x48>)
 * @param void
 * @return void
 ***********************************************************************************************/
//Error state entry
void stateEntry_Error()
{
  401da6:	b082      	sub	sp, #8
 * @param systemStates_t state
 * @return void
 ***********************************************************************************************/
static void setCurrentSystemState(systemStates_t state)
{
	currentSystemState = state; 
  401da8:	2305      	movs	r3, #5
  401daa:	7033      	strb	r3, [r6, #0]
	debugPrintString(systemStateNameString[currentSystemState]);	
  401dac:	47a0      	blx	r4
 ***********************************************************************************************/
//Error state entry
void stateEntry_Error()
{
	setCurrentSystemState(SYS_STATE_ERROR);
	debugPrintString(systemStateNameString[currentSystemState]);	
  401dae:	7833      	ldrb	r3, [r6, #0]
  401db0:	f855 0023 	ldr.w	r0, [r5, r3, lsl #2]
  401db4:	47a0      	blx	r4
	xTimerReset(TimeOutTimer, 0);
  401db6:	4a0c      	ldr	r2, [pc, #48]	; (401de8 <stateEntry_Error+0x4c>)
  401db8:	4b0c      	ldr	r3, [pc, #48]	; (401dec <stateEntry_Error+0x50>)
  401dba:	6815      	ldr	r5, [r2, #0]
  401dbc:	4798      	blx	r3
  401dbe:	2400      	movs	r4, #0
  401dc0:	4602      	mov	r2, r0
  401dc2:	4621      	mov	r1, r4
  401dc4:	4623      	mov	r3, r4
  401dc6:	4628      	mov	r0, r5
  401dc8:	9400      	str	r4, [sp, #0]
  401dca:	4d09      	ldr	r5, [pc, #36]	; (401df0 <stateEntry_Error+0x54>)
  401dcc:	47a8      	blx	r5
	drv_led_set(DRV_LED_YELLOW, DRV_LED_FLASH);
  401dce:	4621      	mov	r1, r4
  401dd0:	4b08      	ldr	r3, [pc, #32]	; (401df4 <stateEntry_Error+0x58>)
  401dd2:	2003      	movs	r0, #3
  401dd4:	4798      	blx	r3
}
  401dd6:	b002      	add	sp, #8
  401dd8:	bd70      	pop	{r4, r5, r6, pc}
  401dda:	bf00      	nop
  401ddc:	200000f0 	.word	0x200000f0
  401de0:	2000336b 	.word	0x2000336b
  401de4:	004008c9 	.word	0x004008c9
  401de8:	2000336c 	.word	0x2000336c
  401dec:	004070a1 	.word	0x004070a1
  401df0:	00407949 	.word	0x00407949
  401df4:	00400699 	.word	0x00400699

00401df8 <stateExit_Error>:
 * @param void
 * @return void
 ***********************************************************************************************/
//Error state exit
void stateExit_Error()
{
  401df8:	b510      	push	{r4, lr}
	xTimerStop(TimeOutTimer, 0);
  401dfa:	4b05      	ldr	r3, [pc, #20]	; (401e10 <stateExit_Error+0x18>)
  401dfc:	4c05      	ldr	r4, [pc, #20]	; (401e14 <stateExit_Error+0x1c>)
  401dfe:	6818      	ldr	r0, [r3, #0]
 * @param void
 * @return void
 ***********************************************************************************************/
//Error state exit
void stateExit_Error()
{
  401e00:	b082      	sub	sp, #8
	xTimerStop(TimeOutTimer, 0);
  401e02:	2300      	movs	r3, #0
  401e04:	461a      	mov	r2, r3
  401e06:	9300      	str	r3, [sp, #0]
  401e08:	2101      	movs	r1, #1
  401e0a:	47a0      	blx	r4
}
  401e0c:	b002      	add	sp, #8
  401e0e:	bd10      	pop	{r4, pc}
  401e10:	2000336c 	.word	0x2000336c
  401e14:	00407949 	.word	0x00407949

00401e18 <stateEntry_GetAccelData>:
 * @brief This initializes the Entry to the get acceleration data state
 * @param void
 * @return void
 ***********************************************************************************************/
void stateEntry_GetAccelData()
{
  401e18:	b570      	push	{r4, r5, r6, lr}
	task_quintic_sendConnectMsg(&quinticConfig[0]);
  401e1a:	481c      	ldr	r0, [pc, #112]	; (401e8c <stateEntry_GetAccelData+0x74>)
  401e1c:	4c1c      	ldr	r4, [pc, #112]	; (401e90 <stateEntry_GetAccelData+0x78>)
	task_quintic_sendConnectMsg(&quinticConfig[1]);
	task_quintic_sendConnectMsg(&quinticConfig[2]);
	//wait for a bit.
	vTaskDelay(100);
  401e1e:	4d1d      	ldr	r5, [pc, #116]	; (401e94 <stateEntry_GetAccelData+0x7c>)
 * @return void
 ***********************************************************************************************/
static void setCurrentSystemState(systemStates_t state)
{
	currentSystemState = state; 
	debugPrintString(systemStateNameString[currentSystemState]);	
  401e20:	4e1d      	ldr	r6, [pc, #116]	; (401e98 <stateEntry_GetAccelData+0x80>)
 * @param void
 * @return void
 ***********************************************************************************************/
void stateEntry_GetAccelData()
{
	task_quintic_sendConnectMsg(&quinticConfig[0]);
  401e22:	47a0      	blx	r4
	task_quintic_sendConnectMsg(&quinticConfig[1]);
  401e24:	481d      	ldr	r0, [pc, #116]	; (401e9c <stateEntry_GetAccelData+0x84>)
  401e26:	47a0      	blx	r4
	task_quintic_sendConnectMsg(&quinticConfig[2]);
  401e28:	481d      	ldr	r0, [pc, #116]	; (401ea0 <stateEntry_GetAccelData+0x88>)
  401e2a:	47a0      	blx	r4
	//wait for a bit.
	vTaskDelay(100);
  401e2c:	2064      	movs	r0, #100	; 0x64
  401e2e:	47a8      	blx	r5
 * @return void
 ***********************************************************************************************/
static void setCurrentSystemState(systemStates_t state)
{
	currentSystemState = state; 
	debugPrintString(systemStateNameString[currentSystemState]);	
  401e30:	4a1c      	ldr	r2, [pc, #112]	; (401ea4 <stateEntry_GetAccelData+0x8c>)
 * @param systemStates_t state
 * @return void
 ***********************************************************************************************/
static void setCurrentSystemState(systemStates_t state)
{
	currentSystemState = state; 
  401e32:	4b1d      	ldr	r3, [pc, #116]	; (401ea8 <stateEntry_GetAccelData+0x90>)
	debugPrintString(systemStateNameString[currentSystemState]);	
  401e34:	6990      	ldr	r0, [r2, #24]
 * @param systemStates_t state
 * @return void
 ***********************************************************************************************/
static void setCurrentSystemState(systemStates_t state)
{
	currentSystemState = state; 
  401e36:	2206      	movs	r2, #6
  401e38:	701a      	strb	r2, [r3, #0]
	debugPrintString(systemStateNameString[currentSystemState]);	
  401e3a:	47b0      	blx	r6
	task_quintic_sendConnectMsg(&quinticConfig[1]);
	task_quintic_sendConnectMsg(&quinticConfig[2]);
	//wait for a bit.
	vTaskDelay(100);
	setCurrentSystemState(SYS_STATE_GET_ACCEL_DATA);
	drv_led_set(DRV_LED_RED, DRV_LED_FLASH);
  401e3c:	2000      	movs	r0, #0
  401e3e:	4601      	mov	r1, r0
  401e40:	4b1a      	ldr	r3, [pc, #104]	; (401eac <stateEntry_GetAccelData+0x94>)
  401e42:	4798      	blx	r3
	//open new log file
	if(task_sdCard_OpenNewFile() != STATUS_PASS)
  401e44:	4b1a      	ldr	r3, [pc, #104]	; (401eb0 <stateEntry_GetAccelData+0x98>)
  401e46:	4798      	blx	r3
  401e48:	4604      	mov	r4, r0
  401e4a:	b9c0      	cbnz	r0, 401e7e <stateEntry_GetAccelData+0x66>
		task_stateMachine_EnqueueEvent(SYS_EVENT_SD_FILE_ERROR, 0);
		return;
	}
	//wait for user to get into position
	vTaskDelay(2500);
	if(brainSettings.numberOfAccelFrames > 0)
  401e4c:	4e19      	ldr	r6, [pc, #100]	; (401eb4 <stateEntry_GetAccelData+0x9c>)
		debugPrintString("Cannot open new file to write records\r\n");
		task_stateMachine_EnqueueEvent(SYS_EVENT_SD_FILE_ERROR, 0);
		return;
	}
	//wait for user to get into position
	vTaskDelay(2500);
  401e4e:	f640 10c4 	movw	r0, #2500	; 0x9c4
  401e52:	47a8      	blx	r5
	if(brainSettings.numberOfAccelFrames > 0)
  401e54:	f8d6 30b4 	ldr.w	r3, [r6, #180]	; 0xb4
  401e58:	2b00      	cmp	r3, #0
  401e5a:	dd0b      	ble.n	401e74 <stateEntry_GetAccelData+0x5c>
	{
		task_quintic_startGetAccelData(&quinticConfig[0]);
  401e5c:	4c16      	ldr	r4, [pc, #88]	; (401eb8 <stateEntry_GetAccelData+0xa0>)
  401e5e:	480b      	ldr	r0, [pc, #44]	; (401e8c <stateEntry_GetAccelData+0x74>)
  401e60:	47a0      	blx	r4
		task_quintic_startGetAccelData(&quinticConfig[1]);
  401e62:	480e      	ldr	r0, [pc, #56]	; (401e9c <stateEntry_GetAccelData+0x84>)
  401e64:	47a0      	blx	r4
		task_quintic_startGetAccelData(&quinticConfig[2]);
  401e66:	480e      	ldr	r0, [pc, #56]	; (401ea0 <stateEntry_GetAccelData+0x88>)
  401e68:	47a0      	blx	r4
		task_dataProcessor_startGetAccelData(brainSettings.numberOfAccelFrames); 
  401e6a:	f8d6 00b4 	ldr.w	r0, [r6, #180]	; 0xb4
  401e6e:	4b13      	ldr	r3, [pc, #76]	; (401ebc <stateEntry_GetAccelData+0xa4>)
  401e70:	4798      	blx	r3
  401e72:	bd70      	pop	{r4, r5, r6, pc}
	}
	else
	{
		task_stateMachine_EnqueueEvent(SYS_EVENT_GET_ACCEL_DATA_COMPLETE, 0x00); 
  401e74:	4621      	mov	r1, r4
  401e76:	4b12      	ldr	r3, [pc, #72]	; (401ec0 <stateEntry_GetAccelData+0xa8>)
  401e78:	200d      	movs	r0, #13
  401e7a:	4798      	blx	r3
  401e7c:	bd70      	pop	{r4, r5, r6, pc}
	drv_led_set(DRV_LED_RED, DRV_LED_FLASH);
	//open new log file
	if(task_sdCard_OpenNewFile() != STATUS_PASS)
	{
		//this is an error, we should probably do something
		debugPrintString("Cannot open new file to write records\r\n");
  401e7e:	4811      	ldr	r0, [pc, #68]	; (401ec4 <stateEntry_GetAccelData+0xac>)
  401e80:	47b0      	blx	r6
		task_stateMachine_EnqueueEvent(SYS_EVENT_SD_FILE_ERROR, 0);
  401e82:	2100      	movs	r1, #0
  401e84:	4b0e      	ldr	r3, [pc, #56]	; (401ec0 <stateEntry_GetAccelData+0xa8>)
  401e86:	2005      	movs	r0, #5
  401e88:	4798      	blx	r3
		return;
  401e8a:	bd70      	pop	{r4, r5, r6, pc}
  401e8c:	20000264 	.word	0x20000264
  401e90:	0040ab25 	.word	0x0040ab25
  401e94:	004072ed 	.word	0x004072ed
  401e98:	004008c9 	.word	0x004008c9
  401e9c:	200002a0 	.word	0x200002a0
  401ea0:	200002dc 	.word	0x200002dc
  401ea4:	200000f0 	.word	0x200000f0
  401ea8:	2000336b 	.word	0x2000336b
  401eac:	00400699 	.word	0x00400699
  401eb0:	004012dd 	.word	0x004012dd
  401eb4:	200001ac 	.word	0x200001ac
  401eb8:	0040abbd 	.word	0x0040abbd
  401ebc:	00409851 	.word	0x00409851
  401ec0:	00401a99 	.word	0x00401a99
  401ec4:	00415b28 	.word	0x00415b28

00401ec8 <stateExit_GetAccelData>:
 * @brief This initializes the exit from the acceleration data state
 * @param void
 * @return void
 ***********************************************************************************************/
void stateExit_GetAccelData()
{
  401ec8:	b538      	push	{r3, r4, r5, lr}
	task_quintic_stopGetAccelData(&quinticConfig[0]);
  401eca:	4d05      	ldr	r5, [pc, #20]	; (401ee0 <stateExit_GetAccelData+0x18>)
  401ecc:	4c05      	ldr	r4, [pc, #20]	; (401ee4 <stateExit_GetAccelData+0x1c>)
  401ece:	4628      	mov	r0, r5
  401ed0:	47a0      	blx	r4
	task_quintic_stopGetAccelData(&quinticConfig[1]);
  401ed2:	f105 003c 	add.w	r0, r5, #60	; 0x3c
  401ed6:	47a0      	blx	r4
	task_quintic_stopGetAccelData(&quinticConfig[2]);	
  401ed8:	f105 0078 	add.w	r0, r5, #120	; 0x78
  401edc:	47a0      	blx	r4
  401ede:	bd38      	pop	{r3, r4, r5, pc}
  401ee0:	20000264 	.word	0x20000264
  401ee4:	0040abf5 	.word	0x0040abf5

00401ee8 <reloadConfigSettings>:
 * @brief Reload the config settings from SD card 
 * @param void
 * @return void
 ***********************************************************************************************/
status_t  __attribute__((optimize("O0"))) reloadConfigSettings()
{
  401ee8:	b590      	push	{r4, r7, lr}
  401eea:	b087      	sub	sp, #28
  401eec:	af02      	add	r7, sp, #8
	static FATFS fs;
	static FATFS* fs1;	//pointer to FATFS structure used to check free space
	static FRESULT res;
	static DWORD freeClusters, freeSectors, totalSectors;
	status_t result = STATUS_FAIL;
  401eee:	2301      	movs	r3, #1
  401ef0:	73fb      	strb	r3, [r7, #15]
	Ctrl_status status; 
	drv_gpio_pin_state_t sdCdPinState;
	int i;
	
	drv_gpio_getPinState(DRV_GPIO_PIN_SD_CD, &sdCdPinState);
  401ef2:	1dbb      	adds	r3, r7, #6
  401ef4:	2010      	movs	r0, #16
  401ef6:	4619      	mov	r1, r3
  401ef8:	4b7a      	ldr	r3, [pc, #488]	; (4020e4 <reloadConfigSettings+0x1fc>)
  401efa:	4798      	blx	r3
	//check the pin value to see if the card is detected. 
	if (sdCdPinState != SD_MMC_0_CD_DETECT_VALUE)
  401efc:	79bb      	ldrb	r3, [r7, #6]
  401efe:	2b01      	cmp	r3, #1
  401f00:	d004      	beq.n	401f0c <reloadConfigSettings+0x24>
	{
		//card has not been detected.
		sdInsertWaitTimeoutFlag = FALSE;	//clear the flag for resuse
  401f02:	4b79      	ldr	r3, [pc, #484]	; (4020e8 <reloadConfigSettings+0x200>)
  401f04:	2200      	movs	r2, #0
  401f06:	701a      	strb	r2, [r3, #0]
		return result;
  401f08:	7bfb      	ldrb	r3, [r7, #15]
  401f0a:	e0e7      	b.n	4020dc <reloadConfigSettings+0x1f4>
	}
	//SD-Card present, reconfigure the interrupt to use it for detecting removal
	drv_gpio_config_interrupt(DRV_GPIO_PIN_SD_CD, DRV_GPIO_INTERRUPT_LOW_EDGE);
  401f0c:	2010      	movs	r0, #16
  401f0e:	2101      	movs	r1, #1
  401f10:	4b76      	ldr	r3, [pc, #472]	; (4020ec <reloadConfigSettings+0x204>)
  401f12:	4798      	blx	r3
	//initialize the sd card... assuming that the card has not been initialized? 
	sd_mmc_init();
  401f14:	4b76      	ldr	r3, [pc, #472]	; (4020f0 <reloadConfigSettings+0x208>)
  401f16:	4798      	blx	r3
	sdTimeOutTimer = xTimerCreate("SD insert tmr", (SD_INSERT_WAIT_TIMEOUT/portTICK_RATE_MS), pdFALSE, NULL, vSdTimeOutTimerCallback);
  401f18:	4b76      	ldr	r3, [pc, #472]	; (4020f4 <reloadConfigSettings+0x20c>)
  401f1a:	9300      	str	r3, [sp, #0]
  401f1c:	4876      	ldr	r0, [pc, #472]	; (4020f8 <reloadConfigSettings+0x210>)
  401f1e:	f241 3188 	movw	r1, #5000	; 0x1388
  401f22:	2200      	movs	r2, #0
  401f24:	2300      	movs	r3, #0
  401f26:	4c75      	ldr	r4, [pc, #468]	; (4020fc <reloadConfigSettings+0x214>)
  401f28:	47a0      	blx	r4
  401f2a:	4602      	mov	r2, r0
  401f2c:	4b74      	ldr	r3, [pc, #464]	; (402100 <reloadConfigSettings+0x218>)
  401f2e:	601a      	str	r2, [r3, #0]
	if (sdTimeOutTimer == NULL)
  401f30:	4b73      	ldr	r3, [pc, #460]	; (402100 <reloadConfigSettings+0x218>)
  401f32:	681b      	ldr	r3, [r3, #0]
  401f34:	2b00      	cmp	r3, #0
  401f36:	d102      	bne.n	401f3e <reloadConfigSettings+0x56>
	{
		debugPrintString("Failed to create SD card timer\r\n");
  401f38:	4872      	ldr	r0, [pc, #456]	; (402104 <reloadConfigSettings+0x21c>)
  401f3a:	4b73      	ldr	r3, [pc, #460]	; (402108 <reloadConfigSettings+0x220>)
  401f3c:	4798      	blx	r3
	}
	xTimerStart(sdTimeOutTimer, 0);
  401f3e:	4b70      	ldr	r3, [pc, #448]	; (402100 <reloadConfigSettings+0x218>)
  401f40:	681c      	ldr	r4, [r3, #0]
  401f42:	4b72      	ldr	r3, [pc, #456]	; (40210c <reloadConfigSettings+0x224>)
  401f44:	4798      	blx	r3
  401f46:	4603      	mov	r3, r0
  401f48:	2200      	movs	r2, #0
  401f4a:	9200      	str	r2, [sp, #0]
  401f4c:	4620      	mov	r0, r4
  401f4e:	2100      	movs	r1, #0
  401f50:	461a      	mov	r2, r3
  401f52:	2300      	movs	r3, #0
  401f54:	4c6e      	ldr	r4, [pc, #440]	; (402110 <reloadConfigSettings+0x228>)
  401f56:	47a0      	blx	r4
	do
	{
		status = sd_mmc_test_unit_ready(0);
  401f58:	2000      	movs	r0, #0
  401f5a:	4b6e      	ldr	r3, [pc, #440]	; (402114 <reloadConfigSettings+0x22c>)
  401f5c:	4798      	blx	r3
  401f5e:	4603      	mov	r3, r0
  401f60:	71fb      	strb	r3, [r7, #7]
		if (CTRL_FAIL == status)
  401f62:	79fb      	ldrb	r3, [r7, #7]
  401f64:	2b01      	cmp	r3, #1
  401f66:	d117      	bne.n	401f98 <reloadConfigSettings+0xb0>
		{
			debugPrintString("Card install FAIL\n\r");
  401f68:	486b      	ldr	r0, [pc, #428]	; (402118 <reloadConfigSettings+0x230>)
  401f6a:	4b67      	ldr	r3, [pc, #412]	; (402108 <reloadConfigSettings+0x220>)
  401f6c:	4798      	blx	r3
			debugPrintString("Please unplug and re-plug the card.\n\r");
  401f6e:	486b      	ldr	r0, [pc, #428]	; (40211c <reloadConfigSettings+0x234>)
  401f70:	4b65      	ldr	r3, [pc, #404]	; (402108 <reloadConfigSettings+0x220>)
  401f72:	4798      	blx	r3
			while ((CTRL_NO_PRESENT != sd_mmc_check(0)) && (sdInsertWaitTimeoutFlag == FALSE))
  401f74:	e002      	b.n	401f7c <reloadConfigSettings+0x94>
			{
				vTaskDelay(1);
  401f76:	2001      	movs	r0, #1
  401f78:	4b69      	ldr	r3, [pc, #420]	; (402120 <reloadConfigSettings+0x238>)
  401f7a:	4798      	blx	r3
		status = sd_mmc_test_unit_ready(0);
		if (CTRL_FAIL == status)
		{
			debugPrintString("Card install FAIL\n\r");
			debugPrintString("Please unplug and re-plug the card.\n\r");
			while ((CTRL_NO_PRESENT != sd_mmc_check(0)) && (sdInsertWaitTimeoutFlag == FALSE))
  401f7c:	2000      	movs	r0, #0
  401f7e:	4b69      	ldr	r3, [pc, #420]	; (402124 <reloadConfigSettings+0x23c>)
  401f80:	4798      	blx	r3
  401f82:	4603      	mov	r3, r0
  401f84:	2b02      	cmp	r3, #2
  401f86:	d007      	beq.n	401f98 <reloadConfigSettings+0xb0>
  401f88:	4b57      	ldr	r3, [pc, #348]	; (4020e8 <reloadConfigSettings+0x200>)
  401f8a:	781b      	ldrb	r3, [r3, #0]
  401f8c:	b2db      	uxtb	r3, r3
  401f8e:	f083 0301 	eor.w	r3, r3, #1
  401f92:	b2db      	uxtb	r3, r3
  401f94:	2b00      	cmp	r3, #0
  401f96:	d1ee      	bne.n	401f76 <reloadConfigSettings+0x8e>
			{
				vTaskDelay(1);
			}
		}
		vTaskDelay(1);
  401f98:	2001      	movs	r0, #1
  401f9a:	4b61      	ldr	r3, [pc, #388]	; (402120 <reloadConfigSettings+0x238>)
  401f9c:	4798      	blx	r3
	} while ((CTRL_GOOD != status) && (sdInsertWaitTimeoutFlag == FALSE));
  401f9e:	79fb      	ldrb	r3, [r7, #7]
  401fa0:	2b00      	cmp	r3, #0
  401fa2:	d007      	beq.n	401fb4 <reloadConfigSettings+0xcc>
  401fa4:	4b50      	ldr	r3, [pc, #320]	; (4020e8 <reloadConfigSettings+0x200>)
  401fa6:	781b      	ldrb	r3, [r3, #0]
  401fa8:	b2db      	uxtb	r3, r3
  401faa:	f083 0301 	eor.w	r3, r3, #1
  401fae:	b2db      	uxtb	r3, r3
  401fb0:	2b00      	cmp	r3, #0
  401fb2:	d1d1      	bne.n	401f58 <reloadConfigSettings+0x70>
	
	sdInsertWaitTimeoutFlag = FALSE;	//clear the flag for reuse
  401fb4:	4b4c      	ldr	r3, [pc, #304]	; (4020e8 <reloadConfigSettings+0x200>)
  401fb6:	2200      	movs	r2, #0
  401fb8:	701a      	strb	r2, [r3, #0]
	xTimerStop(sdTimeOutTimer, 0);
  401fba:	4b51      	ldr	r3, [pc, #324]	; (402100 <reloadConfigSettings+0x218>)
  401fbc:	681b      	ldr	r3, [r3, #0]
  401fbe:	2200      	movs	r2, #0
  401fc0:	9200      	str	r2, [sp, #0]
  401fc2:	4618      	mov	r0, r3
  401fc4:	2101      	movs	r1, #1
  401fc6:	2200      	movs	r2, #0
  401fc8:	2300      	movs	r3, #0
  401fca:	4c51      	ldr	r4, [pc, #324]	; (402110 <reloadConfigSettings+0x228>)
  401fcc:	47a0      	blx	r4
	xTimerDelete(sdTimeOutTimer, 0);
  401fce:	4b4c      	ldr	r3, [pc, #304]	; (402100 <reloadConfigSettings+0x218>)
  401fd0:	681b      	ldr	r3, [r3, #0]
  401fd2:	2200      	movs	r2, #0
  401fd4:	9200      	str	r2, [sp, #0]
  401fd6:	4618      	mov	r0, r3
  401fd8:	2103      	movs	r1, #3
  401fda:	2200      	movs	r2, #0
  401fdc:	2300      	movs	r3, #0
  401fde:	4c4c      	ldr	r4, [pc, #304]	; (402110 <reloadConfigSettings+0x228>)
  401fe0:	47a0      	blx	r4
	
	/*	Mount the SD card	*/
	if(status == CTRL_GOOD)
  401fe2:	79fb      	ldrb	r3, [r7, #7]
  401fe4:	2b00      	cmp	r3, #0
  401fe6:	d178      	bne.n	4020da <reloadConfigSettings+0x1f2>
	{
		memset(&fs, 0, sizeof(FATFS));
  401fe8:	484f      	ldr	r0, [pc, #316]	; (402128 <reloadConfigSettings+0x240>)
  401fea:	2100      	movs	r1, #0
  401fec:	f44f 720c 	mov.w	r2, #560	; 0x230
  401ff0:	4b4e      	ldr	r3, [pc, #312]	; (40212c <reloadConfigSettings+0x244>)
  401ff2:	4798      	blx	r3
		res = f_mount(LUN_ID_SD_MMC_0_MEM, &fs);
  401ff4:	2000      	movs	r0, #0
  401ff6:	494c      	ldr	r1, [pc, #304]	; (402128 <reloadConfigSettings+0x240>)
  401ff8:	4b4d      	ldr	r3, [pc, #308]	; (402130 <reloadConfigSettings+0x248>)
  401ffa:	4798      	blx	r3
  401ffc:	4603      	mov	r3, r0
  401ffe:	461a      	mov	r2, r3
  402000:	4b4c      	ldr	r3, [pc, #304]	; (402134 <reloadConfigSettings+0x24c>)
  402002:	701a      	strb	r2, [r3, #0]
		if (res == FR_INVALID_DRIVE)
  402004:	4b4b      	ldr	r3, [pc, #300]	; (402134 <reloadConfigSettings+0x24c>)
  402006:	781b      	ldrb	r3, [r3, #0]
  402008:	2b0b      	cmp	r3, #11
  40200a:	d104      	bne.n	402016 <reloadConfigSettings+0x12e>
		{
			debugPrintString("Error: Invalid Drive\r\n");
  40200c:	484a      	ldr	r0, [pc, #296]	; (402138 <reloadConfigSettings+0x250>)
  40200e:	4b3e      	ldr	r3, [pc, #248]	; (402108 <reloadConfigSettings+0x220>)
  402010:	4798      	blx	r3
			return result;
  402012:	7bfb      	ldrb	r3, [r7, #15]
  402014:	e062      	b.n	4020dc <reloadConfigSettings+0x1f4>
		}
		
		//Check the free space on card
		result = f_getfree("0:", &freeClusters, &fs1);
  402016:	4849      	ldr	r0, [pc, #292]	; (40213c <reloadConfigSettings+0x254>)
  402018:	4949      	ldr	r1, [pc, #292]	; (402140 <reloadConfigSettings+0x258>)
  40201a:	4a4a      	ldr	r2, [pc, #296]	; (402144 <reloadConfigSettings+0x25c>)
  40201c:	4b4a      	ldr	r3, [pc, #296]	; (402148 <reloadConfigSettings+0x260>)
  40201e:	4798      	blx	r3
  402020:	4603      	mov	r3, r0
  402022:	73fb      	strb	r3, [r7, #15]
		if (result != FR_OK)
  402024:	7bfb      	ldrb	r3, [r7, #15]
  402026:	2b00      	cmp	r3, #0
  402028:	d006      	beq.n	402038 <reloadConfigSettings+0x150>
		{
			result = STATUS_FAIL;
  40202a:	2301      	movs	r3, #1
  40202c:	73fb      	strb	r3, [r7, #15]
			debugPrintString("Error: Cannot calculate free space\r\n");
  40202e:	4847      	ldr	r0, [pc, #284]	; (40214c <reloadConfigSettings+0x264>)
  402030:	4b35      	ldr	r3, [pc, #212]	; (402108 <reloadConfigSettings+0x220>)
  402032:	4798      	blx	r3
			return result;
  402034:	7bfb      	ldrb	r3, [r7, #15]
  402036:	e051      	b.n	4020dc <reloadConfigSettings+0x1f4>
		}
		totalSectors = (fs1->n_fatent -2) * fs1->csize;	//only needed to calculate used space
  402038:	4b42      	ldr	r3, [pc, #264]	; (402144 <reloadConfigSettings+0x25c>)
  40203a:	681b      	ldr	r3, [r3, #0]
  40203c:	699b      	ldr	r3, [r3, #24]
  40203e:	3b02      	subs	r3, #2
  402040:	4a40      	ldr	r2, [pc, #256]	; (402144 <reloadConfigSettings+0x25c>)
  402042:	6812      	ldr	r2, [r2, #0]
  402044:	7892      	ldrb	r2, [r2, #2]
  402046:	fb02 f203 	mul.w	r2, r2, r3
  40204a:	4b41      	ldr	r3, [pc, #260]	; (402150 <reloadConfigSettings+0x268>)
  40204c:	601a      	str	r2, [r3, #0]
		freeSectors = freeClusters * fs1->csize;	//assuming 512 bytes/sector
  40204e:	4b3d      	ldr	r3, [pc, #244]	; (402144 <reloadConfigSettings+0x25c>)
  402050:	681b      	ldr	r3, [r3, #0]
  402052:	789b      	ldrb	r3, [r3, #2]
  402054:	4a3a      	ldr	r2, [pc, #232]	; (402140 <reloadConfigSettings+0x258>)
  402056:	6812      	ldr	r2, [r2, #0]
  402058:	fb02 f203 	mul.w	r2, r2, r3
  40205c:	4b3d      	ldr	r3, [pc, #244]	; (402154 <reloadConfigSettings+0x26c>)
  40205e:	601a      	str	r2, [r3, #0]
		if ((freeSectors/2) < SD_DISK_SPACE_LOW_THRESHOLD)	
  402060:	4b3c      	ldr	r3, [pc, #240]	; (402154 <reloadConfigSettings+0x26c>)
  402062:	681b      	ldr	r3, [r3, #0]
  402064:	f5b3 2f16 	cmp.w	r3, #614400	; 0x96000
  402068:	d206      	bcs.n	402078 <reloadConfigSettings+0x190>
		{
			result = STATUS_FAIL;
  40206a:	2301      	movs	r3, #1
  40206c:	73fb      	strb	r3, [r7, #15]
			debugPrintString("Error: Low disk space on SD-card\r\n");
  40206e:	483a      	ldr	r0, [pc, #232]	; (402158 <reloadConfigSettings+0x270>)
  402070:	4b25      	ldr	r3, [pc, #148]	; (402108 <reloadConfigSettings+0x220>)
  402072:	4798      	blx	r3
			return result;
  402074:	7bfb      	ldrb	r3, [r7, #15]
  402076:	e031      	b.n	4020dc <reloadConfigSettings+0x1f4>
		}
		
		//prevent system to go in reset state on button press event after a failed config load
		result = STATUS_PASS;
  402078:	2300      	movs	r3, #0
  40207a:	73fb      	strb	r3, [r7, #15]
		if(loadSettings(SETTINGS_FILENAME) != STATUS_PASS)
  40207c:	4837      	ldr	r0, [pc, #220]	; (40215c <reloadConfigSettings+0x274>)
  40207e:	4b38      	ldr	r3, [pc, #224]	; (402160 <reloadConfigSettings+0x278>)
  402080:	4798      	blx	r3
  402082:	4603      	mov	r3, r0
  402084:	2b00      	cmp	r3, #0
  402086:	d006      	beq.n	402096 <reloadConfigSettings+0x1ae>
		{
			result = STATUS_FAIL;
  402088:	2301      	movs	r3, #1
  40208a:	73fb      	strb	r3, [r7, #15]
			debugPrintString("failed to get read settings\r\n");
  40208c:	4835      	ldr	r0, [pc, #212]	; (402164 <reloadConfigSettings+0x27c>)
  40208e:	4b1e      	ldr	r3, [pc, #120]	; (402108 <reloadConfigSettings+0x220>)
  402090:	4798      	blx	r3
			return result;
  402092:	7bfb      	ldrb	r3, [r7, #15]
  402094:	e022      	b.n	4020dc <reloadConfigSettings+0x1f4>
		}
		brainSettings.isLoaded = 1;
  402096:	4b34      	ldr	r3, [pc, #208]	; (402168 <reloadConfigSettings+0x280>)
  402098:	2201      	movs	r2, #1
  40209a:	601a      	str	r2, [r3, #0]
		for (i=0; i<3; i++)	//Update the vExpectedResetStatus value according to new settings file
  40209c:	2300      	movs	r3, #0
  40209e:	60bb      	str	r3, [r7, #8]
  4020a0:	e018      	b.n	4020d4 <reloadConfigSettings+0x1ec>
		{
			if (quinticConfig[i].expectedNumberOfNods > 0)
  4020a2:	4932      	ldr	r1, [pc, #200]	; (40216c <reloadConfigSettings+0x284>)
  4020a4:	68ba      	ldr	r2, [r7, #8]
  4020a6:	4613      	mov	r3, r2
  4020a8:	011b      	lsls	r3, r3, #4
  4020aa:	1a9b      	subs	r3, r3, r2
  4020ac:	009b      	lsls	r3, r3, #2
  4020ae:	440b      	add	r3, r1
  4020b0:	3318      	adds	r3, #24
  4020b2:	681b      	ldr	r3, [r3, #0]
  4020b4:	2b00      	cmp	r3, #0
  4020b6:	dd0a      	ble.n	4020ce <reloadConfigSettings+0x1e6>
			{
				vExpectedResetStatus |= (1u<<i);
  4020b8:	2201      	movs	r2, #1
  4020ba:	68bb      	ldr	r3, [r7, #8]
  4020bc:	fa02 f303 	lsl.w	r3, r2, r3
  4020c0:	b2da      	uxtb	r2, r3
  4020c2:	4b2b      	ldr	r3, [pc, #172]	; (402170 <reloadConfigSettings+0x288>)
  4020c4:	781b      	ldrb	r3, [r3, #0]
  4020c6:	4313      	orrs	r3, r2
  4020c8:	b2da      	uxtb	r2, r3
  4020ca:	4b29      	ldr	r3, [pc, #164]	; (402170 <reloadConfigSettings+0x288>)
  4020cc:	701a      	strb	r2, [r3, #0]
			result = STATUS_FAIL;
			debugPrintString("failed to get read settings\r\n");
			return result;
		}
		brainSettings.isLoaded = 1;
		for (i=0; i<3; i++)	//Update the vExpectedResetStatus value according to new settings file
  4020ce:	68bb      	ldr	r3, [r7, #8]
  4020d0:	3301      	adds	r3, #1
  4020d2:	60bb      	str	r3, [r7, #8]
  4020d4:	68bb      	ldr	r3, [r7, #8]
  4020d6:	2b02      	cmp	r3, #2
  4020d8:	dde3      	ble.n	4020a2 <reloadConfigSettings+0x1ba>
			{
				vExpectedResetStatus |= (1u<<i);
			}
		}
	}
	return result;
  4020da:	7bfb      	ldrb	r3, [r7, #15]
}
  4020dc:	4618      	mov	r0, r3
  4020de:	3714      	adds	r7, #20
  4020e0:	46bd      	mov	sp, r7
  4020e2:	bd90      	pop	{r4, r7, pc}
  4020e4:	00408829 	.word	0x00408829
  4020e8:	20003370 	.word	0x20003370
  4020ec:	00408871 	.word	0x00408871
  4020f0:	004028bd 	.word	0x004028bd
  4020f4:	00401a8d 	.word	0x00401a8d
  4020f8:	0041598c 	.word	0x0041598c
  4020fc:	004078fd 	.word	0x004078fd
  402100:	20003364 	.word	0x20003364
  402104:	0041599c 	.word	0x0041599c
  402108:	004008c9 	.word	0x004008c9
  40210c:	004070a1 	.word	0x004070a1
  402110:	00407949 	.word	0x00407949
  402114:	00403265 	.word	0x00403265
  402118:	004159c0 	.word	0x004159c0
  40211c:	004159d4 	.word	0x004159d4
  402120:	004072ed 	.word	0x004072ed
  402124:	004028dd 	.word	0x004028dd
  402128:	20003134 	.word	0x20003134
  40212c:	0040c31d 	.word	0x0040c31d
  402130:	00405559 	.word	0x00405559
  402134:	20003130 	.word	0x20003130
  402138:	004159fc 	.word	0x004159fc
  40213c:	00415a14 	.word	0x00415a14
  402140:	2000312c 	.word	0x2000312c
  402144:	20003128 	.word	0x20003128
  402148:	00405f65 	.word	0x00405f65
  40214c:	00415a18 	.word	0x00415a18
  402150:	20003124 	.word	0x20003124
  402154:	20003120 	.word	0x20003120
  402158:	00415a40 	.word	0x00415a40
  40215c:	00415a64 	.word	0x00415a64
  402160:	004080ad 	.word	0x004080ad
  402164:	00415a74 	.word	0x00415a74
  402168:	200001ac 	.word	0x200001ac
  40216c:	20000264 	.word	0x20000264
  402170:	20003368 	.word	0x20003368

00402174 <lowBatteryBlink>:
 * @brief Blink the LED to indicate low battery 
 * @param void
 * @return void
 ***********************************************************************************************/
void lowBatteryBlink()
{
  402174:	b570      	push	{r4, r5, r6, lr}
  402176:	4e08      	ldr	r6, [pc, #32]	; (402198 <lowBatteryBlink+0x24>)
  402178:	4d08      	ldr	r5, [pc, #32]	; (40219c <lowBatteryBlink+0x28>)
  40217a:	2403      	movs	r4, #3
	//Blink the LED connected to STAT pin to indicate battery low
	#ifndef USES_NEW_POWER_BOARD //if we use the new power board don't blink the LED
	for (int i = 0; i < 3; i++)
	{
		drv_gpio_setPinState(DRV_GPIO_PIN_PB_GPIO, DRV_GPIO_PIN_STATE_HIGH);
  40217c:	2101      	movs	r1, #1
  40217e:	2012      	movs	r0, #18
  402180:	47b0      	blx	r6
		delay_ms(LED_BLINK_RATE);
  402182:	4807      	ldr	r0, [pc, #28]	; (4021a0 <lowBatteryBlink+0x2c>)
  402184:	47a8      	blx	r5
		drv_gpio_setPinState(DRV_GPIO_PIN_PB_GPIO, DRV_GPIO_PIN_STATE_LOW);
  402186:	2100      	movs	r1, #0
  402188:	2012      	movs	r0, #18
  40218a:	47b0      	blx	r6
		delay_ms(LED_BLINK_RATE);
  40218c:	4804      	ldr	r0, [pc, #16]	; (4021a0 <lowBatteryBlink+0x2c>)
  40218e:	47a8      	blx	r5
 ***********************************************************************************************/
void lowBatteryBlink()
{
	//Blink the LED connected to STAT pin to indicate battery low
	#ifndef USES_NEW_POWER_BOARD //if we use the new power board don't blink the LED
	for (int i = 0; i < 3; i++)
  402190:	3c01      	subs	r4, #1
  402192:	d1f3      	bne.n	40217c <lowBatteryBlink+0x8>
		delay_ms(LED_BLINK_RATE);
		drv_gpio_setPinState(DRV_GPIO_PIN_PB_GPIO, DRV_GPIO_PIN_STATE_LOW);
		delay_ms(LED_BLINK_RATE);
	}
	#endif
  402194:	bd70      	pop	{r4, r5, r6, pc}
  402196:	bf00      	nop
  402198:	004087b1 	.word	0x004087b1
  40219c:	20000085 	.word	0x20000085
  4021a0:	0020b28a 	.word	0x0020b28a

004021a4 <stateEntry_PowerDown>:
 * @return void
 ***********************************************************************************************/
//entry and exit functions
//power down function (handles entry and exit)
void stateEntry_PowerDown()
{
  4021a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 * @return void
 ***********************************************************************************************/
static void setCurrentSystemState(systemStates_t state)
{
	currentSystemState = state; 
	debugPrintString(systemStateNameString[currentSystemState]);	
  4021a8:	4a73      	ldr	r2, [pc, #460]	; (402378 <stateEntry_PowerDown+0x1d4>)
 * @param systemStates_t state
 * @return void
 ***********************************************************************************************/
static void setCurrentSystemState(systemStates_t state)
{
	currentSystemState = state; 
  4021aa:	4b74      	ldr	r3, [pc, #464]	; (40237c <stateEntry_PowerDown+0x1d8>)
	debugPrintString(systemStateNameString[currentSystemState]);	
  4021ac:	6850      	ldr	r0, [r2, #4]
  4021ae:	f8df a258 	ldr.w	sl, [pc, #600]	; 402408 <stateEntry_PowerDown+0x264>
	drv_gpio_pin_state_t pwSwState = DRV_GPIO_PIN_STATE_HIGH, lboState = DRV_GPIO_PIN_STATE_HIGH;
	bool pwrSwFlag = FALSE; 
	setCurrentSystemState(SYS_STATE_POWER_DOWN);	
	drv_led_set(DRV_LED_OFF, DRV_LED_SOLID);
	
	if (firstBoot == TRUE)
  4021b2:	4e73      	ldr	r6, [pc, #460]	; (402380 <stateEntry_PowerDown+0x1dc>)
	{
		//Put the BLE's in reset. 
		drv_gpio_setPinState(quinticConfig[0].resetPin, DRV_GPIO_PIN_STATE_LOW);
  4021b4:	4f73      	ldr	r7, [pc, #460]	; (402384 <stateEntry_PowerDown+0x1e0>)
  4021b6:	4d74      	ldr	r5, [pc, #464]	; (402388 <stateEntry_PowerDown+0x1e4>)
 * @return void
 ***********************************************************************************************/
//entry and exit functions
//power down function (handles entry and exit)
void stateEntry_PowerDown()
{
  4021b8:	b087      	sub	sp, #28
	drv_gpio_pin_state_t pwSwState = DRV_GPIO_PIN_STATE_HIGH, lboState = DRV_GPIO_PIN_STATE_HIGH;
  4021ba:	2401      	movs	r4, #1
 * @param systemStates_t state
 * @return void
 ***********************************************************************************************/
static void setCurrentSystemState(systemStates_t state)
{
	currentSystemState = state; 
  4021bc:	701c      	strb	r4, [r3, #0]
 ***********************************************************************************************/
//entry and exit functions
//power down function (handles entry and exit)
void stateEntry_PowerDown()
{
	drv_gpio_pin_state_t pwSwState = DRV_GPIO_PIN_STATE_HIGH, lboState = DRV_GPIO_PIN_STATE_HIGH;
  4021be:	f88d 400e 	strb.w	r4, [sp, #14]
  4021c2:	f88d 400f 	strb.w	r4, [sp, #15]
 * @return void
 ***********************************************************************************************/
static void setCurrentSystemState(systemStates_t state)
{
	currentSystemState = state; 
	debugPrintString(systemStateNameString[currentSystemState]);	
  4021c6:	47d0      	blx	sl
void stateEntry_PowerDown()
{
	drv_gpio_pin_state_t pwSwState = DRV_GPIO_PIN_STATE_HIGH, lboState = DRV_GPIO_PIN_STATE_HIGH;
	bool pwrSwFlag = FALSE; 
	setCurrentSystemState(SYS_STATE_POWER_DOWN);	
	drv_led_set(DRV_LED_OFF, DRV_LED_SOLID);
  4021c8:	4b70      	ldr	r3, [pc, #448]	; (40238c <stateEntry_PowerDown+0x1e8>)
  4021ca:	4621      	mov	r1, r4
  4021cc:	2006      	movs	r0, #6
  4021ce:	4798      	blx	r3
	
	if (firstBoot == TRUE)
  4021d0:	7833      	ldrb	r3, [r6, #0]
  4021d2:	2b00      	cmp	r3, #0
  4021d4:	f040 80a4 	bne.w	402320 <stateEntry_PowerDown+0x17c>
		brainSettings.isLoaded = 0;
	
		//turn off the JACK power supplies (they're negatively asserted) 
		//drv_gpio_setPinState(DRV_GPIO_PIN_JC_EN1, DRV_GPIO_PIN_STATE_HIGH);
		//drv_gpio_setPinState(DRV_GPIO_PIN_JC_EN2, DRV_GPIO_PIN_STATE_HIGH);
		toggleJackEnables(DRV_GPIO_PIN_STATE_HIGH);
  4021d8:	4b6d      	ldr	r3, [pc, #436]	; (402390 <stateEntry_PowerDown+0x1ec>)
	
	if (firstBoot == FALSE)
	{
		//disable the interrupts, except for the power button
		//it is assumed that the button has already been held for 5 seconds
		DisconnectImus(&quinticConfig[0]);
  4021da:	4c6e      	ldr	r4, [pc, #440]	; (402394 <stateEntry_PowerDown+0x1f0>)
  4021dc:	4869      	ldr	r0, [pc, #420]	; (402384 <stateEntry_PowerDown+0x1e0>)
		brainSettings.isLoaded = 0;
	
		//turn off the JACK power supplies (they're negatively asserted) 
		//drv_gpio_setPinState(DRV_GPIO_PIN_JC_EN1, DRV_GPIO_PIN_STATE_HIGH);
		//drv_gpio_setPinState(DRV_GPIO_PIN_JC_EN2, DRV_GPIO_PIN_STATE_HIGH);
		toggleJackEnables(DRV_GPIO_PIN_STATE_HIGH);
  4021de:	9301      	str	r3, [sp, #4]
	
	if (firstBoot == FALSE)
	{
		//disable the interrupts, except for the power button
		//it is assumed that the button has already been held for 5 seconds
		DisconnectImus(&quinticConfig[0]);
  4021e0:	47a0      	blx	r4
		DisconnectImus(&quinticConfig[1]);
  4021e2:	486d      	ldr	r0, [pc, #436]	; (402398 <stateEntry_PowerDown+0x1f4>)
				while(1); //loop here forever... wait for power board to turn us off
				#endif
			}
			#ifndef USES_NEW_POWER_BOARD
			//cpu_irq_disable();	
			pmc_enable_sleepmode(0);	
  4021e4:	f8df 9224 	ldr.w	r9, [pc, #548]	; 40240c <stateEntry_PowerDown+0x268>
	if (firstBoot == FALSE)
	{
		//disable the interrupts, except for the power button
		//it is assumed that the button has already been held for 5 seconds
		DisconnectImus(&quinticConfig[0]);
		DisconnectImus(&quinticConfig[1]);
  4021e8:	47a0      	blx	r4
		DisconnectImus(&quinticConfig[2]);
  4021ea:	486c      	ldr	r0, [pc, #432]	; (40239c <stateEntry_PowerDown+0x1f8>)
  4021ec:	47a0      	blx	r4
		task_fabSense_stop(&fsConfig);
  4021ee:	4b6c      	ldr	r3, [pc, #432]	; (4023a0 <stateEntry_PowerDown+0x1fc>)
  4021f0:	486c      	ldr	r0, [pc, #432]	; (4023a4 <stateEntry_PowerDown+0x200>)
  4021f2:	4798      	blx	r3
		task_debugLog_CloseFile();
  4021f4:	4b6c      	ldr	r3, [pc, #432]	; (4023a8 <stateEntry_PowerDown+0x204>)
  4021f6:	4798      	blx	r3
	
		//clear the settings loaded bit
		brainSettings.isLoaded = 0;
  4021f8:	4b6c      	ldr	r3, [pc, #432]	; (4023ac <stateEntry_PowerDown+0x208>)
  4021fa:	2400      	movs	r4, #0
	
		//turn off the JACK power supplies (they're negatively asserted) 
		//drv_gpio_setPinState(DRV_GPIO_PIN_JC_EN1, DRV_GPIO_PIN_STATE_HIGH);
		//drv_gpio_setPinState(DRV_GPIO_PIN_JC_EN2, DRV_GPIO_PIN_STATE_HIGH);
		toggleJackEnables(DRV_GPIO_PIN_STATE_HIGH);
  4021fc:	2001      	movs	r0, #1
		DisconnectImus(&quinticConfig[2]);
		task_fabSense_stop(&fsConfig);
		task_debugLog_CloseFile();
	
		//clear the settings loaded bit
		brainSettings.isLoaded = 0;
  4021fe:	601c      	str	r4, [r3, #0]
	
		//turn off the JACK power supplies (they're negatively asserted) 
		//drv_gpio_setPinState(DRV_GPIO_PIN_JC_EN1, DRV_GPIO_PIN_STATE_HIGH);
		//drv_gpio_setPinState(DRV_GPIO_PIN_JC_EN2, DRV_GPIO_PIN_STATE_HIGH);
		toggleJackEnables(DRV_GPIO_PIN_STATE_HIGH);
  402200:	9b01      	ldr	r3, [sp, #4]
  402202:	4798      	blx	r3
		//Put the BLE's in reset. 
		drv_gpio_setPinState(quinticConfig[0].resetPin, DRV_GPIO_PIN_STATE_LOW);
  402204:	4621      	mov	r1, r4
  402206:	f897 0020 	ldrb.w	r0, [r7, #32]
  40220a:	47a8      	blx	r5
		drv_gpio_setPinState(quinticConfig[1].resetPin, DRV_GPIO_PIN_STATE_LOW);
  40220c:	4621      	mov	r1, r4
  40220e:	f897 005c 	ldrb.w	r0, [r7, #92]	; 0x5c
  402212:	47a8      	blx	r5
		drv_gpio_setPinState(quinticConfig[2].resetPin, DRV_GPIO_PIN_STATE_LOW);	
  402214:	4621      	mov	r1, r4
  402216:	f897 0098 	ldrb.w	r0, [r7, #152]	; 0x98
  40221a:	47a8      	blx	r5
		drv_gpio_setPinState(DRV_GPIO_PIN_BT_PWR_EN, DRV_GPIO_PIN_STATE_LOW);
  40221c:	4621      	mov	r1, r4
  40221e:	2011      	movs	r0, #17
  402220:	47a8      	blx	r5
		/* Put the processor to sleep, in this context with the systick timer
		*  dead, we will never leave, so initialization has to be done here too. 
		*   
		*/	
		debugPrintString("Sleep mode enabled\r\n");
  402222:	4863      	ldr	r0, [pc, #396]	; (4023b0 <stateEntry_PowerDown+0x20c>)
  402224:	47d0      	blx	sl
static void PreSleepProcess()
{
	//supc_disable_brownout_detector(SUPC);	
	//unmount the SD card. 
	static FRESULT res;
	res = f_mount(LUN_ID_SD_MMC_0_MEM, NULL);
  402226:	4621      	mov	r1, r4
  402228:	4b62      	ldr	r3, [pc, #392]	; (4023b4 <stateEntry_PowerDown+0x210>)
  40222a:	4620      	mov	r0, r4
  40222c:	4798      	blx	r3
  40222e:	4a62      	ldr	r2, [pc, #392]	; (4023b8 <stateEntry_PowerDown+0x214>)
	SysTick->CTRL = SysTick_CTRL_ENABLE_Msk | SysTick_CTRL_CLKSOURCE_Msk;	//disable the systick timer
  402230:	4b62      	ldr	r3, [pc, #392]	; (4023bc <stateEntry_PowerDown+0x218>)
static void PreSleepProcess()
{
	//supc_disable_brownout_detector(SUPC);	
	//unmount the SD card. 
	static FRESULT res;
	res = f_mount(LUN_ID_SD_MMC_0_MEM, NULL);
  402232:	7010      	strb	r0, [r2, #0]
	SysTick->CTRL = SysTick_CTRL_ENABLE_Msk | SysTick_CTRL_CLKSOURCE_Msk;	//disable the systick timer
  402234:	2205      	movs	r2, #5
  402236:	601a      	str	r2, [r3, #0]
	deInitAllUarts();
  402238:	4b61      	ldr	r3, [pc, #388]	; (4023c0 <stateEntry_PowerDown+0x21c>)
  40223a:	4798      	blx	r3
	drv_gpio_disable_interrupt_all();
  40223c:	4b61      	ldr	r3, [pc, #388]	; (4023c4 <stateEntry_PowerDown+0x220>)
  40223e:	4798      	blx	r3

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
  402240:	4b61      	ldr	r3, [pc, #388]	; (4023c8 <stateEntry_PowerDown+0x224>)
	NVIC_DisableIRQ(WDT_IRQn);
	NVIC_ClearPendingIRQ(WDT_IRQn);	
	drv_gpio_config_interrupt(DRV_GPIO_PIN_PW_SW, DRV_GPIO_INTERRUPT_LOW_EDGE);
  402242:	f8df c1cc 	ldr.w	ip, [pc, #460]	; 402410 <stateEntry_PowerDown+0x26c>
  402246:	2210      	movs	r2, #16
  402248:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  40224c:	4620      	mov	r0, r4

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
  40224e:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
  402252:	2101      	movs	r1, #1
  402254:	47e0      	blx	ip
	drv_gpio_enable_interrupt(DRV_GPIO_PIN_PW_SW); 		
  402256:	4620      	mov	r0, r4
  402258:	4b5c      	ldr	r3, [pc, #368]	; (4023cc <stateEntry_PowerDown+0x228>)
  40225a:	4798      	blx	r3
		//
	
		while (pwrSwFlag == FALSE)	//Stay in sleep mode until wakeup
		{
			//if first boot, don't go to sleep, wake up. 
			if(firstBoot == true)
  40225c:	f896 b000 	ldrb.w	fp, [r6]
			#ifndef USES_NEW_POWER_BOARD
			//cpu_irq_disable();	
			pmc_enable_sleepmode(0);	
			//Processor wakes up from sleep		
			delay_ms(WAKEUP_DELAY);
			drv_gpio_getPinState(DRV_GPIO_PIN_PW_SW, &pwSwState);	//poll the power switch
  402260:	4c5b      	ldr	r4, [pc, #364]	; (4023d0 <stateEntry_PowerDown+0x22c>)
		//
	
		while (pwrSwFlag == FALSE)	//Stay in sleep mode until wakeup
		{
			//if first boot, don't go to sleep, wake up. 
			if(firstBoot == true)
  402262:	f8df 811c 	ldr.w	r8, [pc, #284]	; 402380 <stateEntry_PowerDown+0x1dc>
				while(1); //loop here forever... wait for power board to turn us off
				#endif
			}
			#ifndef USES_NEW_POWER_BOARD
			//cpu_irq_disable();	
			pmc_enable_sleepmode(0);	
  402266:	4658      	mov	r0, fp
		//
	
		while (pwrSwFlag == FALSE)	//Stay in sleep mode until wakeup
		{
			//if first boot, don't go to sleep, wake up. 
			if(firstBoot == true)
  402268:	f1bb 0f00 	cmp.w	fp, #0
  40226c:	d17e      	bne.n	40236c <stateEntry_PowerDown+0x1c8>
				while(1); //loop here forever... wait for power board to turn us off
				#endif
			}
			#ifndef USES_NEW_POWER_BOARD
			//cpu_irq_disable();	
			pmc_enable_sleepmode(0);	
  40226e:	47c8      	blx	r9
			//Processor wakes up from sleep		
			delay_ms(WAKEUP_DELAY);
  402270:	4a58      	ldr	r2, [pc, #352]	; (4023d4 <stateEntry_PowerDown+0x230>)
  402272:	4859      	ldr	r0, [pc, #356]	; (4023d8 <stateEntry_PowerDown+0x234>)
  402274:	4790      	blx	r2
			drv_gpio_getPinState(DRV_GPIO_PIN_PW_SW, &pwSwState);	//poll the power switch
  402276:	f10d 010e 	add.w	r1, sp, #14
  40227a:	4658      	mov	r0, fp
  40227c:	47a0      	blx	r4
			drv_gpio_getPinState(DRV_GPIO_PIN_LBO, &lboState);	//poll Low battery out
  40227e:	200f      	movs	r0, #15
  402280:	eb0d 0100 	add.w	r1, sp, r0
  402284:	47a0      	blx	r4
			if(pwSwState == DRV_GPIO_PIN_STATE_LOW)	//check if it is a false wakeup
  402286:	f89d 000e 	ldrb.w	r0, [sp, #14]
  40228a:	2800      	cmp	r0, #0
  40228c:	d1e6      	bne.n	40225c <stateEntry_PowerDown+0xb8>
			{
				if (lboState == DRV_GPIO_PIN_STATE_HIGH)
  40228e:	f89d 300f 	ldrb.w	r3, [sp, #15]
				{
					pwrSwFlag = TRUE;
				}
				else
				{
					lowBatteryBlink();	//the battery is low, blink to indicate
  402292:	4a52      	ldr	r2, [pc, #328]	; (4023dc <stateEntry_PowerDown+0x238>)
			delay_ms(WAKEUP_DELAY);
			drv_gpio_getPinState(DRV_GPIO_PIN_PW_SW, &pwSwState);	//poll the power switch
			drv_gpio_getPinState(DRV_GPIO_PIN_LBO, &lboState);	//poll Low battery out
			if(pwSwState == DRV_GPIO_PIN_STATE_LOW)	//check if it is a false wakeup
			{
				if (lboState == DRV_GPIO_PIN_STATE_HIGH)
  402294:	2b01      	cmp	r3, #1
  402296:	d001      	beq.n	40229c <stateEntry_PowerDown+0xf8>
				{
					pwrSwFlag = TRUE;
				}
				else
				{
					lowBatteryBlink();	//the battery is low, blink to indicate
  402298:	4790      	blx	r2
  40229a:	e7df      	b.n	40225c <stateEntry_PowerDown+0xb8>
 * @param void
 * @return void
 ***********************************************************************************************/
static void PostSleepProcess()
{
	drv_gpio_clear_Int(DRV_GPIO_PIN_PW_SW);	//Clear the interrupt generated by power switch flag
  40229c:	4b50      	ldr	r3, [pc, #320]	; (4023e0 <stateEntry_PowerDown+0x23c>)
  40229e:	4798      	blx	r3
	drv_gpio_initializeAll();
  4022a0:	4b50      	ldr	r3, [pc, #320]	; (4023e4 <stateEntry_PowerDown+0x240>)
  4022a2:	4798      	blx	r3
	initAllUarts();
  4022a4:	4b50      	ldr	r3, [pc, #320]	; (4023e8 <stateEntry_PowerDown+0x244>)
  4022a6:	4798      	blx	r3
	debugPrintString("Exit Sleep mode\r\n");
  4022a8:	4850      	ldr	r0, [pc, #320]	; (4023ec <stateEntry_PowerDown+0x248>)
  4022aa:	47d0      	blx	sl
	SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk;	//enable the systick timer
  4022ac:	4843      	ldr	r0, [pc, #268]	; (4023bc <stateEntry_PowerDown+0x218>)
    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
  4022ae:	4a46      	ldr	r2, [pc, #280]	; (4023c8 <stateEntry_PowerDown+0x224>)
			}
			#endif
		}
		PostSleepProcess();
		//blink BLUE to indicate wake up
		drv_led_activate_timer();
  4022b0:	4b4f      	ldr	r3, [pc, #316]	; (4023f0 <stateEntry_PowerDown+0x24c>)
  4022b2:	2110      	movs	r1, #16
{
	drv_gpio_clear_Int(DRV_GPIO_PIN_PW_SW);	//Clear the interrupt generated by power switch flag
	drv_gpio_initializeAll();
	initAllUarts();
	debugPrintString("Exit Sleep mode\r\n");
	SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk;	//enable the systick timer
  4022b4:	2407      	movs	r4, #7
  4022b6:	6004      	str	r4, [r0, #0]
  4022b8:	6011      	str	r1, [r2, #0]
			}
			#endif
		}
		PostSleepProcess();
		//blink BLUE to indicate wake up
		drv_led_activate_timer();
  4022ba:	4798      	blx	r3
	}
	if (firstBoot == TRUE)
  4022bc:	f898 3000 	ldrb.w	r3, [r8]
  4022c0:	2b00      	cmp	r3, #0
  4022c2:	d13f      	bne.n	402344 <stateEntry_PowerDown+0x1a0>
		drv_gpio_setPinState(quinticConfig[1].resetPin, DRV_GPIO_PIN_STATE_HIGH);
		drv_gpio_setPinState(quinticConfig[2].resetPin, DRV_GPIO_PIN_STATE_HIGH);
		firstBoot = FALSE;
	}
	
	drv_led_set(DRV_LED_BLUE, DRV_LED_SOLID);
  4022c4:	2001      	movs	r0, #1
  4022c6:	4601      	mov	r1, r0
  4022c8:	4b30      	ldr	r3, [pc, #192]	; (40238c <stateEntry_PowerDown+0x1e8>)
	//drv_gpio_setPinState(DRV_GPIO_PIN_JC_EN2, DRV_GPIO_PIN_STATE_LOW);
	toggleJackEnables(DRV_GPIO_PIN_STATE_LOW);
	drv_gpio_setPinState(DRV_GPIO_PIN_BT_PWR_EN, DRV_GPIO_PIN_STATE_HIGH);
	//clear the queue of any messages
	uint32_t numberOfMessages = 0; 
	if(queue_stateMachineEvents != NULL)
  4022ca:	4e4a      	ldr	r6, [pc, #296]	; (4023f4 <stateEntry_PowerDown+0x250>)
		drv_gpio_setPinState(quinticConfig[1].resetPin, DRV_GPIO_PIN_STATE_HIGH);
		drv_gpio_setPinState(quinticConfig[2].resetPin, DRV_GPIO_PIN_STATE_HIGH);
		firstBoot = FALSE;
	}
	
	drv_led_set(DRV_LED_BLUE, DRV_LED_SOLID);
  4022cc:	4798      	blx	r3
	//enable the jacks
	//drv_gpio_setPinState(DRV_GPIO_PIN_JC_EN1, DRV_GPIO_PIN_STATE_LOW);
	//drv_gpio_setPinState(DRV_GPIO_PIN_JC_EN2, DRV_GPIO_PIN_STATE_LOW);
	toggleJackEnables(DRV_GPIO_PIN_STATE_LOW);
  4022ce:	2000      	movs	r0, #0
  4022d0:	9b01      	ldr	r3, [sp, #4]
  4022d2:	4798      	blx	r3
	drv_gpio_setPinState(DRV_GPIO_PIN_BT_PWR_EN, DRV_GPIO_PIN_STATE_HIGH);
  4022d4:	2011      	movs	r0, #17
  4022d6:	2101      	movs	r1, #1
  4022d8:	47a8      	blx	r5
	//clear the queue of any messages
	uint32_t numberOfMessages = 0; 
	if(queue_stateMachineEvents != NULL)
  4022da:	6830      	ldr	r0, [r6, #0]
  4022dc:	b1e8      	cbz	r0, 40231a <stateEntry_PowerDown+0x176>
	{
		numberOfMessages = uxQueueMessagesWaiting(queue_stateMachineEvents); 
  4022de:	4b46      	ldr	r3, [pc, #280]	; (4023f8 <stateEntry_PowerDown+0x254>)
  4022e0:	4798      	blx	r3
	}	
	int i = 0; 
	eventMessage_t eventMessage;
	if(numberOfMessages > 0)
  4022e2:	4605      	mov	r5, r0
  4022e4:	2800      	cmp	r0, #0
  4022e6:	d03f      	beq.n	402368 <stateEntry_PowerDown+0x1c4>
  4022e8:	4f44      	ldr	r7, [pc, #272]	; (4023fc <stateEntry_PowerDown+0x258>)
  4022ea:	2400      	movs	r4, #0
	{
		for(i=0;i<numberOfMessages;i++)
  4022ec:	3401      	adds	r4, #1
		{
			xQueueReceive(queue_stateMachineEvents, &(eventMessage), 10); 						
  4022ee:	6830      	ldr	r0, [r6, #0]
  4022f0:	f8df 8100 	ldr.w	r8, [pc, #256]	; 4023f4 <stateEntry_PowerDown+0x250>
  4022f4:	a904      	add	r1, sp, #16
  4022f6:	220a      	movs	r2, #10
  4022f8:	2300      	movs	r3, #0
  4022fa:	47b8      	blx	r7
	}	
	int i = 0; 
	eventMessage_t eventMessage;
	if(numberOfMessages > 0)
	{
		for(i=0;i<numberOfMessages;i++)
  4022fc:	42ac      	cmp	r4, r5
  4022fe:	d1f5      	bne.n	4022ec <stateEntry_PowerDown+0x148>
  402300:	f8d8 0000 	ldr.w	r0, [r8]
		}
	}
	//TODO check which jacks are connected to determine which IMUs are there	
	
	//send power up complete event
	eventMessage_t msg = {.sysEvent = SYS_EVENT_POWER_UP_COMPLETE, .data = 0};
  402304:	220c      	movs	r2, #12
  402306:	2300      	movs	r3, #0
  402308:	f88d 2014 	strb.w	r2, [sp, #20]
  40230c:	f8ad 3016 	strh.w	r3, [sp, #22]
	if(queue_stateMachineEvents != NULL)
  402310:	b118      	cbz	r0, 40231a <stateEntry_PowerDown+0x176>
	{
		xQueueSendToBack(queue_stateMachineEvents, &msg,5);
  402312:	a905      	add	r1, sp, #20
  402314:	2205      	movs	r2, #5
  402316:	4c3a      	ldr	r4, [pc, #232]	; (402400 <stateEntry_PowerDown+0x25c>)
  402318:	47a0      	blx	r4
	}
		
}
  40231a:	b007      	add	sp, #28
  40231c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	drv_led_set(DRV_LED_OFF, DRV_LED_SOLID);
	
	if (firstBoot == TRUE)
	{
		//Put the BLE's in reset. 
		drv_gpio_setPinState(quinticConfig[0].resetPin, DRV_GPIO_PIN_STATE_LOW);
  402320:	2100      	movs	r1, #0
  402322:	f897 0020 	ldrb.w	r0, [r7, #32]
  402326:	47a8      	blx	r5
		drv_gpio_setPinState(quinticConfig[1].resetPin, DRV_GPIO_PIN_STATE_LOW);
  402328:	2100      	movs	r1, #0
  40232a:	f897 005c 	ldrb.w	r0, [r7, #92]	; 0x5c
  40232e:	47a8      	blx	r5
		drv_gpio_setPinState(quinticConfig[2].resetPin, DRV_GPIO_PIN_STATE_LOW);
  402330:	f897 0098 	ldrb.w	r0, [r7, #152]	; 0x98
  402334:	2100      	movs	r1, #0
  402336:	47a8      	blx	r5
	}
	
	if (firstBoot == FALSE)
  402338:	7833      	ldrb	r3, [r6, #0]
  40233a:	2b00      	cmp	r3, #0
  40233c:	f43f af4c 	beq.w	4021d8 <stateEntry_PowerDown+0x34>
  402340:	4b13      	ldr	r3, [pc, #76]	; (402390 <stateEntry_PowerDown+0x1ec>)
  402342:	9301      	str	r3, [sp, #4]
		//blink BLUE to indicate wake up
		drv_led_activate_timer();
	}
	if (firstBoot == TRUE)
	{
		vTaskDelay(10);
  402344:	4b2f      	ldr	r3, [pc, #188]	; (402404 <stateEntry_PowerDown+0x260>)
  402346:	200a      	movs	r0, #10
  402348:	4798      	blx	r3
		drv_gpio_setPinState(quinticConfig[0].resetPin, DRV_GPIO_PIN_STATE_HIGH);
  40234a:	2101      	movs	r1, #1
  40234c:	f897 0020 	ldrb.w	r0, [r7, #32]
  402350:	47a8      	blx	r5
		drv_gpio_setPinState(quinticConfig[1].resetPin, DRV_GPIO_PIN_STATE_HIGH);
  402352:	2101      	movs	r1, #1
  402354:	f897 005c 	ldrb.w	r0, [r7, #92]	; 0x5c
  402358:	47a8      	blx	r5
		drv_gpio_setPinState(quinticConfig[2].resetPin, DRV_GPIO_PIN_STATE_HIGH);
  40235a:	f897 0098 	ldrb.w	r0, [r7, #152]	; 0x98
  40235e:	2101      	movs	r1, #1
  402360:	47a8      	blx	r5
		firstBoot = FALSE;
  402362:	2300      	movs	r3, #0
  402364:	7033      	strb	r3, [r6, #0]
  402366:	e7ad      	b.n	4022c4 <stateEntry_PowerDown+0x120>
  402368:	6830      	ldr	r0, [r6, #0]
  40236a:	e7cb      	b.n	402304 <stateEntry_PowerDown+0x160>
		while (pwrSwFlag == FALSE)	//Stay in sleep mode until wakeup
		{
			//if first boot, don't go to sleep, wake up. 
			if(firstBoot == true)
			{			
				firstBoot = false; 
  40236c:	2300      	movs	r3, #0
  40236e:	f888 3000 	strb.w	r3, [r8]
	if(queue_stateMachineEvents != NULL)
	{
		xQueueSendToBack(queue_stateMachineEvents, &msg,5);
	}
		
}
  402372:	b007      	add	sp, #28
  402374:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  402378:	200000f0 	.word	0x200000f0
  40237c:	2000336b 	.word	0x2000336b
  402380:	200000b4 	.word	0x200000b4
  402384:	20000264 	.word	0x20000264
  402388:	004087b1 	.word	0x004087b1
  40238c:	00400699 	.word	0x00400699
  402390:	0040a4a1 	.word	0x0040a4a1
  402394:	0040ac2d 	.word	0x0040ac2d
  402398:	200002a0 	.word	0x200002a0
  40239c:	200002dc 	.word	0x200002dc
  4023a0:	00409a61 	.word	0x00409a61
  4023a4:	200001a0 	.word	0x200001a0
  4023a8:	004015c1 	.word	0x004015c1
  4023ac:	200001ac 	.word	0x200001ac
  4023b0:	00415b50 	.word	0x00415b50
  4023b4:	00405559 	.word	0x00405559
  4023b8:	20003369 	.word	0x20003369
  4023bc:	e000e010 	.word	0xe000e010
  4023c0:	00407d1d 	.word	0x00407d1d
  4023c4:	00408959 	.word	0x00408959
  4023c8:	e000e100 	.word	0xe000e100
  4023cc:	004088f9 	.word	0x004088f9
  4023d0:	00408829 	.word	0x00408829
  4023d4:	20000085 	.word	0x20000085
  4023d8:	0082ca25 	.word	0x0082ca25
  4023dc:	00402175 	.word	0x00402175
  4023e0:	004088e5 	.word	0x004088e5
  4023e4:	0040874d 	.word	0x0040874d
  4023e8:	00407ce1 	.word	0x00407ce1
  4023ec:	00415b68 	.word	0x00415b68
  4023f0:	00400789 	.word	0x00400789
  4023f4:	20003374 	.word	0x20003374
  4023f8:	00406c89 	.word	0x00406c89
  4023fc:	00406b35 	.word	0x00406b35
  402400:	00406979 	.word	0x00406979
  402404:	004072ed 	.word	0x004072ed
  402408:	004008c9 	.word	0x004008c9
  40240c:	0040b275 	.word	0x0040b275
  402410:	00408871 	.word	0x00408871

00402414 <processEvent>:
	return currentSystemState;
}
//static functions
//event processor
void processEvent(eventMessage_t eventMsg)
{
  402414:	b510      	push	{r4, lr}
  402416:	b082      	sub	sp, #8
	switch(eventMsg.sysEvent)
  402418:	b2c3      	uxtb	r3, r0
	return currentSystemState;
}
//static functions
//event processor
void processEvent(eventMessage_t eventMsg)
{
  40241a:	9001      	str	r0, [sp, #4]
	switch(eventMsg.sysEvent)
  40241c:	2b0d      	cmp	r3, #13
  40241e:	d82f      	bhi.n	402480 <processEvent+0x6c>
  402420:	e8df f013 	tbh	[pc, r3, lsl #1]
  402424:	009b008c 	.word	0x009b008c
  402428:	00ba00ae 	.word	0x00ba00ae
  40242c:	003c0034 	.word	0x003c0034
  402430:	00ba0059 	.word	0x00ba0059
  402434:	006a00ba 	.word	0x006a00ba
  402438:	007e000e 	.word	0x007e000e
  40243c:	00830030 	.word	0x00830030
			stateEntry_PowerDown(); 		
		}
		break;
		case SYS_EVENT_RESET_COMPLETE:
		{
			if(currentSystemState != SYS_STATE_RESET)
  402440:	4b82      	ldr	r3, [pc, #520]	; (40264c <processEvent+0x238>)
  402442:	781b      	ldrb	r3, [r3, #0]
  402444:	2b02      	cmp	r3, #2
  402446:	d11b      	bne.n	402480 <processEvent+0x6c>
  402448:	f8bd 2006 	ldrh.w	r2, [sp, #6]
  40244c:	4980      	ldr	r1, [pc, #512]	; (402650 <processEvent+0x23c>)
			int z;
			for (z=0; z<3; z++)
			{
				if (eventMsg.data == z)	//check for which Quintic is successfully initialized
				{
					ResetStatus |= (1u<<(z));	//Save the result to a result flag
  40244e:	2301      	movs	r3, #1
  402450:	4093      	lsls	r3, r2
  402452:	b2d8      	uxtb	r0, r3
  402454:	780b      	ldrb	r3, [r1, #0]
			}
			//QResetCount++;	//Check if all three Quintics are past the initialization process
			int z;
			for (z=0; z<3; z++)
			{
				if (eventMsg.data == z)	//check for which Quintic is successfully initialized
  402456:	b11a      	cbz	r2, 402460 <processEvent+0x4c>
  402458:	2a01      	cmp	r2, #1
  40245a:	d001      	beq.n	402460 <processEvent+0x4c>
  40245c:	2a02      	cmp	r2, #2
  40245e:	d100      	bne.n	402462 <processEvent+0x4e>
				{
					ResetStatus |= (1u<<(z));	//Save the result to a result flag
  402460:	4303      	orrs	r3, r0
				}
			}
			//go to the idle state
			if (QResetCount < 3)	//If not all Quintic were initialized,
  402462:	4a7c      	ldr	r2, [pc, #496]	; (402654 <processEvent+0x240>)
  402464:	700b      	strb	r3, [r1, #0]
  402466:	7812      	ldrb	r2, [r2, #0]
  402468:	2a02      	cmp	r2, #2
  40246a:	f240 80e0 	bls.w	40262e <processEvent+0x21a>
			{
				CheckInitQuintic();	// pass the init command to the next one
			}
			else
			{
				if (ResetStatus == vExpectedResetStatus)	//Check if all of them were initialized
  40246e:	4a7a      	ldr	r2, [pc, #488]	; (402658 <processEvent+0x244>)
  402470:	7812      	ldrb	r2, [r2, #0]
  402472:	429a      	cmp	r2, r3
  402474:	f000 80d8 	beq.w	402628 <processEvent+0x214>
					//go to the idle state
					stateEntry_Idle();
				}
				else
				{
					task_stateMachine_EnqueueEvent(SYS_EVENT_RESET_FAILED, 0);	//Assert Reset failed as one or more failed to initialize
  402478:	200b      	movs	r0, #11
  40247a:	2100      	movs	r1, #0
  40247c:	4b77      	ldr	r3, [pc, #476]	; (40265c <processEvent+0x248>)
  40247e:	4798      	blx	r3
		break;
		default:
		//do nothing, should never reach here
		break; 										
	}
}
  402480:	b002      	add	sp, #8
  402482:	bd10      	pop	{r4, pc}
			}
		}
		break;
		case SYS_EVENT_POWER_UP_COMPLETE:
		{
			if(currentSystemState != SYS_STATE_POWER_DOWN)
  402484:	4b71      	ldr	r3, [pc, #452]	; (40264c <processEvent+0x238>)
  402486:	781b      	ldrb	r3, [r3, #0]
  402488:	2b01      	cmp	r3, #1
  40248a:	d1f9      	bne.n	402480 <processEvent+0x6c>
			{
				//we should not have gotten this event here
				break;
			}
			//first thing to do after the power up is reload config settings 
			if(reloadConfigSettings() == STATUS_PASS)
  40248c:	4b74      	ldr	r3, [pc, #464]	; (402660 <processEvent+0x24c>)
  40248e:	4798      	blx	r3
  402490:	b9e8      	cbnz	r0, 4024ce <processEvent+0xba>
			{	
				if(task_debugLog_OpenFile() == STATUS_PASS)
  402492:	4b74      	ldr	r3, [pc, #464]	; (402664 <processEvent+0x250>)
  402494:	4798      	blx	r3
  402496:	2800      	cmp	r0, #0
  402498:	d06f      	beq.n	40257a <processEvent+0x166>
  40249a:	e018      	b.n	4024ce <processEvent+0xba>
			stateEntry_Error(); 			
		}
		break;
		case SYS_EVENT_SD_FILE_ERROR:
		{
			if (currentSystemState == SYS_STATE_RESET)
  40249c:	4c6b      	ldr	r4, [pc, #428]	; (40264c <processEvent+0x238>)
  40249e:	7823      	ldrb	r3, [r4, #0]
  4024a0:	2b02      	cmp	r3, #2
  4024a2:	f000 809a 	beq.w	4025da <processEvent+0x1c6>
			{
				stateExit_Reset();
			}
			if (currentSystemState == SYS_STATE_RECORDING)
  4024a6:	2b04      	cmp	r3, #4
  4024a8:	f000 8094 	beq.w	4025d4 <processEvent+0x1c0>
			{
				stateExit_Recording();
			}
			else if (currentSystemState == SYS_STATE_GET_ACCEL_DATA)
  4024ac:	2b06      	cmp	r3, #6
  4024ae:	f000 808f 	beq.w	4025d0 <processEvent+0x1bc>
			{
				stateExit_GetAccelData();
				stateExit_Recording();
			}
			//SD card was removed clear all file open / loaded flags
			brainSettings.isLoaded = 0;
  4024b2:	4a6d      	ldr	r2, [pc, #436]	; (402668 <processEvent+0x254>)
			//get the SD card task to actually close the files. 
			task_sdCard_CloseFile();
  4024b4:	4b6d      	ldr	r3, [pc, #436]	; (40266c <processEvent+0x258>)
			{
				stateExit_GetAccelData();
				stateExit_Recording();
			}
			//SD card was removed clear all file open / loaded flags
			brainSettings.isLoaded = 0;
  4024b6:	2400      	movs	r4, #0
  4024b8:	6014      	str	r4, [r2, #0]
			//get the SD card task to actually close the files. 
			task_sdCard_CloseFile();
  4024ba:	4798      	blx	r3
			task_debugLog_CloseFile(); 
  4024bc:	4b6c      	ldr	r3, [pc, #432]	; (402670 <processEvent+0x25c>)
  4024be:	4798      	blx	r3
			vTaskDelay(200); //wait for the files to get closed in the SD card task. 
  4024c0:	20c8      	movs	r0, #200	; 0xc8
  4024c2:	4b6c      	ldr	r3, [pc, #432]	; (402674 <processEvent+0x260>)
  4024c4:	4798      	blx	r3
			f_mount(LUN_ID_SD_MMC_0_MEM, NULL);
  4024c6:	4620      	mov	r0, r4
  4024c8:	4621      	mov	r1, r4
  4024ca:	4b6b      	ldr	r3, [pc, #428]	; (402678 <processEvent+0x264>)
  4024cc:	4798      	blx	r3
			stateEntry_Error(); 
  4024ce:	4b6b      	ldr	r3, [pc, #428]	; (40267c <processEvent+0x268>)
  4024d0:	4798      	blx	r3
		break;
		default:
		//do nothing, should never reach here
		break; 										
	}
}
  4024d2:	b002      	add	sp, #8
  4024d4:	bd10      	pop	{r4, pc}
			 
		}
		break;
		case SYS_EVENT_IMU_DISCONNECT:
		{		
			if(currentSystemState == SYS_STATE_POWER_DOWN)
  4024d6:	4c5d      	ldr	r4, [pc, #372]	; (40264c <processEvent+0x238>)
  4024d8:	7823      	ldrb	r3, [r4, #0]
  4024da:	f003 02fb 	and.w	r2, r3, #251	; 0xfb
  4024de:	2a01      	cmp	r2, #1
  4024e0:	d0ce      	beq.n	402480 <processEvent+0x6c>
			}
		}		
		case SYS_EVENT_OVER_CURRENT:
		case SYS_EVENT_BLE_ERROR:
		case SYS_EVENT_JACK_DETECT:
		if (currentSystemState == SYS_STATE_RESET)
  4024e2:	2b02      	cmp	r3, #2
  4024e4:	d06c      	beq.n	4025c0 <processEvent+0x1ac>
		{
			stateExit_Reset();
		}
		if(currentSystemState == SYS_STATE_RECORDING)
  4024e6:	2b04      	cmp	r3, #4
  4024e8:	d003      	beq.n	4024f2 <processEvent+0xde>
		{
			//stop recording
			stateExit_Recording();
		}
		else if (currentSystemState == SYS_STATE_GET_ACCEL_DATA)
  4024ea:	2b06      	cmp	r3, #6
  4024ec:	d1ef      	bne.n	4024ce <processEvent+0xba>
		{
			stateExit_GetAccelData();
  4024ee:	4b64      	ldr	r3, [pc, #400]	; (402680 <processEvent+0x26c>)
  4024f0:	4798      	blx	r3
			stateExit_Recording();
  4024f2:	4b64      	ldr	r3, [pc, #400]	; (402684 <processEvent+0x270>)
  4024f4:	4798      	blx	r3
  4024f6:	e7ea      	b.n	4024ce <processEvent+0xba>
			stateEntry_Error(); 
		}
		break;
		case SYS_EVENT_LOW_BATTERY:
		{
			if(currentSystemState == SYS_STATE_RECORDING)
  4024f8:	4b54      	ldr	r3, [pc, #336]	; (40264c <processEvent+0x238>)
  4024fa:	781b      	ldrb	r3, [r3, #0]
  4024fc:	2b04      	cmp	r3, #4
  4024fe:	f000 8081 	beq.w	402604 <processEvent+0x1f0>
			{
				//stop recording
				stateExit_Recording();
			}
			else if (currentSystemState == SYS_STATE_GET_ACCEL_DATA)
  402502:	2b06      	cmp	r3, #6
  402504:	d07c      	beq.n	402600 <processEvent+0x1ec>
			{
				stateExit_GetAccelData();
				stateExit_Recording();
			}
			else if (currentSystemState == SYS_STATE_IDLE)
  402506:	2b03      	cmp	r3, #3
  402508:	d057      	beq.n	4025ba <processEvent+0x1a6>
			{
				stateExit_Idle();
			}
			else if (currentSystemState == SYS_STATE_ERROR)
  40250a:	2b05      	cmp	r3, #5
  40250c:	f000 8089 	beq.w	402622 <processEvent+0x20e>
			{
				stateExit_Error();
			}
			else if (currentSystemState == SYS_STATE_RESET)
  402510:	2b02      	cmp	r3, #2
  402512:	d07a      	beq.n	40260a <processEvent+0x1f6>
			{
				stateExit_Reset();
			}
			//go to the power down state. 
			lowBatteryBlink();	
  402514:	4b5c      	ldr	r3, [pc, #368]	; (402688 <processEvent+0x274>)
  402516:	4798      	blx	r3
			stateEntry_PowerDown(); 		
  402518:	4b5c      	ldr	r3, [pc, #368]	; (40268c <processEvent+0x278>)
  40251a:	4798      	blx	r3
		break;
		default:
		//do nothing, should never reach here
		break; 										
	}
}
  40251c:	b002      	add	sp, #8
  40251e:	bd10      	pop	{r4, pc}
		}		
		stateEntry_Error(); 
		break;
		case SYS_EVENT_RESET_FAILED:
		{
			if(currentSystemState == SYS_STATE_RECORDING)
  402520:	4b4a      	ldr	r3, [pc, #296]	; (40264c <processEvent+0x238>)
  402522:	781b      	ldrb	r3, [r3, #0]
  402524:	2b04      	cmp	r3, #4
  402526:	d1d2      	bne.n	4024ce <processEvent+0xba>
  402528:	e7e3      	b.n	4024f2 <processEvent+0xde>
			}
		}		
		break; 		
		case SYS_EVENT_GET_ACCEL_DATA_COMPLETE:
		{
			if(currentSystemState == SYS_STATE_GET_ACCEL_DATA)
  40252a:	4b48      	ldr	r3, [pc, #288]	; (40264c <processEvent+0x238>)
  40252c:	781b      	ldrb	r3, [r3, #0]
  40252e:	2b06      	cmp	r3, #6
  402530:	d1a6      	bne.n	402480 <processEvent+0x6c>
			{
				stateExit_GetAccelData(); 
  402532:	4b53      	ldr	r3, [pc, #332]	; (402680 <processEvent+0x26c>)
  402534:	4798      	blx	r3
				stateEntry_Recording(); 				
  402536:	4b56      	ldr	r3, [pc, #344]	; (402690 <processEvent+0x27c>)
  402538:	4798      	blx	r3
  40253a:	e7a1      	b.n	402480 <processEvent+0x6c>
{
	switch(eventMsg.sysEvent)
	{
		case SYS_EVENT_POWER_SWITCH:
		{
			if(currentSystemState == SYS_STATE_RECORDING)
  40253c:	4b43      	ldr	r3, [pc, #268]	; (40264c <processEvent+0x238>)
  40253e:	781b      	ldrb	r3, [r3, #0]
  402540:	2b04      	cmp	r3, #4
  402542:	d05a      	beq.n	4025fa <processEvent+0x1e6>
			{
				//stop recording, then go to the off state. 
				stateExit_Recording(); 
			}
			else if (currentSystemState == SYS_STATE_GET_ACCEL_DATA)
  402544:	2b06      	cmp	r3, #6
  402546:	d056      	beq.n	4025f6 <processEvent+0x1e2>
			{
				stateExit_GetAccelData(); 
				stateExit_Recording(); 
			}			
			else if (currentSystemState == SYS_STATE_RESET)
  402548:	2b02      	cmp	r3, #2
  40254a:	d02f      	beq.n	4025ac <processEvent+0x198>
			{				
				stateExit_Reset();
			}
			else if (currentSystemState == SYS_STATE_IDLE)
  40254c:	2b03      	cmp	r3, #3
  40254e:	d074      	beq.n	40263a <processEvent+0x226>
			{
				stateExit_Idle();
			}
			else if (currentSystemState == SYS_STATE_ERROR)
  402550:	2b05      	cmp	r3, #5
  402552:	d078      	beq.n	402646 <processEvent+0x232>
			{
				stateExit_Error();
			}
			else if(currentSystemState == SYS_STATE_POWER_DOWN)
  402554:	2b01      	cmp	r3, #1
  402556:	d1df      	bne.n	402518 <processEvent+0x104>
  402558:	e792      	b.n	402480 <processEvent+0x6c>
			}
		}
		break;
		case SYS_EVENT_RESET_SWITCH:
		{
			if(currentSystemState == SYS_STATE_RECORDING)
  40255a:	4b3c      	ldr	r3, [pc, #240]	; (40264c <processEvent+0x238>)
  40255c:	781b      	ldrb	r3, [r3, #0]
  40255e:	2b04      	cmp	r3, #4
  402560:	d046      	beq.n	4025f0 <processEvent+0x1dc>
			{
				//stop recording
				stateExit_Recording();
			}
			else if (currentSystemState == SYS_STATE_GET_ACCEL_DATA)
  402562:	2b06      	cmp	r3, #6
  402564:	d042      	beq.n	4025ec <processEvent+0x1d8>
			{
				stateExit_GetAccelData();
				stateExit_Recording();
			}
			else if(currentSystemState == SYS_STATE_RESET)
  402566:	2b02      	cmp	r3, #2
  402568:	d019      	beq.n	40259e <processEvent+0x18a>
				if (ResetHandle != NULL)
				{
					vTaskDelete(ResetHandle);
				}
			}
			else if (currentSystemState == SYS_STATE_IDLE)
  40256a:	2b03      	cmp	r3, #3
  40256c:	d062      	beq.n	402634 <processEvent+0x220>
			{
				stateExit_Idle();
			}
			else if (currentSystemState == SYS_STATE_ERROR)
  40256e:	2b05      	cmp	r3, #5
  402570:	d066      	beq.n	402640 <processEvent+0x22c>
			{
				stateExit_Error();
			}
						 
			//start the reset process... 
			if (brainSettings.isLoaded == 1)
  402572:	4b3d      	ldr	r3, [pc, #244]	; (402668 <processEvent+0x254>)
  402574:	681b      	ldr	r3, [r3, #0]
  402576:	2b01      	cmp	r3, #1
  402578:	d1a9      	bne.n	4024ce <processEvent+0xba>
			{
				stateEntry_Reset();
  40257a:	4b46      	ldr	r3, [pc, #280]	; (402694 <processEvent+0x280>)
  40257c:	4798      	blx	r3
  40257e:	e77f      	b.n	402480 <processEvent+0x6c>
			stateEntry_PowerDown(); 	
		}
		break;
		case SYS_EVENT_RECORD_SWITCH:
		{
			if(currentSystemState == SYS_STATE_IDLE)
  402580:	4b32      	ldr	r3, [pc, #200]	; (40264c <processEvent+0x238>)
  402582:	781b      	ldrb	r3, [r3, #0]
  402584:	2b03      	cmp	r3, #3
  402586:	d047      	beq.n	402618 <processEvent+0x204>
				stateExit_Idle();
				//go to get accel data first. 
				stateEntry_GetAccelData();
				//go to recording state
			}
			else if(currentSystemState == SYS_STATE_RECORDING)
  402588:	2b04      	cmp	r3, #4
  40258a:	f47f af79 	bne.w	402480 <processEvent+0x6c>
			{
				//stop recording
				stateExit_Recording();
  40258e:	4b3d      	ldr	r3, [pc, #244]	; (402684 <processEvent+0x270>)
  402590:	4798      	blx	r3
				//go to IDLE state
				stateEntry_Idle(); 
  402592:	4b41      	ldr	r3, [pc, #260]	; (402698 <processEvent+0x284>)
  402594:	4798      	blx	r3
  402596:	e773      	b.n	402480 <processEvent+0x6c>
  402598:	4c2c      	ldr	r4, [pc, #176]	; (40264c <processEvent+0x238>)
  40259a:	7823      	ldrb	r3, [r4, #0]
  40259c:	e7a1      	b.n	4024e2 <processEvent+0xce>
			}
			else if(currentSystemState == SYS_STATE_RESET)
			{

				//Delete the on going Reset task to re-spawn again.
				if (ResetHandle != NULL)
  40259e:	4b3f      	ldr	r3, [pc, #252]	; (40269c <processEvent+0x288>)
  4025a0:	6818      	ldr	r0, [r3, #0]
  4025a2:	2800      	cmp	r0, #0
  4025a4:	d0e5      	beq.n	402572 <processEvent+0x15e>
				{
					vTaskDelete(ResetHandle);
  4025a6:	4b3e      	ldr	r3, [pc, #248]	; (4026a0 <processEvent+0x28c>)
  4025a8:	4798      	blx	r3
  4025aa:	e7e2      	b.n	402572 <processEvent+0x15e>
 * @param void
 * @return void
 ***********************************************************************************************/
void stateExit_Reset()
{
	if (ResetHandle != NULL)
  4025ac:	4b3b      	ldr	r3, [pc, #236]	; (40269c <processEvent+0x288>)
  4025ae:	6818      	ldr	r0, [r3, #0]
  4025b0:	2800      	cmp	r0, #0
  4025b2:	d0b1      	beq.n	402518 <processEvent+0x104>
	{
		vTaskDelete(ResetHandle);
  4025b4:	4b3a      	ldr	r3, [pc, #232]	; (4026a0 <processEvent+0x28c>)
  4025b6:	4798      	blx	r3
  4025b8:	e7ae      	b.n	402518 <processEvent+0x104>
				stateExit_GetAccelData();
				stateExit_Recording();
			}
			else if (currentSystemState == SYS_STATE_IDLE)
			{
				stateExit_Idle();
  4025ba:	4b3a      	ldr	r3, [pc, #232]	; (4026a4 <processEvent+0x290>)
  4025bc:	4798      	blx	r3
  4025be:	e7a9      	b.n	402514 <processEvent+0x100>
 * @param void
 * @return void
 ***********************************************************************************************/
void stateExit_Reset()
{
	if (ResetHandle != NULL)
  4025c0:	4b36      	ldr	r3, [pc, #216]	; (40269c <processEvent+0x288>)
  4025c2:	6818      	ldr	r0, [r3, #0]
  4025c4:	2800      	cmp	r0, #0
  4025c6:	d082      	beq.n	4024ce <processEvent+0xba>
	{
		vTaskDelete(ResetHandle);
  4025c8:	4b35      	ldr	r3, [pc, #212]	; (4026a0 <processEvent+0x28c>)
  4025ca:	4798      	blx	r3
  4025cc:	7823      	ldrb	r3, [r4, #0]
  4025ce:	e78a      	b.n	4024e6 <processEvent+0xd2>
			{
				stateExit_Recording();
			}
			else if (currentSystemState == SYS_STATE_GET_ACCEL_DATA)
			{
				stateExit_GetAccelData();
  4025d0:	4b2b      	ldr	r3, [pc, #172]	; (402680 <processEvent+0x26c>)
  4025d2:	4798      	blx	r3
				stateExit_Recording();
  4025d4:	4b2b      	ldr	r3, [pc, #172]	; (402684 <processEvent+0x270>)
  4025d6:	4798      	blx	r3
  4025d8:	e76b      	b.n	4024b2 <processEvent+0x9e>
 * @param void
 * @return void
 ***********************************************************************************************/
void stateExit_Reset()
{
	if (ResetHandle != NULL)
  4025da:	4b30      	ldr	r3, [pc, #192]	; (40269c <processEvent+0x288>)
  4025dc:	6818      	ldr	r0, [r3, #0]
  4025de:	2800      	cmp	r0, #0
  4025e0:	f43f af67 	beq.w	4024b2 <processEvent+0x9e>
	{
		vTaskDelete(ResetHandle);
  4025e4:	4b2e      	ldr	r3, [pc, #184]	; (4026a0 <processEvent+0x28c>)
  4025e6:	4798      	blx	r3
  4025e8:	7823      	ldrb	r3, [r4, #0]
  4025ea:	e75c      	b.n	4024a6 <processEvent+0x92>
				//stop recording
				stateExit_Recording();
			}
			else if (currentSystemState == SYS_STATE_GET_ACCEL_DATA)
			{
				stateExit_GetAccelData();
  4025ec:	4b24      	ldr	r3, [pc, #144]	; (402680 <processEvent+0x26c>)
  4025ee:	4798      	blx	r3
				stateExit_Recording();
  4025f0:	4b24      	ldr	r3, [pc, #144]	; (402684 <processEvent+0x270>)
  4025f2:	4798      	blx	r3
  4025f4:	e7bd      	b.n	402572 <processEvent+0x15e>
				//stop recording, then go to the off state. 
				stateExit_Recording(); 
			}
			else if (currentSystemState == SYS_STATE_GET_ACCEL_DATA)
			{
				stateExit_GetAccelData(); 
  4025f6:	4b22      	ldr	r3, [pc, #136]	; (402680 <processEvent+0x26c>)
  4025f8:	4798      	blx	r3
				stateExit_Recording(); 
  4025fa:	4b22      	ldr	r3, [pc, #136]	; (402684 <processEvent+0x270>)
  4025fc:	4798      	blx	r3
  4025fe:	e78b      	b.n	402518 <processEvent+0x104>
				//stop recording
				stateExit_Recording();
			}
			else if (currentSystemState == SYS_STATE_GET_ACCEL_DATA)
			{
				stateExit_GetAccelData();
  402600:	4b1f      	ldr	r3, [pc, #124]	; (402680 <processEvent+0x26c>)
  402602:	4798      	blx	r3
				stateExit_Recording();
  402604:	4b1f      	ldr	r3, [pc, #124]	; (402684 <processEvent+0x270>)
  402606:	4798      	blx	r3
  402608:	e784      	b.n	402514 <processEvent+0x100>
 * @param void
 * @return void
 ***********************************************************************************************/
void stateExit_Reset()
{
	if (ResetHandle != NULL)
  40260a:	4b24      	ldr	r3, [pc, #144]	; (40269c <processEvent+0x288>)
  40260c:	6818      	ldr	r0, [r3, #0]
  40260e:	2800      	cmp	r0, #0
  402610:	d080      	beq.n	402514 <processEvent+0x100>
	{
		vTaskDelete(ResetHandle);
  402612:	4b23      	ldr	r3, [pc, #140]	; (4026a0 <processEvent+0x28c>)
  402614:	4798      	blx	r3
  402616:	e77d      	b.n	402514 <processEvent+0x100>
		case SYS_EVENT_RECORD_SWITCH:
		{
			if(currentSystemState == SYS_STATE_IDLE)
			{
				//start recording
				stateExit_Idle();
  402618:	4b22      	ldr	r3, [pc, #136]	; (4026a4 <processEvent+0x290>)
  40261a:	4798      	blx	r3
				//go to get accel data first. 
				stateEntry_GetAccelData();
  40261c:	4b22      	ldr	r3, [pc, #136]	; (4026a8 <processEvent+0x294>)
  40261e:	4798      	blx	r3
  402620:	e72e      	b.n	402480 <processEvent+0x6c>
			{
				stateExit_Idle();
			}
			else if (currentSystemState == SYS_STATE_ERROR)
			{
				stateExit_Error();
  402622:	4b22      	ldr	r3, [pc, #136]	; (4026ac <processEvent+0x298>)
  402624:	4798      	blx	r3
  402626:	e775      	b.n	402514 <processEvent+0x100>
			else
			{
				if (ResetStatus == vExpectedResetStatus)	//Check if all of them were initialized
				{
					//go to the idle state
					stateEntry_Idle();
  402628:	4b1b      	ldr	r3, [pc, #108]	; (402698 <processEvent+0x284>)
  40262a:	4798      	blx	r3
  40262c:	e728      	b.n	402480 <processEvent+0x6c>
				}
			}
			//go to the idle state
			if (QResetCount < 3)	//If not all Quintic were initialized,
			{
				CheckInitQuintic();	// pass the init command to the next one
  40262e:	4b20      	ldr	r3, [pc, #128]	; (4026b0 <processEvent+0x29c>)
  402630:	4798      	blx	r3
  402632:	e725      	b.n	402480 <processEvent+0x6c>
					vTaskDelete(ResetHandle);
				}
			}
			else if (currentSystemState == SYS_STATE_IDLE)
			{
				stateExit_Idle();
  402634:	4b1b      	ldr	r3, [pc, #108]	; (4026a4 <processEvent+0x290>)
  402636:	4798      	blx	r3
  402638:	e79b      	b.n	402572 <processEvent+0x15e>
			{				
				stateExit_Reset();
			}
			else if (currentSystemState == SYS_STATE_IDLE)
			{
				stateExit_Idle();
  40263a:	4b1a      	ldr	r3, [pc, #104]	; (4026a4 <processEvent+0x290>)
  40263c:	4798      	blx	r3
  40263e:	e76b      	b.n	402518 <processEvent+0x104>
			{
				stateExit_Idle();
			}
			else if (currentSystemState == SYS_STATE_ERROR)
			{
				stateExit_Error();
  402640:	4b1a      	ldr	r3, [pc, #104]	; (4026ac <processEvent+0x298>)
  402642:	4798      	blx	r3
  402644:	e795      	b.n	402572 <processEvent+0x15e>
			{
				stateExit_Idle();
			}
			else if (currentSystemState == SYS_STATE_ERROR)
			{
				stateExit_Error();
  402646:	4b19      	ldr	r3, [pc, #100]	; (4026ac <processEvent+0x298>)
  402648:	4798      	blx	r3
  40264a:	e765      	b.n	402518 <processEvent+0x104>
  40264c:	2000336b 	.word	0x2000336b
  402650:	20003371 	.word	0x20003371
  402654:	2000336a 	.word	0x2000336a
  402658:	20003368 	.word	0x20003368
  40265c:	00401a99 	.word	0x00401a99
  402660:	00401ee9 	.word	0x00401ee9
  402664:	00401665 	.word	0x00401665
  402668:	200001ac 	.word	0x200001ac
  40266c:	00401579 	.word	0x00401579
  402670:	004015c1 	.word	0x004015c1
  402674:	004072ed 	.word	0x004072ed
  402678:	00405559 	.word	0x00405559
  40267c:	00401d9d 	.word	0x00401d9d
  402680:	00401ec9 	.word	0x00401ec9
  402684:	00401ced 	.word	0x00401ced
  402688:	00402175 	.word	0x00402175
  40268c:	004021a5 	.word	0x004021a5
  402690:	00401c9d 	.word	0x00401c9d
  402694:	00401c35 	.word	0x00401c35
  402698:	00401d2d 	.word	0x00401d2d
  40269c:	20003378 	.word	0x20003378
  4026a0:	00406fad 	.word	0x00406fad
  4026a4:	00401d7d 	.word	0x00401d7d
  4026a8:	00401e19 	.word	0x00401e19
  4026ac:	00401df9 	.word	0x00401df9
  4026b0:	00401af9 	.word	0x00401af9

004026b4 <task_stateMachineHandler>:
	sdInsertWaitTimeoutFlag = TRUE;
}

//task to handle the events
void task_stateMachineHandler(void *pvParameters)
{
  4026b4:	b5f0      	push	{r4, r5, r6, r7, lr}
  4026b6:	b085      	sub	sp, #20
	//Start Idle-time out timer 
	TimeOutTimer = xTimerCreate("Time Out Timer", (MAX_IDLE_TIMEOUT/portTICK_RATE_MS), pdFALSE, NULL, vTimeOutTimerCallback);
  4026b8:	4b1a      	ldr	r3, [pc, #104]	; (402724 <task_stateMachineHandler+0x70>)
  4026ba:	9300      	str	r3, [sp, #0]
  4026bc:	2200      	movs	r2, #0
  4026be:	4613      	mov	r3, r2
  4026c0:	4919      	ldr	r1, [pc, #100]	; (402728 <task_stateMachineHandler+0x74>)
  4026c2:	481a      	ldr	r0, [pc, #104]	; (40272c <task_stateMachineHandler+0x78>)
  4026c4:	4c1a      	ldr	r4, [pc, #104]	; (402730 <task_stateMachineHandler+0x7c>)
  4026c6:	47a0      	blx	r4
  4026c8:	4b1a      	ldr	r3, [pc, #104]	; (402734 <task_stateMachineHandler+0x80>)
  4026ca:	4601      	mov	r1, r0
  4026cc:	6018      	str	r0, [r3, #0]
	if (TimeOutTimer == NULL)
  4026ce:	b328      	cbz	r0, 40271c <task_stateMachineHandler+0x68>
	{
		printf("Failed to create timer task code %d\r\n", TimeOutTimer);
	}	
	queue_stateMachineEvents = xQueueCreate( 10, sizeof(eventMessage_t));
  4026d0:	200a      	movs	r0, #10
  4026d2:	2104      	movs	r1, #4
  4026d4:	4b18      	ldr	r3, [pc, #96]	; (402738 <task_stateMachineHandler+0x84>)
  4026d6:	4c19      	ldr	r4, [pc, #100]	; (40273c <task_stateMachineHandler+0x88>)
  4026d8:	4798      	blx	r3
  4026da:	6020      	str	r0, [r4, #0]
	if(queue_stateMachineEvents == 0)
  4026dc:	b1c8      	cbz	r0, 402712 <task_stateMachineHandler+0x5e>
	{
		// Queue was not created this is an error!
		debugPrintString("an error has occurred, state machine queue creation failed. \r\n");
		return;
	}	
	eventMessage_t eventMessage = {.sysEvent = SYS_EVENT_POWER_SWITCH, .data = 0x0000}; 
  4026de:	2500      	movs	r5, #0
	//from start immediately put the system into power down mode. 
	xQueueSendToBack( queue_stateMachineEvents,( void * ) &eventMessage,5); 
  4026e0:	462b      	mov	r3, r5
  4026e2:	4e17      	ldr	r6, [pc, #92]	; (402740 <task_stateMachineHandler+0x8c>)
	{
		// Queue was not created this is an error!
		debugPrintString("an error has occurred, state machine queue creation failed. \r\n");
		return;
	}	
	eventMessage_t eventMessage = {.sysEvent = SYS_EVENT_POWER_SWITCH, .data = 0x0000}; 
  4026e4:	f88d 500c 	strb.w	r5, [sp, #12]
	//from start immediately put the system into power down mode. 
	xQueueSendToBack( queue_stateMachineEvents,( void * ) &eventMessage,5); 
  4026e8:	a903      	add	r1, sp, #12
  4026ea:	2205      	movs	r2, #5
	{
		// Queue was not created this is an error!
		debugPrintString("an error has occurred, state machine queue creation failed. \r\n");
		return;
	}	
	eventMessage_t eventMessage = {.sysEvent = SYS_EVENT_POWER_SWITCH, .data = 0x0000}; 
  4026ec:	f8ad 500e 	strh.w	r5, [sp, #14]
  4026f0:	4f14      	ldr	r7, [pc, #80]	; (402744 <task_stateMachineHandler+0x90>)
  4026f2:	4d15      	ldr	r5, [pc, #84]	; (402748 <task_stateMachineHandler+0x94>)
	//from start immediately put the system into power down mode. 
	xQueueSendToBack( queue_stateMachineEvents,( void * ) &eventMessage,5); 
  4026f4:	47b0      	blx	r6
  4026f6:	4e15      	ldr	r6, [pc, #84]	; (40274c <task_stateMachineHandler+0x98>)
  4026f8:	e001      	b.n	4026fe <task_stateMachineHandler+0x4a>
	{
		if(xQueueReceive(queue_stateMachineEvents, &(eventMessage), 100) == TRUE)
		{
			processEvent(eventMessage); 
		}
		vTaskDelay(50); 	
  4026fa:	2032      	movs	r0, #50	; 0x32
  4026fc:	47a8      	blx	r5
	eventMessage_t eventMessage = {.sysEvent = SYS_EVENT_POWER_SWITCH, .data = 0x0000}; 
	//from start immediately put the system into power down mode. 
	xQueueSendToBack( queue_stateMachineEvents,( void * ) &eventMessage,5); 
	while(1)
	{
		if(xQueueReceive(queue_stateMachineEvents, &(eventMessage), 100) == TRUE)
  4026fe:	6820      	ldr	r0, [r4, #0]
  402700:	a903      	add	r1, sp, #12
  402702:	2264      	movs	r2, #100	; 0x64
  402704:	2300      	movs	r3, #0
  402706:	47b0      	blx	r6
  402708:	2801      	cmp	r0, #1
  40270a:	d1f6      	bne.n	4026fa <task_stateMachineHandler+0x46>
		{
			processEvent(eventMessage); 
  40270c:	9803      	ldr	r0, [sp, #12]
  40270e:	47b8      	blx	r7
  402710:	e7f3      	b.n	4026fa <task_stateMachineHandler+0x46>
	}	
	queue_stateMachineEvents = xQueueCreate( 10, sizeof(eventMessage_t));
	if(queue_stateMachineEvents == 0)
	{
		// Queue was not created this is an error!
		debugPrintString("an error has occurred, state machine queue creation failed. \r\n");
  402712:	480f      	ldr	r0, [pc, #60]	; (402750 <task_stateMachineHandler+0x9c>)
  402714:	4b0f      	ldr	r3, [pc, #60]	; (402754 <task_stateMachineHandler+0xa0>)
  402716:	4798      	blx	r3
		{
			processEvent(eventMessage); 
		}
		vTaskDelay(50); 	
	}		
}
  402718:	b005      	add	sp, #20
  40271a:	bdf0      	pop	{r4, r5, r6, r7, pc}
{
	//Start Idle-time out timer 
	TimeOutTimer = xTimerCreate("Time Out Timer", (MAX_IDLE_TIMEOUT/portTICK_RATE_MS), pdFALSE, NULL, vTimeOutTimerCallback);
	if (TimeOutTimer == NULL)
	{
		printf("Failed to create timer task code %d\r\n", TimeOutTimer);
  40271c:	4b0e      	ldr	r3, [pc, #56]	; (402758 <task_stateMachineHandler+0xa4>)
  40271e:	480f      	ldr	r0, [pc, #60]	; (40275c <task_stateMachineHandler+0xa8>)
  402720:	4798      	blx	r3
  402722:	e7d5      	b.n	4026d0 <task_stateMachineHandler+0x1c>
  402724:	00401add 	.word	0x00401add
  402728:	000493e0 	.word	0x000493e0
  40272c:	00415b7c 	.word	0x00415b7c
  402730:	004078fd 	.word	0x004078fd
  402734:	2000336c 	.word	0x2000336c
  402738:	00406901 	.word	0x00406901
  40273c:	20003374 	.word	0x20003374
  402740:	00406979 	.word	0x00406979
  402744:	00402415 	.word	0x00402415
  402748:	004072ed 	.word	0x004072ed
  40274c:	00406b35 	.word	0x00406b35
  402750:	00415bb4 	.word	0x00415bb4
  402754:	004008c9 	.word	0x004008c9
  402758:	0040bba9 	.word	0x0040bba9
  40275c:	00415b8c 	.word	0x00415b8c

00402760 <sd_mmc_configure_slot>:

/**
 * \brief Configures the driver with the selected card configuration
 */
static void sd_mmc_configure_slot(void)
{
  402760:	b510      	push	{r4, lr}
	driver_select_device(sd_mmc_slot_sel, sd_mmc_card->clock,
  402762:	4a07      	ldr	r2, [pc, #28]	; (402780 <sd_mmc_configure_slot+0x20>)
  402764:	4b07      	ldr	r3, [pc, #28]	; (402784 <sd_mmc_configure_slot+0x24>)
  402766:	6812      	ldr	r2, [r2, #0]
  402768:	7818      	ldrb	r0, [r3, #0]
  40276a:	f892 3022 	ldrb.w	r3, [r2, #34]	; 0x22
  40276e:	6811      	ldr	r1, [r2, #0]
  402770:	4c05      	ldr	r4, [pc, #20]	; (402788 <sd_mmc_configure_slot+0x28>)
  402772:	7c52      	ldrb	r2, [r2, #17]
  402774:	3300      	adds	r3, #0
  402776:	bf18      	it	ne
  402778:	2301      	movne	r3, #1
  40277a:	47a0      	blx	r4
  40277c:	bd10      	pop	{r4, pc}
  40277e:	bf00      	nop
  402780:	20003380 	.word	0x20003380
  402784:	20003386 	.word	0x20003386
  402788:	00403655 	.word	0x00403655

0040278c <sd_mmc_select_slot.part.0>:
 * \retval SD_MMC_ERR_NO_CARD  No card present on slot
 * \retval SD_MMC_ERR_UNUSABLE Unusable card
 * \retval SD_MMC_INIT_ONGOING Card initialization requested
 * \retval SD_MMC_OK           Card present
 */
static sd_mmc_err_t sd_mmc_select_slot(uint8_t slot)
  40278c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	}
	Assert(sd_mmc_nb_block_remaining == 0);

#if (defined SD_MMC_0_CD_GPIO)
	//! Card Detect pins
	if (ioport_get_pin_level(sd_mmc_cards[slot].cd_gpio)
  40278e:	00c5      	lsls	r5, r0, #3
  402790:	4c34      	ldr	r4, [pc, #208]	; (402864 <sd_mmc_select_slot.part.0+0xd8>)
  402792:	1829      	adds	r1, r5, r0
  402794:	eb04 0181 	add.w	r1, r4, r1, lsl #2
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
  402798:	2601      	movs	r6, #1
  40279a:	688a      	ldr	r2, [r1, #8]
typedef uint32_t ioport_port_t;
typedef uint32_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 5;
  40279c:	0953      	lsrs	r3, r2, #5
	} else {
		return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
		       (IOPORT_PIO_OFFSET * port));
	}
#else
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  40279e:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  4027a2:	f203 7307 	addw	r3, r3, #1799	; 0x707
  4027a6:	025b      	lsls	r3, r3, #9
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
  4027a8:	f002 021f 	and.w	r2, r2, #31
	base->PIO_CODR = mask & ~level;
}

__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	return arch_ioport_pin_to_base(pin)->PIO_PDSR & arch_ioport_pin_to_mask(pin);
  4027ac:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
  4027ae:	fa06 f202 	lsl.w	r2, r6, r2
  4027b2:	4013      	ands	r3, r2
  4027b4:	f101 0108 	add.w	r1, r1, #8
  4027b8:	d110      	bne.n	4027dc <sd_mmc_select_slot.part.0+0x50>
			!= SD_MMC_0_CD_DETECT_VALUE) {
		if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_DEBOUNCE) {
  4027ba:	7989      	ldrb	r1, [r1, #6]
  4027bc:	42b1      	cmp	r1, r6
  4027be:	d006      	beq.n	4027ce <sd_mmc_select_slot.part.0+0x42>
			SD_MMC_STOP_TIMEOUT();
		}
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_NO_CARD;
  4027c0:	4428      	add	r0, r5
  4027c2:	eb04 0480 	add.w	r4, r4, r0, lsl #2
  4027c6:	2304      	movs	r3, #4
  4027c8:	73a3      	strb	r3, [r4, #14]
		return SD_MMC_ERR_NO_CARD;
  4027ca:	2002      	movs	r0, #2
  4027cc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return false;
}

static inline void SD_MMC_STOP_TIMEOUT(void)
{
	if (sd_mmc_sam_systick_used) {
  4027ce:	4a26      	ldr	r2, [pc, #152]	; (402868 <sd_mmc_select_slot.part.0+0xdc>)
  4027d0:	7812      	ldrb	r2, [r2, #0]
  4027d2:	2a00      	cmp	r2, #0
  4027d4:	d0f4      	beq.n	4027c0 <sd_mmc_select_slot.part.0+0x34>
		SysTick->CTRL = 0;
  4027d6:	4a25      	ldr	r2, [pc, #148]	; (40286c <sd_mmc_select_slot.part.0+0xe0>)
  4027d8:	6013      	str	r3, [r2, #0]
  4027da:	e7f1      	b.n	4027c0 <sd_mmc_select_slot.part.0+0x34>
			SD_MMC_STOP_TIMEOUT();
		}
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_NO_CARD;
		return SD_MMC_ERR_NO_CARD;
	}
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_NO_CARD) {
  4027dc:	798b      	ldrb	r3, [r1, #6]
  4027de:	2b04      	cmp	r3, #4
  4027e0:	d02a      	beq.n	402838 <sd_mmc_select_slot.part.0+0xac>
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_DEBOUNCE;
		// Debounce + Power On Setup
		SD_MMC_START_TIMEOUT();
		return SD_MMC_ERR_NO_CARD;
	}
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_DEBOUNCE) {
  4027e2:	2b01      	cmp	r3, #1
  4027e4:	d003      	beq.n	4027ee <sd_mmc_select_slot.part.0+0x62>
		// Set 1-bit bus width and low clock for initialization
		sd_mmc_cards[slot].clock = SDMMC_CLOCK_INIT;
		sd_mmc_cards[slot].bus_width = 1;
		sd_mmc_cards[slot].high_speed = 0;
	}
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_UNUSABLE) {
  4027e6:	2b03      	cmp	r3, #3
  4027e8:	d118      	bne.n	40281c <sd_mmc_select_slot.part.0+0x90>
		return SD_MMC_ERR_UNUSABLE;
  4027ea:	4618      	mov	r0, r3
  4027ec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	}
}

static inline bool SD_MMC_IS_TIMEOUT(void)
{
	if (!sd_mmc_sam_systick_used) {
  4027ee:	4b1e      	ldr	r3, [pc, #120]	; (402868 <sd_mmc_select_slot.part.0+0xdc>)
  4027f0:	781b      	ldrb	r3, [r3, #0]
  4027f2:	b12b      	cbz	r3, 402800 <sd_mmc_select_slot.part.0+0x74>
		return (xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdTRUE);
#else
		return true;
#endif
	}
	if (SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) {
  4027f4:	4b1d      	ldr	r3, [pc, #116]	; (40286c <sd_mmc_select_slot.part.0+0xe0>)
  4027f6:	681a      	ldr	r2, [r3, #0]
  4027f8:	03d2      	lsls	r2, r2, #15
  4027fa:	d530      	bpl.n	40285e <sd_mmc_select_slot.part.0+0xd2>
		SysTick->CTRL = 0;
  4027fc:	2200      	movs	r2, #0
  4027fe:	601a      	str	r2, [r3, #0]
		if (!SD_MMC_IS_TIMEOUT()) {
			// Debounce on going
			return SD_MMC_ERR_NO_CARD;
		}
		// Card is not initialized
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_INIT;
  402800:	1829      	adds	r1, r5, r0
  402802:	0089      	lsls	r1, r1, #2
  402804:	1863      	adds	r3, r4, r1
		// Set 1-bit bus width and low clock for initialization
		sd_mmc_cards[slot].clock = SDMMC_CLOCK_INIT;
  402806:	4f1a      	ldr	r7, [pc, #104]	; (402870 <sd_mmc_select_slot.part.0+0xe4>)
		if (!SD_MMC_IS_TIMEOUT()) {
			// Debounce on going
			return SD_MMC_ERR_NO_CARD;
		}
		// Card is not initialized
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_INIT;
  402808:	2602      	movs	r6, #2
  40280a:	739e      	strb	r6, [r3, #14]
		// Set 1-bit bus width and low clock for initialization
		sd_mmc_cards[slot].clock = SDMMC_CLOCK_INIT;
  40280c:	5067      	str	r7, [r4, r1]
		sd_mmc_cards[slot].bus_width = 1;
  40280e:	2701      	movs	r7, #1
		sd_mmc_cards[slot].high_speed = 0;
  402810:	2100      	movs	r1, #0
		}
		// Card is not initialized
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_INIT;
		// Set 1-bit bus width and low clock for initialization
		sd_mmc_cards[slot].clock = SDMMC_CLOCK_INIT;
		sd_mmc_cards[slot].bus_width = 1;
  402812:	745f      	strb	r7, [r3, #17]
		sd_mmc_cards[slot].high_speed = 0;
  402814:	f883 1022 	strb.w	r1, [r3, #34]	; 0x22
  402818:	7b9b      	ldrb	r3, [r3, #14]
  40281a:	e7e4      	b.n	4027e6 <sd_mmc_select_slot.part.0+0x5a>
	}
#endif

	// Initialize interface
	sd_mmc_slot_sel = slot;
	sd_mmc_card = &sd_mmc_cards[slot];
  40281c:	4405      	add	r5, r0
  40281e:	eb04 0485 	add.w	r4, r4, r5, lsl #2
  402822:	4914      	ldr	r1, [pc, #80]	; (402874 <sd_mmc_select_slot.part.0+0xe8>)
		sd_mmc_cards[slot].high_speed = 0;
	}
#endif

	// Initialize interface
	sd_mmc_slot_sel = slot;
  402824:	4a14      	ldr	r2, [pc, #80]	; (402878 <sd_mmc_select_slot.part.0+0xec>)
	sd_mmc_card = &sd_mmc_cards[slot];
	sd_mmc_configure_slot();
  402826:	4b15      	ldr	r3, [pc, #84]	; (40287c <sd_mmc_select_slot.part.0+0xf0>)
		sd_mmc_cards[slot].high_speed = 0;
	}
#endif

	// Initialize interface
	sd_mmc_slot_sel = slot;
  402828:	7010      	strb	r0, [r2, #0]
	sd_mmc_card = &sd_mmc_cards[slot];
  40282a:	600c      	str	r4, [r1, #0]
	sd_mmc_configure_slot();
  40282c:	4798      	blx	r3
	return (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_INIT) ?
			SD_MMC_INIT_ONGOING : SD_MMC_OK;
  40282e:	7ba0      	ldrb	r0, [r4, #14]

	// Initialize interface
	sd_mmc_slot_sel = slot;
	sd_mmc_card = &sd_mmc_cards[slot];
	sd_mmc_configure_slot();
	return (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_INIT) ?
  402830:	1e83      	subs	r3, r0, #2
  402832:	4258      	negs	r0, r3
  402834:	4158      	adcs	r0, r3
  402836:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		static xTimeOutType xTimeOut;
#endif

static inline void SD_MMC_START_TIMEOUT(void)
{
	if (!SysTick->CTRL) {
  402838:	4b0c      	ldr	r3, [pc, #48]	; (40286c <sd_mmc_select_slot.part.0+0xe0>)
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_NO_CARD;
		return SD_MMC_ERR_NO_CARD;
	}
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_NO_CARD) {
		// A card plug on going, but this is not initialized
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_DEBOUNCE;
  40283a:	718e      	strb	r6, [r1, #6]
		static xTimeOutType xTimeOut;
#endif

static inline void SD_MMC_START_TIMEOUT(void)
{
	if (!SysTick->CTRL) {
  40283c:	681a      	ldr	r2, [r3, #0]
  40283e:	b932      	cbnz	r2, 40284e <sd_mmc_select_slot.part.0+0xc2>
		sd_mmc_sam_systick_used = true;
  402840:	4909      	ldr	r1, [pc, #36]	; (402868 <sd_mmc_select_slot.part.0+0xdc>)
		SysTick->LOAD = (sysclk_get_cpu_hz() / (8 * 1000))
  402842:	4a0f      	ldr	r2, [pc, #60]	; (402880 <sd_mmc_select_slot.part.0+0xf4>)
#endif

static inline void SD_MMC_START_TIMEOUT(void)
{
	if (!SysTick->CTRL) {
		sd_mmc_sam_systick_used = true;
  402844:	700e      	strb	r6, [r1, #0]
		SysTick->LOAD = (sysclk_get_cpu_hz() / (8 * 1000))
  402846:	605a      	str	r2, [r3, #4]
				* SD_MMC_DEBOUNCE_TIMEOUT;
		SysTick->CTRL = SysTick_CTRL_ENABLE_Msk;
  402848:	601e      	str	r6, [r3, #0]
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_NO_CARD) {
		// A card plug on going, but this is not initialized
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_DEBOUNCE;
		// Debounce + Power On Setup
		SD_MMC_START_TIMEOUT();
		return SD_MMC_ERR_NO_CARD;
  40284a:	2002      	movs	r0, #2
  40284c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		sd_mmc_sam_systick_used = true;
		SysTick->LOAD = (sysclk_get_cpu_hz() / (8 * 1000))
				* SD_MMC_DEBOUNCE_TIMEOUT;
		SysTick->CTRL = SysTick_CTRL_ENABLE_Msk;
	} else {
		sd_mmc_sam_systick_used = false;
  40284e:	4a06      	ldr	r2, [pc, #24]	; (402868 <sd_mmc_select_slot.part.0+0xdc>)
#ifdef FREERTOS_USED
		// Note: the define INCLUDE_vTaskDelay must be set to one
		// in FreeRTOSConfig.h file.
		vTaskSetTimeOutState(&xTimeOut);
#else
		delay_ms(SD_MMC_DEBOUNCE_TIMEOUT);
  402850:	480c      	ldr	r0, [pc, #48]	; (402884 <sd_mmc_select_slot.part.0+0xf8>)
  402852:	4b0d      	ldr	r3, [pc, #52]	; (402888 <sd_mmc_select_slot.part.0+0xfc>)
		sd_mmc_sam_systick_used = true;
		SysTick->LOAD = (sysclk_get_cpu_hz() / (8 * 1000))
				* SD_MMC_DEBOUNCE_TIMEOUT;
		SysTick->CTRL = SysTick_CTRL_ENABLE_Msk;
	} else {
		sd_mmc_sam_systick_used = false;
  402854:	2100      	movs	r1, #0
  402856:	7011      	strb	r1, [r2, #0]
#ifdef FREERTOS_USED
		// Note: the define INCLUDE_vTaskDelay must be set to one
		// in FreeRTOSConfig.h file.
		vTaskSetTimeOutState(&xTimeOut);
#else
		delay_ms(SD_MMC_DEBOUNCE_TIMEOUT);
  402858:	4798      	blx	r3
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_NO_CARD) {
		// A card plug on going, but this is not initialized
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_DEBOUNCE;
		// Debounce + Power On Setup
		SD_MMC_START_TIMEOUT();
		return SD_MMC_ERR_NO_CARD;
  40285a:	2002      	movs	r0, #2
  40285c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	}
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_DEBOUNCE) {
		if (!SD_MMC_IS_TIMEOUT()) {
			// Debounce on going
			return SD_MMC_ERR_NO_CARD;
  40285e:	2002      	movs	r0, #2
  402860:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  402862:	bf00      	nop
  402864:	2000010c 	.word	0x2000010c
  402868:	2000337e 	.word	0x2000337e
  40286c:	e000e010 	.word	0xe000e010
  402870:	00061a80 	.word	0x00061a80
  402874:	20003380 	.word	0x20003380
  402878:	20003386 	.word	0x20003386
  40287c:	00402761 	.word	0x00402761
  402880:	00e4e1c0 	.word	0x00e4e1c0
  402884:	0082ca25 	.word	0x0082ca25
  402888:	20000085 	.word	0x20000085

0040288c <sd_mmc_cmd9_mci>:
 * data (CSD) on the CMD line mci.
 *
 * \return true if success, otherwise false
 */
static bool sd_mmc_cmd9_mci(void)
{
  40288c:	b538      	push	{r3, r4, r5, lr}
	if (!driver_send_cmd(SDMMC_MCI_CMD9_SEND_CSD, (uint32_t)sd_mmc_card->rca << 16)) {
  40288e:	4d08      	ldr	r5, [pc, #32]	; (4028b0 <sd_mmc_cmd9_mci+0x24>)
  402890:	4a08      	ldr	r2, [pc, #32]	; (4028b4 <sd_mmc_cmd9_mci+0x28>)
  402892:	682b      	ldr	r3, [r5, #0]
  402894:	8999      	ldrh	r1, [r3, #12]
  402896:	f641 3009 	movw	r0, #6921	; 0x1b09
  40289a:	0409      	lsls	r1, r1, #16
  40289c:	4790      	blx	r2
  40289e:	4604      	mov	r4, r0
  4028a0:	b118      	cbz	r0, 4028aa <sd_mmc_cmd9_mci+0x1e>
		return false;
	}
	driver_get_response_128(sd_mmc_card->csd);
  4028a2:	6828      	ldr	r0, [r5, #0]
  4028a4:	4b04      	ldr	r3, [pc, #16]	; (4028b8 <sd_mmc_cmd9_mci+0x2c>)
  4028a6:	3012      	adds	r0, #18
  4028a8:	4798      	blx	r3
	return true;
}
  4028aa:	4620      	mov	r0, r4
  4028ac:	bd38      	pop	{r3, r4, r5, pc}
  4028ae:	bf00      	nop
  4028b0:	20003380 	.word	0x20003380
  4028b4:	004036f9 	.word	0x004036f9
  4028b8:	0040372d 	.word	0x0040372d

004028bc <sd_mmc_init>:

//-------------------------------------------------------------------
//--------------------- PUBLIC FUNCTIONS ----------------------------

void sd_mmc_init(void)
{
  4028bc:	b510      	push	{r4, lr}
	pmc_enable_periph_clk(SD_MMC_##slot##_WP_PIO_ID);
	MREPEAT(SD_MMC_MEM_CNT, SD_MMC_ENABLE_WP_PIN, ~)
# undef SD_MMC_ENABLE_WP_PIN
#endif
	for (uint8_t slot = 0; slot < SD_MMC_MEM_CNT; slot++) {
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_NO_CARD;
  4028be:	4804      	ldr	r0, [pc, #16]	; (4028d0 <sd_mmc_init+0x14>)
	}
	sd_mmc_slot_sel = 0xFF; // No slot configurated
  4028c0:	4a04      	ldr	r2, [pc, #16]	; (4028d4 <sd_mmc_init+0x18>)
	driver_init();
  4028c2:	4b05      	ldr	r3, [pc, #20]	; (4028d8 <sd_mmc_init+0x1c>)
	pmc_enable_periph_clk(SD_MMC_##slot##_WP_PIO_ID);
	MREPEAT(SD_MMC_MEM_CNT, SD_MMC_ENABLE_WP_PIN, ~)
# undef SD_MMC_ENABLE_WP_PIN
#endif
	for (uint8_t slot = 0; slot < SD_MMC_MEM_CNT; slot++) {
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_NO_CARD;
  4028c4:	2404      	movs	r4, #4
	}
	sd_mmc_slot_sel = 0xFF; // No slot configurated
  4028c6:	21ff      	movs	r1, #255	; 0xff
	pmc_enable_periph_clk(SD_MMC_##slot##_WP_PIO_ID);
	MREPEAT(SD_MMC_MEM_CNT, SD_MMC_ENABLE_WP_PIN, ~)
# undef SD_MMC_ENABLE_WP_PIN
#endif
	for (uint8_t slot = 0; slot < SD_MMC_MEM_CNT; slot++) {
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_NO_CARD;
  4028c8:	7384      	strb	r4, [r0, #14]
	}
	sd_mmc_slot_sel = 0xFF; // No slot configurated
  4028ca:	7011      	strb	r1, [r2, #0]
	driver_init();
  4028cc:	4798      	blx	r3
  4028ce:	bd10      	pop	{r4, pc}
  4028d0:	2000010c 	.word	0x2000010c
  4028d4:	20003386 	.word	0x20003386
  4028d8:	0040361d 	.word	0x0040361d

004028dc <sd_mmc_check>:
{
	return SD_MMC_MEM_CNT;
}

sd_mmc_err_t sd_mmc_check(uint8_t slot)
{
  4028dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 * \retval SD_MMC_INIT_ONGOING Card initialization requested
 * \retval SD_MMC_OK           Card present
 */
static sd_mmc_err_t sd_mmc_select_slot(uint8_t slot)
{
	if (slot >= SD_MMC_MEM_CNT) {
  4028e0:	4605      	mov	r5, r0
{
	return SD_MMC_MEM_CNT;
}

sd_mmc_err_t sd_mmc_check(uint8_t slot)
{
  4028e2:	b095      	sub	sp, #84	; 0x54
 * \retval SD_MMC_INIT_ONGOING Card initialization requested
 * \retval SD_MMC_OK           Card present
 */
static sd_mmc_err_t sd_mmc_select_slot(uint8_t slot)
{
	if (slot >= SD_MMC_MEM_CNT) {
  4028e4:	2800      	cmp	r0, #0
  4028e6:	f000 80ea 	beq.w	402abe <sd_mmc_check+0x1e2>
		return SD_MMC_ERR_SLOT;
  4028ea:	2404      	movs	r4, #4
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  4028ec:	4b9e      	ldr	r3, [pc, #632]	; (402b68 <sd_mmc_check+0x28c>)
  4028ee:	7818      	ldrb	r0, [r3, #0]
  4028f0:	2800      	cmp	r0, #0
  4028f2:	f000 80de 	beq.w	402ab2 <sd_mmc_check+0x1d6>
	}
	sd_mmc_debug("SD/MMC card initialization failed\n\r");
	sd_mmc_card->state = SD_MMC_CARD_STATE_UNUSABLE;
	sd_mmc_deselect_slot();
	return SD_MMC_ERR_UNUSABLE;
}
  4028f6:	4620      	mov	r0, r4
  4028f8:	b015      	add	sp, #84	; 0x54
  4028fa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
{
	uint32_t resp;

	*v2 = 0;
	// Test for SD version 2
	if (!driver_send_cmd(SD_CMD8_SEND_IF_COND,
  4028fe:	f245 5008 	movw	r0, #21768	; 0x5508
  402902:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
  402906:	47b0      	blx	r6
  402908:	2800      	cmp	r0, #0
  40290a:	f040 80f7 	bne.w	402afc <sd_mmc_check+0x220>
 */
static bool sd_cmd8(uint8_t * v2)
{
	uint32_t resp;

	*v2 = 0;
  40290e:	f04f 0900 	mov.w	r9, #0
	// Try to get the SDIO card's operating condition
	if (!sdio_op_cond()) {
		return false;
	}

	if (sd_mmc_card->type & CARD_TYPE_SD) {
  402912:	683b      	ldr	r3, [r7, #0]
  402914:	7bdb      	ldrb	r3, [r3, #15]
  402916:	07da      	lsls	r2, r3, #31
  402918:	f100 80fc 	bmi.w	402b14 <sd_mmc_check+0x238>
		if (!driver_send_cmd(SDMMC_CMD2_ALL_SEND_CID, 0)) {
			return false;
		}
	}
	// Ask the card to publish a new relative address (RCA).
	if (!driver_send_cmd(SD_CMD3_SEND_RELATIVE_ADDR, 0)) {
  40291c:	f245 1003 	movw	r0, #20739	; 0x5103
  402920:	2100      	movs	r1, #0
  402922:	47b0      	blx	r6
  402924:	2800      	cmp	r0, #0
  402926:	f000 80e0 	beq.w	402aea <sd_mmc_check+0x20e>
		return false;
	}
	sd_mmc_card->rca = (driver_get_response() >> 16) & 0xFFFF;
  40292a:	f8df 9274 	ldr.w	r9, [pc, #628]	; 402ba0 <sd_mmc_check+0x2c4>
  40292e:	683d      	ldr	r5, [r7, #0]
  402930:	f8df a268 	ldr.w	sl, [pc, #616]	; 402b9c <sd_mmc_check+0x2c0>
  402934:	47c8      	blx	r9

	// SD MEMORY, Get the Card-Specific Data
	if (sd_mmc_card->type & CARD_TYPE_SD) {
  402936:	683b      	ldr	r3, [r7, #0]
	}
	// Ask the card to publish a new relative address (RCA).
	if (!driver_send_cmd(SD_CMD3_SEND_RELATIVE_ADDR, 0)) {
		return false;
	}
	sd_mmc_card->rca = (driver_get_response() >> 16) & 0xFFFF;
  402938:	0c00      	lsrs	r0, r0, #16
  40293a:	81a8      	strh	r0, [r5, #12]

	// SD MEMORY, Get the Card-Specific Data
	if (sd_mmc_card->type & CARD_TYPE_SD) {
  40293c:	7bda      	ldrb	r2, [r3, #15]
  40293e:	07d5      	lsls	r5, r2, #31
  402940:	d53a      	bpl.n	4029b8 <sd_mmc_check+0xdc>
		if (!sd_mmc_cmd9_mci()) {
  402942:	4b8a      	ldr	r3, [pc, #552]	; (402b6c <sd_mmc_check+0x290>)
  402944:	4798      	blx	r3
  402946:	2800      	cmp	r0, #0
  402948:	f000 80cf 	beq.w	402aea <sd_mmc_check+0x20e>
 	uint32_t unit;
	uint32_t mul;
	uint32_t tran_speed;

	// Get SD memory maximum transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
  40294c:	f8da 3000 	ldr.w	r3, [sl]
	unit = sd_mmc_trans_units[tran_speed & 0x7];
  402950:	4d87      	ldr	r5, [pc, #540]	; (402b70 <sd_mmc_check+0x294>)
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  402952:	7d5a      	ldrb	r2, [r3, #21]
	mul = sd_trans_multipliers[(tran_speed >> 3) & 0xF];
  402954:	4887      	ldr	r0, [pc, #540]	; (402b74 <sd_mmc_check+0x298>)
  402956:	7c99      	ldrb	r1, [r3, #18]
	uint32_t mul;
	uint32_t tran_speed;

	// Get SD memory maximum transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
	unit = sd_mmc_trans_units[tran_speed & 0x7];
  402958:	f002 0e07 	and.w	lr, r2, #7
	mul = sd_trans_multipliers[(tran_speed >> 3) & 0xF];
  40295c:	f3c2 02c3 	ubfx	r2, r2, #3, #4
	sd_mmc_card->clock = unit * mul * 1000;
  402960:	f855 502e 	ldr.w	r5, [r5, lr, lsl #2]
  402964:	f850 0022 	ldr.w	r0, [r0, r2, lsl #2]
  402968:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  40296c:	fb02 f205 	mul.w	r2, r2, r5
  402970:	fb00 f202 	mul.w	r2, r0, r2
	 * BLOCK_LEN = 2 ^ READ_BL_LEN      (READ_BL_LEN < 12)
	 * ----------------------------------------------------
	 * For high capacity SD card:
	 * memory capacity = (C_SIZE+1) * 512K byte
	 */
	if (CSD_STRUCTURE_VERSION(sd_mmc_card->csd) >= SD_CSD_VER_2_0) {
  402974:	0989      	lsrs	r1, r1, #6

	// Get SD memory maximum transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
	unit = sd_mmc_trans_units[tran_speed & 0x7];
	mul = sd_trans_multipliers[(tran_speed >> 3) & 0xF];
	sd_mmc_card->clock = unit * mul * 1000;
  402976:	601a      	str	r2, [r3, #0]
	 * BLOCK_LEN = 2 ^ READ_BL_LEN      (READ_BL_LEN < 12)
	 * ----------------------------------------------------
	 * For high capacity SD card:
	 * memory capacity = (C_SIZE+1) * 512K byte
	 */
	if (CSD_STRUCTURE_VERSION(sd_mmc_card->csd) >= SD_CSD_VER_2_0) {
  402978:	f040 8179 	bne.w	402c6e <sd_mmc_check+0x392>
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  40297c:	7e58      	ldrb	r0, [r3, #25]
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  40297e:	f893 c018 	ldrb.w	ip, [r3, #24]
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  402982:	7ed9      	ldrb	r1, [r3, #27]
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  402984:	f893 e01a 	ldrb.w	lr, [r3, #26]
  402988:	7f1d      	ldrb	r5, [r3, #28]
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	value &=  ((uint32_t)1 << size) - 1;
  40298a:	7dda      	ldrb	r2, [r3, #23]
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  40298c:	0080      	lsls	r0, r0, #2
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  40298e:	ea40 208c 	orr.w	r0, r0, ip, lsl #10
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  402992:	0049      	lsls	r1, r1, #1
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  402994:	ea40 109e 	orr.w	r0, r0, lr, lsr #6
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  402998:	ea41 11d5 	orr.w	r1, r1, r5, lsr #7
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	value &=  ((uint32_t)1 << size) - 1;
  40299c:	f3c0 000b 	ubfx	r0, r0, #0, #12
  4029a0:	f001 0107 	and.w	r1, r1, #7
		sd_mmc_card->capacity =
				(SD_CSD_2_0_C_SIZE(sd_mmc_card->csd) + 1)
				* 512;
	} else {
		uint32_t blocknr = ((SD_CSD_1_0_C_SIZE(sd_mmc_card->csd) + 1) *
  4029a4:	3001      	adds	r0, #1
				(1 << (SD_CSD_1_0_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
  4029a6:	3102      	adds	r1, #2
	if (CSD_STRUCTURE_VERSION(sd_mmc_card->csd) >= SD_CSD_VER_2_0) {
		sd_mmc_card->capacity =
				(SD_CSD_2_0_C_SIZE(sd_mmc_card->csd) + 1)
				* 512;
	} else {
		uint32_t blocknr = ((SD_CSD_1_0_C_SIZE(sd_mmc_card->csd) + 1) *
  4029a8:	fa00 f101 	lsl.w	r1, r0, r1
				(1 << (SD_CSD_1_0_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
		sd_mmc_card->capacity = blocknr *
  4029ac:	f002 020f 	and.w	r2, r2, #15
  4029b0:	fa01 f202 	lsl.w	r2, r1, r2
				(1 << SD_CSD_1_0_READ_BL_LEN(sd_mmc_card->csd))
				/ 1024;
  4029b4:	0a92      	lsrs	r2, r2, #10
				(SD_CSD_2_0_C_SIZE(sd_mmc_card->csd) + 1)
				* 512;
	} else {
		uint32_t blocknr = ((SD_CSD_1_0_C_SIZE(sd_mmc_card->csd) + 1) *
				(1 << (SD_CSD_1_0_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
		sd_mmc_card->capacity = blocknr *
  4029b6:	605a      	str	r2, [r3, #4]
		}
		sd_decode_csd();
	}
	// Select the and put it into Transfer Mode
	if (!driver_send_cmd(SDMMC_CMD7_SELECT_CARD_CMD,
			(uint32_t)sd_mmc_card->rca << 16)) {
  4029b8:	8999      	ldrh	r1, [r3, #12]
			return false;
		}
		sd_decode_csd();
	}
	// Select the and put it into Transfer Mode
	if (!driver_send_cmd(SDMMC_CMD7_SELECT_CARD_CMD,
  4029ba:	4d6f      	ldr	r5, [pc, #444]	; (402b78 <sd_mmc_check+0x29c>)
  4029bc:	0409      	lsls	r1, r1, #16
  4029be:	f243 1007 	movw	r0, #12551	; 0x3107
  4029c2:	47b0      	blx	r6
  4029c4:	2800      	cmp	r0, #0
  4029c6:	f000 8090 	beq.w	402aea <sd_mmc_check+0x20e>
			(uint32_t)sd_mmc_card->rca << 16)) {
		return false;
	}
	// SD MEMORY, Read the SCR to get card version
	if (sd_mmc_card->type & CARD_TYPE_SD) {
  4029ca:	683b      	ldr	r3, [r7, #0]
  4029cc:	f8df a1cc 	ldr.w	sl, [pc, #460]	; 402b9c <sd_mmc_check+0x2c0>
  4029d0:	7bda      	ldrb	r2, [r3, #15]
  4029d2:	07d0      	lsls	r0, r2, #31
  4029d4:	d530      	bpl.n	402a38 <sd_mmc_check+0x15c>
{
	uint8_t scr[SD_SCR_REG_BSIZE];

	// CMD55 - Indicate to the card that the next command is an
	// application specific command rather than a standard command.
	if (!driver_send_cmd(SDMMC_CMD55_APP_CMD, (uint32_t)sd_mmc_card->rca << 16)) {
  4029d6:	8999      	ldrh	r1, [r3, #12]
  4029d8:	f241 1037 	movw	r0, #4407	; 0x1137
  4029dc:	0409      	lsls	r1, r1, #16
  4029de:	47a8      	blx	r5
  4029e0:	2800      	cmp	r0, #0
  4029e2:	f000 8082 	beq.w	402aea <sd_mmc_check+0x20e>
		return false;
	}
	if (!driver_adtc_start(SD_ACMD51_SEND_SCR, 0,
  4029e6:	2501      	movs	r5, #1
  4029e8:	9500      	str	r5, [sp, #0]
  4029ea:	462b      	mov	r3, r5
  4029ec:	4863      	ldr	r0, [pc, #396]	; (402b7c <sd_mmc_check+0x2a0>)
  4029ee:	f8df c1b8 	ldr.w	ip, [pc, #440]	; 402ba8 <sd_mmc_check+0x2cc>
  4029f2:	2100      	movs	r1, #0
  4029f4:	2208      	movs	r2, #8
  4029f6:	47e0      	blx	ip
  4029f8:	2800      	cmp	r0, #0
  4029fa:	d076      	beq.n	402aea <sd_mmc_check+0x20e>
			SD_SCR_REG_BSIZE, 1, true)) {
		return false;
	}
	if (!driver_start_read_blocks(scr, 1)) {
  4029fc:	4629      	mov	r1, r5
  4029fe:	a804      	add	r0, sp, #16
  402a00:	4b5f      	ldr	r3, [pc, #380]	; (402b80 <sd_mmc_check+0x2a4>)
  402a02:	4798      	blx	r3
  402a04:	2800      	cmp	r0, #0
  402a06:	d070      	beq.n	402aea <sd_mmc_check+0x20e>
		return false;
	}
	if (!driver_wait_end_of_read_blocks()) {
  402a08:	4b5e      	ldr	r3, [pc, #376]	; (402b84 <sd_mmc_check+0x2a8>)
  402a0a:	4798      	blx	r3
  402a0c:	2800      	cmp	r0, #0
  402a0e:	d06c      	beq.n	402aea <sd_mmc_check+0x20e>
  402a10:	f89d 3010 	ldrb.w	r3, [sp, #16]
		return false;
	}

	// Get SD Memory Card - Spec. Version
	switch (SD_SCR_SD_SPEC(scr)) {
  402a14:	f003 030f 	and.w	r3, r3, #15
  402a18:	2b01      	cmp	r3, #1
  402a1a:	f000 8223 	beq.w	402e64 <sd_mmc_check+0x588>
  402a1e:	f0c0 821c 	bcc.w	402e5a <sd_mmc_check+0x57e>
  402a22:	2b02      	cmp	r3, #2
  402a24:	f040 8219 	bne.w	402e5a <sd_mmc_check+0x57e>
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  402a28:	f89d 3012 	ldrb.w	r3, [sp, #18]
	case SD_SCR_SD_SPEC_1_10:
		sd_mmc_card->version = CARD_VER_SD_1_10;
		break;

	case SD_SCR_SD_SPEC_2_00:
		if (SD_SCR_SD_SPEC3(scr) == SD_SCR_SD_SPEC_3_00) {
  402a2c:	09db      	lsrs	r3, r3, #7
			sd_mmc_card->version = CARD_VER_SD_3_0;
  402a2e:	683b      	ldr	r3, [r7, #0]
  402a30:	bf14      	ite	ne
  402a32:	2230      	movne	r2, #48	; 0x30
		} else {
			sd_mmc_card->version = CARD_VER_SD_2_0;
  402a34:	2220      	moveq	r2, #32
  402a36:	741a      	strb	r2, [r3, #16]
	if (IS_SDIO()) {
		if (!sdio_get_max_speed()) {
			return false;
		}
	}
	if ((4 <= driver_get_bus_width(sd_mmc_slot_sel))) {
  402a38:	4d4b      	ldr	r5, [pc, #300]	; (402b68 <sd_mmc_check+0x28c>)
  402a3a:	4b53      	ldr	r3, [pc, #332]	; (402b88 <sd_mmc_check+0x2ac>)
  402a3c:	7828      	ldrb	r0, [r5, #0]
  402a3e:	4798      	blx	r3
  402a40:	2803      	cmp	r0, #3
  402a42:	d91a      	bls.n	402a7a <sd_mmc_check+0x19e>
		if (IS_SDIO()) {
			if (!sdio_cmd52_set_bus_width()) {
				return false;
			}
		}
		if (sd_mmc_card->type & CARD_TYPE_SD) {
  402a44:	683b      	ldr	r3, [r7, #0]
  402a46:	f8df a154 	ldr.w	sl, [pc, #340]	; 402b9c <sd_mmc_check+0x2c0>
  402a4a:	7bda      	ldrb	r2, [r3, #15]
  402a4c:	07d1      	lsls	r1, r2, #31
  402a4e:	d512      	bpl.n	402a76 <sd_mmc_check+0x19a>
 */
static bool sd_acmd6(void)
{
	// CMD55 - Indicate to the card that the next command is an
	// application specific command rather than a standard command.
	if (!driver_send_cmd(SDMMC_CMD55_APP_CMD, (uint32_t)sd_mmc_card->rca << 16)) {
  402a50:	8999      	ldrh	r1, [r3, #12]
  402a52:	f8df b124 	ldr.w	fp, [pc, #292]	; 402b78 <sd_mmc_check+0x29c>
  402a56:	0409      	lsls	r1, r1, #16
  402a58:	f241 1037 	movw	r0, #4407	; 0x1137
  402a5c:	47b0      	blx	r6
  402a5e:	2800      	cmp	r0, #0
  402a60:	d044      	beq.n	402aec <sd_mmc_check+0x210>
		return false;
	}
	// 10b = 4 bits bus
	if (!driver_send_cmd(SD_ACMD6_SET_BUS_WIDTH, 0x2)) {
  402a62:	f241 1006 	movw	r0, #4358	; 0x1106
  402a66:	2102      	movs	r1, #2
  402a68:	47d8      	blx	fp
  402a6a:	2800      	cmp	r0, #0
  402a6c:	d03e      	beq.n	402aec <sd_mmc_check+0x210>
		return false;
	}
	sd_mmc_card->bus_width = 4;
  402a6e:	f8da 3000 	ldr.w	r3, [sl]
  402a72:	2204      	movs	r2, #4
  402a74:	745a      	strb	r2, [r3, #17]
			if (!sd_acmd6()) {
				return false;
			}
		}
		// Switch to selected bus mode
		sd_mmc_configure_slot();
  402a76:	4b45      	ldr	r3, [pc, #276]	; (402b8c <sd_mmc_check+0x2b0>)
  402a78:	4798      	blx	r3
	}
	if (driver_is_high_speed_capable()) {
  402a7a:	4b45      	ldr	r3, [pc, #276]	; (402b90 <sd_mmc_check+0x2b4>)
  402a7c:	4798      	blx	r3
  402a7e:	b158      	cbz	r0, 402a98 <sd_mmc_check+0x1bc>
		if (IS_SDIO()) {
			if (!sdio_cmd52_set_high_speed()) {
				return false;
			}
		}
		if (sd_mmc_card->type & CARD_TYPE_SD) {
  402a80:	683b      	ldr	r3, [r7, #0]
  402a82:	f8df b118 	ldr.w	fp, [pc, #280]	; 402b9c <sd_mmc_check+0x2c0>
  402a86:	7bda      	ldrb	r2, [r3, #15]
  402a88:	07d2      	lsls	r2, r2, #31
  402a8a:	d503      	bpl.n	402a94 <sd_mmc_check+0x1b8>
			if (sd_mmc_card->version > CARD_VER_SD_1_0) {
  402a8c:	7c1b      	ldrb	r3, [r3, #16]
  402a8e:	2b10      	cmp	r3, #16
  402a90:	f200 80fa 	bhi.w	402c88 <sd_mmc_check+0x3ac>
					return false;
				}
			}
		}
		// Valid new configuration
		sd_mmc_configure_slot();
  402a94:	4b3d      	ldr	r3, [pc, #244]	; (402b8c <sd_mmc_check+0x2b0>)
  402a96:	4798      	blx	r3
	}
	// SD MEMORY, Set default block size
	if (sd_mmc_card->type & CARD_TYPE_SD) {
  402a98:	683a      	ldr	r2, [r7, #0]
  402a9a:	f8df 8100 	ldr.w	r8, [pc, #256]	; 402b9c <sd_mmc_check+0x2c0>
  402a9e:	7bd3      	ldrb	r3, [r2, #15]
  402aa0:	07d9      	lsls	r1, r3, #31
  402aa2:	f100 80d9 	bmi.w	402c58 <sd_mmc_check+0x37c>
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  402aa6:	7828      	ldrb	r0, [r5, #0]
	//if (sd_mmc_is_spi()? sd_mmc_spi_card_init()
			//: sd_mmc_mci_card_init())
	if(sd_mmc_mci_card_init()) 
	{
		sd_mmc_debug("SD/MMC card ready\n\r");
		sd_mmc_card->state = SD_MMC_CARD_STATE_READY;
  402aa8:	2300      	movs	r3, #0
  402aaa:	7393      	strb	r3, [r2, #14]
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  402aac:	2800      	cmp	r0, #0
  402aae:	f47f af22 	bne.w	4028f6 <sd_mmc_check+0x1a>
		driver_deselect_device(sd_mmc_slot_sel);
  402ab2:	4b38      	ldr	r3, [pc, #224]	; (402b94 <sd_mmc_check+0x2b8>)
  402ab4:	4798      	blx	r3
	}
	sd_mmc_debug("SD/MMC card initialization failed\n\r");
	sd_mmc_card->state = SD_MMC_CARD_STATE_UNUSABLE;
	sd_mmc_deselect_slot();
	return SD_MMC_ERR_UNUSABLE;
}
  402ab6:	4620      	mov	r0, r4
  402ab8:	b015      	add	sp, #84	; 0x54
  402aba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  402abe:	4b36      	ldr	r3, [pc, #216]	; (402b98 <sd_mmc_check+0x2bc>)
  402ac0:	4798      	blx	r3
sd_mmc_err_t sd_mmc_check(uint8_t slot)
{
	sd_mmc_err_t sd_mmc_err;

	sd_mmc_err = sd_mmc_select_slot(slot);
	if (sd_mmc_err != SD_MMC_INIT_ONGOING) {
  402ac2:	2801      	cmp	r0, #1
  402ac4:	4604      	mov	r4, r0
  402ac6:	f47f af11 	bne.w	4028ec <sd_mmc_check+0x10>
static bool sd_mmc_mci_card_init(void)
{
	uint8_t v2 = 0;

	// In first, try to install SD/SDIO card
	sd_mmc_card->type = CARD_TYPE_SD;
  402aca:	4f34      	ldr	r7, [pc, #208]	; (402b9c <sd_mmc_check+0x2c0>)
	sd_mmc_card->version = CARD_VER_UNKNOWN;
	sd_mmc_card->rca = 0;
	sd_mmc_debug("Start SD card install\n\r");

	// Card need of 74 cycles clock minimum to start
	driver_send_clock();
  402acc:	f8df 80dc 	ldr.w	r8, [pc, #220]	; 402bac <sd_mmc_check+0x2d0>
static bool sd_mmc_mci_card_init(void)
{
	uint8_t v2 = 0;

	// In first, try to install SD/SDIO card
	sd_mmc_card->type = CARD_TYPE_SD;
  402ad0:	683b      	ldr	r3, [r7, #0]

	// Card need of 74 cycles clock minimum to start
	driver_send_clock();

	// CMD0 - Reset all cards to idle state.
	if (!driver_send_cmd(SDMMC_MCI_CMD0_GO_IDLE_STATE, 0)) {
  402ad2:	4e29      	ldr	r6, [pc, #164]	; (402b78 <sd_mmc_check+0x29c>)
static bool sd_mmc_mci_card_init(void)
{
	uint8_t v2 = 0;

	// In first, try to install SD/SDIO card
	sd_mmc_card->type = CARD_TYPE_SD;
  402ad4:	73d8      	strb	r0, [r3, #15]
	sd_mmc_card->version = CARD_VER_UNKNOWN;
  402ad6:	741d      	strb	r5, [r3, #16]
	sd_mmc_card->rca = 0;
  402ad8:	819d      	strh	r5, [r3, #12]
	sd_mmc_debug("Start SD card install\n\r");

	// Card need of 74 cycles clock minimum to start
	driver_send_clock();
  402ada:	47c0      	blx	r8

	// CMD0 - Reset all cards to idle state.
	if (!driver_send_cmd(SDMMC_MCI_CMD0_GO_IDLE_STATE, 0)) {
  402adc:	4629      	mov	r1, r5
  402ade:	f44f 4080 	mov.w	r0, #16384	; 0x4000
  402ae2:	47b0      	blx	r6
  402ae4:	2800      	cmp	r0, #0
  402ae6:	f47f af0a 	bne.w	4028fe <sd_mmc_check+0x22>
  402aea:	4d1f      	ldr	r5, [pc, #124]	; (402b68 <sd_mmc_check+0x28c>)
		// To notify that the card has been just initialized
		// It is necessary for USB Device MSC
		return SD_MMC_INIT_ONGOING;
	}
	sd_mmc_debug("SD/MMC card initialization failed\n\r");
	sd_mmc_card->state = SD_MMC_CARD_STATE_UNUSABLE;
  402aec:	683b      	ldr	r3, [r7, #0]
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  402aee:	7828      	ldrb	r0, [r5, #0]
		// To notify that the card has been just initialized
		// It is necessary for USB Device MSC
		return SD_MMC_INIT_ONGOING;
	}
	sd_mmc_debug("SD/MMC card initialization failed\n\r");
	sd_mmc_card->state = SD_MMC_CARD_STATE_UNUSABLE;
  402af0:	2403      	movs	r4, #3
  402af2:	739c      	strb	r4, [r3, #14]
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  402af4:	2800      	cmp	r0, #0
  402af6:	f47f aefe 	bne.w	4028f6 <sd_mmc_check+0x1a>
  402afa:	e7da      	b.n	402ab2 <sd_mmc_check+0x1d6>
	if (!driver_send_cmd(SD_CMD8_SEND_IF_COND,
			SD_CMD8_PATTERN | SD_CMD8_HIGH_VOLTAGE)) {
		return true; // It is not a V2
	}
	// Check R7 response
	resp = driver_get_response();
  402afc:	4b28      	ldr	r3, [pc, #160]	; (402ba0 <sd_mmc_check+0x2c4>)
  402afe:	4798      	blx	r3
	if (resp == 0xFFFFFFFF) {
  402b00:	1c45      	adds	r5, r0, #1
  402b02:	f43f af04 	beq.w	40290e <sd_mmc_check+0x32>
		// No compliance R7 value
		return true; // It is not a V2
	}
	if ((resp & (SD_CMD8_MASK_PATTERN | SD_CMD8_MASK_VOLTAGE))
  402b06:	f3c0 000b 	ubfx	r0, r0, #0, #12
  402b0a:	f5b0 7fd5 	cmp.w	r0, #426	; 0x1aa
  402b0e:	d1ec      	bne.n	402aea <sd_mmc_check+0x20e>
		sd_mmc_debug("%s: CMD8 resp32 0x%08x UNUSABLE CARD\n\r",
				__func__, resp);
		return false;
	}
	sd_mmc_debug("SD card V2\n\r");
	*v2 = 1;
  402b10:	46a1      	mov	r9, r4
  402b12:	e6fe      	b.n	402912 <sd_mmc_check+0x36>
	// Try to get the SDIO card's operating condition
	if (!sdio_op_cond()) {
		return false;
	}

	if (sd_mmc_card->type & CARD_TYPE_SD) {
  402b14:	f640 0535 	movw	r5, #2101	; 0x835
			sd_mmc_debug("%s: CMD55 Fail\n\r", __func__);
			return false;
		}

		// (ACMD41) Sends host OCR register
		arg = SD_MMC_VOLTAGE_SUPPORT;
  402b18:	f8df a088 	ldr.w	sl, [pc, #136]	; 402ba4 <sd_mmc_check+0x2c8>
		// Check response
		if (!driver_send_cmd(SD_MCI_ACMD41_SD_SEND_OP_COND, arg)) {
			sd_mmc_debug("%s: ACMD41 Fail\n\r", __func__);
			return false;
		}
		resp = driver_get_response();
  402b1c:	f8df b080 	ldr.w	fp, [pc, #128]	; 402ba0 <sd_mmc_check+0x2c4>
  402b20:	e00e      	b.n	402b40 <sd_mmc_check+0x264>
			sd_mmc_debug("%s: CMD55 Fail\n\r", __func__);
			return false;
		}

		// (ACMD41) Sends host OCR register
		arg = SD_MMC_VOLTAGE_SUPPORT;
  402b22:	f1b9 0f00 	cmp.w	r9, #0
		if (v2) {
			arg |= SD_ACMD41_HCS;
		}
		// Check response
		if (!driver_send_cmd(SD_MCI_ACMD41_SD_SEND_OP_COND, arg)) {
  402b26:	bf14      	ite	ne
  402b28:	4651      	movne	r1, sl
  402b2a:	f44f 11fc 	moveq.w	r1, #2064384	; 0x1f8000
  402b2e:	f244 5029 	movw	r0, #17705	; 0x4529
  402b32:	47b0      	blx	r6
  402b34:	b150      	cbz	r0, 402b4c <sd_mmc_check+0x270>
			sd_mmc_debug("%s: ACMD41 Fail\n\r", __func__);
			return false;
		}
		resp = driver_get_response();
  402b36:	47d8      	blx	fp
		if (resp & OCR_POWER_UP_BUSY) {
  402b38:	2800      	cmp	r0, #0
  402b3a:	db78      	blt.n	402c2e <sd_mmc_check+0x352>
			if ((resp & OCR_CCS) != 0) {
				sd_mmc_card->type |= CARD_TYPE_HC;
			}
			break;
		}
		if (retry-- == 0) {
  402b3c:	3d01      	subs	r5, #1
  402b3e:	d005      	beq.n	402b4c <sd_mmc_check+0x270>
	 */
	retry = 2100;
	do {
		// CMD55 - Indicate to the card that the next command is an
		// application specific command rather than a standard command.
		if (!driver_send_cmd(SDMMC_CMD55_APP_CMD, 0)) {
  402b40:	f241 1037 	movw	r0, #4407	; 0x1137
  402b44:	2100      	movs	r1, #0
  402b46:	47b0      	blx	r6
  402b48:	2800      	cmp	r0, #0
  402b4a:	d1ea      	bne.n	402b22 <sd_mmc_check+0x246>
	if (sd_mmc_card->type & CARD_TYPE_SD) {
		// Try to get the SD card's operating condition
		if (!sd_mci_op_cond(v2)) {
			// It is not a SD card
			sd_mmc_debug("Start MMC Install\n\r");
			sd_mmc_card->type = CARD_TYPE_MMC;
  402b4c:	683b      	ldr	r3, [r7, #0]
  402b4e:	2202      	movs	r2, #2
  402b50:	73da      	strb	r2, [r3, #15]
static bool sd_mmc_mci_install_mmc(void)
{
	uint8_t b_authorize_high_speed;

	// CMD0 - Reset all cards to idle state.
	if (!driver_send_cmd(SDMMC_MCI_CMD0_GO_IDLE_STATE, 0)) {
  402b52:	f44f 4080 	mov.w	r0, #16384	; 0x4000
  402b56:	2100      	movs	r1, #0
  402b58:	47b0      	blx	r6
  402b5a:	2800      	cmp	r0, #0
  402b5c:	d0c5      	beq.n	402aea <sd_mmc_check+0x20e>
  402b5e:	f241 0569 	movw	r5, #4201	; 0x1069
			sd_mmc_debug("%s: CMD1 MCI Fail - Busy retry %d\n\r",
					__func__, (int)(4200 - retry));
			return false;
		}
		// Check busy flag
		resp = driver_get_response();
  402b62:	f8df 803c 	ldr.w	r8, [pc, #60]	; 402ba0 <sd_mmc_check+0x2c4>
  402b66:	e025      	b.n	402bb4 <sd_mmc_check+0x2d8>
  402b68:	20003386 	.word	0x20003386
  402b6c:	0040288d 	.word	0x0040288d
  402b70:	00415f68 	.word	0x00415f68
  402b74:	00415f28 	.word	0x00415f28
  402b78:	004036f9 	.word	0x004036f9
  402b7c:	00081133 	.word	0x00081133
  402b80:	004038a5 	.word	0x004038a5
  402b84:	0040390d 	.word	0x0040390d
  402b88:	00403645 	.word	0x00403645
  402b8c:	00402761 	.word	0x00402761
  402b90:	00403651 	.word	0x00403651
  402b94:	004036d5 	.word	0x004036d5
  402b98:	0040278d 	.word	0x0040278d
  402b9c:	20003380 	.word	0x20003380
  402ba0:	00403725 	.word	0x00403725
  402ba4:	401f8000 	.word	0x401f8000
  402ba8:	00403751 	.word	0x00403751
  402bac:	004036d9 	.word	0x004036d9
					== OCR_ACCESS_MODE_SECTOR) {
				sd_mmc_card->type |= CARD_TYPE_HC;
			}
			break;
		}
		if (retry-- == 0) {
  402bb0:	3d01      	subs	r5, #1
  402bb2:	d09a      	beq.n	402aea <sd_mmc_check+0x20e>
	 * 6 = cmd byte size
	 * 6 = response byte size
	 */
	retry = 4200;
	do {
		if (!driver_send_cmd(MMC_MCI_CMD1_SEND_OP_COND,
  402bb4:	49af      	ldr	r1, [pc, #700]	; (402e74 <sd_mmc_check+0x598>)
			sd_mmc_debug("%s: CMD1 MCI Fail - Busy retry %d\n\r",
					__func__, (int)(4200 - retry));
			return false;
		}
		// Check busy flag
		resp = driver_get_response();
  402bb6:	f8df 92fc 	ldr.w	r9, [pc, #764]	; 402eb4 <sd_mmc_check+0x5d8>
	 * 6 = cmd byte size
	 * 6 = response byte size
	 */
	retry = 4200;
	do {
		if (!driver_send_cmd(MMC_MCI_CMD1_SEND_OP_COND,
  402bba:	f244 5001 	movw	r0, #17665	; 0x4501
  402bbe:	47b0      	blx	r6
  402bc0:	2800      	cmp	r0, #0
  402bc2:	d092      	beq.n	402aea <sd_mmc_check+0x20e>
			sd_mmc_debug("%s: CMD1 MCI Fail - Busy retry %d\n\r",
					__func__, (int)(4200 - retry));
			return false;
		}
		// Check busy flag
		resp = driver_get_response();
  402bc4:	47c0      	blx	r8
		if (resp & OCR_POWER_UP_BUSY) {
  402bc6:	2800      	cmp	r0, #0
  402bc8:	daf2      	bge.n	402bb0 <sd_mmc_check+0x2d4>
			// Check OCR value
			if ((resp & OCR_ACCESS_MODE_MASK)
  402bca:	f000 40c0 	and.w	r0, r0, #1610612736	; 0x60000000
  402bce:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
  402bd2:	d104      	bne.n	402bde <sd_mmc_check+0x302>
					== OCR_ACCESS_MODE_SECTOR) {
				sd_mmc_card->type |= CARD_TYPE_HC;
  402bd4:	683b      	ldr	r3, [r7, #0]
  402bd6:	7bda      	ldrb	r2, [r3, #15]
  402bd8:	f042 0208 	orr.w	r2, r2, #8
  402bdc:	73da      	strb	r2, [r3, #15]
		return false;
	}

	// Put the Card in Identify Mode
	// Note: The CID is not used in this stack
	if (!driver_send_cmd(SDMMC_CMD2_ALL_SEND_CID, 0)) {
  402bde:	f645 3002 	movw	r0, #23298	; 0x5b02
  402be2:	2100      	movs	r1, #0
  402be4:	f8df 82d0 	ldr.w	r8, [pc, #720]	; 402eb8 <sd_mmc_check+0x5dc>
  402be8:	47b0      	blx	r6
  402bea:	2800      	cmp	r0, #0
  402bec:	f43f af7d 	beq.w	402aea <sd_mmc_check+0x20e>
		return false;
	}
	// Assign relative address to the card.
	sd_mmc_card->rca = 1;
  402bf0:	683b      	ldr	r3, [r7, #0]
  402bf2:	4da1      	ldr	r5, [pc, #644]	; (402e78 <sd_mmc_check+0x59c>)
  402bf4:	2201      	movs	r2, #1
  402bf6:	819a      	strh	r2, [r3, #12]
	if (!driver_send_cmd(MMC_CMD3_SET_RELATIVE_ADDR,
  402bf8:	f241 1003 	movw	r0, #4355	; 0x1103
  402bfc:	f44f 3180 	mov.w	r1, #65536	; 0x10000
  402c00:	47c0      	blx	r8
  402c02:	2800      	cmp	r0, #0
  402c04:	f43f af71 	beq.w	402aea <sd_mmc_check+0x20e>
			(uint32_t)sd_mmc_card->rca << 16)) {
		return false;
	}
	// Get the Card-Specific Data
	if (!sd_mmc_cmd9_mci()) {
  402c08:	4b9c      	ldr	r3, [pc, #624]	; (402e7c <sd_mmc_check+0x5a0>)
  402c0a:	4798      	blx	r3
  402c0c:	2800      	cmp	r0, #0
  402c0e:	f43f af6c 	beq.w	402aea <sd_mmc_check+0x20e>
 	uint32_t unit;
	uint32_t mul;
	uint32_t tran_speed;

	// Get MMC System Specification version supported by the card
	switch (MMC_CSD_SPEC_VERS(sd_mmc_card->csd)) {
  402c12:	682b      	ldr	r3, [r5, #0]
  402c14:	7c9a      	ldrb	r2, [r3, #18]
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	value &=  ((uint32_t)1 << size) - 1;
  402c16:	f3c2 0283 	ubfx	r2, r2, #2, #4
  402c1a:	3a01      	subs	r2, #1
  402c1c:	2a03      	cmp	r2, #3
  402c1e:	f200 817c 	bhi.w	402f1a <sd_mmc_check+0x63e>
  402c22:	e8df f012 	tbh	[pc, r2, lsl #1]
  402c26:	0177      	.short	0x0177
  402c28:	0124017d 	.word	0x0124017d
  402c2c:	0068      	.short	0x0068
			return false;
		}
		resp = driver_get_response();
		if (resp & OCR_POWER_UP_BUSY) {
			// Card is ready
			if ((resp & OCR_CCS) != 0) {
  402c2e:	0041      	lsls	r1, r0, #1
  402c30:	d50f      	bpl.n	402c52 <sd_mmc_check+0x376>
				sd_mmc_card->type |= CARD_TYPE_HC;
  402c32:	683a      	ldr	r2, [r7, #0]
  402c34:	7bd3      	ldrb	r3, [r2, #15]
  402c36:	f043 0308 	orr.w	r3, r3, #8
  402c3a:	73d3      	strb	r3, [r2, #15]
			sd_mmc_card->type = CARD_TYPE_MMC;
			return sd_mmc_mci_install_mmc();
		}
	}

	if (sd_mmc_card->type & CARD_TYPE_SD) {
  402c3c:	07db      	lsls	r3, r3, #31
  402c3e:	f57f ae6d 	bpl.w	40291c <sd_mmc_check+0x40>
		// SD MEMORY, Put the Card in Identify Mode
		// Note: The CID is not used in this stack
		if (!driver_send_cmd(SDMMC_CMD2_ALL_SEND_CID, 0)) {
  402c42:	f645 3002 	movw	r0, #23298	; 0x5b02
  402c46:	2100      	movs	r1, #0
  402c48:	47b0      	blx	r6
  402c4a:	2800      	cmp	r0, #0
  402c4c:	f47f ae66 	bne.w	40291c <sd_mmc_check+0x40>
  402c50:	e74b      	b.n	402aea <sd_mmc_check+0x20e>
  402c52:	683b      	ldr	r3, [r7, #0]
  402c54:	7bdb      	ldrb	r3, [r3, #15]
  402c56:	e7f1      	b.n	402c3c <sd_mmc_check+0x360>
		// Valid new configuration
		sd_mmc_configure_slot();
	}
	// SD MEMORY, Set default block size
	if (sd_mmc_card->type & CARD_TYPE_SD) {
		if (!driver_send_cmd(SDMMC_CMD16_SET_BLOCKLEN, SD_MMC_BLOCK_SIZE)) {
  402c58:	f241 1010 	movw	r0, #4368	; 0x1110
  402c5c:	f44f 7100 	mov.w	r1, #512	; 0x200
  402c60:	47b0      	blx	r6
  402c62:	2800      	cmp	r0, #0
  402c64:	f43f af42 	beq.w	402aec <sd_mmc_check+0x210>
  402c68:	f8d8 2000 	ldr.w	r2, [r8]
  402c6c:	e71b      	b.n	402aa6 <sd_mmc_check+0x1ca>
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  402c6e:	7e59      	ldrb	r1, [r3, #25]
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  402c70:	7e98      	ldrb	r0, [r3, #26]
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  402c72:	7eda      	ldrb	r2, [r3, #27]
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  402c74:	0409      	lsls	r1, r1, #16
  402c76:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  402c7a:	430a      	orrs	r2, r1
	}
	value &=  ((uint32_t)1 << size) - 1;
  402c7c:	f3c2 0215 	ubfx	r2, r2, #0, #22
	 * memory capacity = (C_SIZE+1) * 512K byte
	 */
	if (CSD_STRUCTURE_VERSION(sd_mmc_card->csd) >= SD_CSD_VER_2_0) {
		sd_mmc_card->capacity =
				(SD_CSD_2_0_C_SIZE(sd_mmc_card->csd) + 1)
				* 512;
  402c80:	3201      	adds	r2, #1
  402c82:	0252      	lsls	r2, r2, #9
	 * ----------------------------------------------------
	 * For high capacity SD card:
	 * memory capacity = (C_SIZE+1) * 512K byte
	 */
	if (CSD_STRUCTURE_VERSION(sd_mmc_card->csd) >= SD_CSD_VER_2_0) {
		sd_mmc_card->capacity =
  402c84:	605a      	str	r2, [r3, #4]
  402c86:	e697      	b.n	4029b8 <sd_mmc_check+0xdc>
 */
static bool sd_cm6_set_high_speed(void)
{
	uint8_t switch_status[SD_SW_STATUS_BSIZE];

	if (!driver_adtc_start(SD_CMD6_SWITCH_FUNC,
  402c88:	f04f 0a01 	mov.w	sl, #1
  402c8c:	f8cd a000 	str.w	sl, [sp]
  402c90:	4653      	mov	r3, sl
  402c92:	487b      	ldr	r0, [pc, #492]	; (402e80 <sd_mmc_check+0x5a4>)
  402c94:	497b      	ldr	r1, [pc, #492]	; (402e84 <sd_mmc_check+0x5a8>)
  402c96:	f8df c204 	ldr.w	ip, [pc, #516]	; 402e9c <sd_mmc_check+0x5c0>
  402c9a:	2240      	movs	r2, #64	; 0x40
  402c9c:	47e0      	blx	ip
  402c9e:	2800      	cmp	r0, #0
  402ca0:	f43f af24 	beq.w	402aec <sd_mmc_check+0x210>
			| SD_CMD6_GRP2_DEFAULT
			| SD_CMD6_GRP1_HIGH_SPEED,
			SD_SW_STATUS_BSIZE, 1, true)) {
		return false;
	}
	if (!driver_start_read_blocks(switch_status, 1)) {
  402ca4:	a804      	add	r0, sp, #16
  402ca6:	4651      	mov	r1, sl
  402ca8:	4b77      	ldr	r3, [pc, #476]	; (402e88 <sd_mmc_check+0x5ac>)
  402caa:	4798      	blx	r3
  402cac:	2800      	cmp	r0, #0
  402cae:	f43f af1d 	beq.w	402aec <sd_mmc_check+0x210>
		return false;
	}
	if (!driver_wait_end_of_read_blocks()) {
  402cb2:	4b76      	ldr	r3, [pc, #472]	; (402e8c <sd_mmc_check+0x5b0>)
  402cb4:	4798      	blx	r3
  402cb6:	2800      	cmp	r0, #0
  402cb8:	f43f af18 	beq.w	402aec <sd_mmc_check+0x210>
		return false;
	}

	if (driver_get_response() & CARD_STATUS_SWITCH_ERROR) {
  402cbc:	47c8      	blx	r9
  402cbe:	0600      	lsls	r0, r0, #24
  402cc0:	f53f af14 	bmi.w	402aec <sd_mmc_check+0x210>
  402cc4:	f89d 3020 	ldrb.w	r3, [sp, #32]
		sd_mmc_debug("%s: CMD6 CARD_STATUS_SWITCH_ERROR\n\r", __func__);
		return false;
	}
	if (SD_SW_STATUS_FUN_GRP1_RC(switch_status)
  402cc8:	f003 030f 	and.w	r3, r3, #15
  402ccc:	2b0f      	cmp	r3, #15
  402cce:	f43f aee1 	beq.w	402a94 <sd_mmc_check+0x1b8>
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  402cd2:	f89d 302d 	ldrb.w	r3, [sp, #45]	; 0x2d
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  402cd6:	f89d 202c 	ldrb.w	r2, [sp, #44]	; 0x2c
			== SD_SW_STATUS_FUN_GRP_RC_ERROR) {
		// No supported, it is not a protocol error
		return true;
	}
	if (SD_SW_STATUS_FUN_GRP1_BUSY(switch_status)) {
  402cda:	ea53 2202 	orrs.w	r2, r3, r2, lsl #8
  402cde:	f47f af05 	bne.w	402aec <sd_mmc_check+0x210>
		sd_mmc_debug("%s: CMD6 SD_SW_STATUS_FUN_GRP1_BUSY\n\r", __func__);
		return false;
	}
	// CMD6 function switching period is within 8 clocks
	// after the end bit of status data.
	driver_send_clock();
  402ce2:	47c0      	blx	r8
	sd_mmc_card->high_speed = 1;
  402ce4:	f8db 3000 	ldr.w	r3, [fp]
	sd_mmc_card->clock *= 2;
  402ce8:	681a      	ldr	r2, [r3, #0]
		return false;
	}
	// CMD6 function switching period is within 8 clocks
	// after the end bit of status data.
	driver_send_clock();
	sd_mmc_card->high_speed = 1;
  402cea:	f883 a022 	strb.w	sl, [r3, #34]	; 0x22
	sd_mmc_card->clock *= 2;
  402cee:	fa02 f20a 	lsl.w	r2, r2, sl
  402cf2:	601a      	str	r2, [r3, #0]
  402cf4:	e6ce      	b.n	402a94 <sd_mmc_check+0x1b8>
	case 3:
		sd_mmc_card->version = CARD_VER_MMC_3;
		break;

	case 4:
		sd_mmc_card->version = CARD_VER_MMC_4;
  402cf6:	2240      	movs	r2, #64	; 0x40
  402cf8:	741a      	strb	r2, [r3, #16]
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  402cfa:	7d5a      	ldrb	r2, [r3, #21]
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  402cfc:	f893 e019 	ldrb.w	lr, [r3, #25]
		break;
	}

	// Get MMC memory max transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
	unit = sd_mmc_trans_units[tran_speed & 0x7];
  402d00:	4963      	ldr	r1, [pc, #396]	; (402e90 <sd_mmc_check+0x5b4>)
	mul = mmc_trans_multipliers[(tran_speed >> 3) & 0xF];
  402d02:	4864      	ldr	r0, [pc, #400]	; (402e94 <sd_mmc_check+0x5b8>)
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  402d04:	f893 c018 	ldrb.w	ip, [r3, #24]
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  402d08:	7e9d      	ldrb	r5, [r3, #26]
		break;
	}

	// Get MMC memory max transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
	unit = sd_mmc_trans_units[tran_speed & 0x7];
  402d0a:	f002 0807 	and.w	r8, r2, #7
	mul = mmc_trans_multipliers[(tran_speed >> 3) & 0xF];
  402d0e:	f3c2 02c3 	ubfx	r2, r2, #3, #4
	sd_mmc_card->clock = unit * mul * 1000;
  402d12:	f851 1028 	ldr.w	r1, [r1, r8, lsl #2]
  402d16:	f850 0022 	ldr.w	r0, [r0, r2, lsl #2]
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  402d1a:	ea4f 028e 	mov.w	r2, lr, lsl #2
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  402d1e:	ea42 228c 	orr.w	r2, r2, ip, lsl #10
  402d22:	f44f 7e7a 	mov.w	lr, #1000	; 0x3e8
  402d26:	fb0e f101 	mul.w	r1, lr, r1
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  402d2a:	ea42 1295 	orr.w	r2, r2, r5, lsr #6
  402d2e:	fb00 f001 	mul.w	r0, r0, r1
	}
	value &=  ((uint32_t)1 << size) - 1;
  402d32:	f3c2 020b 	ubfx	r2, r2, #0, #12
	 * BLOCK_LEN = 2 ^ READ_BL_LEN      (READ_BL_LEN < 12)
	 * ----------------------------------------------------
	 * For high capacity SD/MMC card:
	 * memory capacity = SEC_COUNT * 512 byte
	 */
	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) != 0xFFF) {
  402d36:	f640 71ff 	movw	r1, #4095	; 0xfff
  402d3a:	428a      	cmp	r2, r1

	// Get MMC memory max transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
	unit = sd_mmc_trans_units[tran_speed & 0x7];
	mul = mmc_trans_multipliers[(tran_speed >> 3) & 0xF];
	sd_mmc_card->clock = unit * mul * 1000;
  402d3c:	6018      	str	r0, [r3, #0]
	 * BLOCK_LEN = 2 ^ READ_BL_LEN      (READ_BL_LEN < 12)
	 * ----------------------------------------------------
	 * For high capacity SD/MMC card:
	 * memory capacity = SEC_COUNT * 512 byte
	 */
	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) != 0xFFF) {
  402d3e:	d011      	beq.n	402d64 <sd_mmc_check+0x488>
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  402d40:	7ed9      	ldrb	r1, [r3, #27]
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  402d42:	7f1d      	ldrb	r5, [r3, #28]
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	value &=  ((uint32_t)1 << size) - 1;
  402d44:	7dd8      	ldrb	r0, [r3, #23]
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  402d46:	0049      	lsls	r1, r1, #1
  402d48:	ea41 11d5 	orr.w	r1, r1, r5, lsr #7
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	value &=  ((uint32_t)1 << size) - 1;
  402d4c:	f001 0107 	and.w	r1, r1, #7
		uint32_t blocknr = ((MMC_CSD_C_SIZE(sd_mmc_card->csd) + 1) *
  402d50:	3201      	adds	r2, #1
			(1 << (MMC_CSD_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
  402d52:	3102      	adds	r1, #2
	 * ----------------------------------------------------
	 * For high capacity SD/MMC card:
	 * memory capacity = SEC_COUNT * 512 byte
	 */
	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) != 0xFFF) {
		uint32_t blocknr = ((MMC_CSD_C_SIZE(sd_mmc_card->csd) + 1) *
  402d54:	fa02 f101 	lsl.w	r1, r2, r1
			(1 << (MMC_CSD_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
		sd_mmc_card->capacity = blocknr *
  402d58:	f000 020f 	and.w	r2, r0, #15
  402d5c:	fa01 f202 	lsl.w	r2, r1, r2
			(1 << MMC_CSD_READ_BL_LEN(sd_mmc_card->csd)) / 1024;
  402d60:	0a92      	lsrs	r2, r2, #10
	 * memory capacity = SEC_COUNT * 512 byte
	 */
	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) != 0xFFF) {
		uint32_t blocknr = ((MMC_CSD_C_SIZE(sd_mmc_card->csd) + 1) *
			(1 << (MMC_CSD_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
		sd_mmc_card->capacity = blocknr *
  402d62:	605a      	str	r2, [r3, #4]
		return false;
	}
	mmc_decode_csd();
	// Select the and put it into Transfer Mode
	if (!driver_send_cmd(SDMMC_CMD7_SELECT_CARD_CMD,
			(uint32_t)sd_mmc_card->rca << 16)) {
  402d64:	8999      	ldrh	r1, [r3, #12]
	if (!sd_mmc_cmd9_mci()) {
		return false;
	}
	mmc_decode_csd();
	// Select the and put it into Transfer Mode
	if (!driver_send_cmd(SDMMC_CMD7_SELECT_CARD_CMD,
  402d66:	f243 1007 	movw	r0, #12551	; 0x3107
  402d6a:	0409      	lsls	r1, r1, #16
  402d6c:	47b0      	blx	r6
  402d6e:	2800      	cmp	r0, #0
  402d70:	f43f aebb 	beq.w	402aea <sd_mmc_check+0x20e>
			(uint32_t)sd_mmc_card->rca << 16)) {
		return false;
	}
	if (sd_mmc_card->version >= CARD_VER_MMC_4) {
  402d74:	683b      	ldr	r3, [r7, #0]
  402d76:	7c1b      	ldrb	r3, [r3, #16]
  402d78:	2b3f      	cmp	r3, #63	; 0x3f
  402d7a:	f240 80b1 	bls.w	402ee0 <sd_mmc_check+0x604>
{
	uint16_t i;
	uint32_t ext_csd;
	uint32_t sec_count;

	if (!driver_adtc_start(MMC_CMD8_SEND_EXT_CSD, 0,
  402d7e:	2100      	movs	r1, #0
  402d80:	9100      	str	r1, [sp, #0]
  402d82:	4845      	ldr	r0, [pc, #276]	; (402e98 <sd_mmc_check+0x5bc>)
  402d84:	4d45      	ldr	r5, [pc, #276]	; (402e9c <sd_mmc_check+0x5c0>)
  402d86:	f44f 7200 	mov.w	r2, #512	; 0x200
  402d8a:	2301      	movs	r3, #1
  402d8c:	47a8      	blx	r5
  402d8e:	2800      	cmp	r0, #0
  402d90:	f43f aeab 	beq.w	402aea <sd_mmc_check+0x20e>
  402d94:	f8df 8124 	ldr.w	r8, [pc, #292]	; 402ebc <sd_mmc_check+0x5e0>
  402d98:	2532      	movs	r5, #50	; 0x32
	// Note: The read access is done in byte to avoid a buffer
	// of EXT_CSD_BSIZE Byte in stack.

	// Read card type
	for (i = 0; i < (EXT_CSD_CARD_TYPE_INDEX + 4) / 4; i++) {
		if (!driver_read_word(&ext_csd)) {
  402d9a:	a803      	add	r0, sp, #12
  402d9c:	47c0      	blx	r8
  402d9e:	3d01      	subs	r5, #1
  402da0:	b2ad      	uxth	r5, r5
  402da2:	2800      	cmp	r0, #0
  402da4:	f43f aea1 	beq.w	402aea <sd_mmc_check+0x20e>
	//** Read and decode Extended Extended CSD
	// Note: The read access is done in byte to avoid a buffer
	// of EXT_CSD_BSIZE Byte in stack.

	// Read card type
	for (i = 0; i < (EXT_CSD_CARD_TYPE_INDEX + 4) / 4; i++) {
  402da8:	2d00      	cmp	r5, #0
  402daa:	d1f6      	bne.n	402d9a <sd_mmc_check+0x4be>
		}
	}
	*b_authorize_high_speed = (ext_csd >> ((EXT_CSD_CARD_TYPE_INDEX % 4) * 8))
			& MMC_CTYPE_52MHZ;

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
  402dac:	683b      	ldr	r3, [r7, #0]
	for (i = 0; i < (EXT_CSD_CARD_TYPE_INDEX + 4) / 4; i++) {
		if (!driver_read_word(&ext_csd)) {
			return false;
		}
	}
	*b_authorize_high_speed = (ext_csd >> ((EXT_CSD_CARD_TYPE_INDEX % 4) * 8))
  402dae:	9a03      	ldr	r2, [sp, #12]
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  402db0:	7e5d      	ldrb	r5, [r3, #25]
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  402db2:	7e18      	ldrb	r0, [r3, #24]
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  402db4:	7e99      	ldrb	r1, [r3, #26]
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  402db6:	00ab      	lsls	r3, r5, #2
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  402db8:	ea43 2380 	orr.w	r3, r3, r0, lsl #10
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  402dbc:	ea43 1191 	orr.w	r1, r3, r1, lsr #6
	}
	value &=  ((uint32_t)1 << size) - 1;
  402dc0:	f3c1 010b 	ubfx	r1, r1, #0, #12
			& MMC_CTYPE_52MHZ;

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
  402dc4:	f640 73ff 	movw	r3, #4095	; 0xfff
	for (i = 0; i < (EXT_CSD_CARD_TYPE_INDEX + 4) / 4; i++) {
		if (!driver_read_word(&ext_csd)) {
			return false;
		}
	}
	*b_authorize_high_speed = (ext_csd >> ((EXT_CSD_CARD_TYPE_INDEX % 4) * 8))
  402dc8:	f002 0202 	and.w	r2, r2, #2
			& MMC_CTYPE_52MHZ;

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
  402dcc:	4299      	cmp	r1, r3
	for (i = 0; i < (EXT_CSD_CARD_TYPE_INDEX + 4) / 4; i++) {
		if (!driver_read_word(&ext_csd)) {
			return false;
		}
	}
	*b_authorize_high_speed = (ext_csd >> ((EXT_CSD_CARD_TYPE_INDEX % 4) * 8))
  402dce:	fa5f fa82 	uxtb.w	sl, r2
			& MMC_CTYPE_52MHZ;

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
  402dd2:	f04f 0532 	mov.w	r5, #50	; 0x32
  402dd6:	f10d 0b10 	add.w	fp, sp, #16
  402dda:	d073      	beq.n	402ec4 <sd_mmc_check+0x5e8>
			}
		}
		sd_mmc_card->capacity = sec_count / 2;
	}
	for (; i < EXT_CSD_BSIZE / 4; i++) {
		if (!driver_read_word(&sec_count)) {
  402ddc:	4658      	mov	r0, fp
  402dde:	47c0      	blx	r8
				return false;
			}
		}
		sd_mmc_card->capacity = sec_count / 2;
	}
	for (; i < EXT_CSD_BSIZE / 4; i++) {
  402de0:	3501      	adds	r5, #1
  402de2:	b2ad      	uxth	r5, r5
		if (!driver_read_word(&sec_count)) {
  402de4:	2800      	cmp	r0, #0
  402de6:	f43f ae80 	beq.w	402aea <sd_mmc_check+0x20e>
				return false;
			}
		}
		sd_mmc_card->capacity = sec_count / 2;
	}
	for (; i < EXT_CSD_BSIZE / 4; i++) {
  402dea:	2d7f      	cmp	r5, #127	; 0x7f
  402dec:	d9f6      	bls.n	402ddc <sd_mmc_check+0x500>
		// For MMC 4.0 Higher version
		// Get EXT_CSD
		if (!mmc_cmd8(&b_authorize_high_speed)) {
			return false;
		}
		if (4 <= driver_get_bus_width(sd_mmc_slot_sel)) {
  402dee:	4d2c      	ldr	r5, [pc, #176]	; (402ea0 <sd_mmc_check+0x5c4>)
  402df0:	f8df 80cc 	ldr.w	r8, [pc, #204]	; 402ec0 <sd_mmc_check+0x5e4>
  402df4:	7828      	ldrb	r0, [r5, #0]
  402df6:	47c0      	blx	r8
  402df8:	2803      	cmp	r0, #3
  402dfa:	d918      	bls.n	402e2e <sd_mmc_check+0x552>
			// Enable more bus width
			if (!mmc_cmd6_set_bus_width(driver_get_bus_width(sd_mmc_slot_sel))) {
  402dfc:	7828      	ldrb	r0, [r5, #0]
  402dfe:	47c0      	blx	r8
 */
static bool mmc_cmd6_set_bus_width(uint8_t bus_width)
{
	uint32_t arg;

	switch (bus_width) {
  402e00:	2804      	cmp	r0, #4
		if (!mmc_cmd8(&b_authorize_high_speed)) {
			return false;
		}
		if (4 <= driver_get_bus_width(sd_mmc_slot_sel)) {
			// Enable more bus width
			if (!mmc_cmd6_set_bus_width(driver_get_bus_width(sd_mmc_slot_sel))) {
  402e02:	4680      	mov	r8, r0
 */
static bool mmc_cmd6_set_bus_width(uint8_t bus_width)
{
	uint32_t arg;

	switch (bus_width) {
  402e04:	d070      	beq.n	402ee8 <sd_mmc_check+0x60c>
		arg = MMC_CMD6_ACCESS_SET_BITS
				| MMC_CMD6_INDEX_BUS_WIDTH
				| MMC_CMD6_VALUE_BUS_WIDTH_4BIT;
		break;
	default:
		arg = MMC_CMD6_ACCESS_SET_BITS
  402e06:	4927      	ldr	r1, [pc, #156]	; (402ea4 <sd_mmc_check+0x5c8>)
  402e08:	4b27      	ldr	r3, [pc, #156]	; (402ea8 <sd_mmc_check+0x5cc>)
  402e0a:	2808      	cmp	r0, #8
  402e0c:	bf18      	it	ne
  402e0e:	4619      	movne	r1, r3
				| MMC_CMD6_INDEX_BUS_WIDTH
				| MMC_CMD6_VALUE_BUS_WIDTH_1BIT;
		break;
	}
	if (!driver_send_cmd(MMC_CMD6_SWITCH, arg)) {
  402e10:	f243 1006 	movw	r0, #12550	; 0x3106
  402e14:	47b0      	blx	r6
  402e16:	2800      	cmp	r0, #0
  402e18:	f43f ae68 	beq.w	402aec <sd_mmc_check+0x210>
		return false;
	}
	if (driver_get_response() & CARD_STATUS_SWITCH_ERROR) {
  402e1c:	47c8      	blx	r9
  402e1e:	0602      	lsls	r2, r0, #24
  402e20:	f53f ae64 	bmi.w	402aec <sd_mmc_check+0x210>
		// No supported, it is not a protocol error
		sd_mmc_debug("%s: CMD6 CARD_STATUS_SWITCH_ERROR\n\r", __func__);
		return false;
	}
	sd_mmc_card->bus_width = bus_width;
  402e24:	683b      	ldr	r3, [r7, #0]
			// Enable more bus width
			if (!mmc_cmd6_set_bus_width(driver_get_bus_width(sd_mmc_slot_sel))) {
				return false;
			}
			// Reinitialize the slot with the bus width
			sd_mmc_configure_slot();
  402e26:	4a21      	ldr	r2, [pc, #132]	; (402eac <sd_mmc_check+0x5d0>)
	if (driver_get_response() & CARD_STATUS_SWITCH_ERROR) {
		// No supported, it is not a protocol error
		sd_mmc_debug("%s: CMD6 CARD_STATUS_SWITCH_ERROR\n\r", __func__);
		return false;
	}
	sd_mmc_card->bus_width = bus_width;
  402e28:	f883 8011 	strb.w	r8, [r3, #17]
			// Enable more bus width
			if (!mmc_cmd6_set_bus_width(driver_get_bus_width(sd_mmc_slot_sel))) {
				return false;
			}
			// Reinitialize the slot with the bus width
			sd_mmc_configure_slot();
  402e2c:	4790      	blx	r2
		}
		if (driver_is_high_speed_capable() && b_authorize_high_speed) {
  402e2e:	4b20      	ldr	r3, [pc, #128]	; (402eb0 <sd_mmc_check+0x5d4>)
  402e30:	4798      	blx	r3
  402e32:	b110      	cbz	r0, 402e3a <sd_mmc_check+0x55e>
  402e34:	f1ba 0f00 	cmp.w	sl, #0
  402e38:	d158      	bne.n	402eec <sd_mmc_check+0x610>
		arg = MMC_CMD6_ACCESS_SET_BITS
				| MMC_CMD6_INDEX_BUS_WIDTH
				| MMC_CMD6_VALUE_BUS_WIDTH_4BIT;
		break;
	default:
		arg = MMC_CMD6_ACCESS_SET_BITS
  402e3a:	f04f 080a 	mov.w	r8, #10
		// Retry is a WORKAROUND for no compliance card (Atmel Internal ref. MMC19):
		// These cards seem not ready immediatly
		// after the end of busy of mmc_cmd6_set_high_speed()

		// Set default block size
		if (driver_send_cmd(SDMMC_CMD16_SET_BLOCKLEN, SD_MMC_BLOCK_SIZE)) {
  402e3e:	f241 1010 	movw	r0, #4368	; 0x1110
  402e42:	f44f 7100 	mov.w	r1, #512	; 0x200
  402e46:	47b0      	blx	r6
  402e48:	f108 38ff 	add.w	r8, r8, #4294967295
  402e4c:	2800      	cmp	r0, #0
  402e4e:	d16a      	bne.n	402f26 <sd_mmc_check+0x64a>
		// Reinitialize the slot with the new speed
		sd_mmc_configure_slot();
	}

	uint8_t retry = 10;
	while (retry--) {
  402e50:	f018 08ff 	ands.w	r8, r8, #255	; 0xff
  402e54:	f43f ae4a 	beq.w	402aec <sd_mmc_check+0x210>
  402e58:	e7f1      	b.n	402e3e <sd_mmc_check+0x562>
			sd_mmc_card->version = CARD_VER_SD_2_0;
		}
		break;

	default:
		sd_mmc_card->version = CARD_VER_SD_1_0;
  402e5a:	f8da 3000 	ldr.w	r3, [sl]
  402e5e:	2210      	movs	r2, #16
  402e60:	741a      	strb	r2, [r3, #16]
  402e62:	e5e9      	b.n	402a38 <sd_mmc_check+0x15c>
	case SD_SCR_SD_SPEC_1_0_01:
		sd_mmc_card->version = CARD_VER_SD_1_0;
		break;

	case SD_SCR_SD_SPEC_1_10:
		sd_mmc_card->version = CARD_VER_SD_1_10;
  402e64:	f8da 3000 	ldr.w	r3, [sl]
  402e68:	221a      	movs	r2, #26
  402e6a:	741a      	strb	r2, [r3, #16]
  402e6c:	e5e4      	b.n	402a38 <sd_mmc_check+0x15c>
	case 2:
		sd_mmc_card->version = CARD_VER_MMC_2_2;
		break;

	case 3:
		sd_mmc_card->version = CARD_VER_MMC_3;
  402e6e:	2230      	movs	r2, #48	; 0x30
  402e70:	741a      	strb	r2, [r3, #16]
  402e72:	e742      	b.n	402cfa <sd_mmc_check+0x41e>
  402e74:	401f8000 	.word	0x401f8000
  402e78:	20003380 	.word	0x20003380
  402e7c:	0040288d 	.word	0x0040288d
  402e80:	00081106 	.word	0x00081106
  402e84:	80ffff01 	.word	0x80ffff01
  402e88:	004038a5 	.word	0x004038a5
  402e8c:	0040390d 	.word	0x0040390d
  402e90:	00415f68 	.word	0x00415f68
  402e94:	00415f84 	.word	0x00415f84
  402e98:	00081108 	.word	0x00081108
  402e9c:	00403751 	.word	0x00403751
  402ea0:	20003386 	.word	0x20003386
  402ea4:	01b70200 	.word	0x01b70200
  402ea8:	01b70000 	.word	0x01b70000
  402eac:	00402761 	.word	0x00402761
  402eb0:	00403651 	.word	0x00403651
  402eb4:	00403725 	.word	0x00403725
  402eb8:	004036f9 	.word	0x004036f9
  402ebc:	00403801 	.word	0x00403801
  402ec0:	00403645 	.word	0x00403645

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
		// For high capacity SD/MMC card,
		// memory capacity = SEC_COUNT * 512 byte
		for (; i <(EXT_CSD_SEC_COUNT_INDEX + 4) / 4; i++) {
			if (!driver_read_word(&sec_count)) {
  402ec4:	4658      	mov	r0, fp
  402ec6:	47c0      	blx	r8
			& MMC_CTYPE_52MHZ;

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
		// For high capacity SD/MMC card,
		// memory capacity = SEC_COUNT * 512 byte
		for (; i <(EXT_CSD_SEC_COUNT_INDEX + 4) / 4; i++) {
  402ec8:	3501      	adds	r5, #1
  402eca:	b2ad      	uxth	r5, r5
			if (!driver_read_word(&sec_count)) {
  402ecc:	2800      	cmp	r0, #0
  402ece:	f43f ae0c 	beq.w	402aea <sd_mmc_check+0x20e>
			& MMC_CTYPE_52MHZ;

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
		// For high capacity SD/MMC card,
		// memory capacity = SEC_COUNT * 512 byte
		for (; i <(EXT_CSD_SEC_COUNT_INDEX + 4) / 4; i++) {
  402ed2:	2d36      	cmp	r5, #54	; 0x36
  402ed4:	d1f6      	bne.n	402ec4 <sd_mmc_check+0x5e8>
			if (!driver_read_word(&sec_count)) {
				return false;
			}
		}
		sd_mmc_card->capacity = sec_count / 2;
  402ed6:	9a04      	ldr	r2, [sp, #16]
  402ed8:	683b      	ldr	r3, [r7, #0]
  402eda:	0852      	lsrs	r2, r2, #1
  402edc:	605a      	str	r2, [r3, #4]
  402ede:	e77d      	b.n	402ddc <sd_mmc_check+0x500>
			// Reinitialize the slot with the new speed
			sd_mmc_configure_slot();
		}
	} else {
		// Reinitialize the slot with the new speed
		sd_mmc_configure_slot();
  402ee0:	4b12      	ldr	r3, [pc, #72]	; (402f2c <sd_mmc_check+0x650>)
  402ee2:	4d13      	ldr	r5, [pc, #76]	; (402f30 <sd_mmc_check+0x654>)
  402ee4:	4798      	blx	r3
  402ee6:	e7a8      	b.n	402e3a <sd_mmc_check+0x55e>
		arg = MMC_CMD6_ACCESS_SET_BITS
				| MMC_CMD6_INDEX_BUS_WIDTH
				| MMC_CMD6_VALUE_BUS_WIDTH_8BIT;
		break;
	case 4:
		arg = MMC_CMD6_ACCESS_SET_BITS
  402ee8:	4912      	ldr	r1, [pc, #72]	; (402f34 <sd_mmc_check+0x658>)
  402eea:	e791      	b.n	402e10 <sd_mmc_check+0x534>
 *
 * \return true if success, otherwise false
 */
static bool mmc_cmd6_set_high_speed(void)
{
	if (!driver_send_cmd(MMC_CMD6_SWITCH,
  402eec:	f243 1006 	movw	r0, #12550	; 0x3106
  402ef0:	4911      	ldr	r1, [pc, #68]	; (402f38 <sd_mmc_check+0x65c>)
  402ef2:	47b0      	blx	r6
  402ef4:	2800      	cmp	r0, #0
  402ef6:	f43f adf9 	beq.w	402aec <sd_mmc_check+0x210>
			MMC_CMD6_ACCESS_WRITE_BYTE
			| MMC_CMD6_INDEX_HS_TIMING
			| MMC_CMD6_VALUE_HS_TIMING_ENABLE)) {
		return false;
	}
	if (driver_get_response() & CARD_STATUS_SWITCH_ERROR) {
  402efa:	47c8      	blx	r9
  402efc:	0603      	lsls	r3, r0, #24
  402efe:	f53f adf5 	bmi.w	402aec <sd_mmc_check+0x210>
		// No supported, it is not a protocol error
		sd_mmc_debug("%s: CMD6 CARD_STATUS_SWITCH_ERROR\n\r", __func__);
		return false;
	}
	sd_mmc_card->high_speed = 1;
  402f02:	683b      	ldr	r3, [r7, #0]
	sd_mmc_card->clock = 52000000lu;
  402f04:	4a0d      	ldr	r2, [pc, #52]	; (402f3c <sd_mmc_check+0x660>)
  402f06:	601a      	str	r2, [r3, #0]
	if (driver_get_response() & CARD_STATUS_SWITCH_ERROR) {
		// No supported, it is not a protocol error
		sd_mmc_debug("%s: CMD6 CARD_STATUS_SWITCH_ERROR\n\r", __func__);
		return false;
	}
	sd_mmc_card->high_speed = 1;
  402f08:	2201      	movs	r2, #1
  402f0a:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
			// Enable HS
			if (!mmc_cmd6_set_high_speed()) {
				return false;
			}
			// Reinitialize the slot with the new speed
			sd_mmc_configure_slot();
  402f0e:	4b07      	ldr	r3, [pc, #28]	; (402f2c <sd_mmc_check+0x650>)
  402f10:	4798      	blx	r3
  402f12:	e792      	b.n	402e3a <sd_mmc_check+0x55e>
	case 0:
		sd_mmc_card->version = CARD_VER_MMC_1_2;
		break;

	case 1:
		sd_mmc_card->version = CARD_VER_MMC_1_4;
  402f14:	2214      	movs	r2, #20
  402f16:	741a      	strb	r2, [r3, #16]
  402f18:	e6ef      	b.n	402cfa <sd_mmc_check+0x41e>

	// Get MMC System Specification version supported by the card
	switch (MMC_CSD_SPEC_VERS(sd_mmc_card->csd)) {
	default:
	case 0:
		sd_mmc_card->version = CARD_VER_MMC_1_2;
  402f1a:	2212      	movs	r2, #18
  402f1c:	741a      	strb	r2, [r3, #16]
  402f1e:	e6ec      	b.n	402cfa <sd_mmc_check+0x41e>
	case 1:
		sd_mmc_card->version = CARD_VER_MMC_1_4;
		break;

	case 2:
		sd_mmc_card->version = CARD_VER_MMC_2_2;
  402f20:	2222      	movs	r2, #34	; 0x22
  402f22:	741a      	strb	r2, [r3, #16]
  402f24:	e6e9      	b.n	402cfa <sd_mmc_check+0x41e>
  402f26:	683a      	ldr	r2, [r7, #0]
  402f28:	e5bd      	b.n	402aa6 <sd_mmc_check+0x1ca>
  402f2a:	bf00      	nop
  402f2c:	00402761 	.word	0x00402761
  402f30:	20003386 	.word	0x20003386
  402f34:	01b70100 	.word	0x01b70100
  402f38:	03b90100 	.word	0x03b90100
  402f3c:	03197500 	.word	0x03197500

00402f40 <sd_mmc_get_type>:
	sd_mmc_deselect_slot();
	return SD_MMC_ERR_UNUSABLE;
}

card_type_t sd_mmc_get_type(uint8_t slot)
{
  402f40:	b508      	push	{r3, lr}
 * \retval SD_MMC_INIT_ONGOING Card initialization requested
 * \retval SD_MMC_OK           Card present
 */
static sd_mmc_err_t sd_mmc_select_slot(uint8_t slot)
{
	if (slot >= SD_MMC_MEM_CNT) {
  402f42:	b108      	cbz	r0, 402f48 <sd_mmc_get_type+0x8>
}

card_type_t sd_mmc_get_type(uint8_t slot)
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
		return CARD_TYPE_UNKNOWN;
  402f44:	2000      	movs	r0, #0
  402f46:	bd08      	pop	{r3, pc}
  402f48:	4b08      	ldr	r3, [pc, #32]	; (402f6c <sd_mmc_get_type+0x2c>)
  402f4a:	4798      	blx	r3
	return SD_MMC_ERR_UNUSABLE;
}

card_type_t sd_mmc_get_type(uint8_t slot)
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
  402f4c:	2800      	cmp	r0, #0
  402f4e:	d1f9      	bne.n	402f44 <sd_mmc_get_type+0x4>
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  402f50:	4b07      	ldr	r3, [pc, #28]	; (402f70 <sd_mmc_get_type+0x30>)
  402f52:	781b      	ldrb	r3, [r3, #0]
  402f54:	b11b      	cbz	r3, 402f5e <sd_mmc_get_type+0x1e>
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
		return CARD_TYPE_UNKNOWN;
	}
	sd_mmc_deselect_slot();
	return sd_mmc_card->type;
  402f56:	4b07      	ldr	r3, [pc, #28]	; (402f74 <sd_mmc_get_type+0x34>)
  402f58:	681b      	ldr	r3, [r3, #0]
  402f5a:	7bd8      	ldrb	r0, [r3, #15]
}
  402f5c:	bd08      	pop	{r3, pc}
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
		driver_deselect_device(sd_mmc_slot_sel);
  402f5e:	4b06      	ldr	r3, [pc, #24]	; (402f78 <sd_mmc_get_type+0x38>)
  402f60:	4798      	blx	r3
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
		return CARD_TYPE_UNKNOWN;
	}
	sd_mmc_deselect_slot();
	return sd_mmc_card->type;
  402f62:	4b04      	ldr	r3, [pc, #16]	; (402f74 <sd_mmc_get_type+0x34>)
  402f64:	681b      	ldr	r3, [r3, #0]
  402f66:	7bd8      	ldrb	r0, [r3, #15]
}
  402f68:	bd08      	pop	{r3, pc}
  402f6a:	bf00      	nop
  402f6c:	0040278d 	.word	0x0040278d
  402f70:	20003386 	.word	0x20003386
  402f74:	20003380 	.word	0x20003380
  402f78:	004036d5 	.word	0x004036d5

00402f7c <sd_mmc_get_capacity>:
	sd_mmc_deselect_slot();
	return sd_mmc_card->version;
}

uint32_t sd_mmc_get_capacity(uint8_t slot)
{
  402f7c:	b508      	push	{r3, lr}
 * \retval SD_MMC_INIT_ONGOING Card initialization requested
 * \retval SD_MMC_OK           Card present
 */
static sd_mmc_err_t sd_mmc_select_slot(uint8_t slot)
{
	if (slot >= SD_MMC_MEM_CNT) {
  402f7e:	b108      	cbz	r0, 402f84 <sd_mmc_get_capacity+0x8>
}

uint32_t sd_mmc_get_capacity(uint8_t slot)
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
		return 0;
  402f80:	2000      	movs	r0, #0
  402f82:	bd08      	pop	{r3, pc}
  402f84:	4b08      	ldr	r3, [pc, #32]	; (402fa8 <sd_mmc_get_capacity+0x2c>)
  402f86:	4798      	blx	r3
	return sd_mmc_card->version;
}

uint32_t sd_mmc_get_capacity(uint8_t slot)
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
  402f88:	2800      	cmp	r0, #0
  402f8a:	d1f9      	bne.n	402f80 <sd_mmc_get_capacity+0x4>
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  402f8c:	4b07      	ldr	r3, [pc, #28]	; (402fac <sd_mmc_get_capacity+0x30>)
  402f8e:	781b      	ldrb	r3, [r3, #0]
  402f90:	b11b      	cbz	r3, 402f9a <sd_mmc_get_capacity+0x1e>
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
		return 0;
	}
	sd_mmc_deselect_slot();
	return sd_mmc_card->capacity;
  402f92:	4b07      	ldr	r3, [pc, #28]	; (402fb0 <sd_mmc_get_capacity+0x34>)
  402f94:	681b      	ldr	r3, [r3, #0]
  402f96:	6858      	ldr	r0, [r3, #4]
}
  402f98:	bd08      	pop	{r3, pc}
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
		driver_deselect_device(sd_mmc_slot_sel);
  402f9a:	4b06      	ldr	r3, [pc, #24]	; (402fb4 <sd_mmc_get_capacity+0x38>)
  402f9c:	4798      	blx	r3
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
		return 0;
	}
	sd_mmc_deselect_slot();
	return sd_mmc_card->capacity;
  402f9e:	4b04      	ldr	r3, [pc, #16]	; (402fb0 <sd_mmc_get_capacity+0x34>)
  402fa0:	681b      	ldr	r3, [r3, #0]
  402fa2:	6858      	ldr	r0, [r3, #4]
}
  402fa4:	bd08      	pop	{r3, pc}
  402fa6:	bf00      	nop
  402fa8:	0040278d 	.word	0x0040278d
  402fac:	20003386 	.word	0x20003386
  402fb0:	20003380 	.word	0x20003380
  402fb4:	004036d5 	.word	0x004036d5

00402fb8 <sd_mmc_is_write_protected>:
			== SD_MMC_0_WP_DETECT_VALUE) {
		return true;
	}
#endif
	return false;
}
  402fb8:	2000      	movs	r0, #0
  402fba:	4770      	bx	lr

00402fbc <sd_mmc_init_read_blocks>:

sd_mmc_err_t sd_mmc_init_read_blocks(uint8_t slot, uint32_t start,
		uint16_t nb_block)
{
  402fbc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  402fc0:	468b      	mov	fp, r1
  402fc2:	b083      	sub	sp, #12
  402fc4:	4692      	mov	sl, r2
 * \retval SD_MMC_INIT_ONGOING Card initialization requested
 * \retval SD_MMC_OK           Card present
 */
static sd_mmc_err_t sd_mmc_select_slot(uint8_t slot)
{
	if (slot >= SD_MMC_MEM_CNT) {
  402fc6:	b128      	cbz	r0, 402fd4 <sd_mmc_init_read_blocks+0x18>
		return SD_MMC_ERR_SLOT;
  402fc8:	f04f 0904 	mov.w	r9, #4
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}
  402fcc:	4648      	mov	r0, r9
  402fce:	b003      	add	sp, #12
  402fd0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  402fd4:	4b26      	ldr	r3, [pc, #152]	; (403070 <sd_mmc_init_read_blocks+0xb4>)
  402fd6:	4798      	blx	r3
{
	sd_mmc_err_t sd_mmc_err;
	uint32_t cmd, arg, resp;

	sd_mmc_err = sd_mmc_select_slot(slot);
	if (sd_mmc_err != SD_MMC_OK) {
  402fd8:	4681      	mov	r9, r0
  402fda:	2800      	cmp	r0, #0
  402fdc:	d1f6      	bne.n	402fcc <sd_mmc_init_read_blocks+0x10>
  402fde:	4c25      	ldr	r4, [pc, #148]	; (403074 <sd_mmc_init_read_blocks+0xb8>)
  402fe0:	4d25      	ldr	r5, [pc, #148]	; (403078 <sd_mmc_init_read_blocks+0xbc>)
  402fe2:	4e26      	ldr	r6, [pc, #152]	; (40307c <sd_mmc_init_read_blocks+0xc0>)
			if (!driver_send_cmd(SDMMC_MCI_CMD13_SEND_STATUS,
					(uint32_t)sd_mmc_card->rca << 16)) {
				return false;
			}
			// Check busy flag
			if (driver_get_response() & CARD_STATUS_READY_FOR_DATA) {
  402fe4:	4f26      	ldr	r7, [pc, #152]	; (403080 <sd_mmc_init_read_blocks+0xc4>)
  402fe6:	e004      	b.n	402ff2 <sd_mmc_init_read_blocks+0x36>
  402fe8:	47b8      	blx	r7
  402fea:	05c2      	lsls	r2, r0, #23
  402fec:	d414      	bmi.n	403018 <sd_mmc_init_read_blocks+0x5c>
				break;
			}
		}
		if (nec_timeout-- == 0) {
  402fee:	3c01      	subs	r4, #1
  402ff0:	d009      	beq.n	403006 <sd_mmc_init_read_blocks+0x4a>
			if (!(driver_get_response() & 0xFF)) {
				break;
			}
		} else {
			if (!driver_send_cmd(SDMMC_MCI_CMD13_SEND_STATUS,
					(uint32_t)sd_mmc_card->rca << 16)) {
  402ff2:	682b      	ldr	r3, [r5, #0]
				return false;
			}
			// Check busy flag
			if (driver_get_response() & CARD_STATUS_READY_FOR_DATA) {
  402ff4:	f8df 8088 	ldr.w	r8, [pc, #136]	; 403080 <sd_mmc_init_read_blocks+0xc4>
			if (!(driver_get_response() & 0xFF)) {
				break;
			}
		} else {
			if (!driver_send_cmd(SDMMC_MCI_CMD13_SEND_STATUS,
					(uint32_t)sd_mmc_card->rca << 16)) {
  402ff8:	8999      	ldrh	r1, [r3, #12]
			// Check busy flag
			if (!(driver_get_response() & 0xFF)) {
				break;
			}
		} else {
			if (!driver_send_cmd(SDMMC_MCI_CMD13_SEND_STATUS,
  402ffa:	f241 100d 	movw	r0, #4365	; 0x110d
  402ffe:	0409      	lsls	r1, r1, #16
  403000:	47b0      	blx	r6
  403002:	2800      	cmp	r0, #0
  403004:	d1f0      	bne.n	402fe8 <sd_mmc_init_read_blocks+0x2c>
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  403006:	4b1f      	ldr	r3, [pc, #124]	; (403084 <sd_mmc_init_read_blocks+0xc8>)
  403008:	781b      	ldrb	r3, [r3, #0]
  40300a:	b33b      	cbz	r3, 40305c <sd_mmc_init_read_blocks+0xa0>
		arg = (start * SD_MMC_BLOCK_SIZE);
	}

	if (!driver_adtc_start(cmd, arg, SD_MMC_BLOCK_SIZE, nb_block, true)) {
		sd_mmc_deselect_slot();
		return SD_MMC_ERR_COMM;
  40300c:	f04f 0905 	mov.w	r9, #5
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}
  403010:	4648      	mov	r0, r9
  403012:	b003      	add	sp, #12
  403014:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  403018:	682b      	ldr	r3, [r5, #0]
	}

	if (nb_block > 1) {
		cmd = SDMMC_CMD18_READ_MULTIPLE_BLOCK;
	} else {
		cmd = SDMMC_CMD17_READ_SINGLE_BLOCK;
  40301a:	481b      	ldr	r0, [pc, #108]	; (403088 <sd_mmc_init_read_blocks+0xcc>)
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  40301c:	7bdb      	ldrb	r3, [r3, #15]
	}

	if (nb_block > 1) {
		cmd = SDMMC_CMD18_READ_MULTIPLE_BLOCK;
	} else {
		cmd = SDMMC_CMD17_READ_SINGLE_BLOCK;
  40301e:	4a1b      	ldr	r2, [pc, #108]	; (40308c <sd_mmc_init_read_blocks+0xd0>)
  403020:	f1ba 0f01 	cmp.w	sl, #1
  403024:	bf98      	it	ls
  403026:	4610      	movls	r0, r2
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  403028:	071b      	lsls	r3, r3, #28
  40302a:	d401      	bmi.n	403030 <sd_mmc_init_read_blocks+0x74>
		arg = start;
	} else {
		arg = (start * SD_MMC_BLOCK_SIZE);
  40302c:	ea4f 2b4b 	mov.w	fp, fp, lsl #9
	}

	if (!driver_adtc_start(cmd, arg, SD_MMC_BLOCK_SIZE, nb_block, true)) {
  403030:	2301      	movs	r3, #1
  403032:	9300      	str	r3, [sp, #0]
  403034:	4659      	mov	r1, fp
  403036:	f44f 7200 	mov.w	r2, #512	; 0x200
  40303a:	4653      	mov	r3, sl
  40303c:	4c14      	ldr	r4, [pc, #80]	; (403090 <sd_mmc_init_read_blocks+0xd4>)
  40303e:	47a0      	blx	r4
  403040:	2800      	cmp	r0, #0
  403042:	d0e0      	beq.n	403006 <sd_mmc_init_read_blocks+0x4a>
		sd_mmc_deselect_slot();
		return SD_MMC_ERR_COMM;
	}
	// Check response
	if (sd_mmc_is_mci()) {
		resp = driver_get_response();
  403044:	47c0      	blx	r8
		if (resp & CARD_STATUS_ERR_RD_WR) {
  403046:	4b13      	ldr	r3, [pc, #76]	; (403094 <sd_mmc_init_read_blocks+0xd8>)
  403048:	4003      	ands	r3, r0
  40304a:	2b00      	cmp	r3, #0
  40304c:	d1db      	bne.n	403006 <sd_mmc_init_read_blocks+0x4a>
					__func__, (int)SDMMC_CMD_GET_INDEX(cmd), resp);
			sd_mmc_deselect_slot();
			return SD_MMC_ERR_COMM;
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
  40304e:	4a12      	ldr	r2, [pc, #72]	; (403098 <sd_mmc_init_read_blocks+0xdc>)
	sd_mmc_nb_block_to_tranfer = nb_block;
  403050:	4b12      	ldr	r3, [pc, #72]	; (40309c <sd_mmc_init_read_blocks+0xe0>)
					__func__, (int)SDMMC_CMD_GET_INDEX(cmd), resp);
			sd_mmc_deselect_slot();
			return SD_MMC_ERR_COMM;
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
  403052:	f8a2 a000 	strh.w	sl, [r2]
	sd_mmc_nb_block_to_tranfer = nb_block;
  403056:	f8a3 a000 	strh.w	sl, [r3]
	return SD_MMC_OK;
  40305a:	e7b7      	b.n	402fcc <sd_mmc_init_read_blocks+0x10>
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
		driver_deselect_device(sd_mmc_slot_sel);
  40305c:	2000      	movs	r0, #0
  40305e:	4b10      	ldr	r3, [pc, #64]	; (4030a0 <sd_mmc_init_read_blocks+0xe4>)
  403060:	4798      	blx	r3
	}

	// Wait for data ready status
	if (!sd_mmc_cmd13()) {
		sd_mmc_deselect_slot();
		return SD_MMC_ERR_COMM;
  403062:	f04f 0905 	mov.w	r9, #5
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}
  403066:	4648      	mov	r0, r9
  403068:	b003      	add	sp, #12
  40306a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40306e:	bf00      	nop
  403070:	0040278d 	.word	0x0040278d
  403074:	00030d41 	.word	0x00030d41
  403078:	20003380 	.word	0x20003380
  40307c:	004036f9 	.word	0x004036f9
  403080:	00403725 	.word	0x00403725
  403084:	20003386 	.word	0x20003386
  403088:	00101112 	.word	0x00101112
  40308c:	00081111 	.word	0x00081111
  403090:	00403751 	.word	0x00403751
  403094:	e4580000 	.word	0xe4580000
  403098:	20003384 	.word	0x20003384
  40309c:	2000337c 	.word	0x2000337c
  4030a0:	004036d5 	.word	0x004036d5

004030a4 <sd_mmc_start_read_blocks>:

sd_mmc_err_t sd_mmc_start_read_blocks(void *dest, uint16_t nb_block)
{
  4030a4:	b510      	push	{r4, lr}
	Assert(sd_mmc_nb_block_remaining >= nb_block);

	if (!driver_start_read_blocks(dest, nb_block)) {
  4030a6:	4b07      	ldr	r3, [pc, #28]	; (4030c4 <sd_mmc_start_read_blocks+0x20>)
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}

sd_mmc_err_t sd_mmc_start_read_blocks(void *dest, uint16_t nb_block)
{
  4030a8:	460c      	mov	r4, r1
	Assert(sd_mmc_nb_block_remaining >= nb_block);

	if (!driver_start_read_blocks(dest, nb_block)) {
  4030aa:	4798      	blx	r3
  4030ac:	4603      	mov	r3, r0
  4030ae:	b918      	cbnz	r0, 4030b8 <sd_mmc_start_read_blocks+0x14>
		sd_mmc_nb_block_remaining = 0;
  4030b0:	4a05      	ldr	r2, [pc, #20]	; (4030c8 <sd_mmc_start_read_blocks+0x24>)
  4030b2:	8013      	strh	r3, [r2, #0]
		return SD_MMC_ERR_COMM;
  4030b4:	2005      	movs	r0, #5
  4030b6:	bd10      	pop	{r4, pc}
	}
	sd_mmc_nb_block_remaining -= nb_block;
  4030b8:	4b03      	ldr	r3, [pc, #12]	; (4030c8 <sd_mmc_start_read_blocks+0x24>)
  4030ba:	881a      	ldrh	r2, [r3, #0]
  4030bc:	1b14      	subs	r4, r2, r4
  4030be:	801c      	strh	r4, [r3, #0]
	return SD_MMC_OK;
  4030c0:	2000      	movs	r0, #0
}
  4030c2:	bd10      	pop	{r4, pc}
  4030c4:	004038a5 	.word	0x004038a5
  4030c8:	20003384 	.word	0x20003384

004030cc <sd_mmc_wait_end_of_read_blocks>:

sd_mmc_err_t sd_mmc_wait_end_of_read_blocks(bool abort)
{
  4030cc:	b510      	push	{r4, lr}
	if (!driver_wait_end_of_read_blocks()) {
  4030ce:	4b12      	ldr	r3, [pc, #72]	; (403118 <sd_mmc_wait_end_of_read_blocks+0x4c>)
	sd_mmc_nb_block_remaining -= nb_block;
	return SD_MMC_OK;
}

sd_mmc_err_t sd_mmc_wait_end_of_read_blocks(bool abort)
{
  4030d0:	4604      	mov	r4, r0
	if (!driver_wait_end_of_read_blocks()) {
  4030d2:	4798      	blx	r3
  4030d4:	b908      	cbnz	r0, 4030da <sd_mmc_wait_end_of_read_blocks+0xe>
		return SD_MMC_ERR_COMM;
  4030d6:	2005      	movs	r0, #5
	if (!driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0)) {
		driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0);
	}
	sd_mmc_deselect_slot();
	return SD_MMC_OK;
}
  4030d8:	bd10      	pop	{r4, pc}
{
	if (!driver_wait_end_of_read_blocks()) {
		return SD_MMC_ERR_COMM;
	}
	if (abort) {
		sd_mmc_nb_block_remaining = 0;
  4030da:	4b10      	ldr	r3, [pc, #64]	; (40311c <sd_mmc_wait_end_of_read_blocks+0x50>)
sd_mmc_err_t sd_mmc_wait_end_of_read_blocks(bool abort)
{
	if (!driver_wait_end_of_read_blocks()) {
		return SD_MMC_ERR_COMM;
	}
	if (abort) {
  4030dc:	b99c      	cbnz	r4, 403106 <sd_mmc_wait_end_of_read_blocks+0x3a>
		sd_mmc_nb_block_remaining = 0;
	} else if (sd_mmc_nb_block_remaining) {
  4030de:	881b      	ldrh	r3, [r3, #0]
  4030e0:	b97b      	cbnz	r3, 403102 <sd_mmc_wait_end_of_read_blocks+0x36>
		return SD_MMC_OK;
	}

	// All blocks are transfered then stop read operation
	if (sd_mmc_nb_block_to_tranfer == 1) {
  4030e2:	4b0f      	ldr	r3, [pc, #60]	; (403120 <sd_mmc_wait_end_of_read_blocks+0x54>)
  4030e4:	881b      	ldrh	r3, [r3, #0]
  4030e6:	2b01      	cmp	r3, #1
  4030e8:	d005      	beq.n	4030f6 <sd_mmc_wait_end_of_read_blocks+0x2a>
		return SD_MMC_OK;
	}
	// WORKAROUND for no compliance card (Atmel Internal ref. !MMC7 !SD19):
	// The errors on this command must be ignored
	// and one retry can be necessary in SPI mode for no compliance card.
	if (!driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0)) {
  4030ea:	f243 100c 	movw	r0, #12556	; 0x310c
  4030ee:	2100      	movs	r1, #0
  4030f0:	4c0c      	ldr	r4, [pc, #48]	; (403124 <sd_mmc_wait_end_of_read_blocks+0x58>)
  4030f2:	47a0      	blx	r4
  4030f4:	b150      	cbz	r0, 40310c <sd_mmc_wait_end_of_read_blocks+0x40>
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  4030f6:	4b0c      	ldr	r3, [pc, #48]	; (403128 <sd_mmc_wait_end_of_read_blocks+0x5c>)
  4030f8:	781b      	ldrb	r3, [r3, #0]
  4030fa:	b913      	cbnz	r3, 403102 <sd_mmc_wait_end_of_read_blocks+0x36>
		driver_deselect_device(sd_mmc_slot_sel);
  4030fc:	2000      	movs	r0, #0
  4030fe:	4b0b      	ldr	r3, [pc, #44]	; (40312c <sd_mmc_wait_end_of_read_blocks+0x60>)
  403100:	4798      	blx	r3

	// All blocks are transfered then stop read operation
	if (sd_mmc_nb_block_to_tranfer == 1) {
		// Single block transfer, then nothing to do
		sd_mmc_deselect_slot();
		return SD_MMC_OK;
  403102:	2000      	movs	r0, #0
  403104:	bd10      	pop	{r4, pc}
{
	if (!driver_wait_end_of_read_blocks()) {
		return SD_MMC_ERR_COMM;
	}
	if (abort) {
		sd_mmc_nb_block_remaining = 0;
  403106:	2200      	movs	r2, #0
  403108:	801a      	strh	r2, [r3, #0]
  40310a:	e7ea      	b.n	4030e2 <sd_mmc_wait_end_of_read_blocks+0x16>
	}
	// WORKAROUND for no compliance card (Atmel Internal ref. !MMC7 !SD19):
	// The errors on this command must be ignored
	// and one retry can be necessary in SPI mode for no compliance card.
	if (!driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0)) {
		driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0);
  40310c:	4601      	mov	r1, r0
  40310e:	f243 100c 	movw	r0, #12556	; 0x310c
  403112:	47a0      	blx	r4
  403114:	e7ef      	b.n	4030f6 <sd_mmc_wait_end_of_read_blocks+0x2a>
  403116:	bf00      	nop
  403118:	0040390d 	.word	0x0040390d
  40311c:	20003384 	.word	0x20003384
  403120:	2000337c 	.word	0x2000337c
  403124:	004036f9 	.word	0x004036f9
  403128:	20003386 	.word	0x20003386
  40312c:	004036d5 	.word	0x004036d5

00403130 <sd_mmc_init_write_blocks>:
	return SD_MMC_OK;
}

sd_mmc_err_t sd_mmc_init_write_blocks(uint8_t slot, uint32_t start,
		uint16_t nb_block)
{
  403130:	b570      	push	{r4, r5, r6, lr}
  403132:	4615      	mov	r5, r2
  403134:	b084      	sub	sp, #16
 * \retval SD_MMC_INIT_ONGOING Card initialization requested
 * \retval SD_MMC_OK           Card present
 */
static sd_mmc_err_t sd_mmc_select_slot(uint8_t slot)
{
	if (slot >= SD_MMC_MEM_CNT) {
  403136:	b118      	cbz	r0, 403140 <sd_mmc_init_write_blocks+0x10>
		return SD_MMC_ERR_SLOT;
  403138:	2404      	movs	r4, #4
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}
  40313a:	4620      	mov	r0, r4
  40313c:	b004      	add	sp, #16
  40313e:	bd70      	pop	{r4, r5, r6, pc}
  403140:	9103      	str	r1, [sp, #12]
  403142:	4b18      	ldr	r3, [pc, #96]	; (4031a4 <sd_mmc_init_write_blocks+0x74>)
  403144:	4798      	blx	r3
{
	sd_mmc_err_t sd_mmc_err;
	uint32_t cmd, arg, resp;

	sd_mmc_err = sd_mmc_select_slot(slot);
	if (sd_mmc_err != SD_MMC_OK) {
  403146:	9903      	ldr	r1, [sp, #12]
  403148:	4604      	mov	r4, r0
  40314a:	2800      	cmp	r0, #0
  40314c:	d1f5      	bne.n	40313a <sd_mmc_init_write_blocks+0xa>
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  40314e:	4b16      	ldr	r3, [pc, #88]	; (4031a8 <sd_mmc_init_write_blocks+0x78>)
		sd_mmc_deselect_slot();
		return SD_MMC_ERR_WP;
	}

	if (nb_block > 1) {
		cmd = SDMMC_CMD25_WRITE_MULTIPLE_BLOCK;
  403150:	4a16      	ldr	r2, [pc, #88]	; (4031ac <sd_mmc_init_write_blocks+0x7c>)
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  403152:	681b      	ldr	r3, [r3, #0]
		sd_mmc_deselect_slot();
		return SD_MMC_ERR_WP;
	}

	if (nb_block > 1) {
		cmd = SDMMC_CMD25_WRITE_MULTIPLE_BLOCK;
  403154:	4816      	ldr	r0, [pc, #88]	; (4031b0 <sd_mmc_init_write_blocks+0x80>)
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  403156:	7bdb      	ldrb	r3, [r3, #15]
		arg = start;
	} else {
		arg = (start * SD_MMC_BLOCK_SIZE);
	}
	if (!driver_adtc_start(cmd, arg, SD_MMC_BLOCK_SIZE, nb_block, true)) {
  403158:	4e16      	ldr	r6, [pc, #88]	; (4031b4 <sd_mmc_init_write_blocks+0x84>)
		sd_mmc_deselect_slot();
		return SD_MMC_ERR_WP;
	}

	if (nb_block > 1) {
		cmd = SDMMC_CMD25_WRITE_MULTIPLE_BLOCK;
  40315a:	2d01      	cmp	r5, #1
  40315c:	bf88      	it	hi
  40315e:	4610      	movhi	r0, r2
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  403160:	071b      	lsls	r3, r3, #28
		arg = start;
	} else {
		arg = (start * SD_MMC_BLOCK_SIZE);
	}
	if (!driver_adtc_start(cmd, arg, SD_MMC_BLOCK_SIZE, nb_block, true)) {
  403162:	f04f 0301 	mov.w	r3, #1
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
		arg = start;
	} else {
		arg = (start * SD_MMC_BLOCK_SIZE);
  403166:	bf58      	it	pl
  403168:	0249      	lslpl	r1, r1, #9
	}
	if (!driver_adtc_start(cmd, arg, SD_MMC_BLOCK_SIZE, nb_block, true)) {
  40316a:	9300      	str	r3, [sp, #0]
  40316c:	f44f 7200 	mov.w	r2, #512	; 0x200
  403170:	462b      	mov	r3, r5
  403172:	47b0      	blx	r6
  403174:	b930      	cbnz	r0, 403184 <sd_mmc_init_write_blocks+0x54>
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  403176:	4b10      	ldr	r3, [pc, #64]	; (4031b8 <sd_mmc_init_write_blocks+0x88>)
  403178:	781b      	ldrb	r3, [r3, #0]
  40317a:	b173      	cbz	r3, 40319a <sd_mmc_init_write_blocks+0x6a>
	} else {
		arg = (start * SD_MMC_BLOCK_SIZE);
	}
	if (!driver_adtc_start(cmd, arg, SD_MMC_BLOCK_SIZE, nb_block, true)) {
		sd_mmc_deselect_slot();
		return SD_MMC_ERR_COMM;
  40317c:	2405      	movs	r4, #5
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}
  40317e:	4620      	mov	r0, r4
  403180:	b004      	add	sp, #16
  403182:	bd70      	pop	{r4, r5, r6, pc}
		sd_mmc_deselect_slot();
		return SD_MMC_ERR_COMM;
	}
	// Check response
	if (sd_mmc_is_mci()) {
		resp = driver_get_response();
  403184:	4b0d      	ldr	r3, [pc, #52]	; (4031bc <sd_mmc_init_write_blocks+0x8c>)
  403186:	4798      	blx	r3
		if (resp & CARD_STATUS_ERR_RD_WR) {
  403188:	4b0d      	ldr	r3, [pc, #52]	; (4031c0 <sd_mmc_init_write_blocks+0x90>)
  40318a:	4003      	ands	r3, r0
  40318c:	2b00      	cmp	r3, #0
  40318e:	d1f2      	bne.n	403176 <sd_mmc_init_write_blocks+0x46>
					__func__, (int)SDMMC_CMD_GET_INDEX(cmd), resp);
			sd_mmc_deselect_slot();
			return SD_MMC_ERR_COMM;
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
  403190:	4a0c      	ldr	r2, [pc, #48]	; (4031c4 <sd_mmc_init_write_blocks+0x94>)
	sd_mmc_nb_block_to_tranfer = nb_block;
  403192:	4b0d      	ldr	r3, [pc, #52]	; (4031c8 <sd_mmc_init_write_blocks+0x98>)
					__func__, (int)SDMMC_CMD_GET_INDEX(cmd), resp);
			sd_mmc_deselect_slot();
			return SD_MMC_ERR_COMM;
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
  403194:	8015      	strh	r5, [r2, #0]
	sd_mmc_nb_block_to_tranfer = nb_block;
  403196:	801d      	strh	r5, [r3, #0]
	return SD_MMC_OK;
  403198:	e7cf      	b.n	40313a <sd_mmc_init_write_blocks+0xa>
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
		driver_deselect_device(sd_mmc_slot_sel);
  40319a:	2000      	movs	r0, #0
  40319c:	4b0b      	ldr	r3, [pc, #44]	; (4031cc <sd_mmc_init_write_blocks+0x9c>)
  40319e:	4798      	blx	r3
  4031a0:	e7ec      	b.n	40317c <sd_mmc_init_write_blocks+0x4c>
  4031a2:	bf00      	nop
  4031a4:	0040278d 	.word	0x0040278d
  4031a8:	20003380 	.word	0x20003380
  4031ac:	00109119 	.word	0x00109119
  4031b0:	00089118 	.word	0x00089118
  4031b4:	00403751 	.word	0x00403751
  4031b8:	20003386 	.word	0x20003386
  4031bc:	00403725 	.word	0x00403725
  4031c0:	e4580000 	.word	0xe4580000
  4031c4:	20003384 	.word	0x20003384
  4031c8:	2000337c 	.word	0x2000337c
  4031cc:	004036d5 	.word	0x004036d5

004031d0 <sd_mmc_start_write_blocks>:
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}

sd_mmc_err_t sd_mmc_start_write_blocks(const void *src, uint16_t nb_block)
{
  4031d0:	b510      	push	{r4, lr}
	Assert(sd_mmc_nb_block_remaining >= nb_block);
	if (!driver_start_write_blocks(src, nb_block)) {
  4031d2:	4b07      	ldr	r3, [pc, #28]	; (4031f0 <sd_mmc_start_write_blocks+0x20>)
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}

sd_mmc_err_t sd_mmc_start_write_blocks(const void *src, uint16_t nb_block)
{
  4031d4:	460c      	mov	r4, r1
	Assert(sd_mmc_nb_block_remaining >= nb_block);
	if (!driver_start_write_blocks(src, nb_block)) {
  4031d6:	4798      	blx	r3
  4031d8:	4603      	mov	r3, r0
  4031da:	b918      	cbnz	r0, 4031e4 <sd_mmc_start_write_blocks+0x14>
		sd_mmc_nb_block_remaining = 0;
  4031dc:	4a05      	ldr	r2, [pc, #20]	; (4031f4 <sd_mmc_start_write_blocks+0x24>)
  4031de:	8013      	strh	r3, [r2, #0]
		return SD_MMC_ERR_COMM;
  4031e0:	2005      	movs	r0, #5
  4031e2:	bd10      	pop	{r4, pc}
	}
	sd_mmc_nb_block_remaining -= nb_block;
  4031e4:	4b03      	ldr	r3, [pc, #12]	; (4031f4 <sd_mmc_start_write_blocks+0x24>)
  4031e6:	881a      	ldrh	r2, [r3, #0]
  4031e8:	1b14      	subs	r4, r2, r4
  4031ea:	801c      	strh	r4, [r3, #0]
	return SD_MMC_OK;
  4031ec:	2000      	movs	r0, #0
}
  4031ee:	bd10      	pop	{r4, pc}
  4031f0:	004039b1 	.word	0x004039b1
  4031f4:	20003384 	.word	0x20003384

004031f8 <sd_mmc_wait_end_of_write_blocks>:

sd_mmc_err_t sd_mmc_wait_end_of_write_blocks(bool abort)
{
  4031f8:	b510      	push	{r4, lr}
	if (!driver_wait_end_of_write_blocks()) {
  4031fa:	4b14      	ldr	r3, [pc, #80]	; (40324c <sd_mmc_wait_end_of_write_blocks+0x54>)
	sd_mmc_nb_block_remaining -= nb_block;
	return SD_MMC_OK;
}

sd_mmc_err_t sd_mmc_wait_end_of_write_blocks(bool abort)
{
  4031fc:	4604      	mov	r4, r0
	if (!driver_wait_end_of_write_blocks()) {
  4031fe:	4798      	blx	r3
  403200:	b908      	cbnz	r0, 403206 <sd_mmc_wait_end_of_write_blocks+0xe>
	if (sd_mmc_is_mci()) {
		// Note: SPI multiblock writes terminate using a special
		// token, not a STOP_TRANSMISSION request.
		if (!driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0)) {
			sd_mmc_deselect_slot();
			return SD_MMC_ERR_COMM;
  403202:	2005      	movs	r0, #5
  403204:	bd10      	pop	{r4, pc}
{
	if (!driver_wait_end_of_write_blocks()) {
		return SD_MMC_ERR_COMM;
	}
	if (abort) {
		sd_mmc_nb_block_remaining = 0;
  403206:	4b12      	ldr	r3, [pc, #72]	; (403250 <sd_mmc_wait_end_of_write_blocks+0x58>)
sd_mmc_err_t sd_mmc_wait_end_of_write_blocks(bool abort)
{
	if (!driver_wait_end_of_write_blocks()) {
		return SD_MMC_ERR_COMM;
	}
	if (abort) {
  403208:	b994      	cbnz	r4, 403230 <sd_mmc_wait_end_of_write_blocks+0x38>
		sd_mmc_nb_block_remaining = 0;
	} else if (sd_mmc_nb_block_remaining) {
  40320a:	881b      	ldrh	r3, [r3, #0]
  40320c:	b9e3      	cbnz	r3, 403248 <sd_mmc_wait_end_of_write_blocks+0x50>
		return SD_MMC_OK;
	}

	// All blocks are transfered then stop write operation
	if (sd_mmc_nb_block_to_tranfer == 1) {
  40320e:	4b11      	ldr	r3, [pc, #68]	; (403254 <sd_mmc_wait_end_of_write_blocks+0x5c>)
  403210:	881b      	ldrh	r3, [r3, #0]
  403212:	2b01      	cmp	r3, #1
  403214:	d012      	beq.n	40323c <sd_mmc_wait_end_of_write_blocks+0x44>
	}

	if (sd_mmc_is_mci()) {
		// Note: SPI multiblock writes terminate using a special
		// token, not a STOP_TRANSMISSION request.
		if (!driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0)) {
  403216:	f243 100c 	movw	r0, #12556	; 0x310c
  40321a:	2100      	movs	r1, #0
  40321c:	4b0e      	ldr	r3, [pc, #56]	; (403258 <sd_mmc_wait_end_of_write_blocks+0x60>)
  40321e:	4798      	blx	r3
  403220:	b960      	cbnz	r0, 40323c <sd_mmc_wait_end_of_write_blocks+0x44>
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  403222:	4b0e      	ldr	r3, [pc, #56]	; (40325c <sd_mmc_wait_end_of_write_blocks+0x64>)
  403224:	781b      	ldrb	r3, [r3, #0]
  403226:	2b00      	cmp	r3, #0
  403228:	d1eb      	bne.n	403202 <sd_mmc_wait_end_of_write_blocks+0xa>
		driver_deselect_device(sd_mmc_slot_sel);
  40322a:	4b0d      	ldr	r3, [pc, #52]	; (403260 <sd_mmc_wait_end_of_write_blocks+0x68>)
  40322c:	4798      	blx	r3
  40322e:	e7e8      	b.n	403202 <sd_mmc_wait_end_of_write_blocks+0xa>
{
	if (!driver_wait_end_of_write_blocks()) {
		return SD_MMC_ERR_COMM;
	}
	if (abort) {
		sd_mmc_nb_block_remaining = 0;
  403230:	2200      	movs	r2, #0
  403232:	801a      	strh	r2, [r3, #0]
	} else if (sd_mmc_nb_block_remaining) {
		return SD_MMC_OK;
	}

	// All blocks are transfered then stop write operation
	if (sd_mmc_nb_block_to_tranfer == 1) {
  403234:	4b07      	ldr	r3, [pc, #28]	; (403254 <sd_mmc_wait_end_of_write_blocks+0x5c>)
  403236:	881b      	ldrh	r3, [r3, #0]
  403238:	2b01      	cmp	r3, #1
  40323a:	d1ec      	bne.n	403216 <sd_mmc_wait_end_of_write_blocks+0x1e>
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  40323c:	4b07      	ldr	r3, [pc, #28]	; (40325c <sd_mmc_wait_end_of_write_blocks+0x64>)
  40323e:	781b      	ldrb	r3, [r3, #0]
  403240:	b913      	cbnz	r3, 403248 <sd_mmc_wait_end_of_write_blocks+0x50>
		driver_deselect_device(sd_mmc_slot_sel);
  403242:	2000      	movs	r0, #0
  403244:	4b06      	ldr	r3, [pc, #24]	; (403260 <sd_mmc_wait_end_of_write_blocks+0x68>)
  403246:	4798      	blx	r3

	// All blocks are transfered then stop write operation
	if (sd_mmc_nb_block_to_tranfer == 1) {
		// Single block transfer, then nothing to do
		sd_mmc_deselect_slot();
		return SD_MMC_OK;
  403248:	2000      	movs	r0, #0
  40324a:	bd10      	pop	{r4, pc}
  40324c:	00403a1d 	.word	0x00403a1d
  403250:	20003384 	.word	0x20003384
  403254:	2000337c 	.word	0x2000337c
  403258:	004036f9 	.word	0x004036f9
  40325c:	20003386 	.word	0x20003386
  403260:	004036d5 	.word	0x004036d5

00403264 <sd_mmc_test_unit_ready>:
 */

static bool sd_mmc_ejected[2] = {false, false};

Ctrl_status sd_mmc_test_unit_ready(uint8_t slot)
{
  403264:	b510      	push	{r4, lr}
	switch (sd_mmc_check(slot))
  403266:	4b0f      	ldr	r3, [pc, #60]	; (4032a4 <sd_mmc_test_unit_ready+0x40>)
 */

static bool sd_mmc_ejected[2] = {false, false};

Ctrl_status sd_mmc_test_unit_ready(uint8_t slot)
{
  403268:	4604      	mov	r4, r0
	switch (sd_mmc_check(slot))
  40326a:	4798      	blx	r3
  40326c:	2801      	cmp	r0, #1
  40326e:	d00d      	beq.n	40328c <sd_mmc_test_unit_ready+0x28>
  403270:	d307      	bcc.n	403282 <sd_mmc_test_unit_ready+0x1e>
  403272:	2802      	cmp	r0, #2
  403274:	d103      	bne.n	40327e <sd_mmc_test_unit_ready+0x1a>

	case SD_MMC_INIT_ONGOING:
		return CTRL_BUSY;

	case SD_MMC_ERR_NO_CARD:
		sd_mmc_ejected[slot] = false;
  403276:	4b0c      	ldr	r3, [pc, #48]	; (4032a8 <sd_mmc_test_unit_ready+0x44>)
  403278:	2200      	movs	r2, #0
  40327a:	551a      	strb	r2, [r3, r4]
		return CTRL_NO_PRESENT;
  40327c:	bd10      	pop	{r4, pc}

	default:
		return CTRL_FAIL;
  40327e:	2001      	movs	r0, #1
  403280:	bd10      	pop	{r4, pc}
Ctrl_status sd_mmc_test_unit_ready(uint8_t slot)
{
	switch (sd_mmc_check(slot))
	{
	case SD_MMC_OK:
		if (sd_mmc_ejected[slot]) {
  403282:	4b09      	ldr	r3, [pc, #36]	; (4032a8 <sd_mmc_test_unit_ready+0x44>)
  403284:	5d1b      	ldrb	r3, [r3, r4]
  403286:	b11b      	cbz	r3, 403290 <sd_mmc_test_unit_ready+0x2c>
			return CTRL_NO_PRESENT;
  403288:	2002      	movs	r0, #2
		return CTRL_NO_PRESENT;

	default:
		return CTRL_FAIL;
	}
}
  40328a:	bd10      	pop	{r4, pc}
		}
		// It is not a memory card
		return CTRL_NO_PRESENT;

	case SD_MMC_INIT_ONGOING:
		return CTRL_BUSY;
  40328c:	2003      	movs	r0, #3
  40328e:	bd10      	pop	{r4, pc}
	{
	case SD_MMC_OK:
		if (sd_mmc_ejected[slot]) {
			return CTRL_NO_PRESENT;
		}
		if (sd_mmc_get_type(slot) & (CARD_TYPE_SD | CARD_TYPE_MMC)) {
  403290:	4620      	mov	r0, r4
  403292:	4b06      	ldr	r3, [pc, #24]	; (4032ac <sd_mmc_test_unit_ready+0x48>)
  403294:	4798      	blx	r3
  403296:	f010 0f03 	tst.w	r0, #3
			return CTRL_GOOD;
  40329a:	bf0c      	ite	eq
  40329c:	2002      	moveq	r0, #2
  40329e:	2000      	movne	r0, #0
  4032a0:	bd10      	pop	{r4, pc}
  4032a2:	bf00      	nop
  4032a4:	004028dd 	.word	0x004028dd
  4032a8:	20003388 	.word	0x20003388
  4032ac:	00402f41 	.word	0x00402f41

004032b0 <sd_mmc_test_unit_ready_0>:
		return CTRL_FAIL;
	}
}

Ctrl_status sd_mmc_test_unit_ready_0(void)
{
  4032b0:	b508      	push	{r3, lr}
	return sd_mmc_test_unit_ready(0);
  4032b2:	2000      	movs	r0, #0
  4032b4:	4b01      	ldr	r3, [pc, #4]	; (4032bc <sd_mmc_test_unit_ready_0+0xc>)
  4032b6:	4798      	blx	r3
}
  4032b8:	bd08      	pop	{r3, pc}
  4032ba:	bf00      	nop
  4032bc:	00403265 	.word	0x00403265

004032c0 <sd_mmc_test_unit_ready_1>:


Ctrl_status sd_mmc_test_unit_ready_1(void)
{
  4032c0:	b508      	push	{r3, lr}
	return sd_mmc_test_unit_ready(1);
  4032c2:	2001      	movs	r0, #1
  4032c4:	4b01      	ldr	r3, [pc, #4]	; (4032cc <sd_mmc_test_unit_ready_1+0xc>)
  4032c6:	4798      	blx	r3
}
  4032c8:	bd08      	pop	{r3, pc}
  4032ca:	bf00      	nop
  4032cc:	00403265 	.word	0x00403265

004032d0 <sd_mmc_read_capacity>:

Ctrl_status sd_mmc_read_capacity(uint8_t slot, uint32_t *nb_sector)
{
  4032d0:	b538      	push	{r3, r4, r5, lr}
	// Return last sector address (-1)
	*nb_sector = (sd_mmc_get_capacity(slot) * 2) - 1;
  4032d2:	4b05      	ldr	r3, [pc, #20]	; (4032e8 <sd_mmc_read_capacity+0x18>)
{
	return sd_mmc_test_unit_ready(1);
}

Ctrl_status sd_mmc_read_capacity(uint8_t slot, uint32_t *nb_sector)
{
  4032d4:	460d      	mov	r5, r1
  4032d6:	4604      	mov	r4, r0
	// Return last sector address (-1)
	*nb_sector = (sd_mmc_get_capacity(slot) * 2) - 1;
  4032d8:	4798      	blx	r3
  4032da:	0040      	lsls	r0, r0, #1
  4032dc:	3801      	subs	r0, #1
  4032de:	6028      	str	r0, [r5, #0]
	return sd_mmc_test_unit_ready(slot);
  4032e0:	4b02      	ldr	r3, [pc, #8]	; (4032ec <sd_mmc_read_capacity+0x1c>)
  4032e2:	4620      	mov	r0, r4
  4032e4:	4798      	blx	r3
}
  4032e6:	bd38      	pop	{r3, r4, r5, pc}
  4032e8:	00402f7d 	.word	0x00402f7d
  4032ec:	00403265 	.word	0x00403265

004032f0 <sd_mmc_read_capacity_0>:

Ctrl_status sd_mmc_read_capacity_0(uint32_t *nb_sector)
{
  4032f0:	b508      	push	{r3, lr}
  4032f2:	4601      	mov	r1, r0
	return sd_mmc_read_capacity(0, nb_sector);
  4032f4:	4b01      	ldr	r3, [pc, #4]	; (4032fc <sd_mmc_read_capacity_0+0xc>)
  4032f6:	2000      	movs	r0, #0
  4032f8:	4798      	blx	r3
}
  4032fa:	bd08      	pop	{r3, pc}
  4032fc:	004032d1 	.word	0x004032d1

00403300 <sd_mmc_read_capacity_1>:

Ctrl_status sd_mmc_read_capacity_1(uint32_t *nb_sector)
{
  403300:	b508      	push	{r3, lr}
  403302:	4601      	mov	r1, r0
	return sd_mmc_read_capacity(1, nb_sector);
  403304:	4b01      	ldr	r3, [pc, #4]	; (40330c <sd_mmc_read_capacity_1+0xc>)
  403306:	2001      	movs	r0, #1
  403308:	4798      	blx	r3
}
  40330a:	bd08      	pop	{r3, pc}
  40330c:	004032d1 	.word	0x004032d1

00403310 <sd_mmc_unload_0>:

bool sd_mmc_unload(uint8_t slot, bool unload)
{
	sd_mmc_ejected[slot] = unload;
  403310:	4b01      	ldr	r3, [pc, #4]	; (403318 <sd_mmc_unload_0+0x8>)
  403312:	7018      	strb	r0, [r3, #0]
}

bool sd_mmc_unload_0(bool unload)
{
	return sd_mmc_unload(0, unload);
}
  403314:	2001      	movs	r0, #1
  403316:	4770      	bx	lr
  403318:	20003388 	.word	0x20003388

0040331c <sd_mmc_unload_1>:
	return sd_mmc_read_capacity(1, nb_sector);
}

bool sd_mmc_unload(uint8_t slot, bool unload)
{
	sd_mmc_ejected[slot] = unload;
  40331c:	4b01      	ldr	r3, [pc, #4]	; (403324 <sd_mmc_unload_1+0x8>)
  40331e:	7058      	strb	r0, [r3, #1]
}

bool sd_mmc_unload_1(bool unload)
{
	return sd_mmc_unload(1, unload);
}
  403320:	2001      	movs	r0, #1
  403322:	4770      	bx	lr
  403324:	20003388 	.word	0x20003388

00403328 <sd_mmc_wr_protect_0>:
{
	return sd_mmc_is_write_protected(slot);
}

bool sd_mmc_wr_protect_0(void)
{
  403328:	b508      	push	{r3, lr}
	return sd_mmc_unload(1, unload);
}

bool sd_mmc_wr_protect(uint8_t slot)
{
	return sd_mmc_is_write_protected(slot);
  40332a:	2000      	movs	r0, #0
  40332c:	4b01      	ldr	r3, [pc, #4]	; (403334 <sd_mmc_wr_protect_0+0xc>)
  40332e:	4798      	blx	r3
}

bool sd_mmc_wr_protect_0(void)
{
	return sd_mmc_wr_protect(0);
}
  403330:	bd08      	pop	{r3, pc}
  403332:	bf00      	nop
  403334:	00402fb9 	.word	0x00402fb9

00403338 <sd_mmc_wr_protect_1>:

bool sd_mmc_wr_protect_1(void)
{
  403338:	b508      	push	{r3, lr}
	return sd_mmc_unload(1, unload);
}

bool sd_mmc_wr_protect(uint8_t slot)
{
	return sd_mmc_is_write_protected(slot);
  40333a:	2001      	movs	r0, #1
  40333c:	4b01      	ldr	r3, [pc, #4]	; (403344 <sd_mmc_wr_protect_1+0xc>)
  40333e:	4798      	blx	r3
}

bool sd_mmc_wr_protect_1(void)
{
	return sd_mmc_wr_protect(1);
}
  403340:	bd08      	pop	{r3, pc}
  403342:	bf00      	nop
  403344:	00402fb9 	.word	0x00402fb9

00403348 <sd_mmc_removal_0>:
}

bool sd_mmc_removal_0(void)
{
	return sd_mmc_removal(0);
}
  403348:	2001      	movs	r0, #1
  40334a:	4770      	bx	lr

0040334c <sd_mmc_removal_1>:

bool sd_mmc_removal_1(void)
{
	return sd_mmc_removal(1);
}
  40334c:	2001      	movs	r0, #1
  40334e:	4770      	bx	lr

00403350 <sd_mmc_mem_2_ram>:
/**
 * \name MEM <-> RAM Interface
 * @{
 */
Ctrl_status sd_mmc_mem_2_ram(uint8_t slot, uint32_t addr, void *ram)
{
  403350:	b510      	push	{r4, lr}
	switch (sd_mmc_init_read_blocks(slot, addr, 1)) {
  403352:	4b0b      	ldr	r3, [pc, #44]	; (403380 <sd_mmc_mem_2_ram+0x30>)
/**
 * \name MEM <-> RAM Interface
 * @{
 */
Ctrl_status sd_mmc_mem_2_ram(uint8_t slot, uint32_t addr, void *ram)
{
  403354:	4614      	mov	r4, r2
	switch (sd_mmc_init_read_blocks(slot, addr, 1)) {
  403356:	2201      	movs	r2, #1
  403358:	4798      	blx	r3
  40335a:	b120      	cbz	r0, 403366 <sd_mmc_mem_2_ram+0x16>
  40335c:	2802      	cmp	r0, #2
	case SD_MMC_OK:
		break;
	case SD_MMC_ERR_NO_CARD:
		return CTRL_NO_PRESENT;
	default:
		return CTRL_FAIL;
  40335e:	bf0c      	ite	eq
  403360:	2002      	moveq	r0, #2
  403362:	2001      	movne	r0, #1
  403364:	bd10      	pop	{r4, pc}
	}
	if (SD_MMC_OK != sd_mmc_start_read_blocks(ram, 1)) {
  403366:	4620      	mov	r0, r4
  403368:	2101      	movs	r1, #1
  40336a:	4b06      	ldr	r3, [pc, #24]	; (403384 <sd_mmc_mem_2_ram+0x34>)
  40336c:	4798      	blx	r3
  40336e:	b108      	cbz	r0, 403374 <sd_mmc_mem_2_ram+0x24>
		return CTRL_FAIL;
  403370:	2001      	movs	r0, #1
	}
	if (SD_MMC_OK != sd_mmc_wait_end_of_read_blocks(false)) {
		return CTRL_FAIL;
	}
	return CTRL_GOOD;
}
  403372:	bd10      	pop	{r4, pc}
		return CTRL_FAIL;
	}
	if (SD_MMC_OK != sd_mmc_start_read_blocks(ram, 1)) {
		return CTRL_FAIL;
	}
	if (SD_MMC_OK != sd_mmc_wait_end_of_read_blocks(false)) {
  403374:	4b04      	ldr	r3, [pc, #16]	; (403388 <sd_mmc_mem_2_ram+0x38>)
  403376:	4798      	blx	r3
		return CTRL_FAIL;
  403378:	3000      	adds	r0, #0
  40337a:	bf18      	it	ne
  40337c:	2001      	movne	r0, #1
  40337e:	bd10      	pop	{r4, pc}
  403380:	00402fbd 	.word	0x00402fbd
  403384:	004030a5 	.word	0x004030a5
  403388:	004030cd 	.word	0x004030cd

0040338c <sd_mmc_mem_2_ram_0>:
	}
	return CTRL_GOOD;
}

Ctrl_status sd_mmc_mem_2_ram_0(uint32_t addr, void *ram)
{
  40338c:	b508      	push	{r3, lr}
  40338e:	460a      	mov	r2, r1
	return sd_mmc_mem_2_ram(0, addr, ram);
  403390:	4b02      	ldr	r3, [pc, #8]	; (40339c <sd_mmc_mem_2_ram_0+0x10>)
  403392:	4601      	mov	r1, r0
  403394:	2000      	movs	r0, #0
  403396:	4798      	blx	r3
}
  403398:	bd08      	pop	{r3, pc}
  40339a:	bf00      	nop
  40339c:	00403351 	.word	0x00403351

004033a0 <sd_mmc_mem_2_ram_1>:

Ctrl_status sd_mmc_mem_2_ram_1(uint32_t addr, void *ram)
{
  4033a0:	b508      	push	{r3, lr}
  4033a2:	460a      	mov	r2, r1
	return sd_mmc_mem_2_ram(1, addr, ram);
  4033a4:	4b02      	ldr	r3, [pc, #8]	; (4033b0 <sd_mmc_mem_2_ram_1+0x10>)
  4033a6:	4601      	mov	r1, r0
  4033a8:	2001      	movs	r0, #1
  4033aa:	4798      	blx	r3
}
  4033ac:	bd08      	pop	{r3, pc}
  4033ae:	bf00      	nop
  4033b0:	00403351 	.word	0x00403351

004033b4 <sd_mmc_ram_2_mem>:

Ctrl_status sd_mmc_ram_2_mem(uint8_t slot, uint32_t addr, const void *ram)
{
  4033b4:	b510      	push	{r4, lr}
	switch (sd_mmc_init_write_blocks(slot, addr, 1)) {
  4033b6:	4b0b      	ldr	r3, [pc, #44]	; (4033e4 <sd_mmc_ram_2_mem+0x30>)
{
	return sd_mmc_mem_2_ram(1, addr, ram);
}

Ctrl_status sd_mmc_ram_2_mem(uint8_t slot, uint32_t addr, const void *ram)
{
  4033b8:	4614      	mov	r4, r2
	switch (sd_mmc_init_write_blocks(slot, addr, 1)) {
  4033ba:	2201      	movs	r2, #1
  4033bc:	4798      	blx	r3
  4033be:	b120      	cbz	r0, 4033ca <sd_mmc_ram_2_mem+0x16>
  4033c0:	2802      	cmp	r0, #2
	case SD_MMC_OK:
		break;
	case SD_MMC_ERR_NO_CARD:
		return CTRL_NO_PRESENT;
	default:
		return CTRL_FAIL;
  4033c2:	bf0c      	ite	eq
  4033c4:	2002      	moveq	r0, #2
  4033c6:	2001      	movne	r0, #1
  4033c8:	bd10      	pop	{r4, pc}
	}
	if (SD_MMC_OK != sd_mmc_start_write_blocks(ram, 1)) {
  4033ca:	4620      	mov	r0, r4
  4033cc:	2101      	movs	r1, #1
  4033ce:	4b06      	ldr	r3, [pc, #24]	; (4033e8 <sd_mmc_ram_2_mem+0x34>)
  4033d0:	4798      	blx	r3
  4033d2:	b108      	cbz	r0, 4033d8 <sd_mmc_ram_2_mem+0x24>
		return CTRL_FAIL;
  4033d4:	2001      	movs	r0, #1
	}
	if (SD_MMC_OK != sd_mmc_wait_end_of_write_blocks(false)) {
		return CTRL_FAIL;
	}
	return CTRL_GOOD;
}
  4033d6:	bd10      	pop	{r4, pc}
		return CTRL_FAIL;
	}
	if (SD_MMC_OK != sd_mmc_start_write_blocks(ram, 1)) {
		return CTRL_FAIL;
	}
	if (SD_MMC_OK != sd_mmc_wait_end_of_write_blocks(false)) {
  4033d8:	4b04      	ldr	r3, [pc, #16]	; (4033ec <sd_mmc_ram_2_mem+0x38>)
  4033da:	4798      	blx	r3
		return CTRL_FAIL;
  4033dc:	3000      	adds	r0, #0
  4033de:	bf18      	it	ne
  4033e0:	2001      	movne	r0, #1
  4033e2:	bd10      	pop	{r4, pc}
  4033e4:	00403131 	.word	0x00403131
  4033e8:	004031d1 	.word	0x004031d1
  4033ec:	004031f9 	.word	0x004031f9

004033f0 <sd_mmc_ram_2_mem_0>:
	}
	return CTRL_GOOD;
}

Ctrl_status sd_mmc_ram_2_mem_0(uint32_t addr, const void *ram)
{
  4033f0:	b508      	push	{r3, lr}
  4033f2:	460a      	mov	r2, r1
	return sd_mmc_ram_2_mem(0, addr, ram);
  4033f4:	4b02      	ldr	r3, [pc, #8]	; (403400 <sd_mmc_ram_2_mem_0+0x10>)
  4033f6:	4601      	mov	r1, r0
  4033f8:	2000      	movs	r0, #0
  4033fa:	4798      	blx	r3
}
  4033fc:	bd08      	pop	{r3, pc}
  4033fe:	bf00      	nop
  403400:	004033b5 	.word	0x004033b5

00403404 <sd_mmc_ram_2_mem_1>:

Ctrl_status sd_mmc_ram_2_mem_1(uint32_t addr, const void *ram)
{
  403404:	b508      	push	{r3, lr}
  403406:	460a      	mov	r2, r1
	return sd_mmc_ram_2_mem(1, addr, ram);
  403408:	4b02      	ldr	r3, [pc, #8]	; (403414 <sd_mmc_ram_2_mem_1+0x10>)
  40340a:	4601      	mov	r1, r0
  40340c:	2001      	movs	r0, #1
  40340e:	4798      	blx	r3
}
  403410:	bd08      	pop	{r3, pc}
  403412:	bf00      	nop
  403414:	004033b5 	.word	0x004033b5

00403418 <mem_test_unit_ready>:
{
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
  403418:	2801      	cmp	r0, #1
  return LUN_ID_0;
}


Ctrl_status mem_test_unit_ready(U8 lun)
{
  40341a:	b508      	push	{r3, lr}
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
  40341c:	d901      	bls.n	403422 <mem_test_unit_ready+0xa>
  40341e:	2001      	movs	r0, #1
#endif

  Ctrl_access_unlock();

  return status;
}
  403420:	bd08      	pop	{r3, pc}

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
#if MAX_LUN
         (lun < MAX_LUN) ? lun_desc[lun].test_unit_ready() :
  403422:	0140      	lsls	r0, r0, #5
  403424:	4b01      	ldr	r3, [pc, #4]	; (40342c <mem_test_unit_ready+0x14>)
{
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
  403426:	581b      	ldr	r3, [r3, r0]
  403428:	4798      	blx	r3
  40342a:	bd08      	pop	{r3, pc}
  40342c:	00415fc4 	.word	0x00415fc4

00403430 <mem_read_capacity>:
{
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
  403430:	2801      	cmp	r0, #1
  return status;
}


Ctrl_status mem_read_capacity(U8 lun, U32 *u32_nb_sector)
{
  403432:	b508      	push	{r3, lr}
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
  403434:	d901      	bls.n	40343a <mem_read_capacity+0xa>
  403436:	2001      	movs	r0, #1
#endif

  Ctrl_access_unlock();

  return status;
}
  403438:	bd08      	pop	{r3, pc}

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
#if MAX_LUN
         (lun < MAX_LUN) ? lun_desc[lun].read_capacity(u32_nb_sector) :
  40343a:	4b03      	ldr	r3, [pc, #12]	; (403448 <mem_read_capacity+0x18>)
  40343c:	eb03 1340 	add.w	r3, r3, r0, lsl #5
{
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
  403440:	4608      	mov	r0, r1
  403442:	685b      	ldr	r3, [r3, #4]
  403444:	4798      	blx	r3
  403446:	bd08      	pop	{r3, pc}
  403448:	00415fc4 	.word	0x00415fc4

0040344c <mem_sector_size>:
#endif

  Ctrl_access_unlock();

  return sector_size;
}
  40344c:	2801      	cmp	r0, #1
  40344e:	bf8c      	ite	hi
  403450:	2000      	movhi	r0, #0
  403452:	2001      	movls	r0, #1
  403454:	4770      	bx	lr
  403456:	bf00      	nop

00403458 <mem_wr_protect>:

  if (!Ctrl_access_lock()) return true;

  wr_protect =
#if MAX_LUN
             (lun < MAX_LUN) ? lun_desc[lun].wr_protect() :
  403458:	2801      	cmp	r0, #1

  return unloaded;
}

bool mem_wr_protect(U8 lun)
{
  40345a:	b508      	push	{r3, lr}

  if (!Ctrl_access_lock()) return true;

  wr_protect =
#if MAX_LUN
             (lun < MAX_LUN) ? lun_desc[lun].wr_protect() :
  40345c:	d901      	bls.n	403462 <mem_wr_protect+0xa>
  40345e:	2001      	movs	r0, #1
#endif

  Ctrl_access_unlock();

  return wr_protect;
}
  403460:	bd08      	pop	{r3, pc}

  if (!Ctrl_access_lock()) return true;

  wr_protect =
#if MAX_LUN
             (lun < MAX_LUN) ? lun_desc[lun].wr_protect() :
  403462:	4b03      	ldr	r3, [pc, #12]	; (403470 <mem_wr_protect+0x18>)
  403464:	eb03 1040 	add.w	r0, r3, r0, lsl #5
  403468:	68c3      	ldr	r3, [r0, #12]
  40346a:	4798      	blx	r3
  40346c:	bd08      	pop	{r3, pc}
  40346e:	bf00      	nop
  403470:	00415fc4 	.word	0x00415fc4

00403474 <memory_2_ram>:
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_read_action(1);
  status =
  403474:	2801      	cmp	r0, #1
 */
//! @{


Ctrl_status memory_2_ram(U8 lun, U32 addr, void *ram)
{
  403476:	b508      	push	{r3, lr}
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_read_action(1);
  status =
  403478:	d901      	bls.n	40347e <memory_2_ram+0xa>
  40347a:	2001      	movs	r0, #1
  memory_stop_read_action();

  Ctrl_access_unlock();

  return status;
}
  40347c:	bd08      	pop	{r3, pc}
  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_read_action(1);
  status =
#if MAX_LUN
           (lun < MAX_LUN) ? lun_desc[lun].mem_2_ram(addr, ram) :
  40347e:	4b04      	ldr	r3, [pc, #16]	; (403490 <memory_2_ram+0x1c>)
  403480:	eb03 1340 	add.w	r3, r3, r0, lsl #5
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_read_action(1);
  status =
  403484:	4608      	mov	r0, r1
  403486:	695b      	ldr	r3, [r3, #20]
  403488:	4611      	mov	r1, r2
  40348a:	4798      	blx	r3
  40348c:	bd08      	pop	{r3, pc}
  40348e:	bf00      	nop
  403490:	00415fc4 	.word	0x00415fc4

00403494 <ram_2_memory>:
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_write_action(1);
  status =
  403494:	2801      	cmp	r0, #1
  return status;
}


Ctrl_status ram_2_memory(U8 lun, U32 addr, const void *ram)
{
  403496:	b508      	push	{r3, lr}
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_write_action(1);
  status =
  403498:	d901      	bls.n	40349e <ram_2_memory+0xa>
  40349a:	2001      	movs	r0, #1
  memory_stop_write_action();

  Ctrl_access_unlock();

  return status;
}
  40349c:	bd08      	pop	{r3, pc}
  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_write_action(1);
  status =
#if MAX_LUN
           (lun < MAX_LUN) ? lun_desc[lun].ram_2_mem(addr, ram) :
  40349e:	4b04      	ldr	r3, [pc, #16]	; (4034b0 <ram_2_memory+0x1c>)
  4034a0:	eb03 1340 	add.w	r3, r3, r0, lsl #5
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_write_action(1);
  status =
  4034a4:	4608      	mov	r0, r1
  4034a6:	699b      	ldr	r3, [r3, #24]
  4034a8:	4611      	mov	r1, r2
  4034aa:	4798      	blx	r3
  4034ac:	bd08      	pop	{r3, pc}
  4034ae:	bf00      	nop
  4034b0:	00415fc4 	.word	0x00415fc4

004034b4 <_read>:
int __attribute__((weak))
_read (int file, char * ptr, int len); // Remove GCC compiler warning

int __attribute__((weak))
_read (int file, char * ptr, int len)
{
  4034b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  4034b8:	460c      	mov	r4, r1
  4034ba:	4690      	mov	r8, r2
	int nChars = 0;

	if (file != 0) {
  4034bc:	b970      	cbnz	r0, 4034dc <_read+0x28>
		return -1;
	}

	for (; len > 0; --len) {
  4034be:	2a00      	cmp	r2, #0
  4034c0:	dd0a      	ble.n	4034d8 <_read+0x24>
  4034c2:	4e08      	ldr	r6, [pc, #32]	; (4034e4 <_read+0x30>)
  4034c4:	4f08      	ldr	r7, [pc, #32]	; (4034e8 <_read+0x34>)
  4034c6:	188d      	adds	r5, r1, r2
		ptr_get(stdio_base, ptr);
  4034c8:	4621      	mov	r1, r4
  4034ca:	6830      	ldr	r0, [r6, #0]
  4034cc:	683b      	ldr	r3, [r7, #0]
		ptr++;
  4034ce:	3401      	adds	r4, #1
	if (file != 0) {
		return -1;
	}

	for (; len > 0; --len) {
		ptr_get(stdio_base, ptr);
  4034d0:	4798      	blx	r3

	if (file != 0) {
		return -1;
	}

	for (; len > 0; --len) {
  4034d2:	42ac      	cmp	r4, r5
  4034d4:	d1f8      	bne.n	4034c8 <_read+0x14>
  4034d6:	4640      	mov	r0, r8
		ptr_get(stdio_base, ptr);
		ptr++;
		nChars++;
	}
	return nChars;
}
  4034d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
_read (int file, char * ptr, int len)
{
	int nChars = 0;

	if (file != 0) {
		return -1;
  4034dc:	f04f 30ff 	mov.w	r0, #4294967295
  4034e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4034e4:	20003e10 	.word	0x20003e10
  4034e8:	20003e08 	.word	0x20003e08

004034ec <_write>:
int __attribute__((weak))
_write (int file, const char *ptr, int len)
{
	int nChars = 0;

	if ((file != 1) && (file != 2) && (file!=3)) {
  4034ec:	3801      	subs	r0, #1
  4034ee:	2802      	cmp	r0, #2
int __attribute__((weak))
_write (int file, const char *ptr, int len);

int __attribute__((weak))
_write (int file, const char *ptr, int len)
{
  4034f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  4034f4:	460e      	mov	r6, r1
  4034f6:	4615      	mov	r5, r2
	int nChars = 0;

	if ((file != 1) && (file != 2) && (file!=3)) {
  4034f8:	d810      	bhi.n	40351c <_write+0x30>
		return -1;
	}

	for (; len != 0; --len) {
  4034fa:	b19a      	cbz	r2, 403524 <_write+0x38>
  4034fc:	4f0b      	ldr	r7, [pc, #44]	; (40352c <_write+0x40>)
  4034fe:	f8df 8030 	ldr.w	r8, [pc, #48]	; 403530 <_write+0x44>
  403502:	2400      	movs	r4, #0
  403504:	e001      	b.n	40350a <_write+0x1e>
  403506:	42a5      	cmp	r5, r4
  403508:	d00c      	beq.n	403524 <_write+0x38>
		if (ptr_put(stdio_base, *ptr++) < 0) {
  40350a:	5d31      	ldrb	r1, [r6, r4]
  40350c:	6838      	ldr	r0, [r7, #0]
  40350e:	f8d8 3000 	ldr.w	r3, [r8]
  403512:	4798      	blx	r3
  403514:	2800      	cmp	r0, #0
			return -1;
		}
		++nChars;
  403516:	f104 0401 	add.w	r4, r4, #1
	if ((file != 1) && (file != 2) && (file!=3)) {
		return -1;
	}

	for (; len != 0; --len) {
		if (ptr_put(stdio_base, *ptr++) < 0) {
  40351a:	daf4      	bge.n	403506 <_write+0x1a>
_write (int file, const char *ptr, int len)
{
	int nChars = 0;

	if ((file != 1) && (file != 2) && (file!=3)) {
		return -1;
  40351c:	f04f 30ff 	mov.w	r0, #4294967295
  403520:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

	for (; len != 0; --len) {
		if (ptr_put(stdio_base, *ptr++) < 0) {
			return -1;
		}
		++nChars;
  403524:	4628      	mov	r0, r5
	}
	return nChars;
}
  403526:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40352a:	bf00      	nop
  40352c:	20003e10 	.word	0x20003e10
  403530:	20003e0c 	.word	0x20003e0c

00403534 <hsmci_send_cmd_execute>:
 *
 * \return true if success, otherwise false
 */
static bool hsmci_send_cmd_execute(uint32_t cmdr, sdmmc_cmd_def_t cmd,
		uint32_t arg)
{
  403534:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}
	uint32_t sr;

	cmdr |= HSMCI_CMDR_CMDNB(cmd) | HSMCI_CMDR_SPCMD_STD;
  403538:	f001 033f 	and.w	r3, r1, #63	; 0x3f
	if (cmd & SDMMC_RESP_PRESENT) {
  40353c:	05cf      	lsls	r7, r1, #23
static bool hsmci_send_cmd_execute(uint32_t cmdr, sdmmc_cmd_def_t cmd,
		uint32_t arg)
{
	uint32_t sr;

	cmdr |= HSMCI_CMDR_CMDNB(cmd) | HSMCI_CMDR_SPCMD_STD;
  40353e:	ea43 0000 	orr.w	r0, r3, r0
	if (cmd & SDMMC_RESP_PRESENT) {
  403542:	d503      	bpl.n	40354c <hsmci_send_cmd_execute+0x18>
		cmdr |= HSMCI_CMDR_MAXLAT;
		if (cmd & SDMMC_RESP_136) {
  403544:	050e      	lsls	r6, r1, #20
  403546:	d530      	bpl.n	4035aa <hsmci_send_cmd_execute+0x76>
			cmdr |= HSMCI_CMDR_RSPTYP_136_BIT;
  403548:	f440 5084 	orr.w	r0, r0, #4224	; 0x1080
	if (cmd & SDMMC_CMD_OPENDRAIN) {
		cmdr |= HSMCI_CMDR_OPDCMD_OPENDRAIN;
	}

	// Write argument
	HSMCI->HSMCI_ARGR = arg;
  40354c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
			cmdr |= HSMCI_CMDR_RSPTYP_R1B;
		} else {
			cmdr |= HSMCI_CMDR_RSPTYP_48_BIT;
		}
	}
	if (cmd & SDMMC_CMD_OPENDRAIN) {
  403550:	044c      	lsls	r4, r1, #17
		cmdr |= HSMCI_CMDR_OPDCMD_OPENDRAIN;
  403552:	bf48      	it	mi
  403554:	f440 6000 	orrmi.w	r0, r0, #2048	; 0x800
	}

	// Write argument
	HSMCI->HSMCI_ARGR = arg;
  403558:	611a      	str	r2, [r3, #16]
	// Write and start command
	HSMCI->HSMCI_CMDR = cmdr;

	// Wait end of command
	do {
		sr = HSMCI->HSMCI_SR;
  40355a:	461d      	mov	r5, r3
  40355c:	f401 5480 	and.w	r4, r1, #4096	; 0x1000
	}

	// Write argument
	HSMCI->HSMCI_ARGR = arg;
	// Write and start command
	HSMCI->HSMCI_CMDR = cmdr;
  403560:	6158      	str	r0, [r3, #20]
  403562:	e004      	b.n	40356e <hsmci_send_cmd_execute+0x3a>

	// Wait end of command
	do {
		sr = HSMCI->HSMCI_SR;
		if (cmd & SDMMC_RESP_CRC) {
			if (sr & (HSMCI_SR_CSTOE | HSMCI_SR_RTOE
  403564:	f413 0f1f 	tst.w	r3, #10420224	; 0x9f0000
  403568:	d12c      	bne.n	4035c4 <hsmci_send_cmd_execute+0x90>
						__func__, cmd, sr);
				hsmci_reset();
				return false;
			}
		}
	} while (!(sr & HSMCI_SR_CMDRDY));
  40356a:	07da      	lsls	r2, r3, #31
  40356c:	d424      	bmi.n	4035b8 <hsmci_send_cmd_execute+0x84>
	// Write and start command
	HSMCI->HSMCI_CMDR = cmdr;

	// Wait end of command
	do {
		sr = HSMCI->HSMCI_SR;
  40356e:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  403572:	6c2b      	ldr	r3, [r5, #64]	; 0x40
		if (cmd & SDMMC_RESP_CRC) {
  403574:	2c00      	cmp	r4, #0
  403576:	d1f5      	bne.n	403564 <hsmci_send_cmd_execute+0x30>
						__func__, cmd, sr);
				hsmci_reset();
				return false;
			}
		} else {
			if (sr & (HSMCI_SR_CSTOE | HSMCI_SR_RTOE
  403578:	f413 0f1b 	tst.w	r3, #10158080	; 0x9b0000
  40357c:	d0f5      	beq.n	40356a <hsmci_send_cmd_execute+0x36>
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  40357e:	f8d2 c004 	ldr.w	ip, [r2, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  403582:	6897      	ldr	r7, [r2, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  403584:	68d6      	ldr	r6, [r2, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  403586:	69d5      	ldr	r5, [r2, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  403588:	6d51      	ldr	r1, [r2, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  40358a:	f04f 0880 	mov.w	r8, #128	; 0x80
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  40358e:	2305      	movs	r3, #5
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  403590:	f8c2 8000 	str.w	r8, [r2]
	HSMCI->HSMCI_MR = mr;
  403594:	f8c2 c004 	str.w	ip, [r2, #4]
	HSMCI->HSMCI_DTOR = dtor;
  403598:	6097      	str	r7, [r2, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  40359a:	60d6      	str	r6, [r2, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  40359c:	61d5      	str	r5, [r2, #28]
	HSMCI->HSMCI_CFG = cfg;
  40359e:	6551      	str	r1, [r2, #84]	; 0x54
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  4035a0:	6013      	str	r3, [r2, #0]
					| HSMCI_SR_RENDE
					| HSMCI_SR_RDIRE | HSMCI_SR_RINDE)) {
				hsmci_debug("%s: CMD 0x%08x sr 0x%08x error\n\r",
						__func__, cmd, sr);
				hsmci_reset();
				return false;
  4035a2:	4620      	mov	r0, r4
		if (!hsmci_wait_busy()) {
			return false;
		}
	}
	return true;
}
  4035a4:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
  4035a8:	4770      	bx	lr
	cmdr |= HSMCI_CMDR_CMDNB(cmd) | HSMCI_CMDR_SPCMD_STD;
	if (cmd & SDMMC_RESP_PRESENT) {
		cmdr |= HSMCI_CMDR_MAXLAT;
		if (cmd & SDMMC_RESP_136) {
			cmdr |= HSMCI_CMDR_RSPTYP_136_BIT;
		} else if (cmd & SDMMC_RESP_BUSY) {
  4035aa:	048d      	lsls	r5, r1, #18
			cmdr |= HSMCI_CMDR_RSPTYP_R1B;
  4035ac:	bf4c      	ite	mi
  4035ae:	f440 5086 	orrmi.w	r0, r0, #4288	; 0x10c0
		} else {
			cmdr |= HSMCI_CMDR_RSPTYP_48_BIT;
  4035b2:	f440 5082 	orrpl.w	r0, r0, #4160	; 0x1040
  4035b6:	e7c9      	b.n	40354c <hsmci_send_cmd_execute+0x18>
				return false;
			}
		}
	} while (!(sr & HSMCI_SR_CMDRDY));

	if (cmd & SDMMC_RESP_BUSY) {
  4035b8:	048b      	lsls	r3, r1, #18
  4035ba:	d415      	bmi.n	4035e8 <hsmci_send_cmd_execute+0xb4>
		if (!hsmci_wait_busy()) {
			return false;
		}
	}
	return true;
  4035bc:	2001      	movs	r0, #1
}
  4035be:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
  4035c2:	4770      	bx	lr
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  4035c4:	2080      	movs	r0, #128	; 0x80
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  4035c6:	6857      	ldr	r7, [r2, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  4035c8:	6896      	ldr	r6, [r2, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  4035ca:	68d5      	ldr	r5, [r2, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  4035cc:	69d4      	ldr	r4, [r2, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  4035ce:	6d51      	ldr	r1, [r2, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  4035d0:	6010      	str	r0, [r2, #0]
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  4035d2:	2305      	movs	r3, #5
					| HSMCI_SR_RENDE | HSMCI_SR_RCRCE
					| HSMCI_SR_RDIRE | HSMCI_SR_RINDE)) {
				hsmci_debug("%s: CMD 0x%08x sr 0x%08x error\n\r",
						__func__, cmd, sr);
				hsmci_reset();
				return false;
  4035d4:	2000      	movs	r0, #0
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
	HSMCI->HSMCI_MR = mr;
  4035d6:	6057      	str	r7, [r2, #4]
	HSMCI->HSMCI_DTOR = dtor;
  4035d8:	6096      	str	r6, [r2, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  4035da:	60d5      	str	r5, [r2, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  4035dc:	61d4      	str	r4, [r2, #28]
	HSMCI->HSMCI_CFG = cfg;
  4035de:	6551      	str	r1, [r2, #84]	; 0x54
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  4035e0:	6013      	str	r3, [r2, #0]
		if (!hsmci_wait_busy()) {
			return false;
		}
	}
	return true;
}
  4035e2:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
  4035e6:	4770      	bx	lr
{
	uint32_t busy_wait = 0xFFFFFFFF;
	uint32_t sr;

	do {
		sr = HSMCI->HSMCI_SR;
  4035e8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  4035ec:	4619      	mov	r1, r3
  4035ee:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  4035f0:	f04f 30ff 	mov.w	r0, #4294967295
		if (busy_wait-- == 0) {
			hsmci_debug("%s: timeout\n\r", __func__);
			hsmci_reset();
			return false;
		}
	} while (!((sr & HSMCI_SR_NOTBUSY) && ((sr & HSMCI_SR_DTIP) == 0)));
  4035f4:	f003 0330 	and.w	r3, r3, #48	; 0x30
  4035f8:	2b20      	cmp	r3, #32
{
	uint32_t busy_wait = 0xFFFFFFFF;
	uint32_t sr;

	do {
		sr = HSMCI->HSMCI_SR;
  4035fa:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
		if (busy_wait-- == 0) {
			hsmci_debug("%s: timeout\n\r", __func__);
			hsmci_reset();
			return false;
		}
	} while (!((sr & HSMCI_SR_NOTBUSY) && ((sr & HSMCI_SR_DTIP) == 0)));
  4035fe:	d0dd      	beq.n	4035bc <hsmci_send_cmd_execute+0x88>
	uint32_t busy_wait = 0xFFFFFFFF;
	uint32_t sr;

	do {
		sr = HSMCI->HSMCI_SR;
		if (busy_wait-- == 0) {
  403600:	3801      	subs	r0, #1
{
	uint32_t busy_wait = 0xFFFFFFFF;
	uint32_t sr;

	do {
		sr = HSMCI->HSMCI_SR;
  403602:	6c0b      	ldr	r3, [r1, #64]	; 0x40
		if (busy_wait-- == 0) {
  403604:	d1f6      	bne.n	4035f4 <hsmci_send_cmd_execute+0xc0>
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  403606:	f04f 0c80 	mov.w	ip, #128	; 0x80
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  40360a:	6857      	ldr	r7, [r2, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  40360c:	6896      	ldr	r6, [r2, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  40360e:	68d5      	ldr	r5, [r2, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  403610:	69d4      	ldr	r4, [r2, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  403612:	6d51      	ldr	r1, [r2, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  403614:	f8c2 c000 	str.w	ip, [r2]
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  403618:	2305      	movs	r3, #5
  40361a:	e7dc      	b.n	4035d6 <hsmci_send_cmd_execute+0xa2>

0040361c <hsmci_init>:

//-------------------------------------------------------------------
//--------------------- PUBLIC FUNCTIONS ----------------------------

void hsmci_init(void)
{
  40361c:	b510      	push	{r4, lr}
	pmc_enable_periph_clk(ID_HSMCI);
  40361e:	4b08      	ldr	r3, [pc, #32]	; (403640 <hsmci_init+0x24>)
  403620:	2012      	movs	r0, #18
  403622:	4798      	blx	r3
	// Enable clock for DMA controller
	pmc_enable_periph_clk(ID_DMAC);
#endif

	// Set the Data Timeout Register to 2 Mega Cycles
	HSMCI->HSMCI_DTOR = HSMCI_DTOR_DTOMUL_1048576 | HSMCI_DTOR_DTOCYC(2);
  403624:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  403628:	2272      	movs	r2, #114	; 0x72
	// Set Completion Signal Timeout to 2 Mega Cycles
	HSMCI->HSMCI_CSTOR = HSMCI_CSTOR_CSTOMUL_1048576 | HSMCI_CSTOR_CSTOCYC(2);
	// Set Configuration Register
	HSMCI->HSMCI_CFG = HSMCI_CFG_FIFOMODE | HSMCI_CFG_FERRCTRL;
  40362a:	2411      	movs	r4, #17
	// Set power saving to maximum value
	HSMCI->HSMCI_MR = HSMCI_MR_PWSDIV_Msk;
  40362c:	f44f 60e0 	mov.w	r0, #1792	; 0x700

	// Enable the HSMCI and the Power Saving
	HSMCI->HSMCI_CR = HSMCI_CR_MCIEN | HSMCI_CR_PWSEN;
  403630:	2105      	movs	r1, #5
	// Enable clock for DMA controller
	pmc_enable_periph_clk(ID_DMAC);
#endif

	// Set the Data Timeout Register to 2 Mega Cycles
	HSMCI->HSMCI_DTOR = HSMCI_DTOR_DTOMUL_1048576 | HSMCI_DTOR_DTOCYC(2);
  403632:	609a      	str	r2, [r3, #8]
	// Set Completion Signal Timeout to 2 Mega Cycles
	HSMCI->HSMCI_CSTOR = HSMCI_CSTOR_CSTOMUL_1048576 | HSMCI_CSTOR_CSTOCYC(2);
  403634:	61da      	str	r2, [r3, #28]
	// Set Configuration Register
	HSMCI->HSMCI_CFG = HSMCI_CFG_FIFOMODE | HSMCI_CFG_FERRCTRL;
  403636:	655c      	str	r4, [r3, #84]	; 0x54
	// Set power saving to maximum value
	HSMCI->HSMCI_MR = HSMCI_MR_PWSDIV_Msk;
  403638:	6058      	str	r0, [r3, #4]

	// Enable the HSMCI and the Power Saving
	HSMCI->HSMCI_CR = HSMCI_CR_MCIEN | HSMCI_CR_PWSEN;
  40363a:	6019      	str	r1, [r3, #0]
  40363c:	bd10      	pop	{r4, pc}
  40363e:	bf00      	nop
  403640:	0040b231 	.word	0x0040b231

00403644 <hsmci_get_bus_width>:
}

uint8_t hsmci_get_bus_width(uint8_t slot)
{
	switch (slot) {
  403644:	2800      	cmp	r0, #0
		return SD_MMC_HSMCI_SLOT_1_SIZE;
#endif
	default:
		return 0; // Slot number wrong
	}
}
  403646:	bf0c      	ite	eq
  403648:	2004      	moveq	r0, #4
  40364a:	2000      	movne	r0, #0
  40364c:	4770      	bx	lr
  40364e:	bf00      	nop

00403650 <hsmci_is_high_speed_capable>:

bool hsmci_is_high_speed_capable(void)
{
	return true;
}
  403650:	2001      	movs	r0, #1
  403652:	4770      	bx	lr

00403654 <hsmci_select_device>:
void hsmci_select_device(uint8_t slot, uint32_t clock, uint8_t bus_width, bool high_speed)
{
	uint32_t hsmci_slot = HSMCI_SDCR_SDCSEL_SLOTA;
	uint32_t hsmci_bus_width = HSMCI_SDCR_SDCBUS_1;

	if (high_speed) {
  403654:	b33b      	cbz	r3, 4036a6 <hsmci_select_device+0x52>
		HSMCI->HSMCI_CFG |= HSMCI_CFG_HSMODE;
  403656:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
#else
	uint32_t clkdiv = 0;
	uint32_t rest = 0;

	// Speed = MCK clock / (2 * (CLKDIV + 1))
	if ((speed * 2) < mck) {
  40365a:	0049      	lsls	r1, r1, #1
{
	uint32_t hsmci_slot = HSMCI_SDCR_SDCSEL_SLOTA;
	uint32_t hsmci_bus_width = HSMCI_SDCR_SDCBUS_1;

	if (high_speed) {
		HSMCI->HSMCI_CFG |= HSMCI_CFG_HSMODE;
  40365c:	6d58      	ldr	r0, [r3, #84]	; 0x54
  40365e:	f440 7080 	orr.w	r0, r0, #256	; 0x100
  403662:	6558      	str	r0, [r3, #84]	; 0x54
#else
	uint32_t clkdiv = 0;
	uint32_t rest = 0;

	// Speed = MCK clock / (2 * (CLKDIV + 1))
	if ((speed * 2) < mck) {
  403664:	4b1a      	ldr	r3, [pc, #104]	; (4036d0 <hsmci_select_device+0x7c>)
  403666:	4299      	cmp	r1, r3
  403668:	d827      	bhi.n	4036ba <hsmci_select_device+0x66>
		clkdiv = mck / (2 * speed);
  40366a:	3301      	adds	r3, #1
		rest = mck % (2 * speed);
  40366c:	4618      	mov	r0, r3
	uint32_t clkdiv = 0;
	uint32_t rest = 0;

	// Speed = MCK clock / (2 * (CLKDIV + 1))
	if ((speed * 2) < mck) {
		clkdiv = mck / (2 * speed);
  40366e:	fbb3 f3f1 	udiv	r3, r3, r1
		rest = mck % (2 * speed);
  403672:	fb01 f103 	mul.w	r1, r1, r3
  403676:	1a40      	subs	r0, r0, r1
		if (rest > 0) {
  403678:	bb08      	cbnz	r0, 4036be <hsmci_select_device+0x6a>
			// Ensure that the card speed not be higher than expected.
			clkdiv++;
		}
		if (clkdiv > 0) {
  40367a:	bb0b      	cbnz	r3, 4036c0 <hsmci_select_device+0x6c>
  40367c:	4619      	mov	r1, r3
			clkdiv -= 1;
		}
	} else {
		clkdiv = 0;
	}
	HSMCI->HSMCI_MR &= ~HSMCI_MR_CLKDIV_Msk;
  40367e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
#endif
	default:
		Assert(false); // Slot number wrong
	}

	switch (bus_width) {
  403682:	2a04      	cmp	r2, #4
			clkdiv -= 1;
		}
	} else {
		clkdiv = 0;
	}
	HSMCI->HSMCI_MR &= ~HSMCI_MR_CLKDIV_Msk;
  403684:	6858      	ldr	r0, [r3, #4]
  403686:	f020 00ff 	bic.w	r0, r0, #255	; 0xff
  40368a:	6058      	str	r0, [r3, #4]
	HSMCI->HSMCI_MR |= HSMCI_MR_CLKDIV(clkdiv);
  40368c:	6858      	ldr	r0, [r3, #4]
  40368e:	ea41 0100 	orr.w	r1, r1, r0
  403692:	6059      	str	r1, [r3, #4]
#endif
	default:
		Assert(false); // Slot number wrong
	}

	switch (bus_width) {
  403694:	d017      	beq.n	4036c6 <hsmci_select_device+0x72>
  403696:	2a08      	cmp	r2, #8
		break;

	default:
		Assert(false); // Bus width wrong
	}
	HSMCI->HSMCI_SDCR = hsmci_slot | hsmci_bus_width;
  403698:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
}

void hsmci_select_device(uint8_t slot, uint32_t clock, uint8_t bus_width, bool high_speed)
{
	uint32_t hsmci_slot = HSMCI_SDCR_SDCSEL_SLOTA;
	uint32_t hsmci_bus_width = HSMCI_SDCR_SDCBUS_1;
  40369c:	bf0c      	ite	eq
  40369e:	22c0      	moveq	r2, #192	; 0xc0
  4036a0:	2200      	movne	r2, #0
		break;

	default:
		Assert(false); // Bus width wrong
	}
	HSMCI->HSMCI_SDCR = hsmci_slot | hsmci_bus_width;
  4036a2:	60da      	str	r2, [r3, #12]
  4036a4:	4770      	bx	lr
	uint32_t hsmci_bus_width = HSMCI_SDCR_SDCBUS_1;

	if (high_speed) {
		HSMCI->HSMCI_CFG |= HSMCI_CFG_HSMODE;
	} else {
		HSMCI->HSMCI_CFG &= ~HSMCI_CFG_HSMODE;
  4036a6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
#else
	uint32_t clkdiv = 0;
	uint32_t rest = 0;

	// Speed = MCK clock / (2 * (CLKDIV + 1))
	if ((speed * 2) < mck) {
  4036aa:	0049      	lsls	r1, r1, #1
	uint32_t hsmci_bus_width = HSMCI_SDCR_SDCBUS_1;

	if (high_speed) {
		HSMCI->HSMCI_CFG |= HSMCI_CFG_HSMODE;
	} else {
		HSMCI->HSMCI_CFG &= ~HSMCI_CFG_HSMODE;
  4036ac:	6d58      	ldr	r0, [r3, #84]	; 0x54
  4036ae:	f420 7080 	bic.w	r0, r0, #256	; 0x100
  4036b2:	6558      	str	r0, [r3, #84]	; 0x54
#else
	uint32_t clkdiv = 0;
	uint32_t rest = 0;

	// Speed = MCK clock / (2 * (CLKDIV + 1))
	if ((speed * 2) < mck) {
  4036b4:	4b06      	ldr	r3, [pc, #24]	; (4036d0 <hsmci_select_device+0x7c>)
  4036b6:	4299      	cmp	r1, r3
  4036b8:	d9d7      	bls.n	40366a <hsmci_select_device+0x16>
  4036ba:	2100      	movs	r1, #0
  4036bc:	e7df      	b.n	40367e <hsmci_select_device+0x2a>
		clkdiv = mck / (2 * speed);
		rest = mck % (2 * speed);
		if (rest > 0) {
			// Ensure that the card speed not be higher than expected.
			clkdiv++;
  4036be:	3301      	adds	r3, #1
		}
		if (clkdiv > 0) {
			clkdiv -= 1;
  4036c0:	3b01      	subs	r3, #1
  4036c2:	b2d9      	uxtb	r1, r3
  4036c4:	e7db      	b.n	40367e <hsmci_select_device+0x2a>
		break;

	default:
		Assert(false); // Bus width wrong
	}
	HSMCI->HSMCI_SDCR = hsmci_slot | hsmci_bus_width;
  4036c6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
	case 1:
		hsmci_bus_width = HSMCI_SDCR_SDCBUS_1;
		break;

	case 4:
		hsmci_bus_width = HSMCI_SDCR_SDCBUS_4;
  4036ca:	2280      	movs	r2, #128	; 0x80
		break;

	default:
		Assert(false); // Bus width wrong
	}
	HSMCI->HSMCI_SDCR = hsmci_slot | hsmci_bus_width;
  4036cc:	60da      	str	r2, [r3, #12]
  4036ce:	4770      	bx	lr
  4036d0:	07270dff 	.word	0x07270dff

004036d4 <hsmci_deselect_device>:
}

void hsmci_deselect_device(uint8_t slot)
{
  4036d4:	4770      	bx	lr
  4036d6:	bf00      	nop

004036d8 <hsmci_send_clock>:
}

void hsmci_send_clock(void)
{
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
  4036d8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
	// Write argument
	HSMCI->HSMCI_ARGR = 0;
  4036dc:	2000      	movs	r0, #0
}

void hsmci_send_clock(void)
{
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
  4036de:	685a      	ldr	r2, [r3, #4]
	// Write argument
	HSMCI->HSMCI_ARGR = 0;
	// Write and start initialization command
	HSMCI->HSMCI_CMDR = HSMCI_CMDR_RSPTYP_NORESP
  4036e0:	f44f 6110 	mov.w	r1, #2304	; 0x900
}

void hsmci_send_clock(void)
{
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
  4036e4:	f422 5260 	bic.w	r2, r2, #14336	; 0x3800
  4036e8:	605a      	str	r2, [r3, #4]
	// Write argument
	HSMCI->HSMCI_ARGR = 0;
  4036ea:	6118      	str	r0, [r3, #16]
	// Write and start initialization command
	HSMCI->HSMCI_CMDR = HSMCI_CMDR_RSPTYP_NORESP
			| HSMCI_CMDR_SPCMD_INIT
			| HSMCI_CMDR_OPDCMD_OPENDRAIN;
	// Wait end of initialization command
	while (!(HSMCI->HSMCI_SR & HSMCI_SR_CMDRDY));
  4036ec:	461a      	mov	r2, r3
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
	// Write argument
	HSMCI->HSMCI_ARGR = 0;
	// Write and start initialization command
	HSMCI->HSMCI_CMDR = HSMCI_CMDR_RSPTYP_NORESP
  4036ee:	6159      	str	r1, [r3, #20]
			| HSMCI_CMDR_SPCMD_INIT
			| HSMCI_CMDR_OPDCMD_OPENDRAIN;
	// Wait end of initialization command
	while (!(HSMCI->HSMCI_SR & HSMCI_SR_CMDRDY));
  4036f0:	6c13      	ldr	r3, [r2, #64]	; 0x40
  4036f2:	07db      	lsls	r3, r3, #31
  4036f4:	d5fc      	bpl.n	4036f0 <hsmci_send_clock+0x18>
}
  4036f6:	4770      	bx	lr

004036f8 <hsmci_send_cmd>:

bool hsmci_send_cmd(sdmmc_cmd_def_t cmd, uint32_t arg)
{
  4036f8:	b570      	push	{r4, r5, r6, lr}
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
  4036fa:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
#endif
#ifdef HSMCI_MR_PDCMODE
	// Disable PDC for HSMCI
	HSMCI->HSMCI_MR &= ~HSMCI_MR_PDCMODE;
#endif
	HSMCI->HSMCI_BLKR = 0;
  4036fe:	2400      	movs	r4, #0
}

bool hsmci_send_cmd(sdmmc_cmd_def_t cmd, uint32_t arg)
{
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
  403700:	685a      	ldr	r2, [r3, #4]
#ifdef HSMCI_MR_PDCMODE
	// Disable PDC for HSMCI
	HSMCI->HSMCI_MR &= ~HSMCI_MR_PDCMODE;
#endif
	HSMCI->HSMCI_BLKR = 0;
	return hsmci_send_cmd_execute(0, cmd, arg);
  403702:	4d07      	ldr	r5, [pc, #28]	; (403720 <hsmci_send_cmd+0x28>)
}

bool hsmci_send_cmd(sdmmc_cmd_def_t cmd, uint32_t arg)
{
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
  403704:	f422 5260 	bic.w	r2, r2, #14336	; 0x3800
  403708:	605a      	str	r2, [r3, #4]
	// Disable DMA for HSMCI
	HSMCI->HSMCI_DMA = 0;
#endif
#ifdef HSMCI_MR_PDCMODE
	// Disable PDC for HSMCI
	HSMCI->HSMCI_MR &= ~HSMCI_MR_PDCMODE;
  40370a:	685e      	ldr	r6, [r3, #4]
  40370c:	f426 4600 	bic.w	r6, r6, #32768	; 0x8000
	// Wait end of initialization command
	while (!(HSMCI->HSMCI_SR & HSMCI_SR_CMDRDY));
}

bool hsmci_send_cmd(sdmmc_cmd_def_t cmd, uint32_t arg)
{
  403710:	460a      	mov	r2, r1
	// Disable DMA for HSMCI
	HSMCI->HSMCI_DMA = 0;
#endif
#ifdef HSMCI_MR_PDCMODE
	// Disable PDC for HSMCI
	HSMCI->HSMCI_MR &= ~HSMCI_MR_PDCMODE;
  403712:	605e      	str	r6, [r3, #4]
#endif
	HSMCI->HSMCI_BLKR = 0;
	return hsmci_send_cmd_execute(0, cmd, arg);
  403714:	4601      	mov	r1, r0
#endif
#ifdef HSMCI_MR_PDCMODE
	// Disable PDC for HSMCI
	HSMCI->HSMCI_MR &= ~HSMCI_MR_PDCMODE;
#endif
	HSMCI->HSMCI_BLKR = 0;
  403716:	619c      	str	r4, [r3, #24]
	return hsmci_send_cmd_execute(0, cmd, arg);
  403718:	4620      	mov	r0, r4
  40371a:	47a8      	blx	r5
}
  40371c:	bd70      	pop	{r4, r5, r6, pc}
  40371e:	bf00      	nop
  403720:	00403535 	.word	0x00403535

00403724 <hsmci_get_response>:

uint32_t hsmci_get_response(void)
{
	return HSMCI->HSMCI_RSPR[0];
  403724:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  403728:	6a18      	ldr	r0, [r3, #32]
}
  40372a:	4770      	bx	lr

0040372c <hsmci_get_response_128>:

void hsmci_get_response_128(uint8_t* response)
{
  40372c:	b430      	push	{r4, r5}
  40372e:	f100 0510 	add.w	r5, r0, #16
	uint32_t response_32;

	for (uint8_t i = 0; i < 4; i++) {
		response_32 = HSMCI->HSMCI_RSPR[0];
  403732:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
  403736:	6a23      	ldr	r3, [r4, #32]
		response++;
		*response = (response_32 >> 16) & 0xFF;
		response++;
		*response = (response_32 >>  8) & 0xFF;
		response++;
		*response = (response_32 >>  0) & 0xFF;
  403738:	70c3      	strb	r3, [r0, #3]
{
	uint32_t response_32;

	for (uint8_t i = 0; i < 4; i++) {
		response_32 = HSMCI->HSMCI_RSPR[0];
		*response = (response_32 >> 24) & 0xFF;
  40373a:	0e19      	lsrs	r1, r3, #24
		response++;
		*response = (response_32 >> 16) & 0xFF;
  40373c:	0c1a      	lsrs	r2, r3, #16
		response++;
		*response = (response_32 >>  8) & 0xFF;
  40373e:	0a1b      	lsrs	r3, r3, #8
{
	uint32_t response_32;

	for (uint8_t i = 0; i < 4; i++) {
		response_32 = HSMCI->HSMCI_RSPR[0];
		*response = (response_32 >> 24) & 0xFF;
  403740:	7001      	strb	r1, [r0, #0]
		response++;
		*response = (response_32 >> 16) & 0xFF;
  403742:	7042      	strb	r2, [r0, #1]
		response++;
		*response = (response_32 >>  8) & 0xFF;
  403744:	7083      	strb	r3, [r0, #2]
  403746:	3004      	adds	r0, #4

void hsmci_get_response_128(uint8_t* response)
{
	uint32_t response_32;

	for (uint8_t i = 0; i < 4; i++) {
  403748:	42a8      	cmp	r0, r5
  40374a:	d1f4      	bne.n	403736 <hsmci_get_response_128+0xa>
		*response = (response_32 >>  8) & 0xFF;
		response++;
		*response = (response_32 >>  0) & 0xFF;
		response++;
	}
}
  40374c:	bc30      	pop	{r4, r5}
  40374e:	4770      	bx	lr

00403750 <hsmci_adtc_start>:

bool hsmci_adtc_start(sdmmc_cmd_def_t cmd, uint32_t arg, uint16_t block_size, uint16_t nb_block, bool access_block)
{
  403750:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  403752:	460e      	mov	r6, r1
  403754:	f89d 5018 	ldrb.w	r5, [sp, #24]
#endif

#ifdef HSMCI_MR_PDCMODE
	if (access_block) {
		// Enable PDC for HSMCI
		HSMCI->HSMCI_MR |= HSMCI_MR_PDCMODE;
  403758:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
		response++;
	}
}

bool hsmci_adtc_start(sdmmc_cmd_def_t cmd, uint32_t arg, uint16_t block_size, uint16_t nb_block, bool access_block)
{
  40375c:	4604      	mov	r4, r0
#endif

#ifdef HSMCI_MR_PDCMODE
	if (access_block) {
		// Enable PDC for HSMCI
		HSMCI->HSMCI_MR |= HSMCI_MR_PDCMODE;
  40375e:	6848      	ldr	r0, [r1, #4]
		HSMCI->HSMCI_DMA = 0;
	}
#endif

#ifdef HSMCI_MR_PDCMODE
	if (access_block) {
  403760:	b34d      	cbz	r5, 4037b6 <hsmci_adtc_start+0x66>
		// Enable PDC for HSMCI
		HSMCI->HSMCI_MR |= HSMCI_MR_PDCMODE;
  403762:	f440 4000 	orr.w	r0, r0, #32768	; 0x8000
  403766:	6048      	str	r0, [r1, #4]
#endif

	// Enabling Read/Write Proof allows to stop the HSMCI Clock during
	// read/write  access if the internal FIFO is full.
	// This will guarantee data integrity, not bandwidth.
	HSMCI->HSMCI_MR |= HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF;
  403768:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
	// Force byte transfer if needed
	if (block_size & 0x3) {
  40376c:	0797      	lsls	r7, r2, #30
#endif

	// Enabling Read/Write Proof allows to stop the HSMCI Clock during
	// read/write  access if the internal FIFO is full.
	// This will guarantee data integrity, not bandwidth.
	HSMCI->HSMCI_MR |= HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF;
  40376e:	6841      	ldr	r1, [r0, #4]
  403770:	f441 51c0 	orr.w	r1, r1, #6144	; 0x1800
  403774:	6041      	str	r1, [r0, #4]
	// Force byte transfer if needed
	if (block_size & 0x3) {
		HSMCI->HSMCI_MR |= HSMCI_MR_FBYTE;
  403776:	6841      	ldr	r1, [r0, #4]
  403778:	bf14      	ite	ne
  40377a:	f441 5100 	orrne.w	r1, r1, #8192	; 0x2000
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
  40377e:	f421 5100 	biceq.w	r1, r1, #8192	; 0x2000
	}

	if (cmd & SDMMC_CMD_WRITE) {
		cmdr = HSMCI_CMDR_TRCMD_START_DATA | HSMCI_CMDR_TRDIR_WRITE;
  403782:	f414 4f00 	tst.w	r4, #32768	; 0x8000
	HSMCI->HSMCI_MR |= HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF;
	// Force byte transfer if needed
	if (block_size & 0x3) {
		HSMCI->HSMCI_MR |= HSMCI_MR_FBYTE;
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
  403786:	6041      	str	r1, [r0, #4]
	}

	if (cmd & SDMMC_CMD_WRITE) {
		cmdr = HSMCI_CMDR_TRCMD_START_DATA | HSMCI_CMDR_TRDIR_WRITE;
  403788:	bf0c      	ite	eq
  40378a:	f44f 20a0 	moveq.w	r0, #327680	; 0x50000
  40378e:	f44f 3080 	movne.w	r0, #65536	; 0x10000
	} else {
		cmdr = HSMCI_CMDR_TRCMD_START_DATA | HSMCI_CMDR_TRDIR_READ;
	}

	if (cmd & SDMMC_CMD_SDIO_BYTE) {
  403792:	03e5      	lsls	r5, r4, #15
			cmdr |= HSMCI_CMDR_TRTYP_BYTE;
			// Value 0 corresponds to a 512-byte transfer
			HSMCI->HSMCI_BLKR = ((block_size % 512) << HSMCI_BLKR_BCNT_Pos);
  403794:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
		cmdr = HSMCI_CMDR_TRCMD_START_DATA | HSMCI_CMDR_TRDIR_WRITE;
	} else {
		cmdr = HSMCI_CMDR_TRCMD_START_DATA | HSMCI_CMDR_TRDIR_READ;
	}

	if (cmd & SDMMC_CMD_SDIO_BYTE) {
  403798:	d421      	bmi.n	4037de <hsmci_adtc_start+0x8e>
			cmdr |= HSMCI_CMDR_TRTYP_BYTE;
			// Value 0 corresponds to a 512-byte transfer
			HSMCI->HSMCI_BLKR = ((block_size % 512) << HSMCI_BLKR_BCNT_Pos);
	} else {
		HSMCI->HSMCI_BLKR = (block_size << HSMCI_BLKR_BLKLEN_Pos) |
  40379a:	ea43 4502 	orr.w	r5, r3, r2, lsl #16
  40379e:	618d      	str	r5, [r1, #24]
				(nb_block << HSMCI_BLKR_BCNT_Pos);
		if (cmd & SDMMC_CMD_SDIO_BLOCK) {
  4037a0:	03a1      	lsls	r1, r4, #14
  4037a2:	d40c      	bmi.n	4037be <hsmci_adtc_start+0x6e>
			cmdr |= HSMCI_CMDR_TRTYP_BLOCK;
		} else if (cmd & SDMMC_CMD_STREAM) {
  4037a4:	0367      	lsls	r7, r4, #13
  4037a6:	d420      	bmi.n	4037ea <hsmci_adtc_start+0x9a>
			cmdr |= HSMCI_CMDR_TRTYP_STREAM;
		} else if (cmd & SDMMC_CMD_SINGLE_BLOCK) {
  4037a8:	0325      	lsls	r5, r4, #12
  4037aa:	d40a      	bmi.n	4037c2 <hsmci_adtc_start+0x72>
			cmdr |= HSMCI_CMDR_TRTYP_SINGLE;
		} else if (cmd & SDMMC_CMD_MULTI_BLOCK) {
  4037ac:	02e1      	lsls	r1, r4, #11
			cmdr |= HSMCI_CMDR_TRTYP_MULTIPLE;
  4037ae:	bf48      	it	mi
  4037b0:	f440 2000 	orrmi.w	r0, r0, #524288	; 0x80000
  4037b4:	e005      	b.n	4037c2 <hsmci_adtc_start+0x72>
	if (access_block) {
		// Enable PDC for HSMCI
		HSMCI->HSMCI_MR |= HSMCI_MR_PDCMODE;
	} else {
		// Disable PDC for HSMCI
		HSMCI->HSMCI_MR &= ~HSMCI_MR_PDCMODE;
  4037b6:	f420 4000 	bic.w	r0, r0, #32768	; 0x8000
  4037ba:	6048      	str	r0, [r1, #4]
  4037bc:	e7d4      	b.n	403768 <hsmci_adtc_start+0x18>
			HSMCI->HSMCI_BLKR = ((block_size % 512) << HSMCI_BLKR_BCNT_Pos);
	} else {
		HSMCI->HSMCI_BLKR = (block_size << HSMCI_BLKR_BLKLEN_Pos) |
				(nb_block << HSMCI_BLKR_BCNT_Pos);
		if (cmd & SDMMC_CMD_SDIO_BLOCK) {
			cmdr |= HSMCI_CMDR_TRTYP_BLOCK;
  4037be:	f440 1020 	orr.w	r0, r0, #2621440	; 0x280000
		} else {
			Assert(false); // Incorrect flags
		}
	}
	hsmci_transfert_pos = 0;
	hsmci_block_size = block_size;
  4037c2:	490b      	ldr	r1, [pc, #44]	; (4037f0 <hsmci_adtc_start+0xa0>)
			cmdr |= HSMCI_CMDR_TRTYP_MULTIPLE;
		} else {
			Assert(false); // Incorrect flags
		}
	}
	hsmci_transfert_pos = 0;
  4037c4:	f8df e034 	ldr.w	lr, [pc, #52]	; 4037fc <hsmci_adtc_start+0xac>
	hsmci_block_size = block_size;
	hsmci_nb_block = nb_block;
  4037c8:	4f0a      	ldr	r7, [pc, #40]	; (4037f4 <hsmci_adtc_start+0xa4>)
		} else {
			Assert(false); // Incorrect flags
		}
	}
	hsmci_transfert_pos = 0;
	hsmci_block_size = block_size;
  4037ca:	800a      	strh	r2, [r1, #0]
	hsmci_nb_block = nb_block;

	return hsmci_send_cmd_execute(cmdr, cmd, arg);
  4037cc:	4d0a      	ldr	r5, [pc, #40]	; (4037f8 <hsmci_adtc_start+0xa8>)
			Assert(false); // Incorrect flags
		}
	}
	hsmci_transfert_pos = 0;
	hsmci_block_size = block_size;
	hsmci_nb_block = nb_block;
  4037ce:	803b      	strh	r3, [r7, #0]

	return hsmci_send_cmd_execute(cmdr, cmd, arg);
  4037d0:	4621      	mov	r1, r4
  4037d2:	4632      	mov	r2, r6
			cmdr |= HSMCI_CMDR_TRTYP_MULTIPLE;
		} else {
			Assert(false); // Incorrect flags
		}
	}
	hsmci_transfert_pos = 0;
  4037d4:	2400      	movs	r4, #0
  4037d6:	f8ce 4000 	str.w	r4, [lr]
	hsmci_block_size = block_size;
	hsmci_nb_block = nb_block;

	return hsmci_send_cmd_execute(cmdr, cmd, arg);
  4037da:	47a8      	blx	r5
}
  4037dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	}

	if (cmd & SDMMC_CMD_SDIO_BYTE) {
			cmdr |= HSMCI_CMDR_TRTYP_BYTE;
			// Value 0 corresponds to a 512-byte transfer
			HSMCI->HSMCI_BLKR = ((block_size % 512) << HSMCI_BLKR_BCNT_Pos);
  4037de:	f3c2 0508 	ubfx	r5, r2, #0, #9
	} else {
		cmdr = HSMCI_CMDR_TRCMD_START_DATA | HSMCI_CMDR_TRDIR_READ;
	}

	if (cmd & SDMMC_CMD_SDIO_BYTE) {
			cmdr |= HSMCI_CMDR_TRTYP_BYTE;
  4037e2:	f440 1000 	orr.w	r0, r0, #2097152	; 0x200000
			// Value 0 corresponds to a 512-byte transfer
			HSMCI->HSMCI_BLKR = ((block_size % 512) << HSMCI_BLKR_BCNT_Pos);
  4037e6:	618d      	str	r5, [r1, #24]
  4037e8:	e7eb      	b.n	4037c2 <hsmci_adtc_start+0x72>
		HSMCI->HSMCI_BLKR = (block_size << HSMCI_BLKR_BLKLEN_Pos) |
				(nb_block << HSMCI_BLKR_BCNT_Pos);
		if (cmd & SDMMC_CMD_SDIO_BLOCK) {
			cmdr |= HSMCI_CMDR_TRTYP_BLOCK;
		} else if (cmd & SDMMC_CMD_STREAM) {
			cmdr |= HSMCI_CMDR_TRTYP_STREAM;
  4037ea:	f440 1080 	orr.w	r0, r0, #1048576	; 0x100000
  4037ee:	e7e8      	b.n	4037c2 <hsmci_adtc_start+0x72>
  4037f0:	2000338c 	.word	0x2000338c
  4037f4:	2000338e 	.word	0x2000338e
  4037f8:	00403535 	.word	0x00403535
  4037fc:	20003390 	.word	0x20003390

00403800 <hsmci_read_word>:
{
	return hsmci_send_cmd_execute(HSMCI_CMDR_TRCMD_STOP_DATA, cmd, arg);
}

bool hsmci_read_word(uint32_t* value)
{
  403800:	b4f0      	push	{r4, r5, r6, r7}

	Assert(((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos);

	// Wait data available
	do {
		sr = HSMCI->HSMCI_SR;
  403802:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
  403806:	e001      	b.n	40380c <hsmci_read_word+0xc>
			hsmci_debug("%s: DMA sr 0x%08x error\n\r",
					__func__, sr);
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_RXRDY));
  403808:	0792      	lsls	r2, r2, #30
  40380a:	d417      	bmi.n	40383c <hsmci_read_word+0x3c>

	Assert(((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos);

	// Wait data available
	do {
		sr = HSMCI->HSMCI_SR;
  40380c:	6c22      	ldr	r2, [r4, #64]	; 0x40
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  40380e:	4b21      	ldr	r3, [pc, #132]	; (403894 <hsmci_read_word+0x94>)
  403810:	4013      	ands	r3, r2

	Assert(((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos);

	// Wait data available
	do {
		sr = HSMCI->HSMCI_SR;
  403812:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  403816:	2b00      	cmp	r3, #0
  403818:	d0f6      	beq.n	403808 <hsmci_read_word+0x8>
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  40381a:	684f      	ldr	r7, [r1, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  40381c:	688e      	ldr	r6, [r1, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  40381e:	68cd      	ldr	r5, [r1, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  403820:	69cc      	ldr	r4, [r1, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  403822:	6d4a      	ldr	r2, [r1, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  403824:	2080      	movs	r0, #128	; 0x80
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  403826:	2305      	movs	r3, #5
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  403828:	6008      	str	r0, [r1, #0]
	HSMCI->HSMCI_MR = mr;
  40382a:	604f      	str	r7, [r1, #4]
	HSMCI->HSMCI_DTOR = dtor;
  40382c:	608e      	str	r6, [r1, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  40382e:	60cd      	str	r5, [r1, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  403830:	61cc      	str	r4, [r1, #28]
	HSMCI->HSMCI_CFG = cfg;
  403832:	654a      	str	r2, [r1, #84]	; 0x54
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  403834:	600b      	str	r3, [r1, #0]
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: DMA sr 0x%08x error\n\r",
					__func__, sr);
			hsmci_reset();
			return false;
  403836:	2000      	movs	r0, #0
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
	return true;
}
  403838:	bcf0      	pop	{r4, r5, r6, r7}
  40383a:	4770      	bx	lr
		}
	} while (!(sr & HSMCI_SR_RXRDY));

	// Read data
	*value = HSMCI->HSMCI_RDR;
	hsmci_transfert_pos += 4;
  40383c:	4a16      	ldr	r2, [pc, #88]	; (403898 <hsmci_read_word+0x98>)
	if (((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos) {
  40383e:	4c17      	ldr	r4, [pc, #92]	; (40389c <hsmci_read_word+0x9c>)
  403840:	4d17      	ldr	r5, [pc, #92]	; (4038a0 <hsmci_read_word+0xa0>)
		}
	} while (!(sr & HSMCI_SR_RXRDY));

	// Read data
	*value = HSMCI->HSMCI_RDR;
	hsmci_transfert_pos += 4;
  403842:	6813      	ldr	r3, [r2, #0]
	if (((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos) {
  403844:	8826      	ldrh	r6, [r4, #0]
  403846:	882d      	ldrh	r5, [r5, #0]
			return false;
		}
	} while (!(sr & HSMCI_SR_RXRDY));

	// Read data
	*value = HSMCI->HSMCI_RDR;
  403848:	6b0c      	ldr	r4, [r1, #48]	; 0x30
  40384a:	6004      	str	r4, [r0, #0]
	hsmci_transfert_pos += 4;
  40384c:	3304      	adds	r3, #4
	if (((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos) {
  40384e:	fb06 f005 	mul.w	r0, r6, r5
  403852:	4283      	cmp	r3, r0
		}
	} while (!(sr & HSMCI_SR_RXRDY));

	// Read data
	*value = HSMCI->HSMCI_RDR;
	hsmci_transfert_pos += 4;
  403854:	6013      	str	r3, [r2, #0]
	if (((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos) {
  403856:	d202      	bcs.n	40385e <hsmci_read_word+0x5e>
  403858:	e019      	b.n	40388e <hsmci_read_word+0x8e>
			hsmci_debug("%s: DMA sr 0x%08x error\n\r",
					__func__, sr);
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
  40385a:	0113      	lsls	r3, r2, #4
  40385c:	d417      	bmi.n	40388e <hsmci_read_word+0x8e>
	}

	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI
	do {
		sr = HSMCI->HSMCI_SR;
  40385e:	6c0a      	ldr	r2, [r1, #64]	; 0x40
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  403860:	4b0c      	ldr	r3, [pc, #48]	; (403894 <hsmci_read_word+0x94>)
  403862:	4013      	ands	r3, r2
	}

	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI
	do {
		sr = HSMCI->HSMCI_SR;
  403864:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  403868:	2b00      	cmp	r3, #0
  40386a:	d0f6      	beq.n	40385a <hsmci_read_word+0x5a>
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  40386c:	6867      	ldr	r7, [r4, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  40386e:	68a6      	ldr	r6, [r4, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  403870:	68e5      	ldr	r5, [r4, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  403872:	69e1      	ldr	r1, [r4, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  403874:	6d62      	ldr	r2, [r4, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  403876:	2080      	movs	r0, #128	; 0x80
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  403878:	2305      	movs	r3, #5
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  40387a:	6020      	str	r0, [r4, #0]
	HSMCI->HSMCI_MR = mr;
  40387c:	6067      	str	r7, [r4, #4]
	HSMCI->HSMCI_DTOR = dtor;
  40387e:	60a6      	str	r6, [r4, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  403880:	60e5      	str	r5, [r4, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  403882:	61e1      	str	r1, [r4, #28]
	HSMCI->HSMCI_CFG = cfg;
  403884:	6562      	str	r2, [r4, #84]	; 0x54
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  403886:	6023      	str	r3, [r4, #0]
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: DMA sr 0x%08x error\n\r",
					__func__, sr);
			hsmci_reset();
			return false;
  403888:	2000      	movs	r0, #0
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
	return true;
}
  40388a:	bcf0      	pop	{r4, r5, r6, r7}
  40388c:	4770      	bx	lr

	// Read data
	*value = HSMCI->HSMCI_RDR;
	hsmci_transfert_pos += 4;
	if (((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos) {
		return true;
  40388e:	2001      	movs	r0, #1
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
	return true;
}
  403890:	bcf0      	pop	{r4, r5, r6, r7}
  403892:	4770      	bx	lr
  403894:	c0600000 	.word	0xc0600000
  403898:	20003390 	.word	0x20003390
  40389c:	2000338c 	.word	0x2000338c
  4038a0:	2000338e 	.word	0x2000338e

004038a4 <hsmci_start_read_blocks>:
}
#endif // HSMCI_SR_DMADONE

#ifdef HSMCI_MR_PDCMODE
bool hsmci_start_read_blocks(void *dest, uint16_t nb_block)
{
  4038a4:	b430      	push	{r4, r5}
	uint32_t nb_data;

	nb_data = nb_block * hsmci_block_size;
  4038a6:	4b17      	ldr	r3, [pc, #92]	; (403904 <hsmci_start_read_blocks+0x60>)
  4038a8:	881b      	ldrh	r3, [r3, #0]
	Assert(nb_data <= (((uint32_t)hsmci_block_size * hsmci_nb_block) - hsmci_transfert_pos));
	Assert(nb_data <= (PERIPH_RCR_RXCTR_Msk >> PERIPH_RCR_RXCTR_Pos));

	// Handle unaligned memory address
	if (((uint32_t)dest & 0x3) || (hsmci_block_size & 0x3)) {
  4038aa:	0784      	lsls	r4, r0, #30
#ifdef HSMCI_MR_PDCMODE
bool hsmci_start_read_blocks(void *dest, uint16_t nb_block)
{
	uint32_t nb_data;

	nb_data = nb_block * hsmci_block_size;
  4038ac:	fb03 f101 	mul.w	r1, r3, r1
	Assert(nb_data <= (((uint32_t)hsmci_block_size * hsmci_nb_block) - hsmci_transfert_pos));
	Assert(nb_data <= (PERIPH_RCR_RXCTR_Msk >> PERIPH_RCR_RXCTR_Pos));

	// Handle unaligned memory address
	if (((uint32_t)dest & 0x3) || (hsmci_block_size & 0x3)) {
  4038b0:	d101      	bne.n	4038b6 <hsmci_start_read_blocks+0x12>
  4038b2:	079a      	lsls	r2, r3, #30
  4038b4:	d01e      	beq.n	4038f4 <hsmci_start_read_blocks+0x50>
		HSMCI->HSMCI_MR |= HSMCI_MR_FBYTE;
  4038b6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  4038ba:	685a      	ldr	r2, [r3, #4]
  4038bc:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
  4038c0:	605a      	str	r2, [r3, #4]
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
	}

	// Configure PDC transfer
	HSMCI->HSMCI_RPR = (uint32_t)dest;
  4038c2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
	HSMCI->HSMCI_RCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
			nb_data : nb_data / 4;
	HSMCI->HSMCI_RNCR = 0;
  4038c6:	2400      	movs	r4, #0
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
	}

	// Configure PDC transfer
	HSMCI->HSMCI_RPR = (uint32_t)dest;
  4038c8:	f8c3 0100 	str.w	r0, [r3, #256]	; 0x100
	HSMCI->HSMCI_RCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  4038cc:	685b      	ldr	r3, [r3, #4]
			nb_data : nb_data / 4;
	HSMCI->HSMCI_RNCR = 0;
	// Start transfer
	HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTEN;
	hsmci_transfert_pos += nb_data;
  4038ce:	4a0e      	ldr	r2, [pc, #56]	; (403908 <hsmci_start_read_blocks+0x64>)
	}

	// Configure PDC transfer
	HSMCI->HSMCI_RPR = (uint32_t)dest;
	HSMCI->HSMCI_RCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
			nb_data : nb_data / 4;
  4038d0:	049b      	lsls	r3, r3, #18
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
	}

	// Configure PDC transfer
	HSMCI->HSMCI_RPR = (uint32_t)dest;
	HSMCI->HSMCI_RCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  4038d2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
			nb_data : nb_data / 4;
  4038d6:	bf54      	ite	pl
  4038d8:	088d      	lsrpl	r5, r1, #2
  4038da:	460d      	movmi	r5, r1
	HSMCI->HSMCI_RNCR = 0;
	// Start transfer
	HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTEN;
  4038dc:	2001      	movs	r0, #1
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
	}

	// Configure PDC transfer
	HSMCI->HSMCI_RPR = (uint32_t)dest;
	HSMCI->HSMCI_RCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  4038de:	f8c3 5104 	str.w	r5, [r3, #260]	; 0x104
			nb_data : nb_data / 4;
	HSMCI->HSMCI_RNCR = 0;
  4038e2:	f8c3 4114 	str.w	r4, [r3, #276]	; 0x114
	// Start transfer
	HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTEN;
  4038e6:	f8c3 0120 	str.w	r0, [r3, #288]	; 0x120
	hsmci_transfert_pos += nb_data;
  4038ea:	6813      	ldr	r3, [r2, #0]
  4038ec:	4419      	add	r1, r3
  4038ee:	6011      	str	r1, [r2, #0]
	return true;
}
  4038f0:	bc30      	pop	{r4, r5}
  4038f2:	4770      	bx	lr

	// Handle unaligned memory address
	if (((uint32_t)dest & 0x3) || (hsmci_block_size & 0x3)) {
		HSMCI->HSMCI_MR |= HSMCI_MR_FBYTE;
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
  4038f4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  4038f8:	685a      	ldr	r2, [r3, #4]
  4038fa:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
  4038fe:	605a      	str	r2, [r3, #4]
  403900:	e7df      	b.n	4038c2 <hsmci_start_read_blocks+0x1e>
  403902:	bf00      	nop
  403904:	2000338c 	.word	0x2000338c
  403908:	20003390 	.word	0x20003390

0040390c <hsmci_wait_end_of_read_blocks>:
	hsmci_transfert_pos += nb_data;
	return true;
}

bool hsmci_wait_end_of_read_blocks(void)
{
  40390c:	b4f0      	push	{r4, r5, r6, r7}
	uint32_t sr;
	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  40390e:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
  403912:	e001      	b.n	403918 <hsmci_wait_end_of_read_blocks+0xc>
			HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTDIS | HSMCI_PTCR_TXTDIS;
			hsmci_reset();
			return false;
		}

	} while (!(sr & HSMCI_SR_RXBUFF));
  403914:	0452      	lsls	r2, r2, #17
  403916:	d41b      	bmi.n	403950 <hsmci_wait_end_of_read_blocks+0x44>
{
	uint32_t sr;
	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  403918:	6c02      	ldr	r2, [r0, #64]	; 0x40
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  40391a:	4b21      	ldr	r3, [pc, #132]	; (4039a0 <hsmci_wait_end_of_read_blocks+0x94>)
  40391c:	4013      	ands	r3, r2
{
	uint32_t sr;
	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  40391e:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  403922:	2b00      	cmp	r3, #0
  403924:	d0f6      	beq.n	403914 <hsmci_wait_end_of_read_blocks+0x8>
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: PDC sr 0x%08x error\n\r",
					__func__, sr);
			HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTDIS | HSMCI_PTCR_TXTDIS;
  403926:	f240 2302 	movw	r3, #514	; 0x202
  40392a:	f8c1 3120 	str.w	r3, [r1, #288]	; 0x120
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  40392e:	684f      	ldr	r7, [r1, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  403930:	688e      	ldr	r6, [r1, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  403932:	68cd      	ldr	r5, [r1, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  403934:	69cc      	ldr	r4, [r1, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  403936:	6d4a      	ldr	r2, [r1, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  403938:	2080      	movs	r0, #128	; 0x80
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  40393a:	2305      	movs	r3, #5
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  40393c:	6008      	str	r0, [r1, #0]
	HSMCI->HSMCI_MR = mr;
  40393e:	604f      	str	r7, [r1, #4]
	HSMCI->HSMCI_DTOR = dtor;
  403940:	608e      	str	r6, [r1, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  403942:	60cd      	str	r5, [r1, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  403944:	61cc      	str	r4, [r1, #28]
	HSMCI->HSMCI_CFG = cfg;
  403946:	654a      	str	r2, [r1, #84]	; 0x54
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  403948:	600b      	str	r3, [r1, #0]
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: PDC sr 0x%08x error\n\r",
					__func__, sr);
			HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTDIS | HSMCI_PTCR_TXTDIS;
			hsmci_reset();
			return false;
  40394a:	2000      	movs	r0, #0
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
	return true;
}
  40394c:	bcf0      	pop	{r4, r5, r6, r7}
  40394e:	4770      	bx	lr
			return false;
		}

	} while (!(sr & HSMCI_SR_RXBUFF));

	if (hsmci_transfert_pos < ((uint32_t)hsmci_block_size * hsmci_nb_block)) {
  403950:	4a14      	ldr	r2, [pc, #80]	; (4039a4 <hsmci_wait_end_of_read_blocks+0x98>)
  403952:	4815      	ldr	r0, [pc, #84]	; (4039a8 <hsmci_wait_end_of_read_blocks+0x9c>)
  403954:	4b15      	ldr	r3, [pc, #84]	; (4039ac <hsmci_wait_end_of_read_blocks+0xa0>)
  403956:	8812      	ldrh	r2, [r2, #0]
  403958:	8800      	ldrh	r0, [r0, #0]
  40395a:	681b      	ldr	r3, [r3, #0]
  40395c:	fb00 f202 	mul.w	r2, r0, r2
  403960:	429a      	cmp	r2, r3
  403962:	d902      	bls.n	40396a <hsmci_wait_end_of_read_blocks+0x5e>
  403964:	e019      	b.n	40399a <hsmci_wait_end_of_read_blocks+0x8e>
			hsmci_debug("%s: PDC sr 0x%08x last transfer error\n\r",
					__func__, sr);
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
  403966:	0113      	lsls	r3, r2, #4
  403968:	d417      	bmi.n	40399a <hsmci_wait_end_of_read_blocks+0x8e>
		return true;
	}
	// It is the last transfer, then wait command completed
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  40396a:	6c0a      	ldr	r2, [r1, #64]	; 0x40
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  40396c:	4b0c      	ldr	r3, [pc, #48]	; (4039a0 <hsmci_wait_end_of_read_blocks+0x94>)
  40396e:	4013      	ands	r3, r2
		return true;
	}
	// It is the last transfer, then wait command completed
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  403970:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  403974:	2b00      	cmp	r3, #0
  403976:	d0f6      	beq.n	403966 <hsmci_wait_end_of_read_blocks+0x5a>
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  403978:	6867      	ldr	r7, [r4, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  40397a:	68a6      	ldr	r6, [r4, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  40397c:	68e5      	ldr	r5, [r4, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  40397e:	69e1      	ldr	r1, [r4, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  403980:	6d62      	ldr	r2, [r4, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  403982:	2080      	movs	r0, #128	; 0x80
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  403984:	2305      	movs	r3, #5
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  403986:	6020      	str	r0, [r4, #0]
	HSMCI->HSMCI_MR = mr;
  403988:	6067      	str	r7, [r4, #4]
	HSMCI->HSMCI_DTOR = dtor;
  40398a:	60a6      	str	r6, [r4, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  40398c:	60e5      	str	r5, [r4, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  40398e:	61e1      	str	r1, [r4, #28]
	HSMCI->HSMCI_CFG = cfg;
  403990:	6562      	str	r2, [r4, #84]	; 0x54
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  403992:	6023      	str	r3, [r4, #0]
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: PDC sr 0x%08x last transfer error\n\r",
					__func__, sr);
			hsmci_reset();
			return false;
  403994:	2000      	movs	r0, #0
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
	return true;
}
  403996:	bcf0      	pop	{r4, r5, r6, r7}
  403998:	4770      	bx	lr
		}

	} while (!(sr & HSMCI_SR_RXBUFF));

	if (hsmci_transfert_pos < ((uint32_t)hsmci_block_size * hsmci_nb_block)) {
		return true;
  40399a:	2001      	movs	r0, #1
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
	return true;
}
  40399c:	bcf0      	pop	{r4, r5, r6, r7}
  40399e:	4770      	bx	lr
  4039a0:	c0600000 	.word	0xc0600000
  4039a4:	2000338e 	.word	0x2000338e
  4039a8:	2000338c 	.word	0x2000338c
  4039ac:	20003390 	.word	0x20003390

004039b0 <hsmci_start_write_blocks>:

bool hsmci_start_write_blocks(const void *src, uint16_t nb_block)
{
  4039b0:	b430      	push	{r4, r5}
	uint32_t nb_data;

	nb_data = nb_block * hsmci_block_size;
  4039b2:	4b18      	ldr	r3, [pc, #96]	; (403a14 <hsmci_start_write_blocks+0x64>)
  4039b4:	881b      	ldrh	r3, [r3, #0]
	Assert(nb_data <= (((uint32_t)hsmci_block_size * hsmci_nb_block) - hsmci_transfert_pos));
	Assert(nb_data <= (PERIPH_TCR_TXCTR_Msk >> PERIPH_TCR_TXCTR_Pos));

	// Handle unaligned memory address
	if (((uint32_t)src & 0x3) || (hsmci_block_size & 0x3)) {
  4039b6:	0784      	lsls	r4, r0, #30

bool hsmci_start_write_blocks(const void *src, uint16_t nb_block)
{
	uint32_t nb_data;

	nb_data = nb_block * hsmci_block_size;
  4039b8:	fb03 f101 	mul.w	r1, r3, r1
	Assert(nb_data <= (((uint32_t)hsmci_block_size * hsmci_nb_block) - hsmci_transfert_pos));
	Assert(nb_data <= (PERIPH_TCR_TXCTR_Msk >> PERIPH_TCR_TXCTR_Pos));

	// Handle unaligned memory address
	if (((uint32_t)src & 0x3) || (hsmci_block_size & 0x3)) {
  4039bc:	d101      	bne.n	4039c2 <hsmci_start_write_blocks+0x12>
  4039be:	079a      	lsls	r2, r3, #30
  4039c0:	d020      	beq.n	403a04 <hsmci_start_write_blocks+0x54>
		HSMCI->HSMCI_MR |= HSMCI_MR_FBYTE;
  4039c2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  4039c6:	685a      	ldr	r2, [r3, #4]
  4039c8:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
  4039cc:	605a      	str	r2, [r3, #4]
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
	}

	// Configure PDC transfer
	HSMCI->HSMCI_TPR = (uint32_t)src;
  4039ce:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
	HSMCI->HSMCI_TCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
			nb_data : nb_data / 4;
	HSMCI->HSMCI_TNCR = 0;
  4039d2:	2400      	movs	r4, #0
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
	}

	// Configure PDC transfer
	HSMCI->HSMCI_TPR = (uint32_t)src;
  4039d4:	f8c3 0108 	str.w	r0, [r3, #264]	; 0x108
	HSMCI->HSMCI_TCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  4039d8:	685b      	ldr	r3, [r3, #4]
			nb_data : nb_data / 4;
	HSMCI->HSMCI_TNCR = 0;
	// Start transfer
	HSMCI->HSMCI_PTCR = HSMCI_PTCR_TXTEN;
	hsmci_transfert_pos += nb_data;
  4039da:	4a0f      	ldr	r2, [pc, #60]	; (403a18 <hsmci_start_write_blocks+0x68>)
	}

	// Configure PDC transfer
	HSMCI->HSMCI_TPR = (uint32_t)src;
	HSMCI->HSMCI_TCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
			nb_data : nb_data / 4;
  4039dc:	049b      	lsls	r3, r3, #18
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
	}

	// Configure PDC transfer
	HSMCI->HSMCI_TPR = (uint32_t)src;
	HSMCI->HSMCI_TCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  4039de:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
			nb_data : nb_data / 4;
  4039e2:	bf54      	ite	pl
  4039e4:	088d      	lsrpl	r5, r1, #2
  4039e6:	460d      	movmi	r5, r1
	HSMCI->HSMCI_TNCR = 0;
	// Start transfer
	HSMCI->HSMCI_PTCR = HSMCI_PTCR_TXTEN;
  4039e8:	f44f 7080 	mov.w	r0, #256	; 0x100
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
	}

	// Configure PDC transfer
	HSMCI->HSMCI_TPR = (uint32_t)src;
	HSMCI->HSMCI_TCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  4039ec:	f8c3 510c 	str.w	r5, [r3, #268]	; 0x10c
			nb_data : nb_data / 4;
	HSMCI->HSMCI_TNCR = 0;
  4039f0:	f8c3 411c 	str.w	r4, [r3, #284]	; 0x11c
	// Start transfer
	HSMCI->HSMCI_PTCR = HSMCI_PTCR_TXTEN;
  4039f4:	f8c3 0120 	str.w	r0, [r3, #288]	; 0x120
	hsmci_transfert_pos += nb_data;
  4039f8:	6813      	ldr	r3, [r2, #0]
  4039fa:	4419      	add	r1, r3
  4039fc:	6011      	str	r1, [r2, #0]
	return true;
}
  4039fe:	2001      	movs	r0, #1
  403a00:	bc30      	pop	{r4, r5}
  403a02:	4770      	bx	lr

	// Handle unaligned memory address
	if (((uint32_t)src & 0x3) || (hsmci_block_size & 0x3)) {
		HSMCI->HSMCI_MR |= HSMCI_MR_FBYTE;
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
  403a04:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  403a08:	685a      	ldr	r2, [r3, #4]
  403a0a:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
  403a0e:	605a      	str	r2, [r3, #4]
  403a10:	e7dd      	b.n	4039ce <hsmci_start_write_blocks+0x1e>
  403a12:	bf00      	nop
  403a14:	2000338c 	.word	0x2000338c
  403a18:	20003390 	.word	0x20003390

00403a1c <hsmci_wait_end_of_write_blocks>:
	hsmci_transfert_pos += nb_data;
	return true;
}

bool hsmci_wait_end_of_write_blocks(void)
{
  403a1c:	b4f0      	push	{r4, r5, r6, r7}
	uint32_t sr;

	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  403a1e:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
  403a22:	e001      	b.n	403a28 <hsmci_wait_end_of_write_blocks+0xc>
					__func__, sr);
			hsmci_reset();
			HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTDIS | HSMCI_PTCR_TXTDIS;
			return false;
		}
	} while (!(sr & HSMCI_SR_TXBUFE));
  403a24:	0412      	lsls	r2, r2, #16
  403a26:	d41d      	bmi.n	403a64 <hsmci_wait_end_of_write_blocks+0x48>
	uint32_t sr;

	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  403a28:	6c02      	ldr	r2, [r0, #64]	; 0x40
		if (sr &
  403a2a:	4b22      	ldr	r3, [pc, #136]	; (403ab4 <hsmci_wait_end_of_write_blocks+0x98>)
  403a2c:	4013      	ands	r3, r2
	uint32_t sr;

	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  403a2e:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
		if (sr &
  403a32:	2b00      	cmp	r3, #0
  403a34:	d0f6      	beq.n	403a24 <hsmci_wait_end_of_write_blocks+0x8>
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  403a36:	f8d1 c004 	ldr.w	ip, [r1, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  403a3a:	688f      	ldr	r7, [r1, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  403a3c:	68ce      	ldr	r6, [r1, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  403a3e:	69cd      	ldr	r5, [r1, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  403a40:	6d4c      	ldr	r4, [r1, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  403a42:	2080      	movs	r0, #128	; 0x80
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  403a44:	2205      	movs	r2, #5
				(HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: PDC sr 0x%08x error\n\r",
					__func__, sr);
			hsmci_reset();
			HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTDIS | HSMCI_PTCR_TXTDIS;
  403a46:	f240 2302 	movw	r3, #514	; 0x202
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  403a4a:	6008      	str	r0, [r1, #0]
	HSMCI->HSMCI_MR = mr;
  403a4c:	f8c1 c004 	str.w	ip, [r1, #4]
	HSMCI->HSMCI_DTOR = dtor;
  403a50:	608f      	str	r7, [r1, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  403a52:	60ce      	str	r6, [r1, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  403a54:	61cd      	str	r5, [r1, #28]
	HSMCI->HSMCI_CFG = cfg;
  403a56:	654c      	str	r4, [r1, #84]	; 0x54
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  403a58:	600a      	str	r2, [r1, #0]
				(HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: PDC sr 0x%08x error\n\r",
					__func__, sr);
			hsmci_reset();
			HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTDIS | HSMCI_PTCR_TXTDIS;
  403a5a:	f8c1 3120 	str.w	r3, [r1, #288]	; 0x120
			return false;
  403a5e:	2000      	movs	r0, #0
			return false;
		}
	} while (!(sr & HSMCI_SR_NOTBUSY));
	Assert(HSMCI->HSMCI_SR & HSMCI_SR_FIFOEMPTY);
	return true;
}
  403a60:	bcf0      	pop	{r4, r5, r6, r7}
  403a62:	4770      	bx	lr
			return false;
		}
	} while (!(sr & HSMCI_SR_TXBUFE));


	if (hsmci_transfert_pos < ((uint32_t)hsmci_block_size * hsmci_nb_block)) {
  403a64:	4a14      	ldr	r2, [pc, #80]	; (403ab8 <hsmci_wait_end_of_write_blocks+0x9c>)
  403a66:	4815      	ldr	r0, [pc, #84]	; (403abc <hsmci_wait_end_of_write_blocks+0xa0>)
  403a68:	4b15      	ldr	r3, [pc, #84]	; (403ac0 <hsmci_wait_end_of_write_blocks+0xa4>)
  403a6a:	8812      	ldrh	r2, [r2, #0]
  403a6c:	8800      	ldrh	r0, [r0, #0]
  403a6e:	681b      	ldr	r3, [r3, #0]
  403a70:	fb00 f202 	mul.w	r2, r0, r2
  403a74:	429a      	cmp	r2, r3
  403a76:	d902      	bls.n	403a7e <hsmci_wait_end_of_write_blocks+0x62>
  403a78:	e019      	b.n	403aae <hsmci_wait_end_of_write_blocks+0x92>
			hsmci_debug("%s: PDC sr 0x%08x last transfer error\n\r",
					__func__, sr);
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_NOTBUSY));
  403a7a:	0693      	lsls	r3, r2, #26
  403a7c:	d417      	bmi.n	403aae <hsmci_wait_end_of_write_blocks+0x92>
		return true;
	}
	// It is the last transfer, then wait command completed
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  403a7e:	6c0a      	ldr	r2, [r1, #64]	; 0x40
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  403a80:	4b0c      	ldr	r3, [pc, #48]	; (403ab4 <hsmci_wait_end_of_write_blocks+0x98>)
  403a82:	4013      	ands	r3, r2
		return true;
	}
	// It is the last transfer, then wait command completed
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  403a84:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  403a88:	2b00      	cmp	r3, #0
  403a8a:	d0f6      	beq.n	403a7a <hsmci_wait_end_of_write_blocks+0x5e>
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  403a8c:	6867      	ldr	r7, [r4, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  403a8e:	68a6      	ldr	r6, [r4, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  403a90:	68e5      	ldr	r5, [r4, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  403a92:	69e1      	ldr	r1, [r4, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  403a94:	6d62      	ldr	r2, [r4, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  403a96:	2080      	movs	r0, #128	; 0x80
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  403a98:	2305      	movs	r3, #5
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  403a9a:	6020      	str	r0, [r4, #0]
	HSMCI->HSMCI_MR = mr;
  403a9c:	6067      	str	r7, [r4, #4]
	HSMCI->HSMCI_DTOR = dtor;
  403a9e:	60a6      	str	r6, [r4, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  403aa0:	60e5      	str	r5, [r4, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  403aa2:	61e1      	str	r1, [r4, #28]
	HSMCI->HSMCI_CFG = cfg;
  403aa4:	6562      	str	r2, [r4, #84]	; 0x54
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  403aa6:	6023      	str	r3, [r4, #0]
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: PDC sr 0x%08x last transfer error\n\r",
					__func__, sr);
			hsmci_reset();
			return false;
  403aa8:	2000      	movs	r0, #0
		}
	} while (!(sr & HSMCI_SR_NOTBUSY));
	Assert(HSMCI->HSMCI_SR & HSMCI_SR_FIFOEMPTY);
	return true;
}
  403aaa:	bcf0      	pop	{r4, r5, r6, r7}
  403aac:	4770      	bx	lr
		}
	} while (!(sr & HSMCI_SR_TXBUFE));


	if (hsmci_transfert_pos < ((uint32_t)hsmci_block_size * hsmci_nb_block)) {
		return true;
  403aae:	2001      	movs	r0, #1
			return false;
		}
	} while (!(sr & HSMCI_SR_NOTBUSY));
	Assert(HSMCI->HSMCI_SR & HSMCI_SR_FIFOEMPTY);
	return true;
}
  403ab0:	bcf0      	pop	{r4, r5, r6, r7}
  403ab2:	4770      	bx	lr
  403ab4:	c0600000 	.word	0xc0600000
  403ab8:	2000338e 	.word	0x2000338e
  403abc:	2000338c 	.word	0x2000338c
  403ac0:	20003390 	.word	0x20003390

00403ac4 <pdc_disable_transfer>:
{
	/* Validate inputs. */
	Assert(p_pdc);
	
	p_pdc->PERIPH_PTCR =
			ul_controls & (PERIPH_PTCR_RXTDIS | PERIPH_PTCR_TXTDIS);
  403ac4:	f240 2302 	movw	r3, #514	; 0x202
  403ac8:	4019      	ands	r1, r3
		uint32_t ul_controls)
{
	/* Validate inputs. */
	Assert(p_pdc);
	
	p_pdc->PERIPH_PTCR =
  403aca:	6201      	str	r1, [r0, #32]
  403acc:	4770      	bx	lr
  403ace:	bf00      	nop

00403ad0 <rtc_set_hour_mode>:
 * \param ul_mode 1 for 12-hour mode, 0 for 24-hour mode.
 */
void rtc_set_hour_mode(Rtc *p_rtc, uint32_t ul_mode)
{
	if (ul_mode) {
		p_rtc->RTC_MR |= RTC_MR_HRMOD;
  403ad0:	6843      	ldr	r3, [r0, #4]
 * \param p_rtc Pointer to an RTC instance.
 * \param ul_mode 1 for 12-hour mode, 0 for 24-hour mode.
 */
void rtc_set_hour_mode(Rtc *p_rtc, uint32_t ul_mode)
{
	if (ul_mode) {
  403ad2:	b919      	cbnz	r1, 403adc <rtc_set_hour_mode+0xc>
		p_rtc->RTC_MR |= RTC_MR_HRMOD;
	} else {
		p_rtc->RTC_MR &= (~RTC_MR_HRMOD);
  403ad4:	f023 0301 	bic.w	r3, r3, #1
  403ad8:	6043      	str	r3, [r0, #4]
  403ada:	4770      	bx	lr
 * \param ul_mode 1 for 12-hour mode, 0 for 24-hour mode.
 */
void rtc_set_hour_mode(Rtc *p_rtc, uint32_t ul_mode)
{
	if (ul_mode) {
		p_rtc->RTC_MR |= RTC_MR_HRMOD;
  403adc:	f043 0301 	orr.w	r3, r3, #1
  403ae0:	6043      	str	r3, [r0, #4]
  403ae2:	4770      	bx	lr

00403ae4 <rtc_get_time>:
 * \param pul_minute Current minute.
 * \param pul_second Current second.
 */
void rtc_get_time(Rtc *p_rtc, uint32_t *pul_hour, uint32_t *pul_minute,
		uint32_t *pul_second)
{
  403ae4:	b430      	push	{r4, r5}
	uint32_t ul_time;
	uint32_t ul_temp;

	/* Get the current RTC time (multiple reads are necessary to insure a stable value). */
	ul_time = p_rtc->RTC_TIMR;
  403ae6:	6884      	ldr	r4, [r0, #8]
	while (ul_time != p_rtc->RTC_TIMR) {
  403ae8:	6885      	ldr	r5, [r0, #8]
  403aea:	42ac      	cmp	r4, r5
  403aec:	d003      	beq.n	403af6 <rtc_get_time+0x12>
		ul_time = p_rtc->RTC_TIMR;
  403aee:	6884      	ldr	r4, [r0, #8]
	uint32_t ul_time;
	uint32_t ul_temp;

	/* Get the current RTC time (multiple reads are necessary to insure a stable value). */
	ul_time = p_rtc->RTC_TIMR;
	while (ul_time != p_rtc->RTC_TIMR) {
  403af0:	6885      	ldr	r5, [r0, #8]
  403af2:	42a5      	cmp	r5, r4
  403af4:	d1fb      	bne.n	403aee <rtc_get_time+0xa>
		ul_time = p_rtc->RTC_TIMR;
	}

	/* Hour */
	if (pul_hour) {
  403af6:	b161      	cbz	r1, 403b12 <rtc_get_time+0x2e>
		ul_temp = (ul_time & RTC_TIMR_HOUR_Msk) >> RTC_TIMR_HOUR_Pos;
  403af8:	f404 107c 	and.w	r0, r4, #4128768	; 0x3f0000
		*pul_hour = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  403afc:	0d05      	lsrs	r5, r0, #20
  403afe:	eb05 0585 	add.w	r5, r5, r5, lsl #2
  403b02:	f3c0 4003 	ubfx	r0, r0, #16, #4
  403b06:	eb00 0045 	add.w	r0, r0, r5, lsl #1

		if ((ul_time & RTC_TIMR_AMPM) == RTC_TIMR_AMPM) {
  403b0a:	0265      	lsls	r5, r4, #9
			*pul_hour += 12;
  403b0c:	bf48      	it	mi
  403b0e:	300c      	addmi	r0, #12
  403b10:	6008      	str	r0, [r1, #0]
		}
	}

	/* Minute */
	if (pul_minute) {
  403b12:	b14a      	cbz	r2, 403b28 <rtc_get_time+0x44>
		ul_temp = (ul_time & RTC_TIMR_MIN_Msk) >> RTC_TIMR_MIN_Pos;
  403b14:	f404 41fe 	and.w	r1, r4, #32512	; 0x7f00
		*pul_minute = (ul_temp >> BCD_SHIFT) * BCD_FACTOR +  (ul_temp & BCD_MASK);
  403b18:	0b08      	lsrs	r0, r1, #12
  403b1a:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  403b1e:	f3c1 2103 	ubfx	r1, r1, #8, #4
  403b22:	eb01 0140 	add.w	r1, r1, r0, lsl #1
  403b26:	6011      	str	r1, [r2, #0]
	}

	/* Second */
	if (pul_second) {
  403b28:	b143      	cbz	r3, 403b3c <rtc_get_time+0x58>
		ul_temp = (ul_time & RTC_TIMR_SEC_Msk) >> RTC_TIMR_SEC_Pos;
		*pul_second = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  403b2a:	f3c4 1202 	ubfx	r2, r4, #4, #3
  403b2e:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  403b32:	f004 040f 	and.w	r4, r4, #15
  403b36:	eb04 0242 	add.w	r2, r4, r2, lsl #1
  403b3a:	601a      	str	r2, [r3, #0]
	}
}
  403b3c:	bc30      	pop	{r4, r5}
  403b3e:	4770      	bx	lr

00403b40 <rtc_set_time>:
 *
 * \return 0 for OK, else invalid setting.
 */
uint32_t rtc_set_time(Rtc *p_rtc, uint32_t ul_hour, uint32_t ul_minute,
		uint32_t ul_second)
{
  403b40:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}
	uint32_t ul_time = 0;

	/* If 12-hour mode, set AMPM bit */
	if ((p_rtc->RTC_MR & RTC_MR_HRMOD) == RTC_MR_HRMOD) {
  403b44:	6844      	ldr	r4, [r0, #4]
  403b46:	f014 0c01 	ands.w	ip, r4, #1
  403b4a:	d006      	beq.n	403b5a <rtc_set_time+0x1a>
		if (ul_hour > 12) {
  403b4c:	290c      	cmp	r1, #12
			ul_hour -= 12;
  403b4e:	bf86      	itte	hi
  403b50:	390c      	subhi	r1, #12
			ul_time |= RTC_TIMR_AMPM;
  403b52:	f44f 0c80 	movhi.w	ip, #4194304	; 0x400000
 * \return 0 for OK, else invalid setting.
 */
uint32_t rtc_set_time(Rtc *p_rtc, uint32_t ul_hour, uint32_t ul_minute,
		uint32_t ul_second)
{
	uint32_t ul_time = 0;
  403b56:	f04f 0c00 	movls.w	ip, #0
	/* Minute */
	ul_time |= ((ul_minute / BCD_FACTOR) << (RTC_TIMR_MIN_Pos + BCD_SHIFT)) |
			((ul_minute % BCD_FACTOR) << RTC_TIMR_MIN_Pos);

	/* Second */
	ul_time |= ((ul_second / BCD_FACTOR) << (RTC_TIMR_SEC_Pos + BCD_SHIFT)) |
  403b5a:	4c1d      	ldr	r4, [pc, #116]	; (403bd0 <rtc_set_time+0x90>)
			((ul_second % BCD_FACTOR) << RTC_TIMR_SEC_Pos);

	/* Update time register. Check the spec for the flow. */
	p_rtc->RTC_CR |= RTC_CR_UPDTIM;
  403b5c:	6807      	ldr	r7, [r0, #0]
	/* Minute */
	ul_time |= ((ul_minute / BCD_FACTOR) << (RTC_TIMR_MIN_Pos + BCD_SHIFT)) |
			((ul_minute % BCD_FACTOR) << RTC_TIMR_MIN_Pos);

	/* Second */
	ul_time |= ((ul_second / BCD_FACTOR) << (RTC_TIMR_SEC_Pos + BCD_SHIFT)) |
  403b5e:	fba4 5603 	umull	r5, r6, r4, r3
  403b62:	08f6      	lsrs	r6, r6, #3
			((ul_second % BCD_FACTOR) << RTC_TIMR_SEC_Pos);
  403b64:	eb06 0886 	add.w	r8, r6, r6, lsl #2
	/* Hour */
	ul_time |= ((ul_hour / BCD_FACTOR) << (RTC_TIMR_HOUR_Pos + BCD_SHIFT)) |
			((ul_hour % BCD_FACTOR) << RTC_TIMR_HOUR_Pos);

	/* Minute */
	ul_time |= ((ul_minute / BCD_FACTOR) << (RTC_TIMR_MIN_Pos + BCD_SHIFT)) |
  403b68:	fba4 9502 	umull	r9, r5, r4, r2
			((ul_minute % BCD_FACTOR) << RTC_TIMR_MIN_Pos);

	/* Second */
	ul_time |= ((ul_second / BCD_FACTOR) << (RTC_TIMR_SEC_Pos + BCD_SHIFT)) |
			((ul_second % BCD_FACTOR) << RTC_TIMR_SEC_Pos);
  403b6c:	eba3 0348 	sub.w	r3, r3, r8, lsl #1
	/* Hour */
	ul_time |= ((ul_hour / BCD_FACTOR) << (RTC_TIMR_HOUR_Pos + BCD_SHIFT)) |
			((ul_hour % BCD_FACTOR) << RTC_TIMR_HOUR_Pos);

	/* Minute */
	ul_time |= ((ul_minute / BCD_FACTOR) << (RTC_TIMR_MIN_Pos + BCD_SHIFT)) |
  403b70:	08ed      	lsrs	r5, r5, #3
			((ul_minute % BCD_FACTOR) << RTC_TIMR_MIN_Pos);

	/* Second */
	ul_time |= ((ul_second / BCD_FACTOR) << (RTC_TIMR_SEC_Pos + BCD_SHIFT)) |
  403b72:	ea43 1606 	orr.w	r6, r3, r6, lsl #4
	ul_time |= ((ul_hour / BCD_FACTOR) << (RTC_TIMR_HOUR_Pos + BCD_SHIFT)) |
			((ul_hour % BCD_FACTOR) << RTC_TIMR_HOUR_Pos);

	/* Minute */
	ul_time |= ((ul_minute / BCD_FACTOR) << (RTC_TIMR_MIN_Pos + BCD_SHIFT)) |
			((ul_minute % BCD_FACTOR) << RTC_TIMR_MIN_Pos);
  403b76:	eb05 0885 	add.w	r8, r5, r5, lsl #2
  403b7a:	eba2 0248 	sub.w	r2, r2, r8, lsl #1
			ul_time |= RTC_TIMR_AMPM;
		}
	}

	/* Hour */
	ul_time |= ((ul_hour / BCD_FACTOR) << (RTC_TIMR_HOUR_Pos + BCD_SHIFT)) |
  403b7e:	ea46 3505 	orr.w	r5, r6, r5, lsl #12
  403b82:	fba4 6301 	umull	r6, r3, r4, r1
  403b86:	08db      	lsrs	r3, r3, #3
  403b88:	ea45 2502 	orr.w	r5, r5, r2, lsl #8
			((ul_hour % BCD_FACTOR) << RTC_TIMR_HOUR_Pos);

	/* Minute */
	ul_time |= ((ul_minute / BCD_FACTOR) << (RTC_TIMR_MIN_Pos + BCD_SHIFT)) |
  403b8c:	ea45 020c 	orr.w	r2, r5, ip
		}
	}

	/* Hour */
	ul_time |= ((ul_hour / BCD_FACTOR) << (RTC_TIMR_HOUR_Pos + BCD_SHIFT)) |
			((ul_hour % BCD_FACTOR) << RTC_TIMR_HOUR_Pos);
  403b90:	eb03 0683 	add.w	r6, r3, r3, lsl #2
  403b94:	eba1 0146 	sub.w	r1, r1, r6, lsl #1

	/* Minute */
	ul_time |= ((ul_minute / BCD_FACTOR) << (RTC_TIMR_MIN_Pos + BCD_SHIFT)) |
  403b98:	ea42 5303 	orr.w	r3, r2, r3, lsl #20
	/* Second */
	ul_time |= ((ul_second / BCD_FACTOR) << (RTC_TIMR_SEC_Pos + BCD_SHIFT)) |
			((ul_second % BCD_FACTOR) << RTC_TIMR_SEC_Pos);

	/* Update time register. Check the spec for the flow. */
	p_rtc->RTC_CR |= RTC_CR_UPDTIM;
  403b9c:	f047 0201 	orr.w	r2, r7, #1
	/* Minute */
	ul_time |= ((ul_minute / BCD_FACTOR) << (RTC_TIMR_MIN_Pos + BCD_SHIFT)) |
			((ul_minute % BCD_FACTOR) << RTC_TIMR_MIN_Pos);

	/* Second */
	ul_time |= ((ul_second / BCD_FACTOR) << (RTC_TIMR_SEC_Pos + BCD_SHIFT)) |
  403ba0:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
			((ul_second % BCD_FACTOR) << RTC_TIMR_SEC_Pos);

	/* Update time register. Check the spec for the flow. */
	p_rtc->RTC_CR |= RTC_CR_UPDTIM;
  403ba4:	6002      	str	r2, [r0, #0]
	while ((p_rtc->RTC_SR & RTC_SR_ACKUPD) != RTC_SR_ACKUPD);
  403ba6:	6983      	ldr	r3, [r0, #24]
  403ba8:	07db      	lsls	r3, r3, #31
  403baa:	d5fc      	bpl.n	403ba6 <rtc_set_time+0x66>
	p_rtc->RTC_SCCR = RTC_SCCR_ACKCLR;
  403bac:	2301      	movs	r3, #1
  403bae:	61c3      	str	r3, [r0, #28]
	p_rtc->RTC_TIMR = ul_time;
  403bb0:	6081      	str	r1, [r0, #8]
	p_rtc->RTC_CR &= (~RTC_CR_UPDTIM);
  403bb2:	6803      	ldr	r3, [r0, #0]
  403bb4:	f023 0301 	bic.w	r3, r3, #1
  403bb8:	6003      	str	r3, [r0, #0]
	p_rtc->RTC_SCCR |= RTC_SCCR_SECCLR;
  403bba:	69c3      	ldr	r3, [r0, #28]
  403bbc:	f043 0304 	orr.w	r3, r3, #4
  403bc0:	61c3      	str	r3, [r0, #28]

	return (p_rtc->RTC_VER & RTC_VER_NVTIM);
  403bc2:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
}
  403bc4:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
  403bc8:	f000 0001 	and.w	r0, r0, #1
  403bcc:	4770      	bx	lr
  403bce:	bf00      	nop
  403bd0:	cccccccd 	.word	0xcccccccd

00403bd4 <rtc_get_date>:
 * \param pul_day Current day.
 * \param pul_week Current day in current week.
 */
void rtc_get_date(Rtc *p_rtc, uint32_t *pul_year, uint32_t *pul_month,
		uint32_t *pul_day, uint32_t *pul_week)
{
  403bd4:	b4f0      	push	{r4, r5, r6, r7}
	uint32_t ul_date;
	uint32_t ul_cent;
	uint32_t ul_temp;

	/* Get the current date (multiple reads are necessary to insure a stable value). */
	ul_date = p_rtc->RTC_CALR;
  403bd6:	68c4      	ldr	r4, [r0, #12]
	while (ul_date != p_rtc->RTC_CALR) {
  403bd8:	68c5      	ldr	r5, [r0, #12]
 * \param pul_day Current day.
 * \param pul_week Current day in current week.
 */
void rtc_get_date(Rtc *p_rtc, uint32_t *pul_year, uint32_t *pul_month,
		uint32_t *pul_day, uint32_t *pul_week)
{
  403bda:	9e04      	ldr	r6, [sp, #16]
	uint32_t ul_cent;
	uint32_t ul_temp;

	/* Get the current date (multiple reads are necessary to insure a stable value). */
	ul_date = p_rtc->RTC_CALR;
	while (ul_date != p_rtc->RTC_CALR) {
  403bdc:	42ac      	cmp	r4, r5
  403bde:	d003      	beq.n	403be8 <rtc_get_date+0x14>
		ul_date = p_rtc->RTC_CALR;
  403be0:	68c4      	ldr	r4, [r0, #12]
	uint32_t ul_cent;
	uint32_t ul_temp;

	/* Get the current date (multiple reads are necessary to insure a stable value). */
	ul_date = p_rtc->RTC_CALR;
	while (ul_date != p_rtc->RTC_CALR) {
  403be2:	68c5      	ldr	r5, [r0, #12]
  403be4:	42a5      	cmp	r5, r4
  403be6:	d1fb      	bne.n	403be0 <rtc_get_date+0xc>
		ul_date = p_rtc->RTC_CALR;
	}

	/* Retrieve year */
	if (pul_year) {
  403be8:	b1a1      	cbz	r1, 403c14 <rtc_get_date+0x40>
		ul_temp = (ul_date & RTC_CALR_CENT_Msk) >> RTC_CALR_CENT_Pos;
		ul_cent = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
		ul_temp = (ul_date & RTC_CALR_YEAR_Msk) >> RTC_CALR_YEAR_Pos;
  403bea:	f404 457f 	and.w	r5, r4, #65280	; 0xff00
		*pul_year = (ul_cent * BCD_FACTOR * BCD_FACTOR) +
				(ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  403bee:	0b2f      	lsrs	r7, r5, #12
	}

	/* Retrieve year */
	if (pul_year) {
		ul_temp = (ul_date & RTC_CALR_CENT_Msk) >> RTC_CALR_CENT_Pos;
		ul_cent = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  403bf0:	f3c4 1002 	ubfx	r0, r4, #4, #3
		ul_temp = (ul_date & RTC_CALR_YEAR_Msk) >> RTC_CALR_YEAR_Pos;
		*pul_year = (ul_cent * BCD_FACTOR * BCD_FACTOR) +
				(ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  403bf4:	eb07 0c87 	add.w	ip, r7, r7, lsl #2
  403bf8:	f3c5 2503 	ubfx	r5, r5, #8, #4
	}

	/* Retrieve year */
	if (pul_year) {
		ul_temp = (ul_date & RTC_CALR_CENT_Msk) >> RTC_CALR_CENT_Pos;
		ul_cent = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  403bfc:	f004 070f 	and.w	r7, r4, #15
  403c00:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  403c04:	eb07 0040 	add.w	r0, r7, r0, lsl #1
		ul_temp = (ul_date & RTC_CALR_YEAR_Msk) >> RTC_CALR_YEAR_Pos;
		*pul_year = (ul_cent * BCD_FACTOR * BCD_FACTOR) +
  403c08:	eb05 054c 	add.w	r5, r5, ip, lsl #1
  403c0c:	2764      	movs	r7, #100	; 0x64
				(ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  403c0e:	fb07 5000 	mla	r0, r7, r0, r5
	/* Retrieve year */
	if (pul_year) {
		ul_temp = (ul_date & RTC_CALR_CENT_Msk) >> RTC_CALR_CENT_Pos;
		ul_cent = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
		ul_temp = (ul_date & RTC_CALR_YEAR_Msk) >> RTC_CALR_YEAR_Pos;
		*pul_year = (ul_cent * BCD_FACTOR * BCD_FACTOR) +
  403c12:	6008      	str	r0, [r1, #0]
				(ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
	}

	/* Retrieve month */
	if (pul_month) {
  403c14:	b14a      	cbz	r2, 403c2a <rtc_get_date+0x56>
		ul_temp = (ul_date & RTC_CALR_MONTH_Msk) >> RTC_CALR_MONTH_Pos;
  403c16:	f404 10f8 	and.w	r0, r4, #2031616	; 0x1f0000
		*pul_month = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  403c1a:	0d01      	lsrs	r1, r0, #20
  403c1c:	008d      	lsls	r5, r1, #2
  403c1e:	f3c0 4003 	ubfx	r0, r0, #16, #4
  403c22:	4429      	add	r1, r5
  403c24:	eb00 0141 	add.w	r1, r0, r1, lsl #1
  403c28:	6011      	str	r1, [r2, #0]
	}

	/* Retrieve day */
	if (pul_day) {
  403c2a:	b14b      	cbz	r3, 403c40 <rtc_get_date+0x6c>
		ul_temp = (ul_date & RTC_CALR_DATE_Msk) >> RTC_CALR_DATE_Pos;
  403c2c:	f004 527c 	and.w	r2, r4, #1056964608	; 0x3f000000
		*pul_day = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  403c30:	0f11      	lsrs	r1, r2, #28
  403c32:	eb01 0181 	add.w	r1, r1, r1, lsl #2
  403c36:	f3c2 6203 	ubfx	r2, r2, #24, #4
  403c3a:	eb02 0241 	add.w	r2, r2, r1, lsl #1
  403c3e:	601a      	str	r2, [r3, #0]
	}

	/* Retrieve week */
	if (pul_week) {
  403c40:	b116      	cbz	r6, 403c48 <rtc_get_date+0x74>
		*pul_week = ((ul_date & RTC_CALR_DAY_Msk) >> RTC_CALR_DAY_Pos);
  403c42:	f3c4 5442 	ubfx	r4, r4, #21, #3
  403c46:	6034      	str	r4, [r6, #0]
	}
}
  403c48:	bcf0      	pop	{r4, r5, r6, r7}
  403c4a:	4770      	bx	lr

00403c4c <rtc_set_date>:
 *
 * \return 0 for OK, else invalid setting.
 */
uint32_t rtc_set_date(Rtc *p_rtc, uint32_t ul_year, uint32_t ul_month,
		uint32_t ul_day, uint32_t ul_week)
{
  403c4c:	e92d 07f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl}

	/* Week */
	ul_date |= (ul_week << RTC_CALR_DAY_Pos);

	/* Day */
	ul_date |= ((ul_day / BCD_FACTOR) << (RTC_CALR_DATE_Pos + BCD_SHIFT)) |
  403c50:	4c2c      	ldr	r4, [pc, #176]	; (403d04 <rtc_set_date+0xb8>)
 *
 * \return 0 for OK, else invalid setting.
 */
uint32_t rtc_set_date(Rtc *p_rtc, uint32_t ul_year, uint32_t ul_month,
		uint32_t ul_day, uint32_t ul_week)
{
  403c52:	9d07      	ldr	r5, [sp, #28]
	uint32_t ul_date = 0;

	/* Cent */
	ul_date |= ((ul_year / BCD_FACTOR / BCD_FACTOR / BCD_FACTOR) <<
			(RTC_CALR_CENT_Pos + BCD_SHIFT) |
			((ul_year / BCD_FACTOR / BCD_FACTOR) % BCD_FACTOR) <<  RTC_CALR_CENT_Pos);
  403c54:	4f2c      	ldr	r7, [pc, #176]	; (403d08 <rtc_set_date+0xbc>)
		uint32_t ul_day, uint32_t ul_week)
{
	uint32_t ul_date = 0;

	/* Cent */
	ul_date |= ((ul_year / BCD_FACTOR / BCD_FACTOR / BCD_FACTOR) <<
  403c56:	f8df c0b4 	ldr.w	ip, [pc, #180]	; 403d0c <rtc_set_date+0xc0>

	/* Week */
	ul_date |= (ul_week << RTC_CALR_DAY_Pos);

	/* Day */
	ul_date |= ((ul_day / BCD_FACTOR) << (RTC_CALR_DATE_Pos + BCD_SHIFT)) |
  403c5a:	fba4 8603 	umull	r8, r6, r4, r3
  403c5e:	08f6      	lsrs	r6, r6, #3
	ul_date |= (((ul_year / BCD_FACTOR) % BCD_FACTOR) <<
			(RTC_CALR_YEAR_Pos + BCD_SHIFT)) |
			((ul_year % BCD_FACTOR) << RTC_CALR_YEAR_Pos);

	/* Month */
	ul_date |= ((ul_month / BCD_FACTOR) << (RTC_CALR_MONTH_Pos + BCD_SHIFT)) |
  403c60:	fba4 a802 	umull	sl, r8, r4, r2
	/* Week */
	ul_date |= (ul_week << RTC_CALR_DAY_Pos);

	/* Day */
	ul_date |= ((ul_day / BCD_FACTOR) << (RTC_CALR_DATE_Pos + BCD_SHIFT)) |
			((ul_day % BCD_FACTOR) << RTC_CALR_DATE_Pos);
  403c64:	eb06 0986 	add.w	r9, r6, r6, lsl #2
	uint32_t ul_date = 0;

	/* Cent */
	ul_date |= ((ul_year / BCD_FACTOR / BCD_FACTOR / BCD_FACTOR) <<
			(RTC_CALR_CENT_Pos + BCD_SHIFT) |
			((ul_year / BCD_FACTOR / BCD_FACTOR) % BCD_FACTOR) <<  RTC_CALR_CENT_Pos);
  403c68:	fba7 a701 	umull	sl, r7, r7, r1
	/* Month */
	ul_date |= ((ul_month / BCD_FACTOR) << (RTC_CALR_MONTH_Pos + BCD_SHIFT)) |
			((ul_month % BCD_FACTOR) << RTC_CALR_MONTH_Pos);

	/* Week */
	ul_date |= (ul_week << RTC_CALR_DAY_Pos);
  403c6c:	056d      	lsls	r5, r5, #21

	/* Day */
	ul_date |= ((ul_day / BCD_FACTOR) << (RTC_CALR_DATE_Pos + BCD_SHIFT)) |
			((ul_day % BCD_FACTOR) << RTC_CALR_DATE_Pos);
  403c6e:	eba3 0349 	sub.w	r3, r3, r9, lsl #1

	/* Week */
	ul_date |= (ul_week << RTC_CALR_DAY_Pos);

	/* Day */
	ul_date |= ((ul_day / BCD_FACTOR) << (RTC_CALR_DATE_Pos + BCD_SHIFT)) |
  403c72:	ea45 7606 	orr.w	r6, r5, r6, lsl #28
	uint32_t ul_date = 0;

	/* Cent */
	ul_date |= ((ul_year / BCD_FACTOR / BCD_FACTOR / BCD_FACTOR) <<
			(RTC_CALR_CENT_Pos + BCD_SHIFT) |
			((ul_year / BCD_FACTOR / BCD_FACTOR) % BCD_FACTOR) <<  RTC_CALR_CENT_Pos);
  403c76:	097f      	lsrs	r7, r7, #5
	ul_date |= (((ul_year / BCD_FACTOR) % BCD_FACTOR) <<
			(RTC_CALR_YEAR_Pos + BCD_SHIFT)) |
			((ul_year % BCD_FACTOR) << RTC_CALR_YEAR_Pos);

	/* Month */
	ul_date |= ((ul_month / BCD_FACTOR) << (RTC_CALR_MONTH_Pos + BCD_SHIFT)) |
  403c78:	ea4f 05d8 	mov.w	r5, r8, lsr #3
			(RTC_CALR_CENT_Pos + BCD_SHIFT) |
			((ul_year / BCD_FACTOR / BCD_FACTOR) % BCD_FACTOR) <<  RTC_CALR_CENT_Pos);

	/* Year */
	ul_date |= (((ul_year / BCD_FACTOR) % BCD_FACTOR) <<
			(RTC_CALR_YEAR_Pos + BCD_SHIFT)) |
  403c7c:	ea46 6603 	orr.w	r6, r6, r3, lsl #24
			((ul_year % BCD_FACTOR) << RTC_CALR_YEAR_Pos);

	/* Month */
	ul_date |= ((ul_month / BCD_FACTOR) << (RTC_CALR_MONTH_Pos + BCD_SHIFT)) |
			((ul_month % BCD_FACTOR) << RTC_CALR_MONTH_Pos);
  403c80:	eb05 0985 	add.w	r9, r5, r5, lsl #2
	uint32_t ul_date = 0;

	/* Cent */
	ul_date |= ((ul_year / BCD_FACTOR / BCD_FACTOR / BCD_FACTOR) <<
			(RTC_CALR_CENT_Pos + BCD_SHIFT) |
			((ul_year / BCD_FACTOR / BCD_FACTOR) % BCD_FACTOR) <<  RTC_CALR_CENT_Pos);
  403c84:	fba4 3807 	umull	r3, r8, r4, r7

	/* Year */
	ul_date |= (((ul_year / BCD_FACTOR) % BCD_FACTOR) <<
			(RTC_CALR_YEAR_Pos + BCD_SHIFT)) |
			((ul_year % BCD_FACTOR) << RTC_CALR_YEAR_Pos);
  403c88:	fba4 a301 	umull	sl, r3, r4, r1
	ul_date |= ((ul_year / BCD_FACTOR / BCD_FACTOR / BCD_FACTOR) <<
			(RTC_CALR_CENT_Pos + BCD_SHIFT) |
			((ul_year / BCD_FACTOR / BCD_FACTOR) % BCD_FACTOR) <<  RTC_CALR_CENT_Pos);

	/* Year */
	ul_date |= (((ul_year / BCD_FACTOR) % BCD_FACTOR) <<
  403c8c:	ea46 5505 	orr.w	r5, r6, r5, lsl #20
			(RTC_CALR_YEAR_Pos + BCD_SHIFT)) |
			((ul_year % BCD_FACTOR) << RTC_CALR_YEAR_Pos);
  403c90:	08db      	lsrs	r3, r3, #3
		uint32_t ul_day, uint32_t ul_week)
{
	uint32_t ul_date = 0;

	/* Cent */
	ul_date |= ((ul_year / BCD_FACTOR / BCD_FACTOR / BCD_FACTOR) <<
  403c92:	fbac 6c01 	umull	r6, ip, ip, r1
			(RTC_CALR_YEAR_Pos + BCD_SHIFT)) |
			((ul_year % BCD_FACTOR) << RTC_CALR_YEAR_Pos);

	/* Month */
	ul_date |= ((ul_month / BCD_FACTOR) << (RTC_CALR_MONTH_Pos + BCD_SHIFT)) |
			((ul_month % BCD_FACTOR) << RTC_CALR_MONTH_Pos);
  403c96:	eba2 0249 	sub.w	r2, r2, r9, lsl #1
	uint32_t ul_date = 0;

	/* Cent */
	ul_date |= ((ul_year / BCD_FACTOR / BCD_FACTOR / BCD_FACTOR) <<
			(RTC_CALR_CENT_Pos + BCD_SHIFT) |
			((ul_year / BCD_FACTOR / BCD_FACTOR) % BCD_FACTOR) <<  RTC_CALR_CENT_Pos);
  403c9a:	ea4f 08d8 	mov.w	r8, r8, lsr #3
{
	uint32_t ul_date = 0;

	/* Cent */
	ul_date |= ((ul_year / BCD_FACTOR / BCD_FACTOR / BCD_FACTOR) <<
			(RTC_CALR_CENT_Pos + BCD_SHIFT) |
  403c9e:	ea45 4602 	orr.w	r6, r5, r2, lsl #16
			((ul_year / BCD_FACTOR / BCD_FACTOR) % BCD_FACTOR) <<  RTC_CALR_CENT_Pos);

	/* Year */
	ul_date |= (((ul_year / BCD_FACTOR) % BCD_FACTOR) <<
  403ca2:	fba4 a403 	umull	sl, r4, r4, r3
		uint32_t ul_day, uint32_t ul_week)
{
	uint32_t ul_date = 0;

	/* Cent */
	ul_date |= ((ul_year / BCD_FACTOR / BCD_FACTOR / BCD_FACTOR) <<
  403ca6:	ea4f 159c 	mov.w	r5, ip, lsr #6
			(RTC_CALR_CENT_Pos + BCD_SHIFT) |
			((ul_year / BCD_FACTOR / BCD_FACTOR) % BCD_FACTOR) <<  RTC_CALR_CENT_Pos);
  403caa:	eb08 0888 	add.w	r8, r8, r8, lsl #2
	/* Day */
	ul_date |= ((ul_day / BCD_FACTOR) << (RTC_CALR_DATE_Pos + BCD_SHIFT)) |
			((ul_day % BCD_FACTOR) << RTC_CALR_DATE_Pos);

	/* Update calendar register. Check the spec for the flow. */
	p_rtc->RTC_CR |= RTC_CR_UPDCAL;
  403cae:	6802      	ldr	r2, [r0, #0]
			((ul_year / BCD_FACTOR / BCD_FACTOR) % BCD_FACTOR) <<  RTC_CALR_CENT_Pos);

	/* Year */
	ul_date |= (((ul_year / BCD_FACTOR) % BCD_FACTOR) <<
			(RTC_CALR_YEAR_Pos + BCD_SHIFT)) |
			((ul_year % BCD_FACTOR) << RTC_CALR_YEAR_Pos);
  403cb0:	eb03 0a83 	add.w	sl, r3, r3, lsl #2

	/* Month */
	ul_date |= ((ul_month / BCD_FACTOR) << (RTC_CALR_MONTH_Pos + BCD_SHIFT)) |
  403cb4:	ea46 1505 	orr.w	r5, r6, r5, lsl #4
	uint32_t ul_date = 0;

	/* Cent */
	ul_date |= ((ul_year / BCD_FACTOR / BCD_FACTOR / BCD_FACTOR) <<
			(RTC_CALR_CENT_Pos + BCD_SHIFT) |
			((ul_year / BCD_FACTOR / BCD_FACTOR) % BCD_FACTOR) <<  RTC_CALR_CENT_Pos);
  403cb8:	eba7 0748 	sub.w	r7, r7, r8, lsl #1

	/* Year */
	ul_date |= (((ul_year / BCD_FACTOR) % BCD_FACTOR) <<
  403cbc:	08e4      	lsrs	r4, r4, #3
			(RTC_CALR_YEAR_Pos + BCD_SHIFT)) |
			((ul_year % BCD_FACTOR) << RTC_CALR_YEAR_Pos);

	/* Month */
	ul_date |= ((ul_month / BCD_FACTOR) << (RTC_CALR_MONTH_Pos + BCD_SHIFT)) |
  403cbe:	432f      	orrs	r7, r5
	ul_date |= ((ul_year / BCD_FACTOR / BCD_FACTOR / BCD_FACTOR) <<
			(RTC_CALR_CENT_Pos + BCD_SHIFT) |
			((ul_year / BCD_FACTOR / BCD_FACTOR) % BCD_FACTOR) <<  RTC_CALR_CENT_Pos);

	/* Year */
	ul_date |= (((ul_year / BCD_FACTOR) % BCD_FACTOR) <<
  403cc0:	eb04 0484 	add.w	r4, r4, r4, lsl #2
			(RTC_CALR_YEAR_Pos + BCD_SHIFT)) |
			((ul_year % BCD_FACTOR) << RTC_CALR_YEAR_Pos);
  403cc4:	eba1 014a 	sub.w	r1, r1, sl, lsl #1
	/* Day */
	ul_date |= ((ul_day / BCD_FACTOR) << (RTC_CALR_DATE_Pos + BCD_SHIFT)) |
			((ul_day % BCD_FACTOR) << RTC_CALR_DATE_Pos);

	/* Update calendar register. Check the spec for the flow. */
	p_rtc->RTC_CR |= RTC_CR_UPDCAL;
  403cc8:	f042 0202 	orr.w	r2, r2, #2
	ul_date |= ((ul_year / BCD_FACTOR / BCD_FACTOR / BCD_FACTOR) <<
			(RTC_CALR_CENT_Pos + BCD_SHIFT) |
			((ul_year / BCD_FACTOR / BCD_FACTOR) % BCD_FACTOR) <<  RTC_CALR_CENT_Pos);

	/* Year */
	ul_date |= (((ul_year / BCD_FACTOR) % BCD_FACTOR) <<
  403ccc:	eba3 0344 	sub.w	r3, r3, r4, lsl #1
	/* Month */
	ul_date |= ((ul_month / BCD_FACTOR) << (RTC_CALR_MONTH_Pos + BCD_SHIFT)) |
			((ul_month % BCD_FACTOR) << RTC_CALR_MONTH_Pos);

	/* Week */
	ul_date |= (ul_week << RTC_CALR_DAY_Pos);
  403cd0:	ea47 2101 	orr.w	r1, r7, r1, lsl #8
	/* Day */
	ul_date |= ((ul_day / BCD_FACTOR) << (RTC_CALR_DATE_Pos + BCD_SHIFT)) |
			((ul_day % BCD_FACTOR) << RTC_CALR_DATE_Pos);

	/* Update calendar register. Check the spec for the flow. */
	p_rtc->RTC_CR |= RTC_CR_UPDCAL;
  403cd4:	6002      	str	r2, [r0, #0]

	/* Week */
	ul_date |= (ul_week << RTC_CALR_DAY_Pos);

	/* Day */
	ul_date |= ((ul_day / BCD_FACTOR) << (RTC_CALR_DATE_Pos + BCD_SHIFT)) |
  403cd6:	ea41 3103 	orr.w	r1, r1, r3, lsl #12
			((ul_day % BCD_FACTOR) << RTC_CALR_DATE_Pos);

	/* Update calendar register. Check the spec for the flow. */
	p_rtc->RTC_CR |= RTC_CR_UPDCAL;
	while ((p_rtc->RTC_SR & RTC_SR_ACKUPD) != RTC_SR_ACKUPD);
  403cda:	6983      	ldr	r3, [r0, #24]
  403cdc:	07db      	lsls	r3, r3, #31
  403cde:	d5fc      	bpl.n	403cda <rtc_set_date+0x8e>

	p_rtc->RTC_SCCR = RTC_SCCR_ACKCLR;
  403ce0:	2301      	movs	r3, #1
  403ce2:	61c3      	str	r3, [r0, #28]
	p_rtc->RTC_CALR = ul_date;
  403ce4:	60c1      	str	r1, [r0, #12]
	p_rtc->RTC_CR &= (~RTC_CR_UPDCAL);
  403ce6:	6803      	ldr	r3, [r0, #0]
  403ce8:	f023 0302 	bic.w	r3, r3, #2
  403cec:	6003      	str	r3, [r0, #0]
	/* Clear SECENV in SCCR */
	p_rtc->RTC_SCCR |= RTC_SCCR_SECCLR;
  403cee:	69c3      	ldr	r3, [r0, #28]
  403cf0:	f043 0304 	orr.w	r3, r3, #4
  403cf4:	61c3      	str	r3, [r0, #28]

	return (p_rtc->RTC_VER & RTC_VER_NVCAL);
  403cf6:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
}
  403cf8:	e8bd 07f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl}
  403cfc:	f000 0002 	and.w	r0, r0, #2
  403d00:	4770      	bx	lr
  403d02:	bf00      	nop
  403d04:	cccccccd 	.word	0xcccccccd
  403d08:	51eb851f 	.word	0x51eb851f
  403d0c:	10624dd3 	.word	0x10624dd3

00403d10 <rtc_clear_time_alarm>:
 *
 * \param p_rtc Pointer to an RTC instance.
 */
void rtc_clear_time_alarm(Rtc *p_rtc)
{
	p_rtc->RTC_TIMALR = 0;
  403d10:	2300      	movs	r3, #0
  403d12:	6103      	str	r3, [r0, #16]
  403d14:	4770      	bx	lr
  403d16:	bf00      	nop

00403d18 <rtc_clear_date_alarm>:
 * \param p_rtc Pointer to an RTC instance.
 */
void rtc_clear_date_alarm(Rtc *p_rtc)
{
	/* Need a valid value without enabling */
	p_rtc->RTC_CALALR = RTC_CALALR_MONTH(0x01) | RTC_CALALR_DATE(0x01);
  403d18:	4b01      	ldr	r3, [pc, #4]	; (403d20 <rtc_clear_date_alarm+0x8>)
  403d1a:	6143      	str	r3, [r0, #20]
  403d1c:	4770      	bx	lr
  403d1e:	bf00      	nop
  403d20:	01010000 	.word	0x01010000

00403d24 <uart_init>:
 *
 * \retval 0 Success.
 * \retval 1 Bad baud rate generator value.
 */
uint32_t uart_init(Uart *p_uart, const sam_uart_opt_t *p_uart_opt)
{
  403d24:	b410      	push	{r4}
	uint32_t cd = 0;

	/* Reset and disable receiver & transmitter */
	p_uart->UART_CR = UART_CR_RSTRX | UART_CR_RSTTX
  403d26:	22ac      	movs	r2, #172	; 0xac
  403d28:	6002      	str	r2, [r0, #0]
 *
 * \retval 0 Success.
 * \retval 1 Bad baud rate generator value.
 */
uint32_t uart_init(Uart *p_uart, const sam_uart_opt_t *p_uart_opt)
{
  403d2a:	4603      	mov	r3, r0
	p_uart->UART_CR = UART_CR_RSTRX | UART_CR_RSTTX
			| UART_CR_RXDIS | UART_CR_TXDIS;

	/* Check and configure baudrate */
	/* Asynchronous, no oversampling */
	cd = (p_uart_opt->ul_mck / p_uart_opt->ul_baudrate) / UART_MCK_DIV;
  403d2c:	e891 0005 	ldmia.w	r1, {r0, r2}
  403d30:	fbb0 f2f2 	udiv	r2, r0, r2
  403d34:	0912      	lsrs	r2, r2, #4
	if (cd < UART_MCK_DIV_MIN_FACTOR || cd > UART_MCK_DIV_MAX_FACTOR)
  403d36:	1e54      	subs	r4, r2, #1
  403d38:	f64f 70fe 	movw	r0, #65534	; 0xfffe
  403d3c:	4284      	cmp	r4, r0
  403d3e:	d80c      	bhi.n	403d5a <uart_init+0x36>
		return 1;

	p_uart->UART_BRGR = cd;
  403d40:	621a      	str	r2, [r3, #32]
	/* Configure mode */
	p_uart->UART_MR = p_uart_opt->ul_mode;
  403d42:	688a      	ldr	r2, [r1, #8]
  403d44:	605a      	str	r2, [r3, #4]

#if (!SAMV71 && !SAMV70 && !SAME70 && !SAMS70)
	/* Disable PDC channel */
	p_uart->UART_PTCR = UART_PTCR_RXTDIS | UART_PTCR_TXTDIS;
  403d46:	f240 2102 	movw	r1, #514	; 0x202
#endif

	/* Enable receiver and transmitter */
	p_uart->UART_CR = UART_CR_RXEN | UART_CR_TXEN;
  403d4a:	2250      	movs	r2, #80	; 0x50
	/* Configure mode */
	p_uart->UART_MR = p_uart_opt->ul_mode;

#if (!SAMV71 && !SAMV70 && !SAME70 && !SAMS70)
	/* Disable PDC channel */
	p_uart->UART_PTCR = UART_PTCR_RXTDIS | UART_PTCR_TXTDIS;
  403d4c:	f8c3 1120 	str.w	r1, [r3, #288]	; 0x120
#endif

	/* Enable receiver and transmitter */
	p_uart->UART_CR = UART_CR_RXEN | UART_CR_TXEN;
  403d50:	601a      	str	r2, [r3, #0]

	return 0;
  403d52:	2000      	movs	r0, #0
}
  403d54:	f85d 4b04 	ldr.w	r4, [sp], #4
  403d58:	4770      	bx	lr

	/* Check and configure baudrate */
	/* Asynchronous, no oversampling */
	cd = (p_uart_opt->ul_mck / p_uart_opt->ul_baudrate) / UART_MCK_DIV;
	if (cd < UART_MCK_DIV_MIN_FACTOR || cd > UART_MCK_DIV_MAX_FACTOR)
		return 1;
  403d5a:	2001      	movs	r0, #1

	/* Enable receiver and transmitter */
	p_uart->UART_CR = UART_CR_RXEN | UART_CR_TXEN;

	return 0;
}
  403d5c:	f85d 4b04 	ldr.w	r4, [sp], #4
  403d60:	4770      	bx	lr
  403d62:	bf00      	nop

00403d64 <uart_disable_interrupt>:
 * \param p_uart Pointer to a UART instance.
 *  \param ul_sources Interrupts to be disabled.
 */
void uart_disable_interrupt(Uart *p_uart, uint32_t ul_sources)
{
	p_uart->UART_IDR = ul_sources;
  403d64:	60c1      	str	r1, [r0, #12]
  403d66:	4770      	bx	lr

00403d68 <uart_get_status>:
 *
 * \return The current UART status.
 */
uint32_t uart_get_status(Uart *p_uart)
{
	return p_uart->UART_SR;
  403d68:	6940      	ldr	r0, [r0, #20]
}
  403d6a:	4770      	bx	lr

00403d6c <uart_write>:
 * \retval 1 I/O Failure, UART is not ready.
 */
uint32_t uart_write(Uart *p_uart, const uint8_t uc_data)
{
	/* Check if the transmitter is ready */
	if (!(p_uart->UART_SR & UART_SR_TXRDY))
  403d6c:	6943      	ldr	r3, [r0, #20]
  403d6e:	079b      	lsls	r3, r3, #30
		return 1;

	/* Send character */
	p_uart->UART_THR = uc_data;
  403d70:	bf46      	itte	mi
  403d72:	61c1      	strmi	r1, [r0, #28]
	return 0;
  403d74:	2000      	movmi	r0, #0
 */
uint32_t uart_write(Uart *p_uart, const uint8_t uc_data)
{
	/* Check if the transmitter is ready */
	if (!(p_uart->UART_SR & UART_SR_TXRDY))
		return 1;
  403d76:	2001      	movpl	r0, #1

	/* Send character */
	p_uart->UART_THR = uc_data;
	return 0;
}
  403d78:	4770      	bx	lr
  403d7a:	bf00      	nop

00403d7c <uart_read>:
 * \retval 1 I/O Failure, UART is not ready.
 */
uint32_t uart_read(Uart *p_uart, uint8_t *puc_data)
{
	/* Check if the receiver is ready */
	if ((p_uart->UART_SR & UART_SR_RXRDY) == 0)
  403d7c:	6943      	ldr	r3, [r0, #20]
  403d7e:	07db      	lsls	r3, r3, #31
		return 1;

	/* Read character */
	*puc_data = (uint8_t) p_uart->UART_RHR;
  403d80:	bf43      	ittte	mi
  403d82:	6983      	ldrmi	r3, [r0, #24]
  403d84:	700b      	strbmi	r3, [r1, #0]
	return 0;
  403d86:	2000      	movmi	r0, #0
 */
uint32_t uart_read(Uart *p_uart, uint8_t *puc_data)
{
	/* Check if the receiver is ready */
	if ((p_uart->UART_SR & UART_SR_RXRDY) == 0)
		return 1;
  403d88:	2001      	movpl	r0, #1

	/* Read character */
	*puc_data = (uint8_t) p_uart->UART_RHR;
	return 0;
}
  403d8a:	4770      	bx	lr

00403d8c <usart_set_async_baudrate>:
	uint32_t cd_fp;
	uint32_t cd;
	uint32_t fp;

	/* Calculate the receiver sampling divide of baudrate clock. */
	if (ul_mck >= HIGH_FRQ_SAMPLE_DIV * baudrate) {
  403d8c:	010b      	lsls	r3, r1, #4
  403d8e:	4293      	cmp	r3, r2
 * \retval 1 Baud rate set point is out of range for the given input clock
 * frequency.
 */
uint32_t usart_set_async_baudrate(Usart *p_usart,
		uint32_t baudrate, uint32_t ul_mck)
{
  403d90:	b410      	push	{r4}
	uint32_t cd_fp;
	uint32_t cd;
	uint32_t fp;

	/* Calculate the receiver sampling divide of baudrate clock. */
	if (ul_mck >= HIGH_FRQ_SAMPLE_DIV * baudrate) {
  403d92:	d815      	bhi.n	403dc0 <usart_set_async_baudrate+0x34>
	} else {
		over = LOW_FRQ_SAMPLE_DIV;
	}

	/* Calculate clock divider according to the fraction calculated formula. */
	cd_fp = (8 * ul_mck + (over * baudrate) / 2) / (over * baudrate);
  403d94:	00d2      	lsls	r2, r2, #3
  403d96:	eb02 0253 	add.w	r2, r2, r3, lsr #1
  403d9a:	fbb2 f3f3 	udiv	r3, r2, r3
	cd = cd_fp >> 3;
  403d9e:	08da      	lsrs	r2, r3, #3
	fp = cd_fp & 0x07;
	if (cd < MIN_CD_VALUE || cd > MAX_CD_VALUE) {
  403da0:	1e54      	subs	r4, r2, #1
  403da2:	f64f 71fe 	movw	r1, #65534	; 0xfffe
  403da6:	428c      	cmp	r4, r1
	}

	/* Calculate clock divider according to the fraction calculated formula. */
	cd_fp = (8 * ul_mck + (over * baudrate) / 2) / (over * baudrate);
	cd = cd_fp >> 3;
	fp = cd_fp & 0x07;
  403da8:	f003 0307 	and.w	r3, r3, #7
	if (cd < MIN_CD_VALUE || cd > MAX_CD_VALUE) {
  403dac:	d806      	bhi.n	403dbc <usart_set_async_baudrate+0x30>
	if (over == 8) {
		p_usart->US_MR |= US_MR_OVER;
	}

	/* Configure the baudrate generate register. */
	p_usart->US_BRGR = (cd << US_BRGR_CD_Pos) | (fp << US_BRGR_FP_Pos);
  403dae:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
  403db2:	6203      	str	r3, [r0, #32]

	return 0;
  403db4:	2000      	movs	r0, #0
}
  403db6:	f85d 4b04 	ldr.w	r4, [sp], #4
  403dba:	4770      	bx	lr
	/* Calculate clock divider according to the fraction calculated formula. */
	cd_fp = (8 * ul_mck + (over * baudrate) / 2) / (over * baudrate);
	cd = cd_fp >> 3;
	fp = cd_fp & 0x07;
	if (cd < MIN_CD_VALUE || cd > MAX_CD_VALUE) {
		return 1;
  403dbc:	2001      	movs	r0, #1
  403dbe:	e7fa      	b.n	403db6 <usart_set_async_baudrate+0x2a>
	} else {
		over = LOW_FRQ_SAMPLE_DIV;
	}

	/* Calculate clock divider according to the fraction calculated formula. */
	cd_fp = (8 * ul_mck + (over * baudrate) / 2) / (over * baudrate);
  403dc0:	00c9      	lsls	r1, r1, #3
  403dc2:	00d3      	lsls	r3, r2, #3
  403dc4:	eb03 0351 	add.w	r3, r3, r1, lsr #1
  403dc8:	fbb3 f3f1 	udiv	r3, r3, r1
	cd = cd_fp >> 3;
  403dcc:	08da      	lsrs	r2, r3, #3
	fp = cd_fp & 0x07;
	if (cd < MIN_CD_VALUE || cd > MAX_CD_VALUE) {
  403dce:	1e54      	subs	r4, r2, #1
  403dd0:	f64f 71fe 	movw	r1, #65534	; 0xfffe
  403dd4:	428c      	cmp	r4, r1
	}

	/* Calculate clock divider according to the fraction calculated formula. */
	cd_fp = (8 * ul_mck + (over * baudrate) / 2) / (over * baudrate);
	cd = cd_fp >> 3;
	fp = cd_fp & 0x07;
  403dd6:	f003 0307 	and.w	r3, r3, #7
	if (cd < MIN_CD_VALUE || cd > MAX_CD_VALUE) {
  403dda:	d8ef      	bhi.n	403dbc <usart_set_async_baudrate+0x30>
		return 1;
	}

	/* Configure the OVER bit in MR register. */
	if (over == 8) {
		p_usart->US_MR |= US_MR_OVER;
  403ddc:	6841      	ldr	r1, [r0, #4]
  403dde:	f441 2100 	orr.w	r1, r1, #524288	; 0x80000
  403de2:	6041      	str	r1, [r0, #4]
  403de4:	e7e3      	b.n	403dae <usart_set_async_baudrate+0x22>
  403de6:	bf00      	nop

00403de8 <usart_init_rs232>:
 * \retval 0 on success.
 * \retval 1 on failure.
 */
uint32_t usart_init_rs232(Usart *p_usart,
		const sam_usart_opt_t *p_usart_opt, uint32_t ul_mck)
{
  403de8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_disable_writeprotect(Usart *p_usart)
{
	p_usart->US_WPMR = US_WPMR_WPKEY_PASSWD;
  403dec:	4b19      	ldr	r3, [pc, #100]	; (403e54 <usart_init_rs232+0x6c>)
	static uint32_t ul_reg_val;

	/* Reset the USART and shut down TX and RX. */
	usart_reset(p_usart);

	ul_reg_val = 0;
  403dee:	4e1a      	ldr	r6, [pc, #104]	; (403e58 <usart_init_rs232+0x70>)
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_disable_writeprotect(Usart *p_usart)
{
	p_usart->US_WPMR = US_WPMR_WPKEY_PASSWD;
  403df0:	f8c0 30e4 	str.w	r3, [r0, #228]	; 0xe4
	/* Reset the USART and shut down TX and RX. */
	usart_reset(p_usart);

	ul_reg_val = 0;
	/* Check whether the input values are legal. */
	if (!p_usart_opt || usart_set_async_baudrate(p_usart,
  403df4:	460d      	mov	r5, r1
{
	/* Disable the Write Protect. */
	usart_disable_writeprotect(p_usart);

	/* Reset registers that could cause unpredictable behavior after reset. */
	p_usart->US_MR = 0;
  403df6:	2300      	movs	r3, #0
 * \param p_usart Pointer to a USART instance.
 */
void usart_reset_tx(Usart *p_usart)
{
	/* Reset transmitter */
	p_usart->US_CR = US_CR_RSTTX | US_CR_TXDIS;
  403df8:	f04f 0988 	mov.w	r9, #136	; 0x88
 * \param p_usart Pointer to a USART instance.
 */
void usart_reset_rx(Usart *p_usart)
{
	/* Reset Receiver */
	p_usart->US_CR = US_CR_RSTRX | US_CR_RXDIS;
  403dfc:	f04f 0824 	mov.w	r8, #36	; 0x24
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_reset_status(Usart *p_usart)
{
	p_usart->US_CR = US_CR_RSTSTA;
  403e00:	f44f 7c80 	mov.w	ip, #256	; 0x100
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_drive_RTS_pin_high(Usart *p_usart)
{
	p_usart->US_CR = US_CR_RTSDIS;
  403e04:	f44f 2700 	mov.w	r7, #524288	; 0x80000
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_drive_DTR_pin_high(Usart *p_usart)
{
	p_usart->US_CR = US_CR_DTRDIS;
  403e08:	f44f 3100 	mov.w	r1, #131072	; 0x20000
{
	/* Disable the Write Protect. */
	usart_disable_writeprotect(p_usart);

	/* Reset registers that could cause unpredictable behavior after reset. */
	p_usart->US_MR = 0;
  403e0c:	6043      	str	r3, [r0, #4]
 * \retval 0 on success.
 * \retval 1 on failure.
 */
uint32_t usart_init_rs232(Usart *p_usart,
		const sam_usart_opt_t *p_usart_opt, uint32_t ul_mck)
{
  403e0e:	4604      	mov	r4, r0
	/* Disable the Write Protect. */
	usart_disable_writeprotect(p_usart);

	/* Reset registers that could cause unpredictable behavior after reset. */
	p_usart->US_MR = 0;
	p_usart->US_RTOR = 0;
  403e10:	6243      	str	r3, [r0, #36]	; 0x24
	static uint32_t ul_reg_val;

	/* Reset the USART and shut down TX and RX. */
	usart_reset(p_usart);

	ul_reg_val = 0;
  403e12:	6033      	str	r3, [r6, #0]
	usart_disable_writeprotect(p_usart);

	/* Reset registers that could cause unpredictable behavior after reset. */
	p_usart->US_MR = 0;
	p_usart->US_RTOR = 0;
	p_usart->US_TTGR = 0;
  403e14:	6283      	str	r3, [r0, #40]	; 0x28
 * \param p_usart Pointer to a USART instance.
 */
void usart_reset_tx(Usart *p_usart)
{
	/* Reset transmitter */
	p_usart->US_CR = US_CR_RSTTX | US_CR_TXDIS;
  403e16:	f8c0 9000 	str.w	r9, [r0]
 * \param p_usart Pointer to a USART instance.
 */
void usart_reset_rx(Usart *p_usart)
{
	/* Reset Receiver */
	p_usart->US_CR = US_CR_RSTRX | US_CR_RXDIS;
  403e1a:	f8c0 8000 	str.w	r8, [r0]
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_reset_status(Usart *p_usart)
{
	p_usart->US_CR = US_CR_RSTSTA;
  403e1e:	f8c0 c000 	str.w	ip, [r0]
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_drive_RTS_pin_high(Usart *p_usart)
{
	p_usart->US_CR = US_CR_RTSDIS;
  403e22:	6007      	str	r7, [r0, #0]
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_drive_DTR_pin_high(Usart *p_usart)
{
	p_usart->US_CR = US_CR_DTRDIS;
  403e24:	6001      	str	r1, [r0, #0]
	/* Reset the USART and shut down TX and RX. */
	usart_reset(p_usart);

	ul_reg_val = 0;
	/* Check whether the input values are legal. */
	if (!p_usart_opt || usart_set_async_baudrate(p_usart,
  403e26:	b195      	cbz	r5, 403e4e <usart_init_rs232+0x66>
  403e28:	6829      	ldr	r1, [r5, #0]
  403e2a:	4b0c      	ldr	r3, [pc, #48]	; (403e5c <usart_init_rs232+0x74>)
  403e2c:	4798      	blx	r3
  403e2e:	b970      	cbnz	r0, 403e4e <usart_init_rs232+0x66>
			p_usart_opt->baudrate, ul_mck)) {
		return 1;
	}

	/* Configure the USART option. */
	ul_reg_val |= p_usart_opt->char_length | p_usart_opt->parity_type |
  403e30:	f8d5 c008 	ldr.w	ip, [r5, #8]
  403e34:	686b      	ldr	r3, [r5, #4]
  403e36:	692f      	ldr	r7, [r5, #16]
			p_usart_opt->channel_mode | p_usart_opt->stop_bits;
  403e38:	68e9      	ldr	r1, [r5, #12]

	/* Configure the USART mode as normal mode. */
	ul_reg_val |= US_MR_USART_MODE_NORMAL;

	p_usart->US_MR |= ul_reg_val;
  403e3a:	6862      	ldr	r2, [r4, #4]
			p_usart_opt->baudrate, ul_mck)) {
		return 1;
	}

	/* Configure the USART option. */
	ul_reg_val |= p_usart_opt->char_length | p_usart_opt->parity_type |
  403e3c:	ea4c 0303 	orr.w	r3, ip, r3
  403e40:	433b      	orrs	r3, r7
			p_usart_opt->channel_mode | p_usart_opt->stop_bits;
  403e42:	430b      	orrs	r3, r1

	/* Configure the USART mode as normal mode. */
	ul_reg_val |= US_MR_USART_MODE_NORMAL;

	p_usart->US_MR |= ul_reg_val;
  403e44:	431a      	orrs	r2, r3
			p_usart_opt->baudrate, ul_mck)) {
		return 1;
	}

	/* Configure the USART option. */
	ul_reg_val |= p_usart_opt->char_length | p_usart_opt->parity_type |
  403e46:	6033      	str	r3, [r6, #0]
			p_usart_opt->channel_mode | p_usart_opt->stop_bits;

	/* Configure the USART mode as normal mode. */
	ul_reg_val |= US_MR_USART_MODE_NORMAL;

	p_usart->US_MR |= ul_reg_val;
  403e48:	6062      	str	r2, [r4, #4]

	return 0;
}
  403e4a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

	ul_reg_val = 0;
	/* Check whether the input values are legal. */
	if (!p_usart_opt || usart_set_async_baudrate(p_usart,
			p_usart_opt->baudrate, ul_mck)) {
		return 1;
  403e4e:	2001      	movs	r0, #1
  403e50:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  403e54:	55534100 	.word	0x55534100
  403e58:	20003394 	.word	0x20003394
  403e5c:	00403d8d 	.word	0x00403d8d

00403e60 <usart_enable_tx>:
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_enable_tx(Usart *p_usart)
{
	p_usart->US_CR = US_CR_TXEN;
  403e60:	2340      	movs	r3, #64	; 0x40
  403e62:	6003      	str	r3, [r0, #0]
  403e64:	4770      	bx	lr
  403e66:	bf00      	nop

00403e68 <usart_enable_rx>:
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_enable_rx(Usart *p_usart)
{
	p_usart->US_CR = US_CR_RXEN;
  403e68:	2310      	movs	r3, #16
  403e6a:	6003      	str	r3, [r0, #0]
  403e6c:	4770      	bx	lr
  403e6e:	bf00      	nop

00403e70 <usart_enable_interrupt>:
 * \param p_usart Pointer to a USART peripheral.
 * \param ul_sources Interrupt sources bit map.
 */
void usart_enable_interrupt(Usart *p_usart, uint32_t ul_sources)
{
	p_usart->US_IER = ul_sources;
  403e70:	6081      	str	r1, [r0, #8]
  403e72:	4770      	bx	lr

00403e74 <usart_disable_interrupt>:
 * \param p_usart Pointer to a USART peripheral.
 * \param ul_sources Interrupt sources bit map.
 */
void usart_disable_interrupt(Usart *p_usart, uint32_t ul_sources)
{
	p_usart->US_IDR = ul_sources;
  403e74:	60c1      	str	r1, [r0, #12]
  403e76:	4770      	bx	lr

00403e78 <usart_write>:
 * \retval 0 on success.
 * \retval 1 on failure.
 */
uint32_t usart_write(Usart *p_usart, uint32_t c)
{
	if (!(p_usart->US_CSR & US_CSR_TXRDY)) {
  403e78:	6943      	ldr	r3, [r0, #20]
  403e7a:	079b      	lsls	r3, r3, #30
		return 1;
	}

	p_usart->US_THR = US_THR_TXCHR(c);
  403e7c:	bf43      	ittte	mi
  403e7e:	f3c1 0108 	ubfxmi	r1, r1, #0, #9
  403e82:	61c1      	strmi	r1, [r0, #28]
	return 0;
  403e84:	2000      	movmi	r0, #0
 * \retval 1 on failure.
 */
uint32_t usart_write(Usart *p_usart, uint32_t c)
{
	if (!(p_usart->US_CSR & US_CSR_TXRDY)) {
		return 1;
  403e86:	2001      	movpl	r0, #1
	}

	p_usart->US_THR = US_THR_TXCHR(c);
	return 0;
}
  403e88:	4770      	bx	lr
  403e8a:	bf00      	nop

00403e8c <usart_read>:
 * \retval 0 on success.
 * \retval 1 if no data is available or errors.
 */
uint32_t usart_read(Usart *p_usart, uint32_t *c)
{
	if (!(p_usart->US_CSR & US_CSR_RXRDY)) {
  403e8c:	6943      	ldr	r3, [r0, #20]
  403e8e:	07db      	lsls	r3, r3, #31
  403e90:	d505      	bpl.n	403e9e <usart_read+0x12>
		return 1;
	}

	/* Read character */
	*c = p_usart->US_RHR & US_RHR_RXCHR_Msk;
  403e92:	6983      	ldr	r3, [r0, #24]
  403e94:	f3c3 0308 	ubfx	r3, r3, #0, #9
  403e98:	600b      	str	r3, [r1, #0]

	return 0;
  403e9a:	2000      	movs	r0, #0
  403e9c:	4770      	bx	lr
 * \retval 1 if no data is available or errors.
 */
uint32_t usart_read(Usart *p_usart, uint32_t *c)
{
	if (!(p_usart->US_CSR & US_CSR_RXRDY)) {
		return 1;
  403e9e:	2001      	movs	r0, #1

	/* Read character */
	*c = p_usart->US_RHR & US_RHR_RXCHR_Msk;

	return 0;
}
  403ea0:	4770      	bx	lr
  403ea2:	bf00      	nop

00403ea4 <usart_getchar>:
 * \retval 1 on failure.
 */
uint32_t usart_getchar(Usart *p_usart, uint32_t *c)
{
	/* Wait until it's not empty or timeout has reached. */
	while (!(p_usart->US_CSR & US_CSR_RXRDY)) {
  403ea4:	6943      	ldr	r3, [r0, #20]
  403ea6:	07db      	lsls	r3, r3, #31
  403ea8:	d5fc      	bpl.n	403ea4 <usart_getchar>
	}

	/* Read character */
	*c = p_usart->US_RHR & US_RHR_RXCHR_Msk;
  403eaa:	6983      	ldr	r3, [r0, #24]
  403eac:	f3c3 0308 	ubfx	r3, r3, #0, #9
  403eb0:	600b      	str	r3, [r1, #0]

	return 0;
}
  403eb2:	2000      	movs	r0, #0
  403eb4:	4770      	bx	lr
  403eb6:	bf00      	nop

00403eb8 <disk_initialize>:
 *
 * \return 0 or disk status in combination of DSTATUS bits
 *         (STA_NOINIT, STA_PROTECT).
 */
DSTATUS disk_initialize(BYTE drv)
{
  403eb8:	b538      	push	{r3, r4, r5, lr}
	int i;
	Ctrl_status mem_status;

#if (SAM3S || SAM3U || SAM3N || SAM3XA || SAM4S)
	/* Default RTC configuration, 24-hour mode */
	rtc_set_hour_mode(RTC, 0);
  403eba:	2100      	movs	r1, #0
 *
 * \return 0 or disk status in combination of DSTATUS bits
 *         (STA_NOINIT, STA_PROTECT).
 */
DSTATUS disk_initialize(BYTE drv)
{
  403ebc:	4604      	mov	r4, r0
	int i;
	Ctrl_status mem_status;

#if (SAM3S || SAM3U || SAM3N || SAM3XA || SAM4S)
	/* Default RTC configuration, 24-hour mode */
	rtc_set_hour_mode(RTC, 0);
  403ebe:	4b0b      	ldr	r3, [pc, #44]	; (403eec <disk_initialize+0x34>)
  403ec0:	480b      	ldr	r0, [pc, #44]	; (403ef0 <disk_initialize+0x38>)
  403ec2:	4798      	blx	r3
	/* USB disk with multiple LUNs */
	if (drv > LUN_ID_USB + Lun_usb_get_lun()) {
		return STA_NOINIT;
	}
#else
	if (drv > MAX_LUN) {
  403ec4:	2c02      	cmp	r4, #2
  403ec6:	d807      	bhi.n	403ed8 <disk_initialize+0x20>
		return STA_NOINIT;
	}
#endif
	/* Check LUN ready (USB disk report CTRL_BUSY then CTRL_GOOD) */
	for (i = 0; i < 2; i ++) {
		mem_status = mem_test_unit_ready(drv);
  403ec8:	4620      	mov	r0, r4
  403eca:	4d0a      	ldr	r5, [pc, #40]	; (403ef4 <disk_initialize+0x3c>)
  403ecc:	47a8      	blx	r5
		if (CTRL_BUSY != mem_status) {
  403ece:	2803      	cmp	r0, #3
  403ed0:	d101      	bne.n	403ed6 <disk_initialize+0x1e>
		return STA_NOINIT;
	}
#endif
	/* Check LUN ready (USB disk report CTRL_BUSY then CTRL_GOOD) */
	for (i = 0; i < 2; i ++) {
		mem_status = mem_test_unit_ready(drv);
  403ed2:	4620      	mov	r0, r4
  403ed4:	47a8      	blx	r5
		if (CTRL_BUSY != mem_status) {
			break;
		}
	}
	if (mem_status != CTRL_GOOD) {
  403ed6:	b108      	cbz	r0, 403edc <disk_initialize+0x24>
		return STA_NOINIT;
	}
#else
	if (drv > MAX_LUN) {
		/* At least one of the LUN should be defined */
		return STA_NOINIT;
  403ed8:	2001      	movs	r0, #1
  403eda:	bd38      	pop	{r3, r4, r5, pc}
	if (mem_status != CTRL_GOOD) {
		return STA_NOINIT;
	}

	/* Check Write Protection Status */
	if (mem_wr_protect(drv)) {
  403edc:	4620      	mov	r0, r4
  403ede:	4b06      	ldr	r3, [pc, #24]	; (403ef8 <disk_initialize+0x40>)
  403ee0:	4798      	blx	r3
  403ee2:	2800      	cmp	r0, #0
		return STA_PROTECT;
  403ee4:	bf0c      	ite	eq
  403ee6:	2000      	moveq	r0, #0
  403ee8:	2004      	movne	r0, #4
	}

	/* The memory should already be initialized */
	return 0;
}
  403eea:	bd38      	pop	{r3, r4, r5, pc}
  403eec:	00403ad1 	.word	0x00403ad1
  403ef0:	400e1460 	.word	0x400e1460
  403ef4:	00403419 	.word	0x00403419
  403ef8:	00403459 	.word	0x00403459

00403efc <disk_status>:
 *
 * \return 0 or disk status in combination of DSTATUS bits
 *         (STA_NOINIT, STA_NODISK, STA_PROTECT).
 */
DSTATUS disk_status(BYTE drv)
{
  403efc:	b508      	push	{r3, lr}
	switch (mem_test_unit_ready(drv)) {
  403efe:	4b04      	ldr	r3, [pc, #16]	; (403f10 <disk_status+0x14>)
  403f00:	4798      	blx	r3
  403f02:	b118      	cbz	r0, 403f0c <disk_status+0x10>
  403f04:	2802      	cmp	r0, #2
	case CTRL_GOOD:
		return 0;
	case CTRL_NO_PRESENT:
		return STA_NOINIT | STA_NODISK;
	default:
		return STA_NOINIT;
  403f06:	bf0c      	ite	eq
  403f08:	2003      	moveq	r0, #3
  403f0a:	2001      	movne	r0, #1
	}
}
  403f0c:	bd08      	pop	{r3, pc}
  403f0e:	bf00      	nop
  403f10:	00403419 	.word	0x00403419

00403f14 <disk_read>:
 * \param count Number of sectors to read (1..255).
 *
 * \return RES_OK for success, otherwise DRESULT error code.
 */
DRESULT disk_read(BYTE drv, BYTE *buff, DWORD sector, BYTE count)
{
  403f14:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if ACCESS_MEM_TO_RAM
	uint8_t uc_sector_size = mem_sector_size(drv);
  403f18:	4c18      	ldr	r4, [pc, #96]	; (403f7c <disk_read+0x68>)
 * \param count Number of sectors to read (1..255).
 *
 * \return RES_OK for success, otherwise DRESULT error code.
 */
DRESULT disk_read(BYTE drv, BYTE *buff, DWORD sector, BYTE count)
{
  403f1a:	b083      	sub	sp, #12
  403f1c:	460e      	mov	r6, r1
  403f1e:	4615      	mov	r5, r2
  403f20:	4698      	mov	r8, r3
  403f22:	4681      	mov	r9, r0
#if ACCESS_MEM_TO_RAM
	uint8_t uc_sector_size = mem_sector_size(drv);
  403f24:	47a0      	blx	r4
	uint32_t i;
	uint32_t ul_last_sector_num;

	if (uc_sector_size == 0) {
  403f26:	4604      	mov	r4, r0
  403f28:	b918      	cbnz	r0, 403f32 <disk_read+0x1e>
		return RES_ERROR;
  403f2a:	2001      	movs	r0, #1
	return RES_OK;

#else
	return RES_ERROR;
#endif
}
  403f2c:	b003      	add	sp, #12
  403f2e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (uc_sector_size == 0) {
		return RES_ERROR;
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
  403f32:	4b13      	ldr	r3, [pc, #76]	; (403f80 <disk_read+0x6c>)
  403f34:	4648      	mov	r0, r9
  403f36:	a901      	add	r1, sp, #4
  403f38:	4798      	blx	r3
	if ((sector + count * uc_sector_size) >
			(ul_last_sector_num + 1) * uc_sector_size) {
  403f3a:	9b01      	ldr	r3, [sp, #4]
		return RES_ERROR;
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
	if ((sector + count * uc_sector_size) >
  403f3c:	fb18 f204 	smulbb	r2, r8, r4
			(ul_last_sector_num + 1) * uc_sector_size) {
  403f40:	fb03 4304 	mla	r3, r3, r4, r4
		return RES_ERROR;
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
	if ((sector + count * uc_sector_size) >
  403f44:	442a      	add	r2, r5
  403f46:	429a      	cmp	r2, r3
  403f48:	d903      	bls.n	403f52 <disk_read+0x3e>
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
  403f4a:	2004      	movs	r0, #4
	return RES_OK;

#else
	return RES_ERROR;
#endif
}
  403f4c:	b003      	add	sp, #12
  403f4e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
	}

	/* Read the data */
	for (i = 0; i < count; i++) {
  403f52:	f1b8 0f00 	cmp.w	r8, #0
  403f56:	d00f      	beq.n	403f78 <disk_read+0x64>
  403f58:	f8df b028 	ldr.w	fp, [pc, #40]	; 403f84 <disk_read+0x70>
  403f5c:	ea4f 2a44 	mov.w	sl, r4, lsl #9
  403f60:	2700      	movs	r7, #0
		if (memory_2_ram(drv, sector + uc_sector_size * i,
  403f62:	4629      	mov	r1, r5
  403f64:	4632      	mov	r2, r6
  403f66:	4648      	mov	r0, r9
  403f68:	47d8      	blx	fp
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
	}

	/* Read the data */
	for (i = 0; i < count; i++) {
  403f6a:	3701      	adds	r7, #1
  403f6c:	4425      	add	r5, r4
  403f6e:	4456      	add	r6, sl
		if (memory_2_ram(drv, sector + uc_sector_size * i,
  403f70:	2800      	cmp	r0, #0
  403f72:	d1da      	bne.n	403f2a <disk_read+0x16>
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
	}

	/* Read the data */
	for (i = 0; i < count; i++) {
  403f74:	4547      	cmp	r7, r8
  403f76:	d3f4      	bcc.n	403f62 <disk_read+0x4e>
				CTRL_GOOD) {
			return RES_ERROR;
		}
	}

	return RES_OK;
  403f78:	2000      	movs	r0, #0
  403f7a:	e7d7      	b.n	403f2c <disk_read+0x18>
  403f7c:	0040344d 	.word	0x0040344d
  403f80:	00403431 	.word	0x00403431
  403f84:	00403475 	.word	0x00403475

00403f88 <disk_write>:
 *
 * \return RES_OK for success, otherwise DRESULT error code.
 */
#if _READONLY == 0
DRESULT disk_write(BYTE drv, BYTE const *buff, DWORD sector, BYTE count)
{
  403f88:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if ACCESS_MEM_TO_RAM
	uint8_t uc_sector_size = mem_sector_size(drv);
  403f8c:	4c18      	ldr	r4, [pc, #96]	; (403ff0 <disk_write+0x68>)
 *
 * \return RES_OK for success, otherwise DRESULT error code.
 */
#if _READONLY == 0
DRESULT disk_write(BYTE drv, BYTE const *buff, DWORD sector, BYTE count)
{
  403f8e:	b083      	sub	sp, #12
  403f90:	460e      	mov	r6, r1
  403f92:	4615      	mov	r5, r2
  403f94:	4698      	mov	r8, r3
  403f96:	4681      	mov	r9, r0
#if ACCESS_MEM_TO_RAM
	uint8_t uc_sector_size = mem_sector_size(drv);
  403f98:	47a0      	blx	r4
	uint32_t i;
	uint32_t ul_last_sector_num;

	if (uc_sector_size == 0) {
  403f9a:	4604      	mov	r4, r0
  403f9c:	b918      	cbnz	r0, 403fa6 <disk_write+0x1e>
		return RES_ERROR;
  403f9e:	2001      	movs	r0, #1
	return RES_OK;

#else
	return RES_ERROR;
#endif
}
  403fa0:	b003      	add	sp, #12
  403fa2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (uc_sector_size == 0) {
		return RES_ERROR;
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
  403fa6:	4b13      	ldr	r3, [pc, #76]	; (403ff4 <disk_write+0x6c>)
  403fa8:	4648      	mov	r0, r9
  403faa:	a901      	add	r1, sp, #4
  403fac:	4798      	blx	r3
	if ((sector + count * uc_sector_size) >
			(ul_last_sector_num + 1) * uc_sector_size) {
  403fae:	9b01      	ldr	r3, [sp, #4]
		return RES_ERROR;
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
	if ((sector + count * uc_sector_size) >
  403fb0:	fb18 f204 	smulbb	r2, r8, r4
			(ul_last_sector_num + 1) * uc_sector_size) {
  403fb4:	fb03 4304 	mla	r3, r3, r4, r4
		return RES_ERROR;
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
	if ((sector + count * uc_sector_size) >
  403fb8:	442a      	add	r2, r5
  403fba:	429a      	cmp	r2, r3
  403fbc:	d903      	bls.n	403fc6 <disk_write+0x3e>
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
  403fbe:	2004      	movs	r0, #4
	return RES_OK;

#else
	return RES_ERROR;
#endif
}
  403fc0:	b003      	add	sp, #12
  403fc2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
	}

	/* Write the data */
	for (i = 0; i < count; i++) {
  403fc6:	f1b8 0f00 	cmp.w	r8, #0
  403fca:	d00f      	beq.n	403fec <disk_write+0x64>
  403fcc:	f8df b028 	ldr.w	fp, [pc, #40]	; 403ff8 <disk_write+0x70>
  403fd0:	ea4f 2a44 	mov.w	sl, r4, lsl #9
  403fd4:	2700      	movs	r7, #0
		if (ram_2_memory(drv, sector + uc_sector_size * i,
  403fd6:	4629      	mov	r1, r5
  403fd8:	4632      	mov	r2, r6
  403fda:	4648      	mov	r0, r9
  403fdc:	47d8      	blx	fp
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
	}

	/* Write the data */
	for (i = 0; i < count; i++) {
  403fde:	3701      	adds	r7, #1
  403fe0:	4425      	add	r5, r4
  403fe2:	4456      	add	r6, sl
		if (ram_2_memory(drv, sector + uc_sector_size * i,
  403fe4:	2800      	cmp	r0, #0
  403fe6:	d1da      	bne.n	403f9e <disk_write+0x16>
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
	}

	/* Write the data */
	for (i = 0; i < count; i++) {
  403fe8:	4547      	cmp	r7, r8
  403fea:	d3f4      	bcc.n	403fd6 <disk_write+0x4e>
				CTRL_GOOD) {
			return RES_ERROR;
		}
	}

	return RES_OK;
  403fec:	2000      	movs	r0, #0
  403fee:	e7d7      	b.n	403fa0 <disk_write+0x18>
  403ff0:	0040344d 	.word	0x0040344d
  403ff4:	00403431 	.word	0x00403431
  403ff8:	00403495 	.word	0x00403495

00403ffc <disk_ioctl>:
 * \param buff Buffer to send/receive control data.
 *
 * \return RES_OK for success, otherwise DRESULT error code.
 */
DRESULT disk_ioctl(BYTE drv, BYTE ctrl, void *buff)
{
  403ffc:	b510      	push	{r4, lr}
  403ffe:	4614      	mov	r4, r2
  404000:	b082      	sub	sp, #8
	DRESULT res = RES_PARERR;

	switch (ctrl) {
  404002:	2903      	cmp	r1, #3
  404004:	d829      	bhi.n	40405a <disk_ioctl+0x5e>
  404006:	e8df f001 	tbb	[pc, r1]
  40400a:	131c      	.short	0x131c
  40400c:	0207      	.short	0x0207
	case GET_BLOCK_SIZE:
		*(DWORD *)buff = 1;
  40400e:	2301      	movs	r3, #1
  404010:	6013      	str	r3, [r2, #0]
		res = RES_OK;
  404012:	2000      	movs	r0, #0
	default:
		res = RES_PARERR;
	}

	return res;
}
  404014:	b002      	add	sp, #8
  404016:	bd10      	pop	{r4, pc}
	break;

	/* Get sectors on the disk (WORD) */
	case GET_SECTOR_SIZE:
	{
		uint8_t uc_sector_size = mem_sector_size(drv);
  404018:	4b11      	ldr	r3, [pc, #68]	; (404060 <disk_ioctl+0x64>)
  40401a:	4798      	blx	r3

		if ((uc_sector_size != SECTOR_SIZE_512) &&
  40401c:	1e43      	subs	r3, r0, #1
  40401e:	b2db      	uxtb	r3, r3
  404020:	2b01      	cmp	r3, #1
  404022:	d916      	bls.n	404052 <disk_ioctl+0x56>
				(uc_sector_size != SECTOR_SIZE_1024) &&
  404024:	2804      	cmp	r0, #4
  404026:	d014      	beq.n	404052 <disk_ioctl+0x56>
				(uc_sector_size != SECTOR_SIZE_2048) &&
  404028:	2808      	cmp	r0, #8
  40402a:	d012      	beq.n	404052 <disk_ioctl+0x56>
				(uc_sector_size != SECTOR_SIZE_4096)) {
			/* The sector size is not supported by the FatFS */
			return RES_ERROR;
  40402c:	2001      	movs	r0, #1
  40402e:	e7f1      	b.n	404014 <disk_ioctl+0x18>
	case GET_SECTOR_COUNT:
	{
		uint32_t ul_last_sector_num;

		/* Check valid address */
		mem_read_capacity(drv, &ul_last_sector_num);
  404030:	a901      	add	r1, sp, #4
  404032:	4b0c      	ldr	r3, [pc, #48]	; (404064 <disk_ioctl+0x68>)
  404034:	4798      	blx	r3

		*(DWORD *)buff = ul_last_sector_num + 1;
  404036:	9b01      	ldr	r3, [sp, #4]

		res = RES_OK;
  404038:	2000      	movs	r0, #0
		uint32_t ul_last_sector_num;

		/* Check valid address */
		mem_read_capacity(drv, &ul_last_sector_num);

		*(DWORD *)buff = ul_last_sector_num + 1;
  40403a:	3301      	adds	r3, #1
  40403c:	6023      	str	r3, [r4, #0]
	default:
		res = RES_PARERR;
	}

	return res;
}
  40403e:	b002      	add	sp, #8
  404040:	bd10      	pop	{r4, pc}
	}
	break;

	/* Make sure that data has been written */
	case CTRL_SYNC:
		if (mem_test_unit_ready(drv) == CTRL_GOOD) {
  404042:	4b09      	ldr	r3, [pc, #36]	; (404068 <disk_ioctl+0x6c>)
  404044:	4798      	blx	r3
			res = RES_OK;
  404046:	2800      	cmp	r0, #0
  404048:	bf14      	ite	ne
  40404a:	2003      	movne	r0, #3
  40404c:	2000      	moveq	r0, #0
	default:
		res = RES_PARERR;
	}

	return res;
}
  40404e:	b002      	add	sp, #8
  404050:	bd10      	pop	{r4, pc}
				(uc_sector_size != SECTOR_SIZE_4096)) {
			/* The sector size is not supported by the FatFS */
			return RES_ERROR;
		}

		*(U8 *)buff = uc_sector_size * SECTOR_SIZE_DEFAULT;
  404052:	2000      	movs	r0, #0
  404054:	7020      	strb	r0, [r4, #0]
	default:
		res = RES_PARERR;
	}

	return res;
}
  404056:	b002      	add	sp, #8
  404058:	bd10      	pop	{r4, pc}
			res = RES_NOTRDY;
		}
		break;

	default:
		res = RES_PARERR;
  40405a:	2004      	movs	r0, #4
  40405c:	e7da      	b.n	404014 <disk_ioctl+0x18>
  40405e:	bf00      	nop
  404060:	0040344d 	.word	0x0040344d
  404064:	00403431 	.word	0x00403431
  404068:	00403419 	.word	0x00403419

0040406c <get_fattime>:
 * bit4:0    Second (0..59)
 *
 * \return Current time.
 */
uint32_t get_fattime(void)
{
  40406c:	b530      	push	{r4, r5, lr}
	uint32_t ul_time;
	uint32_t ul_hour, ul_minute, ul_second;
	uint32_t ul_year, ul_month, ul_day, ul_week;

	/* Retrieve date and time */
	rtc_get_time(RTC, &ul_hour, &ul_minute, &ul_second);
  40406e:	4c12      	ldr	r4, [pc, #72]	; (4040b8 <get_fattime+0x4c>)
  404070:	4d12      	ldr	r5, [pc, #72]	; (4040bc <get_fattime+0x50>)
 * bit4:0    Second (0..59)
 *
 * \return Current time.
 */
uint32_t get_fattime(void)
{
  404072:	b08b      	sub	sp, #44	; 0x2c
	uint32_t ul_time;
	uint32_t ul_hour, ul_minute, ul_second;
	uint32_t ul_year, ul_month, ul_day, ul_week;

	/* Retrieve date and time */
	rtc_get_time(RTC, &ul_hour, &ul_minute, &ul_second);
  404074:	4620      	mov	r0, r4
  404076:	a903      	add	r1, sp, #12
  404078:	aa04      	add	r2, sp, #16
  40407a:	ab05      	add	r3, sp, #20
  40407c:	47a8      	blx	r5
	rtc_get_date(RTC, &ul_year, &ul_month, &ul_day, &ul_week);
  40407e:	ab09      	add	r3, sp, #36	; 0x24
  404080:	4620      	mov	r0, r4
  404082:	9300      	str	r3, [sp, #0]
  404084:	a906      	add	r1, sp, #24
  404086:	aa07      	add	r2, sp, #28
  404088:	ab08      	add	r3, sp, #32
  40408a:	4c0d      	ldr	r4, [pc, #52]	; (4040c0 <get_fattime+0x54>)
  40408c:	47a0      	blx	r4

	ul_time = ((ul_year - 1980) << 25)
			| (ul_month << 21)
			| (ul_day << 16)
  40408e:	9d08      	ldr	r5, [sp, #32]
	/* Retrieve date and time */
	rtc_get_time(RTC, &ul_hour, &ul_minute, &ul_second);
	rtc_get_date(RTC, &ul_year, &ul_month, &ul_day, &ul_week);

	ul_time = ((ul_year - 1980) << 25)
			| (ul_month << 21)
  404090:	9c07      	ldr	r4, [sp, #28]
			| (ul_day << 16)
  404092:	9805      	ldr	r0, [sp, #20]
			| (ul_hour << 11)
  404094:	9903      	ldr	r1, [sp, #12]
			| (ul_minute << 5)
  404096:	9a04      	ldr	r2, [sp, #16]

	/* Retrieve date and time */
	rtc_get_time(RTC, &ul_hour, &ul_minute, &ul_second);
	rtc_get_date(RTC, &ul_year, &ul_month, &ul_day, &ul_week);

	ul_time = ((ul_year - 1980) << 25)
  404098:	9b06      	ldr	r3, [sp, #24]
			| (ul_month << 21)
			| (ul_day << 16)
  40409a:	042d      	lsls	r5, r5, #16
	/* Retrieve date and time */
	rtc_get_time(RTC, &ul_hour, &ul_minute, &ul_second);
	rtc_get_date(RTC, &ul_year, &ul_month, &ul_day, &ul_week);

	ul_time = ((ul_year - 1980) << 25)
			| (ul_month << 21)
  40409c:	ea45 5444 	orr.w	r4, r5, r4, lsl #21
			| (ul_day << 16)
  4040a0:	4320      	orrs	r0, r4
			| (ul_hour << 11)
  4040a2:	ea40 21c1 	orr.w	r1, r0, r1, lsl #11
			| (ul_minute << 5)
  4040a6:	ea41 1042 	orr.w	r0, r1, r2, lsl #5

	/* Retrieve date and time */
	rtc_get_time(RTC, &ul_hour, &ul_minute, &ul_second);
	rtc_get_date(RTC, &ul_year, &ul_month, &ul_day, &ul_week);

	ul_time = ((ul_year - 1980) << 25)
  4040aa:	f2a3 73bc 	subw	r3, r3, #1980	; 0x7bc
			| (ul_hour << 11)
			| (ul_minute << 5)
			| (ul_second << 0);

	return ul_time;
}
  4040ae:	ea40 6043 	orr.w	r0, r0, r3, lsl #25
  4040b2:	b00b      	add	sp, #44	; 0x2c
  4040b4:	bd30      	pop	{r4, r5, pc}
  4040b6:	bf00      	nop
  4040b8:	400e1460 	.word	0x400e1460
  4040bc:	00403ae5 	.word	0x00403ae5
  4040c0:	00403bd5 	.word	0x00403bd5

004040c4 <chk_lock>:
static
FRESULT chk_lock (	/* Check if the file can be accessed */
	DIR* dj,		/* Directory object pointing the file to be checked */
	int acc			/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
)
{
  4040c4:	b470      	push	{r4, r5, r6}
  4040c6:	4a19      	ldr	r2, [pc, #100]	; (40412c <chk_lock+0x68>)
	UINT i, be;

	/* Search file semaphore table */
	for (i = be = 0; i < _FS_SHARE; i++) {
  4040c8:	2600      	movs	r6, #0
  4040ca:	4633      	mov	r3, r6
		if (Files[i].fs) {	/* Existing entry */
  4040cc:	f852 4c08 	ldr.w	r4, [r2, #-8]
  4040d0:	b174      	cbz	r4, 4040f0 <chk_lock+0x2c>
			if (Files[i].fs == dj->fs &&	 	/* Check if the file matched with an open file */
  4040d2:	6805      	ldr	r5, [r0, #0]
  4040d4:	42ac      	cmp	r4, r5
  4040d6:	d010      	beq.n	4040fa <chk_lock+0x36>
)
{
	UINT i, be;

	/* Search file semaphore table */
	for (i = be = 0; i < _FS_SHARE; i++) {
  4040d8:	3301      	adds	r3, #1
  4040da:	2b03      	cmp	r3, #3
  4040dc:	f102 020c 	add.w	r2, r2, #12
  4040e0:	d1f4      	bne.n	4040cc <chk_lock+0x8>
		} else {			/* Blank entry */
			be++;
		}
	}
	if (i == _FS_SHARE)	/* The file is not opened */
		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new file? */
  4040e2:	b93e      	cbnz	r6, 4040f4 <chk_lock+0x30>
  4040e4:	2902      	cmp	r1, #2
  4040e6:	bf14      	ite	ne
  4040e8:	2012      	movne	r0, #18
  4040ea:	2000      	moveq	r0, #0

	/* The file has been opened. Reject any open against writing file and all write mode open */
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
}
  4040ec:	bc70      	pop	{r4, r5, r6}
  4040ee:	4770      	bx	lr
		if (Files[i].fs) {	/* Existing entry */
			if (Files[i].fs == dj->fs &&	 	/* Check if the file matched with an open file */
				Files[i].clu == dj->sclust &&
				Files[i].idx == dj->index) break;
		} else {			/* Blank entry */
			be++;
  4040f0:	3601      	adds	r6, #1
  4040f2:	e7f1      	b.n	4040d8 <chk_lock+0x14>
		}
	}
	if (i == _FS_SHARE)	/* The file is not opened */
		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new file? */
  4040f4:	2000      	movs	r0, #0

	/* The file has been opened. Reject any open against writing file and all write mode open */
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
}
  4040f6:	bc70      	pop	{r4, r5, r6}
  4040f8:	4770      	bx	lr
	UINT i, be;

	/* Search file semaphore table */
	for (i = be = 0; i < _FS_SHARE; i++) {
		if (Files[i].fs) {	/* Existing entry */
			if (Files[i].fs == dj->fs &&	 	/* Check if the file matched with an open file */
  4040fa:	f852 5c04 	ldr.w	r5, [r2, #-4]
  4040fe:	6884      	ldr	r4, [r0, #8]
  404100:	42a5      	cmp	r5, r4
  404102:	d1e9      	bne.n	4040d8 <chk_lock+0x14>
				Files[i].clu == dj->sclust &&
  404104:	8815      	ldrh	r5, [r2, #0]
  404106:	88c4      	ldrh	r4, [r0, #6]
  404108:	42a5      	cmp	r5, r4
  40410a:	d1e5      	bne.n	4040d8 <chk_lock+0x14>
	}
	if (i == _FS_SHARE)	/* The file is not opened */
		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new file? */

	/* The file has been opened. Reject any open against writing file and all write mode open */
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
  40410c:	b109      	cbz	r1, 404112 <chk_lock+0x4e>
  40410e:	2010      	movs	r0, #16
  404110:	e7ec      	b.n	4040ec <chk_lock+0x28>
  404112:	4a07      	ldr	r2, [pc, #28]	; (404130 <chk_lock+0x6c>)
  404114:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  404118:	eb02 0383 	add.w	r3, r2, r3, lsl #2
}
  40411c:	bc70      	pop	{r4, r5, r6}
	}
	if (i == _FS_SHARE)	/* The file is not opened */
		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new file? */

	/* The file has been opened. Reject any open against writing file and all write mode open */
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
  40411e:	895b      	ldrh	r3, [r3, #10]
  404120:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  404124:	bf14      	ite	ne
  404126:	2000      	movne	r0, #0
  404128:	2010      	moveq	r0, #16
}
  40412a:	4770      	bx	lr
  40412c:	200033a4 	.word	0x200033a4
  404130:	2000339c 	.word	0x2000339c

00404134 <get_fileinfo>:
static
void get_fileinfo (		/* No return code */
	DIR *dj,			/* Pointer to the directory object */
	FILINFO *fno	 	/* Pointer to the file information to be filled */
)
{
  404134:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	BYTE nt, *dir;
	TCHAR *p, c;


	p = fno->fname;
	if (dj->sect) {
  404138:	6903      	ldr	r3, [r0, #16]
static
void get_fileinfo (		/* No return code */
	DIR *dj,			/* Pointer to the directory object */
	FILINFO *fno	 	/* Pointer to the file information to be filled */
)
{
  40413a:	460e      	mov	r6, r1
	UINT i;
	BYTE nt, *dir;
	TCHAR *p, c;


	p = fno->fname;
  40413c:	f101 0509 	add.w	r5, r1, #9
	if (dj->sect) {
  404140:	2b00      	cmp	r3, #0
  404142:	d04e      	beq.n	4041e2 <get_fileinfo+0xae>
		dir = dj->dir;
  404144:	6944      	ldr	r4, [r0, #20]
		nt = dir[DIR_NTres];		/* NT flag */
  404146:	f894 c00c 	ldrb.w	ip, [r4, #12]
		for (i = 0; i < 8; i++) {	/* Copy name body */
			c = dir[i];
			if (c == ' ') break;
			if (c == NDDE) c = (TCHAR)DDE;
			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
  40414a:	f00c 0708 	and.w	r7, ip, #8
  40414e:	b2ff      	uxtb	r7, r7

	p = fno->fname;
	if (dj->sect) {
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
  404150:	2200      	movs	r2, #0
			c = dir[i];
  404152:	5ca3      	ldrb	r3, [r4, r2]
			if (c == ' ') break;
  404154:	2b20      	cmp	r3, #32

	p = fno->fname;
	if (dj->sect) {
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
  404156:	f102 0201 	add.w	r2, r2, #1
			c = dir[i];
			if (c == ' ') break;
  40415a:	d00d      	beq.n	404178 <get_fileinfo+0x44>
			if (c == NDDE) c = (TCHAR)DDE;
  40415c:	2b05      	cmp	r3, #5
  40415e:	bf08      	it	eq
  404160:	23e5      	moveq	r3, #229	; 0xe5
			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
  404162:	f1a3 0141 	sub.w	r1, r3, #65	; 0x41
  404166:	b11f      	cbz	r7, 404170 <get_fileinfo+0x3c>
  404168:	2919      	cmp	r1, #25
  40416a:	bf9c      	itt	ls
  40416c:	3320      	addls	r3, #32
  40416e:	b2db      	uxtbls	r3, r3

	p = fno->fname;
	if (dj->sect) {
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
  404170:	2a08      	cmp	r2, #8
			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
				c = (c << 8) | dir[++i];
			c = ff_convert(c, 1);
			if (!c) c = '?';
#endif
			*p++ = c;
  404172:	f805 3b01 	strb.w	r3, [r5], #1

	p = fno->fname;
	if (dj->sect) {
		dir = dj->dir;
		nt = dir[DIR_NTres];		/* NT flag */
		for (i = 0; i < 8; i++) {	/* Copy name body */
  404176:	d1ec      	bne.n	404152 <get_fileinfo+0x1e>
			c = ff_convert(c, 1);
			if (!c) c = '?';
#endif
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
  404178:	7a23      	ldrb	r3, [r4, #8]
  40417a:	2b20      	cmp	r3, #32
  40417c:	d01a      	beq.n	4041b4 <get_fileinfo+0x80>
			*p++ = '.';
  40417e:	4629      	mov	r1, r5
  404180:	232e      	movs	r3, #46	; 0x2e
			for (i = 8; i < 11; i++) {
				c = dir[i];
				if (c == ' ') break;
				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
  404182:	f00c 0c10 	and.w	ip, ip, #16
			if (!c) c = '?';
#endif
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
  404186:	f801 3b04 	strb.w	r3, [r1], #4
			for (i = 8; i < 11; i++) {
				c = dir[i];
				if (c == ' ') break;
				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
  40418a:	fa5f fc8c 	uxtb.w	ip, ip
			if (!c) c = '?';
#endif
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
  40418e:	3501      	adds	r5, #1
  404190:	1de2      	adds	r2, r4, #7
			for (i = 8; i < 11; i++) {
				c = dir[i];
  404192:	f812 3f01 	ldrb.w	r3, [r2, #1]!
				if (c == ' ') break;
  404196:	2b20      	cmp	r3, #32
				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
  404198:	f1a3 0741 	sub.w	r7, r3, #65	; 0x41
		}
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
			for (i = 8; i < 11; i++) {
				c = dir[i];
				if (c == ' ') break;
  40419c:	d00a      	beq.n	4041b4 <get_fileinfo+0x80>
				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
  40419e:	f1bc 0f00 	cmp.w	ip, #0
  4041a2:	d003      	beq.n	4041ac <get_fileinfo+0x78>
  4041a4:	2f19      	cmp	r7, #25
  4041a6:	bf9c      	itt	ls
  4041a8:	3320      	addls	r3, #32
  4041aa:	b2db      	uxtbls	r3, r3
				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
					c = (c << 8) | dir[++i];
				c = ff_convert(c, 1);
				if (!c) c = '?';
#endif
				*p++ = c;
  4041ac:	f805 3b01 	strb.w	r3, [r5], #1
#endif
			*p++ = c;
		}
		if (dir[8] != ' ') {		/* Copy name extension */
			*p++ = '.';
			for (i = 8; i < 11; i++) {
  4041b0:	428d      	cmp	r5, r1
  4041b2:	d1ee      	bne.n	404192 <get_fileinfo+0x5e>
				if (!c) c = '?';
#endif
				*p++ = c;
			}
		}
		fno->fattrib = dir[DIR_Attr];				/* Attribute */
  4041b4:	7ae3      	ldrb	r3, [r4, #11]
  4041b6:	7233      	strb	r3, [r6, #8]
		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
  4041b8:	7fa3      	ldrb	r3, [r4, #30]
  4041ba:	7fe7      	ldrb	r7, [r4, #31]
  4041bc:	7f21      	ldrb	r1, [r4, #28]
  4041be:	7f62      	ldrb	r2, [r4, #29]
  4041c0:	041b      	lsls	r3, r3, #16
  4041c2:	ea43 6307 	orr.w	r3, r3, r7, lsl #24
  4041c6:	430b      	orrs	r3, r1
  4041c8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  4041cc:	6033      	str	r3, [r6, #0]
		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
  4041ce:	7e62      	ldrb	r2, [r4, #25]
  4041d0:	7e23      	ldrb	r3, [r4, #24]
  4041d2:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  4041d6:	80b3      	strh	r3, [r6, #4]
		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
  4041d8:	7de2      	ldrb	r2, [r4, #23]
  4041da:	7da3      	ldrb	r3, [r4, #22]
  4041dc:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  4041e0:	80f3      	strh	r3, [r6, #6]
	}
	*p = 0;		/* Terminate SFN str by a \0 */
  4041e2:	2400      	movs	r4, #0
  4041e4:	702c      	strb	r4, [r5, #0]

#if _USE_LFN
	if (fno->lfname && fno->lfsize) {
  4041e6:	69b5      	ldr	r5, [r6, #24]
  4041e8:	b135      	cbz	r5, 4041f8 <get_fileinfo+0xc4>
  4041ea:	69f3      	ldr	r3, [r6, #28]
  4041ec:	b123      	cbz	r3, 4041f8 <get_fileinfo+0xc4>
		TCHAR *tp = fno->lfname;
		WCHAR w, *lfn;

		i = 0;
		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
  4041ee:	6903      	ldr	r3, [r0, #16]
  4041f0:	b923      	cbnz	r3, 4041fc <get_fileinfo+0xc8>
#if _USE_LFN
	if (fno->lfname && fno->lfsize) {
		TCHAR *tp = fno->lfname;
		WCHAR w, *lfn;

		i = 0;
  4041f2:	2400      	movs	r4, #0
#endif
				if (i >= fno->lfsize - 1) { i = 0; break; }	/* Buffer overflow, no LFN */
				tp[i++] = (TCHAR)w;
			}
		}
		tp[i] = 0;	/* Terminate the LFN str by a \0 */
  4041f4:	2300      	movs	r3, #0
  4041f6:	552b      	strb	r3, [r5, r4]
  4041f8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (fno->lfname && fno->lfsize) {
		TCHAR *tp = fno->lfname;
		WCHAR w, *lfn;

		i = 0;
		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
  4041fc:	8c02      	ldrh	r2, [r0, #32]
  4041fe:	f64f 73ff 	movw	r3, #65535	; 0xffff
  404202:	429a      	cmp	r2, r3
  404204:	d0f5      	beq.n	4041f2 <get_fileinfo+0xbe>
			lfn = dj->lfn;
  404206:	69c7      	ldr	r7, [r0, #28]
			while ((w = *lfn++) != 0) {			/* Get an LFN char */
  404208:	8838      	ldrh	r0, [r7, #0]
  40420a:	2800      	cmp	r0, #0
  40420c:	d0f1      	beq.n	4041f2 <get_fileinfo+0xbe>
  40420e:	f8df 802c 	ldr.w	r8, [pc, #44]	; 40423c <get_fileinfo+0x108>
  404212:	e00d      	b.n	404230 <get_fileinfo+0xfc>
				w = ff_convert(w, 0);			/* Unicode -> OEM conversion */
				if (!w) { i = 0; break; }		/* Could not convert, no LFN */
				if (_DF1S && w >= 0x100)		/* Put 1st byte if it is a DBC (always false on SBCS cfg) */
					tp[i++] = (TCHAR)(w >> 8);
#endif
				if (i >= fno->lfsize - 1) { i = 0; break; }	/* Buffer overflow, no LFN */
  404214:	69f3      	ldr	r3, [r6, #28]
  404216:	3b01      	subs	r3, #1
  404218:	429c      	cmp	r4, r3
				tp[i++] = (TCHAR)w;
  40421a:	f104 0401 	add.w	r4, r4, #1
  40421e:	eb05 0304 	add.w	r3, r5, r4
				w = ff_convert(w, 0);			/* Unicode -> OEM conversion */
				if (!w) { i = 0; break; }		/* Could not convert, no LFN */
				if (_DF1S && w >= 0x100)		/* Put 1st byte if it is a DBC (always false on SBCS cfg) */
					tp[i++] = (TCHAR)(w >> 8);
#endif
				if (i >= fno->lfsize - 1) { i = 0; break; }	/* Buffer overflow, no LFN */
  404222:	d2e6      	bcs.n	4041f2 <get_fileinfo+0xbe>
				tp[i++] = (TCHAR)w;
  404224:	f803 0c01 	strb.w	r0, [r3, #-1]
		WCHAR w, *lfn;

		i = 0;
		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
			lfn = dj->lfn;
			while ((w = *lfn++) != 0) {			/* Get an LFN char */
  404228:	f837 0014 	ldrh.w	r0, [r7, r4, lsl #1]
  40422c:	2800      	cmp	r0, #0
  40422e:	d0e1      	beq.n	4041f4 <get_fileinfo+0xc0>
#if !_LFN_UNICODE
				w = ff_convert(w, 0);			/* Unicode -> OEM conversion */
  404230:	2100      	movs	r1, #0
  404232:	47c0      	blx	r8
				if (!w) { i = 0; break; }		/* Could not convert, no LFN */
  404234:	2800      	cmp	r0, #0
  404236:	d1ed      	bne.n	404214 <get_fileinfo+0xe0>
  404238:	e7db      	b.n	4041f2 <get_fileinfo+0xbe>
  40423a:	bf00      	nop
  40423c:	00406529 	.word	0x00406529

00404240 <move_window>:
static
FRESULT move_window (
	FATFS *fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)					/* Move to zero only writes back dirty window */
{
  404240:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	DWORD wsect;


	wsect = fs->winsect;
  404244:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
	if (wsect != sector) {	/* Changed current window */
  404246:	428d      	cmp	r5, r1
static
FRESULT move_window (
	FATFS *fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)					/* Move to zero only writes back dirty window */
{
  404248:	4604      	mov	r4, r0
  40424a:	460e      	mov	r6, r1
	DWORD wsect;


	wsect = fs->winsect;
	if (wsect != sector) {	/* Changed current window */
  40424c:	d002      	beq.n	404254 <move_window+0x14>
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
  40424e:	7903      	ldrb	r3, [r0, #4]
  404250:	b973      	cbnz	r3, 404270 <move_window+0x30>
					disk_write(fs->drv, fs->win, wsect, 1);
				}
			}
		}
#endif
		if (sector) {
  404252:	b916      	cbnz	r6, 40425a <move_window+0x1a>
				return FR_DISK_ERR;
			fs->winsect = sector;
		}
	}

	return FR_OK;
  404254:	2000      	movs	r0, #0
  404256:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				}
			}
		}
#endif
		if (sector) {
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
  40425a:	7860      	ldrb	r0, [r4, #1]
  40425c:	4d17      	ldr	r5, [pc, #92]	; (4042bc <move_window+0x7c>)
  40425e:	f104 0130 	add.w	r1, r4, #48	; 0x30
  404262:	4632      	mov	r2, r6
  404264:	2301      	movs	r3, #1
  404266:	47a8      	blx	r5
  404268:	bb20      	cbnz	r0, 4042b4 <move_window+0x74>
				return FR_DISK_ERR;
			fs->winsect = sector;
  40426a:	62e6      	str	r6, [r4, #44]	; 0x2c
		}
	}

	return FR_OK;
}
  40426c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

	wsect = fs->winsect;
	if (wsect != sector) {	/* Changed current window */
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
  404270:	f100 0830 	add.w	r8, r0, #48	; 0x30
  404274:	4641      	mov	r1, r8
  404276:	7840      	ldrb	r0, [r0, #1]
  404278:	f8df 9044 	ldr.w	r9, [pc, #68]	; 4042c0 <move_window+0x80>
  40427c:	462a      	mov	r2, r5
  40427e:	2301      	movs	r3, #1
  404280:	47c8      	blx	r9
  404282:	b9b8      	cbnz	r0, 4042b4 <move_window+0x74>
				return FR_DISK_ERR;
			fs->wflag = 0;
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
  404284:	69e3      	ldr	r3, [r4, #28]
  404286:	6a22      	ldr	r2, [r4, #32]
	if (wsect != sector) {	/* Changed current window */
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
			fs->wflag = 0;
  404288:	7120      	strb	r0, [r4, #4]
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
  40428a:	441a      	add	r2, r3
  40428c:	4295      	cmp	r5, r2
  40428e:	d2e0      	bcs.n	404252 <move_window+0x12>
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
  404290:	78e7      	ldrb	r7, [r4, #3]
  404292:	2f01      	cmp	r7, #1
  404294:	d801      	bhi.n	40429a <move_window+0x5a>
  404296:	e7dc      	b.n	404252 <move_window+0x12>
  404298:	69e3      	ldr	r3, [r4, #28]
					wsect += fs->fsize;
  40429a:	441d      	add	r5, r3
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
			fs->wflag = 0;
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
  40429c:	3f01      	subs	r7, #1
					wsect += fs->fsize;
					disk_write(fs->drv, fs->win, wsect, 1);
  40429e:	462a      	mov	r2, r5
  4042a0:	7860      	ldrb	r0, [r4, #1]
  4042a2:	4641      	mov	r1, r8
  4042a4:	2301      	movs	r3, #1
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
			fs->wflag = 0;
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
  4042a6:	b2ff      	uxtb	r7, r7
					wsect += fs->fsize;
					disk_write(fs->drv, fs->win, wsect, 1);
  4042a8:	47c8      	blx	r9
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
			fs->wflag = 0;
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
  4042aa:	2f01      	cmp	r7, #1
  4042ac:	d1f4      	bne.n	404298 <move_window+0x58>
					disk_write(fs->drv, fs->win, wsect, 1);
				}
			}
		}
#endif
		if (sector) {
  4042ae:	2e00      	cmp	r6, #0
  4042b0:	d0d0      	beq.n	404254 <move_window+0x14>
  4042b2:	e7d2      	b.n	40425a <move_window+0x1a>
	wsect = fs->winsect;
	if (wsect != sector) {	/* Changed current window */
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
  4042b4:	2001      	movs	r0, #1
  4042b6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  4042ba:	bf00      	nop
  4042bc:	00403f15 	.word	0x00403f15
  4042c0:	00403f89 	.word	0x00403f89

004042c4 <sync>:
#if !_FS_READONLY
static
FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
	FATFS *fs	/* File system object */
)
{
  4042c4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	FRESULT res;


	res = move_window(fs, 0);
  4042c8:	2100      	movs	r1, #0
  4042ca:	4b31      	ldr	r3, [pc, #196]	; (404390 <sync+0xcc>)
#if !_FS_READONLY
static
FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
	FATFS *fs	/* File system object */
)
{
  4042cc:	4605      	mov	r5, r0
	FRESULT res;


	res = move_window(fs, 0);
  4042ce:	4798      	blx	r3
  4042d0:	4603      	mov	r3, r0
	if (res == FR_OK) {
  4042d2:	b950      	cbnz	r0, 4042ea <sync+0x26>
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
  4042d4:	782b      	ldrb	r3, [r5, #0]
  4042d6:	2b03      	cmp	r3, #3
  4042d8:	d00a      	beq.n	4042f0 <sync+0x2c>
			/* Write it into the FSInfo sector */
			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
			fs->fsi_flag = 0;
		}
		/* Make sure that no pending write process in the physical drive */
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
  4042da:	2100      	movs	r1, #0
  4042dc:	4b2d      	ldr	r3, [pc, #180]	; (404394 <sync+0xd0>)
  4042de:	7868      	ldrb	r0, [r5, #1]
  4042e0:	460a      	mov	r2, r1
  4042e2:	4798      	blx	r3
  4042e4:	1c03      	adds	r3, r0, #0
  4042e6:	bf18      	it	ne
  4042e8:	2301      	movne	r3, #1
			res = FR_DISK_ERR;
	}

	return res;
}
  4042ea:	4618      	mov	r0, r3
  4042ec:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}


	res = move_window(fs, 0);
	if (res == FR_OK) {
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
  4042f0:	796b      	ldrb	r3, [r5, #5]
  4042f2:	2b00      	cmp	r3, #0
  4042f4:	d0f1      	beq.n	4042da <sync+0x16>
			fs->winsect = 0;
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
  4042f6:	f105 0130 	add.w	r1, r5, #48	; 0x30

	res = move_window(fs, 0);
	if (res == FR_OK) {
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
  4042fa:	62e8      	str	r0, [r5, #44]	; 0x2c
}

/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;
  4042fc:	460b      	mov	r3, r1
  4042fe:	f505 720c 	add.w	r2, r5, #560	; 0x230

	while (cnt--)
		*d++ = (BYTE)val;
  404302:	f803 0b01 	strb.w	r0, [r3], #1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
  404306:	4293      	cmp	r3, r2
		*d++ = (BYTE)val;
  404308:	f04f 0400 	mov.w	r4, #0
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
  40430c:	d1f9      	bne.n	404302 <sync+0x3e>
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
  40430e:	692a      	ldr	r2, [r5, #16]
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
  404310:	68eb      	ldr	r3, [r5, #12]
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
  404312:	f885 2218 	strb.w	r2, [r5, #536]	; 0x218
  404316:	f3c2 2b07 	ubfx	fp, r2, #8, #8
  40431a:	ea4f 4a12 	mov.w	sl, r2, lsr #16
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
  40431e:	ea4f 4c13 	mov.w	ip, r3, lsr #16
  404322:	ea4f 6e13 	mov.w	lr, r3, lsr #24
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
  404326:	2052      	movs	r0, #82	; 0x52
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
  404328:	ea4f 6912 	mov.w	r9, r2, lsr #24
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
  40432c:	f3c3 2807 	ubfx	r8, r3, #8, #8
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
  404330:	2261      	movs	r2, #97	; 0x61
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
  404332:	26aa      	movs	r6, #170	; 0xaa
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
  404334:	f885 b219 	strb.w	fp, [r5, #537]	; 0x219
  404338:	f885 a21a 	strb.w	sl, [r5, #538]	; 0x21a
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
  40433c:	f04f 0b41 	mov.w	fp, #65	; 0x41
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
  404340:	f04f 0a72 	mov.w	sl, #114	; 0x72
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
  404344:	2755      	movs	r7, #85	; 0x55
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
  404346:	f885 321c 	strb.w	r3, [r5, #540]	; 0x21c
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
  40434a:	f885 622f 	strb.w	r6, [r5, #559]	; 0x22f
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
  40434e:	f885 0030 	strb.w	r0, [r5, #48]	; 0x30
  404352:	f885 0031 	strb.w	r0, [r5, #49]	; 0x31
  404356:	f885 2032 	strb.w	r2, [r5, #50]	; 0x32
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
  40435a:	f885 2217 	strb.w	r2, [r5, #535]	; 0x217
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
  40435e:	f885 921b 	strb.w	r9, [r5, #539]	; 0x21b
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
  404362:	f885 821d 	strb.w	r8, [r5, #541]	; 0x21d
  404366:	f885 c21e 	strb.w	ip, [r5, #542]	; 0x21e
  40436a:	f885 e21f 	strb.w	lr, [r5, #543]	; 0x21f
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
  40436e:	f885 722e 	strb.w	r7, [r5, #558]	; 0x22e
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
  404372:	f885 b033 	strb.w	fp, [r5, #51]	; 0x33
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
  404376:	f885 b216 	strb.w	fp, [r5, #534]	; 0x216
  40437a:	f885 a214 	strb.w	sl, [r5, #532]	; 0x214
  40437e:	f885 a215 	strb.w	sl, [r5, #533]	; 0x215
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
			/* Write it into the FSInfo sector */
			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
  404382:	7868      	ldrb	r0, [r5, #1]
  404384:	696a      	ldr	r2, [r5, #20]
  404386:	4e04      	ldr	r6, [pc, #16]	; (404398 <sync+0xd4>)
  404388:	2301      	movs	r3, #1
  40438a:	47b0      	blx	r6
			fs->fsi_flag = 0;
  40438c:	716c      	strb	r4, [r5, #5]
  40438e:	e7a4      	b.n	4042da <sync+0x16>
  404390:	00404241 	.word	0x00404241
  404394:	00403ffd 	.word	0x00403ffd
  404398:	00403f89 	.word	0x00403f89

0040439c <validate>:
static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	FATFS *fs,		/* Pointer to the file system object */
	WORD id			/* Member id of the target object to be checked */
)
{
  40439c:	b508      	push	{r3, lr}
	if (!fs || !fs->fs_type || fs->id != id)
  40439e:	b108      	cbz	r0, 4043a4 <validate+0x8>
  4043a0:	7803      	ldrb	r3, [r0, #0]
  4043a2:	b90b      	cbnz	r3, 4043a8 <validate+0xc>
		return FR_INVALID_OBJECT;
  4043a4:	2009      	movs	r0, #9

	if (disk_status(fs->drv) & STA_NOINIT)
		return FR_NOT_READY;

	return FR_OK;
}
  4043a6:	bd08      	pop	{r3, pc}
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	FATFS *fs,		/* Pointer to the file system object */
	WORD id			/* Member id of the target object to be checked */
)
{
	if (!fs || !fs->fs_type || fs->id != id)
  4043a8:	88c3      	ldrh	r3, [r0, #6]
  4043aa:	428b      	cmp	r3, r1
  4043ac:	d1fa      	bne.n	4043a4 <validate+0x8>
		return FR_INVALID_OBJECT;

	ENTER_FF(fs);		/* Lock file system */

	if (disk_status(fs->drv) & STA_NOINIT)
  4043ae:	4b04      	ldr	r3, [pc, #16]	; (4043c0 <validate+0x24>)
  4043b0:	7840      	ldrb	r0, [r0, #1]
  4043b2:	4798      	blx	r3
  4043b4:	f010 0f01 	tst.w	r0, #1
		return FR_NOT_READY;
  4043b8:	bf0c      	ite	eq
  4043ba:	2000      	moveq	r0, #0
  4043bc:	2003      	movne	r0, #3
  4043be:	bd08      	pop	{r3, pc}
  4043c0:	00403efd 	.word	0x00403efd

004043c4 <check_fs>:
static
BYTE check_fs (	/* 0:FAT-VBR, 1:Valid BR but not FAT, 2:Not a BR, 3:Disk error */
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
  4043c4:	b570      	push	{r4, r5, r6, lr}
  4043c6:	4604      	mov	r4, r0
  4043c8:	460a      	mov	r2, r1
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
  4043ca:	7840      	ldrb	r0, [r0, #1]
  4043cc:	4d1d      	ldr	r5, [pc, #116]	; (404444 <check_fs+0x80>)
  4043ce:	f104 0130 	add.w	r1, r4, #48	; 0x30
  4043d2:	2301      	movs	r3, #1
  4043d4:	47a8      	blx	r5
  4043d6:	b108      	cbz	r0, 4043dc <check_fs+0x18>
		return 3;
  4043d8:	2003      	movs	r0, #3
  4043da:	bd70      	pop	{r4, r5, r6, pc}
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
  4043dc:	f894 122f 	ldrb.w	r1, [r4, #559]	; 0x22f
  4043e0:	f894 222e 	ldrb.w	r2, [r4, #558]	; 0x22e
  4043e4:	4b18      	ldr	r3, [pc, #96]	; (404448 <check_fs+0x84>)
  4043e6:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  4043ea:	b212      	sxth	r2, r2
  4043ec:	429a      	cmp	r2, r3
  4043ee:	d001      	beq.n	4043f4 <check_fs+0x30>
		return 2;
  4043f0:	2002      	movs	r0, #2
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
		return 0;

	return 1;
}
  4043f2:	bd70      	pop	{r4, r5, r6, pc}
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
		return 3;
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
		return 2;

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
  4043f4:	f894 2068 	ldrb.w	r2, [r4, #104]	; 0x68
  4043f8:	f894 6069 	ldrb.w	r6, [r4, #105]	; 0x69
  4043fc:	f894 5066 	ldrb.w	r5, [r4, #102]	; 0x66
  404400:	f894 1067 	ldrb.w	r1, [r4, #103]	; 0x67
  404404:	4b11      	ldr	r3, [pc, #68]	; (40444c <check_fs+0x88>)
  404406:	0412      	lsls	r2, r2, #16
  404408:	ea42 6206 	orr.w	r2, r2, r6, lsl #24
  40440c:	432a      	orrs	r2, r5
  40440e:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  404412:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
  404416:	429a      	cmp	r2, r3
  404418:	d0eb      	beq.n	4043f2 <check_fs+0x2e>
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
  40441a:	f894 2084 	ldrb.w	r2, [r4, #132]	; 0x84
  40441e:	f894 5085 	ldrb.w	r5, [r4, #133]	; 0x85
  404422:	f894 1082 	ldrb.w	r1, [r4, #130]	; 0x82
  404426:	f894 0083 	ldrb.w	r0, [r4, #131]	; 0x83
  40442a:	0412      	lsls	r2, r2, #16
  40442c:	ea42 6205 	orr.w	r2, r2, r5, lsl #24
  404430:	430a      	orrs	r2, r1
  404432:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
  404436:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
		return 0;
  40443a:	1ac0      	subs	r0, r0, r3
  40443c:	bf18      	it	ne
  40443e:	2001      	movne	r0, #1
  404440:	bd70      	pop	{r4, r5, r6, pc}
  404442:	bf00      	nop
  404444:	00403f15 	.word	0x00403f15
  404448:	ffffaa55 	.word	0xffffaa55
  40444c:	00544146 	.word	0x00544146

00404450 <chk_mounted>:
FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
	FATFS **rfs,		/* Pointer to pointer to the found file system object */
	BYTE chk_wp			/* !=0: Check media write protection for write access */
)
{
  404450:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	BYTE fmt, b, pi, *tbl;
	UINT vol;
	DSTATUS stat;
	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
	WORD nrsv;
	const TCHAR *p = *path;
  404454:	6803      	ldr	r3, [r0, #0]
	FATFS *fs;

	/* Get logical drive number from the path name */
	vol = p[0] - '0';					/* Is there a drive number? */
  404456:	781c      	ldrb	r4, [r3, #0]
  404458:	3c30      	subs	r4, #48	; 0x30
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
  40445a:	2c09      	cmp	r4, #9
FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
	FATFS **rfs,		/* Pointer to pointer to the found file system object */
	BYTE chk_wp			/* !=0: Check media write protection for write access */
)
{
  40445c:	4615      	mov	r5, r2
	const TCHAR *p = *path;
	FATFS *fs;

	/* Get logical drive number from the path name */
	vol = p[0] - '0';					/* Is there a drive number? */
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
  40445e:	d802      	bhi.n	404466 <chk_mounted+0x16>
  404460:	785a      	ldrb	r2, [r3, #1]
  404462:	2a3a      	cmp	r2, #58	; 0x3a
  404464:	d015      	beq.n	404492 <chk_mounted+0x42>
	}

	/* Check if the file system object is valid or not */
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
		return FR_INVALID_DRIVE;
	*rfs = fs = FatFs[vol];				/* Return pointer to the corresponding file system object */
  404466:	4bbd      	ldr	r3, [pc, #756]	; (40475c <chk_mounted+0x30c>)
  404468:	681c      	ldr	r4, [r3, #0]
  40446a:	600c      	str	r4, [r1, #0]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
  40446c:	b174      	cbz	r4, 40448c <chk_mounted+0x3c>

	ENTER_FF(fs);						/* Lock file system */

	if (fs->fs_type) {					/* If the logical drive has been mounted */
  40446e:	7823      	ldrb	r3, [r4, #0]
  404470:	b1b3      	cbz	r3, 4044a0 <chk_mounted+0x50>
		stat = disk_status(fs->drv);
  404472:	4bbb      	ldr	r3, [pc, #748]	; (404760 <chk_mounted+0x310>)
  404474:	7860      	ldrb	r0, [r4, #1]
  404476:	4798      	blx	r3
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
  404478:	07c3      	lsls	r3, r0, #31
  40447a:	d411      	bmi.n	4044a0 <chk_mounted+0x50>
			if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
  40447c:	b305      	cbz	r5, 4044c0 <chk_mounted+0x70>
				return FR_WRITE_PROTECTED;
  40447e:	f010 0f04 	tst.w	r0, #4
  404482:	bf0c      	ite	eq
  404484:	2000      	moveq	r0, #0
  404486:	200a      	movne	r0, #10
  404488:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

	/* Check if the file system object is valid or not */
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
		return FR_INVALID_DRIVE;
	*rfs = fs = FatFs[vol];				/* Return pointer to the corresponding file system object */
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
  40448c:	200c      	movs	r0, #12
  40448e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	FATFS *fs;

	/* Get logical drive number from the path name */
	vol = p[0] - '0';					/* Is there a drive number? */
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
		p += 2; *path = p;				/* Return pointer to the path name */
  404492:	3302      	adds	r3, #2
  404494:	6003      	str	r3, [r0, #0]
		vol = 0;						/* Use drive 0 */
#endif
	}

	/* Check if the file system object is valid or not */
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
  404496:	2c00      	cmp	r4, #0
  404498:	d0e5      	beq.n	404466 <chk_mounted+0x16>
		return FR_INVALID_DRIVE;
  40449a:	200b      	movs	r0, #11
  40449c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
  4044a0:	2000      	movs	r0, #0
  4044a2:	7020      	strb	r0, [r4, #0]
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
  4044a4:	7060      	strb	r0, [r4, #1]
	stat = disk_initialize(fs->drv);	/* Initialize low level disk I/O layer */
  4044a6:	4baf      	ldr	r3, [pc, #700]	; (404764 <chk_mounted+0x314>)
  4044a8:	4798      	blx	r3
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
  4044aa:	07c7      	lsls	r7, r0, #31
  4044ac:	d502      	bpl.n	4044b4 <chk_mounted+0x64>
		return FR_NOT_READY;			/* Failed to initialize due to no media or hard error */
  4044ae:	2003      	movs	r0, #3
  4044b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check disk write protection if needed */
  4044b4:	b13d      	cbz	r5, 4044c6 <chk_mounted+0x76>
  4044b6:	0746      	lsls	r6, r0, #29
  4044b8:	d505      	bpl.n	4044c6 <chk_mounted+0x76>
		return FR_WRITE_PROTECTED;
  4044ba:	200a      	movs	r0, #10
  4044bc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (fs->fs_type) {					/* If the logical drive has been mounted */
		stat = disk_status(fs->drv);
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
			if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
				return FR_WRITE_PROTECTED;
			return FR_OK;				/* The file system object is valid */
  4044c0:	4628      	mov	r0, r5
  4044c2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
		return FR_DISK_ERR;
#endif
	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
  4044c6:	4620      	mov	r0, r4
  4044c8:	2100      	movs	r1, #0
  4044ca:	4da7      	ldr	r5, [pc, #668]	; (404768 <chk_mounted+0x318>)
  4044cc:	47a8      	blx	r5
	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
  4044ce:	2801      	cmp	r0, #1
  4044d0:	d007      	beq.n	4044e2 <chk_mounted+0x92>
#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
		return FR_DISK_ERR;
#endif
	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
  4044d2:	2600      	movs	r6, #0
		if (tbl[4]) {						/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
  4044d4:	2803      	cmp	r0, #3
  4044d6:	f000 80bf 	beq.w	404658 <chk_mounted+0x208>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
  4044da:	b1c0      	cbz	r0, 40450e <chk_mounted+0xbe>
  4044dc:	200d      	movs	r0, #13
  4044de:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
		/* Check the partition listed in the partition table */
		pi = LD2PT(vol);
		if (pi) pi--;
		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
		if (tbl[4]) {						/* Is the partition existing? */
  4044e2:	f894 31f2 	ldrb.w	r3, [r4, #498]	; 0x1f2
  4044e6:	2b00      	cmp	r3, #0
  4044e8:	d0f8      	beq.n	4044dc <chk_mounted+0x8c>
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
  4044ea:	f894 21f8 	ldrb.w	r2, [r4, #504]	; 0x1f8
  4044ee:	f894 11f9 	ldrb.w	r1, [r4, #505]	; 0x1f9
  4044f2:	f894 31f6 	ldrb.w	r3, [r4, #502]	; 0x1f6
  4044f6:	f894 61f7 	ldrb.w	r6, [r4, #503]	; 0x1f7
  4044fa:	0412      	lsls	r2, r2, #16
  4044fc:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
  404500:	4313      	orrs	r3, r2
  404502:	ea43 2606 	orr.w	r6, r3, r6, lsl #8
			fmt = check_fs(fs, bsect);		/* Check the partition */
  404506:	4631      	mov	r1, r6
  404508:	4620      	mov	r0, r4
  40450a:	47a8      	blx	r5
  40450c:	e7e2      	b.n	4044d4 <chk_mounted+0x84>
	if (fmt == 3) return FR_DISK_ERR;
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
  40450e:	f894 203c 	ldrb.w	r2, [r4, #60]	; 0x3c
  404512:	f894 303b 	ldrb.w	r3, [r4, #59]	; 0x3b
  404516:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  40451a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
  40451e:	d1dd      	bne.n	4044dc <chk_mounted+0x8c>
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
  404520:	f894 1047 	ldrb.w	r1, [r4, #71]	; 0x47
  404524:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
  404528:	ea53 2101 	orrs.w	r1, r3, r1, lsl #8
  40452c:	d10d      	bne.n	40454a <chk_mounted+0xfa>
  40452e:	f894 2056 	ldrb.w	r2, [r4, #86]	; 0x56
  404532:	f894 0057 	ldrb.w	r0, [r4, #87]	; 0x57
  404536:	f894 3054 	ldrb.w	r3, [r4, #84]	; 0x54
  40453a:	f894 1055 	ldrb.w	r1, [r4, #85]	; 0x55
  40453e:	0412      	lsls	r2, r2, #16
  404540:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
  404544:	4313      	orrs	r3, r2
  404546:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
  40454a:	f894 0040 	ldrb.w	r0, [r4, #64]	; 0x40
	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;
  40454e:	61e1      	str	r1, [r4, #28]

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
  404550:	1e43      	subs	r3, r0, #1
  404552:	2b01      	cmp	r3, #1

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
  404554:	70e0      	strb	r0, [r4, #3]
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
  404556:	d8c1      	bhi.n	4044dc <chk_mounted+0x8c>
	fasize *= b;										/* Number of sectors for FAT area */

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
  404558:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
  40455c:	70a3      	strb	r3, [r4, #2]
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
  40455e:	2b00      	cmp	r3, #0
  404560:	d0bc      	beq.n	4044dc <chk_mounted+0x8c>
  404562:	1e5a      	subs	r2, r3, #1
  404564:	421a      	tst	r2, r3
  404566:	d1b9      	bne.n	4044dc <chk_mounted+0x8c>

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
  404568:	f894 5042 	ldrb.w	r5, [r4, #66]	; 0x42
  40456c:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
  404570:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
  404574:	0715      	lsls	r5, r2, #28
	fasize *= b;										/* Number of sectors for FAT area */

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
  404576:	8122      	strh	r2, [r4, #8]
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
  404578:	d1b0      	bne.n	4044dc <chk_mounted+0x8c>

	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
  40457a:	f894 7044 	ldrb.w	r7, [r4, #68]	; 0x44
  40457e:	f894 5043 	ldrb.w	r5, [r4, #67]	; 0x43
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
  404582:	ea55 2507 	orrs.w	r5, r5, r7, lsl #8
  404586:	d10f      	bne.n	4045a8 <chk_mounted+0x158>
  404588:	f894 c052 	ldrb.w	ip, [r4, #82]	; 0x52
  40458c:	f894 8053 	ldrb.w	r8, [r4, #83]	; 0x53
  404590:	f894 5050 	ldrb.w	r5, [r4, #80]	; 0x50
  404594:	f894 7051 	ldrb.w	r7, [r4, #81]	; 0x51
  404598:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
  40459c:	ea4c 6c08 	orr.w	ip, ip, r8, lsl #24
  4045a0:	ea4c 0505 	orr.w	r5, ip, r5
  4045a4:	ea45 2507 	orr.w	r5, r5, r7, lsl #8

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
  4045a8:	f894 c03f 	ldrb.w	ip, [r4, #63]	; 0x3f
  4045ac:	f894 703e 	ldrb.w	r7, [r4, #62]	; 0x3e
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
  4045b0:	ea57 270c 	orrs.w	r7, r7, ip, lsl #8
  4045b4:	d092      	beq.n	4044dc <chk_mounted+0x8c>
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
	fasize *= b;										/* Number of sectors for FAT area */
  4045b6:	fb00 fc01 	mul.w	ip, r0, r1

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
  4045ba:	eb07 1012 	add.w	r0, r7, r2, lsr #4
  4045be:	4460      	add	r0, ip
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
  4045c0:	4285      	cmp	r5, r0
  4045c2:	d38b      	bcc.n	4044dc <chk_mounted+0x8c>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
  4045c4:	1a2d      	subs	r5, r5, r0
  4045c6:	fbb5 f3f3 	udiv	r3, r5, r3
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
  4045ca:	2b00      	cmp	r3, #0
  4045cc:	d086      	beq.n	4044dc <chk_mounted+0x8c>
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
  4045ce:	f640 75f5 	movw	r5, #4085	; 0xff5
  4045d2:	42ab      	cmp	r3, r5
  4045d4:	f240 80c0 	bls.w	404758 <chk_mounted+0x308>
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
  4045d8:	f64f 75f5 	movw	r5, #65525	; 0xfff5
  4045dc:	42ab      	cmp	r3, r5
  4045de:	f200 80a0 	bhi.w	404722 <chk_mounted+0x2d2>
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
  4045e2:	2502      	movs	r5, #2
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
  4045e4:	3302      	adds	r3, #2
	fs->database = bsect + sysect;						/* Data start sector */
  4045e6:	4430      	add	r0, r6
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
  4045e8:	4437      	add	r7, r6
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
  4045ea:	61a3      	str	r3, [r4, #24]
	fs->database = bsect + sysect;						/* Data start sector */
  4045ec:	62a0      	str	r0, [r4, #40]	; 0x28
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
  4045ee:	6227      	str	r7, [r4, #32]
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
  4045f0:	2a00      	cmp	r2, #0
  4045f2:	f43f af73 	beq.w	4044dc <chk_mounted+0x8c>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
  4045f6:	4467      	add	r7, ip
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
  4045f8:	2d02      	cmp	r5, #2
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
  4045fa:	6267      	str	r7, [r4, #36]	; 0x24
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
  4045fc:	f000 808f 	beq.w	40471e <chk_mounted+0x2ce>
  404600:	eb03 0243 	add.w	r2, r3, r3, lsl #1
  404604:	f003 0301 	and.w	r3, r3, #1
  404608:	eb03 0352 	add.w	r3, r3, r2, lsr #1
  40460c:	2501      	movs	r5, #1
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
  40460e:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
  404612:	ebb1 2f53 	cmp.w	r1, r3, lsr #9
  404616:	f4ff af61 	bcc.w	4044dc <chk_mounted+0x8c>
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->free_clust = 0xFFFFFFFF;
  40461a:	f04f 32ff 	mov.w	r2, #4294967295
	fs->last_clust = 0;
  40461e:	2300      	movs	r3, #0

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
  404620:	2d03      	cmp	r5, #3
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->free_clust = 0xFFFFFFFF;
  404622:	6122      	str	r2, [r4, #16]
	fs->last_clust = 0;
  404624:	60e3      	str	r3, [r4, #12]

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
  404626:	d01a      	beq.n	40465e <chk_mounted+0x20e>
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
	fs->id = ++Fsid;		/* File system mount ID */
  404628:	4e50      	ldr	r6, [pc, #320]	; (40476c <chk_mounted+0x31c>)
  40462a:	4951      	ldr	r1, [pc, #324]	; (404770 <chk_mounted+0x320>)
  40462c:	8830      	ldrh	r0, [r6, #0]
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
  40462e:	7025      	strb	r5, [r4, #0]
	fs->id = ++Fsid;		/* File system mount ID */
  404630:	3001      	adds	r0, #1
	fs->winsect = 0;		/* Invalidate sector cache */
  404632:	2200      	movs	r2, #0
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
	fs->id = ++Fsid;		/* File system mount ID */
  404634:	b280      	uxth	r0, r0
  404636:	8030      	strh	r0, [r6, #0]
  404638:	80e0      	strh	r0, [r4, #6]
	fs->winsect = 0;		/* Invalidate sector cache */
	fs->wflag = 0;
  40463a:	4613      	mov	r3, r2
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
	fs->id = ++Fsid;		/* File system mount ID */
	fs->winsect = 0;		/* Invalidate sector cache */
  40463c:	62e2      	str	r2, [r4, #44]	; 0x2c
	fs->wflag = 0;
  40463e:	7122      	strb	r2, [r4, #4]
)
{
	UINT i;

	for (i = 0; i < _FS_SHARE; i++) {
		if (Files[i].fs == fs) Files[i].fs = 0;
  404640:	4615      	mov	r5, r2
  404642:	4608      	mov	r0, r1
  404644:	58ca      	ldr	r2, [r1, r3]
  404646:	4294      	cmp	r4, r2
  404648:	bf08      	it	eq
  40464a:	501d      	streq	r5, [r3, r0]
  40464c:	330c      	adds	r3, #12
	FATFS *fs
)
{
	UINT i;

	for (i = 0; i < _FS_SHARE; i++) {
  40464e:	2b24      	cmp	r3, #36	; 0x24
  404650:	d1f8      	bne.n	404644 <chk_mounted+0x1f4>
#endif
#if _FS_SHARE				/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
  404652:	2000      	movs	r0, #0
  404654:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (tbl[4]) {						/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
  404658:	2001      	movs	r0, #1
  40465a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	fs->last_clust = 0;

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
  40465e:	f894 1061 	ldrb.w	r1, [r4, #97]	; 0x61
  404662:	f894 2060 	ldrb.w	r2, [r4, #96]	; 0x60
	fs->free_clust = 0xFFFFFFFF;
	fs->last_clust = 0;

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
  404666:	7163      	strb	r3, [r4, #5]
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
  404668:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  40466c:	4432      	add	r2, r6
  40466e:	6162      	str	r2, [r4, #20]
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
  404670:	7860      	ldrb	r0, [r4, #1]
  404672:	4e40      	ldr	r6, [pc, #256]	; (404774 <chk_mounted+0x324>)
  404674:	f104 0130 	add.w	r1, r4, #48	; 0x30
  404678:	2301      	movs	r3, #1
  40467a:	47b0      	blx	r6
  40467c:	2800      	cmp	r0, #0
  40467e:	d1d3      	bne.n	404628 <chk_mounted+0x1d8>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
  404680:	f894 122f 	ldrb.w	r1, [r4, #559]	; 0x22f
  404684:	f894 222e 	ldrb.w	r2, [r4, #558]	; 0x22e

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
  404688:	4b3b      	ldr	r3, [pc, #236]	; (404778 <chk_mounted+0x328>)
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
  40468a:	ea42 2201 	orr.w	r2, r2, r1, lsl #8

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
  40468e:	b212      	sxth	r2, r2
  404690:	429a      	cmp	r2, r3
  404692:	d1c9      	bne.n	404628 <chk_mounted+0x1d8>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
  404694:	f894 0032 	ldrb.w	r0, [r4, #50]	; 0x32
  404698:	f894 6033 	ldrb.w	r6, [r4, #51]	; 0x33
  40469c:	f894 2030 	ldrb.w	r2, [r4, #48]	; 0x30
  4046a0:	f894 1031 	ldrb.w	r1, [r4, #49]	; 0x31
	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
  4046a4:	4b35      	ldr	r3, [pc, #212]	; (40477c <chk_mounted+0x32c>)
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
  4046a6:	0400      	lsls	r0, r0, #16
  4046a8:	ea40 6006 	orr.w	r0, r0, r6, lsl #24
  4046ac:	4302      	orrs	r2, r0
  4046ae:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
  4046b2:	429a      	cmp	r2, r3
  4046b4:	d1b8      	bne.n	404628 <chk_mounted+0x1d8>
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
  4046b6:	f894 0216 	ldrb.w	r0, [r4, #534]	; 0x216
  4046ba:	f894 6217 	ldrb.w	r6, [r4, #535]	; 0x217
  4046be:	f894 2214 	ldrb.w	r2, [r4, #532]	; 0x214
  4046c2:	f894 1215 	ldrb.w	r1, [r4, #533]	; 0x215
  4046c6:	0400      	lsls	r0, r0, #16
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
  4046c8:	f103 53ff 	add.w	r3, r3, #534773760	; 0x1fe00000
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
  4046cc:	ea40 6006 	orr.w	r0, r0, r6, lsl #24
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
  4046d0:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
  4046d4:	4302      	orrs	r2, r0
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
  4046d6:	3320      	adds	r3, #32
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
  4046d8:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
  4046dc:	429a      	cmp	r2, r3
  4046de:	d1a3      	bne.n	404628 <chk_mounted+0x1d8>
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  4046e0:	f894 721e 	ldrb.w	r7, [r4, #542]	; 0x21e
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  4046e4:	f894 621a 	ldrb.w	r6, [r4, #538]	; 0x21a
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  4046e8:	f894 821f 	ldrb.w	r8, [r4, #543]	; 0x21f
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  4046ec:	f894 c21b 	ldrb.w	ip, [r4, #539]	; 0x21b
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  4046f0:	f894 221c 	ldrb.w	r2, [r4, #540]	; 0x21c
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  4046f4:	f894 3218 	ldrb.w	r3, [r4, #536]	; 0x218
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  4046f8:	f894 021d 	ldrb.w	r0, [r4, #541]	; 0x21d
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  4046fc:	f894 1219 	ldrb.w	r1, [r4, #537]	; 0x219
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  404700:	043f      	lsls	r7, r7, #16
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  404702:	0436      	lsls	r6, r6, #16
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  404704:	ea47 6708 	orr.w	r7, r7, r8, lsl #24
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  404708:	ea46 660c 	orr.w	r6, r6, ip, lsl #24
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  40470c:	433a      	orrs	r2, r7
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  40470e:	4333      	orrs	r3, r6
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  404710:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  404714:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  404718:	60e2      	str	r2, [r4, #12]
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  40471a:	6123      	str	r3, [r4, #16]
  40471c:	e784      	b.n	404628 <chk_mounted+0x1d8>
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
  40471e:	005b      	lsls	r3, r3, #1
  404720:	e775      	b.n	40460e <chk_mounted+0x1be>
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
  404722:	3302      	adds	r3, #2
	fs->database = bsect + sysect;						/* Data start sector */
  404724:	4430      	add	r0, r6
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
  404726:	4437      	add	r7, r6
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
  404728:	61a3      	str	r3, [r4, #24]
	fs->database = bsect + sysect;						/* Data start sector */
  40472a:	62a0      	str	r0, [r4, #40]	; 0x28
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
  40472c:	6227      	str	r7, [r4, #32]
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
  40472e:	2a00      	cmp	r2, #0
  404730:	f47f aed4 	bne.w	4044dc <chk_mounted+0x8c>
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
  404734:	f894 505e 	ldrb.w	r5, [r4, #94]	; 0x5e
  404738:	f894 705f 	ldrb.w	r7, [r4, #95]	; 0x5f
  40473c:	f894 205c 	ldrb.w	r2, [r4, #92]	; 0x5c
  404740:	f894 005d 	ldrb.w	r0, [r4, #93]	; 0x5d
  404744:	042d      	lsls	r5, r5, #16
  404746:	ea45 6507 	orr.w	r5, r5, r7, lsl #24
  40474a:	432a      	orrs	r2, r5
  40474c:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
  404750:	009b      	lsls	r3, r3, #2
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
	fs->database = bsect + sysect;						/* Data start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
  404752:	6262      	str	r2, [r4, #36]	; 0x24
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
  404754:	2503      	movs	r5, #3
  404756:	e75a      	b.n	40460e <chk_mounted+0x1be>
	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
  404758:	2501      	movs	r5, #1
  40475a:	e743      	b.n	4045e4 <chk_mounted+0x194>
  40475c:	200033c0 	.word	0x200033c0
  404760:	00403efd 	.word	0x00403efd
  404764:	00403eb9 	.word	0x00403eb9
  404768:	004043c5 	.word	0x004043c5
  40476c:	20003398 	.word	0x20003398
  404770:	2000339c 	.word	0x2000339c
  404774:	00403f15 	.word	0x00403f15
  404778:	ffffaa55 	.word	0xffffaa55
  40477c:	41615252 	.word	0x41615252

00404780 <get_fat.part.3>:
/*-----------------------------------------------------------------------*/
/* FAT access - Read value of a FAT entry                                */
/*-----------------------------------------------------------------------*/


static DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
  404780:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
		return 1;

	switch (fs->fs_type) {
  404784:	7803      	ldrb	r3, [r0, #0]
  404786:	2b02      	cmp	r3, #2
/*-----------------------------------------------------------------------*/
/* FAT access - Read value of a FAT entry                                */
/*-----------------------------------------------------------------------*/


static DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
  404788:	4604      	mov	r4, r0
  40478a:	460d      	mov	r5, r1


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
		return 1;

	switch (fs->fs_type) {
  40478c:	d048      	beq.n	404820 <get_fat.part.3+0xa0>
  40478e:	2b03      	cmp	r3, #3
  404790:	d029      	beq.n	4047e6 <get_fat.part.3+0x66>
  404792:	2b01      	cmp	r3, #1
  404794:	d003      	beq.n	40479e <get_fat.part.3+0x1e>
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
		p = &fs->win[clst * 4 % SS(fs)];
		return LD_DWORD(p) & 0x0FFFFFFF;
	}

	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
  404796:	f04f 30ff 	mov.w	r0, #4294967295
}
  40479a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return 1;

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
  40479e:	6a01      	ldr	r1, [r0, #32]
  4047a0:	4f29      	ldr	r7, [pc, #164]	; (404848 <get_fat.part.3+0xc8>)
	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
		return 1;

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
  4047a2:	eb05 0655 	add.w	r6, r5, r5, lsr #1
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
  4047a6:	eb01 2156 	add.w	r1, r1, r6, lsr #9
  4047aa:	47b8      	blx	r7
  4047ac:	2800      	cmp	r0, #0
  4047ae:	d1f2      	bne.n	404796 <get_fat.part.3+0x16>
		wc = fs->win[bc % SS(fs)]; bc++;
  4047b0:	f3c6 0308 	ubfx	r3, r6, #0, #9
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
  4047b4:	6a21      	ldr	r1, [r4, #32]

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc = fs->win[bc % SS(fs)]; bc++;
  4047b6:	4423      	add	r3, r4
  4047b8:	3601      	adds	r6, #1
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
  4047ba:	eb01 2156 	add.w	r1, r1, r6, lsr #9
  4047be:	4620      	mov	r0, r4

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc = fs->win[bc % SS(fs)]; bc++;
  4047c0:	f893 8030 	ldrb.w	r8, [r3, #48]	; 0x30
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
  4047c4:	47b8      	blx	r7
  4047c6:	2800      	cmp	r0, #0
  4047c8:	d1e5      	bne.n	404796 <get_fat.part.3+0x16>
		wc |= fs->win[bc % SS(fs)] << 8;
  4047ca:	f3c6 0608 	ubfx	r6, r6, #0, #9
  4047ce:	4434      	add	r4, r6
  4047d0:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
  4047d4:	ea48 2003 	orr.w	r0, r8, r3, lsl #8
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
  4047d8:	07eb      	lsls	r3, r5, #31
  4047da:	bf4c      	ite	mi
  4047dc:	0900      	lsrmi	r0, r0, #4
  4047de:	f3c0 000b 	ubfxpl	r0, r0, #0, #12
  4047e2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
		p = &fs->win[clst * 2 % SS(fs)];
		return LD_WORD(p);

	case FS_FAT32 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
  4047e6:	6a01      	ldr	r1, [r0, #32]
  4047e8:	4b17      	ldr	r3, [pc, #92]	; (404848 <get_fat.part.3+0xc8>)
  4047ea:	eb01 11d5 	add.w	r1, r1, r5, lsr #7
  4047ee:	4798      	blx	r3
  4047f0:	2800      	cmp	r0, #0
  4047f2:	d1d0      	bne.n	404796 <get_fat.part.3+0x16>
		p = &fs->win[clst * 4 % SS(fs)];
  4047f4:	00ad      	lsls	r5, r5, #2
  4047f6:	f405 75fe 	and.w	r5, r5, #508	; 0x1fc
  4047fa:	f105 0330 	add.w	r3, r5, #48	; 0x30
  4047fe:	4423      	add	r3, r4
		return LD_DWORD(p) & 0x0FFFFFFF;
  404800:	442c      	add	r4, r5
  404802:	78d8      	ldrb	r0, [r3, #3]
  404804:	7899      	ldrb	r1, [r3, #2]
  404806:	785a      	ldrb	r2, [r3, #1]
  404808:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
  40480c:	0600      	lsls	r0, r0, #24
  40480e:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
  404812:	ea40 2002 	orr.w	r0, r0, r2, lsl #8
  404816:	4318      	orrs	r0, r3
  404818:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000
  40481c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc |= fs->win[bc % SS(fs)] << 8;
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);

	case FS_FAT16 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
  404820:	6a01      	ldr	r1, [r0, #32]
  404822:	4b09      	ldr	r3, [pc, #36]	; (404848 <get_fat.part.3+0xc8>)
  404824:	eb01 2115 	add.w	r1, r1, r5, lsr #8
  404828:	4798      	blx	r3
  40482a:	2800      	cmp	r0, #0
  40482c:	d1b3      	bne.n	404796 <get_fat.part.3+0x16>
		p = &fs->win[clst * 2 % SS(fs)];
  40482e:	006d      	lsls	r5, r5, #1
  404830:	f405 75ff 	and.w	r5, r5, #510	; 0x1fe
		return LD_WORD(p);
  404834:	1963      	adds	r3, r4, r5
  404836:	461c      	mov	r4, r3
  404838:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
  40483c:	f894 0031 	ldrb.w	r0, [r4, #49]	; 0x31
  404840:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
  404844:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  404848:	00404241 	.word	0x00404241

0040484c <dir_sdi>:
static
FRESULT dir_sdi (
	DIR *dj,		/* Pointer to directory object */
	WORD idx		/* Directory index number */
)
{
  40484c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	DWORD clst;
	WORD ic;


	dj->index = idx;
	clst = dj->sclust;
  40484e:	6883      	ldr	r3, [r0, #8]
static
FRESULT dir_sdi (
	DIR *dj,		/* Pointer to directory object */
	WORD idx		/* Directory index number */
)
{
  404850:	4604      	mov	r4, r0
	WORD ic;


	dj->index = idx;
	clst = dj->sclust;
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
  404852:	2b01      	cmp	r3, #1
static
FRESULT dir_sdi (
	DIR *dj,		/* Pointer to directory object */
	WORD idx		/* Directory index number */
)
{
  404854:	460d      	mov	r5, r1
	DWORD clst;
	WORD ic;


	dj->index = idx;
  404856:	80e1      	strh	r1, [r4, #6]
	clst = dj->sclust;
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
  404858:	d003      	beq.n	404862 <dir_sdi+0x16>
  40485a:	6800      	ldr	r0, [r0, #0]
  40485c:	6982      	ldr	r2, [r0, #24]
  40485e:	4293      	cmp	r3, r2
  404860:	d301      	bcc.n	404866 <dir_sdi+0x1a>
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
  404862:	2002      	movs	r0, #2
  404864:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	dj->index = idx;
	clst = dj->sclust;
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
		return FR_INT_ERR;
	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
  404866:	b9b3      	cbnz	r3, 404896 <dir_sdi+0x4a>
  404868:	7803      	ldrb	r3, [r0, #0]
  40486a:	2b03      	cmp	r3, #3
  40486c:	d010      	beq.n	404890 <dir_sdi+0x44>
		clst = dj->fs->dirbase;

	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
		dj->clust = clst;
  40486e:	2300      	movs	r3, #0
  404870:	60e3      	str	r3, [r4, #12]
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
  404872:	8903      	ldrh	r3, [r0, #8]
  404874:	42ab      	cmp	r3, r5
  404876:	d9f4      	bls.n	404862 <dir_sdi+0x16>
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
  404878:	6a43      	ldr	r3, [r0, #36]	; 0x24
  40487a:	eb03 1315 	add.w	r3, r3, r5, lsr #4
  40487e:	6123      	str	r3, [r4, #16]
		}
		dj->clust = clst;
		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
  404880:	f005 050f 	and.w	r5, r5, #15
  404884:	eb00 1045 	add.w	r0, r0, r5, lsl #5
  404888:	3030      	adds	r0, #48	; 0x30
  40488a:	6160      	str	r0, [r4, #20]

	return FR_OK;	/* Seek succeeded */
  40488c:	2000      	movs	r0, #0
  40488e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	dj->index = idx;
	clst = dj->sclust;
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
		return FR_INT_ERR;
	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
		clst = dj->fs->dirbase;
  404890:	6a43      	ldr	r3, [r0, #36]	; 0x24

	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
  404892:	2b00      	cmp	r3, #0
  404894:	d0eb      	beq.n	40486e <dir_sdi+0x22>
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
  404896:	7886      	ldrb	r6, [r0, #2]
  404898:	0136      	lsls	r6, r6, #4
		while (idx >= ic) {	/* Follow cluster chain */
  40489a:	42b5      	cmp	r5, r6
  40489c:	d319      	bcc.n	4048d2 <dir_sdi+0x86>
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  40489e:	2b01      	cmp	r3, #1
  4048a0:	d9df      	bls.n	404862 <dir_sdi+0x16>
  4048a2:	1bad      	subs	r5, r5, r6
  4048a4:	429a      	cmp	r2, r3
  4048a6:	b2ad      	uxth	r5, r5
  4048a8:	d9db      	bls.n	404862 <dir_sdi+0x16>
  4048aa:	4f11      	ldr	r7, [pc, #68]	; (4048f0 <dir_sdi+0xa4>)
  4048ac:	e008      	b.n	4048c0 <dir_sdi+0x74>
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
  4048ae:	2801      	cmp	r0, #1
  4048b0:	d9d7      	bls.n	404862 <dir_sdi+0x16>
  4048b2:	6820      	ldr	r0, [r4, #0]
  4048b4:	6982      	ldr	r2, [r0, #24]
  4048b6:	429a      	cmp	r2, r3
  4048b8:	d9d3      	bls.n	404862 <dir_sdi+0x16>
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
  4048ba:	42ae      	cmp	r6, r5
  4048bc:	d809      	bhi.n	4048d2 <dir_sdi+0x86>
  4048be:	460d      	mov	r5, r1
  4048c0:	4619      	mov	r1, r3
  4048c2:	47b8      	blx	r7
  4048c4:	1ba9      	subs	r1, r5, r6
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
  4048c6:	1c42      	adds	r2, r0, #1
  4048c8:	4603      	mov	r3, r0
  4048ca:	b289      	uxth	r1, r1
  4048cc:	d1ef      	bne.n	4048ae <dir_sdi+0x62>
  4048ce:	2001      	movs	r0, #1
  4048d0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
			idx -= ic;
		}
		dj->clust = clst;
  4048d2:	60e3      	str	r3, [r4, #12]
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  4048d4:	6982      	ldr	r2, [r0, #24]
static DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
  4048d6:	3b02      	subs	r3, #2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  4048d8:	3a02      	subs	r2, #2
  4048da:	4293      	cmp	r3, r2
	return clst * fs->csize + fs->database;
  4048dc:	bf3b      	ittet	cc
  4048de:	7881      	ldrbcc	r1, [r0, #2]
  4048e0:	6a82      	ldrcc	r2, [r0, #40]	; 0x28
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  4048e2:	2300      	movcs	r3, #0
	return clst * fs->csize + fs->database;
  4048e4:	fb01 2303 	mlacc	r3, r1, r3, r2
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
			idx -= ic;
		}
		dj->clust = clst;
		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
  4048e8:	eb03 1315 	add.w	r3, r3, r5, lsr #4
  4048ec:	6123      	str	r3, [r4, #16]
  4048ee:	e7c7      	b.n	404880 <dir_sdi+0x34>
  4048f0:	00404781 	.word	0x00404781

004048f4 <put_fat.part.4>:
/*-----------------------------------------------------------------------*/
/* FAT access - Change value of a FAT entry                              */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY

static FRESULT put_fat (
  4048f4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
  4048f8:	7803      	ldrb	r3, [r0, #0]
  4048fa:	2b02      	cmp	r3, #2
/*-----------------------------------------------------------------------*/
/* FAT access - Change value of a FAT entry                              */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY

static FRESULT put_fat (
  4048fc:	4604      	mov	r4, r0
  4048fe:	460d      	mov	r5, r1
  404900:	4616      	mov	r6, r2

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
  404902:	d05b      	beq.n	4049bc <put_fat.part.4+0xc8>
  404904:	2b03      	cmp	r3, #3
  404906:	d039      	beq.n	40497c <put_fat.part.4+0x88>
  404908:	2b01      	cmp	r3, #1
  40490a:	d004      	beq.n	404916 <put_fat.part.4+0x22>
			val |= LD_DWORD(p) & 0xF0000000;
			ST_DWORD(p, val);
			break;

		default :
			res = FR_INT_ERR;
  40490c:	2002      	movs	r0, #2
		}
		fs->wflag = 1;
  40490e:	2301      	movs	r3, #1
  404910:	7123      	strb	r3, [r4, #4]
	}

	return res;
}
  404912:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

	} else {
		switch (fs->fs_type) {
		case FS_FAT12 :
			bc = clst; bc += bc / 2;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
  404916:	6a01      	ldr	r1, [r0, #32]
  404918:	f8df 80d4 	ldr.w	r8, [pc, #212]	; 4049f0 <put_fat.part.4+0xfc>
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
		case FS_FAT12 :
			bc = clst; bc += bc / 2;
  40491c:	eb05 0755 	add.w	r7, r5, r5, lsr #1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
  404920:	eb01 2157 	add.w	r1, r1, r7, lsr #9
  404924:	47c0      	blx	r8
			if (res != FR_OK) break;
  404926:	2800      	cmp	r0, #0
  404928:	d1f1      	bne.n	40490e <put_fat.part.4+0x1a>
			p = &fs->win[bc % SS(fs)];
  40492a:	f3c7 0308 	ubfx	r3, r7, #0, #9
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
  40492e:	f015 0501 	ands.w	r5, r5, #1
  404932:	4423      	add	r3, r4
  404934:	b2f2      	uxtb	r2, r6
  404936:	d006      	beq.n	404946 <put_fat.part.4+0x52>
  404938:	f893 1030 	ldrb.w	r1, [r3, #48]	; 0x30
  40493c:	f001 010f 	and.w	r1, r1, #15
  404940:	ea41 1202 	orr.w	r2, r1, r2, lsl #4
  404944:	b2d2      	uxtb	r2, r2
  404946:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
			bc++;
			fs->wflag = 1;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
  40494a:	6a21      	ldr	r1, [r4, #32]
			bc = clst; bc += bc / 2;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
			if (res != FR_OK) break;
			p = &fs->win[bc % SS(fs)];
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
			bc++;
  40494c:	3701      	adds	r7, #1
			fs->wflag = 1;
  40494e:	2301      	movs	r3, #1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
  404950:	eb01 2157 	add.w	r1, r1, r7, lsr #9
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
			if (res != FR_OK) break;
			p = &fs->win[bc % SS(fs)];
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
			bc++;
			fs->wflag = 1;
  404954:	7123      	strb	r3, [r4, #4]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
  404956:	4620      	mov	r0, r4
  404958:	47c0      	blx	r8
			if (res != FR_OK) break;
  40495a:	2800      	cmp	r0, #0
  40495c:	d1d7      	bne.n	40490e <put_fat.part.4+0x1a>
			p = &fs->win[bc % SS(fs)];
  40495e:	f3c7 0708 	ubfx	r7, r7, #0, #9
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
  404962:	2d00      	cmp	r5, #0
  404964:	d13f      	bne.n	4049e6 <put_fat.part.4+0xf2>
  404966:	4427      	add	r7, r4
  404968:	f3c6 2603 	ubfx	r6, r6, #8, #4
  40496c:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
  404970:	f023 030f 	bic.w	r3, r3, #15
  404974:	431e      	orrs	r6, r3
  404976:	f887 6030 	strb.w	r6, [r7, #48]	; 0x30
  40497a:	e7c8      	b.n	40490e <put_fat.part.4+0x1a>
			p = &fs->win[clst * 2 % SS(fs)];
			ST_WORD(p, (WORD)val);
			break;

		case FS_FAT32 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
  40497c:	6a01      	ldr	r1, [r0, #32]
  40497e:	4b1c      	ldr	r3, [pc, #112]	; (4049f0 <put_fat.part.4+0xfc>)
  404980:	eb01 11d5 	add.w	r1, r1, r5, lsr #7
  404984:	4798      	blx	r3
			if (res != FR_OK) break;
  404986:	2800      	cmp	r0, #0
  404988:	d1c1      	bne.n	40490e <put_fat.part.4+0x1a>
			p = &fs->win[clst * 4 % SS(fs)];
  40498a:	00ad      	lsls	r5, r5, #2
  40498c:	f405 75fe 	and.w	r5, r5, #508	; 0x1fc
  404990:	f105 0330 	add.w	r3, r5, #48	; 0x30
  404994:	4423      	add	r3, r4
			val |= LD_DWORD(p) & 0xF0000000;
  404996:	4425      	add	r5, r4
  404998:	78da      	ldrb	r2, [r3, #3]
  40499a:	0612      	lsls	r2, r2, #24
  40499c:	f002 4270 	and.w	r2, r2, #4026531840	; 0xf0000000
  4049a0:	4316      	orrs	r6, r2
			ST_DWORD(p, val);
  4049a2:	f3c6 2707 	ubfx	r7, r6, #8, #8
  4049a6:	0c31      	lsrs	r1, r6, #16
  4049a8:	0e32      	lsrs	r2, r6, #24
  4049aa:	f885 6030 	strb.w	r6, [r5, #48]	; 0x30
  4049ae:	705f      	strb	r7, [r3, #1]
  4049b0:	7099      	strb	r1, [r3, #2]
  4049b2:	70da      	strb	r2, [r3, #3]
			break;

		default :
			res = FR_INT_ERR;
		}
		fs->wflag = 1;
  4049b4:	2301      	movs	r3, #1
  4049b6:	7123      	strb	r3, [r4, #4]
	}

	return res;
}
  4049b8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			p = &fs->win[bc % SS(fs)];
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
			break;

		case FS_FAT16 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
  4049bc:	6a01      	ldr	r1, [r0, #32]
  4049be:	4b0c      	ldr	r3, [pc, #48]	; (4049f0 <put_fat.part.4+0xfc>)
  4049c0:	eb01 2115 	add.w	r1, r1, r5, lsr #8
  4049c4:	4798      	blx	r3
			if (res != FR_OK) break;
  4049c6:	2800      	cmp	r0, #0
  4049c8:	d1a1      	bne.n	40490e <put_fat.part.4+0x1a>
			p = &fs->win[clst * 2 % SS(fs)];
  4049ca:	006d      	lsls	r5, r5, #1
  4049cc:	f405 75ff 	and.w	r5, r5, #510	; 0x1fe
			ST_WORD(p, (WORD)val);
  4049d0:	1962      	adds	r2, r4, r5
  4049d2:	f3c6 2307 	ubfx	r3, r6, #8, #8
  4049d6:	f882 3031 	strb.w	r3, [r2, #49]	; 0x31
			break;

		default :
			res = FR_INT_ERR;
		}
		fs->wflag = 1;
  4049da:	2301      	movs	r3, #1

		case FS_FAT16 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
			if (res != FR_OK) break;
			p = &fs->win[clst * 2 % SS(fs)];
			ST_WORD(p, (WORD)val);
  4049dc:	f882 6030 	strb.w	r6, [r2, #48]	; 0x30
			break;

		default :
			res = FR_INT_ERR;
		}
		fs->wflag = 1;
  4049e0:	7123      	strb	r3, [r4, #4]
	}

	return res;
}
  4049e2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			bc++;
			fs->wflag = 1;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
			if (res != FR_OK) break;
			p = &fs->win[bc % SS(fs)];
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
  4049e6:	f3c6 1607 	ubfx	r6, r6, #4, #8
  4049ea:	4427      	add	r7, r4
  4049ec:	e7c3      	b.n	404976 <put_fat.part.4+0x82>
  4049ee:	bf00      	nop
  4049f0:	00404241 	.word	0x00404241

004049f4 <create_chain>:
static
DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
	FATFS *fs,			/* File system object */
	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
)
{
  4049f4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  4049f8:	4605      	mov	r5, r0
	DWORD cs, ncl, scl;
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
  4049fa:	4688      	mov	r8, r1
  4049fc:	bb01      	cbnz	r1, 404a40 <create_chain+0x4c>
		scl = fs->last_clust;			/* Get suggested start point */
  4049fe:	68c6      	ldr	r6, [r0, #12]
  404a00:	6983      	ldr	r3, [r0, #24]
		if (!scl || scl >= fs->n_fatent) scl = 1;
  404a02:	b35e      	cbz	r6, 404a5c <create_chain+0x68>
  404a04:	429e      	cmp	r6, r3
  404a06:	bf28      	it	cs
  404a08:	2601      	movcs	r6, #1
  404a0a:	4f2e      	ldr	r7, [pc, #184]	; (404ac4 <create_chain+0xd0>)
  404a0c:	4634      	mov	r4, r6
  404a0e:	e00f      	b.n	404a30 <create_chain+0x3c>
	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
  404a10:	2e01      	cmp	r6, #1
  404a12:	d925      	bls.n	404a60 <create_chain+0x6c>
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  404a14:	2b02      	cmp	r3, #2
  404a16:	d910      	bls.n	404a3a <create_chain+0x46>

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
  404a18:	2402      	movs	r4, #2
  404a1a:	4628      	mov	r0, r5
  404a1c:	4621      	mov	r1, r4
  404a1e:	47b8      	blx	r7
			if (ncl > scl) return 0;	/* No free cluster */
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
		if (cs == 0) break;				/* Found a free cluster */
  404a20:	b338      	cbz	r0, 404a72 <create_chain+0x7e>
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
  404a22:	1c41      	adds	r1, r0, #1
  404a24:	d021      	beq.n	404a6a <create_chain+0x76>
  404a26:	2801      	cmp	r0, #1
  404a28:	d007      	beq.n	404a3a <create_chain+0x46>
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
  404a2a:	42a6      	cmp	r6, r4
  404a2c:	d018      	beq.n	404a60 <create_chain+0x6c>
  404a2e:	69ab      	ldr	r3, [r5, #24]
		scl = clst;
	}

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
  404a30:	3401      	adds	r4, #1
		if (ncl >= fs->n_fatent) {		/* Wrap around */
  404a32:	429c      	cmp	r4, r3
  404a34:	d2ec      	bcs.n	404a10 <create_chain+0x1c>
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  404a36:	2c01      	cmp	r4, #1
  404a38:	d8ef      	bhi.n	404a1a <create_chain+0x26>
		if (fs->free_clust != 0xFFFFFFFF) {
			fs->free_clust--;
			fs->fsi_flag = 1;
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
  404a3a:	2001      	movs	r0, #1
	}

	return ncl;		/* Return new cluster number or error code */
}
  404a3c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  404a40:	2901      	cmp	r1, #1
  404a42:	d9fa      	bls.n	404a3a <create_chain+0x46>
  404a44:	6983      	ldr	r3, [r0, #24]
  404a46:	4299      	cmp	r1, r3
  404a48:	d2f7      	bcs.n	404a3a <create_chain+0x46>
  404a4a:	4b1e      	ldr	r3, [pc, #120]	; (404ac4 <create_chain+0xd0>)
  404a4c:	4798      	blx	r3
		scl = fs->last_clust;			/* Get suggested start point */
		if (!scl || scl >= fs->n_fatent) scl = 1;
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
		if (cs < 2) return 1;			/* It is an invalid cluster */
  404a4e:	2801      	cmp	r0, #1
  404a50:	d9f3      	bls.n	404a3a <create_chain+0x46>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
  404a52:	69ab      	ldr	r3, [r5, #24]
  404a54:	4283      	cmp	r3, r0
  404a56:	d8f1      	bhi.n	404a3c <create_chain+0x48>
  404a58:	4646      	mov	r6, r8
  404a5a:	e7d6      	b.n	404a0a <create_chain+0x16>
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
		scl = fs->last_clust;			/* Get suggested start point */
		if (!scl || scl >= fs->n_fatent) scl = 1;
  404a5c:	2601      	movs	r6, #1
  404a5e:	e7d4      	b.n	404a0a <create_chain+0x16>
	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
  404a60:	2000      	movs	r0, #0
  404a62:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (fs->free_clust != 0xFFFFFFFF) {
			fs->free_clust--;
			fs->fsi_flag = 1;
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
  404a66:	2801      	cmp	r0, #1
  404a68:	d1e7      	bne.n	404a3a <create_chain+0x46>
  404a6a:	f04f 30ff 	mov.w	r0, #4294967295
  404a6e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
  404a72:	69ab      	ldr	r3, [r5, #24]
  404a74:	42a3      	cmp	r3, r4
  404a76:	d9e0      	bls.n	404a3a <create_chain+0x46>
  404a78:	4628      	mov	r0, r5
  404a7a:	4621      	mov	r1, r4
  404a7c:	f06f 4270 	mvn.w	r2, #4026531840	; 0xf0000000
  404a80:	4e11      	ldr	r6, [pc, #68]	; (404ac8 <create_chain+0xd4>)
  404a82:	47b0      	blx	r6
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
	}

	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
	if (res == FR_OK && clst != 0) {
  404a84:	2800      	cmp	r0, #0
  404a86:	d1ee      	bne.n	404a66 <create_chain+0x72>
  404a88:	f1b8 0f00 	cmp.w	r8, #0
  404a8c:	d00b      	beq.n	404aa6 <create_chain+0xb2>
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
  404a8e:	f1b8 0f01 	cmp.w	r8, #1
  404a92:	d9d2      	bls.n	404a3a <create_chain+0x46>
  404a94:	69ab      	ldr	r3, [r5, #24]
  404a96:	4598      	cmp	r8, r3
  404a98:	d2cf      	bcs.n	404a3a <create_chain+0x46>
  404a9a:	4641      	mov	r1, r8
  404a9c:	4628      	mov	r0, r5
  404a9e:	4622      	mov	r2, r4
  404aa0:	47b0      	blx	r6

	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
	if (res == FR_OK && clst != 0) {
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
	}
	if (res == FR_OK) {
  404aa2:	2800      	cmp	r0, #0
  404aa4:	d1df      	bne.n	404a66 <create_chain+0x72>
		fs->last_clust = ncl;			/* Update FSINFO */
		if (fs->free_clust != 0xFFFFFFFF) {
  404aa6:	692b      	ldr	r3, [r5, #16]
	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
	if (res == FR_OK && clst != 0) {
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
	}
	if (res == FR_OK) {
		fs->last_clust = ncl;			/* Update FSINFO */
  404aa8:	60ec      	str	r4, [r5, #12]
		if (fs->free_clust != 0xFFFFFFFF) {
  404aaa:	1c5a      	adds	r2, r3, #1
  404aac:	d006      	beq.n	404abc <create_chain+0xc8>
			fs->free_clust--;
  404aae:	3b01      	subs	r3, #1
			fs->fsi_flag = 1;
  404ab0:	2201      	movs	r2, #1
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
	}
	if (res == FR_OK) {
		fs->last_clust = ncl;			/* Update FSINFO */
		if (fs->free_clust != 0xFFFFFFFF) {
			fs->free_clust--;
  404ab2:	612b      	str	r3, [r5, #16]
			fs->fsi_flag = 1;
  404ab4:	716a      	strb	r2, [r5, #5]
  404ab6:	4620      	mov	r0, r4
  404ab8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  404abc:	4620      	mov	r0, r4
  404abe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  404ac2:	bf00      	nop
  404ac4:	00404781 	.word	0x00404781
  404ac8:	004048f5 	.word	0x004048f5

00404acc <dir_next>:
static
FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
	DIR *dj,		/* Pointer to directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
  404acc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	DWORD clst;
	WORD i;


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
  404ad0:	88c5      	ldrh	r5, [r0, #6]
  404ad2:	3501      	adds	r5, #1
  404ad4:	b2ad      	uxth	r5, r5
static
FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
	DIR *dj,		/* Pointer to directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
  404ad6:	4604      	mov	r4, r0
  404ad8:	460e      	mov	r6, r1
	WORD i;


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
  404ada:	b915      	cbnz	r5, 404ae2 <dir_next+0x16>
		return FR_NO_FILE;
  404adc:	2004      	movs	r0, #4
  404ade:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	WORD i;


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
  404ae2:	6903      	ldr	r3, [r0, #16]
  404ae4:	2b00      	cmp	r3, #0
  404ae6:	d0f9      	beq.n	404adc <dir_next+0x10>
		return FR_NO_FILE;

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
  404ae8:	f015 070f 	ands.w	r7, r5, #15
  404aec:	d008      	beq.n	404b00 <dir_next+0x34>
  404aee:	6800      	ldr	r0, [r0, #0]
			}
		}
	}

	dj->index = i;
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
  404af0:	eb00 1347 	add.w	r3, r0, r7, lsl #5
  404af4:	3330      	adds	r3, #48	; 0x30
  404af6:	6163      	str	r3, [r4, #20]
				dj->sect = clust2sect(dj->fs, clst);
			}
		}
	}

	dj->index = i;
  404af8:	80e5      	strh	r5, [r4, #6]
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;

	return FR_OK;
  404afa:	2000      	movs	r0, #0
  404afc:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return FR_NO_FILE;

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
		dj->sect++;					/* Next sector */

		if (dj->clust == 0) {	/* Static table */
  404b00:	68c1      	ldr	r1, [r0, #12]
	i = dj->index + 1;
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
		return FR_NO_FILE;

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
		dj->sect++;					/* Next sector */
  404b02:	3301      	adds	r3, #1
  404b04:	6103      	str	r3, [r0, #16]

		if (dj->clust == 0) {	/* Static table */
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
  404b06:	6800      	ldr	r0, [r0, #0]
		return FR_NO_FILE;

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
		dj->sect++;					/* Next sector */

		if (dj->clust == 0) {	/* Static table */
  404b08:	b161      	cbz	r1, 404b24 <dir_next+0x58>
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
  404b0a:	7882      	ldrb	r2, [r0, #2]
  404b0c:	3a01      	subs	r2, #1
  404b0e:	ea12 1215 	ands.w	r2, r2, r5, lsr #4
  404b12:	d1ed      	bne.n	404af0 <dir_next+0x24>
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  404b14:	2901      	cmp	r1, #1
  404b16:	d902      	bls.n	404b1e <dir_next+0x52>
  404b18:	6982      	ldr	r2, [r0, #24]
  404b1a:	4291      	cmp	r1, r2
  404b1c:	d306      	bcc.n	404b2c <dir_next+0x60>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
				if (clst <= 1) return FR_INT_ERR;
  404b1e:	2002      	movs	r0, #2
  404b20:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
		dj->sect++;					/* Next sector */

		if (dj->clust == 0) {	/* Static table */
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
  404b24:	8902      	ldrh	r2, [r0, #8]
  404b26:	42aa      	cmp	r2, r5
  404b28:	d9d8      	bls.n	404adc <dir_next+0x10>
  404b2a:	e7e1      	b.n	404af0 <dir_next+0x24>
  404b2c:	4b34      	ldr	r3, [pc, #208]	; (404c00 <dir_next+0x134>)
  404b2e:	4798      	blx	r3
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
				if (clst <= 1) return FR_INT_ERR;
  404b30:	2801      	cmp	r0, #1
  404b32:	4680      	mov	r8, r0
  404b34:	d9f3      	bls.n	404b1e <dir_next+0x52>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
  404b36:	f1b0 3fff 	cmp.w	r0, #4294967295
  404b3a:	d01c      	beq.n	404b76 <dir_next+0xaa>
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
  404b3c:	6820      	ldr	r0, [r4, #0]
  404b3e:	6982      	ldr	r2, [r0, #24]
  404b40:	4542      	cmp	r2, r8
  404b42:	d90e      	bls.n	404b62 <dir_next+0x96>
  404b44:	f1a8 0602 	sub.w	r6, r8, #2
					dj->fs->winsect -= c;						/* Rewind window address */
#else
					return FR_NO_FILE;			/* Report EOT */
#endif
				}
				dj->clust = clst;				/* Initialize data for new cluster */
  404b48:	f8c4 800c 	str.w	r8, [r4, #12]
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  404b4c:	6982      	ldr	r2, [r0, #24]
  404b4e:	3a02      	subs	r2, #2
  404b50:	4296      	cmp	r6, r2
	return clst * fs->csize + fs->database;
  404b52:	bf3b      	ittet	cc
  404b54:	7881      	ldrbcc	r1, [r0, #2]
  404b56:	6a82      	ldrcc	r2, [r0, #40]	; 0x28
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  404b58:	2600      	movcs	r6, #0
	return clst * fs->csize + fs->database;
  404b5a:	fb01 2606 	mlacc	r6, r1, r6, r2
#else
					return FR_NO_FILE;			/* Report EOT */
#endif
				}
				dj->clust = clst;				/* Initialize data for new cluster */
				dj->sect = clust2sect(dj->fs, clst);
  404b5e:	6126      	str	r6, [r4, #16]
  404b60:	e7c6      	b.n	404af0 <dir_next+0x24>
				if (clst <= 1) return FR_INT_ERR;
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
#if !_FS_READONLY
					BYTE c;
					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
  404b62:	2e00      	cmp	r6, #0
  404b64:	d0ba      	beq.n	404adc <dir_next+0x10>
					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
  404b66:	68e1      	ldr	r1, [r4, #12]
  404b68:	4b26      	ldr	r3, [pc, #152]	; (404c04 <dir_next+0x138>)
  404b6a:	4798      	blx	r3
					if (clst == 0) return FR_DENIED;			/* No free cluster */
  404b6c:	4680      	mov	r8, r0
  404b6e:	b928      	cbnz	r0, 404b7c <dir_next+0xb0>
  404b70:	2007      	movs	r0, #7

	dj->index = i;
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;

	return FR_OK;
}
  404b72:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
				if (clst <= 1) return FR_INT_ERR;
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
  404b76:	2001      	movs	r0, #1
  404b78:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
#if !_FS_READONLY
					BYTE c;
					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
					if (clst == 0) return FR_DENIED;			/* No free cluster */
					if (clst == 1) return FR_INT_ERR;
  404b7c:	2801      	cmp	r0, #1
  404b7e:	d0ce      	beq.n	404b1e <dir_next+0x52>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
  404b80:	f1b0 3fff 	cmp.w	r0, #4294967295
  404b84:	d0f7      	beq.n	404b76 <dir_next+0xaa>
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
  404b86:	6820      	ldr	r0, [r4, #0]
  404b88:	f8df 907c 	ldr.w	r9, [pc, #124]	; 404c08 <dir_next+0x13c>
  404b8c:	2100      	movs	r1, #0
  404b8e:	47c8      	blx	r9
  404b90:	2800      	cmp	r0, #0
  404b92:	d1f0      	bne.n	404b76 <dir_next+0xaa>
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
  404b94:	6822      	ldr	r2, [r4, #0]
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
  404b96:	4601      	mov	r1, r0
					if (clst == 0) return FR_DENIED;			/* No free cluster */
					if (clst == 1) return FR_INT_ERR;
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
  404b98:	f102 0330 	add.w	r3, r2, #48	; 0x30
  404b9c:	f502 720c 	add.w	r2, r2, #560	; 0x230
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
  404ba0:	f803 1b01 	strb.w	r1, [r3], #1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
  404ba4:	4293      	cmp	r3, r2
  404ba6:	d1fb      	bne.n	404ba0 <dir_next+0xd4>
					if (clst == 1) return FR_INT_ERR;
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
  404ba8:	6823      	ldr	r3, [r4, #0]
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  404baa:	699a      	ldr	r2, [r3, #24]
static DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
  404bac:	f1a8 0602 	sub.w	r6, r8, #2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  404bb0:	3a02      	subs	r2, #2
  404bb2:	4296      	cmp	r6, r2
	return clst * fs->csize + fs->database;
  404bb4:	bf3b      	ittet	cc
  404bb6:	6a9a      	ldrcc	r2, [r3, #40]	; 0x28
  404bb8:	7899      	ldrbcc	r1, [r3, #2]
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  404bba:	2200      	movcs	r2, #0
	return clst * fs->csize + fs->database;
  404bbc:	fb01 2206 	mlacc	r2, r1, r6, r2
					if (clst == 1) return FR_INT_ERR;
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
  404bc0:	62da      	str	r2, [r3, #44]	; 0x2c
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
  404bc2:	f04f 0a00 	mov.w	sl, #0
						dj->fs->wflag = 1;
  404bc6:	f04f 0b01 	mov.w	fp, #1
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
  404bca:	e00b      	b.n	404be4 <dir_next+0x118>
						dj->fs->wflag = 1;
  404bcc:	f883 b004 	strb.w	fp, [r3, #4]
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
  404bd0:	6820      	ldr	r0, [r4, #0]
  404bd2:	47c8      	blx	r9
  404bd4:	f10a 0a01 	add.w	sl, sl, #1
  404bd8:	2800      	cmp	r0, #0
  404bda:	d1cc      	bne.n	404b76 <dir_next+0xaa>
						dj->fs->winsect++;
  404bdc:	6823      	ldr	r3, [r4, #0]
  404bde:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  404be0:	3201      	adds	r2, #1
  404be2:	62da      	str	r2, [r3, #44]	; 0x2c
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
  404be4:	6823      	ldr	r3, [r4, #0]
  404be6:	7898      	ldrb	r0, [r3, #2]
  404be8:	fa5f f28a 	uxtb.w	r2, sl
  404bec:	4290      	cmp	r0, r2
						dj->fs->wflag = 1;
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
  404bee:	f04f 0100 	mov.w	r1, #0
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
  404bf2:	d8eb      	bhi.n	404bcc <dir_next+0x100>
						dj->fs->wflag = 1;
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
						dj->fs->winsect++;
					}
					dj->fs->winsect -= c;						/* Rewind window address */
  404bf4:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
  404bf6:	1a8a      	subs	r2, r1, r2
  404bf8:	62da      	str	r2, [r3, #44]	; 0x2c
  404bfa:	6820      	ldr	r0, [r4, #0]
  404bfc:	e7a4      	b.n	404b48 <dir_next+0x7c>
  404bfe:	bf00      	nop
  404c00:	00404781 	.word	0x00404781
  404c04:	004049f5 	.word	0x004049f5
  404c08:	00404241 	.word	0x00404241

00404c0c <dir_read>:
#if _FS_MINIMIZE <= 1
static
FRESULT dir_read (
	DIR *dj			/* Pointer to the directory object that pointing the entry to be read */
)
{
  404c0c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	FRESULT res;
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord = 0xFF, sum = 0xFF;
  404c10:	27ff      	movs	r7, #255	; 0xff
#if _FS_MINIMIZE <= 1
static
FRESULT dir_read (
	DIR *dj			/* Pointer to the directory object that pointing the entry to be read */
)
{
  404c12:	4604      	mov	r4, r0
	FRESULT res;
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord = 0xFF, sum = 0xFF;
  404c14:	463d      	mov	r5, r7
#endif

	res = FR_NO_FILE;
  404c16:	2004      	movs	r0, #4
	while (dj->sect) {
		res = move_window(dj->fs, dj->sect);
  404c18:	4e42      	ldr	r6, [pc, #264]	; (404d24 <dir_read+0x118>)
  404c1a:	f8df 8114 	ldr.w	r8, [pc, #276]	; 404d30 <dir_read+0x124>
#if _USE_LFN
	BYTE a, ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
	while (dj->sect) {
  404c1e:	e009      	b.n	404c34 <dir_read+0x28>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
  404c20:	f1bc 0f0f 	cmp.w	ip, #15
  404c24:	d01d      	beq.n	404c62 <dir_read+0x56>
					sum = dir[LDIR_Chksum];
					c &= ~LLE; ord = c;
					dj->lfn_idx = dj->index;
				}
				/* Check LFN validity and capture it */
				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
  404c26:	25ff      	movs	r5, #255	; 0xff
		}
#else		/* Non LFN configuration */
		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
			break;
#endif
		res = dir_next(dj, 0);				/* Next entry */
  404c28:	4620      	mov	r0, r4
  404c2a:	2100      	movs	r1, #0
  404c2c:	4b3e      	ldr	r3, [pc, #248]	; (404d28 <dir_read+0x11c>)
  404c2e:	4798      	blx	r3
		if (res != FR_OK) break;
  404c30:	2800      	cmp	r0, #0
  404c32:	d14c      	bne.n	404cce <dir_read+0xc2>
#if _USE_LFN
	BYTE a, ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
	while (dj->sect) {
  404c34:	6921      	ldr	r1, [r4, #16]
  404c36:	2900      	cmp	r1, #0
  404c38:	d04d      	beq.n	404cd6 <dir_read+0xca>
		res = move_window(dj->fs, dj->sect);
  404c3a:	6820      	ldr	r0, [r4, #0]
  404c3c:	47b0      	blx	r6
		if (res != FR_OK) break;
  404c3e:	2800      	cmp	r0, #0
  404c40:	d145      	bne.n	404cce <dir_read+0xc2>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
  404c42:	6962      	ldr	r2, [r4, #20]
		c = dir[DIR_Name];
  404c44:	7813      	ldrb	r3, [r2, #0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
  404c46:	2b00      	cmp	r3, #0
  404c48:	d040      	beq.n	404ccc <dir_read+0xc0>
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
  404c4a:	2be5      	cmp	r3, #229	; 0xe5
		if (res != FR_OK) break;
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
  404c4c:	7ad1      	ldrb	r1, [r2, #11]
		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
  404c4e:	d0ea      	beq.n	404c26 <dir_read+0x1a>
  404c50:	2b2e      	cmp	r3, #46	; 0x2e
  404c52:	d0e8      	beq.n	404c26 <dir_read+0x1a>
		if (res != FR_OK) break;
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
  404c54:	f001 0c3f 	and.w	ip, r1, #63	; 0x3f
		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
  404c58:	0709      	lsls	r1, r1, #28
  404c5a:	d4e1      	bmi.n	404c20 <dir_read+0x14>
			ord = 0xFF;
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
  404c5c:	f1bc 0f0f 	cmp.w	ip, #15
  404c60:	d149      	bne.n	404cf6 <dir_read+0xea>
				if (c & LLE) {			/* Is it start of LFN sequence? */
  404c62:	0659      	lsls	r1, r3, #25
  404c64:	d52f      	bpl.n	404cc6 <dir_read+0xba>
					sum = dir[LDIR_Chksum];
					c &= ~LLE; ord = c;
					dj->lfn_idx = dj->index;
  404c66:	88e1      	ldrh	r1, [r4, #6]
		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
			ord = 0xFF;
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
				if (c & LLE) {			/* Is it start of LFN sequence? */
					sum = dir[LDIR_Chksum];
  404c68:	7b57      	ldrb	r7, [r2, #13]
					c &= ~LLE; ord = c;
					dj->lfn_idx = dj->index;
  404c6a:	8421      	strh	r1, [r4, #32]
			ord = 0xFF;
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
				if (c & LLE) {			/* Is it start of LFN sequence? */
					sum = dir[LDIR_Chksum];
					c &= ~LLE; ord = c;
  404c6c:	f003 05bf 	and.w	r5, r3, #191	; 0xbf
					dj->lfn_idx = dj->index;
				}
				/* Check LFN validity and capture it */
				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
  404c70:	f892 e00d 	ldrb.w	lr, [r2, #13]
  404c74:	45be      	cmp	lr, r7
  404c76:	d1d6      	bne.n	404c26 <dir_read+0x1a>
{
	UINT i, s;
	WCHAR wc, uc;


	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
  404c78:	7811      	ldrb	r1, [r2, #0]
					sum = dir[LDIR_Chksum];
					c &= ~LLE; ord = c;
					dj->lfn_idx = dj->index;
				}
				/* Check LFN validity and capture it */
				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
  404c7a:	f8d4 c01c 	ldr.w	ip, [r4, #28]
  404c7e:	4b2b      	ldr	r3, [pc, #172]	; (404d2c <dir_read+0x120>)
{
	UINT i, s;
	WCHAR wc, uc;


	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
  404c80:	f001 013f 	and.w	r1, r1, #63	; 0x3f
  404c84:	3901      	subs	r1, #1
  404c86:	eb01 0041 	add.w	r0, r1, r1, lsl #1
  404c8a:	eb01 0080 	add.w	r0, r1, r0, lsl #2

	s = 0; wc = 1;
  404c8e:	2701      	movs	r7, #1
		uc = LD_WORD(dir+LfnOfs[s]);		/* Pick an LFN character from the entry */
		if (wc) {	/* Last char has not been processed */
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
			lfnbuf[i++] = wc = uc;			/* Store it */
		} else {
			if (uc != 0xFFFF) return 0;		/* Check filler */
  404c90:	f64f 79ff 	movw	r9, #65535	; 0xffff
  404c94:	e007      	b.n	404ca6 <dir_read+0x9a>

	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir+LfnOfs[s]);		/* Pick an LFN character from the entry */
		if (wc) {	/* Last char has not been processed */
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
  404c96:	28fe      	cmp	r0, #254	; 0xfe
  404c98:	d812      	bhi.n	404cc0 <dir_read+0xb4>
			lfnbuf[i++] = wc = uc;			/* Store it */
  404c9a:	f82c 1010 	strh.w	r1, [ip, r0, lsl #1]

	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */

	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir+LfnOfs[s]);		/* Pick an LFN character from the entry */
  404c9e:	460f      	mov	r7, r1
		if (wc) {	/* Last char has not been processed */
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
			lfnbuf[i++] = wc = uc;			/* Store it */
  404ca0:	3001      	adds	r0, #1
		} else {
			if (uc != 0xFFFF) return 0;		/* Check filler */
		}
	} while (++s < 13);						/* Read all character in the entry */
  404ca2:	4543      	cmp	r3, r8
  404ca4:	d01b      	beq.n	404cde <dir_read+0xd2>

	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */

	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir+LfnOfs[s]);		/* Pick an LFN character from the entry */
  404ca6:	f813 1f01 	ldrb.w	r1, [r3, #1]!
  404caa:	eb02 0a01 	add.w	sl, r2, r1
  404cae:	5c51      	ldrb	r1, [r2, r1]
  404cb0:	f89a a001 	ldrb.w	sl, [sl, #1]
  404cb4:	ea41 210a 	orr.w	r1, r1, sl, lsl #8
		if (wc) {	/* Last char has not been processed */
  404cb8:	2f00      	cmp	r7, #0
  404cba:	d1ec      	bne.n	404c96 <dir_read+0x8a>
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
			lfnbuf[i++] = wc = uc;			/* Store it */
		} else {
			if (uc != 0xFFFF) return 0;		/* Check filler */
  404cbc:	4549      	cmp	r1, r9
  404cbe:	d0f0      	beq.n	404ca2 <dir_read+0x96>
					sum = dir[LDIR_Chksum];
					c &= ~LLE; ord = c;
					dj->lfn_idx = dj->index;
				}
				/* Check LFN validity and capture it */
				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
  404cc0:	4677      	mov	r7, lr
  404cc2:	25ff      	movs	r5, #255	; 0xff
  404cc4:	e7b0      	b.n	404c28 <dir_read+0x1c>
  404cc6:	429d      	cmp	r5, r3
  404cc8:	d1ad      	bne.n	404c26 <dir_read+0x1a>
  404cca:	e7d1      	b.n	404c70 <dir_read+0x64>
	while (dj->sect) {
		res = move_window(dj->fs, dj->sect);
		if (res != FR_OK) break;
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
  404ccc:	2004      	movs	r0, #4
#endif
		res = dir_next(dj, 0);				/* Next entry */
		if (res != FR_OK) break;
	}

	if (res != FR_OK) dj->sect = 0;
  404cce:	2300      	movs	r3, #0
  404cd0:	6123      	str	r3, [r4, #16]
  404cd2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  404cd6:	2800      	cmp	r0, #0
  404cd8:	d1f9      	bne.n	404cce <dir_read+0xc2>

	return res;
}
  404cda:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		} else {
			if (uc != 0xFFFF) return 0;		/* Check filler */
		}
	} while (++s < 13);						/* Read all character in the entry */

	if (dir[LDIR_Ord] & LLE) {				/* Put terminator if it is the last LFN part */
  404cde:	7813      	ldrb	r3, [r2, #0]
  404ce0:	065b      	lsls	r3, r3, #25
  404ce2:	d504      	bpl.n	404cee <dir_read+0xe2>
		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
  404ce4:	28fe      	cmp	r0, #254	; 0xfe
  404ce6:	d8eb      	bhi.n	404cc0 <dir_read+0xb4>
		lfnbuf[i] = 0;
  404ce8:	2300      	movs	r3, #0
  404cea:	f82c 3010 	strh.w	r3, [ip, r0, lsl #1]
					sum = dir[LDIR_Chksum];
					c &= ~LLE; ord = c;
					dj->lfn_idx = dj->index;
				}
				/* Check LFN validity and capture it */
				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
  404cee:	3d01      	subs	r5, #1
  404cf0:	b2ed      	uxtb	r5, r5
  404cf2:	4677      	mov	r7, lr
  404cf4:	e798      	b.n	404c28 <dir_read+0x1c>
			} else {					/* An SFN entry is found */
				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
  404cf6:	b97d      	cbnz	r5, 404d18 <dir_read+0x10c>
  404cf8:	f102 060a 	add.w	r6, r2, #10
  404cfc:	4601      	mov	r1, r0
  404cfe:	e001      	b.n	404d04 <dir_read+0xf8>
  404d00:	f812 3f01 	ldrb.w	r3, [r2, #1]!
)
{
	BYTE sum = 0;
	UINT n = 11;

	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
  404d04:	01cd      	lsls	r5, r1, #7
  404d06:	ea45 0151 	orr.w	r1, r5, r1, lsr #1
  404d0a:	fa53 f181 	uxtab	r1, r3, r1
  404d0e:	42b2      	cmp	r2, r6
  404d10:	b2c9      	uxtb	r1, r1
  404d12:	d1f5      	bne.n	404d00 <dir_read+0xf4>
					dj->lfn_idx = dj->index;
				}
				/* Check LFN validity and capture it */
				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
			} else {					/* An SFN entry is found */
				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
  404d14:	428f      	cmp	r7, r1
  404d16:	d0e0      	beq.n	404cda <dir_read+0xce>
					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
  404d18:	f64f 73ff 	movw	r3, #65535	; 0xffff
  404d1c:	8423      	strh	r3, [r4, #32]
  404d1e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  404d22:	bf00      	nop
  404d24:	00404241 	.word	0x00404241
  404d28:	00404acd 	.word	0x00404acd
  404d2c:	004160c7 	.word	0x004160c7
  404d30:	004160d4 	.word	0x004160d4

00404d34 <dir_remove>:
#if !_FS_READONLY && !_FS_MINIMIZE
static
FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
	DIR *dj				/* Directory object pointing the entry to be removed */
)
{
  404d34:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	FRESULT res;
#if _USE_LFN	/* LFN configuration */
	WORD i;

	i = dj->index;	/* SFN index */
  404d38:	88c5      	ldrh	r5, [r0, #6]
	res = dir_sdi(dj, (WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx));	/* Goto the SFN or top of the LFN entries */
  404d3a:	8c01      	ldrh	r1, [r0, #32]
  404d3c:	4b14      	ldr	r3, [pc, #80]	; (404d90 <dir_remove+0x5c>)
  404d3e:	f64f 72ff 	movw	r2, #65535	; 0xffff
  404d42:	4291      	cmp	r1, r2
  404d44:	bf08      	it	eq
  404d46:	4629      	moveq	r1, r5
#if !_FS_READONLY && !_FS_MINIMIZE
static
FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
	DIR *dj				/* Directory object pointing the entry to be removed */
)
{
  404d48:	4604      	mov	r4, r0
	FRESULT res;
#if _USE_LFN	/* LFN configuration */
	WORD i;

	i = dj->index;	/* SFN index */
	res = dir_sdi(dj, (WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx));	/* Goto the SFN or top of the LFN entries */
  404d4a:	4798      	blx	r3
	if (res == FR_OK) {
  404d4c:	4602      	mov	r2, r0
  404d4e:	b9e0      	cbnz	r0, 404d8a <dir_remove+0x56>
  404d50:	4e10      	ldr	r6, [pc, #64]	; (404d94 <dir_remove+0x60>)
			res = move_window(dj->fs, dj->sect);
			if (res != FR_OK) break;
			*dj->dir = DDE;			/* Mark the entry "deleted" */
			dj->fs->wflag = 1;
			if (dj->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
			res = dir_next(dj, 0);		/* Next entry */
  404d52:	f8df 9044 	ldr.w	r9, [pc, #68]	; 404d98 <dir_remove+0x64>
	res = dir_sdi(dj, (WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx));	/* Goto the SFN or top of the LFN entries */
	if (res == FR_OK) {
		do {
			res = move_window(dj->fs, dj->sect);
			if (res != FR_OK) break;
			*dj->dir = DDE;			/* Mark the entry "deleted" */
  404d56:	f04f 08e5 	mov.w	r8, #229	; 0xe5
			dj->fs->wflag = 1;
  404d5a:	2701      	movs	r7, #1
  404d5c:	e00a      	b.n	404d74 <dir_remove+0x40>
	res = dir_sdi(dj, (WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx));	/* Goto the SFN or top of the LFN entries */
	if (res == FR_OK) {
		do {
			res = move_window(dj->fs, dj->sect);
			if (res != FR_OK) break;
			*dj->dir = DDE;			/* Mark the entry "deleted" */
  404d5e:	6963      	ldr	r3, [r4, #20]
  404d60:	f883 8000 	strb.w	r8, [r3]
			dj->fs->wflag = 1;
  404d64:	6823      	ldr	r3, [r4, #0]
  404d66:	711f      	strb	r7, [r3, #4]
			if (dj->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
  404d68:	88e3      	ldrh	r3, [r4, #6]
  404d6a:	42ab      	cmp	r3, r5
  404d6c:	d20d      	bcs.n	404d8a <dir_remove+0x56>
			res = dir_next(dj, 0);		/* Next entry */
  404d6e:	47c8      	blx	r9
		} while (res == FR_OK);
  404d70:	4602      	mov	r2, r0
  404d72:	b938      	cbnz	r0, 404d84 <dir_remove+0x50>

	i = dj->index;	/* SFN index */
	res = dir_sdi(dj, (WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx));	/* Goto the SFN or top of the LFN entries */
	if (res == FR_OK) {
		do {
			res = move_window(dj->fs, dj->sect);
  404d74:	6921      	ldr	r1, [r4, #16]
  404d76:	6820      	ldr	r0, [r4, #0]
  404d78:	47b0      	blx	r6
			if (res != FR_OK) break;
  404d7a:	4602      	mov	r2, r0
			*dj->dir = DDE;			/* Mark the entry "deleted" */
			dj->fs->wflag = 1;
			if (dj->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
			res = dir_next(dj, 0);		/* Next entry */
  404d7c:	4601      	mov	r1, r0
  404d7e:	4620      	mov	r0, r4
	i = dj->index;	/* SFN index */
	res = dir_sdi(dj, (WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx));	/* Goto the SFN or top of the LFN entries */
	if (res == FR_OK) {
		do {
			res = move_window(dj->fs, dj->sect);
			if (res != FR_OK) break;
  404d80:	2a00      	cmp	r2, #0
  404d82:	d0ec      	beq.n	404d5e <dir_remove+0x2a>
			*dj->dir = DDE;			/* Mark the entry "deleted" */
			dj->fs->wflag = 1;
			if (dj->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
			res = dir_next(dj, 0);		/* Next entry */
		} while (res == FR_OK);
		if (res == FR_NO_FILE) res = FR_INT_ERR;
  404d84:	2a04      	cmp	r2, #4
  404d86:	bf08      	it	eq
  404d88:	2202      	moveq	r2, #2
		}
	}
#endif

	return res;
}
  404d8a:	4610      	mov	r0, r2
  404d8c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  404d90:	0040484d 	.word	0x0040484d
  404d94:	00404241 	.word	0x00404241
  404d98:	00404acd 	.word	0x00404acd

00404d9c <dir_find.part.5>:
/*-----------------------------------------------------------------------*/
/* Directory handling - Find an object in the directory                  */
/*-----------------------------------------------------------------------*/

static
FRESULT dir_find (
  404d9c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  404da0:	f04f 08ff 	mov.w	r8, #255	; 0xff
  404da4:	b085      	sub	sp, #20
  404da6:	4f52      	ldr	r7, [pc, #328]	; (404ef0 <dir_find.part.5+0x154>)
  404da8:	f8df 914c 	ldr.w	r9, [pc, #332]	; 404ef8 <dir_find.part.5+0x15c>
	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
		if (wc) {	/* Last char has not been processed */
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
  404dac:	f8df a14c 	ldr.w	sl, [pc, #332]	; 404efc <dir_find.part.5+0x160>
/*-----------------------------------------------------------------------*/
/* Directory handling - Find an object in the directory                  */
/*-----------------------------------------------------------------------*/

static
FRESULT dir_find (
  404db0:	4605      	mov	r5, r0
  404db2:	4646      	mov	r6, r8
  404db4:	e008      	b.n	404dc8 <dir_find.part.5+0x2c>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
  404db6:	290f      	cmp	r1, #15
  404db8:	d03e      	beq.n	404e38 <dir_find.part.5+0x9c>
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
  404dba:	26ff      	movs	r6, #255	; 0xff
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
			break;
#endif
		res = dir_next(dj, 0);		/* Next entry */
  404dbc:	4628      	mov	r0, r5
  404dbe:	2100      	movs	r1, #0
  404dc0:	4b4c      	ldr	r3, [pc, #304]	; (404ef4 <dir_find.part.5+0x158>)
  404dc2:	4798      	blx	r3
	} while (res == FR_OK);
  404dc4:	2800      	cmp	r0, #0
  404dc6:	d134      	bne.n	404e32 <dir_find.part.5+0x96>

#if _USE_LFN
	ord = sum = 0xFF;
#endif
	do {
		res = move_window(dj->fs, dj->sect);
  404dc8:	6828      	ldr	r0, [r5, #0]
  404dca:	6929      	ldr	r1, [r5, #16]
  404dcc:	47b8      	blx	r7
		if (res != FR_OK) break;
  404dce:	bb80      	cbnz	r0, 404e32 <dir_find.part.5+0x96>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
  404dd0:	696c      	ldr	r4, [r5, #20]
		c = dir[DIR_Name];
  404dd2:	7822      	ldrb	r2, [r4, #0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
  404dd4:	2a00      	cmp	r2, #0
  404dd6:	d078      	beq.n	404eca <dir_find.part.5+0x12e>
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
  404dd8:	7ae3      	ldrb	r3, [r4, #11]
		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
  404dda:	2ae5      	cmp	r2, #229	; 0xe5
		if (res != FR_OK) break;
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
  404ddc:	f003 013f 	and.w	r1, r3, #63	; 0x3f
		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
  404de0:	d0eb      	beq.n	404dba <dir_find.part.5+0x1e>
  404de2:	071b      	lsls	r3, r3, #28
  404de4:	d4e7      	bmi.n	404db6 <dir_find.part.5+0x1a>
			ord = 0xFF;
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
  404de6:	290f      	cmp	r1, #15
  404de8:	d026      	beq.n	404e38 <dir_find.part.5+0x9c>
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
  404dea:	b98e      	cbnz	r6, 404e10 <dir_find.part.5+0x74>
  404dec:	4694      	mov	ip, r2
  404dee:	f104 060a 	add.w	r6, r4, #10
  404df2:	4622      	mov	r2, r4
  404df4:	4603      	mov	r3, r0
  404df6:	e001      	b.n	404dfc <dir_find.part.5+0x60>
  404df8:	f812 cf01 	ldrb.w	ip, [r2, #1]!
)
{
	BYTE sum = 0;
	UINT n = 11;

	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
  404dfc:	01d9      	lsls	r1, r3, #7
  404dfe:	ea41 0353 	orr.w	r3, r1, r3, lsr #1
  404e02:	fa5c f383 	uxtab	r3, ip, r3
  404e06:	42b2      	cmp	r2, r6
  404e08:	b2db      	uxtb	r3, r3
  404e0a:	d1f5      	bne.n	404df8 <dir_find.part.5+0x5c>
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
  404e0c:	4543      	cmp	r3, r8
  404e0e:	d010      	beq.n	404e32 <dir_find.part.5+0x96>
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
  404e10:	f64f 72ff 	movw	r2, #65535	; 0xffff
				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
  404e14:	69ab      	ldr	r3, [r5, #24]
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
  404e16:	842a      	strh	r2, [r5, #32]
				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
  404e18:	7ada      	ldrb	r2, [r3, #11]
  404e1a:	07d2      	lsls	r2, r2, #31
  404e1c:	d4cd      	bmi.n	404dba <dir_find.part.5+0x1e>
  404e1e:	f104 060b 	add.w	r6, r4, #11
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
	int r = 0;

	while (cnt-- && (r = *d++ - *s++) == 0) ;
  404e22:	f814 1b01 	ldrb.w	r1, [r4], #1
  404e26:	f813 2b01 	ldrb.w	r2, [r3], #1
  404e2a:	4291      	cmp	r1, r2
  404e2c:	d1c5      	bne.n	404dba <dir_find.part.5+0x1e>
  404e2e:	42b4      	cmp	r4, r6
  404e30:	d1f7      	bne.n	404e22 <dir_find.part.5+0x86>
#endif
		res = dir_next(dj, 0);		/* Next entry */
	} while (res == FR_OK);

	return res;
}
  404e32:	b005      	add	sp, #20
  404e34:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		a = dir[DIR_Attr] & AM_MASK;
		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
			ord = 0xFF;
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
				if (dj->lfn) {
  404e38:	69eb      	ldr	r3, [r5, #28]
  404e3a:	2b00      	cmp	r3, #0
  404e3c:	d0be      	beq.n	404dbc <dir_find.part.5+0x20>
					if (c & LLE) {		/* Is it start of LFN sequence? */
  404e3e:	0651      	lsls	r1, r2, #25
  404e40:	d53f      	bpl.n	404ec2 <dir_find.part.5+0x126>
						sum = dir[LDIR_Chksum];
						c &= ~LLE; ord = c;	/* LFN start order */
						dj->lfn_idx = dj->index;
  404e42:	88e9      	ldrh	r1, [r5, #6]
			ord = 0xFF;
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
				if (dj->lfn) {
					if (c & LLE) {		/* Is it start of LFN sequence? */
						sum = dir[LDIR_Chksum];
  404e44:	f894 800d 	ldrb.w	r8, [r4, #13]
						c &= ~LLE; ord = c;	/* LFN start order */
						dj->lfn_idx = dj->index;
  404e48:	8429      	strh	r1, [r5, #32]
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
				if (dj->lfn) {
					if (c & LLE) {		/* Is it start of LFN sequence? */
						sum = dir[LDIR_Chksum];
						c &= ~LLE; ord = c;	/* LFN start order */
  404e4a:	f002 06bf 	and.w	r6, r2, #191	; 0xbf
						dj->lfn_idx = dj->index;
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
  404e4e:	7b61      	ldrb	r1, [r4, #13]
  404e50:	4541      	cmp	r1, r8
  404e52:	d1b2      	bne.n	404dba <dir_find.part.5+0x1e>
{
	UINT i, s;
	WCHAR wc, uc;


	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
  404e54:	7822      	ldrb	r2, [r4, #0]
  404e56:	f8df b0a8 	ldr.w	fp, [pc, #168]	; 404f00 <dir_find.part.5+0x164>
  404e5a:	f022 0240 	bic.w	r2, r2, #64	; 0x40
  404e5e:	3a01      	subs	r2, #1
  404e60:	eb02 0c42 	add.w	ip, r2, r2, lsl #1
  404e64:	eb02 0c8c 	add.w	ip, r2, ip, lsl #2
		if (wc) {	/* Last char has not been processed */
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
				return 0;				/* Not matched */
		} else {
			if (uc != 0xFFFF) return 0;	/* Check filler */
  404e68:	f64f 78ff 	movw	r8, #65535	; 0xffff
	UINT i, s;
	WCHAR wc, uc;


	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
	s = 0; wc = 1;
  404e6c:	2201      	movs	r2, #1
  404e6e:	e003      	b.n	404e78 <dir_find.part.5+0xdc>
		if (wc) {	/* Last char has not been processed */
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
				return 0;				/* Not matched */
		} else {
			if (uc != 0xFFFF) return 0;	/* Check filler */
  404e70:	4540      	cmp	r0, r8
  404e72:	d135      	bne.n	404ee0 <dir_find.part.5+0x144>
		}
	} while (++s < 13);				/* Repeat until all chars in the entry are checked */
  404e74:	45cb      	cmp	fp, r9
  404e76:	d02c      	beq.n	404ed2 <dir_find.part.5+0x136>


	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
  404e78:	f81b 0f01 	ldrb.w	r0, [fp, #1]!
  404e7c:	eb04 0e00 	add.w	lr, r4, r0
  404e80:	5c20      	ldrb	r0, [r4, r0]
  404e82:	f89e e001 	ldrb.w	lr, [lr, #1]
  404e86:	ea40 200e 	orr.w	r0, r0, lr, lsl #8
		if (wc) {	/* Last char has not been processed */
  404e8a:	2a00      	cmp	r2, #0
  404e8c:	d0f0      	beq.n	404e70 <dir_find.part.5+0xd4>
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
  404e8e:	f10c 0201 	add.w	r2, ip, #1
	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
		if (wc) {	/* Last char has not been processed */
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
  404e92:	e88d 100a 	stmia.w	sp, {r1, r3, ip}
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
  404e96:	9203      	str	r2, [sp, #12]
	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
		if (wc) {	/* Last char has not been processed */
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
  404e98:	47d0      	blx	sl
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
  404e9a:	f8dd c008 	ldr.w	ip, [sp, #8]
  404e9e:	f1bc 0ffe 	cmp.w	ip, #254	; 0xfe
	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
		if (wc) {	/* Last char has not been processed */
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
  404ea2:	4602      	mov	r2, r0
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
  404ea4:	e89d 000a 	ldmia.w	sp, {r1, r3}
  404ea8:	d81a      	bhi.n	404ee0 <dir_find.part.5+0x144>
  404eaa:	f833 001c 	ldrh.w	r0, [r3, ip, lsl #1]
  404eae:	9202      	str	r2, [sp, #8]
  404eb0:	47d0      	blx	sl
  404eb2:	9a02      	ldr	r2, [sp, #8]
  404eb4:	4282      	cmp	r2, r0
  404eb6:	e89d 000a 	ldmia.w	sp, {r1, r3}
  404eba:	d111      	bne.n	404ee0 <dir_find.part.5+0x144>
  404ebc:	f8dd c00c 	ldr.w	ip, [sp, #12]
  404ec0:	e7d8      	b.n	404e74 <dir_find.part.5+0xd8>
						sum = dir[LDIR_Chksum];
						c &= ~LLE; ord = c;	/* LFN start order */
						dj->lfn_idx = dj->index;
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
  404ec2:	42b2      	cmp	r2, r6
  404ec4:	f47f af79 	bne.w	404dba <dir_find.part.5+0x1e>
  404ec8:	e7c1      	b.n	404e4e <dir_find.part.5+0xb2>
	do {
		res = move_window(dj->fs, dj->sect);
		if (res != FR_OK) break;
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
  404eca:	2004      	movs	r0, #4
#endif
		res = dir_next(dj, 0);		/* Next entry */
	} while (res == FR_OK);

	return res;
}
  404ecc:	b005      	add	sp, #20
  404ece:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		} else {
			if (uc != 0xFFFF) return 0;	/* Check filler */
		}
	} while (++s < 13);				/* Repeat until all chars in the entry are checked */

	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i])	/* Last segment matched but different length */
  404ed2:	7820      	ldrb	r0, [r4, #0]
  404ed4:	0640      	lsls	r0, r0, #25
  404ed6:	d506      	bpl.n	404ee6 <dir_find.part.5+0x14a>
  404ed8:	b12a      	cbz	r2, 404ee6 <dir_find.part.5+0x14a>
  404eda:	f833 301c 	ldrh.w	r3, [r3, ip, lsl #1]
  404ede:	b113      	cbz	r3, 404ee6 <dir_find.part.5+0x14a>
						sum = dir[LDIR_Chksum];
						c &= ~LLE; ord = c;	/* LFN start order */
						dj->lfn_idx = dj->index;
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
  404ee0:	4688      	mov	r8, r1
  404ee2:	26ff      	movs	r6, #255	; 0xff
  404ee4:	e76a      	b.n	404dbc <dir_find.part.5+0x20>
  404ee6:	3e01      	subs	r6, #1
  404ee8:	b2f6      	uxtb	r6, r6
  404eea:	4688      	mov	r8, r1
  404eec:	e766      	b.n	404dbc <dir_find.part.5+0x20>
  404eee:	bf00      	nop
  404ef0:	00404241 	.word	0x00404241
  404ef4:	00404acd 	.word	0x00404acd
  404ef8:	004160d4 	.word	0x004160d4
  404efc:	00406575 	.word	0x00406575
  404f00:	004160c7 	.word	0x004160c7

00404f04 <dir_register>:
#if !_FS_READONLY
static
FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
	DIR *dj				/* Target directory with object name to be created */
)
{
  404f04:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	WORD n, ne, is;
	BYTE sn[12], *fn, sum;
	WCHAR *lfn;


	fn = dj->fn; lfn = dj->lfn;
  404f08:	f8d0 a018 	ldr.w	sl, [r0, #24]
  404f0c:	69c5      	ldr	r5, [r0, #28]
#if !_FS_READONLY
static
FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
	DIR *dj				/* Target directory with object name to be created */
)
{
  404f0e:	b089      	sub	sp, #36	; 0x24
  404f10:	f10a 36ff 	add.w	r6, sl, #4294967295
  404f14:	4604      	mov	r4, r0
	WORD n, ne, is;
	BYTE sn[12], *fn, sum;
	WCHAR *lfn;


	fn = dj->fn; lfn = dj->lfn;
  404f16:	4632      	mov	r2, r6
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
	BYTE *d = (BYTE*)dst;
  404f18:	ab05      	add	r3, sp, #20
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
  404f1a:	f812 1f01 	ldrb.w	r1, [r2, #1]!
  404f1e:	f803 1b01 	strb.w	r1, [r3], #1
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
  404f22:	a908      	add	r1, sp, #32
  404f24:	428b      	cmp	r3, r1
  404f26:	d1f8      	bne.n	404f1a <dir_register+0x16>
	mem_cpy(sn, fn, 12);

	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
		return FR_INVALID_NAME;

	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
  404f28:	f89d 301f 	ldrb.w	r3, [sp, #31]
  404f2c:	9301      	str	r3, [sp, #4]
  404f2e:	07da      	lsls	r2, r3, #31
  404f30:	d456      	bmi.n	404fe0 <dir_register+0xdc>
  404f32:	4fb1      	ldr	r7, [pc, #708]	; (4051f8 <dir_register+0x2f4>)
		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
		fn[NS] = sn[NS]; dj->lfn = lfn;
	}

	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, reserve an SFN + LFN entries. */
  404f34:	9b01      	ldr	r3, [sp, #4]
  404f36:	079b      	lsls	r3, r3, #30
  404f38:	f100 80c2 	bmi.w	4050c0 <dir_register+0x1bc>
		for (ne = 0; lfn[ne]; ne++) ;
		ne = (ne + 25) / 13;
	} else {						/* Otherwise reserve only an SFN entry. */
		ne = 1;
  404f3c:	f04f 0901 	mov.w	r9, #1
	}

	/* Reserve contiguous entries */
	res = dir_sdi(dj, 0);
  404f40:	4620      	mov	r0, r4
  404f42:	2100      	movs	r1, #0
  404f44:	47b8      	blx	r7
	if (res != FR_OK) return res;
  404f46:	2800      	cmp	r0, #0
  404f48:	d147      	bne.n	404fda <dir_register+0xd6>
  404f4a:	4682      	mov	sl, r0
  404f4c:	4eab      	ldr	r6, [pc, #684]	; (4051fc <dir_register+0x2f8>)
			if (n == 0) is = dj->index;	/* First index of the contiguous entry */
			if (++n == ne) break;	/* A contiguous entry that required count is found */
		} else {
			n = 0;					/* Not a blank entry. Restart to search */
		}
		res = dir_next(dj, 1);		/* Next entry with table stretch */
  404f4e:	f8df 82b4 	ldr.w	r8, [pc, #692]	; 405204 <dir_register+0x300>
		ne = 1;
	}

	/* Reserve contiguous entries */
	res = dir_sdi(dj, 0);
	if (res != FR_OK) return res;
  404f52:	4605      	mov	r5, r0
  404f54:	e005      	b.n	404f62 <dir_register+0x5e>
		c = *dj->dir;				/* Check the entry status */
		if (c == DDE || c == 0) {	/* Is it a blank entry? */
			if (n == 0) is = dj->index;	/* First index of the contiguous entry */
			if (++n == ne) break;	/* A contiguous entry that required count is found */
		} else {
			n = 0;					/* Not a blank entry. Restart to search */
  404f56:	461d      	mov	r5, r3
		}
		res = dir_next(dj, 1);		/* Next entry with table stretch */
  404f58:	47c0      	blx	r8
	} while (res == FR_OK);
  404f5a:	4603      	mov	r3, r0
  404f5c:	2800      	cmp	r0, #0
  404f5e:	f040 80ce 	bne.w	4050fe <dir_register+0x1fa>
	/* Reserve contiguous entries */
	res = dir_sdi(dj, 0);
	if (res != FR_OK) return res;
	n = is = 0;
	do {
		res = move_window(dj->fs, dj->sect);
  404f62:	6921      	ldr	r1, [r4, #16]
  404f64:	6820      	ldr	r0, [r4, #0]
  404f66:	47b0      	blx	r6
		if (res != FR_OK) break;
  404f68:	4603      	mov	r3, r0
		c = *dj->dir;				/* Check the entry status */
		if (c == DDE || c == 0) {	/* Is it a blank entry? */
			if (n == 0) is = dj->index;	/* First index of the contiguous entry */
			if (++n == ne) break;	/* A contiguous entry that required count is found */
  404f6a:	f105 0c01 	add.w	ip, r5, #1
		} else {
			n = 0;					/* Not a blank entry. Restart to search */
		}
		res = dir_next(dj, 1);		/* Next entry with table stretch */
  404f6e:	4620      	mov	r0, r4
  404f70:	2101      	movs	r1, #1
	res = dir_sdi(dj, 0);
	if (res != FR_OK) return res;
	n = is = 0;
	do {
		res = move_window(dj->fs, dj->sect);
		if (res != FR_OK) break;
  404f72:	2b00      	cmp	r3, #0
  404f74:	f040 80c3 	bne.w	4050fe <dir_register+0x1fa>
		c = *dj->dir;				/* Check the entry status */
  404f78:	6962      	ldr	r2, [r4, #20]
  404f7a:	7812      	ldrb	r2, [r2, #0]
		if (c == DDE || c == 0) {	/* Is it a blank entry? */
  404f7c:	2ae5      	cmp	r2, #229	; 0xe5
  404f7e:	d001      	beq.n	404f84 <dir_register+0x80>
  404f80:	2a00      	cmp	r2, #0
  404f82:	d1e8      	bne.n	404f56 <dir_register+0x52>
			if (n == 0) is = dj->index;	/* First index of the contiguous entry */
  404f84:	b90d      	cbnz	r5, 404f8a <dir_register+0x86>
  404f86:	f8b4 a006 	ldrh.w	sl, [r4, #6]
			if (++n == ne) break;	/* A contiguous entry that required count is found */
  404f8a:	fa1f f58c 	uxth.w	r5, ip
  404f8e:	454d      	cmp	r5, r9
  404f90:	d1e2      	bne.n	404f58 <dir_register+0x54>
			n = 0;					/* Not a blank entry. Restart to search */
		}
		res = dir_next(dj, 1);		/* Next entry with table stretch */
	} while (res == FR_OK);

	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
  404f92:	f1b9 0f01 	cmp.w	r9, #1
  404f96:	f040 80b6 	bne.w	405106 <dir_register+0x202>
		} while (res == FR_OK);
	}
#endif

	if (res == FR_OK) {		/* Initialize the SFN entry */
		res = move_window(dj->fs, dj->sect);
  404f9a:	6820      	ldr	r0, [r4, #0]
  404f9c:	6921      	ldr	r1, [r4, #16]
  404f9e:	47b0      	blx	r6
		if (res == FR_OK) {
  404fa0:	b9d8      	cbnz	r0, 404fda <dir_register+0xd6>
			dir = dj->dir;
  404fa2:	6965      	ldr	r5, [r4, #20]
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
  404fa4:	4601      	mov	r1, r0
  404fa6:	f105 0220 	add.w	r2, r5, #32
}

/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;
  404faa:	462b      	mov	r3, r5

	while (cnt--)
		*d++ = (BYTE)val;
  404fac:	f803 1b01 	strb.w	r1, [r3], #1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
  404fb0:	4293      	cmp	r3, r2
  404fb2:	d1fb      	bne.n	404fac <dir_register+0xa8>
	if (res == FR_OK) {		/* Initialize the SFN entry */
		res = move_window(dj->fs, dj->sect);
		if (res == FR_OK) {
			dir = dj->dir;
			mem_set(dir, 0, SZ_DIR);	/* Clean the entry */
			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
  404fb4:	69a2      	ldr	r2, [r4, #24]
  404fb6:	f105 000b 	add.w	r0, r5, #11
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
	BYTE *d = (BYTE*)dst;
  404fba:	462b      	mov	r3, r5
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
  404fbc:	f812 1b01 	ldrb.w	r1, [r2], #1
  404fc0:	f803 1b01 	strb.w	r1, [r3], #1
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
  404fc4:	4283      	cmp	r3, r0
  404fc6:	d1f9      	bne.n	404fbc <dir_register+0xb8>
		if (res == FR_OK) {
			dir = dj->dir;
			mem_set(dir, 0, SZ_DIR);	/* Clean the entry */
			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
#if _USE_LFN
			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
  404fc8:	69a3      	ldr	r3, [r4, #24]
  404fca:	7adb      	ldrb	r3, [r3, #11]
  404fcc:	f003 0318 	and.w	r3, r3, #24
  404fd0:	732b      	strb	r3, [r5, #12]
#endif
			dj->fs->wflag = 1;
  404fd2:	6823      	ldr	r3, [r4, #0]
  404fd4:	2201      	movs	r2, #1
  404fd6:	711a      	strb	r2, [r3, #4]
  404fd8:	2000      	movs	r0, #0
		}
	}

	return res;
}
  404fda:	b009      	add	sp, #36	; 0x24
  404fdc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
		return FR_INVALID_NAME;

	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
  404fe0:	2300      	movs	r3, #0
  404fe2:	4f85      	ldr	r7, [pc, #532]	; (4051f8 <dir_register+0x2f4>)
  404fe4:	f8df 8220 	ldr.w	r8, [pc, #544]	; 405208 <dir_register+0x304>
  404fe8:	f88a 300b 	strb.w	r3, [sl, #11]
		for (n = 1; n < 100; n++) {
  404fec:	f04f 0901 	mov.w	r9, #1

	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
		return FR_INVALID_NAME;

	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
  404ff0:	61e3      	str	r3, [r4, #28]
  404ff2:	f10d 0b1f 	add.w	fp, sp, #31
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
	BYTE *d = (BYTE*)dst;
  404ff6:	4632      	mov	r2, r6
  404ff8:	ab05      	add	r3, sp, #20
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
  404ffa:	f813 1b01 	ldrb.w	r1, [r3], #1
  404ffe:	f802 1f01 	strb.w	r1, [r2, #1]!
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
  405002:	455b      	cmp	r3, fp
  405004:	d1f9      	bne.n	404ffa <dir_register+0xf6>
	UINT i, j;


	mem_cpy(dst, src, 11);

	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
  405006:	f1b9 0f05 	cmp.w	r9, #5
  40500a:	d957      	bls.n	4050bc <dir_register+0x1b8>
  40500c:	8828      	ldrh	r0, [r5, #0]
  40500e:	4629      	mov	r1, r5
  405010:	464a      	mov	r2, r9
  405012:	e000      	b.n	405016 <dir_register+0x112>
		do seq = (seq >> 1) + (seq << 15) + (WORD)*lfn++; while (*lfn);
  405014:	4618      	mov	r0, r3
  405016:	03d3      	lsls	r3, r2, #15
  405018:	ea43 0252 	orr.w	r2, r3, r2, lsr #1
  40501c:	f831 3f02 	ldrh.w	r3, [r1, #2]!
  405020:	fa10 f282 	uxtah	r2, r0, r2
  405024:	b292      	uxth	r2, r2
  405026:	2b00      	cmp	r3, #0
  405028:	d1f4      	bne.n	405014 <dir_register+0x110>
	UINT i, j;


	mem_cpy(dst, src, 11);

	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
  40502a:	2307      	movs	r3, #7
	}

	/* itoa (hexdecimal) */
	i = 7;
	do {
		c = (seq % 16) + '0';
  40502c:	f002 000f 	and.w	r0, r2, #15
  405030:	f100 0130 	add.w	r1, r0, #48	; 0x30
		if (c > '9') c += 7;
  405034:	2939      	cmp	r1, #57	; 0x39
  405036:	bf88      	it	hi
  405038:	f100 0137 	addhi.w	r1, r0, #55	; 0x37
		ns[i--] = c;
  40503c:	3b01      	subs	r3, #1
  40503e:	a803      	add	r0, sp, #12
  405040:	4418      	add	r0, r3
		seq /= 16;
  405042:	f3c2 120f 	ubfx	r2, r2, #4, #16
	/* itoa (hexdecimal) */
	i = 7;
	do {
		c = (seq % 16) + '0';
		if (c > '9') c += 7;
		ns[i--] = c;
  405046:	7041      	strb	r1, [r0, #1]
		seq /= 16;
	} while (seq);
  405048:	2a00      	cmp	r2, #0
  40504a:	d1ef      	bne.n	40502c <dir_register+0x128>
	ns[i] = '~';
  40504c:	a908      	add	r1, sp, #32
  40504e:	4419      	add	r1, r3
  405050:	207e      	movs	r0, #126	; 0x7e
  405052:	f801 0c14 	strb.w	r0, [r1, #-20]

	/* Append the number */
	for (j = 0; j < i && dst[j] != ' '; j++) {
  405056:	2b00      	cmp	r3, #0
  405058:	d04f      	beq.n	4050fa <dir_register+0x1f6>
  40505a:	f89a 1000 	ldrb.w	r1, [sl]
  40505e:	2920      	cmp	r1, #32
  405060:	d014      	beq.n	40508c <dir_register+0x188>
  405062:	4651      	mov	r1, sl
  405064:	e003      	b.n	40506e <dir_register+0x16a>
  405066:	f811 0f01 	ldrb.w	r0, [r1, #1]!
  40506a:	2820      	cmp	r0, #32
  40506c:	d00e      	beq.n	40508c <dir_register+0x188>
  40506e:	3201      	adds	r2, #1
  405070:	429a      	cmp	r2, r3
  405072:	d1f8      	bne.n	405066 <dir_register+0x162>
			if (j == i - 1) break;
			j++;
		}
	}
	do {
		dst[j++] = (i < 8) ? ns[i++] : ' ';
  405074:	2b07      	cmp	r3, #7
  405076:	d80b      	bhi.n	405090 <dir_register+0x18c>
  405078:	a908      	add	r1, sp, #32
  40507a:	4419      	add	r1, r3
  40507c:	3301      	adds	r3, #1
  40507e:	f811 1c14 	ldrb.w	r1, [r1, #-20]
  405082:	f80a 1002 	strb.w	r1, [sl, r2]
  405086:	3201      	adds	r2, #1
	} while (j < 8);
  405088:	2a07      	cmp	r2, #7
  40508a:	d807      	bhi.n	40509c <dir_register+0x198>
			if (j == i - 1) break;
			j++;
		}
	}
	do {
		dst[j++] = (i < 8) ? ns[i++] : ' ';
  40508c:	2b07      	cmp	r3, #7
  40508e:	d9f3      	bls.n	405078 <dir_register+0x174>
  405090:	2120      	movs	r1, #32
  405092:	f80a 1002 	strb.w	r1, [sl, r2]
  405096:	3201      	adds	r2, #1
	} while (j < 8);
  405098:	2a07      	cmp	r2, #7
  40509a:	d9f7      	bls.n	40508c <dir_register+0x188>
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dj, 0);			/* Rewind directory object */
  40509c:	4620      	mov	r0, r4
  40509e:	2100      	movs	r1, #0
  4050a0:	47b8      	blx	r7
	if (res != FR_OK) return res;
  4050a2:	bb10      	cbnz	r0, 4050ea <dir_register+0x1e6>
  4050a4:	4620      	mov	r0, r4
  4050a6:	47c0      	blx	r8
	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
		for (n = 1; n < 100; n++) {
			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
			res = dir_find(dj);				/* Check if the name collides with existing SFN */
			if (res != FR_OK) break;
  4050a8:	b9f8      	cbnz	r0, 4050ea <dir_register+0x1e6>
	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
		return FR_INVALID_NAME;

	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
		for (n = 1; n < 100; n++) {
  4050aa:	f109 0901 	add.w	r9, r9, #1
  4050ae:	fa1f f989 	uxth.w	r9, r9
  4050b2:	f1b9 0f64 	cmp.w	r9, #100	; 0x64
  4050b6:	d19e      	bne.n	404ff6 <dir_register+0xf2>
			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
			res = dir_find(dj);				/* Check if the name collides with existing SFN */
			if (res != FR_OK) break;
		}
		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
  4050b8:	2007      	movs	r0, #7
  4050ba:	e78e      	b.n	404fda <dir_register+0xd6>
	UINT i, j;


	mem_cpy(dst, src, 11);

	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
  4050bc:	464a      	mov	r2, r9
  4050be:	e7b4      	b.n	40502a <dir_register+0x126>
		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
		fn[NS] = sn[NS]; dj->lfn = lfn;
	}

	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, reserve an SFN + LFN entries. */
		for (ne = 0; lfn[ne]; ne++) ;
  4050c0:	882b      	ldrh	r3, [r5, #0]
  4050c2:	2b00      	cmp	r3, #0
  4050c4:	f43f af3a 	beq.w	404f3c <dir_register+0x38>
  4050c8:	2300      	movs	r3, #0
  4050ca:	3301      	adds	r3, #1
  4050cc:	b29b      	uxth	r3, r3
  4050ce:	f835 2013 	ldrh.w	r2, [r5, r3, lsl #1]
  4050d2:	2a00      	cmp	r2, #0
  4050d4:	d1f9      	bne.n	4050ca <dir_register+0x1c6>
  4050d6:	4a4a      	ldr	r2, [pc, #296]	; (405200 <dir_register+0x2fc>)
  4050d8:	3319      	adds	r3, #25
  4050da:	fb82 1903 	smull	r1, r9, r2, r3
  4050de:	17db      	asrs	r3, r3, #31
  4050e0:	ebc3 09a9 	rsb	r9, r3, r9, asr #2
  4050e4:	fa1f f989 	uxth.w	r9, r9
  4050e8:	e72a      	b.n	404f40 <dir_register+0x3c>
			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
			res = dir_find(dj);				/* Check if the name collides with existing SFN */
			if (res != FR_OK) break;
		}
		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
  4050ea:	2804      	cmp	r0, #4
  4050ec:	f47f af75 	bne.w	404fda <dir_register+0xd6>
		fn[NS] = sn[NS]; dj->lfn = lfn;
  4050f0:	9b01      	ldr	r3, [sp, #4]
  4050f2:	f88a 300b 	strb.w	r3, [sl, #11]
  4050f6:	61e5      	str	r5, [r4, #28]
  4050f8:	e71c      	b.n	404f34 <dir_register+0x30>
		seq /= 16;
	} while (seq);
	ns[i] = '~';

	/* Append the number */
	for (j = 0; j < i && dst[j] != ' '; j++) {
  4050fa:	461a      	mov	r2, r3
  4050fc:	e7c6      	b.n	40508c <dir_register+0x188>
  4050fe:	4618      	mov	r0, r3
			dj->fs->wflag = 1;
		}
	}

	return res;
}
  405100:	b009      	add	sp, #36	; 0x24
  405102:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		}
		res = dir_next(dj, 1);		/* Next entry with table stretch */
	} while (res == FR_OK);

	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
		res = dir_sdi(dj, is);
  405106:	4651      	mov	r1, sl
  405108:	4620      	mov	r0, r4
  40510a:	47b8      	blx	r7
		if (res == FR_OK) {
  40510c:	4603      	mov	r3, r0
  40510e:	2800      	cmp	r0, #0
  405110:	d1f5      	bne.n	4050fe <dir_register+0x1fa>
			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
  405112:	69a2      	ldr	r2, [r4, #24]
static
BYTE sum_sfn (
	const BYTE *dir		/* Ptr to directory entry */
)
{
	BYTE sum = 0;
  405114:	4683      	mov	fp, r0
  405116:	f102 000b 	add.w	r0, r2, #11
	UINT n = 11;

	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
  40511a:	f812 3b01 	ldrb.w	r3, [r2], #1
  40511e:	ea4f 11cb 	mov.w	r1, fp, lsl #7
  405122:	ea41 0b5b 	orr.w	fp, r1, fp, lsr #1
  405126:	fa53 fb8b 	uxtab	fp, r3, fp
  40512a:	4282      	cmp	r2, r0
  40512c:	fa5f fb8b 	uxtb.w	fp, fp
  405130:	d1f3      	bne.n	40511a <dir_register+0x216>

	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
		res = dir_sdi(dj, is);
		if (res == FR_OK) {
			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
			ne--;
  405132:	f109 39ff 	add.w	r9, r9, #4294967295
  405136:	fa1f f989 	uxth.w	r9, r9
  40513a:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 40520c <dir_register+0x308>
  40513e:	f8cd b000 	str.w	fp, [sp]
  405142:	46cb      	mov	fp, r9
			do {					/* Store LFN entries in bottom first */
				res = move_window(dj->fs, dj->sect);
  405144:	6820      	ldr	r0, [r4, #0]
  405146:	6921      	ldr	r1, [r4, #16]
  405148:	47b0      	blx	r6
  40514a:	4603      	mov	r3, r0
				if (res != FR_OK) break;
  40514c:	2800      	cmp	r0, #0
  40514e:	d1d6      	bne.n	4050fe <dir_register+0x1fa>
				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
  405150:	fa5f fa8b 	uxtb.w	sl, fp
  405154:	6965      	ldr	r5, [r4, #20]
{
	UINT i, s;
	WCHAR wc;


	dir[LDIR_Chksum] = sum;			/* Set check sum */
  405156:	9b00      	ldr	r3, [sp, #0]
			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
			ne--;
			do {					/* Store LFN entries in bottom first */
				res = move_window(dj->fs, dj->sect);
				if (res != FR_OK) break;
				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
  405158:	f8d4 901c 	ldr.w	r9, [r4, #28]
{
	UINT i, s;
	WCHAR wc;


	dir[LDIR_Chksum] = sum;			/* Set check sum */
  40515c:	736b      	strb	r3, [r5, #13]
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
	dir[LDIR_Type] = 0;
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
  40515e:	f10a 32ff 	add.w	r2, sl, #4294967295
  405162:	eb02 0142 	add.w	r1, r2, r2, lsl #1
	UINT i, s;
	WCHAR wc;


	dir[LDIR_Chksum] = sum;			/* Set check sum */
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
  405166:	270f      	movs	r7, #15
	dir[LDIR_Type] = 0;
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
  405168:	4603      	mov	r3, r0
	dir[LDIR_Chksum] = sum;			/* Set check sum */
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
	dir[LDIR_Type] = 0;
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
  40516a:	eb02 0181 	add.w	r1, r2, r1, lsl #2
	UINT i, s;
	WCHAR wc;


	dir[LDIR_Chksum] = sum;			/* Set check sum */
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
  40516e:	72ef      	strb	r7, [r5, #11]
	dir[LDIR_Type] = 0;
  405170:	7328      	strb	r0, [r5, #12]
	ST_WORD(dir+LDIR_FstClusLO, 0);
  405172:	76a8      	strb	r0, [r5, #26]
  405174:	76e8      	strb	r0, [r5, #27]

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
  405176:	4602      	mov	r2, r0
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
  405178:	f64f 77ff 	movw	r7, #65535	; 0xffff
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
  40517c:	20ff      	movs	r0, #255	; 0xff
  40517e:	e010      	b.n	4051a2 <dir_register+0x29e>
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
  405180:	f839 3011 	ldrh.w	r3, [r9, r1, lsl #1]
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
  405184:	f805 300e 	strb.w	r3, [r5, lr]
		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
	} while (++s < 13);
  405188:	3201      	adds	r2, #1

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
  40518a:	44ae      	add	lr, r5
  40518c:	ea4f 2c13 	mov.w	ip, r3, lsr #8
		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
  405190:	2b00      	cmp	r3, #0
  405192:	bf08      	it	eq
  405194:	463b      	moveq	r3, r7
	} while (++s < 13);
  405196:	2a0d      	cmp	r2, #13
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
  405198:	f101 0101 	add.w	r1, r1, #1
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
  40519c:	f88e c001 	strb.w	ip, [lr, #1]
		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
	} while (++s < 13);
  4051a0:	d00c      	beq.n	4051bc <dir_register+0x2b8>
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
  4051a2:	42bb      	cmp	r3, r7
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
  4051a4:	f818 e002 	ldrb.w	lr, [r8, r2]
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
  4051a8:	d1ea      	bne.n	405180 <dir_register+0x27c>
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
  4051aa:	eb05 0c0e 	add.w	ip, r5, lr
		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
	} while (++s < 13);
  4051ae:	3201      	adds	r2, #1
  4051b0:	2a0d      	cmp	r2, #13

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
  4051b2:	f805 000e 	strb.w	r0, [r5, lr]
  4051b6:	f88c 0001 	strb.w	r0, [ip, #1]
		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
	} while (++s < 13);
  4051ba:	d1f2      	bne.n	4051a2 <dir_register+0x29e>
	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLE;	/* Bottom LFN part is the start of LFN sequence */
  4051bc:	f64f 72ff 	movw	r2, #65535	; 0xffff
  4051c0:	4293      	cmp	r3, r2
  4051c2:	d002      	beq.n	4051ca <dir_register+0x2c6>
  4051c4:	f839 3011 	ldrh.w	r3, [r9, r1, lsl #1]
  4051c8:	b90b      	cbnz	r3, 4051ce <dir_register+0x2ca>
  4051ca:	f04a 0a40 	orr.w	sl, sl, #64	; 0x40
	dir[LDIR_Ord] = ord;			/* Set the LFN order */
  4051ce:	f885 a000 	strb.w	sl, [r5]
			ne--;
			do {					/* Store LFN entries in bottom first */
				res = move_window(dj->fs, dj->sect);
				if (res != FR_OK) break;
				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
				dj->fs->wflag = 1;
  4051d2:	6823      	ldr	r3, [r4, #0]
				res = dir_next(dj, 0);	/* Next entry */
  4051d4:	4a0b      	ldr	r2, [pc, #44]	; (405204 <dir_register+0x300>)
			ne--;
			do {					/* Store LFN entries in bottom first */
				res = move_window(dj->fs, dj->sect);
				if (res != FR_OK) break;
				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
				dj->fs->wflag = 1;
  4051d6:	2101      	movs	r1, #1
  4051d8:	7119      	strb	r1, [r3, #4]
				res = dir_next(dj, 0);	/* Next entry */
  4051da:	4620      	mov	r0, r4
  4051dc:	2100      	movs	r1, #0
  4051de:	4790      	blx	r2
			} while (res == FR_OK && --ne);
  4051e0:	4603      	mov	r3, r0
  4051e2:	2800      	cmp	r0, #0
  4051e4:	d18b      	bne.n	4050fe <dir_register+0x1fa>
  4051e6:	f10b 3bff 	add.w	fp, fp, #4294967295
  4051ea:	fa1f fb8b 	uxth.w	fp, fp
  4051ee:	f1bb 0f00 	cmp.w	fp, #0
  4051f2:	d1a7      	bne.n	405144 <dir_register+0x240>
  4051f4:	e6d1      	b.n	404f9a <dir_register+0x96>
  4051f6:	bf00      	nop
  4051f8:	0040484d 	.word	0x0040484d
  4051fc:	00404241 	.word	0x00404241
  405200:	4ec4ec4f 	.word	0x4ec4ec4f
  405204:	00404acd 	.word	0x00404acd
  405208:	00404d9d 	.word	0x00404d9d
  40520c:	004160c8 	.word	0x004160c8

00405210 <remove_chain.part.6>:
/*-----------------------------------------------------------------------*/
/* FAT handling - Remove a cluster chain                                 */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY
static
FRESULT remove_chain (
  405210:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  405214:	4604      	mov	r4, r0
  405216:	460d      	mov	r5, r1
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
  405218:	69a3      	ldr	r3, [r4, #24]
  40521a:	4f16      	ldr	r7, [pc, #88]	; (405274 <remove_chain.part.6+0x64>)
  40521c:	f8df 8058 	ldr.w	r8, [pc, #88]	; 405278 <remove_chain.part.6+0x68>
  405220:	429d      	cmp	r5, r3
  405222:	d220      	bcs.n	405266 <remove_chain.part.6+0x56>
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  405224:	2d01      	cmp	r5, #1
  405226:	d90b      	bls.n	405240 <remove_chain.part.6+0x30>
  405228:	4620      	mov	r0, r4
  40522a:	4629      	mov	r1, r5
  40522c:	47b8      	blx	r7

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
  40522e:	4606      	mov	r6, r0
  405230:	b1c8      	cbz	r0, 405266 <remove_chain.part.6+0x56>
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
  405232:	2801      	cmp	r0, #1
  405234:	d004      	beq.n	405240 <remove_chain.part.6+0x30>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
  405236:	3001      	adds	r0, #1
  405238:	d018      	beq.n	40526c <remove_chain.part.6+0x5c>
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
  40523a:	69a3      	ldr	r3, [r4, #24]
  40523c:	429d      	cmp	r5, r3
  40523e:	d302      	bcc.n	405246 <remove_chain.part.6+0x36>
	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
  405240:	2002      	movs	r0, #2
  405242:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  405246:	2200      	movs	r2, #0
  405248:	4629      	mov	r1, r5
  40524a:	4620      	mov	r0, r4
  40524c:	47c0      	blx	r8
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
			if (res != FR_OK) break;
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
				fs->free_clust++;
				fs->fsi_flag = 1;
  40524e:	2201      	movs	r2, #1
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
			if (res != FR_OK) break;
  405250:	b968      	cbnz	r0, 40526e <remove_chain.part.6+0x5e>
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
  405252:	6923      	ldr	r3, [r4, #16]
  405254:	1c59      	adds	r1, r3, #1
  405256:	d002      	beq.n	40525e <remove_chain.part.6+0x4e>
				fs->free_clust++;
  405258:	4413      	add	r3, r2
  40525a:	6123      	str	r3, [r4, #16]
				fs->fsi_flag = 1;
  40525c:	7162      	strb	r2, [r4, #5]
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
  40525e:	69a3      	ldr	r3, [r4, #24]
/*-----------------------------------------------------------------------*/
/* FAT handling - Remove a cluster chain                                 */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY
static
FRESULT remove_chain (
  405260:	4635      	mov	r5, r6
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
  405262:	429d      	cmp	r5, r3
  405264:	d3de      	bcc.n	405224 <remove_chain.part.6+0x14>
/*-----------------------------------------------------------------------*/
/* FAT handling - Remove a cluster chain                                 */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY
static
FRESULT remove_chain (
  405266:	2000      	movs	r0, #0
  405268:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
  40526c:	2001      	movs	r0, #1
			clst = nxt;	/* Next cluster */
		}
	}

	return res;
}
  40526e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  405272:	bf00      	nop
  405274:	00404781 	.word	0x00404781
  405278:	004048f5 	.word	0x004048f5

0040527c <follow_path>:
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR *dj,			/* Directory object to return last directory and found object */
	const TCHAR *path	/* Full-path string to find a file or directory */
)
{
  40527c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
	} else {							/* No heading separator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
	}
#else
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
  405280:	780b      	ldrb	r3, [r1, #0]
  405282:	2b2f      	cmp	r3, #47	; 0x2f
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR *dj,			/* Directory object to return last directory and found object */
	const TCHAR *path	/* Full-path string to find a file or directory */
)
{
  405284:	b083      	sub	sp, #12
  405286:	4689      	mov	r9, r1
  405288:	4606      	mov	r6, r0
		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
	} else {							/* No heading separator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
	}
#else
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
  40528a:	f000 8133 	beq.w	4054f4 <follow_path+0x278>
  40528e:	2b5c      	cmp	r3, #92	; 0x5c
  405290:	f000 8130 	beq.w	4054f4 <follow_path+0x278>
		path++;
	dj->sclust = 0;						/* Start from the root dir */
  405294:	2400      	movs	r4, #0
  405296:	60b4      	str	r4, [r6, #8]
#endif

	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
  405298:	f899 0000 	ldrb.w	r0, [r9]
  40529c:	281f      	cmp	r0, #31
  40529e:	f240 8132 	bls.w	405506 <follow_path+0x28a>
  4052a2:	4da7      	ldr	r5, [pc, #668]	; (405540 <follow_path+0x2c4>)
  4052a4:	e001      	b.n	4052aa <follow_path+0x2e>
  4052a6:	f819 0f01 	ldrb.w	r0, [r9, #1]!
	WCHAR w, *lfn;
	UINT i, ni, si, di;
	const TCHAR *p;

	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
  4052aa:	282f      	cmp	r0, #47	; 0x2f
  4052ac:	d0fb      	beq.n	4052a6 <follow_path+0x2a>
  4052ae:	285c      	cmp	r0, #92	; 0x5c
  4052b0:	d0f9      	beq.n	4052a6 <follow_path+0x2a>
	lfn = dj->lfn;
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
  4052b2:	281f      	cmp	r0, #31
	UINT i, ni, si, di;
	const TCHAR *p;

	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
  4052b4:	69f7      	ldr	r7, [r6, #28]
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
  4052b6:	f240 80ec 	bls.w	405492 <follow_path+0x216>
  4052ba:	282f      	cmp	r0, #47	; 0x2f
  4052bc:	d02d      	beq.n	40531a <follow_path+0x9e>
  4052be:	285c      	cmp	r0, #92	; 0x5c
  4052c0:	d02b      	beq.n	40531a <follow_path+0x9e>
			b = (BYTE)p[si++];			/* Get 2nd byte */
			if (!IsDBCS2(b))
				return FR_INVALID_NAME;	/* Reject invalid sequence */
			w = (w << 8) + b;			/* Create a DBC */
		}
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
  4052c2:	2101      	movs	r1, #1
  4052c4:	f1a7 0b02 	sub.w	fp, r7, #2
  4052c8:	46ca      	mov	sl, r9
	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
  4052ca:	2401      	movs	r4, #1
			b = (BYTE)p[si++];			/* Get 2nd byte */
			if (!IsDBCS2(b))
				return FR_INVALID_NAME;	/* Reject invalid sequence */
			w = (w << 8) + b;			/* Create a DBC */
		}
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
  4052cc:	47a8      	blx	r5
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
  4052ce:	b300      	cbz	r0, 405312 <follow_path+0x96>
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
  4052d0:	287f      	cmp	r0, #127	; 0x7f
  4052d2:	d809      	bhi.n	4052e8 <follow_path+0x6c>
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
  4052d4:	2822      	cmp	r0, #34	; 0x22
  4052d6:	d01c      	beq.n	405312 <follow_path+0x96>
  4052d8:	4a9a      	ldr	r2, [pc, #616]	; (405544 <follow_path+0x2c8>)
  4052da:	e001      	b.n	4052e0 <follow_path+0x64>
  4052dc:	4298      	cmp	r0, r3
  4052de:	d018      	beq.n	405312 <follow_path+0x96>
  4052e0:	f812 3f01 	ldrb.w	r3, [r2, #1]!
  4052e4:	2b00      	cmp	r3, #0
  4052e6:	d1f9      	bne.n	4052dc <follow_path+0x60>
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
			return FR_INVALID_NAME;
		lfn[di++] = w;					/* Store the Unicode char */
  4052e8:	f82b 0f02 	strh.w	r0, [fp, #2]!
	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
  4052ec:	f81a 0f01 	ldrb.w	r0, [sl, #1]!
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
  4052f0:	281f      	cmp	r0, #31
	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
  4052f2:	f104 0301 	add.w	r3, r4, #1
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
  4052f6:	f240 80ce 	bls.w	405496 <follow_path+0x21a>
  4052fa:	282f      	cmp	r0, #47	; 0x2f
  4052fc:	d00f      	beq.n	40531e <follow_path+0xa2>
  4052fe:	285c      	cmp	r0, #92	; 0x5c
  405300:	d00d      	beq.n	40531e <follow_path+0xa2>
		if (di >= _MAX_LFN)				/* Reject too long name */
  405302:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  405306:	d004      	beq.n	405312 <follow_path+0x96>
			b = (BYTE)p[si++];			/* Get 2nd byte */
			if (!IsDBCS2(b))
				return FR_INVALID_NAME;	/* Reject invalid sequence */
			w = (w << 8) + b;			/* Create a DBC */
		}
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
  405308:	2101      	movs	r1, #1
	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
  40530a:	461c      	mov	r4, r3
			b = (BYTE)p[si++];			/* Get 2nd byte */
			if (!IsDBCS2(b))
				return FR_INVALID_NAME;	/* Reject invalid sequence */
			w = (w << 8) + b;			/* Create a DBC */
		}
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
  40530c:	47a8      	blx	r5
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
  40530e:	2800      	cmp	r0, #0
  405310:	d1de      	bne.n	4052d0 <follow_path+0x54>
		if (i >= ni || si == di) {		/* Extension or end of SFN */
			if (ni == 11) {				/* Long extension */
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
			if (si > di) break;			/* No extension */
  405312:	2006      	movs	r0, #6
			dj->sclust = LD_CLUST(dir);
		}
	}

	return res;
}
  405314:	b003      	add	sp, #12
  405316:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	const TCHAR *p;

	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
  40531a:	2400      	movs	r4, #0
	for (;;) {
		w = p[si++];					/* Get a character */
  40531c:	2301      	movs	r3, #1
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
			return FR_INVALID_NAME;
		lfn[di++] = w;					/* Store the Unicode char */
	}
	*path = &p[si];						/* Return pointer to the next segment */
  40531e:	4499      	add	r9, r3
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
  405320:	f04f 0b00 	mov.w	fp, #0
			dj->fn[i] = (i < di) ? '.' : ' ';
		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
		return FR_OK;
	}
#endif
	while (di) {						/* Strip trailing spaces and dots */
  405324:	2c00      	cmp	r4, #0
  405326:	d0f4      	beq.n	405312 <follow_path+0x96>
  405328:	eb07 0044 	add.w	r0, r7, r4, lsl #1
		w = lfn[di-1];
  40532c:	f830 2d02 	ldrh.w	r2, [r0, #-2]!
		if (w != ' ' && w != '.') break;
  405330:	2a20      	cmp	r2, #32
  405332:	d001      	beq.n	405338 <follow_path+0xbc>
  405334:	2a2e      	cmp	r2, #46	; 0x2e
  405336:	d102      	bne.n	40533e <follow_path+0xc2>
			dj->fn[i] = (i < di) ? '.' : ' ';
		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
		return FR_OK;
	}
#endif
	while (di) {						/* Strip trailing spaces and dots */
  405338:	3c01      	subs	r4, #1
  40533a:	d1f7      	bne.n	40532c <follow_path+0xb0>
  40533c:	e7e9      	b.n	405312 <follow_path+0x96>
		if (w != ' ' && w != '.') break;
		di--;
	}
	if (!di) return FR_INVALID_NAME;	/* Reject nul string */

	lfn[di] = 0;						/* LFN is created */
  40533e:	2300      	movs	r3, #0
  405340:	f827 3014 	strh.w	r3, [r7, r4, lsl #1]

	/* Create SFN in directory form */
	mem_set(dj->fn, ' ', 11);
  405344:	69b3      	ldr	r3, [r6, #24]
		if (w != ' ' && w != '.') break;
		di--;
	}
	if (!di) return FR_INVALID_NAME;	/* Reject nul string */

	lfn[di] = 0;						/* LFN is created */
  405346:	eb07 0044 	add.w	r0, r7, r4, lsl #1
  40534a:	f103 010b 	add.w	r1, r3, #11
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
  40534e:	2220      	movs	r2, #32
  405350:	f803 2b01 	strb.w	r2, [r3], #1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
  405354:	428b      	cmp	r3, r1
  405356:	d1fb      	bne.n	405350 <follow_path+0xd4>
  405358:	1ebb      	subs	r3, r7, #2
  40535a:	f04f 0a00 	mov.w	sl, #0
  40535e:	e001      	b.n	405364 <follow_path+0xe8>

	lfn[di] = 0;						/* LFN is created */

	/* Create SFN in directory form */
	mem_set(dj->fn, ' ', 11);
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
  405360:	f10a 0a01 	add.w	sl, sl, #1
  405364:	f833 2f02 	ldrh.w	r2, [r3, #2]!
  405368:	2a20      	cmp	r2, #32
  40536a:	d0f9      	beq.n	405360 <follow_path+0xe4>
  40536c:	2a2e      	cmp	r2, #46	; 0x2e
  40536e:	d0f7      	beq.n	405360 <follow_path+0xe4>
	if (si) cf |= NS_LOSS | NS_LFN;
  405370:	f1ba 0f00 	cmp.w	sl, #0
  405374:	d001      	beq.n	40537a <follow_path+0xfe>
  405376:	f04b 0b03 	orr.w	fp, fp, #3
  40537a:	4603      	mov	r3, r0
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
  40537c:	f833 1d02 	ldrh.w	r1, [r3, #-2]!
  405380:	292e      	cmp	r1, #46	; 0x2e
  405382:	d001      	beq.n	405388 <follow_path+0x10c>
  405384:	3c01      	subs	r4, #1
  405386:	d1f9      	bne.n	40537c <follow_path+0x100>

	lfn[di] = 0;						/* LFN is created */

	/* Create SFN in directory form */
	mem_set(dj->fn, ' ', 11);
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
  405388:	f04f 0c00 	mov.w	ip, #0
  40538c:	4610      	mov	r0, r2
  40538e:	46e0      	mov	r8, ip
  405390:	2308      	movs	r3, #8
	if (si) cf |= NS_LOSS | NS_LFN;
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */

	b = i = 0; ni = 8;
	for (;;) {
		w = lfn[si++];					/* Get an LFN char */
  405392:	f10a 0a01 	add.w	sl, sl, #1
		if (!w) break;					/* Break on end of the LFN */
  405396:	b378      	cbz	r0, 4053f8 <follow_path+0x17c>
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
  405398:	2820      	cmp	r0, #32
  40539a:	d01f      	beq.n	4053dc <follow_path+0x160>
  40539c:	282e      	cmp	r0, #46	; 0x2e
  40539e:	d01b      	beq.n	4053d8 <follow_path+0x15c>
			cf |= NS_LOSS | NS_LFN; continue;
		}

		if (i >= ni || si == di) {		/* Extension or end of SFN */
  4053a0:	459c      	cmp	ip, r3
  4053a2:	d220      	bcs.n	4053e6 <follow_path+0x16a>
  4053a4:	4554      	cmp	r4, sl
  4053a6:	d07a      	beq.n	40549e <follow_path+0x222>
			if (si > di) break;			/* No extension */
			si = di; i = 8; ni = 11;	/* Enter extension section */
			b <<= 2; continue;
		}

		if (w >= 0x80) {				/* Non ASCII char */
  4053a8:	287f      	cmp	r0, #127	; 0x7f
  4053aa:	f200 8083 	bhi.w	4054b4 <follow_path+0x238>
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
  4053ae:	282b      	cmp	r0, #43	; 0x2b
  4053b0:	f000 8090 	beq.w	4054d4 <follow_path+0x258>
  4053b4:	4a64      	ldr	r2, [pc, #400]	; (405548 <follow_path+0x2cc>)
  4053b6:	e002      	b.n	4053be <follow_path+0x142>
  4053b8:	4288      	cmp	r0, r1
  4053ba:	f000 808b 	beq.w	4054d4 <follow_path+0x258>
  4053be:	f812 1f01 	ldrb.w	r1, [r2, #1]!
  4053c2:	2900      	cmp	r1, #0
  4053c4:	d1f8      	bne.n	4053b8 <follow_path+0x13c>
			dj->fn[i++] = (BYTE)(w >> 8);
		} else {						/* Single byte char */
			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
			} else {
				if (IsUpper(w)) {		/* ASCII large capital */
  4053c6:	f1a0 0141 	sub.w	r1, r0, #65	; 0x41
  4053ca:	2919      	cmp	r1, #25
  4053cc:	f200 80a6 	bhi.w	40551c <follow_path+0x2a0>
					b |= 2;
  4053d0:	f048 0802 	orr.w	r8, r8, #2
  4053d4:	b2c0      	uxtb	r0, r0
  4053d6:	e080      	b.n	4054da <follow_path+0x25e>

	b = i = 0; ni = 8;
	for (;;) {
		w = lfn[si++];					/* Get an LFN char */
		if (!w) break;					/* Break on end of the LFN */
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
  4053d8:	4554      	cmp	r4, sl
  4053da:	d060      	beq.n	40549e <follow_path+0x222>
			cf |= NS_LOSS | NS_LFN; continue;
  4053dc:	f04b 0b03 	orr.w	fp, fp, #3
  4053e0:	f837 001a 	ldrh.w	r0, [r7, sl, lsl #1]
  4053e4:	e7d5      	b.n	405392 <follow_path+0x116>
		}

		if (i >= ni || si == di) {		/* Extension or end of SFN */
			if (ni == 11) {				/* Long extension */
  4053e6:	2b0b      	cmp	r3, #11
  4053e8:	f000 80a6 	beq.w	405538 <follow_path+0x2bc>
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
  4053ec:	4554      	cmp	r4, sl
  4053ee:	d058      	beq.n	4054a2 <follow_path+0x226>
			if (si > di) break;			/* No extension */
  4053f0:	45a2      	cmp	sl, r4

		if (i >= ni || si == di) {		/* Extension or end of SFN */
			if (ni == 11) {				/* Long extension */
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
  4053f2:	f04b 0b03 	orr.w	fp, fp, #3
			if (si > di) break;			/* No extension */
  4053f6:	d954      	bls.n	4054a2 <follow_path+0x226>
			}
		}
		dj->fn[i++] = (BYTE)w;
	}

	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */
  4053f8:	69b1      	ldr	r1, [r6, #24]
  4053fa:	7808      	ldrb	r0, [r1, #0]
  4053fc:	28e5      	cmp	r0, #229	; 0xe5
  4053fe:	d075      	beq.n	4054ec <follow_path+0x270>

	if (ni == 8) b <<= 2;
  405400:	2b08      	cmp	r3, #8
  405402:	bf04      	itt	eq
  405404:	ea4f 0288 	moveq.w	r2, r8, lsl #2
  405408:	fa5f f882 	uxtbeq.w	r8, r2
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
  40540c:	f008 030c 	and.w	r3, r8, #12
  405410:	2b0c      	cmp	r3, #12
  405412:	d068      	beq.n	4054e6 <follow_path+0x26a>
  405414:	f008 0003 	and.w	r0, r8, #3
  405418:	2803      	cmp	r0, #3
  40541a:	d064      	beq.n	4054e6 <follow_path+0x26a>
		cf |= NS_LFN;
	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended char, NT flags are created */
  40541c:	f01b 0f02 	tst.w	fp, #2
  405420:	d109      	bne.n	405436 <follow_path+0x1ba>
		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
  405422:	f008 0203 	and.w	r2, r8, #3
  405426:	2a01      	cmp	r2, #1
  405428:	bf08      	it	eq
  40542a:	f04b 0b10 	orreq.w	fp, fp, #16
		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
  40542e:	2b04      	cmp	r3, #4
  405430:	bf08      	it	eq
  405432:	f04b 0b08 	orreq.w	fp, fp, #8
	}

	dj->fn[NS] = cf;	/* SFN is created */
  405436:	f881 b00b 	strb.w	fp, [r1, #11]
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dj, 0);			/* Rewind directory object */
  40543a:	4630      	mov	r0, r6
  40543c:	2100      	movs	r1, #0
  40543e:	4b43      	ldr	r3, [pc, #268]	; (40554c <follow_path+0x2d0>)
  405440:	4798      	blx	r3
	if (res != FR_OK) return res;
  405442:	b9d0      	cbnz	r0, 40547a <follow_path+0x1fe>
  405444:	4b42      	ldr	r3, [pc, #264]	; (405550 <follow_path+0x2d4>)
  405446:	4630      	mov	r0, r6
  405448:	4798      	blx	r3
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			ns = *(dj->fn+NS);
  40544a:	69b3      	ldr	r3, [r6, #24]
  40544c:	7adb      	ldrb	r3, [r3, #11]
			if (res != FR_OK) {				/* Failed to find the object */
  40544e:	b9b0      	cbnz	r0, 40547e <follow_path+0x202>
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
  405450:	0759      	lsls	r1, r3, #29
  405452:	f53f af5f 	bmi.w	405314 <follow_path+0x98>
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
  405456:	6973      	ldr	r3, [r6, #20]
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
  405458:	7ada      	ldrb	r2, [r3, #11]
  40545a:	06d2      	lsls	r2, r2, #27
  40545c:	d568      	bpl.n	405530 <follow_path+0x2b4>
				res = FR_NO_PATH; break;
			}
			dj->sclust = LD_CLUST(dir);
  40545e:	7d5c      	ldrb	r4, [r3, #21]
  405460:	7d1a      	ldrb	r2, [r3, #20]
  405462:	7ed8      	ldrb	r0, [r3, #27]
  405464:	7e99      	ldrb	r1, [r3, #26]
  405466:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
  40546a:	ea41 2300 	orr.w	r3, r1, r0, lsl #8
  40546e:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  405472:	60b3      	str	r3, [r6, #8]
  405474:	f899 0000 	ldrb.w	r0, [r9]
		}
  405478:	e717      	b.n	4052aa <follow_path+0x2e>
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			ns = *(dj->fn+NS);
  40547a:	69b3      	ldr	r3, [r6, #24]
  40547c:	7adb      	ldrb	r3, [r3, #11]
			if (res != FR_OK) {				/* Failed to find the object */
				if (res != FR_NO_FILE) break;	/* Abort if any hard error occured */
  40547e:	2804      	cmp	r0, #4
  405480:	f47f af48 	bne.w	405314 <follow_path+0x98>
				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
					res = FR_OK;
					if (!(ns & NS_LAST)) continue;
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
  405484:	f013 0f04 	tst.w	r3, #4
  405488:	bf08      	it	eq
  40548a:	2005      	moveq	r0, #5
			dj->sclust = LD_CLUST(dir);
		}
	}

	return res;
}
  40548c:	b003      	add	sp, #12
  40548e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	const TCHAR *p;

	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
  405492:	2400      	movs	r4, #0
	for (;;) {
		w = p[si++];					/* Get a character */
  405494:	2301      	movs	r3, #1
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
			return FR_INVALID_NAME;
		lfn[di++] = w;					/* Store the Unicode char */
	}
	*path = &p[si];						/* Return pointer to the next segment */
  405496:	4499      	add	r9, r3
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
  405498:	f04f 0b04 	mov.w	fp, #4
  40549c:	e742      	b.n	405324 <follow_path+0xa8>
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
			cf |= NS_LOSS | NS_LFN; continue;
		}

		if (i >= ni || si == di) {		/* Extension or end of SFN */
			if (ni == 11) {				/* Long extension */
  40549e:	2b0b      	cmp	r3, #11
  4054a0:	d04a      	beq.n	405538 <follow_path+0x2bc>
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
			if (si > di) break;			/* No extension */
			si = di; i = 8; ni = 11;	/* Enter extension section */
			b <<= 2; continue;
  4054a2:	ea4f 0288 	mov.w	r2, r8, lsl #2
  4054a6:	fa5f f882 	uxtb.w	r8, r2
  4054aa:	46a2      	mov	sl, r4
			if (ni == 11) {				/* Long extension */
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
			if (si > di) break;			/* No extension */
			si = di; i = 8; ni = 11;	/* Enter extension section */
  4054ac:	230b      	movs	r3, #11
  4054ae:	f04f 0c08 	mov.w	ip, #8
  4054b2:	e795      	b.n	4053e0 <follow_path+0x164>
			b <<= 2; continue;
		}

		if (w >= 0x80) {				/* Non ASCII char */
#ifdef _EXCVT
			w = ff_convert(w, 0);		/* Unicode -> OEM code */
  4054b4:	2100      	movs	r1, #0
  4054b6:	e88d 1008 	stmia.w	sp, {r3, ip}
  4054ba:	47a8      	blx	r5
			if (w) w = excvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
  4054bc:	e89d 1008 	ldmia.w	sp, {r3, ip}
  4054c0:	b348      	cbz	r0, 405516 <follow_path+0x29a>
  4054c2:	4a24      	ldr	r2, [pc, #144]	; (405554 <follow_path+0x2d8>)
  4054c4:	4410      	add	r0, r2
#else
			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
#endif
			cf |= NS_LFN;				/* Force create LFN entry */
  4054c6:	f04b 0b02 	orr.w	fp, fp, #2
		}

		if (w >= 0x80) {				/* Non ASCII char */
#ifdef _EXCVT
			w = ff_convert(w, 0);		/* Unicode -> OEM code */
			if (w) w = excvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
  4054ca:	f810 0c80 	ldrb.w	r0, [r0, #-128]
			if (i >= ni - 1) {
				cf |= NS_LOSS | NS_LFN; i = ni; continue;
			}
			dj->fn[i++] = (BYTE)(w >> 8);
		} else {						/* Single byte char */
			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
  4054ce:	2800      	cmp	r0, #0
  4054d0:	f47f af6d 	bne.w	4053ae <follow_path+0x132>
				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
  4054d4:	f04b 0b03 	orr.w	fp, fp, #3
  4054d8:	205f      	movs	r0, #95	; 0x5f
						b |= 1; w -= 0x20;
					}
				}
			}
		}
		dj->fn[i++] = (BYTE)w;
  4054da:	69b1      	ldr	r1, [r6, #24]
  4054dc:	f801 000c 	strb.w	r0, [r1, ip]
  4054e0:	f10c 0c01 	add.w	ip, ip, #1
  4054e4:	e77c      	b.n	4053e0 <follow_path+0x164>

	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */

	if (ni == 8) b <<= 2;
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
		cf |= NS_LFN;
  4054e6:	f04b 0b02 	orr.w	fp, fp, #2
  4054ea:	e797      	b.n	40541c <follow_path+0x1a0>
			}
		}
		dj->fn[i++] = (BYTE)w;
	}

	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */
  4054ec:	2005      	movs	r0, #5
  4054ee:	7008      	strb	r0, [r1, #0]
  4054f0:	69b1      	ldr	r1, [r6, #24]
  4054f2:	e785      	b.n	405400 <follow_path+0x184>
	} else {							/* No heading separator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
	}
#else
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
		path++;
  4054f4:	f109 0901 	add.w	r9, r9, #1
	dj->sclust = 0;						/* Start from the root dir */
  4054f8:	2400      	movs	r4, #0
  4054fa:	60b4      	str	r4, [r6, #8]
#endif

	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
  4054fc:	f899 0000 	ldrb.w	r0, [r9]
  405500:	281f      	cmp	r0, #31
  405502:	f63f aece 	bhi.w	4052a2 <follow_path+0x26>
		res = dir_sdi(dj, 0);
  405506:	4630      	mov	r0, r6
  405508:	4621      	mov	r1, r4
  40550a:	4b10      	ldr	r3, [pc, #64]	; (40554c <follow_path+0x2d0>)
  40550c:	4798      	blx	r3
		dj->dir = 0;
  40550e:	6174      	str	r4, [r6, #20]
			dj->sclust = LD_CLUST(dir);
		}
	}

	return res;
}
  405510:	b003      	add	sp, #12
  405512:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			w = ff_convert(w, 0);		/* Unicode -> OEM code */
			if (w) w = excvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
#else
			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
#endif
			cf |= NS_LFN;				/* Force create LFN entry */
  405516:	f04b 0b02 	orr.w	fp, fp, #2
  40551a:	e7db      	b.n	4054d4 <follow_path+0x258>
				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
			} else {
				if (IsUpper(w)) {		/* ASCII large capital */
					b |= 2;
				} else {
					if (IsLower(w)) {	/* ASCII small capital */
  40551c:	f1a0 0161 	sub.w	r1, r0, #97	; 0x61
  405520:	2919      	cmp	r1, #25
						b |= 1; w -= 0x20;
  405522:	bf97      	itett	ls
  405524:	3820      	subls	r0, #32
  405526:	b2c0      	uxtbhi	r0, r0
  405528:	b2c0      	uxtbls	r0, r0
  40552a:	f048 0801 	orrls.w	r8, r8, #1
  40552e:	e7d4      	b.n	4054da <follow_path+0x25e>
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
				res = FR_NO_PATH; break;
  405530:	2005      	movs	r0, #5
			dj->sclust = LD_CLUST(dir);
		}
	}

	return res;
}
  405532:	b003      	add	sp, #12
  405534:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			cf |= NS_LOSS | NS_LFN; continue;
		}

		if (i >= ni || si == di) {		/* Extension or end of SFN */
			if (ni == 11) {				/* Long extension */
				cf |= NS_LOSS | NS_LFN; break;
  405538:	f04b 0b03 	orr.w	fp, fp, #3
  40553c:	230b      	movs	r3, #11
  40553e:	e75b      	b.n	4053f8 <follow_path+0x17c>
  405540:	00406529 	.word	0x00406529
  405544:	004160b4 	.word	0x004160b4
  405548:	004160c0 	.word	0x004160c0
  40554c:	0040484d 	.word	0x0040484d
  405550:	00404d9d 	.word	0x00404d9d
  405554:	00416034 	.word	0x00416034

00405558 <f_mount>:

FRESULT f_mount (
	BYTE vol,		/* Logical drive number to be mounted/unmounted */
	FATFS *fs		/* Pointer to new file system object (NULL for unmount)*/
)
{
  405558:	b4f0      	push	{r4, r5, r6, r7}
	FATFS *rfs;


	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
  40555a:	b110      	cbz	r0, 405562 <f_mount+0xa>
		return FR_INVALID_DRIVE;
  40555c:	200b      	movs	r0, #11
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */

	return FR_OK;
}
  40555e:	bcf0      	pop	{r4, r5, r6, r7}
  405560:	4770      	bx	lr
	FATFS *rfs;


	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
		return FR_INVALID_DRIVE;
	rfs = FatFs[vol];			/* Get current fs object */
  405562:	4d0b      	ldr	r5, [pc, #44]	; (405590 <f_mount+0x38>)
  405564:	682b      	ldr	r3, [r5, #0]

	if (rfs) {
  405566:	b15b      	cbz	r3, 405580 <f_mount+0x28>
  405568:	4c0a      	ldr	r4, [pc, #40]	; (405594 <f_mount+0x3c>)
)
{
	UINT i;

	for (i = 0; i < _FS_SHARE; i++) {
		if (Files[i].fs == fs) Files[i].fs = 0;
  40556a:	4607      	mov	r7, r0
  40556c:	4626      	mov	r6, r4
  40556e:	5822      	ldr	r2, [r4, r0]
  405570:	4293      	cmp	r3, r2
  405572:	bf08      	it	eq
  405574:	5187      	streq	r7, [r0, r6]
  405576:	300c      	adds	r0, #12
	FATFS *fs
)
{
	UINT i;

	for (i = 0; i < _FS_SHARE; i++) {
  405578:	2824      	cmp	r0, #36	; 0x24
  40557a:	d1f8      	bne.n	40556e <f_mount+0x16>
		clear_lock(rfs);
#endif
#if _FS_REENTRANT				/* Discard sync object of the current volume */
		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
#endif
		rfs->fs_type = 0;		/* Clear old fs object */
  40557c:	2200      	movs	r2, #0
  40557e:	701a      	strb	r2, [r3, #0]
	}

	if (fs) {
  405580:	b109      	cbz	r1, 405586 <f_mount+0x2e>
		fs->fs_type = 0;		/* Clear new fs object */
  405582:	2300      	movs	r3, #0
  405584:	700b      	strb	r3, [r1, #0]
#if _FS_REENTRANT				/* Create sync object for the new volume */
		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */
  405586:	6029      	str	r1, [r5, #0]

	return FR_OK;
  405588:	2000      	movs	r0, #0
}
  40558a:	bcf0      	pop	{r4, r5, r6, r7}
  40558c:	4770      	bx	lr
  40558e:	bf00      	nop
  405590:	200033c0 	.word	0x200033c0
  405594:	2000339c 	.word	0x2000339c

00405598 <f_open>:
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const TCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
  405598:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40559c:	f5ad 7d0f 	sub.w	sp, sp, #572	; 0x23c
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	fp->fs = 0;			/* Clear file object */
  4055a0:	2300      	movs	r3, #0
  4055a2:	6003      	str	r3, [r0, #0]
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const TCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
  4055a4:	4616      	mov	r6, r2
  4055a6:	9101      	str	r1, [sp, #4]

	fp->fs = 0;			/* Clear file object */

#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
  4055a8:	f002 021e 	and.w	r2, r2, #30
  4055ac:	4b9a      	ldr	r3, [pc, #616]	; (405818 <f_open+0x280>)
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const TCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
  4055ae:	4604      	mov	r4, r0

	fp->fs = 0;			/* Clear file object */

#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
  4055b0:	a905      	add	r1, sp, #20
  4055b2:	a801      	add	r0, sp, #4
  4055b4:	4798      	blx	r3
#else
	mode &= FA_READ;
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	INIT_BUF(dj);
  4055b6:	ab02      	add	r3, sp, #8
  4055b8:	aa0e      	add	r2, sp, #56	; 0x38
  4055ba:	930b      	str	r3, [sp, #44]	; 0x2c
  4055bc:	920c      	str	r2, [sp, #48]	; 0x30


	fp->fs = 0;			/* Clear file object */

#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
  4055be:	f006 071f 	and.w	r7, r6, #31
#else
	mode &= FA_READ;
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	INIT_BUF(dj);
	if (res == FR_OK)
  4055c2:	b130      	cbz	r0, 4055d2 <f_open+0x3a>
		else
			res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
#endif
	}
	/* Create or Open a file */
	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
  4055c4:	f016 0f1c 	tst.w	r6, #28
  4055c8:	d11a      	bne.n	405600 <f_open+0x68>
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
	}

	LEAVE_FF(dj.fs, res);
}
  4055ca:	f50d 7d0f 	add.w	sp, sp, #572	; 0x23c
  4055ce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	mode &= FA_READ;
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	INIT_BUF(dj);
	if (res == FR_OK)
		res = follow_path(&dj, path);	/* Follow the file path */
  4055d2:	9901      	ldr	r1, [sp, #4]
  4055d4:	4b91      	ldr	r3, [pc, #580]	; (40581c <f_open+0x284>)
  4055d6:	a805      	add	r0, sp, #20
  4055d8:	4798      	blx	r3
	dir = dj.dir;
  4055da:	9d0a      	ldr	r5, [sp, #40]	; 0x28

#if !_FS_READONLY	/* R/W configuration */
	if (res == FR_OK) {
  4055dc:	2800      	cmp	r0, #0
  4055de:	d1f1      	bne.n	4055c4 <f_open+0x2c>
		if (!dir)	/* Current dir itself */
  4055e0:	2d00      	cmp	r5, #0
  4055e2:	f000 80ab 	beq.w	40573c <f_open+0x1a4>
			res = FR_INVALID_NAME;
#if _FS_SHARE
		else
			res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
  4055e6:	f037 0801 	bics.w	r8, r7, #1
  4055ea:	bf0c      	ite	eq
  4055ec:	2100      	moveq	r1, #0
  4055ee:	2101      	movne	r1, #1
  4055f0:	a805      	add	r0, sp, #20
  4055f2:	4b8b      	ldr	r3, [pc, #556]	; (405820 <f_open+0x288>)
  4055f4:	4798      	blx	r3
#endif
	}
	/* Create or Open a file */
	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
  4055f6:	f016 0f1c 	tst.w	r6, #28
  4055fa:	d01b      	beq.n	405634 <f_open+0x9c>
		DWORD dw, cl;

		if (res != FR_OK) {					/* No file, create new */
  4055fc:	2800      	cmp	r0, #0
  4055fe:	d050      	beq.n	4056a2 <f_open+0x10a>
			if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
  405600:	2804      	cmp	r0, #4
  405602:	d1e2      	bne.n	4055ca <f_open+0x32>
static
int enq_lock (void)	/* Check if an entry is available for a new file */
{
	UINT i;

	for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
  405604:	4b87      	ldr	r3, [pc, #540]	; (405824 <f_open+0x28c>)
  405606:	681a      	ldr	r2, [r3, #0]
  405608:	b12a      	cbz	r2, 405616 <f_open+0x7e>
  40560a:	68da      	ldr	r2, [r3, #12]
  40560c:	b11a      	cbz	r2, 405616 <f_open+0x7e>
  40560e:	699b      	ldr	r3, [r3, #24]
		DWORD dw, cl;

		if (res != FR_OK) {					/* No file, create new */
			if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
#if _FS_SHARE
				res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
  405610:	2012      	movs	r0, #18
static
int enq_lock (void)	/* Check if an entry is available for a new file */
{
	UINT i;

	for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
  405612:	2b00      	cmp	r3, #0
  405614:	d1d9      	bne.n	4055ca <f_open+0x32>
		DWORD dw, cl;

		if (res != FR_OK) {					/* No file, create new */
			if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
#if _FS_SHARE
				res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
  405616:	a805      	add	r0, sp, #20
  405618:	4b83      	ldr	r3, [pc, #524]	; (405828 <f_open+0x290>)
  40561a:	4798      	blx	r3
#else
				res = dir_register(&dj);
#endif
			mode |= FA_CREATE_ALWAYS;		/* File is created */
  40561c:	f047 0708 	orr.w	r7, r7, #8
			dir = dj.dir;					/* New entry */
  405620:	9d0a      	ldr	r5, [sp, #40]	; 0x28
			} else {
				if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
					res = FR_EXIST;
			}
		}
		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
  405622:	2800      	cmp	r0, #0
  405624:	d1d1      	bne.n	4055ca <f_open+0x32>
  405626:	0738      	lsls	r0, r7, #28
  405628:	f100 808a 	bmi.w	405740 <f_open+0x1a8>
  40562c:	9e05      	ldr	r6, [sp, #20]
  40562e:	f027 0801 	bic.w	r8, r7, #1
  405632:	e011      	b.n	405658 <f_open+0xc0>
				}
			}
		}
	}
	else {	/* Open an existing file */
		if (res == FR_OK) {						/* Follow succeeded */
  405634:	2800      	cmp	r0, #0
  405636:	d1c8      	bne.n	4055ca <f_open+0x32>
			if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
  405638:	7aeb      	ldrb	r3, [r5, #11]
  40563a:	06d9      	lsls	r1, r3, #27
  40563c:	d43e      	bmi.n	4056bc <f_open+0x124>
				res = FR_NO_FILE;
			} else {
				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
  40563e:	07b2      	lsls	r2, r6, #30
  405640:	d501      	bpl.n	405646 <f_open+0xae>
  405642:	07db      	lsls	r3, r3, #31
  405644:	d435      	bmi.n	4056b2 <f_open+0x11a>
  405646:	f006 0308 	and.w	r3, r6, #8
  40564a:	b2db      	uxtb	r3, r3
  40564c:	9e05      	ldr	r6, [sp, #20]
					res = FR_DENIED;
			}
		}
	}
	if (res == FR_OK) {
		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
  40564e:	b11b      	cbz	r3, 405658 <f_open+0xc0>
			mode |= FA__WRITTEN;
  405650:	f047 0720 	orr.w	r7, r7, #32
  405654:	f027 0801 	bic.w	r8, r7, #1
		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
  405658:	6af3      	ldr	r3, [r6, #44]	; 0x2c
	UINT i;


	for (i = 0; i < _FS_SHARE; i++) {	/* Find the file */
		if (Files[i].fs == dj->fs &&
			Files[i].clu == dj->sclust &&
  40565a:	9807      	ldr	r0, [sp, #28]
			Files[i].idx == dj->index) break;
  40565c:	f8bd c01a 	ldrh.w	ip, [sp, #26]
  405660:	4a72      	ldr	r2, [pc, #456]	; (40582c <f_open+0x294>)
		}
	}
	if (res == FR_OK) {
		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
			mode |= FA__WRITTEN;
		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
  405662:	61e3      	str	r3, [r4, #28]
		fp->dir_ptr = dir;
  405664:	6225      	str	r5, [r4, #32]
)
{
	UINT i;


	for (i = 0; i < _FS_SHARE; i++) {	/* Find the file */
  405666:	2300      	movs	r3, #0
		if (Files[i].fs == dj->fs &&
  405668:	f852 1c08 	ldr.w	r1, [r2, #-8]
  40566c:	42b1      	cmp	r1, r6
  40566e:	d02a      	beq.n	4056c6 <f_open+0x12e>
)
{
	UINT i;


	for (i = 0; i < _FS_SHARE; i++) {	/* Find the file */
  405670:	3301      	adds	r3, #1
  405672:	2b03      	cmp	r3, #3
  405674:	f102 020c 	add.w	r2, r2, #12
  405678:	d1f6      	bne.n	405668 <f_open+0xd0>
			Files[i].clu == dj->sclust &&
			Files[i].idx == dj->index) break;
	}

	if (i == _FS_SHARE) {				/* Not opened. Register it as new. */
		for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
  40567a:	4a6a      	ldr	r2, [pc, #424]	; (405824 <f_open+0x28c>)
  40567c:	6813      	ldr	r3, [r2, #0]
  40567e:	2b00      	cmp	r3, #0
  405680:	f000 809a 	beq.w	4057b8 <f_open+0x220>
  405684:	68d3      	ldr	r3, [r2, #12]
  405686:	2b00      	cmp	r3, #0
  405688:	f000 8095 	beq.w	4057b6 <f_open+0x21e>
  40568c:	6993      	ldr	r3, [r2, #24]
  40568e:	2b00      	cmp	r3, #0
  405690:	f000 80ac 	beq.w	4057ec <f_open+0x254>
		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
			mode |= FA__WRITTEN;
		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
		fp->dir_ptr = dir;
#if _FS_SHARE
		fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
  405694:	2300      	movs	r3, #0
		if (!fp->lockid) res = FR_INT_ERR;
  405696:	2002      	movs	r0, #2
		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
			mode |= FA__WRITTEN;
		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
		fp->dir_ptr = dir;
#if _FS_SHARE
		fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
  405698:	6263      	str	r3, [r4, #36]	; 0x24
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
	}

	LEAVE_FF(dj.fs, res);
}
  40569a:	f50d 7d0f 	add.w	sp, sp, #572	; 0x23c
  40569e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
#endif
			mode |= FA_CREATE_ALWAYS;		/* File is created */
			dir = dj.dir;					/* New entry */
		}
		else {								/* Any object is already existing */
			if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
  4056a2:	7aeb      	ldrb	r3, [r5, #11]
  4056a4:	f013 0f11 	tst.w	r3, #17
  4056a8:	d103      	bne.n	4056b2 <f_open+0x11a>
				res = FR_DENIED;
			} else {
				if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
  4056aa:	0776      	lsls	r6, r6, #29
  4056ac:	d5bb      	bpl.n	405626 <f_open+0x8e>
					res = FR_EXIST;
  4056ae:	2008      	movs	r0, #8
  4056b0:	e78b      	b.n	4055ca <f_open+0x32>
		if (res == FR_OK) {						/* Follow succeeded */
			if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
				res = FR_NO_FILE;
			} else {
				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
					res = FR_DENIED;
  4056b2:	2007      	movs	r0, #7
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
	}

	LEAVE_FF(dj.fs, res);
}
  4056b4:	f50d 7d0f 	add.w	sp, sp, #572	; 0x23c
  4056b8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		}
	}
	else {	/* Open an existing file */
		if (res == FR_OK) {						/* Follow succeeded */
			if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
				res = FR_NO_FILE;
  4056bc:	2004      	movs	r0, #4
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
	}

	LEAVE_FF(dj.fs, res);
}
  4056be:	f50d 7d0f 	add.w	sp, sp, #572	; 0x23c
  4056c2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
{
	UINT i;


	for (i = 0; i < _FS_SHARE; i++) {	/* Find the file */
		if (Files[i].fs == dj->fs &&
  4056c6:	f852 1c04 	ldr.w	r1, [r2, #-4]
  4056ca:	4281      	cmp	r1, r0
  4056cc:	d1d0      	bne.n	405670 <f_open+0xd8>
			Files[i].clu == dj->sclust &&
  4056ce:	8811      	ldrh	r1, [r2, #0]
  4056d0:	4561      	cmp	r1, ip
  4056d2:	d1cd      	bne.n	405670 <f_open+0xd8>
  4056d4:	0059      	lsls	r1, r3, #1
  4056d6:	4a53      	ldr	r2, [pc, #332]	; (405824 <f_open+0x28c>)
  4056d8:	18c8      	adds	r0, r1, r3
  4056da:	eb02 0080 	add.w	r0, r2, r0, lsl #2
  4056de:	8940      	ldrh	r0, [r0, #10]
		Files[i].clu = dj->sclust;
		Files[i].idx = dj->index;
		Files[i].ctr = 0;
	}

	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
  4056e0:	f1b8 0f00 	cmp.w	r8, #0
  4056e4:	d161      	bne.n	4057aa <f_open+0x212>

	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
  4056e6:	3001      	adds	r0, #1
  4056e8:	b280      	uxth	r0, r0
  4056ea:	4419      	add	r1, r3
  4056ec:	eb02 0281 	add.w	r2, r2, r1, lsl #2

	return i + 1;
  4056f0:	3301      	adds	r3, #1
		Files[i].ctr = 0;
	}

	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */

	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
  4056f2:	8150      	strh	r0, [r2, #10]
		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
			mode |= FA__WRITTEN;
		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
		fp->dir_ptr = dir;
#if _FS_SHARE
		fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
  4056f4:	6263      	str	r3, [r4, #36]	; 0x24
		if (!fp->lockid) res = FR_INT_ERR;
  4056f6:	2b00      	cmp	r3, #0
  4056f8:	d052      	beq.n	4057a0 <f_open+0x208>
	}
#endif
	FREE_BUF();

	if (res == FR_OK) {
		fp->flag = mode;					/* File access mode */
  4056fa:	71a7      	strb	r7, [r4, #6]
		fp->sclust = LD_CLUST(dir);			/* File start cluster */
  4056fc:	7d68      	ldrb	r0, [r5, #21]
  4056fe:	7ea9      	ldrb	r1, [r5, #26]
  405700:	7d2a      	ldrb	r2, [r5, #20]
  405702:	7eeb      	ldrb	r3, [r5, #27]
  405704:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
  405708:	ea41 2303 	orr.w	r3, r1, r3, lsl #8
  40570c:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  405710:	6123      	str	r3, [r4, #16]
		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
  405712:	7fab      	ldrb	r3, [r5, #30]
  405714:	7fe8      	ldrb	r0, [r5, #31]
  405716:	7f29      	ldrb	r1, [r5, #28]
  405718:	7f6a      	ldrb	r2, [r5, #29]
		fp->fptr = 0;						/* File pointer */
		fp->dsect = 0;
#if _USE_FASTSEEK
		fp->cltbl = 0;						/* Normal seek mode */
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
  40571a:	6026      	str	r6, [r4, #0]
	FREE_BUF();

	if (res == FR_OK) {
		fp->flag = mode;					/* File access mode */
		fp->sclust = LD_CLUST(dir);			/* File start cluster */
		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
  40571c:	041b      	lsls	r3, r3, #16
  40571e:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
  405722:	430b      	orrs	r3, r1
		fp->fptr = 0;						/* File pointer */
  405724:	2000      	movs	r0, #0
	FREE_BUF();

	if (res == FR_OK) {
		fp->flag = mode;					/* File access mode */
		fp->sclust = LD_CLUST(dir);			/* File start cluster */
		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
  405726:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  40572a:	60e3      	str	r3, [r4, #12]
		fp->fptr = 0;						/* File pointer */
  40572c:	60a0      	str	r0, [r4, #8]
		fp->dsect = 0;
  40572e:	61a0      	str	r0, [r4, #24]
#if _USE_FASTSEEK
		fp->cltbl = 0;						/* Normal seek mode */
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
  405730:	88f3      	ldrh	r3, [r6, #6]
  405732:	80a3      	strh	r3, [r4, #4]
	}

	LEAVE_FF(dj.fs, res);
}
  405734:	f50d 7d0f 	add.w	sp, sp, #572	; 0x23c
  405738:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	dir = dj.dir;

#if !_FS_READONLY	/* R/W configuration */
	if (res == FR_OK) {
		if (!dir)	/* Current dir itself */
			res = FR_INVALID_NAME;
  40573c:	2006      	movs	r0, #6
  40573e:	e741      	b.n	4055c4 <f_open+0x2c>
				if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
					res = FR_EXIST;
			}
		}
		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
			dw = get_fattime();					/* Created time */
  405740:	4b3b      	ldr	r3, [pc, #236]	; (405830 <f_open+0x298>)
  405742:	4798      	blx	r3
			ST_DWORD(dir+DIR_CrtTime, dw);
			dir[DIR_Attr] = 0;					/* Reset attribute */
			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
			cl = LD_CLUST(dir);					/* Get start cluster */
  405744:	f895 c015 	ldrb.w	ip, [r5, #21]
  405748:	7eab      	ldrb	r3, [r5, #26]
  40574a:	7d29      	ldrb	r1, [r5, #20]
  40574c:	7eea      	ldrb	r2, [r5, #27]
			ST_CLUST(dir, 0);					/* cluster = 0 */
			dj.fs->wflag = 1;
  40574e:	9e05      	ldr	r6, [sp, #20]
					res = FR_EXIST;
			}
		}
		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
			dw = get_fattime();					/* Created time */
			ST_DWORD(dir+DIR_CrtTime, dw);
  405750:	73a8      	strb	r0, [r5, #14]
  405752:	ea4f 4810 	mov.w	r8, r0, lsr #16
			dir[DIR_Attr] = 0;					/* Reset attribute */
			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
			cl = LD_CLUST(dir);					/* Get start cluster */
  405756:	ea41 210c 	orr.w	r1, r1, ip, lsl #8
  40575a:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
					res = FR_EXIST;
			}
		}
		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
			dw = get_fattime();					/* Created time */
			ST_DWORD(dir+DIR_CrtTime, dw);
  40575e:	f3c0 2907 	ubfx	r9, r0, #8, #8
			dir[DIR_Attr] = 0;					/* Reset attribute */
  405762:	2300      	movs	r3, #0
					res = FR_EXIST;
			}
		}
		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
			dw = get_fattime();					/* Created time */
			ST_DWORD(dir+DIR_CrtTime, dw);
  405764:	f885 8010 	strb.w	r8, [r5, #16]
  405768:	0e00      	lsrs	r0, r0, #24
			dir[DIR_Attr] = 0;					/* Reset attribute */
			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
			cl = LD_CLUST(dir);					/* Get start cluster */
			ST_CLUST(dir, 0);					/* cluster = 0 */
			dj.fs->wflag = 1;
  40576a:	f04f 0c01 	mov.w	ip, #1
			if (cl) {							/* Remove the cluster chain if exist */
  40576e:	ea52 4801 	orrs.w	r8, r2, r1, lsl #16
					res = FR_EXIST;
			}
		}
		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
			dw = get_fattime();					/* Created time */
			ST_DWORD(dir+DIR_CrtTime, dw);
  405772:	f885 900f 	strb.w	r9, [r5, #15]
  405776:	7468      	strb	r0, [r5, #17]
			dir[DIR_Attr] = 0;					/* Reset attribute */
  405778:	72eb      	strb	r3, [r5, #11]
			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
  40577a:	772b      	strb	r3, [r5, #28]
  40577c:	776b      	strb	r3, [r5, #29]
  40577e:	77ab      	strb	r3, [r5, #30]
  405780:	77eb      	strb	r3, [r5, #31]
			cl = LD_CLUST(dir);					/* Get start cluster */
			ST_CLUST(dir, 0);					/* cluster = 0 */
  405782:	76ab      	strb	r3, [r5, #26]
  405784:	76eb      	strb	r3, [r5, #27]
  405786:	752b      	strb	r3, [r5, #20]
  405788:	756b      	strb	r3, [r5, #21]
			dj.fs->wflag = 1;
  40578a:	f886 c004 	strb.w	ip, [r6, #4]
			if (cl) {							/* Remove the cluster chain if exist */
  40578e:	f43f af5f 	beq.w	405650 <f_open+0xb8>
	DWORD nxt;
#if _USE_ERASE
	DWORD scl = clst, ecl = clst, resion[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
  405792:	45e0      	cmp	r8, ip
			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
			cl = LD_CLUST(dir);					/* Get start cluster */
			ST_CLUST(dir, 0);					/* cluster = 0 */
			dj.fs->wflag = 1;
			if (cl) {							/* Remove the cluster chain if exist */
				dw = dj.fs->winsect;
  405794:	f8d6 902c 	ldr.w	r9, [r6, #44]	; 0x2c
	DWORD nxt;
#if _USE_ERASE
	DWORD scl = clst, ecl = clst, resion[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
  405798:	d002      	beq.n	4057a0 <f_open+0x208>
  40579a:	69b3      	ldr	r3, [r6, #24]
  40579c:	4598      	cmp	r8, r3
  40579e:	d327      	bcc.n	4057f0 <f_open+0x258>
			mode |= FA__WRITTEN;
		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
		fp->dir_ptr = dir;
#if _FS_SHARE
		fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
		if (!fp->lockid) res = FR_INT_ERR;
  4057a0:	2002      	movs	r0, #2
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
	}

	LEAVE_FF(dj.fs, res);
}
  4057a2:	f50d 7d0f 	add.w	sp, sp, #572	; 0x23c
  4057a6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		Files[i].clu = dj->sclust;
		Files[i].idx = dj->index;
		Files[i].ctr = 0;
	}

	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
  4057aa:	2800      	cmp	r0, #0
  4057ac:	f47f af72 	bne.w	405694 <f_open+0xfc>

	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
  4057b0:	f44f 7080 	mov.w	r0, #256	; 0x100
  4057b4:	e799      	b.n	4056ea <f_open+0x152>
			Files[i].clu == dj->sclust &&
			Files[i].idx == dj->index) break;
	}

	if (i == _FS_SHARE) {				/* Not opened. Register it as new. */
		for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
  4057b6:	2301      	movs	r3, #1
		if (i == _FS_SHARE) return 0;	/* No space to register (int err) */
		Files[i].fs = dj->fs;
  4057b8:	0059      	lsls	r1, r3, #1
  4057ba:	eb01 0c03 	add.w	ip, r1, r3
  4057be:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
  4057c2:	eb02 000c 	add.w	r0, r2, ip
  4057c6:	f842 600c 	str.w	r6, [r2, ip]
		Files[i].clu = dj->sclust;
  4057ca:	f8dd b01c 	ldr.w	fp, [sp, #28]
		Files[i].idx = dj->index;
  4057ce:	f8bd a01a 	ldrh.w	sl, [sp, #26]

	if (i == _FS_SHARE) {				/* Not opened. Register it as new. */
		for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
		if (i == _FS_SHARE) return 0;	/* No space to register (int err) */
		Files[i].fs = dj->fs;
		Files[i].clu = dj->sclust;
  4057d2:	f8c0 b004 	str.w	fp, [r0, #4]
		Files[i].idx = dj->index;
		Files[i].ctr = 0;
  4057d6:	f04f 0c00 	mov.w	ip, #0
	if (i == _FS_SHARE) {				/* Not opened. Register it as new. */
		for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
		if (i == _FS_SHARE) return 0;	/* No space to register (int err) */
		Files[i].fs = dj->fs;
		Files[i].clu = dj->sclust;
		Files[i].idx = dj->index;
  4057da:	f8a0 a008 	strh.w	sl, [r0, #8]
		Files[i].ctr = 0;
  4057de:	f8a0 c00a 	strh.w	ip, [r0, #10]
	}

	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
  4057e2:	f1b8 0f00 	cmp.w	r8, #0
  4057e6:	d1e3      	bne.n	4057b0 <f_open+0x218>
  4057e8:	4640      	mov	r0, r8
  4057ea:	e77c      	b.n	4056e6 <f_open+0x14e>
			Files[i].clu == dj->sclust &&
			Files[i].idx == dj->index) break;
	}

	if (i == _FS_SHARE) {				/* Not opened. Register it as new. */
		for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
  4057ec:	2302      	movs	r3, #2
  4057ee:	e7e3      	b.n	4057b8 <f_open+0x220>
  4057f0:	4630      	mov	r0, r6
  4057f2:	4641      	mov	r1, r8
  4057f4:	4b0f      	ldr	r3, [pc, #60]	; (405834 <f_open+0x29c>)
  4057f6:	4798      	blx	r3
			ST_CLUST(dir, 0);					/* cluster = 0 */
			dj.fs->wflag = 1;
			if (cl) {							/* Remove the cluster chain if exist */
				dw = dj.fs->winsect;
				res = remove_chain(dj.fs, cl);
				if (res == FR_OK) {
  4057f8:	2800      	cmp	r0, #0
  4057fa:	f47f aee6 	bne.w	4055ca <f_open+0x32>
					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
  4057fe:	9805      	ldr	r0, [sp, #20]
					res = move_window(dj.fs, dw);
  405800:	4b0d      	ldr	r3, [pc, #52]	; (405838 <f_open+0x2a0>)
			dj.fs->wflag = 1;
			if (cl) {							/* Remove the cluster chain if exist */
				dw = dj.fs->winsect;
				res = remove_chain(dj.fs, cl);
				if (res == FR_OK) {
					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
  405802:	f108 32ff 	add.w	r2, r8, #4294967295
					res = move_window(dj.fs, dw);
  405806:	4649      	mov	r1, r9
			dj.fs->wflag = 1;
			if (cl) {							/* Remove the cluster chain if exist */
				dw = dj.fs->winsect;
				res = remove_chain(dj.fs, cl);
				if (res == FR_OK) {
					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
  405808:	60c2      	str	r2, [r0, #12]
					res = move_window(dj.fs, dw);
  40580a:	4798      	blx	r3
				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
					res = FR_DENIED;
			}
		}
	}
	if (res == FR_OK) {
  40580c:	2800      	cmp	r0, #0
  40580e:	f47f aedc 	bne.w	4055ca <f_open+0x32>
  405812:	9e05      	ldr	r6, [sp, #20]
  405814:	e71c      	b.n	405650 <f_open+0xb8>
  405816:	bf00      	nop
  405818:	00404451 	.word	0x00404451
  40581c:	0040527d 	.word	0x0040527d
  405820:	004040c5 	.word	0x004040c5
  405824:	2000339c 	.word	0x2000339c
  405828:	00404f05 	.word	0x00404f05
  40582c:	200033a4 	.word	0x200033a4
  405830:	0040406d 	.word	0x0040406d
  405834:	00405211 	.word	0x00405211
  405838:	00404241 	.word	0x00404241

0040583c <f_read>:
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
  40583c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  405840:	469b      	mov	fp, r3
  405842:	4606      	mov	r6, r0
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE csect, *rbuff = buff;


	*br = 0;	/* Initialize byte counter */
  405844:	2300      	movs	r3, #0
  405846:	f8cb 3000 	str.w	r3, [fp]
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
  40584a:	b083      	sub	sp, #12
  40584c:	460d      	mov	r5, r1
	BYTE csect, *rbuff = buff;


	*br = 0;	/* Initialize byte counter */

	res = validate(fp->fs, fp->id);				/* Check validity */
  40584e:	6800      	ldr	r0, [r0, #0]
  405850:	88b1      	ldrh	r1, [r6, #4]
  405852:	4b62      	ldr	r3, [pc, #392]	; (4059dc <f_read+0x1a0>)
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
  405854:	4614      	mov	r4, r2
	BYTE csect, *rbuff = buff;


	*br = 0;	/* Initialize byte counter */

	res = validate(fp->fs, fp->id);				/* Check validity */
  405856:	4798      	blx	r3
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
  405858:	b928      	cbnz	r0, 405866 <f_read+0x2a>
	if (fp->flag & FA__ERROR)					/* Aborted file? */
  40585a:	79b3      	ldrb	r3, [r6, #6]
  40585c:	061f      	lsls	r7, r3, #24
  40585e:	d405      	bmi.n	40586c <f_read+0x30>
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
  405860:	07d8      	lsls	r0, r3, #31
  405862:	d407      	bmi.n	405874 <f_read+0x38>
		LEAVE_FF(fp->fs, FR_DENIED);
  405864:	2007      	movs	r0, #7
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
}
  405866:	b003      	add	sp, #12
  405868:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	*br = 0;	/* Initialize byte counter */

	res = validate(fp->fs, fp->id);				/* Check validity */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)					/* Aborted file? */
		LEAVE_FF(fp->fs, FR_INT_ERR);
  40586c:	2002      	movs	r0, #2
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
}
  40586e:	b003      	add	sp, #12
  405870:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)					/* Aborted file? */
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
  405874:	68b1      	ldr	r1, [r6, #8]
  405876:	68f7      	ldr	r7, [r6, #12]
  405878:	1a7f      	subs	r7, r7, r1
  40587a:	42bc      	cmp	r4, r7
  40587c:	bf38      	it	cc
  40587e:	4627      	movcc	r7, r4
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
  405880:	2f00      	cmp	r7, #0
  405882:	f000 80a8 	beq.w	4059d6 <f_read+0x19a>
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
  405886:	f3c1 0308 	ubfx	r3, r1, #0, #9
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
					fp->flag &= ~FA__DIRTY;
				}
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
  40588a:	f8df 8158 	ldr.w	r8, [pc, #344]	; 4059e4 <f_read+0x1a8>
			}
#if !_FS_TINY
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
#if !_FS_READONLY
				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
  40588e:	f8df 9158 	ldr.w	r9, [pc, #344]	; 4059e8 <f_read+0x1ac>
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
  405892:	2b00      	cmp	r3, #0
  405894:	d13e      	bne.n	405914 <f_read+0xd8>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
  405896:	6830      	ldr	r0, [r6, #0]
  405898:	7883      	ldrb	r3, [r0, #2]
  40589a:	3b01      	subs	r3, #1
  40589c:	ea03 2351 	and.w	r3, r3, r1, lsr #9
			if (!csect) {						/* On the cluster boundary? */
  4058a0:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
  4058a4:	d04b      	beq.n	40593e <f_read+0x102>
  4058a6:	6972      	ldr	r2, [r6, #20]
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  4058a8:	6981      	ldr	r1, [r0, #24]
static DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
  4058aa:	f1a2 0c02 	sub.w	ip, r2, #2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  4058ae:	3902      	subs	r1, #2
  4058b0:	458c      	cmp	ip, r1
  4058b2:	d271      	bcs.n	405998 <f_read+0x15c>
	return clst * fs->csize + fs->database;
  4058b4:	7882      	ldrb	r2, [r0, #2]
  4058b6:	6a81      	ldr	r1, [r0, #40]	; 0x28
  4058b8:	fb02 110c 	mla	r1, r2, ip, r1
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
				fp->clust = clst;				/* Update current cluster */
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
  4058bc:	2900      	cmp	r1, #0
  4058be:	d06b      	beq.n	405998 <f_read+0x15c>
			sect += csect;
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
			if (cc) {							/* Read maximum contiguous sectors directly */
  4058c0:	0a7c      	lsrs	r4, r7, #9
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
				fp->clust = clst;				/* Update current cluster */
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
			sect += csect;
  4058c2:	eb01 0a03 	add.w	sl, r1, r3
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
			if (cc) {							/* Read maximum contiguous sectors directly */
  4058c6:	d043      	beq.n	405950 <f_read+0x114>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
  4058c8:	1919      	adds	r1, r3, r4
  4058ca:	4291      	cmp	r1, r2
					cc = fp->fs->csize - csect;
  4058cc:	bf88      	it	hi
  4058ce:	ebc3 0402 	rsbhi	r4, r3, r2
				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
  4058d2:	b2e3      	uxtb	r3, r4
  4058d4:	7840      	ldrb	r0, [r0, #1]
  4058d6:	4629      	mov	r1, r5
  4058d8:	4652      	mov	r2, sl
  4058da:	47c0      	blx	r8
					ABORT(fp->fs, FR_DISK_ERR);
  4058dc:	79b3      	ldrb	r3, [r6, #6]
			sect += csect;
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
			if (cc) {							/* Read maximum contiguous sectors directly */
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
					cc = fp->fs->csize - csect;
				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
  4058de:	2800      	cmp	r0, #0
  4058e0:	d161      	bne.n	4059a6 <f_read+0x16a>
#if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
#if _FS_TINY
				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
  4058e2:	065a      	lsls	r2, r3, #25
  4058e4:	d504      	bpl.n	4058f0 <f_read+0xb4>
  4058e6:	69b3      	ldr	r3, [r6, #24]
  4058e8:	ebca 0303 	rsb	r3, sl, r3
  4058ec:	429c      	cmp	r4, r3
  4058ee:	d85f      	bhi.n	4059b0 <f_read+0x174>
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
#endif
#endif
				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
  4058f0:	0262      	lsls	r2, r4, #9
  4058f2:	68b1      	ldr	r1, [r6, #8]
  4058f4:	18ab      	adds	r3, r5, r2
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
  4058f6:	4411      	add	r1, r2
  4058f8:	60b1      	str	r1, [r6, #8]
  4058fa:	f8db 1000 	ldr.w	r1, [fp]
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
  4058fe:	1abf      	subs	r7, r7, r2
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
  405900:	4411      	add	r1, r2
  405902:	461d      	mov	r5, r3
  405904:	f8cb 1000 	str.w	r1, [fp]
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
  405908:	d065      	beq.n	4059d6 <f_read+0x19a>
  40590a:	68b1      	ldr	r1, [r6, #8]
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
  40590c:	f3c1 0308 	ubfx	r3, r1, #0, #9
  405910:	2b00      	cmp	r3, #0
  405912:	d0c0      	beq.n	405896 <f_read+0x5a>
					ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
		}
		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
  405914:	f5c3 7200 	rsb	r2, r3, #512	; 0x200
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#else
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
  405918:	f103 0428 	add.w	r4, r3, #40	; 0x28
  40591c:	42ba      	cmp	r2, r7
  40591e:	bf28      	it	cs
  405920:	463a      	movcs	r2, r7
  405922:	4434      	add	r4, r6
  405924:	462b      	mov	r3, r5
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
  405926:	2a00      	cmp	r2, #0
  405928:	d0e5      	beq.n	4058f6 <f_read+0xba>
  40592a:	18ab      	adds	r3, r5, r2
  40592c:	4629      	mov	r1, r5
		*d++ = *s++;
  40592e:	f814 5b01 	ldrb.w	r5, [r4], #1
  405932:	f801 5b01 	strb.w	r5, [r1], #1
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
  405936:	4299      	cmp	r1, r3
  405938:	d1f9      	bne.n	40592e <f_read+0xf2>
  40593a:	68b1      	ldr	r1, [r6, #8]
  40593c:	e7db      	b.n	4058f6 <f_read+0xba>
	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
			if (!csect) {						/* On the cluster boundary? */
				if (fp->fptr == 0) {			/* On the top of the file? */
  40593e:	bb29      	cbnz	r1, 40598c <f_read+0x150>
					clst = fp->sclust;			/* Follow from the origin */
  405940:	6932      	ldr	r2, [r6, #16]
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
				}
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
  405942:	2a01      	cmp	r2, #1
  405944:	d928      	bls.n	405998 <f_read+0x15c>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
  405946:	1c51      	adds	r1, r2, #1
  405948:	d02c      	beq.n	4059a4 <f_read+0x168>
  40594a:	6830      	ldr	r0, [r6, #0]
				fp->clust = clst;				/* Update current cluster */
  40594c:	6172      	str	r2, [r6, #20]
  40594e:	e7ab      	b.n	4058a8 <f_read+0x6c>
#endif
				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
				continue;
			}
#if !_FS_TINY
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
  405950:	69b2      	ldr	r2, [r6, #24]
  405952:	4552      	cmp	r2, sl
  405954:	d014      	beq.n	405980 <f_read+0x144>
#if !_FS_READONLY
				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
  405956:	79b3      	ldrb	r3, [r6, #6]
  405958:	065b      	lsls	r3, r3, #25
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
  40595a:	f106 0428 	add.w	r4, r6, #40	; 0x28
				continue;
			}
#if !_FS_TINY
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
#if !_FS_READONLY
				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
  40595e:	d509      	bpl.n	405974 <f_read+0x138>
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
  405960:	2301      	movs	r3, #1
  405962:	7840      	ldrb	r0, [r0, #1]
  405964:	4621      	mov	r1, r4
  405966:	47c8      	blx	r9
						ABORT(fp->fs, FR_DISK_ERR);
  405968:	79b3      	ldrb	r3, [r6, #6]
			}
#if !_FS_TINY
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
#if !_FS_READONLY
				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
  40596a:	b9e0      	cbnz	r0, 4059a6 <f_read+0x16a>
						ABORT(fp->fs, FR_DISK_ERR);
					fp->flag &= ~FA__DIRTY;
  40596c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  405970:	6830      	ldr	r0, [r6, #0]
  405972:	71b3      	strb	r3, [r6, #6]
				}
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
  405974:	7840      	ldrb	r0, [r0, #1]
  405976:	4621      	mov	r1, r4
  405978:	4652      	mov	r2, sl
  40597a:	2301      	movs	r3, #1
  40597c:	47c0      	blx	r8
  40597e:	b988      	cbnz	r0, 4059a4 <f_read+0x168>
  405980:	68b1      	ldr	r1, [r6, #8]
					ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
  405982:	f8c6 a018 	str.w	sl, [r6, #24]
  405986:	f3c1 0308 	ubfx	r3, r1, #0, #9
  40598a:	e7c3      	b.n	405914 <f_read+0xd8>
#if _USE_FASTSEEK
					if (fp->cltbl)
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
  40598c:	6971      	ldr	r1, [r6, #20]
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  40598e:	2901      	cmp	r1, #1
  405990:	d902      	bls.n	405998 <f_read+0x15c>
  405992:	6982      	ldr	r2, [r0, #24]
  405994:	4291      	cmp	r1, r2
  405996:	d318      	bcc.n	4059ca <f_read+0x18e>
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
				fp->clust = clst;				/* Update current cluster */
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
  405998:	79b3      	ldrb	r3, [r6, #6]
  40599a:	f063 037f 	orn	r3, r3, #127	; 0x7f
  40599e:	71b3      	strb	r3, [r6, #6]
  4059a0:	2002      	movs	r0, #2
  4059a2:	e760      	b.n	405866 <f_read+0x2a>
						ABORT(fp->fs, FR_DISK_ERR);
					fp->flag &= ~FA__DIRTY;
				}
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
					ABORT(fp->fs, FR_DISK_ERR);
  4059a4:	79b3      	ldrb	r3, [r6, #6]
  4059a6:	f063 037f 	orn	r3, r3, #127	; 0x7f
  4059aa:	71b3      	strb	r3, [r6, #6]
  4059ac:	2001      	movs	r0, #1
  4059ae:	e75a      	b.n	405866 <f_read+0x2a>
#if _FS_TINY
				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
  4059b0:	eb05 2343 	add.w	r3, r5, r3, lsl #9
  4059b4:	f503 7000 	add.w	r0, r3, #512	; 0x200
  4059b8:	f106 0228 	add.w	r2, r6, #40	; 0x28
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
  4059bc:	f812 1b01 	ldrb.w	r1, [r2], #1
  4059c0:	f803 1b01 	strb.w	r1, [r3], #1
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
  4059c4:	4283      	cmp	r3, r0
  4059c6:	d1f9      	bne.n	4059bc <f_read+0x180>
  4059c8:	e792      	b.n	4058f0 <f_read+0xb4>
  4059ca:	9301      	str	r3, [sp, #4]
  4059cc:	4a04      	ldr	r2, [pc, #16]	; (4059e0 <f_read+0x1a4>)
  4059ce:	4790      	blx	r2
  4059d0:	9b01      	ldr	r3, [sp, #4]
  4059d2:	4602      	mov	r2, r0
  4059d4:	e7b5      	b.n	405942 <f_read+0x106>
#else
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
  4059d6:	2000      	movs	r0, #0
  4059d8:	e745      	b.n	405866 <f_read+0x2a>
  4059da:	bf00      	nop
  4059dc:	0040439d 	.word	0x0040439d
  4059e0:	00404781 	.word	0x00404781
  4059e4:	00403f15 	.word	0x00403f15
  4059e8:	00403f89 	.word	0x00403f89

004059ec <f_write>:
	FIL *fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT *bw			/* Pointer to number of bytes written */
)
{
  4059ec:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4059f0:	461e      	mov	r6, r3
  4059f2:	4604      	mov	r4, r0
	UINT wcnt, cc;
	const BYTE *wbuff = buff;
	BYTE csect;


	*bw = 0;	/* Initialize byte counter */
  4059f4:	2300      	movs	r3, #0
  4059f6:	6033      	str	r3, [r6, #0]
	FIL *fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT *bw			/* Pointer to number of bytes written */
)
{
  4059f8:	460f      	mov	r7, r1
	BYTE csect;


	*bw = 0;	/* Initialize byte counter */

	res = validate(fp->fs, fp->id);			/* Check validity */
  4059fa:	6800      	ldr	r0, [r0, #0]
  4059fc:	88a1      	ldrh	r1, [r4, #4]
  4059fe:	4b6f      	ldr	r3, [pc, #444]	; (405bbc <f_write+0x1d0>)
	FIL *fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT *bw			/* Pointer to number of bytes written */
)
{
  405a00:	4615      	mov	r5, r2
	BYTE csect;


	*bw = 0;	/* Initialize byte counter */

	res = validate(fp->fs, fp->id);			/* Check validity */
  405a02:	4798      	blx	r3
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
  405a04:	b928      	cbnz	r0, 405a12 <f_write+0x26>
	if (fp->flag & FA__ERROR)				/* Aborted file? */
  405a06:	79a3      	ldrb	r3, [r4, #6]
  405a08:	0618      	lsls	r0, r3, #24
  405a0a:	d404      	bmi.n	405a16 <f_write+0x2a>
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
  405a0c:	0799      	lsls	r1, r3, #30
  405a0e:	d405      	bmi.n	405a1c <f_write+0x30>
		LEAVE_FF(fp->fs, FR_DENIED);
  405a10:	2007      	movs	r0, #7

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
	fp->flag |= FA__WRITTEN;						/* Set file change flag */

	LEAVE_FF(fp->fs, FR_OK);
}
  405a12:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	*bw = 0;	/* Initialize byte counter */

	res = validate(fp->fs, fp->id);			/* Check validity */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)				/* Aborted file? */
		LEAVE_FF(fp->fs, FR_INT_ERR);
  405a16:	2002      	movs	r0, #2
  405a18:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */
  405a1c:	68e2      	ldr	r2, [r4, #12]
  405a1e:	42d5      	cmn	r5, r2
  405a20:	d309      	bcc.n	405a36 <f_write+0x4a>
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->flag |= FA__DIRTY;
#endif
	}

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
  405a22:	68a1      	ldr	r1, [r4, #8]
	fp->flag |= FA__WRITTEN;						/* Set file change flag */
  405a24:	f043 0320 	orr.w	r3, r3, #32
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->flag |= FA__DIRTY;
#endif
	}

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
  405a28:	4291      	cmp	r1, r2
  405a2a:	bf88      	it	hi
  405a2c:	60e1      	strhi	r1, [r4, #12]
	fp->flag |= FA__WRITTEN;						/* Set file change flag */
  405a2e:	71a3      	strb	r3, [r4, #6]

	LEAVE_FF(fp->fs, FR_OK);
  405a30:	2000      	movs	r0, #0
  405a32:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
  405a36:	2d00      	cmp	r5, #0
  405a38:	d0f3      	beq.n	405a22 <f_write+0x36>
			sect += csect;
			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
			if (cc) {						/* Write maximum contiguous sectors directly */
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
					cc = fp->fs->csize - csect;
				if (disk_write(fp->fs->drv, wbuff, sect, (BYTE)cc) != RES_OK)
  405a3a:	f8df a188 	ldr.w	sl, [pc, #392]	; 405bc4 <f_write+0x1d8>
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
  405a3e:	68a2      	ldr	r2, [r4, #8]
  405a40:	f3c2 0308 	ubfx	r3, r2, #0, #9
  405a44:	2b00      	cmp	r3, #0
  405a46:	d16b      	bne.n	405b20 <f_write+0x134>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
  405a48:	6820      	ldr	r0, [r4, #0]
  405a4a:	f890 c002 	ldrb.w	ip, [r0, #2]
  405a4e:	f10c 3cff 	add.w	ip, ip, #4294967295
  405a52:	ea0c 2c52 	and.w	ip, ip, r2, lsr #9
			if (!csect) {					/* On the cluster boundary? */
  405a56:	f01c 0bff 	ands.w	fp, ip, #255	; 0xff
  405a5a:	d10d      	bne.n	405a78 <f_write+0x8c>
				if (fp->fptr == 0) {		/* On the top of the file? */
  405a5c:	2a00      	cmp	r2, #0
  405a5e:	f040 8089 	bne.w	405b74 <f_write+0x188>
					clst = fp->sclust;		/* Follow from the origin */
  405a62:	6921      	ldr	r1, [r4, #16]
					if (clst == 0)			/* When no cluster is allocated, */
  405a64:	2900      	cmp	r1, #0
  405a66:	f000 808e 	beq.w	405b86 <f_write+0x19a>
					else
#endif
						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
  405a6a:	2901      	cmp	r1, #1
  405a6c:	f000 809f 	beq.w	405bae <f_write+0x1c2>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
  405a70:	1c4a      	adds	r2, r1, #1
  405a72:	d078      	beq.n	405b66 <f_write+0x17a>
  405a74:	6820      	ldr	r0, [r4, #0]
				fp->clust = clst;			/* Update current cluster */
  405a76:	6161      	str	r1, [r4, #20]
			}
#if _FS_TINY
			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write-back sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
#else
			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
  405a78:	79a2      	ldrb	r2, [r4, #6]
  405a7a:	0653      	lsls	r3, r2, #25
  405a7c:	d466      	bmi.n	405b4c <f_write+0x160>
static DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
  405a7e:	6961      	ldr	r1, [r4, #20]
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  405a80:	6982      	ldr	r2, [r0, #24]
static DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
  405a82:	f1a1 0802 	sub.w	r8, r1, #2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  405a86:	3a02      	subs	r2, #2
  405a88:	4590      	cmp	r8, r2
  405a8a:	f080 8090 	bcs.w	405bae <f_write+0x1c2>
	return clst * fs->csize + fs->database;
  405a8e:	7881      	ldrb	r1, [r0, #2]
  405a90:	6a82      	ldr	r2, [r0, #40]	; 0x28
  405a92:	fb08 2201 	mla	r2, r8, r1, r2
					ABORT(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
			}
#endif
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
  405a96:	2a00      	cmp	r2, #0
  405a98:	f000 8089 	beq.w	405bae <f_write+0x1c2>
			sect += csect;
			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
			if (cc) {						/* Write maximum contiguous sectors directly */
  405a9c:	ea5f 2955 	movs.w	r9, r5, lsr #9
				fp->flag &= ~FA__DIRTY;
			}
#endif
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
			sect += csect;
  405aa0:	eb0b 0802 	add.w	r8, fp, r2
			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
			if (cc) {						/* Write maximum contiguous sectors directly */
  405aa4:	d031      	beq.n	405b0a <f_write+0x11e>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
  405aa6:	eb09 020b 	add.w	r2, r9, fp
  405aaa:	428a      	cmp	r2, r1
					cc = fp->fs->csize - csect;
  405aac:	bf88      	it	hi
  405aae:	ebcb 0901 	rsbhi	r9, fp, r1
				if (disk_write(fp->fs->drv, wbuff, sect, (BYTE)cc) != RES_OK)
  405ab2:	7840      	ldrb	r0, [r0, #1]
  405ab4:	4639      	mov	r1, r7
  405ab6:	4642      	mov	r2, r8
  405ab8:	fa5f f389 	uxtb.w	r3, r9
  405abc:	47d0      	blx	sl
  405abe:	2800      	cmp	r0, #0
  405ac0:	d151      	bne.n	405b66 <f_write+0x17a>
				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
					fp->fs->wflag = 0;
				}
#else
				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
  405ac2:	69a2      	ldr	r2, [r4, #24]
  405ac4:	ebc8 0802 	rsb	r8, r8, r2
  405ac8:	45c1      	cmp	r9, r8
  405aca:	d90f      	bls.n	405aec <f_write+0x100>
					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
  405acc:	eb07 2248 	add.w	r2, r7, r8, lsl #9
  405ad0:	f104 0328 	add.w	r3, r4, #40	; 0x28
  405ad4:	f504 700a 	add.w	r0, r4, #552	; 0x228
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
  405ad8:	f812 1b01 	ldrb.w	r1, [r2], #1
  405adc:	f803 1b01 	strb.w	r1, [r3], #1
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
  405ae0:	4283      	cmp	r3, r0
  405ae2:	d1f9      	bne.n	405ad8 <f_write+0xec>
					fp->fs->wflag = 0;
				}
#else
				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
					fp->flag &= ~FA__DIRTY;
  405ae4:	79a3      	ldrb	r3, [r4, #6]
  405ae6:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  405aea:	71a3      	strb	r3, [r4, #6]
				}
#endif
				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
  405aec:	ea4f 2049 	mov.w	r0, r9, lsl #9
  405af0:	68a2      	ldr	r2, [r4, #8]
  405af2:	1839      	adds	r1, r7, r0
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
  405af4:	4402      	add	r2, r0
  405af6:	60a2      	str	r2, [r4, #8]
  405af8:	6833      	ldr	r3, [r6, #0]
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
  405afa:	1a2d      	subs	r5, r5, r0
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
  405afc:	4403      	add	r3, r0
  405afe:	460f      	mov	r7, r1
  405b00:	6033      	str	r3, [r6, #0]
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
  405b02:	d19c      	bne.n	405a3e <f_write+0x52>
  405b04:	68e2      	ldr	r2, [r4, #12]
  405b06:	79a3      	ldrb	r3, [r4, #6]
  405b08:	e78b      	b.n	405a22 <f_write+0x36>
			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
  405b0a:	69a2      	ldr	r2, [r4, #24]
  405b0c:	4542      	cmp	r2, r8
				if (fp->fptr < fp->fsize &&
  405b0e:	68a2      	ldr	r2, [r4, #8]
			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
  405b10:	d002      	beq.n	405b18 <f_write+0x12c>
				if (fp->fptr < fp->fsize &&
  405b12:	68e1      	ldr	r1, [r4, #12]
  405b14:	428a      	cmp	r2, r1
  405b16:	d33e      	bcc.n	405b96 <f_write+0x1aa>
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
  405b18:	f8c4 8018 	str.w	r8, [r4, #24]
  405b1c:	f3c2 0308 	ubfx	r3, r2, #0, #9
		}
		wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
  405b20:	f5c3 7000 	rsb	r0, r3, #512	; 0x200
  405b24:	42a8      	cmp	r0, r5
  405b26:	bf28      	it	cs
  405b28:	4628      	movcs	r0, r5
		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->fs->wflag = 1;
#else
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
  405b2a:	3328      	adds	r3, #40	; 0x28
  405b2c:	4423      	add	r3, r4
  405b2e:	4639      	mov	r1, r7
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
  405b30:	b138      	cbz	r0, 405b42 <f_write+0x156>
  405b32:	1839      	adds	r1, r7, r0
		*d++ = *s++;
  405b34:	f817 2b01 	ldrb.w	r2, [r7], #1
  405b38:	f803 2b01 	strb.w	r2, [r3], #1
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
  405b3c:	428f      	cmp	r7, r1
  405b3e:	d1f9      	bne.n	405b34 <f_write+0x148>
  405b40:	68a2      	ldr	r2, [r4, #8]
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->fs->wflag = 1;
#else
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->flag |= FA__DIRTY;
  405b42:	79a3      	ldrb	r3, [r4, #6]
  405b44:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  405b48:	71a3      	strb	r3, [r4, #6]
  405b4a:	e7d3      	b.n	405af4 <f_write+0x108>
#if _FS_TINY
			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write-back sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
#else
			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
  405b4c:	7840      	ldrb	r0, [r0, #1]
  405b4e:	69a2      	ldr	r2, [r4, #24]
  405b50:	f104 0128 	add.w	r1, r4, #40	; 0x28
  405b54:	2301      	movs	r3, #1
  405b56:	47d0      	blx	sl
  405b58:	b928      	cbnz	r0, 405b66 <f_write+0x17a>
					ABORT(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
  405b5a:	79a2      	ldrb	r2, [r4, #6]
  405b5c:	6820      	ldr	r0, [r4, #0]
  405b5e:	f022 0240 	bic.w	r2, r2, #64	; 0x40
  405b62:	71a2      	strb	r2, [r4, #6]
  405b64:	e78b      	b.n	405a7e <f_write+0x92>
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
				if (fp->fptr < fp->fsize &&
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
  405b66:	79a3      	ldrb	r3, [r4, #6]
  405b68:	f063 037f 	orn	r3, r3, #127	; 0x7f
  405b6c:	71a3      	strb	r3, [r4, #6]
  405b6e:	2001      	movs	r0, #1
  405b70:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
#if _USE_FASTSEEK
					if (fp->cltbl)
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
  405b74:	6961      	ldr	r1, [r4, #20]
  405b76:	f8df c048 	ldr.w	ip, [pc, #72]	; 405bc0 <f_write+0x1d4>
  405b7a:	47e0      	blx	ip
  405b7c:	4601      	mov	r1, r0
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
  405b7e:	2900      	cmp	r1, #0
  405b80:	f47f af73 	bne.w	405a6a <f_write+0x7e>
  405b84:	e7be      	b.n	405b04 <f_write+0x118>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
			if (!csect) {					/* On the cluster boundary? */
				if (fp->fptr == 0) {		/* On the top of the file? */
					clst = fp->sclust;		/* Follow from the origin */
					if (clst == 0)			/* When no cluster is allocated, */
						fp->sclust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
  405b86:	4b0e      	ldr	r3, [pc, #56]	; (405bc0 <f_write+0x1d4>)
  405b88:	4798      	blx	r3
  405b8a:	4601      	mov	r1, r0
  405b8c:	6120      	str	r0, [r4, #16]
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
  405b8e:	2900      	cmp	r1, #0
  405b90:	f47f af6b 	bne.w	405a6a <f_write+0x7e>
  405b94:	e7b6      	b.n	405b04 <f_write+0x118>
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
				if (fp->fptr < fp->fsize &&
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
  405b96:	7840      	ldrb	r0, [r0, #1]
  405b98:	f8df c02c 	ldr.w	ip, [pc, #44]	; 405bc8 <f_write+0x1dc>
  405b9c:	f104 0128 	add.w	r1, r4, #40	; 0x28
  405ba0:	4642      	mov	r2, r8
  405ba2:	2301      	movs	r3, #1
  405ba4:	47e0      	blx	ip
				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
				if (fp->fptr < fp->fsize &&
  405ba6:	2800      	cmp	r0, #0
  405ba8:	d1dd      	bne.n	405b66 <f_write+0x17a>
  405baa:	68a2      	ldr	r2, [r4, #8]
  405bac:	e7b4      	b.n	405b18 <f_write+0x12c>
					ABORT(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
			}
#endif
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
  405bae:	79a3      	ldrb	r3, [r4, #6]
  405bb0:	f063 037f 	orn	r3, r3, #127	; 0x7f
  405bb4:	71a3      	strb	r3, [r4, #6]
  405bb6:	2002      	movs	r0, #2
  405bb8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  405bbc:	0040439d 	.word	0x0040439d
  405bc0:	004049f5 	.word	0x004049f5
  405bc4:	00403f89 	.word	0x00403f89
  405bc8:	00403f15 	.word	0x00403f15

00405bcc <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL *fp		/* Pointer to the file object */
)
{
  405bcc:	b538      	push	{r3, r4, r5, lr}
  405bce:	4604      	mov	r4, r0
	FRESULT res;
	DWORD tim;
	BYTE *dir;


	res = validate(fp->fs, fp->id);		/* Check validity of the object */
  405bd0:	4b27      	ldr	r3, [pc, #156]	; (405c70 <f_sync+0xa4>)
  405bd2:	6800      	ldr	r0, [r0, #0]
  405bd4:	88a1      	ldrh	r1, [r4, #4]
  405bd6:	4798      	blx	r3
	if (res == FR_OK) {
  405bd8:	b9d0      	cbnz	r0, 405c10 <f_sync+0x44>
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
  405bda:	79a2      	ldrb	r2, [r4, #6]
  405bdc:	f002 0320 	and.w	r3, r2, #32
  405be0:	f003 00ff 	and.w	r0, r3, #255	; 0xff
  405be4:	b1a3      	cbz	r3, 405c10 <f_sync+0x44>
#if !_FS_TINY	/* Write-back dirty buffer */
			if (fp->flag & FA__DIRTY) {
  405be6:	0653      	lsls	r3, r2, #25
  405be8:	d50d      	bpl.n	405c06 <f_sync+0x3a>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
  405bea:	4621      	mov	r1, r4
  405bec:	69a2      	ldr	r2, [r4, #24]
  405bee:	f851 3b28 	ldr.w	r3, [r1], #40
  405bf2:	4d20      	ldr	r5, [pc, #128]	; (405c74 <f_sync+0xa8>)
  405bf4:	7858      	ldrb	r0, [r3, #1]
  405bf6:	2301      	movs	r3, #1
  405bf8:	47a8      	blx	r5
  405bfa:	2800      	cmp	r0, #0
  405bfc:	d136      	bne.n	405c6c <f_sync+0xa0>
					LEAVE_FF(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
  405bfe:	79a3      	ldrb	r3, [r4, #6]
  405c00:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  405c04:	71a3      	strb	r3, [r4, #6]
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
  405c06:	6820      	ldr	r0, [r4, #0]
  405c08:	69e1      	ldr	r1, [r4, #28]
  405c0a:	4b1b      	ldr	r3, [pc, #108]	; (405c78 <f_sync+0xac>)
  405c0c:	4798      	blx	r3
			if (res == FR_OK) {
  405c0e:	b100      	cbz	r0, 405c12 <f_sync+0x46>
			}
		}
	}

	LEAVE_FF(fp->fs, res);
}
  405c10:	bd38      	pop	{r3, r4, r5, pc}
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
			if (res == FR_OK) {
				dir = fp->dir_ptr;
  405c12:	6a25      	ldr	r5, [r4, #32]
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
				ST_CLUST(dir, fp->sclust);					/* Update start cluster */
				tim = get_fattime();						/* Update updated time */
  405c14:	4a19      	ldr	r2, [pc, #100]	; (405c7c <f_sync+0xb0>)
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
			if (res == FR_OK) {
				dir = fp->dir_ptr;
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
  405c16:	7aeb      	ldrb	r3, [r5, #11]
  405c18:	f043 0320 	orr.w	r3, r3, #32
  405c1c:	72eb      	strb	r3, [r5, #11]
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
  405c1e:	68e3      	ldr	r3, [r4, #12]
  405c20:	772b      	strb	r3, [r5, #28]
  405c22:	89a3      	ldrh	r3, [r4, #12]
  405c24:	0a1b      	lsrs	r3, r3, #8
  405c26:	776b      	strb	r3, [r5, #29]
  405c28:	89e3      	ldrh	r3, [r4, #14]
  405c2a:	77ab      	strb	r3, [r5, #30]
  405c2c:	7be3      	ldrb	r3, [r4, #15]
  405c2e:	77eb      	strb	r3, [r5, #31]
				ST_CLUST(dir, fp->sclust);					/* Update start cluster */
  405c30:	6923      	ldr	r3, [r4, #16]
  405c32:	76ab      	strb	r3, [r5, #26]
  405c34:	8a23      	ldrh	r3, [r4, #16]
  405c36:	0a1b      	lsrs	r3, r3, #8
  405c38:	76eb      	strb	r3, [r5, #27]
  405c3a:	8a63      	ldrh	r3, [r4, #18]
  405c3c:	752b      	strb	r3, [r5, #20]
  405c3e:	8a63      	ldrh	r3, [r4, #18]
  405c40:	0a1b      	lsrs	r3, r3, #8
  405c42:	756b      	strb	r3, [r5, #21]
				tim = get_fattime();						/* Update updated time */
  405c44:	4790      	blx	r2
				ST_DWORD(dir+DIR_WrtTime, tim);
  405c46:	f3c0 2107 	ubfx	r1, r0, #8, #8
  405c4a:	0c02      	lsrs	r2, r0, #16
  405c4c:	0e03      	lsrs	r3, r0, #24
  405c4e:	75e9      	strb	r1, [r5, #23]
  405c50:	762a      	strb	r2, [r5, #24]
  405c52:	75a8      	strb	r0, [r5, #22]
  405c54:	766b      	strb	r3, [r5, #25]
				fp->flag &= ~FA__WRITTEN;
  405c56:	79a0      	ldrb	r0, [r4, #6]
				fp->fs->wflag = 1;
  405c58:	6823      	ldr	r3, [r4, #0]
				res = sync(fp->fs);
  405c5a:	4a09      	ldr	r2, [pc, #36]	; (405c80 <f_sync+0xb4>)
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
				ST_CLUST(dir, fp->sclust);					/* Update start cluster */
				tim = get_fattime();						/* Update updated time */
				ST_DWORD(dir+DIR_WrtTime, tim);
				fp->flag &= ~FA__WRITTEN;
  405c5c:	f020 0020 	bic.w	r0, r0, #32
				fp->fs->wflag = 1;
  405c60:	2101      	movs	r1, #1
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
				ST_CLUST(dir, fp->sclust);					/* Update start cluster */
				tim = get_fattime();						/* Update updated time */
				ST_DWORD(dir+DIR_WrtTime, tim);
				fp->flag &= ~FA__WRITTEN;
  405c62:	71a0      	strb	r0, [r4, #6]
				fp->fs->wflag = 1;
  405c64:	7119      	strb	r1, [r3, #4]
				res = sync(fp->fs);
  405c66:	6820      	ldr	r0, [r4, #0]
  405c68:	4790      	blx	r2
  405c6a:	bd38      	pop	{r3, r4, r5, pc}
	if (res == FR_OK) {
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
#if !_FS_TINY	/* Write-back dirty buffer */
			if (fp->flag & FA__DIRTY) {
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
					LEAVE_FF(fp->fs, FR_DISK_ERR);
  405c6c:	2001      	movs	r0, #1
  405c6e:	e7cf      	b.n	405c10 <f_sync+0x44>
  405c70:	0040439d 	.word	0x0040439d
  405c74:	00403f89 	.word	0x00403f89
  405c78:	00404241 	.word	0x00404241
  405c7c:	0040406d 	.word	0x0040406d
  405c80:	004042c5 	.word	0x004042c5

00405c84 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
  405c84:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	res = validate(fs, fp->id);
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
	LEAVE_FF(fs, res);

#else
	res = f_sync(fp);		/* Flush cached data */
  405c86:	4b10      	ldr	r3, [pc, #64]	; (405cc8 <f_close+0x44>)
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
  405c88:	4604      	mov	r4, r0
	res = validate(fs, fp->id);
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
	LEAVE_FF(fs, res);

#else
	res = f_sync(fp);		/* Flush cached data */
  405c8a:	4798      	blx	r3
#if _FS_SHARE
	if (res == FR_OK) {		/* Decrement open counter */
  405c8c:	b998      	cbnz	r0, 405cb6 <f_close+0x32>
{
	WORD n;
	FRESULT res;


	if (--i < _FS_SHARE) {
  405c8e:	6a63      	ldr	r3, [r4, #36]	; 0x24
  405c90:	3b01      	subs	r3, #1
  405c92:	2b02      	cmp	r3, #2
  405c94:	d810      	bhi.n	405cb8 <f_close+0x34>
		n = Files[i].ctr;
  405c96:	005d      	lsls	r5, r3, #1
  405c98:	490c      	ldr	r1, [pc, #48]	; (405ccc <f_close+0x48>)
  405c9a:	18ea      	adds	r2, r5, r3
  405c9c:	eb01 0282 	add.w	r2, r1, r2, lsl #2
  405ca0:	3208      	adds	r2, #8
  405ca2:	8856      	ldrh	r6, [r2, #2]
		if (n == 0x100) n = 0;
		if (n) n--;
  405ca4:	f426 7780 	bic.w	r7, r6, #256	; 0x100
  405ca8:	b147      	cbz	r7, 405cbc <f_close+0x38>
  405caa:	3e01      	subs	r6, #1
  405cac:	b2b6      	uxth	r6, r6
		Files[i].ctr = n;
  405cae:	8056      	strh	r6, [r2, #2]
		if (!n) Files[i].fs = 0;
  405cb0:	b12e      	cbz	r6, 405cbe <f_close+0x3a>
#else
		res = dec_lock(fp->lockid);
#endif
	}
#endif
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
  405cb2:	2300      	movs	r3, #0
  405cb4:	6023      	str	r3, [r4, #0]
	return res;
#endif
}
  405cb6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (n) n--;
		Files[i].ctr = n;
		if (!n) Files[i].fs = 0;
		res = FR_OK;
	} else {
		res = FR_INT_ERR;
  405cb8:	2002      	movs	r0, #2
  405cba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	if (--i < _FS_SHARE) {
		n = Files[i].ctr;
		if (n == 0x100) n = 0;
		if (n) n--;
		Files[i].ctr = n;
  405cbc:	8050      	strh	r0, [r2, #2]
		if (!n) Files[i].fs = 0;
  405cbe:	442b      	add	r3, r5
  405cc0:	009b      	lsls	r3, r3, #2
  405cc2:	2200      	movs	r2, #0
  405cc4:	50ca      	str	r2, [r1, r3]
  405cc6:	e7f4      	b.n	405cb2 <f_close+0x2e>
  405cc8:	00405bcd 	.word	0x00405bcd
  405ccc:	2000339c 	.word	0x2000339c

00405cd0 <f_lseek>:

FRESULT f_lseek (
	FIL *fp,		/* Pointer to the file object */
	DWORD ofs		/* File pointer from top of file */
)
{
  405cd0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  405cd4:	4604      	mov	r4, r0
  405cd6:	460d      	mov	r5, r1
	FRESULT res;


	res = validate(fp->fs, fp->id);		/* Check validity of the object */
  405cd8:	6800      	ldr	r0, [r0, #0]
  405cda:	88a1      	ldrh	r1, [r4, #4]
  405cdc:	4b66      	ldr	r3, [pc, #408]	; (405e78 <f_lseek+0x1a8>)
  405cde:	4798      	blx	r3
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
  405ce0:	2800      	cmp	r0, #0
  405ce2:	d149      	bne.n	405d78 <f_lseek+0xa8>
	if (fp->flag & FA__ERROR)			/* Check abort flag */
  405ce4:	79a3      	ldrb	r3, [r4, #6]
  405ce6:	0618      	lsls	r0, r3, #24
  405ce8:	d448      	bmi.n	405d7c <f_lseek+0xac>

	/* Normal Seek */
	{
		DWORD clst, bcs, nsect, ifptr;

		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
  405cea:	68e2      	ldr	r2, [r4, #12]
  405cec:	42aa      	cmp	r2, r5
  405cee:	d203      	bcs.n	405cf8 <f_lseek+0x28>
  405cf0:	f013 0f02 	tst.w	r3, #2
  405cf4:	bf08      	it	eq
  405cf6:	4615      	moveq	r5, r2
			 && !(fp->flag & FA_WRITE)
#endif
			) ofs = fp->fsize;

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
  405cf8:	2300      	movs	r3, #0
#if !_FS_READONLY
			 && !(fp->flag & FA_WRITE)
#endif
			) ofs = fp->fsize;

		ifptr = fp->fptr;
  405cfa:	68a2      	ldr	r2, [r4, #8]
		fp->fptr = nsect = 0;
  405cfc:	60a3      	str	r3, [r4, #8]
		if (ofs) {
  405cfe:	2d00      	cmp	r5, #0
  405d00:	d03f      	beq.n	405d82 <f_lseek+0xb2>
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
  405d02:	6820      	ldr	r0, [r4, #0]
  405d04:	7886      	ldrb	r6, [r0, #2]
  405d06:	0276      	lsls	r6, r6, #9
			if (ifptr > 0 &&
  405d08:	b142      	cbz	r2, 405d1c <f_lseek+0x4c>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
  405d0a:	3a01      	subs	r2, #1
  405d0c:	1e69      	subs	r1, r5, #1
  405d0e:	fbb2 f3f6 	udiv	r3, r2, r6
  405d12:	fbb1 f1f6 	udiv	r1, r1, r6

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
		if (ofs) {
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
			if (ifptr > 0 &&
  405d16:	4299      	cmp	r1, r3
  405d18:	f080 808e 	bcs.w	405e38 <f_lseek+0x168>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
				ofs -= fp->fptr;
				clst = fp->clust;
			} else {									/* When seek to back cluster, */
				clst = fp->sclust;						/* start from the first cluster */
  405d1c:	6922      	ldr	r2, [r4, #16]
#if !_FS_READONLY
				if (clst == 0) {						/* If no cluster chain, create a new chain */
  405d1e:	2a00      	cmp	r2, #0
  405d20:	f000 8090 	beq.w	405e44 <f_lseek+0x174>
					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
					fp->sclust = clst;
				}
#endif
				fp->clust = clst;
  405d24:	6162      	str	r2, [r4, #20]
			}
			if (clst != 0) {
  405d26:	2a00      	cmp	r2, #0
  405d28:	d12e      	bne.n	405d88 <f_lseek+0xb8>
  405d2a:	68a3      	ldr	r3, [r4, #8]
			 && !(fp->flag & FA_WRITE)
#endif
			) ofs = fp->fsize;

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
  405d2c:	4615      	mov	r5, r2
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
					nsect += ofs / SS(fp->fs);
				}
			}
		}
		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
  405d2e:	f3c3 0208 	ubfx	r2, r3, #0, #9
  405d32:	2a00      	cmp	r2, #0
  405d34:	f000 8090 	beq.w	405e58 <f_lseek+0x188>
  405d38:	69a2      	ldr	r2, [r4, #24]
  405d3a:	42aa      	cmp	r2, r5
  405d3c:	f000 808c 	beq.w	405e58 <f_lseek+0x188>
#if !_FS_TINY
#if !_FS_READONLY
			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
  405d40:	79a3      	ldrb	r3, [r4, #6]
  405d42:	065b      	lsls	r3, r3, #25
  405d44:	d469      	bmi.n	405e1a <f_lseek+0x14a>
  405d46:	f104 0628 	add.w	r6, r4, #40	; 0x28
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
					ABORT(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
			}
#endif
			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
  405d4a:	6823      	ldr	r3, [r4, #0]
  405d4c:	4f4b      	ldr	r7, [pc, #300]	; (405e7c <f_lseek+0x1ac>)
  405d4e:	7858      	ldrb	r0, [r3, #1]
  405d50:	4631      	mov	r1, r6
  405d52:	462a      	mov	r2, r5
  405d54:	2301      	movs	r3, #1
  405d56:	47b8      	blx	r7
  405d58:	2800      	cmp	r0, #0
  405d5a:	d157      	bne.n	405e0c <f_lseek+0x13c>
  405d5c:	68a3      	ldr	r3, [r4, #8]
  405d5e:	68e2      	ldr	r2, [r4, #12]
				ABORT(fp->fs, FR_DISK_ERR);
#endif
			fp->dsect = nsect;
  405d60:	61a5      	str	r5, [r4, #24]
		}
#if !_FS_READONLY
		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
  405d62:	429a      	cmp	r2, r3
  405d64:	d207      	bcs.n	405d76 <f_lseek+0xa6>
			fp->fsize = fp->fptr;
			fp->flag |= FA__WRITTEN;
  405d66:	79a2      	ldrb	r2, [r4, #6]
#endif
			fp->dsect = nsect;
		}
#if !_FS_READONLY
		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
			fp->fsize = fp->fptr;
  405d68:	60e3      	str	r3, [r4, #12]
			fp->flag |= FA__WRITTEN;
  405d6a:	f042 0320 	orr.w	r3, r2, #32
  405d6e:	71a3      	strb	r3, [r4, #6]
  405d70:	2000      	movs	r0, #0
  405d72:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  405d76:	2000      	movs	r0, #0
		}
#endif
	}

	LEAVE_FF(fp->fs, res);
}
  405d78:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}


	res = validate(fp->fs, fp->id);		/* Check validity of the object */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)			/* Check abort flag */
		LEAVE_FF(fp->fs, FR_INT_ERR);
  405d7c:	2002      	movs	r0, #2
  405d7e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  405d82:	4628      	mov	r0, r5
  405d84:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				}
#endif
				fp->clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
  405d88:	42b5      	cmp	r5, r6
  405d8a:	d973      	bls.n	405e74 <f_lseek+0x1a4>
  405d8c:	6820      	ldr	r0, [r4, #0]
  405d8e:	f8df 80f8 	ldr.w	r8, [pc, #248]	; 405e88 <f_lseek+0x1b8>
#if !_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
  405d92:	4f3b      	ldr	r7, [pc, #236]	; (405e80 <f_lseek+0x1b0>)
				fp->clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
#if !_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
  405d94:	79a1      	ldrb	r1, [r4, #6]
  405d96:	078b      	lsls	r3, r1, #30
						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
					fp->clust = clst;
					fp->fptr += bcs;
					ofs -= bcs;
  405d98:	ebc6 0505 	rsb	r5, r6, r5
				fp->clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
#if !_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
  405d9c:	d40a      	bmi.n	405db4 <f_lseek+0xe4>
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  405d9e:	2a01      	cmp	r2, #1
  405da0:	d902      	bls.n	405da8 <f_lseek+0xd8>
  405da2:	6983      	ldr	r3, [r0, #24]
  405da4:	4293      	cmp	r3, r2
  405da6:	d82d      	bhi.n	405e04 <f_lseek+0x134>
						}
					} else
#endif
						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
  405da8:	f061 017f 	orn	r1, r1, #127	; 0x7f
  405dac:	71a1      	strb	r1, [r4, #6]
  405dae:	2002      	movs	r0, #2
  405db0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
#if !_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
  405db4:	4611      	mov	r1, r2
  405db6:	47b8      	blx	r7
						if (clst == 0) {				/* When disk gets full, clip file size */
  405db8:	4602      	mov	r2, r0
  405dba:	2800      	cmp	r0, #0
  405dbc:	d059      	beq.n	405e72 <f_lseek+0x1a2>
							ofs = bcs; break;
						}
					} else
#endif
						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
  405dbe:	1c51      	adds	r1, r2, #1
  405dc0:	d024      	beq.n	405e0c <f_lseek+0x13c>
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
  405dc2:	2a01      	cmp	r2, #1
  405dc4:	d951      	bls.n	405e6a <f_lseek+0x19a>
  405dc6:	6820      	ldr	r0, [r4, #0]
  405dc8:	6983      	ldr	r3, [r0, #24]
  405dca:	429a      	cmp	r2, r3
  405dcc:	d24d      	bcs.n	405e6a <f_lseek+0x19a>
					fp->clust = clst;
					fp->fptr += bcs;
  405dce:	68a3      	ldr	r3, [r4, #8]
					} else
#endif
						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
					fp->clust = clst;
  405dd0:	6162      	str	r2, [r4, #20]
					fp->fptr += bcs;
  405dd2:	4433      	add	r3, r6
				}
#endif
				fp->clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
  405dd4:	42ae      	cmp	r6, r5
#endif
						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
					fp->clust = clst;
					fp->fptr += bcs;
  405dd6:	60a3      	str	r3, [r4, #8]
				}
#endif
				fp->clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
  405dd8:	d3dc      	bcc.n	405d94 <f_lseek+0xc4>
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
					fp->clust = clst;
					fp->fptr += bcs;
					ofs -= bcs;
				}
				fp->fptr += ofs;
  405dda:	442b      	add	r3, r5
				if (ofs % SS(fp->fs)) {
  405ddc:	f3c5 0108 	ubfx	r1, r5, #0, #9
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
					fp->clust = clst;
					fp->fptr += bcs;
					ofs -= bcs;
				}
				fp->fptr += ofs;
  405de0:	60a3      	str	r3, [r4, #8]
				if (ofs % SS(fp->fs)) {
  405de2:	2900      	cmp	r1, #0
  405de4:	d043      	beq.n	405e6e <f_lseek+0x19e>
					nsect = clust2sect(fp->fs, clst);	/* Current sector */
  405de6:	6821      	ldr	r1, [r4, #0]
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  405de8:	6988      	ldr	r0, [r1, #24]
static DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
  405dea:	3a02      	subs	r2, #2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  405dec:	3802      	subs	r0, #2
  405dee:	4282      	cmp	r2, r0
  405df0:	d234      	bcs.n	405e5c <f_lseek+0x18c>
	return clst * fs->csize + fs->database;
  405df2:	7888      	ldrb	r0, [r1, #2]
  405df4:	6a89      	ldr	r1, [r1, #40]	; 0x28
  405df6:	fb00 1202 	mla	r2, r0, r2, r1
					ofs -= bcs;
				}
				fp->fptr += ofs;
				if (ofs % SS(fp->fs)) {
					nsect = clust2sect(fp->fs, clst);	/* Current sector */
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
  405dfa:	2a00      	cmp	r2, #0
  405dfc:	d02e      	beq.n	405e5c <f_lseek+0x18c>
					nsect += ofs / SS(fp->fs);
  405dfe:	eb02 2555 	add.w	r5, r2, r5, lsr #9
  405e02:	e794      	b.n	405d2e <f_lseek+0x5e>
  405e04:	4611      	mov	r1, r2
  405e06:	47c0      	blx	r8
  405e08:	4602      	mov	r2, r0
  405e0a:	e7d8      	b.n	405dbe <f_lseek+0xee>
					ABORT(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
			}
#endif
			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
  405e0c:	79a3      	ldrb	r3, [r4, #6]
  405e0e:	f063 037f 	orn	r3, r3, #127	; 0x7f
  405e12:	71a3      	strb	r3, [r4, #6]
  405e14:	2001      	movs	r0, #1
  405e16:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		}
		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
#if !_FS_TINY
#if !_FS_READONLY
			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
  405e1a:	6823      	ldr	r3, [r4, #0]
  405e1c:	4f19      	ldr	r7, [pc, #100]	; (405e84 <f_lseek+0x1b4>)
  405e1e:	7858      	ldrb	r0, [r3, #1]
  405e20:	f104 0628 	add.w	r6, r4, #40	; 0x28
  405e24:	2301      	movs	r3, #1
  405e26:	4631      	mov	r1, r6
  405e28:	47b8      	blx	r7
					ABORT(fp->fs, FR_DISK_ERR);
  405e2a:	79a3      	ldrb	r3, [r4, #6]
		}
		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
#if !_FS_TINY
#if !_FS_READONLY
			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
  405e2c:	2800      	cmp	r0, #0
  405e2e:	d1ee      	bne.n	405e0e <f_lseek+0x13e>
					ABORT(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
  405e30:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  405e34:	71a3      	strb	r3, [r4, #6]
  405e36:	e788      	b.n	405d4a <f_lseek+0x7a>
		fp->fptr = nsect = 0;
		if (ofs) {
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
			if (ifptr > 0 &&
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
  405e38:	4273      	negs	r3, r6
  405e3a:	401a      	ands	r2, r3
  405e3c:	60a2      	str	r2, [r4, #8]
				ofs -= fp->fptr;
  405e3e:	1aad      	subs	r5, r5, r2
				clst = fp->clust;
  405e40:	6962      	ldr	r2, [r4, #20]
  405e42:	e770      	b.n	405d26 <f_lseek+0x56>
			} else {									/* When seek to back cluster, */
				clst = fp->sclust;						/* start from the first cluster */
#if !_FS_READONLY
				if (clst == 0) {						/* If no cluster chain, create a new chain */
					clst = create_chain(fp->fs, 0);
  405e44:	4611      	mov	r1, r2
  405e46:	4b0e      	ldr	r3, [pc, #56]	; (405e80 <f_lseek+0x1b0>)
  405e48:	4798      	blx	r3
					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
  405e4a:	2801      	cmp	r0, #1
				clst = fp->clust;
			} else {									/* When seek to back cluster, */
				clst = fp->sclust;						/* start from the first cluster */
#if !_FS_READONLY
				if (clst == 0) {						/* If no cluster chain, create a new chain */
					clst = create_chain(fp->fs, 0);
  405e4c:	4602      	mov	r2, r0
					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
  405e4e:	d005      	beq.n	405e5c <f_lseek+0x18c>
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
  405e50:	1c41      	adds	r1, r0, #1
  405e52:	d0db      	beq.n	405e0c <f_lseek+0x13c>
					fp->sclust = clst;
  405e54:	6120      	str	r0, [r4, #16]
  405e56:	e765      	b.n	405d24 <f_lseek+0x54>
  405e58:	68e2      	ldr	r2, [r4, #12]
  405e5a:	e782      	b.n	405d62 <f_lseek+0x92>
					ofs -= bcs;
				}
				fp->fptr += ofs;
				if (ofs % SS(fp->fs)) {
					nsect = clust2sect(fp->fs, clst);	/* Current sector */
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
  405e5c:	79a3      	ldrb	r3, [r4, #6]
  405e5e:	f063 037f 	orn	r3, r3, #127	; 0x7f
  405e62:	71a3      	strb	r3, [r4, #6]
  405e64:	2002      	movs	r0, #2
  405e66:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  405e6a:	79a1      	ldrb	r1, [r4, #6]
  405e6c:	e79c      	b.n	405da8 <f_lseek+0xd8>
			 && !(fp->flag & FA_WRITE)
#endif
			) ofs = fp->fsize;

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
  405e6e:	460d      	mov	r5, r1
  405e70:	e75d      	b.n	405d2e <f_lseek+0x5e>
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
#if !_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
						if (clst == 0) {				/* When disk gets full, clip file size */
  405e72:	4635      	mov	r5, r6
  405e74:	68a3      	ldr	r3, [r4, #8]
  405e76:	e7b0      	b.n	405dda <f_lseek+0x10a>
  405e78:	0040439d 	.word	0x0040439d
  405e7c:	00403f15 	.word	0x00403f15
  405e80:	004049f5 	.word	0x004049f5
  405e84:	00403f89 	.word	0x00403f89
  405e88:	00404781 	.word	0x00404781

00405e8c <f_opendir>:

FRESULT f_opendir (
	DIR *dj,			/* Pointer to directory object to create */
	const TCHAR *path	/* Pointer to the directory path */
)
{
  405e8c:	b530      	push	{r4, r5, lr}
  405e8e:	f5ad 7d07 	sub.w	sp, sp, #540	; 0x21c
  405e92:	4604      	mov	r4, r0
  405e94:	9101      	str	r1, [sp, #4]
	FRESULT res;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj->fs, 0);
  405e96:	a801      	add	r0, sp, #4
  405e98:	4621      	mov	r1, r4
  405e9a:	2200      	movs	r2, #0
  405e9c:	4b16      	ldr	r3, [pc, #88]	; (405ef8 <f_opendir+0x6c>)
  405e9e:	4798      	blx	r3
	if (res == FR_OK) {
  405ea0:	b110      	cbz	r0, 405ea8 <f_opendir+0x1c>
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
	}

	LEAVE_FF(dj->fs, res);
}
  405ea2:	f50d 7d07 	add.w	sp, sp, #540	; 0x21c
  405ea6:	bd30      	pop	{r4, r5, pc}
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj->fs, 0);
	if (res == FR_OK) {
		INIT_BUF(*dj);
  405ea8:	ab06      	add	r3, sp, #24
  405eaa:	aa03      	add	r2, sp, #12
  405eac:	61e3      	str	r3, [r4, #28]
		res = follow_path(dj, path);			/* Follow the path to the directory */
  405eae:	9901      	ldr	r1, [sp, #4]
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj->fs, 0);
	if (res == FR_OK) {
		INIT_BUF(*dj);
  405eb0:	61a2      	str	r2, [r4, #24]
		res = follow_path(dj, path);			/* Follow the path to the directory */
  405eb2:	4620      	mov	r0, r4
  405eb4:	4b11      	ldr	r3, [pc, #68]	; (405efc <f_opendir+0x70>)
  405eb6:	4798      	blx	r3
		FREE_BUF();
		if (res == FR_OK) {						/* Follow completed */
  405eb8:	b9b0      	cbnz	r0, 405ee8 <f_opendir+0x5c>
			if (dj->dir) {						/* It is not the root dir */
  405eba:	6963      	ldr	r3, [r4, #20]
  405ebc:	b16b      	cbz	r3, 405eda <f_opendir+0x4e>
				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
  405ebe:	7ada      	ldrb	r2, [r3, #11]
  405ec0:	06d2      	lsls	r2, r2, #27
  405ec2:	d517      	bpl.n	405ef4 <f_opendir+0x68>
					dj->sclust = LD_CLUST(dj->dir);
  405ec4:	7d5d      	ldrb	r5, [r3, #21]
  405ec6:	7d1a      	ldrb	r2, [r3, #20]
  405ec8:	7ed8      	ldrb	r0, [r3, #27]
  405eca:	7e99      	ldrb	r1, [r3, #26]
  405ecc:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
  405ed0:	ea41 2300 	orr.w	r3, r1, r0, lsl #8
  405ed4:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  405ed8:	60a3      	str	r3, [r4, #8]
				} else {						/* The object is not a directory */
					res = FR_NO_PATH;
				}
			}
			if (res == FR_OK) {
				dj->id = dj->fs->id;
  405eda:	6823      	ldr	r3, [r4, #0]
				res = dir_sdi(dj, 0);			/* Rewind dir */
  405edc:	4a08      	ldr	r2, [pc, #32]	; (405f00 <f_opendir+0x74>)
				} else {						/* The object is not a directory */
					res = FR_NO_PATH;
				}
			}
			if (res == FR_OK) {
				dj->id = dj->fs->id;
  405ede:	88db      	ldrh	r3, [r3, #6]
  405ee0:	80a3      	strh	r3, [r4, #4]
				res = dir_sdi(dj, 0);			/* Rewind dir */
  405ee2:	4620      	mov	r0, r4
  405ee4:	2100      	movs	r1, #0
  405ee6:	4790      	blx	r2
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
  405ee8:	2804      	cmp	r0, #4
  405eea:	bf08      	it	eq
  405eec:	2005      	moveq	r0, #5
	}

	LEAVE_FF(dj->fs, res);
}
  405eee:	f50d 7d07 	add.w	sp, sp, #540	; 0x21c
  405ef2:	bd30      	pop	{r4, r5, pc}
		if (res == FR_OK) {						/* Follow completed */
			if (dj->dir) {						/* It is not the root dir */
				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
					dj->sclust = LD_CLUST(dj->dir);
				} else {						/* The object is not a directory */
					res = FR_NO_PATH;
  405ef4:	2005      	movs	r0, #5
  405ef6:	e7d4      	b.n	405ea2 <f_opendir+0x16>
  405ef8:	00404451 	.word	0x00404451
  405efc:	0040527d 	.word	0x0040527d
  405f00:	0040484d 	.word	0x0040484d

00405f04 <f_stat>:

FRESULT f_stat (
	const TCHAR *path,	/* Pointer to the file path */
	FILINFO *fno		/* Pointer to file information to return */
)
{
  405f04:	b530      	push	{r4, r5, lr}
  405f06:	f5ad 7d0f 	sub.w	sp, sp, #572	; 0x23c
  405f0a:	460d      	mov	r5, r1
  405f0c:	9001      	str	r0, [sp, #4]
	FRESULT res;
	DIR dj;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 0);
  405f0e:	a905      	add	r1, sp, #20
  405f10:	a801      	add	r0, sp, #4
  405f12:	2200      	movs	r2, #0
  405f14:	4b10      	ldr	r3, [pc, #64]	; (405f58 <f_stat+0x54>)
  405f16:	4798      	blx	r3
	if (res == FR_OK) {
  405f18:	4604      	mov	r4, r0
  405f1a:	b118      	cbz	r0, 405f24 <f_stat+0x20>
		}
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
}
  405f1c:	4620      	mov	r0, r4
  405f1e:	f50d 7d0f 	add.w	sp, sp, #572	; 0x23c
  405f22:	bd30      	pop	{r4, r5, pc}
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 0);
	if (res == FR_OK) {
		INIT_BUF(dj);
  405f24:	ac02      	add	r4, sp, #8
  405f26:	aa0e      	add	r2, sp, #56	; 0x38
		res = follow_path(&dj, path);	/* Follow the file path */
  405f28:	9901      	ldr	r1, [sp, #4]
  405f2a:	4b0c      	ldr	r3, [pc, #48]	; (405f5c <f_stat+0x58>)
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 0);
	if (res == FR_OK) {
		INIT_BUF(dj);
  405f2c:	940b      	str	r4, [sp, #44]	; 0x2c
		res = follow_path(&dj, path);	/* Follow the file path */
  405f2e:	a805      	add	r0, sp, #20
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 0);
	if (res == FR_OK) {
		INIT_BUF(dj);
  405f30:	920c      	str	r2, [sp, #48]	; 0x30
		res = follow_path(&dj, path);	/* Follow the file path */
  405f32:	4798      	blx	r3
		if (res == FR_OK) {				/* Follow completed */
  405f34:	4604      	mov	r4, r0
  405f36:	2800      	cmp	r0, #0
  405f38:	d1f0      	bne.n	405f1c <f_stat+0x18>
			if (dj.dir)		/* Found an object */
  405f3a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  405f3c:	b13b      	cbz	r3, 405f4e <f_stat+0x4a>
				get_fileinfo(&dj, fno);
  405f3e:	a805      	add	r0, sp, #20
  405f40:	4629      	mov	r1, r5
  405f42:	4b07      	ldr	r3, [pc, #28]	; (405f60 <f_stat+0x5c>)
  405f44:	4798      	blx	r3
		}
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
}
  405f46:	4620      	mov	r0, r4
  405f48:	f50d 7d0f 	add.w	sp, sp, #572	; 0x23c
  405f4c:	bd30      	pop	{r4, r5, pc}
		res = follow_path(&dj, path);	/* Follow the file path */
		if (res == FR_OK) {				/* Follow completed */
			if (dj.dir)		/* Found an object */
				get_fileinfo(&dj, fno);
			else			/* It is root dir */
				res = FR_INVALID_NAME;
  405f4e:	2406      	movs	r4, #6
		}
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
}
  405f50:	4620      	mov	r0, r4
  405f52:	f50d 7d0f 	add.w	sp, sp, #572	; 0x23c
  405f56:	bd30      	pop	{r4, r5, pc}
  405f58:	00404451 	.word	0x00404451
  405f5c:	0040527d 	.word	0x0040527d
  405f60:	00404135 	.word	0x00404135

00405f64 <f_getfree>:
FRESULT f_getfree (
	const TCHAR *path,	/* Pointer to the logical drive number (root dir) */
	DWORD *nclst,		/* Pointer to the variable to return number of free clusters */
	FATFS **fatfs		/* Pointer to pointer to corresponding file system object to return */
)
{
  405f64:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  405f68:	b083      	sub	sp, #12
  405f6a:	ab02      	add	r3, sp, #8
  405f6c:	4690      	mov	r8, r2
  405f6e:	f843 0d04 	str.w	r0, [r3, #-4]!
  405f72:	4689      	mov	r9, r1
	UINT i;
	BYTE fat, *p;


	/* Get drive number */
	res = chk_mounted(&path, fatfs, 0);
  405f74:	4618      	mov	r0, r3
  405f76:	4611      	mov	r1, r2
  405f78:	4b47      	ldr	r3, [pc, #284]	; (406098 <f_getfree+0x134>)
  405f7a:	2200      	movs	r2, #0
  405f7c:	4798      	blx	r3
	if (res == FR_OK) {
  405f7e:	4683      	mov	fp, r0
  405f80:	bb70      	cbnz	r0, 405fe0 <f_getfree+0x7c>
		/* If free_clust is valid, return it without full cluster scan */
		if ((*fatfs)->free_clust <= (*fatfs)->n_fatent - 2) {
  405f82:	f8d8 6000 	ldr.w	r6, [r8]
  405f86:	69b5      	ldr	r5, [r6, #24]
  405f88:	6933      	ldr	r3, [r6, #16]
  405f8a:	1eaa      	subs	r2, r5, #2
  405f8c:	4293      	cmp	r3, r2
  405f8e:	d92b      	bls.n	405fe8 <f_getfree+0x84>
			*nclst = (*fatfs)->free_clust;
		} else {
			/* Get number of free clusters */
			fat = (*fatfs)->fs_type;
  405f90:	f896 a000 	ldrb.w	sl, [r6]
			n = 0;
			if (fat == FS_FAT12) {
  405f94:	f1ba 0f01 	cmp.w	sl, #1
  405f98:	d04c      	beq.n	406034 <f_getfree+0xd0>
					if (stat == 1) { res = FR_INT_ERR; break; }
					if (stat == 0) n++;
				} while (++clst < (*fatfs)->n_fatent);
			} else {
				clst = (*fatfs)->n_fatent;
				sect = (*fatfs)->fatbase;
  405f9a:	6a32      	ldr	r2, [r6, #32]
				i = 0; p = 0;
  405f9c:	4603      	mov	r3, r0
  405f9e:	4604      	mov	r4, r0
		if ((*fatfs)->free_clust <= (*fatfs)->n_fatent - 2) {
			*nclst = (*fatfs)->free_clust;
		} else {
			/* Get number of free clusters */
			fat = (*fatfs)->fs_type;
			n = 0;
  405fa0:	4607      	mov	r7, r0
  405fa2:	4694      	mov	ip, r2
  405fa4:	4630      	mov	r0, r6
			} else {
				clst = (*fatfs)->n_fatent;
				sect = (*fatfs)->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
  405fa6:	b32c      	cbz	r4, 405ff4 <f_getfree+0x90>
						res = move_window(*fatfs, sect++);
						if (res != FR_OK) break;
						p = (*fatfs)->win;
						i = SS(*fatfs);
					}
					if (fat == FS_FAT16) {
  405fa8:	f1ba 0f02 	cmp.w	sl, #2
  405fac:	d032      	beq.n	406014 <f_getfree+0xb0>
						if (LD_WORD(p) == 0) n++;
						p += 2; i -= 2;
					} else {
						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
  405fae:	789a      	ldrb	r2, [r3, #2]
  405fb0:	78d9      	ldrb	r1, [r3, #3]
  405fb2:	781e      	ldrb	r6, [r3, #0]
  405fb4:	0412      	lsls	r2, r2, #16
  405fb6:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
  405fba:	7859      	ldrb	r1, [r3, #1]
  405fbc:	4332      	orrs	r2, r6
  405fbe:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  405fc2:	f022 4270 	bic.w	r2, r2, #4026531840	; 0xf0000000
  405fc6:	b902      	cbnz	r2, 405fca <f_getfree+0x66>
  405fc8:	3701      	adds	r7, #1
						p += 4; i -= 4;
  405fca:	3304      	adds	r3, #4
  405fcc:	3c04      	subs	r4, #4
					}
				} while (--clst);
  405fce:	3d01      	subs	r5, #1
  405fd0:	d1e9      	bne.n	405fa6 <f_getfree+0x42>
  405fd2:	4606      	mov	r6, r0
			}
			(*fatfs)->free_clust = n;
			if (fat == FS_FAT32) (*fatfs)->fsi_flag = 1;
  405fd4:	f1ba 0f03 	cmp.w	sl, #3
						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
						p += 4; i -= 4;
					}
				} while (--clst);
			}
			(*fatfs)->free_clust = n;
  405fd8:	6137      	str	r7, [r6, #16]
			if (fat == FS_FAT32) (*fatfs)->fsi_flag = 1;
  405fda:	d024      	beq.n	406026 <f_getfree+0xc2>
			*nclst = n;
  405fdc:	f8c9 7000 	str.w	r7, [r9]
		}
	}
	LEAVE_FF(*fatfs, res);
}
  405fe0:	4658      	mov	r0, fp
  405fe2:	b003      	add	sp, #12
  405fe4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  405fe8:	4658      	mov	r0, fp
	/* Get drive number */
	res = chk_mounted(&path, fatfs, 0);
	if (res == FR_OK) {
		/* If free_clust is valid, return it without full cluster scan */
		if ((*fatfs)->free_clust <= (*fatfs)->n_fatent - 2) {
			*nclst = (*fatfs)->free_clust;
  405fea:	f8c9 3000 	str.w	r3, [r9]
			if (fat == FS_FAT32) (*fatfs)->fsi_flag = 1;
			*nclst = n;
		}
	}
	LEAVE_FF(*fatfs, res);
}
  405fee:	b003      	add	sp, #12
  405ff0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				clst = (*fatfs)->n_fatent;
				sect = (*fatfs)->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(*fatfs, sect++);
  405ff4:	4661      	mov	r1, ip
  405ff6:	4b29      	ldr	r3, [pc, #164]	; (40609c <f_getfree+0x138>)
  405ff8:	f10c 0401 	add.w	r4, ip, #1
  405ffc:	4798      	blx	r3
						if (res != FR_OK) break;
  405ffe:	bb18      	cbnz	r0, 406048 <f_getfree+0xe4>
						p = (*fatfs)->win;
  406000:	f8d8 0000 	ldr.w	r0, [r8]
						i = SS(*fatfs);
					}
					if (fat == FS_FAT16) {
  406004:	f1ba 0f02 	cmp.w	sl, #2
				clst = (*fatfs)->n_fatent;
				sect = (*fatfs)->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(*fatfs, sect++);
  406008:	46a4      	mov	ip, r4
						if (res != FR_OK) break;
						p = (*fatfs)->win;
  40600a:	f100 0330 	add.w	r3, r0, #48	; 0x30
						i = SS(*fatfs);
  40600e:	f44f 7400 	mov.w	r4, #512	; 0x200
					}
					if (fat == FS_FAT16) {
  406012:	d1cc      	bne.n	405fae <f_getfree+0x4a>
						if (LD_WORD(p) == 0) n++;
  406014:	7859      	ldrb	r1, [r3, #1]
  406016:	781a      	ldrb	r2, [r3, #0]
  406018:	ea52 2201 	orrs.w	r2, r2, r1, lsl #8
  40601c:	bf08      	it	eq
  40601e:	3701      	addeq	r7, #1
						p += 2; i -= 2;
  406020:	3302      	adds	r3, #2
  406022:	3c02      	subs	r4, #2
  406024:	e7d3      	b.n	405fce <f_getfree+0x6a>
						p += 4; i -= 4;
					}
				} while (--clst);
			}
			(*fatfs)->free_clust = n;
			if (fat == FS_FAT32) (*fatfs)->fsi_flag = 1;
  406026:	f8d8 3000 	ldr.w	r3, [r8]
  40602a:	2201      	movs	r2, #1
  40602c:	715a      	strb	r2, [r3, #5]
			*nclst = n;
  40602e:	f8c9 7000 	str.w	r7, [r9]
  406032:	e7d5      	b.n	405fe0 <f_getfree+0x7c>
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  406034:	2d02      	cmp	r5, #2
  406036:	bf98      	it	ls
  406038:	4607      	movls	r7, r0
  40603a:	d809      	bhi.n	406050 <f_getfree+0xec>
			if (fat == FS_FAT12) {
				clst = 2;
				do {
					stat = get_fat(*fatfs, clst);
					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
					if (stat == 1) { res = FR_INT_ERR; break; }
  40603c:	f04f 0b02 	mov.w	fp, #2
						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
						p += 4; i -= 4;
					}
				} while (--clst);
			}
			(*fatfs)->free_clust = n;
  406040:	6137      	str	r7, [r6, #16]
			if (fat == FS_FAT32) (*fatfs)->fsi_flag = 1;
			*nclst = n;
  406042:	f8c9 7000 	str.w	r7, [r9]
  406046:	e7cb      	b.n	405fe0 <f_getfree+0x7c>
				clst = (*fatfs)->n_fatent;
				sect = (*fatfs)->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(*fatfs, sect++);
  406048:	4683      	mov	fp, r0
  40604a:	f8d8 6000 	ldr.w	r6, [r8]
  40604e:	e7c1      	b.n	405fd4 <f_getfree+0x70>
  406050:	4d13      	ldr	r5, [pc, #76]	; (4060a0 <f_getfree+0x13c>)
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  406052:	4607      	mov	r7, r0
  406054:	2402      	movs	r4, #2
  406056:	4630      	mov	r0, r6
  406058:	4621      	mov	r1, r4
  40605a:	47a8      	blx	r5
			n = 0;
			if (fat == FS_FAT12) {
				clst = 2;
				do {
					stat = get_fat(*fatfs, clst);
					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
  40605c:	1c43      	adds	r3, r0, #1
					if (stat == 1) { res = FR_INT_ERR; break; }
					if (stat == 0) n++;
				} while (++clst < (*fatfs)->n_fatent);
  40605e:	f104 0401 	add.w	r4, r4, #1
			n = 0;
			if (fat == FS_FAT12) {
				clst = 2;
				do {
					stat = get_fat(*fatfs, clst);
					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
  406062:	d00c      	beq.n	40607e <f_getfree+0x11a>
					if (stat == 1) { res = FR_INT_ERR; break; }
  406064:	2801      	cmp	r0, #1
  406066:	d011      	beq.n	40608c <f_getfree+0x128>
					if (stat == 0) n++;
  406068:	b900      	cbnz	r0, 40606c <f_getfree+0x108>
  40606a:	3701      	adds	r7, #1
				} while (++clst < (*fatfs)->n_fatent);
  40606c:	f8d8 0000 	ldr.w	r0, [r8]
  406070:	6983      	ldr	r3, [r0, #24]
  406072:	429c      	cmp	r4, r3
  406074:	d208      	bcs.n	406088 <f_getfree+0x124>
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  406076:	2c01      	cmp	r4, #1
  406078:	d8ee      	bhi.n	406058 <f_getfree+0xf4>
  40607a:	4606      	mov	r6, r0
  40607c:	e7de      	b.n	40603c <f_getfree+0xd8>
  40607e:	f8d8 6000 	ldr.w	r6, [r8]
			n = 0;
			if (fat == FS_FAT12) {
				clst = 2;
				do {
					stat = get_fat(*fatfs, clst);
					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
  406082:	f04f 0b01 	mov.w	fp, #1
  406086:	e7db      	b.n	406040 <f_getfree+0xdc>
  406088:	4606      	mov	r6, r0
  40608a:	e7d9      	b.n	406040 <f_getfree+0xdc>
  40608c:	f8d8 6000 	ldr.w	r6, [r8]
					if (stat == 1) { res = FR_INT_ERR; break; }
  406090:	f04f 0b02 	mov.w	fp, #2
  406094:	e7d4      	b.n	406040 <f_getfree+0xdc>
  406096:	bf00      	nop
  406098:	00404451 	.word	0x00404451
  40609c:	00404241 	.word	0x00404241
  4060a0:	00404781 	.word	0x00404781

004060a4 <f_unlink>:
/*-----------------------------------------------------------------------*/

FRESULT f_unlink (
	const TCHAR *path		/* Pointer to the file or directory path */
)
{
  4060a4:	b530      	push	{r4, r5, lr}
  4060a6:	f5ad 7d19 	sub.w	sp, sp, #612	; 0x264
	BYTE *dir;
	DWORD dclst;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
  4060aa:	a906      	add	r1, sp, #24
/*-----------------------------------------------------------------------*/

FRESULT f_unlink (
	const TCHAR *path		/* Pointer to the file or directory path */
)
{
  4060ac:	9001      	str	r0, [sp, #4]
	BYTE *dir;
	DWORD dclst;
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
  4060ae:	2201      	movs	r2, #1
  4060b0:	a801      	add	r0, sp, #4
  4060b2:	4b2f      	ldr	r3, [pc, #188]	; (406170 <f_unlink+0xcc>)
  4060b4:	4798      	blx	r3
	if (res == FR_OK) {
  4060b6:	b110      	cbz	r0, 4060be <f_unlink+0x1a>
			}
		}
		FREE_BUF();
	}
	LEAVE_FF(dj.fs, res);
}
  4060b8:	f50d 7d19 	add.w	sp, sp, #612	; 0x264
  4060bc:	bd30      	pop	{r4, r5, pc}
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
	if (res == FR_OK) {
		INIT_BUF(dj);
  4060be:	ac03      	add	r4, sp, #12
  4060c0:	aa18      	add	r2, sp, #96	; 0x60
		res = follow_path(&dj, path);		/* Follow the file path */
  4060c2:	9901      	ldr	r1, [sp, #4]
  4060c4:	4b2b      	ldr	r3, [pc, #172]	; (406174 <f_unlink+0xd0>)
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
	if (res == FR_OK) {
		INIT_BUF(dj);
  4060c6:	940c      	str	r4, [sp, #48]	; 0x30
		res = follow_path(&dj, path);		/* Follow the file path */
  4060c8:	a806      	add	r0, sp, #24
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
	if (res == FR_OK) {
		INIT_BUF(dj);
  4060ca:	920d      	str	r2, [sp, #52]	; 0x34
		res = follow_path(&dj, path);		/* Follow the file path */
  4060cc:	4798      	blx	r3
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
#if _FS_SHARE
		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open file */
  4060ce:	2800      	cmp	r0, #0
  4060d0:	d1f2      	bne.n	4060b8 <f_unlink+0x14>
  4060d2:	a806      	add	r0, sp, #24
  4060d4:	2102      	movs	r1, #2
  4060d6:	4b28      	ldr	r3, [pc, #160]	; (406178 <f_unlink+0xd4>)
  4060d8:	4798      	blx	r3
#endif
		if (res == FR_OK) {					/* The object is accessible */
  4060da:	2800      	cmp	r0, #0
  4060dc:	d1ec      	bne.n	4060b8 <f_unlink+0x14>
			dir = dj.dir;
  4060de:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
			if (!dir) {
  4060e0:	2b00      	cmp	r3, #0
  4060e2:	d042      	beq.n	40616a <f_unlink+0xc6>
				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
			} else {
				if (dir[DIR_Attr] & AM_RDO)
  4060e4:	7ada      	ldrb	r2, [r3, #11]
  4060e6:	07d1      	lsls	r1, r2, #31
  4060e8:	d503      	bpl.n	4060f2 <f_unlink+0x4e>
					res = FR_DENIED;		/* Cannot remove R/O object */
  4060ea:	2007      	movs	r0, #7
			}
		}
		FREE_BUF();
	}
	LEAVE_FF(dj.fs, res);
}
  4060ec:	f50d 7d19 	add.w	sp, sp, #612	; 0x264
  4060f0:	bd30      	pop	{r4, r5, pc}
				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
			} else {
				if (dir[DIR_Attr] & AM_RDO)
					res = FR_DENIED;		/* Cannot remove R/O object */
			}
			dclst = LD_CLUST(dir);
  4060f2:	7d5d      	ldrb	r5, [r3, #21]
  4060f4:	7d18      	ldrb	r0, [r3, #20]
  4060f6:	7ed9      	ldrb	r1, [r3, #27]
  4060f8:	7e9b      	ldrb	r3, [r3, #26]
  4060fa:	ea40 2505 	orr.w	r5, r0, r5, lsl #8
  4060fe:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
  406102:	ea43 4505 	orr.w	r5, r3, r5, lsl #16
			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
  406106:	06d3      	lsls	r3, r2, #27
  406108:	d518      	bpl.n	40613c <f_unlink+0x98>
				if (dclst < 2) {
  40610a:	2d01      	cmp	r5, #1
  40610c:	d922      	bls.n	406154 <f_unlink+0xb0>
  40610e:	a80f      	add	r0, sp, #60	; 0x3c
  406110:	4603      	mov	r3, r0
  406112:	ac06      	add	r4, sp, #24
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
  406114:	f814 2b01 	ldrb.w	r2, [r4], #1
  406118:	f803 2b01 	strb.w	r2, [r3], #1
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
  40611c:	4284      	cmp	r4, r0
  40611e:	d1f9      	bne.n	406114 <f_unlink+0x70>
				if (dclst < 2) {
					res = FR_INT_ERR;
				} else {
					mem_cpy(&sdj, &dj, sizeof(DIR));	/* Check if the sub-dir is empty or not */
					sdj.sclust = dclst;
					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
  406120:	4620      	mov	r0, r4
  406122:	2102      	movs	r1, #2
  406124:	4b15      	ldr	r3, [pc, #84]	; (40617c <f_unlink+0xd8>)
			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
				if (dclst < 2) {
					res = FR_INT_ERR;
				} else {
					mem_cpy(&sdj, &dj, sizeof(DIR));	/* Check if the sub-dir is empty or not */
					sdj.sclust = dclst;
  406126:	60a5      	str	r5, [r4, #8]
					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
  406128:	4798      	blx	r3
					if (res == FR_OK) {
  40612a:	2800      	cmp	r0, #0
  40612c:	d1c4      	bne.n	4060b8 <f_unlink+0x14>
						res = dir_read(&sdj);
  40612e:	4620      	mov	r0, r4
  406130:	4b13      	ldr	r3, [pc, #76]	; (406180 <f_unlink+0xdc>)
  406132:	4798      	blx	r3
						if (res == FR_OK			/* Not empty dir */
  406134:	2800      	cmp	r0, #0
  406136:	d0d8      	beq.n	4060ea <f_unlink+0x46>
#if _FS_RPATH
						|| dclst == sdj.fs->cdir	/* Current dir */
#endif
						) res = FR_DENIED;
						if (res == FR_NO_FILE) res = FR_OK;	/* Empty */
  406138:	2804      	cmp	r0, #4
  40613a:	d1bd      	bne.n	4060b8 <f_unlink+0x14>
					}
				}
			}
			if (res == FR_OK) {
				res = dir_remove(&dj);		/* Remove the directory entry */
  40613c:	a806      	add	r0, sp, #24
  40613e:	4b11      	ldr	r3, [pc, #68]	; (406184 <f_unlink+0xe0>)
  406140:	4798      	blx	r3
				if (res == FR_OK) {
  406142:	2800      	cmp	r0, #0
  406144:	d1b8      	bne.n	4060b8 <f_unlink+0x14>
					if (dclst)				/* Remove the cluster chain if exist */
  406146:	b165      	cbz	r5, 406162 <f_unlink+0xbe>
	DWORD nxt;
#if _USE_ERASE
	DWORD scl = clst, ecl = clst, resion[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
  406148:	2d01      	cmp	r5, #1
			}
			if (res == FR_OK) {
				res = dir_remove(&dj);		/* Remove the directory entry */
				if (res == FR_OK) {
					if (dclst)				/* Remove the cluster chain if exist */
						res = remove_chain(dj.fs, dclst);
  40614a:	9806      	ldr	r0, [sp, #24]
	DWORD nxt;
#if _USE_ERASE
	DWORD scl = clst, ecl = clst, resion[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
  40614c:	d002      	beq.n	406154 <f_unlink+0xb0>
  40614e:	6983      	ldr	r3, [r0, #24]
  406150:	429d      	cmp	r5, r3
  406152:	d301      	bcc.n	406158 <f_unlink+0xb4>
					res = FR_DENIED;		/* Cannot remove R/O object */
			}
			dclst = LD_CLUST(dir);
			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
				if (dclst < 2) {
					res = FR_INT_ERR;
  406154:	2002      	movs	r0, #2
  406156:	e7af      	b.n	4060b8 <f_unlink+0x14>
  406158:	4629      	mov	r1, r5
  40615a:	4b0b      	ldr	r3, [pc, #44]	; (406188 <f_unlink+0xe4>)
  40615c:	4798      	blx	r3
			if (res == FR_OK) {
				res = dir_remove(&dj);		/* Remove the directory entry */
				if (res == FR_OK) {
					if (dclst)				/* Remove the cluster chain if exist */
						res = remove_chain(dj.fs, dclst);
					if (res == FR_OK) res = sync(dj.fs);
  40615e:	2800      	cmp	r0, #0
  406160:	d1aa      	bne.n	4060b8 <f_unlink+0x14>
  406162:	9806      	ldr	r0, [sp, #24]
  406164:	4b09      	ldr	r3, [pc, #36]	; (40618c <f_unlink+0xe8>)
  406166:	4798      	blx	r3
  406168:	e7a6      	b.n	4060b8 <f_unlink+0x14>
		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open file */
#endif
		if (res == FR_OK) {					/* The object is accessible */
			dir = dj.dir;
			if (!dir) {
				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
  40616a:	2006      	movs	r0, #6
  40616c:	e7a4      	b.n	4060b8 <f_unlink+0x14>
  40616e:	bf00      	nop
  406170:	00404451 	.word	0x00404451
  406174:	0040527d 	.word	0x0040527d
  406178:	004040c5 	.word	0x004040c5
  40617c:	0040484d 	.word	0x0040484d
  406180:	00404c0d 	.word	0x00404c0d
  406184:	00404d35 	.word	0x00404d35
  406188:	00405211 	.word	0x00405211
  40618c:	004042c5 	.word	0x004042c5

00406190 <f_mkdir>:
/*-----------------------------------------------------------------------*/

FRESULT f_mkdir (
	const TCHAR *path		/* Pointer to the directory path */
)
{
  406190:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  406194:	f5ad 7d17 	sub.w	sp, sp, #604	; 0x25c
	FRESULT res;
	DIR dj;
	BYTE *dir, n;
	DWORD dsc, dcl, pcl, tim = get_fattime();
  406198:	4b84      	ldr	r3, [pc, #528]	; (4063ac <f_mkdir+0x21c>)
/*-----------------------------------------------------------------------*/

FRESULT f_mkdir (
	const TCHAR *path		/* Pointer to the directory path */
)
{
  40619a:	9009      	str	r0, [sp, #36]	; 0x24
	FRESULT res;
	DIR dj;
	BYTE *dir, n;
	DWORD dsc, dcl, pcl, tim = get_fattime();
  40619c:	4798      	blx	r3
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
  40619e:	2201      	movs	r2, #1
)
{
	FRESULT res;
	DIR dj;
	BYTE *dir, n;
	DWORD dsc, dcl, pcl, tim = get_fattime();
  4061a0:	4680      	mov	r8, r0
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
  4061a2:	a90d      	add	r1, sp, #52	; 0x34
  4061a4:	a809      	add	r0, sp, #36	; 0x24
  4061a6:	4b82      	ldr	r3, [pc, #520]	; (4063b0 <f_mkdir+0x220>)
  4061a8:	4798      	blx	r3
  4061aa:	4602      	mov	r2, r0
  4061ac:	4604      	mov	r4, r0
	if (res == FR_OK) {
  4061ae:	b120      	cbz	r0, 4061ba <f_mkdir+0x2a>
		}
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
}
  4061b0:	4610      	mov	r0, r2
  4061b2:	f50d 7d17 	add.w	sp, sp, #604	; 0x25c
  4061b6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
	if (res == FR_OK) {
		INIT_BUF(dj);
  4061ba:	aa16      	add	r2, sp, #88	; 0x58
		res = follow_path(&dj, path);			/* Follow the file path */
  4061bc:	9909      	ldr	r1, [sp, #36]	; 0x24
  4061be:	4b7d      	ldr	r3, [pc, #500]	; (4063b4 <f_mkdir+0x224>)
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
	if (res == FR_OK) {
		INIT_BUF(dj);
  4061c0:	9214      	str	r2, [sp, #80]	; 0x50
  4061c2:	ad0a      	add	r5, sp, #40	; 0x28
		res = follow_path(&dj, path);			/* Follow the file path */
  4061c4:	a80d      	add	r0, sp, #52	; 0x34
	DEF_NAMEBUF;


	res = chk_mounted(&path, &dj.fs, 1);
	if (res == FR_OK) {
		INIT_BUF(dj);
  4061c6:	9513      	str	r5, [sp, #76]	; 0x4c
		res = follow_path(&dj, path);			/* Follow the file path */
  4061c8:	4798      	blx	r3
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
  4061ca:	4602      	mov	r2, r0
  4061cc:	b1a0      	cbz	r0, 4061f8 <f_mkdir+0x68>
		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
		if (res == FR_NO_FILE) {				/* Can create a new directory */
  4061ce:	2804      	cmp	r0, #4
  4061d0:	d1ee      	bne.n	4061b0 <f_mkdir+0x20>
			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
  4061d2:	980d      	ldr	r0, [sp, #52]	; 0x34
  4061d4:	4b78      	ldr	r3, [pc, #480]	; (4063b8 <f_mkdir+0x228>)
  4061d6:	4621      	mov	r1, r4
  4061d8:	4798      	blx	r3
			res = FR_OK;
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
  4061da:	4607      	mov	r7, r0
  4061dc:	b990      	cbnz	r0, 406204 <f_mkdir+0x74>
  4061de:	2207      	movs	r2, #7
	DWORD nxt;
#if _USE_ERASE
	DWORD scl = clst, ecl = clst, resion[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
  4061e0:	2f01      	cmp	r7, #1
					mem_set(dir, 0, SS(dj.fs));
				}
			}
			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
			if (res != FR_OK) {
				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
  4061e2:	980d      	ldr	r0, [sp, #52]	; 0x34
	DWORD nxt;
#if _USE_ERASE
	DWORD scl = clst, ecl = clst, resion[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
  4061e4:	d9e4      	bls.n	4061b0 <f_mkdir+0x20>
  4061e6:	6983      	ldr	r3, [r0, #24]
  4061e8:	429f      	cmp	r7, r3
  4061ea:	d2e1      	bcs.n	4061b0 <f_mkdir+0x20>
  4061ec:	9200      	str	r2, [sp, #0]
  4061ee:	4639      	mov	r1, r7
  4061f0:	4b72      	ldr	r3, [pc, #456]	; (4063bc <f_mkdir+0x22c>)
  4061f2:	4798      	blx	r3
  4061f4:	9a00      	ldr	r2, [sp, #0]
  4061f6:	e7db      	b.n	4061b0 <f_mkdir+0x20>

	res = chk_mounted(&path, &dj.fs, 1);
	if (res == FR_OK) {
		INIT_BUF(dj);
		res = follow_path(&dj, path);			/* Follow the file path */
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
  4061f8:	2208      	movs	r2, #8
		}
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
}
  4061fa:	4610      	mov	r0, r2
  4061fc:	f50d 7d17 	add.w	sp, sp, #604	; 0x25c
  406200:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			res = FR_INVALID_NAME;
		if (res == FR_NO_FILE) {				/* Can create a new directory */
			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
			res = FR_OK;
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
			if (dcl == 1) res = FR_INT_ERR;
  406204:	2801      	cmp	r0, #1
  406206:	d101      	bne.n	40620c <f_mkdir+0x7c>
  406208:	2202      	movs	r2, #2
  40620a:	e7e9      	b.n	4061e0 <f_mkdir+0x50>
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
  40620c:	1c43      	adds	r3, r0, #1
  40620e:	bf08      	it	eq
  406210:	2201      	moveq	r2, #1
  406212:	d0e5      	beq.n	4061e0 <f_mkdir+0x50>
			if (res == FR_OK)					/* Flush FAT */
				res = move_window(dj.fs, 0);
  406214:	4621      	mov	r1, r4
  406216:	980d      	ldr	r0, [sp, #52]	; 0x34
  406218:	4e69      	ldr	r6, [pc, #420]	; (4063c0 <f_mkdir+0x230>)
  40621a:	47b0      	blx	r6
			if (res == FR_OK) {					/* Initialize the new directory table */
  40621c:	4602      	mov	r2, r0
  40621e:	2800      	cmp	r0, #0
  406220:	d1de      	bne.n	4061e0 <f_mkdir+0x50>
				dsc = clust2sect(dj.fs, dcl);
  406222:	990d      	ldr	r1, [sp, #52]	; 0x34
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  406224:	6988      	ldr	r0, [r1, #24]
static DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
  406226:	1ebb      	subs	r3, r7, #2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  406228:	3802      	subs	r0, #2
  40622a:	4283      	cmp	r3, r0
  40622c:	d203      	bcs.n	406236 <f_mkdir+0xa6>
	return clst * fs->csize + fs->database;
  40622e:	7888      	ldrb	r0, [r1, #2]
  406230:	6a8a      	ldr	r2, [r1, #40]	; 0x28
  406232:	fb00 2203 	mla	r2, r0, r3, r2
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
			if (res == FR_OK)					/* Flush FAT */
				res = move_window(dj.fs, 0);
			if (res == FR_OK) {					/* Initialize the new directory table */
				dsc = clust2sect(dj.fs, dcl);
				dir = dj.fs->win;
  406236:	f101 0530 	add.w	r5, r1, #48	; 0x30
}

/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;
  40623a:	462b      	mov	r3, r5
  40623c:	f501 740c 	add.w	r4, r1, #560	; 0x230

	while (cnt--)
		*d++ = (BYTE)val;
  406240:	2000      	movs	r0, #0
  406242:	f803 0b01 	strb.w	r0, [r3], #1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
  406246:	42a3      	cmp	r3, r4
  406248:	d1fb      	bne.n	406242 <f_mkdir+0xb2>
  40624a:	f101 0e3b 	add.w	lr, r1, #59	; 0x3b
  40624e:	462b      	mov	r3, r5
		*d++ = (BYTE)val;
  406250:	2020      	movs	r0, #32
  406252:	f803 0b01 	strb.w	r0, [r3], #1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
  406256:	4573      	cmp	r3, lr
  406258:	d1fb      	bne.n	406252 <f_mkdir+0xc2>
				mem_set(dir, 0, SS(dj.fs));
				mem_set(dir+DIR_Name, ' ', 8+3);	/* Create "." entry */
				dir[DIR_Name] = '.';
				dir[DIR_Attr] = AM_DIR;
				ST_DWORD(dir+DIR_WrtTime, tim);
				ST_CLUST(dir, dcl);
  40625a:	ea4f 4b17 	mov.w	fp, r7, lsr #16
  40625e:	fa5f f38b 	uxtb.w	r3, fp
				dir = dj.fs->win;
				mem_set(dir, 0, SS(dj.fs));
				mem_set(dir+DIR_Name, ' ', 8+3);	/* Create "." entry */
				dir[DIR_Name] = '.';
				dir[DIR_Attr] = AM_DIR;
				ST_DWORD(dir+DIR_WrtTime, tim);
  406262:	fa5f f088 	uxtb.w	r0, r8
				ST_CLUST(dir, dcl);
  406266:	9307      	str	r3, [sp, #28]
				dir = dj.fs->win;
				mem_set(dir, 0, SS(dj.fs));
				mem_set(dir+DIR_Name, ' ', 8+3);	/* Create "." entry */
				dir[DIR_Name] = '.';
				dir[DIR_Attr] = AM_DIR;
				ST_DWORD(dir+DIR_WrtTime, tim);
  406268:	9001      	str	r0, [sp, #4]
				dsc = clust2sect(dj.fs, dcl);
				dir = dj.fs->win;
				mem_set(dir, 0, SS(dj.fs));
				mem_set(dir+DIR_Name, ' ', 8+3);	/* Create "." entry */
				dir[DIR_Name] = '.';
				dir[DIR_Attr] = AM_DIR;
  40626a:	2310      	movs	r3, #16
				ST_DWORD(dir+DIR_WrtTime, tim);
  40626c:	f3c8 2007 	ubfx	r0, r8, #8, #8
  406270:	9002      	str	r0, [sp, #8]
				dsc = clust2sect(dj.fs, dcl);
				dir = dj.fs->win;
				mem_set(dir, 0, SS(dj.fs));
				mem_set(dir+DIR_Name, ' ', 8+3);	/* Create "." entry */
				dir[DIR_Name] = '.';
				dir[DIR_Attr] = AM_DIR;
  406272:	f881 303b 	strb.w	r3, [r1, #59]	; 0x3b
				ST_DWORD(dir+DIR_WrtTime, tim);
  406276:	f3c8 4007 	ubfx	r0, r8, #16, #8
  40627a:	9b01      	ldr	r3, [sp, #4]
  40627c:	9003      	str	r0, [sp, #12]
  40627e:	f881 3046 	strb.w	r3, [r1, #70]	; 0x46
				ST_CLUST(dir, dcl);
  406282:	b2f8      	uxtb	r0, r7
				dir = dj.fs->win;
				mem_set(dir, 0, SS(dj.fs));
				mem_set(dir+DIR_Name, ' ', 8+3);	/* Create "." entry */
				dir[DIR_Name] = '.';
				dir[DIR_Attr] = AM_DIR;
				ST_DWORD(dir+DIR_WrtTime, tim);
  406284:	9b02      	ldr	r3, [sp, #8]
				ST_CLUST(dir, dcl);
  406286:	9005      	str	r0, [sp, #20]
				dir = dj.fs->win;
				mem_set(dir, 0, SS(dj.fs));
				mem_set(dir+DIR_Name, ' ', 8+3);	/* Create "." entry */
				dir[DIR_Name] = '.';
				dir[DIR_Attr] = AM_DIR;
				ST_DWORD(dir+DIR_WrtTime, tim);
  406288:	f881 3047 	strb.w	r3, [r1, #71]	; 0x47
				ST_CLUST(dir, dcl);
  40628c:	f3c7 2007 	ubfx	r0, r7, #8, #8
				dir = dj.fs->win;
				mem_set(dir, 0, SS(dj.fs));
				mem_set(dir+DIR_Name, ' ', 8+3);	/* Create "." entry */
				dir[DIR_Name] = '.';
				dir[DIR_Attr] = AM_DIR;
				ST_DWORD(dir+DIR_WrtTime, tim);
  406290:	9b03      	ldr	r3, [sp, #12]
				ST_CLUST(dir, dcl);
  406292:	9006      	str	r0, [sp, #24]
				dir = dj.fs->win;
				mem_set(dir, 0, SS(dj.fs));
				mem_set(dir+DIR_Name, ' ', 8+3);	/* Create "." entry */
				dir[DIR_Name] = '.';
				dir[DIR_Attr] = AM_DIR;
				ST_DWORD(dir+DIR_WrtTime, tim);
  406294:	f881 3048 	strb.w	r3, [r1, #72]	; 0x48
				ST_CLUST(dir, dcl);
  406298:	9b05      	ldr	r3, [sp, #20]
  40629a:	9807      	ldr	r0, [sp, #28]
  40629c:	f881 304a 	strb.w	r3, [r1, #74]	; 0x4a
  4062a0:	ea4f 2b1b 	mov.w	fp, fp, lsr #8
				dir = dj.fs->win;
				mem_set(dir, 0, SS(dj.fs));
				mem_set(dir+DIR_Name, ' ', 8+3);	/* Create "." entry */
				dir[DIR_Name] = '.';
				dir[DIR_Attr] = AM_DIR;
				ST_DWORD(dir+DIR_WrtTime, tim);
  4062a4:	ea4f 6818 	mov.w	r8, r8, lsr #24
				ST_CLUST(dir, dcl);
  4062a8:	9b06      	ldr	r3, [sp, #24]
  4062aa:	f881 0044 	strb.w	r0, [r1, #68]	; 0x44
			if (res == FR_OK) {					/* Initialize the new directory table */
				dsc = clust2sect(dj.fs, dcl);
				dir = dj.fs->win;
				mem_set(dir, 0, SS(dj.fs));
				mem_set(dir+DIR_Name, ' ', 8+3);	/* Create "." entry */
				dir[DIR_Name] = '.';
  4062ae:	f04f 0e2e 	mov.w	lr, #46	; 0x2e
				dir[DIR_Attr] = AM_DIR;
				ST_DWORD(dir+DIR_WrtTime, tim);
				ST_CLUST(dir, dcl);
  4062b2:	f881 304b 	strb.w	r3, [r1, #75]	; 0x4b
  4062b6:	f8cd b020 	str.w	fp, [sp, #32]
				dir = dj.fs->win;
				mem_set(dir, 0, SS(dj.fs));
				mem_set(dir+DIR_Name, ' ', 8+3);	/* Create "." entry */
				dir[DIR_Name] = '.';
				dir[DIR_Attr] = AM_DIR;
				ST_DWORD(dir+DIR_WrtTime, tim);
  4062ba:	f8cd 8010 	str.w	r8, [sp, #16]
				ST_CLUST(dir, dcl);
  4062be:	f881 b045 	strb.w	fp, [r1, #69]	; 0x45
			if (res == FR_OK) {					/* Initialize the new directory table */
				dsc = clust2sect(dj.fs, dcl);
				dir = dj.fs->win;
				mem_set(dir, 0, SS(dj.fs));
				mem_set(dir+DIR_Name, ' ', 8+3);	/* Create "." entry */
				dir[DIR_Name] = '.';
  4062c2:	f881 e030 	strb.w	lr, [r1, #48]	; 0x30
				dir[DIR_Attr] = AM_DIR;
				ST_DWORD(dir+DIR_WrtTime, tim);
  4062c6:	f881 8049 	strb.w	r8, [r1, #73]	; 0x49
				ST_CLUST(dir, dcl);
				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
  4062ca:	f101 0350 	add.w	r3, r1, #80	; 0x50
  4062ce:	4628      	mov	r0, r5
  4062d0:	f101 0c70 	add.w	ip, r1, #112	; 0x70
  4062d4:	e001      	b.n	4062da <f_mkdir+0x14a>
  4062d6:	f810 ef01 	ldrb.w	lr, [r0, #1]!
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
  4062da:	f803 eb01 	strb.w	lr, [r3], #1
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
  4062de:	4563      	cmp	r3, ip
  4062e0:	d1f9      	bne.n	4062d6 <f_mkdir+0x146>
				dir[DIR_Name] = '.';
				dir[DIR_Attr] = AM_DIR;
				ST_DWORD(dir+DIR_WrtTime, tim);
				ST_CLUST(dir, dcl);
				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
				dir[33] = '.'; pcl = dj.sclust;
  4062e2:	232e      	movs	r3, #46	; 0x2e
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
  4062e4:	980d      	ldr	r0, [sp, #52]	; 0x34
				dir[DIR_Name] = '.';
				dir[DIR_Attr] = AM_DIR;
				ST_DWORD(dir+DIR_WrtTime, tim);
				ST_CLUST(dir, dcl);
				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
				dir[33] = '.'; pcl = dj.sclust;
  4062e6:	f881 3051 	strb.w	r3, [r1, #81]	; 0x51
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
  4062ea:	7803      	ldrb	r3, [r0, #0]
				dir[DIR_Name] = '.';
				dir[DIR_Attr] = AM_DIR;
				ST_DWORD(dir+DIR_WrtTime, tim);
				ST_CLUST(dir, dcl);
				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
				dir[33] = '.'; pcl = dj.sclust;
  4062ec:	f8dd e03c 	ldr.w	lr, [sp, #60]	; 0x3c
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
  4062f0:	2b03      	cmp	r3, #3
  4062f2:	d053      	beq.n	40639c <f_mkdir+0x20c>
  4062f4:	ea4f 431e 	mov.w	r3, lr, lsr #16
  4062f8:	fa5f fc83 	uxtb.w	ip, r3
  4062fc:	fa5f f88e 	uxtb.w	r8, lr
  406300:	0a1b      	lsrs	r3, r3, #8
  406302:	f3ce 2e07 	ubfx	lr, lr, #8, #8
					pcl = 0;
				ST_CLUST(dir+SZ_DIR, pcl);
  406306:	f881 806a 	strb.w	r8, [r1, #106]	; 0x6a
  40630a:	f881 e06b 	strb.w	lr, [r1, #107]	; 0x6b
  40630e:	f881 c064 	strb.w	ip, [r1, #100]	; 0x64
  406312:	f881 3065 	strb.w	r3, [r1, #101]	; 0x65
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
  406316:	7883      	ldrb	r3, [r0, #2]
  406318:	b1f3      	cbz	r3, 406358 <f_mkdir+0x1c8>
  40631a:	3b01      	subs	r3, #1
  40631c:	fa5f f983 	uxtb.w	r9, r3
  406320:	f109 0901 	add.w	r9, r9, #1
  406324:	4491      	add	r9, r2
					dj.fs->winsect = dsc++;
					dj.fs->wflag = 1;
  406326:	f04f 0801 	mov.w	r8, #1
					res = move_window(dj.fs, 0);
  40632a:	f04f 0a00 	mov.w	sl, #0
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				ST_CLUST(dir+SZ_DIR, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
					dj.fs->winsect = dsc++;
					dj.fs->wflag = 1;
  40632e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
				dir[33] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				ST_CLUST(dir+SZ_DIR, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
					dj.fs->winsect = dsc++;
  406330:	62c2      	str	r2, [r0, #44]	; 0x2c
					dj.fs->wflag = 1;
					res = move_window(dj.fs, 0);
  406332:	2100      	movs	r1, #0
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				ST_CLUST(dir+SZ_DIR, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
					dj.fs->winsect = dsc++;
					dj.fs->wflag = 1;
  406334:	f883 8004 	strb.w	r8, [r3, #4]
				dir[33] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				ST_CLUST(dir+SZ_DIR, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
					dj.fs->winsect = dsc++;
  406338:	f102 0b01 	add.w	fp, r2, #1
					dj.fs->wflag = 1;
					res = move_window(dj.fs, 0);
  40633c:	47b0      	blx	r6
					if (res != FR_OK) break;
  40633e:	b948      	cbnz	r0, 406354 <f_mkdir+0x1c4>
  406340:	462b      	mov	r3, r5
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
  406342:	f803 ab01 	strb.w	sl, [r3], #1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
  406346:	42a3      	cmp	r3, r4
  406348:	d1fb      	bne.n	406342 <f_mkdir+0x1b2>
				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
				dir[33] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
					pcl = 0;
				ST_CLUST(dir+SZ_DIR, pcl);
				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
  40634a:	45cb      	cmp	fp, r9
  40634c:	d004      	beq.n	406358 <f_mkdir+0x1c8>
					dj.fs->winsect = dsc++;
  40634e:	465a      	mov	r2, fp
  406350:	980d      	ldr	r0, [sp, #52]	; 0x34
  406352:	e7ec      	b.n	40632e <f_mkdir+0x19e>
  406354:	4602      	mov	r2, r0
  406356:	e743      	b.n	4061e0 <f_mkdir+0x50>
					res = move_window(dj.fs, 0);
					if (res != FR_OK) break;
					mem_set(dir, 0, SS(dj.fs));
				}
			}
			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
  406358:	a80d      	add	r0, sp, #52	; 0x34
  40635a:	4b1a      	ldr	r3, [pc, #104]	; (4063c4 <f_mkdir+0x234>)
  40635c:	4798      	blx	r3
			if (res != FR_OK) {
  40635e:	4602      	mov	r2, r0
  406360:	2800      	cmp	r0, #0
  406362:	f47f af3d 	bne.w	4061e0 <f_mkdir+0x50>
				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
			} else {
				dir = dj.dir;
  406366:	9b12      	ldr	r3, [sp, #72]	; 0x48
				dir[DIR_Attr] = AM_DIR;				/* Attribute */
				ST_DWORD(dir+DIR_WrtTime, tim);		/* Created time */
  406368:	9c01      	ldr	r4, [sp, #4]
  40636a:	759c      	strb	r4, [r3, #22]
  40636c:	9c02      	ldr	r4, [sp, #8]
  40636e:	75dc      	strb	r4, [r3, #23]
  406370:	9c03      	ldr	r4, [sp, #12]
  406372:	761c      	strb	r4, [r3, #24]
  406374:	9c04      	ldr	r4, [sp, #16]
  406376:	765c      	strb	r4, [r3, #25]
				ST_CLUST(dir, dcl);					/* Table start cluster */
  406378:	9c05      	ldr	r4, [sp, #20]
  40637a:	769c      	strb	r4, [r3, #26]
  40637c:	9c06      	ldr	r4, [sp, #24]
				dj.fs->wflag = 1;
  40637e:	9a0d      	ldr	r2, [sp, #52]	; 0x34
				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
			} else {
				dir = dj.dir;
				dir[DIR_Attr] = AM_DIR;				/* Attribute */
				ST_DWORD(dir+DIR_WrtTime, tim);		/* Created time */
				ST_CLUST(dir, dcl);					/* Table start cluster */
  406380:	76dc      	strb	r4, [r3, #27]
  406382:	9c07      	ldr	r4, [sp, #28]
  406384:	751c      	strb	r4, [r3, #20]
			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
			if (res != FR_OK) {
				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
			} else {
				dir = dj.dir;
				dir[DIR_Attr] = AM_DIR;				/* Attribute */
  406386:	2010      	movs	r0, #16
				ST_DWORD(dir+DIR_WrtTime, tim);		/* Created time */
				ST_CLUST(dir, dcl);					/* Table start cluster */
				dj.fs->wflag = 1;
  406388:	2101      	movs	r1, #1
				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
			} else {
				dir = dj.dir;
				dir[DIR_Attr] = AM_DIR;				/* Attribute */
				ST_DWORD(dir+DIR_WrtTime, tim);		/* Created time */
				ST_CLUST(dir, dcl);					/* Table start cluster */
  40638a:	9c08      	ldr	r4, [sp, #32]
			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
			if (res != FR_OK) {
				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
			} else {
				dir = dj.dir;
				dir[DIR_Attr] = AM_DIR;				/* Attribute */
  40638c:	72d8      	strb	r0, [r3, #11]
				ST_DWORD(dir+DIR_WrtTime, tim);		/* Created time */
				ST_CLUST(dir, dcl);					/* Table start cluster */
  40638e:	755c      	strb	r4, [r3, #21]
				dj.fs->wflag = 1;
				res = sync(dj.fs);
  406390:	4610      	mov	r0, r2
			} else {
				dir = dj.dir;
				dir[DIR_Attr] = AM_DIR;				/* Attribute */
				ST_DWORD(dir+DIR_WrtTime, tim);		/* Created time */
				ST_CLUST(dir, dcl);					/* Table start cluster */
				dj.fs->wflag = 1;
  406392:	7111      	strb	r1, [r2, #4]
				res = sync(dj.fs);
  406394:	4b0c      	ldr	r3, [pc, #48]	; (4063c8 <f_mkdir+0x238>)
  406396:	4798      	blx	r3
  406398:	4602      	mov	r2, r0
  40639a:	e709      	b.n	4061b0 <f_mkdir+0x20>
				dir[DIR_Attr] = AM_DIR;
				ST_DWORD(dir+DIR_WrtTime, tim);
				ST_CLUST(dir, dcl);
				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
				dir[33] = '.'; pcl = dj.sclust;
				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
  40639c:	6a43      	ldr	r3, [r0, #36]	; 0x24
  40639e:	4573      	cmp	r3, lr
  4063a0:	d1a8      	bne.n	4062f4 <f_mkdir+0x164>
  4063a2:	2300      	movs	r3, #0
  4063a4:	469c      	mov	ip, r3
  4063a6:	469e      	mov	lr, r3
  4063a8:	4698      	mov	r8, r3
  4063aa:	e7ac      	b.n	406306 <f_mkdir+0x176>
  4063ac:	0040406d 	.word	0x0040406d
  4063b0:	00404451 	.word	0x00404451
  4063b4:	0040527d 	.word	0x0040527d
  4063b8:	004049f5 	.word	0x004049f5
  4063bc:	00405211 	.word	0x00405211
  4063c0:	00404241 	.word	0x00404241
  4063c4:	00404f05 	.word	0x00404f05
  4063c8:	004042c5 	.word	0x004042c5

004063cc <f_rename>:

FRESULT f_rename (
	const TCHAR *path_old,	/* Pointer to the old name */
	const TCHAR *path_new	/* Pointer to the new name */
)
{
  4063cc:	b5f0      	push	{r4, r5, r6, r7, lr}
  4063ce:	f5ad 7d1f 	sub.w	sp, sp, #636	; 0x27c
  4063d2:	460c      	mov	r4, r1
  4063d4:	9001      	str	r0, [sp, #4]
	BYTE buf[21], *dir;
	DWORD dw;
	DEF_NAMEBUF;


	res = chk_mounted(&path_old, &djo.fs, 1);
  4063d6:	a90c      	add	r1, sp, #48	; 0x30
  4063d8:	a801      	add	r0, sp, #4
  4063da:	2201      	movs	r2, #1
  4063dc:	4b4b      	ldr	r3, [pc, #300]	; (40650c <f_rename+0x140>)
  4063de:	4798      	blx	r3
	if (res == FR_OK) {
  4063e0:	b110      	cbz	r0, 4063e8 <f_rename+0x1c>
			}
		}
		FREE_BUF();
	}
	LEAVE_FF(djo.fs, res);
}
  4063e2:	f50d 7d1f 	add.w	sp, sp, #636	; 0x27c
  4063e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
	DEF_NAMEBUF;


	res = chk_mounted(&path_old, &djo.fs, 1);
	if (res == FR_OK) {
		djn.fs = djo.fs;
  4063e8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  4063ea:	9315      	str	r3, [sp, #84]	; 0x54
		INIT_BUF(djo);
  4063ec:	ae1e      	add	r6, sp, #120	; 0x78
  4063ee:	ab03      	add	r3, sp, #12
		res = follow_path(&djo, path_old);		/* Check old object */
  4063f0:	9901      	ldr	r1, [sp, #4]
  4063f2:	4d47      	ldr	r5, [pc, #284]	; (406510 <f_rename+0x144>)


	res = chk_mounted(&path_old, &djo.fs, 1);
	if (res == FR_OK) {
		djn.fs = djo.fs;
		INIT_BUF(djo);
  4063f4:	9312      	str	r3, [sp, #72]	; 0x48
		res = follow_path(&djo, path_old);		/* Check old object */
  4063f6:	a80c      	add	r0, sp, #48	; 0x30


	res = chk_mounted(&path_old, &djo.fs, 1);
	if (res == FR_OK) {
		djn.fs = djo.fs;
		INIT_BUF(djo);
  4063f8:	9613      	str	r6, [sp, #76]	; 0x4c
		res = follow_path(&djo, path_old);		/* Check old object */
  4063fa:	47a8      	blx	r5
		if (_FS_RPATH && res == FR_OK && (djo.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;
#if _FS_SHARE
		if (res == FR_OK) res = chk_lock(&djo, 2);
  4063fc:	2800      	cmp	r0, #0
  4063fe:	d1f0      	bne.n	4063e2 <f_rename+0x16>
  406400:	a80c      	add	r0, sp, #48	; 0x30
  406402:	2102      	movs	r1, #2
  406404:	4b43      	ldr	r3, [pc, #268]	; (406514 <f_rename+0x148>)
  406406:	4798      	blx	r3
#endif
		if (res == FR_OK) {						/* Old object is found */
  406408:	2800      	cmp	r0, #0
  40640a:	d1ea      	bne.n	4063e2 <f_rename+0x16>
			if (!djo.dir) {						/* Is root dir? */
  40640c:	9a11      	ldr	r2, [sp, #68]	; 0x44
  40640e:	2a00      	cmp	r2, #0
  406410:	d060      	beq.n	4064d4 <f_rename+0x108>
				res = FR_NO_FILE;
			} else {
				mem_cpy(buf, djo.dir+DIR_Attr, 21);		/* Save the object information except for name */
  406412:	320b      	adds	r2, #11
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
	BYTE *d = (BYTE*)dst;
  406414:	ab06      	add	r3, sp, #24
  406416:	f10d 072d 	add.w	r7, sp, #45	; 0x2d
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
  40641a:	f812 0b01 	ldrb.w	r0, [r2], #1
  40641e:	f803 0b01 	strb.w	r0, [r3], #1
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
  406422:	42bb      	cmp	r3, r7
  406424:	d1f9      	bne.n	40641a <f_rename+0x4e>
  406426:	aa0c      	add	r2, sp, #48	; 0x30
  406428:	ab15      	add	r3, sp, #84	; 0x54
		*d++ = *s++;
  40642a:	f812 0b01 	ldrb.w	r0, [r2], #1
  40642e:	f803 0b01 	strb.w	r0, [r3], #1
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
  406432:	42b3      	cmp	r3, r6
  406434:	d1f9      	bne.n	40642a <f_rename+0x5e>
			if (!djo.dir) {						/* Is root dir? */
				res = FR_NO_FILE;
			} else {
				mem_cpy(buf, djo.dir+DIR_Attr, 21);		/* Save the object information except for name */
				mem_cpy(&djn, &djo, sizeof(DIR));		/* Check new object */
				res = follow_path(&djn, path_new);
  406436:	4621      	mov	r1, r4
  406438:	a815      	add	r0, sp, #84	; 0x54
  40643a:	47a8      	blx	r5
				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
  40643c:	2800      	cmp	r0, #0
  40643e:	d047      	beq.n	4064d0 <f_rename+0x104>
				if (res == FR_NO_FILE) { 				/* Is it a valid path and no name collision? */
  406440:	2804      	cmp	r0, #4
  406442:	d1ce      	bne.n	4063e2 <f_rename+0x16>
/* Start critical section that any interruption or error can cause cross-link */
					res = dir_register(&djn);			/* Register the new entry */
  406444:	a815      	add	r0, sp, #84	; 0x54
  406446:	4b34      	ldr	r3, [pc, #208]	; (406518 <f_rename+0x14c>)
  406448:	4798      	blx	r3
					if (res == FR_OK) {
  40644a:	2800      	cmp	r0, #0
  40644c:	d1c9      	bne.n	4063e2 <f_rename+0x16>
						dir = djn.dir;					/* Copy object information except for name */
  40644e:	981a      	ldr	r0, [sp, #104]	; 0x68

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
	BYTE *d = (BYTE*)dst;
	const BYTE *s = (const BYTE*)src;
  406450:	f10d 031a 	add.w	r3, sp, #26
				if (res == FR_NO_FILE) { 				/* Is it a valid path and no name collision? */
/* Start critical section that any interruption or error can cause cross-link */
					res = dir_register(&djn);			/* Register the new entry */
					if (res == FR_OK) {
						dir = djn.dir;					/* Copy object information except for name */
						mem_cpy(dir+13, buf+2, 19);
  406454:	f100 020d 	add.w	r2, r0, #13
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
  406458:	f813 1b01 	ldrb.w	r1, [r3], #1
  40645c:	f802 1b01 	strb.w	r1, [r2], #1
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
  406460:	42bb      	cmp	r3, r7
  406462:	d1f9      	bne.n	406458 <f_rename+0x8c>
/* Start critical section that any interruption or error can cause cross-link */
					res = dir_register(&djn);			/* Register the new entry */
					if (res == FR_OK) {
						dir = djn.dir;					/* Copy object information except for name */
						mem_cpy(dir+13, buf+2, 19);
						dir[DIR_Attr] = buf[0] | AM_ARC;
  406464:	f89d 1018 	ldrb.w	r1, [sp, #24]
						djo.fs->wflag = 1;
  406468:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  40646a:	2201      	movs	r2, #1
/* Start critical section that any interruption or error can cause cross-link */
					res = dir_register(&djn);			/* Register the new entry */
					if (res == FR_OK) {
						dir = djn.dir;					/* Copy object information except for name */
						mem_cpy(dir+13, buf+2, 19);
						dir[DIR_Attr] = buf[0] | AM_ARC;
  40646c:	f041 0120 	orr.w	r1, r1, #32
  406470:	72c1      	strb	r1, [r0, #11]
						djo.fs->wflag = 1;
  406472:	711a      	strb	r2, [r3, #4]
						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the directory if needed */
  406474:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  406476:	9b17      	ldr	r3, [sp, #92]	; 0x5c
  406478:	429a      	cmp	r2, r3
  40647a:	d020      	beq.n	4064be <f_rename+0xf2>
  40647c:	7ac3      	ldrb	r3, [r0, #11]
  40647e:	06db      	lsls	r3, r3, #27
  406480:	d51d      	bpl.n	4064be <f_rename+0xf2>
							dw = clust2sect(djn.fs, LD_CLUST(dir));
  406482:	7ec2      	ldrb	r2, [r0, #27]
  406484:	7d44      	ldrb	r4, [r0, #21]
  406486:	7d01      	ldrb	r1, [r0, #20]
  406488:	7e83      	ldrb	r3, [r0, #26]
  40648a:	9815      	ldr	r0, [sp, #84]	; 0x54
  40648c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  406490:	ea41 2104 	orr.w	r1, r1, r4, lsl #8
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  406494:	6982      	ldr	r2, [r0, #24]
						dir = djn.dir;					/* Copy object information except for name */
						mem_cpy(dir+13, buf+2, 19);
						dir[DIR_Attr] = buf[0] | AM_ARC;
						djo.fs->wflag = 1;
						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the directory if needed */
							dw = clust2sect(djn.fs, LD_CLUST(dir));
  406496:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
static DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
  40649a:	3b02      	subs	r3, #2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  40649c:	3a02      	subs	r2, #2
  40649e:	4293      	cmp	r3, r2
  4064a0:	d21a      	bcs.n	4064d8 <f_rename+0x10c>
	return clst * fs->csize + fs->database;
  4064a2:	7881      	ldrb	r1, [r0, #2]
  4064a4:	6a82      	ldr	r2, [r0, #40]	; 0x28
  4064a6:	fb01 2103 	mla	r1, r1, r3, r2
						mem_cpy(dir+13, buf+2, 19);
						dir[DIR_Attr] = buf[0] | AM_ARC;
						djo.fs->wflag = 1;
						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the directory if needed */
							dw = clust2sect(djn.fs, LD_CLUST(dir));
							if (!dw) {
  4064aa:	b1a9      	cbz	r1, 4064d8 <f_rename+0x10c>
								res = FR_INT_ERR;
							} else {
								res = move_window(djn.fs, dw);
  4064ac:	4b1b      	ldr	r3, [pc, #108]	; (40651c <f_rename+0x150>)
  4064ae:	4798      	blx	r3
								dir = djn.fs->win+SZ_DIR;	/* .. entry */
  4064b0:	9b15      	ldr	r3, [sp, #84]	; 0x54
								if (res == FR_OK && dir[1] == '.') {
  4064b2:	2800      	cmp	r0, #0
  4064b4:	d195      	bne.n	4063e2 <f_rename+0x16>
  4064b6:	f893 2051 	ldrb.w	r2, [r3, #81]	; 0x51
  4064ba:	2a2e      	cmp	r2, #46	; 0x2e
  4064bc:	d00e      	beq.n	4064dc <f_rename+0x110>
									djn.fs->wflag = 1;
								}
							}
						}
						if (res == FR_OK) {
							res = dir_remove(&djo);		/* Remove old entry */
  4064be:	a80c      	add	r0, sp, #48	; 0x30
  4064c0:	4b17      	ldr	r3, [pc, #92]	; (406520 <f_rename+0x154>)
  4064c2:	4798      	blx	r3
							if (res == FR_OK)
  4064c4:	2800      	cmp	r0, #0
  4064c6:	d18c      	bne.n	4063e2 <f_rename+0x16>
								res = sync(djo.fs);
  4064c8:	980c      	ldr	r0, [sp, #48]	; 0x30
  4064ca:	4b16      	ldr	r3, [pc, #88]	; (406524 <f_rename+0x158>)
  4064cc:	4798      	blx	r3
  4064ce:	e788      	b.n	4063e2 <f_rename+0x16>
				res = FR_NO_FILE;
			} else {
				mem_cpy(buf, djo.dir+DIR_Attr, 21);		/* Save the object information except for name */
				mem_cpy(&djn, &djo, sizeof(DIR));		/* Check new object */
				res = follow_path(&djn, path_new);
				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
  4064d0:	2008      	movs	r0, #8
  4064d2:	e786      	b.n	4063e2 <f_rename+0x16>
#if _FS_SHARE
		if (res == FR_OK) res = chk_lock(&djo, 2);
#endif
		if (res == FR_OK) {						/* Old object is found */
			if (!djo.dir) {						/* Is root dir? */
				res = FR_NO_FILE;
  4064d4:	2004      	movs	r0, #4
  4064d6:	e784      	b.n	4063e2 <f_rename+0x16>
						dir[DIR_Attr] = buf[0] | AM_ARC;
						djo.fs->wflag = 1;
						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the directory if needed */
							dw = clust2sect(djn.fs, LD_CLUST(dir));
							if (!dw) {
								res = FR_INT_ERR;
  4064d8:	2002      	movs	r0, #2
  4064da:	e782      	b.n	4063e2 <f_rename+0x16>
							} else {
								res = move_window(djn.fs, dw);
								dir = djn.fs->win+SZ_DIR;	/* .. entry */
								if (res == FR_OK && dir[1] == '.') {
									dw = (djn.fs->fs_type == FS_FAT32 && djn.sclust == djn.fs->dirbase) ? 0 : djn.sclust;
  4064dc:	781a      	ldrb	r2, [r3, #0]
  4064de:	2a03      	cmp	r2, #3
  4064e0:	d00f      	beq.n	406502 <f_rename+0x136>
  4064e2:	9817      	ldr	r0, [sp, #92]	; 0x5c
									ST_CLUST(dir, dw);
  4064e4:	0c02      	lsrs	r2, r0, #16
  4064e6:	0a15      	lsrs	r5, r2, #8
  4064e8:	f3c0 2407 	ubfx	r4, r0, #8, #8
									djn.fs->wflag = 1;
  4064ec:	2101      	movs	r1, #1
							} else {
								res = move_window(djn.fs, dw);
								dir = djn.fs->win+SZ_DIR;	/* .. entry */
								if (res == FR_OK && dir[1] == '.') {
									dw = (djn.fs->fs_type == FS_FAT32 && djn.sclust == djn.fs->dirbase) ? 0 : djn.sclust;
									ST_CLUST(dir, dw);
  4064ee:	f883 006a 	strb.w	r0, [r3, #106]	; 0x6a
  4064f2:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
  4064f6:	f883 5065 	strb.w	r5, [r3, #101]	; 0x65
  4064fa:	f883 406b 	strb.w	r4, [r3, #107]	; 0x6b
									djn.fs->wflag = 1;
  4064fe:	7119      	strb	r1, [r3, #4]
  406500:	e7dd      	b.n	4064be <f_rename+0xf2>
								res = FR_INT_ERR;
							} else {
								res = move_window(djn.fs, dw);
								dir = djn.fs->win+SZ_DIR;	/* .. entry */
								if (res == FR_OK && dir[1] == '.') {
									dw = (djn.fs->fs_type == FS_FAT32 && djn.sclust == djn.fs->dirbase) ? 0 : djn.sclust;
  406502:	9917      	ldr	r1, [sp, #92]	; 0x5c
  406504:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  406506:	4291      	cmp	r1, r2
  406508:	d1eb      	bne.n	4064e2 <f_rename+0x116>
  40650a:	e7eb      	b.n	4064e4 <f_rename+0x118>
  40650c:	00404451 	.word	0x00404451
  406510:	0040527d 	.word	0x0040527d
  406514:	004040c5 	.word	0x004040c5
  406518:	00404f05 	.word	0x00404f05
  40651c:	00404241 	.word	0x00404241
  406520:	00404d35 	.word	0x00404d35
  406524:	004042c5 	.word	0x004042c5

00406528 <ff_convert>:
)
{
	WCHAR c;


	if (src < 0x80) {	/* ASCII */
  406528:	287f      	cmp	r0, #127	; 0x7f

WCHAR ff_convert (	/* Converted character, Returns zero on error */
	WCHAR	src,	/* Character code to be converted */
	UINT	dir		/* 0: Unicode to OEMCP, 1: OEMCP to Unicode */
)
{
  40652a:	b410      	push	{r4}
	WCHAR c;


	if (src < 0x80) {	/* ASCII */
  40652c:	d90e      	bls.n	40654c <ff_convert+0x24>
		c = src;

	} else {
		if (dir) {		/* OEMCP to Unicode */
  40652e:	b981      	cbnz	r1, 406552 <ff_convert+0x2a>
  406530:	4b0e      	ldr	r3, [pc, #56]	; (40656c <ff_convert+0x44>)
  406532:	e001      	b.n	406538 <ff_convert+0x10>
			c = (src >= 0x100) ? 0 : Tbl[src - 0x80];

		} else {		/* Unicode to OEMCP */
			for (c = 0; c < 0x80; c++) {
  406534:	2980      	cmp	r1, #128	; 0x80
  406536:	d015      	beq.n	406564 <ff_convert+0x3c>
				if (src == Tbl[c]) break;
  406538:	f833 2f02 	ldrh.w	r2, [r3, #2]!
  40653c:	4282      	cmp	r2, r0
  40653e:	b28c      	uxth	r4, r1
  406540:	f101 0101 	add.w	r1, r1, #1
  406544:	d1f6      	bne.n	406534 <ff_convert+0xc>
  406546:	f104 0080 	add.w	r0, r4, #128	; 0x80
  40654a:	b280      	uxth	r0, r0
			c = (c + 0x80) & 0xFF;
		}
	}

	return c;
}
  40654c:	f85d 4b04 	ldr.w	r4, [sp], #4
  406550:	4770      	bx	lr
	if (src < 0x80) {	/* ASCII */
		c = src;

	} else {
		if (dir) {		/* OEMCP to Unicode */
			c = (src >= 0x100) ? 0 : Tbl[src - 0x80];
  406552:	28ff      	cmp	r0, #255	; 0xff
  406554:	d806      	bhi.n	406564 <ff_convert+0x3c>
  406556:	3880      	subs	r0, #128	; 0x80
  406558:	4b05      	ldr	r3, [pc, #20]	; (406570 <ff_convert+0x48>)
			c = (c + 0x80) & 0xFF;
		}
	}

	return c;
}
  40655a:	f85d 4b04 	ldr.w	r4, [sp], #4
	if (src < 0x80) {	/* ASCII */
		c = src;

	} else {
		if (dir) {		/* OEMCP to Unicode */
			c = (src >= 0x100) ? 0 : Tbl[src - 0x80];
  40655e:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
			c = (c + 0x80) & 0xFF;
		}
	}

	return c;
}
  406562:	4770      	bx	lr
	if (src < 0x80) {	/* ASCII */
		c = src;

	} else {
		if (dir) {		/* OEMCP to Unicode */
			c = (src >= 0x100) ? 0 : Tbl[src - 0x80];
  406564:	2000      	movs	r0, #0
			c = (c + 0x80) & 0xFF;
		}
	}

	return c;
}
  406566:	f85d 4b04 	ldr.w	r4, [sp], #4
  40656a:	4770      	bx	lr
  40656c:	004162b6 	.word	0x004162b6
  406570:	004162b8 	.word	0x004162b8

00406574 <ff_wtoupper>:
	static const WCHAR tbl_lower[] = { 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0xA1, 0x00A2, 0x00A3, 0x00A5, 0x00AC, 0x00AF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0x0FF, 0x101, 0x103, 0x105, 0x107, 0x109, 0x10B, 0x10D, 0x10F, 0x111, 0x113, 0x115, 0x117, 0x119, 0x11B, 0x11D, 0x11F, 0x121, 0x123, 0x125, 0x127, 0x129, 0x12B, 0x12D, 0x12F, 0x131, 0x133, 0x135, 0x137, 0x13A, 0x13C, 0x13E, 0x140, 0x142, 0x144, 0x146, 0x148, 0x14B, 0x14D, 0x14F, 0x151, 0x153, 0x155, 0x157, 0x159, 0x15B, 0x15D, 0x15F, 0x161, 0x163, 0x165, 0x167, 0x169, 0x16B, 0x16D, 0x16F, 0x171, 0x173, 0x175, 0x177, 0x17A, 0x17C, 0x17E, 0x192, 0x3B1, 0x3B2, 0x3B3, 0x3B4, 0x3B5, 0x3B6, 0x3B7, 0x3B8, 0x3B9, 0x3BA, 0x3BB, 0x3BC, 0x3BD, 0x3BE, 0x3BF, 0x3C0, 0x3C1, 0x3C3, 0x3C4, 0x3C5, 0x3C6, 0x3C7, 0x3C8, 0x3C9, 0x3CA, 0x430, 0x431, 0x432, 0x433, 0x434, 0x435, 0x436, 0x437, 0x438, 0x439, 0x43A, 0x43B, 0x43C, 0x43D, 0x43E, 0x43F, 0x440, 0x441, 0x442, 0x443, 0x444, 0x445, 0x446, 0x447, 0x448, 0x449, 0x44A, 0x44B, 0x44C, 0x44D, 0x44E, 0x44F, 0x451, 0x452, 0x453, 0x454, 0x455, 0x456, 0x457, 0x458, 0x459, 0x45A, 0x45B, 0x45C, 0x45E, 0x45F, 0x2170, 0x2171, 0x2172, 0x2173, 0x2174, 0x2175, 0x2176, 0x2177, 0x2178, 0x2179, 0x217A, 0x217B, 0x217C, 0x217D, 0x217E, 0x217F, 0xFF41, 0xFF42, 0xFF43, 0xFF44, 0xFF45, 0xFF46, 0xFF47, 0xFF48, 0xFF49, 0xFF4A, 0xFF4B, 0xFF4C, 0xFF4D, 0xFF4E, 0xFF4F, 0xFF50, 0xFF51, 0xFF52, 0xFF53, 0xFF54, 0xFF55, 0xFF56, 0xFF57, 0xFF58, 0xFF59, 0xFF5A, 0 };
	static const WCHAR tbl_upper[] = { 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x21, 0xFFE0, 0xFFE1, 0xFFE5, 0xFFE2, 0xFFE3, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0x178, 0x100, 0x102, 0x104, 0x106, 0x108, 0x10A, 0x10C, 0x10E, 0x110, 0x112, 0x114, 0x116, 0x118, 0x11A, 0x11C, 0x11E, 0x120, 0x122, 0x124, 0x126, 0x128, 0x12A, 0x12C, 0x12E, 0x130, 0x132, 0x134, 0x136, 0x139, 0x13B, 0x13D, 0x13F, 0x141, 0x143, 0x145, 0x147, 0x14A, 0x14C, 0x14E, 0x150, 0x152, 0x154, 0x156, 0x158, 0x15A, 0x15C, 0x15E, 0x160, 0x162, 0x164, 0x166, 0x168, 0x16A, 0x16C, 0x16E, 0x170, 0x172, 0x174, 0x176, 0x179, 0x17B, 0x17D, 0x191, 0x391, 0x392, 0x393, 0x394, 0x395, 0x396, 0x397, 0x398, 0x399, 0x39A, 0x39B, 0x39C, 0x39D, 0x39E, 0x39F, 0x3A0, 0x3A1, 0x3A3, 0x3A4, 0x3A5, 0x3A6, 0x3A7, 0x3A8, 0x3A9, 0x3AA, 0x410, 0x411, 0x412, 0x413, 0x414, 0x415, 0x416, 0x417, 0x418, 0x419, 0x41A, 0x41B, 0x41C, 0x41D, 0x41E, 0x41F, 0x420, 0x421, 0x422, 0x423, 0x424, 0x425, 0x426, 0x427, 0x428, 0x429, 0x42A, 0x42B, 0x42C, 0x42D, 0x42E, 0x42F, 0x401, 0x402, 0x403, 0x404, 0x405, 0x406, 0x407, 0x408, 0x409, 0x40A, 0x40B, 0x40C, 0x40E, 0x40F, 0x2160, 0x2161, 0x2162, 0x2163, 0x2164, 0x2165, 0x2166, 0x2167, 0x2168, 0x2169, 0x216A, 0x216B, 0x216C, 0x216D, 0x216E, 0x216F, 0xFF21, 0xFF22, 0xFF23, 0xFF24, 0xFF25, 0xFF26, 0xFF27, 0xFF28, 0xFF29, 0xFF2A, 0xFF2B, 0xFF2C, 0xFF2D, 0xFF2E, 0xFF2F, 0xFF30, 0xFF31, 0xFF32, 0xFF33, 0xFF34, 0xFF35, 0xFF36, 0xFF37, 0xFF38, 0xFF39, 0xFF3A, 0 };
	int i;


	for (i = 0; tbl_lower[i] && chr != tbl_lower[i]; i++) ;
  406574:	2861      	cmp	r0, #97	; 0x61
  406576:	d00a      	beq.n	40658e <ff_wtoupper+0x1a>
  406578:	4907      	ldr	r1, [pc, #28]	; (406598 <ff_wtoupper+0x24>)
  40657a:	2200      	movs	r2, #0
  40657c:	e001      	b.n	406582 <ff_wtoupper+0xe>
  40657e:	4283      	cmp	r3, r0
  406580:	d006      	beq.n	406590 <ff_wtoupper+0x1c>
  406582:	f831 3f02 	ldrh.w	r3, [r1, #2]!
  406586:	3201      	adds	r2, #1
  406588:	2b00      	cmp	r3, #0
  40658a:	d1f8      	bne.n	40657e <ff_wtoupper+0xa>

	return tbl_lower[i] ? tbl_upper[i] : chr;
}
  40658c:	4770      	bx	lr
	static const WCHAR tbl_lower[] = { 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0xA1, 0x00A2, 0x00A3, 0x00A5, 0x00AC, 0x00AF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0x0FF, 0x101, 0x103, 0x105, 0x107, 0x109, 0x10B, 0x10D, 0x10F, 0x111, 0x113, 0x115, 0x117, 0x119, 0x11B, 0x11D, 0x11F, 0x121, 0x123, 0x125, 0x127, 0x129, 0x12B, 0x12D, 0x12F, 0x131, 0x133, 0x135, 0x137, 0x13A, 0x13C, 0x13E, 0x140, 0x142, 0x144, 0x146, 0x148, 0x14B, 0x14D, 0x14F, 0x151, 0x153, 0x155, 0x157, 0x159, 0x15B, 0x15D, 0x15F, 0x161, 0x163, 0x165, 0x167, 0x169, 0x16B, 0x16D, 0x16F, 0x171, 0x173, 0x175, 0x177, 0x17A, 0x17C, 0x17E, 0x192, 0x3B1, 0x3B2, 0x3B3, 0x3B4, 0x3B5, 0x3B6, 0x3B7, 0x3B8, 0x3B9, 0x3BA, 0x3BB, 0x3BC, 0x3BD, 0x3BE, 0x3BF, 0x3C0, 0x3C1, 0x3C3, 0x3C4, 0x3C5, 0x3C6, 0x3C7, 0x3C8, 0x3C9, 0x3CA, 0x430, 0x431, 0x432, 0x433, 0x434, 0x435, 0x436, 0x437, 0x438, 0x439, 0x43A, 0x43B, 0x43C, 0x43D, 0x43E, 0x43F, 0x440, 0x441, 0x442, 0x443, 0x444, 0x445, 0x446, 0x447, 0x448, 0x449, 0x44A, 0x44B, 0x44C, 0x44D, 0x44E, 0x44F, 0x451, 0x452, 0x453, 0x454, 0x455, 0x456, 0x457, 0x458, 0x459, 0x45A, 0x45B, 0x45C, 0x45E, 0x45F, 0x2170, 0x2171, 0x2172, 0x2173, 0x2174, 0x2175, 0x2176, 0x2177, 0x2178, 0x2179, 0x217A, 0x217B, 0x217C, 0x217D, 0x217E, 0x217F, 0xFF41, 0xFF42, 0xFF43, 0xFF44, 0xFF45, 0xFF46, 0xFF47, 0xFF48, 0xFF49, 0xFF4A, 0xFF4B, 0xFF4C, 0xFF4D, 0xFF4E, 0xFF4F, 0xFF50, 0xFF51, 0xFF52, 0xFF53, 0xFF54, 0xFF55, 0xFF56, 0xFF57, 0xFF58, 0xFF59, 0xFF5A, 0 };
	static const WCHAR tbl_upper[] = { 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x21, 0xFFE0, 0xFFE1, 0xFFE5, 0xFFE2, 0xFFE3, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0x178, 0x100, 0x102, 0x104, 0x106, 0x108, 0x10A, 0x10C, 0x10E, 0x110, 0x112, 0x114, 0x116, 0x118, 0x11A, 0x11C, 0x11E, 0x120, 0x122, 0x124, 0x126, 0x128, 0x12A, 0x12C, 0x12E, 0x130, 0x132, 0x134, 0x136, 0x139, 0x13B, 0x13D, 0x13F, 0x141, 0x143, 0x145, 0x147, 0x14A, 0x14C, 0x14E, 0x150, 0x152, 0x154, 0x156, 0x158, 0x15A, 0x15C, 0x15E, 0x160, 0x162, 0x164, 0x166, 0x168, 0x16A, 0x16C, 0x16E, 0x170, 0x172, 0x174, 0x176, 0x179, 0x17B, 0x17D, 0x191, 0x391, 0x392, 0x393, 0x394, 0x395, 0x396, 0x397, 0x398, 0x399, 0x39A, 0x39B, 0x39C, 0x39D, 0x39E, 0x39F, 0x3A0, 0x3A1, 0x3A3, 0x3A4, 0x3A5, 0x3A6, 0x3A7, 0x3A8, 0x3A9, 0x3AA, 0x410, 0x411, 0x412, 0x413, 0x414, 0x415, 0x416, 0x417, 0x418, 0x419, 0x41A, 0x41B, 0x41C, 0x41D, 0x41E, 0x41F, 0x420, 0x421, 0x422, 0x423, 0x424, 0x425, 0x426, 0x427, 0x428, 0x429, 0x42A, 0x42B, 0x42C, 0x42D, 0x42E, 0x42F, 0x401, 0x402, 0x403, 0x404, 0x405, 0x406, 0x407, 0x408, 0x409, 0x40A, 0x40B, 0x40C, 0x40E, 0x40F, 0x2160, 0x2161, 0x2162, 0x2163, 0x2164, 0x2165, 0x2166, 0x2167, 0x2168, 0x2169, 0x216A, 0x216B, 0x216C, 0x216D, 0x216E, 0x216F, 0xFF21, 0xFF22, 0xFF23, 0xFF24, 0xFF25, 0xFF26, 0xFF27, 0xFF28, 0xFF29, 0xFF2A, 0xFF2B, 0xFF2C, 0xFF2D, 0xFF2E, 0xFF2F, 0xFF30, 0xFF31, 0xFF32, 0xFF33, 0xFF34, 0xFF35, 0xFF36, 0xFF37, 0xFF38, 0xFF39, 0xFF3A, 0 };
	int i;


	for (i = 0; tbl_lower[i] && chr != tbl_lower[i]; i++) ;
  40658e:	2200      	movs	r2, #0

	return tbl_lower[i] ? tbl_upper[i] : chr;
  406590:	4b02      	ldr	r3, [pc, #8]	; (40659c <ff_wtoupper+0x28>)
  406592:	f833 0012 	ldrh.w	r0, [r3, r2, lsl #1]
}
  406596:	4770      	bx	lr
  406598:	004160d8 	.word	0x004160d8
  40659c:	004163b8 	.word	0x004163b8

004065a0 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
  4065a0:	f100 0308 	add.w	r3, r0, #8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
  4065a4:	f04f 31ff 	mov.w	r1, #4294967295
	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
  4065a8:	2200      	movs	r2, #0
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
  4065aa:	6081      	str	r1, [r0, #8]
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
  4065ac:	6043      	str	r3, [r0, #4]
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
  4065ae:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
  4065b0:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
  4065b2:	6002      	str	r2, [r0, #0]
  4065b4:	4770      	bx	lr
  4065b6:	bf00      	nop

004065b8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
  4065b8:	2300      	movs	r3, #0
  4065ba:	6103      	str	r3, [r0, #16]
  4065bc:	4770      	bx	lr
  4065be:	bf00      	nop

004065c0 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
  4065c0:	6843      	ldr	r3, [r0, #4]

	pxNewListItem->pxNext = pxIndex->pxNext;
  4065c2:	685a      	ldr	r2, [r3, #4]
  4065c4:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxPrevious = pxList->pxIndex;
  4065c6:	6842      	ldr	r2, [r0, #4]
  4065c8:	608a      	str	r2, [r1, #8]
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
  4065ca:	685a      	ldr	r2, [r3, #4]
  4065cc:	6091      	str	r1, [r2, #8]
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
  4065ce:	6059      	str	r1, [r3, #4]
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
  4065d0:	6041      	str	r1, [r0, #4]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
  4065d2:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
  4065d4:	6803      	ldr	r3, [r0, #0]
  4065d6:	3301      	adds	r3, #1
  4065d8:	6003      	str	r3, [r0, #0]
  4065da:	4770      	bx	lr

004065dc <vListInsert>:
}
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
  4065dc:	b410      	push	{r4}
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
  4065de:	680c      	ldr	r4, [r1, #0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
  4065e0:	1c63      	adds	r3, r4, #1
  4065e2:	d016      	beq.n	406612 <vListInsert+0x36>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
  4065e4:	68c3      	ldr	r3, [r0, #12]
  4065e6:	681a      	ldr	r2, [r3, #0]
  4065e8:	4294      	cmp	r4, r2
  4065ea:	f100 0308 	add.w	r3, r0, #8
  4065ee:	d304      	bcc.n	4065fa <vListInsert+0x1e>
  4065f0:	685b      	ldr	r3, [r3, #4]
  4065f2:	685a      	ldr	r2, [r3, #4]
  4065f4:	6812      	ldr	r2, [r2, #0]
  4065f6:	4294      	cmp	r4, r2
  4065f8:	d2fa      	bcs.n	4065f0 <vListInsert+0x14>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
  4065fa:	685a      	ldr	r2, [r3, #4]
  4065fc:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
  4065fe:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious = pxIterator;
  406600:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
  406602:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
  406604:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
  406606:	6803      	ldr	r3, [r0, #0]
}
  406608:	f85d 4b04 	ldr.w	r4, [sp], #4

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
  40660c:	3301      	adds	r3, #1
  40660e:	6003      	str	r3, [r0, #0]
}
  406610:	4770      	bx	lr
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
	{
		pxIterator = pxList->xListEnd.pxPrevious;
  406612:	6903      	ldr	r3, [r0, #16]
  406614:	e7f1      	b.n	4065fa <vListInsert+0x1e>
  406616:	bf00      	nop

00406618 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
  406618:	6843      	ldr	r3, [r0, #4]
  40661a:	6882      	ldr	r2, [r0, #8]
  40661c:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
  40661e:	6883      	ldr	r3, [r0, #8]
  406620:	6842      	ldr	r2, [r0, #4]
  406622:	605a      	str	r2, [r3, #4]

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
  406624:	6903      	ldr	r3, [r0, #16]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
  406626:	685a      	ldr	r2, [r3, #4]
  406628:	4282      	cmp	r2, r0
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
  40662a:	bf04      	itt	eq
  40662c:	6882      	ldreq	r2, [r0, #8]
  40662e:	605a      	streq	r2, [r3, #4]
	}

	pxItemToRemove->pvContainer = NULL;
  406630:	2200      	movs	r2, #0
  406632:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
  406634:	681a      	ldr	r2, [r3, #0]
  406636:	3a01      	subs	r2, #1
  406638:	601a      	str	r2, [r3, #0]
  40663a:	4770      	bx	lr

0040663c <pxPortInitialiseStack>:
/**
 * \brief See header file for description.
 */
portSTACK_TYPE *pxPortInitialiseStack(portSTACK_TYPE *pxTopOfStack,
		pdTASK_CODE pxCode, void *pvParameters)
{
  40663c:	b410      	push	{r4}
	pxTopOfStack--;  /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
	*pxTopOfStack = portINITIAL_XPSR;  /* xPSR */
	pxTopOfStack--;
	*pxTopOfStack = (portSTACK_TYPE) pxCode;  /* PC */
	pxTopOfStack--;
	*pxTopOfStack = 0;  /* LR */
  40663e:	2300      	movs	r3, #0
		pdTASK_CODE pxCode, void *pvParameters)
{
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
	pxTopOfStack--;  /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
	*pxTopOfStack = portINITIAL_XPSR;  /* xPSR */
  406640:	f04f 7480 	mov.w	r4, #16777216	; 0x1000000
	pxTopOfStack--;
	*pxTopOfStack = (portSTACK_TYPE) pxCode;  /* PC */
  406644:	f840 1c08 	str.w	r1, [r0, #-8]
	pxTopOfStack--;
	*pxTopOfStack = 0;  /* LR */
	pxTopOfStack -= 5;  /* R12, R3, R2 and R1. */
	*pxTopOfStack = (portSTACK_TYPE) pvParameters;  /* R0 */
  406648:	f840 2c20 	str.w	r2, [r0, #-32]
		pdTASK_CODE pxCode, void *pvParameters)
{
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
	pxTopOfStack--;  /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
	*pxTopOfStack = portINITIAL_XPSR;  /* xPSR */
  40664c:	f840 4c04 	str.w	r4, [r0, #-4]
	pxTopOfStack--;
	*pxTopOfStack = (portSTACK_TYPE) pxCode;  /* PC */
	pxTopOfStack--;
	*pxTopOfStack = 0;  /* LR */
  406650:	f840 3c0c 	str.w	r3, [r0, #-12]
	pxTopOfStack -= 5;  /* R12, R3, R2 and R1. */
	*pxTopOfStack = (portSTACK_TYPE) pvParameters;  /* R0 */
	pxTopOfStack -= 8;  /* R11, R10, R9, R8, R7, R6, R5 and R4. */

	return pxTopOfStack;
}
  406654:	f85d 4b04 	ldr.w	r4, [sp], #4
  406658:	3840      	subs	r0, #64	; 0x40
  40665a:	4770      	bx	lr

0040665c <SVC_Handler>:
/**
 * \brief Handler for Sytem supervisor call.
 */
void vPortSVCHandler(void)
{
	__asm volatile (" ldr r3, pxCurrentTCBConst2  \n"  /* Restore the context. */
  40665c:	4b06      	ldr	r3, [pc, #24]	; (406678 <pxCurrentTCBConst2>)
  40665e:	6819      	ldr	r1, [r3, #0]
  406660:	6808      	ldr	r0, [r1, #0]
  406662:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
  406666:	f380 8809 	msr	PSP, r0
  40666a:	f04f 0000 	mov.w	r0, #0
  40666e:	f380 8811 	msr	BASEPRI, r0
  406672:	f04e 0e0d 	orr.w	lr, lr, #13
  406676:	4770      	bx	lr

00406678 <pxCurrentTCBConst2>:
  406678:	200034b8 	.word	0x200034b8

0040667c <vPortStartFirstTask>:
/**
 * \brief Start schedule first task.
 */
void vPortStartFirstTask(void)
{
	__asm volatile (" ldr r0, =0xE000ED08   \n"  /* Use the NVIC offset register to locate the stack. */
  40667c:	4802      	ldr	r0, [pc, #8]	; (406688 <vPortStartFirstTask+0xc>)
  40667e:	6800      	ldr	r0, [r0, #0]
  406680:	6800      	ldr	r0, [r0, #0]
  406682:	f380 8808 	msr	MSP, r0
  406686:	df00      	svc	0
  406688:	e000ed08 	.word	0xe000ed08

0040668c <xPortStartScheduler>:

/**
 * \brief See header file for description.
 */
portBASE_TYPE xPortStartScheduler(void)
{
  40668c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
  40668e:	4b0b      	ldr	r3, [pc, #44]	; (4066bc <xPortStartScheduler+0x30>)
void prvSetupTimerInterrupt(void)
{
	/* Configure SysTick to interrupt at the requested rate. */
	*(portNVIC_SYSTICK_LOAD) =
			(configCPU_CLOCK_HZ / configTICK_RATE_HZ) - 1UL;
	*(portNVIC_SYSTICK_CTRL) =
  406690:	480b      	ldr	r0, [pc, #44]	; (4066c0 <xPortStartScheduler+0x34>)
 * \brief See header file for description.
 */
portBASE_TYPE xPortStartScheduler(void)
{
	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
  406692:	681c      	ldr	r4, [r3, #0]
 * frequency.
 */
void prvSetupTimerInterrupt(void)
{
	/* Configure SysTick to interrupt at the requested rate. */
	*(portNVIC_SYSTICK_LOAD) =
  406694:	4e0b      	ldr	r6, [pc, #44]	; (4066c4 <xPortStartScheduler+0x38>)
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
  406696:	490c      	ldr	r1, [pc, #48]	; (4066c8 <xPortStartScheduler+0x3c>)
 * frequency.
 */
void prvSetupTimerInterrupt(void)
{
	/* Configure SysTick to interrupt at the requested rate. */
	*(portNVIC_SYSTICK_LOAD) =
  406698:	4f0c      	ldr	r7, [pc, #48]	; (4066cc <xPortStartScheduler+0x40>)

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;

	/* Start the first task. */
	vPortStartFirstTask();
  40669a:	4a0d      	ldr	r2, [pc, #52]	; (4066d0 <xPortStartScheduler+0x44>)
 * \brief See header file for description.
 */
portBASE_TYPE xPortStartScheduler(void)
{
	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
  40669c:	f444 047f 	orr.w	r4, r4, #16711680	; 0xff0000
  4066a0:	601c      	str	r4, [r3, #0]
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
  4066a2:	681c      	ldr	r4, [r3, #0]
void prvSetupTimerInterrupt(void)
{
	/* Configure SysTick to interrupt at the requested rate. */
	*(portNVIC_SYSTICK_LOAD) =
			(configCPU_CLOCK_HZ / configTICK_RATE_HZ) - 1UL;
	*(portNVIC_SYSTICK_CTRL) =
  4066a4:	2507      	movs	r5, #7
 */
portBASE_TYPE xPortStartScheduler(void)
{
	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
  4066a6:	f044 447f 	orr.w	r4, r4, #4278190080	; 0xff000000
  4066aa:	601c      	str	r4, [r3, #0]
 * frequency.
 */
void prvSetupTimerInterrupt(void)
{
	/* Configure SysTick to interrupt at the requested rate. */
	*(portNVIC_SYSTICK_LOAD) =
  4066ac:	6037      	str	r7, [r6, #0]
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
  4066ae:	2400      	movs	r4, #0
void prvSetupTimerInterrupt(void)
{
	/* Configure SysTick to interrupt at the requested rate. */
	*(portNVIC_SYSTICK_LOAD) =
			(configCPU_CLOCK_HZ / configTICK_RATE_HZ) - 1UL;
	*(portNVIC_SYSTICK_CTRL) =
  4066b0:	6005      	str	r5, [r0, #0]
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
  4066b2:	600c      	str	r4, [r1, #0]

	/* Start the first task. */
	vPortStartFirstTask();
  4066b4:	4790      	blx	r2

	/* Should not get here! */
	return 0;
}
  4066b6:	4620      	mov	r0, r4
  4066b8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  4066ba:	bf00      	nop
  4066bc:	e000ed20 	.word	0xe000ed20
  4066c0:	e000e010 	.word	0xe000e010
  4066c4:	e000e014 	.word	0xe000e014
  4066c8:	20000130 	.word	0x20000130
  4066cc:	0001d4bf 	.word	0x0001d4bf
  4066d0:	0040667d 	.word	0x0040667d

004066d4 <vPortYieldFromISR>:
 * \brief Yield PendSV to request a context switch.
 */
void vPortYieldFromISR(void)
{
	/* Set a PendSV to request a context switch. */
	*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
  4066d4:	4b02      	ldr	r3, [pc, #8]	; (4066e0 <vPortYieldFromISR+0xc>)
  4066d6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  4066da:	601a      	str	r2, [r3, #0]
  4066dc:	4770      	bx	lr
  4066de:	bf00      	nop
  4066e0:	e000ed04 	.word	0xe000ed04

004066e4 <vPortEnterCritical>:
/**
 * \brief Enter Critical code.
 */
void vPortEnterCritical(void)
{
	portDISABLE_INTERRUPTS();
  4066e4:	f04f 0000 	mov.w	r0, #0
  4066e8:	f380 8811 	msr	BASEPRI, r0
	uxCriticalNesting++;
  4066ec:	4b02      	ldr	r3, [pc, #8]	; (4066f8 <vPortEnterCritical+0x14>)
  4066ee:	681a      	ldr	r2, [r3, #0]
  4066f0:	3201      	adds	r2, #1
  4066f2:	601a      	str	r2, [r3, #0]
  4066f4:	4770      	bx	lr
  4066f6:	bf00      	nop
  4066f8:	20000130 	.word	0x20000130

004066fc <vPortExitCritical>:
/**
 * \brief Exit Critical code.
 */
void vPortExitCritical(void)
{
	uxCriticalNesting--;
  4066fc:	4a04      	ldr	r2, [pc, #16]	; (406710 <vPortExitCritical+0x14>)
  4066fe:	6813      	ldr	r3, [r2, #0]
  406700:	3b01      	subs	r3, #1
  406702:	6013      	str	r3, [r2, #0]
	if (uxCriticalNesting == 0) {
  406704:	b91b      	cbnz	r3, 40670e <vPortExitCritical+0x12>
		portENABLE_INTERRUPTS();
  406706:	f04f 0000 	mov.w	r0, #0
  40670a:	f380 8811 	msr	BASEPRI, r0
  40670e:	4770      	bx	lr
  406710:	20000130 	.word	0x20000130

00406714 <PendSV_Handler>:
 * \brief Handler for Sytem interrupt-driven request.
 */
void xPortPendSVHandler(void)
{
	/* This is a naked function. */
	__asm volatile (" mrs r0, psp      \n"
  406714:	f3ef 8009 	mrs	r0, PSP
  406718:	4b0c      	ldr	r3, [pc, #48]	; (40674c <pxCurrentTCBConst>)
  40671a:	681a      	ldr	r2, [r3, #0]
  40671c:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
  406720:	6010      	str	r0, [r2, #0]
  406722:	e92d 4008 	stmdb	sp!, {r3, lr}
  406726:	f04f 0000 	mov.w	r0, #0
  40672a:	f380 8811 	msr	BASEPRI, r0
  40672e:	f000 febb 	bl	4074a8 <vTaskSwitchContext>
  406732:	f04f 0000 	mov.w	r0, #0
  406736:	f380 8811 	msr	BASEPRI, r0
  40673a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  40673e:	6819      	ldr	r1, [r3, #0]
  406740:	6808      	ldr	r0, [r1, #0]
  406742:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
  406746:	f380 8809 	msr	PSP, r0
  40674a:	4770      	bx	lr

0040674c <pxCurrentTCBConst>:
  40674c:	200034b8 	.word	0x200034b8

00406750 <xPortSysTickHandler>:

/**
 * \brief Handler for Sytem Tick interrupt.
 */
void xPortSysTickHandler(void)
{
  406750:	b508      	push	{r3, lr}
	unsigned portLONG ulDummy;

	/* If using preemption, also force a context switch. */
#if configUSE_PREEMPTION == 1
	*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
  406752:	4b07      	ldr	r3, [pc, #28]	; (406770 <xPortSysTickHandler+0x20>)
  406754:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  406758:	601a      	str	r2, [r3, #0]
#endif

	ulDummy = portSET_INTERRUPT_MASK_FROM_ISR();
  40675a:	f04f 0000 	mov.w	r0, #0
  40675e:	f380 8811 	msr	BASEPRI, r0
	{
		vTaskIncrementTick();
  406762:	4b04      	ldr	r3, [pc, #16]	; (406774 <xPortSysTickHandler+0x24>)
  406764:	4798      	blx	r3
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR(ulDummy);
  406766:	f04f 0000 	mov.w	r0, #0
  40676a:	f380 8811 	msr	BASEPRI, r0
  40676e:	bd08      	pop	{r3, pc}
  406770:	e000ed04 	.word	0xe000ed04
  406774:	004070cd 	.word	0x004070cd

00406778 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
  406778:	b510      	push	{r4, lr}
void *pvReturn;

	vTaskSuspendAll();
  40677a:	4b05      	ldr	r3, [pc, #20]	; (406790 <pvPortMalloc+0x18>)
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
  40677c:	4604      	mov	r4, r0
void *pvReturn;

	vTaskSuspendAll();
  40677e:	4798      	blx	r3
	{
		pvReturn = malloc( xWantedSize );
  406780:	4620      	mov	r0, r4
  406782:	4b04      	ldr	r3, [pc, #16]	; (406794 <pvPortMalloc+0x1c>)
  406784:	4798      	blx	r3
	}
	xTaskResumeAll();
  406786:	4b04      	ldr	r3, [pc, #16]	; (406798 <pvPortMalloc+0x20>)
{
void *pvReturn;

	vTaskSuspendAll();
	{
		pvReturn = malloc( xWantedSize );
  406788:	4604      	mov	r4, r0
	}
	xTaskResumeAll();
  40678a:	4798      	blx	r3
		}
	}
	#endif

	return pvReturn;
}
  40678c:	4620      	mov	r0, r4
  40678e:	bd10      	pop	{r4, pc}
  406790:	00407091 	.word	0x00407091
  406794:	0040bbd1 	.word	0x0040bbd1
  406798:	004071f9 	.word	0x004071f9

0040679c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
  40679c:	b510      	push	{r4, lr}
	if( pv )
  40679e:	4604      	mov	r4, r0
  4067a0:	b130      	cbz	r0, 4067b0 <vPortFree+0x14>
	{
		vTaskSuspendAll();
  4067a2:	4b04      	ldr	r3, [pc, #16]	; (4067b4 <vPortFree+0x18>)
  4067a4:	4798      	blx	r3
		{
			free( pv );
  4067a6:	4b04      	ldr	r3, [pc, #16]	; (4067b8 <vPortFree+0x1c>)
  4067a8:	4620      	mov	r0, r4
  4067aa:	4798      	blx	r3
		}
		xTaskResumeAll();
  4067ac:	4b03      	ldr	r3, [pc, #12]	; (4067bc <vPortFree+0x20>)
  4067ae:	4798      	blx	r3
  4067b0:	bd10      	pop	{r4, pc}
  4067b2:	bf00      	nop
  4067b4:	00407091 	.word	0x00407091
  4067b8:	0040bbe1 	.word	0x0040bbe1
  4067bc:	004071f9 	.word	0x004071f9

004067c0 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
  4067c0:	b538      	push	{r3, r4, r5, lr}
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
  4067c2:	6c03      	ldr	r3, [r0, #64]	; 0x40
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
  4067c4:	4604      	mov	r4, r0
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
  4067c6:	b933      	cbnz	r3, 4067d6 <prvCopyDataToQueue+0x16>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  4067c8:	6805      	ldr	r5, [r0, #0]
  4067ca:	2d00      	cmp	r5, #0
  4067cc:	d028      	beq.n	406820 <prvCopyDataToQueue+0x60>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
		}
	}

	++( pxQueue->uxMessagesWaiting );
  4067ce:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  4067d0:	3301      	adds	r3, #1
  4067d2:	63a3      	str	r3, [r4, #56]	; 0x38
  4067d4:	bd38      	pop	{r3, r4, r5, pc}
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
  4067d6:	b982      	cbnz	r2, 4067fa <prvCopyDataToQueue+0x3a>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
  4067d8:	461a      	mov	r2, r3
  4067da:	6880      	ldr	r0, [r0, #8]
  4067dc:	4b13      	ldr	r3, [pc, #76]	; (40682c <prvCopyDataToQueue+0x6c>)
  4067de:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
  4067e0:	68a1      	ldr	r1, [r4, #8]
  4067e2:	6c23      	ldr	r3, [r4, #64]	; 0x40
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
  4067e4:	6862      	ldr	r2, [r4, #4]
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
  4067e6:	440b      	add	r3, r1
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
  4067e8:	4293      	cmp	r3, r2
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
  4067ea:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
  4067ec:	d3ef      	bcc.n	4067ce <prvCopyDataToQueue+0xe>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
  4067ee:	6823      	ldr	r3, [r4, #0]
  4067f0:	60a3      	str	r3, [r4, #8]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
		}
	}

	++( pxQueue->uxMessagesWaiting );
  4067f2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  4067f4:	3301      	adds	r3, #1
  4067f6:	63a3      	str	r3, [r4, #56]	; 0x38
  4067f8:	bd38      	pop	{r3, r4, r5, pc}
			pxQueue->pcWriteTo = pxQueue->pcHead;
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
  4067fa:	461a      	mov	r2, r3
  4067fc:	68c0      	ldr	r0, [r0, #12]
  4067fe:	4b0b      	ldr	r3, [pc, #44]	; (40682c <prvCopyDataToQueue+0x6c>)
  406800:	4798      	blx	r3
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
  406802:	6c22      	ldr	r2, [r4, #64]	; 0x40
  406804:	68e3      	ldr	r3, [r4, #12]
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
  406806:	6821      	ldr	r1, [r4, #0]
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
  406808:	4252      	negs	r2, r2
  40680a:	4413      	add	r3, r2
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
  40680c:	428b      	cmp	r3, r1
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
  40680e:	60e3      	str	r3, [r4, #12]
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
  406810:	d2dd      	bcs.n	4067ce <prvCopyDataToQueue+0xe>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
  406812:	6863      	ldr	r3, [r4, #4]
  406814:	441a      	add	r2, r3
		}
	}

	++( pxQueue->uxMessagesWaiting );
  406816:	6ba3      	ldr	r3, [r4, #56]	; 0x38
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
  406818:	60e2      	str	r2, [r4, #12]
		}
	}

	++( pxQueue->uxMessagesWaiting );
  40681a:	3301      	adds	r3, #1
  40681c:	63a3      	str	r3, [r4, #56]	; 0x38
  40681e:	bd38      	pop	{r3, r4, r5, pc}
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
  406820:	6840      	ldr	r0, [r0, #4]
  406822:	4b03      	ldr	r3, [pc, #12]	; (406830 <prvCopyDataToQueue+0x70>)
  406824:	4798      	blx	r3
				pxQueue->pxMutexHolder = NULL;
  406826:	6065      	str	r5, [r4, #4]
  406828:	e7d1      	b.n	4067ce <prvCopyDataToQueue+0xe>
  40682a:	bf00      	nop
  40682c:	0040c129 	.word	0x0040c129
  406830:	004077d5 	.word	0x004077d5

00406834 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
  406834:	b538      	push	{r3, r4, r5, lr}
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
  406836:	6804      	ldr	r4, [r0, #0]
  406838:	b164      	cbz	r4, 406854 <prvCopyDataFromQueue+0x20>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
  40683a:	68c3      	ldr	r3, [r0, #12]
  40683c:	6c02      	ldr	r2, [r0, #64]	; 0x40
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
  40683e:	6845      	ldr	r5, [r0, #4]

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
  406840:	4413      	add	r3, r2
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
  406842:	42ab      	cmp	r3, r5

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
  406844:	60c3      	str	r3, [r0, #12]
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
  406846:	bf24      	itt	cs
  406848:	4623      	movcs	r3, r4
  40684a:	60c4      	strcs	r4, [r0, #12]
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
  40684c:	4608      	mov	r0, r1
  40684e:	4619      	mov	r1, r3
  406850:	4b01      	ldr	r3, [pc, #4]	; (406858 <prvCopyDataFromQueue+0x24>)
  406852:	4798      	blx	r3
  406854:	bd38      	pop	{r3, r4, r5, pc}
  406856:	bf00      	nop
  406858:	0040c129 	.word	0x0040c129

0040685c <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
  40685c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  406860:	4604      	mov	r4, r0

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
  406862:	4f23      	ldr	r7, [pc, #140]	; (4068f0 <prvUnlockQueue+0x94>)
  406864:	47b8      	blx	r7
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
  406866:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  406868:	2b00      	cmp	r3, #0
  40686a:	dd18      	ble.n	40689e <prvUnlockQueue+0x42>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  40686c:	6a63      	ldr	r3, [r4, #36]	; 0x24
  40686e:	b1b3      	cbz	r3, 40689e <prvUnlockQueue+0x42>
  406870:	f104 0624 	add.w	r6, r4, #36	; 0x24
  406874:	4d1f      	ldr	r5, [pc, #124]	; (4068f4 <prvUnlockQueue+0x98>)
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
  406876:	f8df 8080 	ldr.w	r8, [pc, #128]	; 4068f8 <prvUnlockQueue+0x9c>
  40687a:	e006      	b.n	40688a <prvUnlockQueue+0x2e>
				}

				--( pxQueue->xTxLock );
  40687c:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  40687e:	3b01      	subs	r3, #1
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
  406880:	2b00      	cmp	r3, #0
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
				}

				--( pxQueue->xTxLock );
  406882:	64a3      	str	r3, [r4, #72]	; 0x48
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
  406884:	dd0b      	ble.n	40689e <prvUnlockQueue+0x42>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  406886:	6a63      	ldr	r3, [r4, #36]	; 0x24
  406888:	b14b      	cbz	r3, 40689e <prvUnlockQueue+0x42>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  40688a:	4630      	mov	r0, r6
  40688c:	47a8      	blx	r5
  40688e:	2800      	cmp	r0, #0
  406890:	d0f4      	beq.n	40687c <prvUnlockQueue+0x20>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
  406892:	47c0      	blx	r8
				}

				--( pxQueue->xTxLock );
  406894:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  406896:	3b01      	subs	r3, #1
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
  406898:	2b00      	cmp	r3, #0
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
				}

				--( pxQueue->xTxLock );
  40689a:	64a3      	str	r3, [r4, #72]	; 0x48
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
  40689c:	dcf3      	bgt.n	406886 <prvUnlockQueue+0x2a>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
  40689e:	f04f 33ff 	mov.w	r3, #4294967295
  4068a2:	64a3      	str	r3, [r4, #72]	; 0x48
	}
	taskEXIT_CRITICAL();
  4068a4:	f8df 8054 	ldr.w	r8, [pc, #84]	; 4068fc <prvUnlockQueue+0xa0>
  4068a8:	47c0      	blx	r8

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
  4068aa:	47b8      	blx	r7
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
  4068ac:	6c63      	ldr	r3, [r4, #68]	; 0x44
  4068ae:	2b00      	cmp	r3, #0
  4068b0:	dd17      	ble.n	4068e2 <prvUnlockQueue+0x86>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  4068b2:	6923      	ldr	r3, [r4, #16]
  4068b4:	b1ab      	cbz	r3, 4068e2 <prvUnlockQueue+0x86>
  4068b6:	f104 0610 	add.w	r6, r4, #16
  4068ba:	4d0e      	ldr	r5, [pc, #56]	; (4068f4 <prvUnlockQueue+0x98>)
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
				{
					vTaskMissedYield();
  4068bc:	4f0e      	ldr	r7, [pc, #56]	; (4068f8 <prvUnlockQueue+0x9c>)
  4068be:	e006      	b.n	4068ce <prvUnlockQueue+0x72>
				}

				--( pxQueue->xRxLock );
  4068c0:	6c63      	ldr	r3, [r4, #68]	; 0x44
  4068c2:	3b01      	subs	r3, #1
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
  4068c4:	2b00      	cmp	r3, #0
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
				{
					vTaskMissedYield();
				}

				--( pxQueue->xRxLock );
  4068c6:	6463      	str	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
  4068c8:	dd0b      	ble.n	4068e2 <prvUnlockQueue+0x86>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  4068ca:	6923      	ldr	r3, [r4, #16]
  4068cc:	b14b      	cbz	r3, 4068e2 <prvUnlockQueue+0x86>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  4068ce:	4630      	mov	r0, r6
  4068d0:	47a8      	blx	r5
  4068d2:	2800      	cmp	r0, #0
  4068d4:	d0f4      	beq.n	4068c0 <prvUnlockQueue+0x64>
				{
					vTaskMissedYield();
  4068d6:	47b8      	blx	r7
				}

				--( pxQueue->xRxLock );
  4068d8:	6c63      	ldr	r3, [r4, #68]	; 0x44
  4068da:	3b01      	subs	r3, #1
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
  4068dc:	2b00      	cmp	r3, #0
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
				{
					vTaskMissedYield();
				}

				--( pxQueue->xRxLock );
  4068de:	6463      	str	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
  4068e0:	dcf3      	bgt.n	4068ca <prvUnlockQueue+0x6e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
  4068e2:	f04f 33ff 	mov.w	r3, #4294967295
  4068e6:	6463      	str	r3, [r4, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
  4068e8:	47c0      	blx	r8
  4068ea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4068ee:	bf00      	nop
  4068f0:	004066e5 	.word	0x004066e5
  4068f4:	00407601 	.word	0x00407601
  4068f8:	00407705 	.word	0x00407705
  4068fc:	004066fd 	.word	0x004066fd

00406900 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
  406900:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
  406904:	4606      	mov	r6, r0
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
  406906:	460f      	mov	r7, r1
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
  406908:	b330      	cbz	r0, 406958 <xQueueCreate+0x58>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
  40690a:	204c      	movs	r0, #76	; 0x4c
  40690c:	4d17      	ldr	r5, [pc, #92]	; (40696c <xQueueCreate+0x6c>)
  40690e:	47a8      	blx	r5
		if( pxNewQueue != NULL )
  406910:	4604      	mov	r4, r0
  406912:	b308      	cbz	r0, 406958 <xQueueCreate+0x58>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
  406914:	fb07 f806 	mul.w	r8, r7, r6

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
  406918:	f108 0001 	add.w	r0, r8, #1
  40691c:	47a8      	blx	r5
  40691e:	4605      	mov	r5, r0
  406920:	6020      	str	r0, [r4, #0]
			if( pxNewQueue->pcHead != NULL )
  406922:	b1e8      	cbz	r0, 406960 <xQueueCreate+0x60>
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
  406924:	ebc7 0008 	rsb	r0, r7, r8
  406928:	4428      	add	r0, r5
			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
			if( pxNewQueue->pcHead != NULL )
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
  40692a:	eb05 0108 	add.w	r1, r5, r8
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
				pxNewQueue->uxLength = uxQueueLength;
				pxNewQueue->uxItemSize = uxItemSize;
				pxNewQueue->xRxLock = queueUNLOCKED;
  40692e:	f04f 33ff 	mov.w	r3, #4294967295
			if( pxNewQueue->pcHead != NULL )
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
  406932:	2200      	movs	r2, #0
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
  406934:	60a5      	str	r5, [r4, #8]
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
  406936:	60e0      	str	r0, [r4, #12]
				pxNewQueue->uxLength = uxQueueLength;
  406938:	63e6      	str	r6, [r4, #60]	; 0x3c
				pxNewQueue->uxItemSize = uxItemSize;
				pxNewQueue->xRxLock = queueUNLOCKED;
				pxNewQueue->xTxLock = queueUNLOCKED;

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
  40693a:	f104 0010 	add.w	r0, r4, #16
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
				pxNewQueue->uxLength = uxQueueLength;
				pxNewQueue->uxItemSize = uxItemSize;
  40693e:	6427      	str	r7, [r4, #64]	; 0x40
			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
			if( pxNewQueue->pcHead != NULL )
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
  406940:	6061      	str	r1, [r4, #4]
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
  406942:	63a2      	str	r2, [r4, #56]	; 0x38
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
				pxNewQueue->uxLength = uxQueueLength;
				pxNewQueue->uxItemSize = uxItemSize;
				pxNewQueue->xRxLock = queueUNLOCKED;
  406944:	6463      	str	r3, [r4, #68]	; 0x44
				pxNewQueue->xTxLock = queueUNLOCKED;
  406946:	64a3      	str	r3, [r4, #72]	; 0x48

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
  406948:	4d09      	ldr	r5, [pc, #36]	; (406970 <xQueueCreate+0x70>)
  40694a:	47a8      	blx	r5
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
  40694c:	f104 0024 	add.w	r0, r4, #36	; 0x24
  406950:	47a8      	blx	r5
	}

	configASSERT( xReturn );

	return xReturn;
}
  406952:	4620      	mov	r0, r4
  406954:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
  406958:	2400      	movs	r4, #0
	}

	configASSERT( xReturn );

	return xReturn;
}
  40695a:	4620      	mov	r0, r4
  40695c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
  406960:	4620      	mov	r0, r4
  406962:	4b04      	ldr	r3, [pc, #16]	; (406974 <xQueueCreate+0x74>)
  406964:	4798      	blx	r3

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
  406966:	462c      	mov	r4, r5
  406968:	e7f3      	b.n	406952 <xQueueCreate+0x52>
  40696a:	bf00      	nop
  40696c:	00406779 	.word	0x00406779
  406970:	004065a1 	.word	0x004065a1
  406974:	0040679d 	.word	0x0040679d

00406978 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
  406978:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40697c:	4f37      	ldr	r7, [pc, #220]	; (406a5c <xQueueGenericSend+0xe4>)
  40697e:	4d38      	ldr	r5, [pc, #224]	; (406a60 <xQueueGenericSend+0xe8>)
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
  406980:	f8df a0fc 	ldr.w	sl, [pc, #252]	; 406a80 <xQueueGenericSend+0x108>
		taskEXIT_CRITICAL();

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
  406984:	f8df 80fc 	ldr.w	r8, [pc, #252]	; 406a84 <xQueueGenericSend+0x10c>

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
  406988:	b087      	sub	sp, #28
  40698a:	4604      	mov	r4, r0
  40698c:	9203      	str	r2, [sp, #12]
  40698e:	9101      	str	r1, [sp, #4]
  406990:	9302      	str	r3, [sp, #8]

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
  406992:	46b9      	mov	r9, r7
#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
  406994:	2600      	movs	r6, #0
  406996:	e021      	b.n	4069dc <xQueueGenericSend+0x64>
  406998:	ae04      	add	r6, sp, #16
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
  40699a:	47b8      	blx	r7

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
  40699c:	47c0      	blx	r8
		prvLockQueue( pxQueue );
  40699e:	47a8      	blx	r5
  4069a0:	6c63      	ldr	r3, [r4, #68]	; 0x44
  4069a2:	3301      	adds	r3, #1
  4069a4:	bf04      	itt	eq
  4069a6:	2300      	moveq	r3, #0
  4069a8:	6463      	streq	r3, [r4, #68]	; 0x44
  4069aa:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  4069ac:	3301      	adds	r3, #1
  4069ae:	bf04      	itt	eq
  4069b0:	2300      	moveq	r3, #0
  4069b2:	64a3      	streq	r3, [r4, #72]	; 0x48
  4069b4:	47b8      	blx	r7

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  4069b6:	4630      	mov	r0, r6
  4069b8:	a903      	add	r1, sp, #12
  4069ba:	4b2a      	ldr	r3, [pc, #168]	; (406a64 <xQueueGenericSend+0xec>)
  4069bc:	4798      	blx	r3
  4069be:	2800      	cmp	r0, #0
  4069c0:	d13a      	bne.n	406a38 <xQueueGenericSend+0xc0>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
  4069c2:	47a8      	blx	r5
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
  4069c4:	f8d4 b038 	ldr.w	fp, [r4, #56]	; 0x38
  4069c8:	6be6      	ldr	r6, [r4, #60]	; 0x3c
	taskEXIT_CRITICAL();
  4069ca:	47c8      	blx	r9
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
  4069cc:	45b3      	cmp	fp, r6
  4069ce:	d012      	beq.n	4069f6 <xQueueGenericSend+0x7e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
  4069d0:	4b25      	ldr	r3, [pc, #148]	; (406a68 <xQueueGenericSend+0xf0>)
  4069d2:	4620      	mov	r0, r4
  4069d4:	4798      	blx	r3
				( void ) xTaskResumeAll();
  4069d6:	4b25      	ldr	r3, [pc, #148]	; (406a6c <xQueueGenericSend+0xf4>)
  4069d8:	4798      	blx	r3
  4069da:	2601      	movs	r6, #1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
  4069dc:	47a8      	blx	r5
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
  4069de:	6ba2      	ldr	r2, [r4, #56]	; 0x38
  4069e0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  4069e2:	429a      	cmp	r2, r3
  4069e4:	d316      	bcc.n	406a14 <xQueueGenericSend+0x9c>
				function. */
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
  4069e6:	9803      	ldr	r0, [sp, #12]
  4069e8:	b300      	cbz	r0, 406a2c <xQueueGenericSend+0xb4>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
  4069ea:	2e00      	cmp	r6, #0
  4069ec:	d1d4      	bne.n	406998 <xQueueGenericSend+0x20>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
  4069ee:	ae04      	add	r6, sp, #16
  4069f0:	4630      	mov	r0, r6
  4069f2:	47d0      	blx	sl
  4069f4:	e7d1      	b.n	40699a <xQueueGenericSend+0x22>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
  4069f6:	f104 0010 	add.w	r0, r4, #16
  4069fa:	9903      	ldr	r1, [sp, #12]
  4069fc:	4b1c      	ldr	r3, [pc, #112]	; (406a70 <xQueueGenericSend+0xf8>)
  4069fe:	4798      	blx	r3
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
  406a00:	4b19      	ldr	r3, [pc, #100]	; (406a68 <xQueueGenericSend+0xf0>)
  406a02:	4620      	mov	r0, r4
  406a04:	4798      	blx	r3
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
  406a06:	4b19      	ldr	r3, [pc, #100]	; (406a6c <xQueueGenericSend+0xf4>)
  406a08:	4798      	blx	r3
  406a0a:	2800      	cmp	r0, #0
  406a0c:	d1e5      	bne.n	4069da <xQueueGenericSend+0x62>
				{
					portYIELD_WITHIN_API();
  406a0e:	4b19      	ldr	r3, [pc, #100]	; (406a74 <xQueueGenericSend+0xfc>)
  406a10:	4798      	blx	r3
  406a12:	e7e2      	b.n	4069da <xQueueGenericSend+0x62>
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  406a14:	4b18      	ldr	r3, [pc, #96]	; (406a78 <xQueueGenericSend+0x100>)
  406a16:	9901      	ldr	r1, [sp, #4]
  406a18:	9a02      	ldr	r2, [sp, #8]
  406a1a:	4620      	mov	r0, r4
  406a1c:	4798      	blx	r3

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  406a1e:	6a63      	ldr	r3, [r4, #36]	; 0x24
  406a20:	b99b      	cbnz	r3, 406a4a <xQueueGenericSend+0xd2>
						takes care of that. */
						portYIELD_WITHIN_API();
					}
				}

				taskEXIT_CRITICAL();
  406a22:	47b8      	blx	r7

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
  406a24:	2001      	movs	r0, #1
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
  406a26:	b007      	add	sp, #28
  406a28:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			{
				if( xTicksToWait == ( portTickType ) 0 )
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
  406a2c:	9000      	str	r0, [sp, #0]
  406a2e:	47b8      	blx	r7

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
  406a30:	9800      	ldr	r0, [sp, #0]
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
  406a32:	b007      	add	sp, #28
  406a34:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
  406a38:	4620      	mov	r0, r4
  406a3a:	4b0b      	ldr	r3, [pc, #44]	; (406a68 <xQueueGenericSend+0xf0>)
  406a3c:	4798      	blx	r3
			( void ) xTaskResumeAll();
  406a3e:	4b0b      	ldr	r3, [pc, #44]	; (406a6c <xQueueGenericSend+0xf4>)
  406a40:	4798      	blx	r3

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
  406a42:	2000      	movs	r0, #0
		}
	}
}
  406a44:	b007      	add	sp, #28
  406a46:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
  406a4a:	f104 0024 	add.w	r0, r4, #36	; 0x24
  406a4e:	4b0b      	ldr	r3, [pc, #44]	; (406a7c <xQueueGenericSend+0x104>)
  406a50:	4798      	blx	r3
  406a52:	2801      	cmp	r0, #1
  406a54:	d1e5      	bne.n	406a22 <xQueueGenericSend+0xaa>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
  406a56:	4b07      	ldr	r3, [pc, #28]	; (406a74 <xQueueGenericSend+0xfc>)
  406a58:	4798      	blx	r3
  406a5a:	e7e2      	b.n	406a22 <xQueueGenericSend+0xaa>
  406a5c:	004066fd 	.word	0x004066fd
  406a60:	004066e5 	.word	0x004066e5
  406a64:	00407689 	.word	0x00407689
  406a68:	0040685d 	.word	0x0040685d
  406a6c:	004071f9 	.word	0x004071f9
  406a70:	00407579 	.word	0x00407579
  406a74:	004066d5 	.word	0x004066d5
  406a78:	004067c1 	.word	0x004067c1
  406a7c:	00407601 	.word	0x00407601
  406a80:	00407671 	.word	0x00407671
  406a84:	00407091 	.word	0x00407091

00406a88 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
  406a88:	b570      	push	{r4, r5, r6, lr}
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
  406a8a:	204c      	movs	r0, #76	; 0x4c
  406a8c:	4b0f      	ldr	r3, [pc, #60]	; (406acc <xQueueCreateMutex+0x44>)
  406a8e:	4798      	blx	r3
		if( pxNewQueue != NULL )
  406a90:	4604      	mov	r4, r0
  406a92:	b1c0      	cbz	r0, 406ac6 <xQueueCreateMutex+0x3e>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
  406a94:	2500      	movs	r5, #0
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
			pxNewQueue->xRxLock = queueUNLOCKED;
  406a96:	f04f 33ff 	mov.w	r3, #4294967295

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
  406a9a:	2201      	movs	r2, #1
  406a9c:	63c2      	str	r2, [r0, #60]	; 0x3c
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
			pxNewQueue->xRxLock = queueUNLOCKED;
  406a9e:	6443      	str	r3, [r0, #68]	; 0x44
			pxNewQueue->xTxLock = queueUNLOCKED;
  406aa0:	6483      	str	r3, [r0, #72]	; 0x48
		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
		if( pxNewQueue != NULL )
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
  406aa2:	6045      	str	r5, [r0, #4]
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
  406aa4:	6005      	str	r5, [r0, #0]

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
  406aa6:	6085      	str	r5, [r0, #8]
			pxNewQueue->pcReadFrom = NULL;
  406aa8:	60c5      	str	r5, [r0, #12]

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
  406aaa:	6385      	str	r5, [r0, #56]	; 0x38
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
  406aac:	6405      	str	r5, [r0, #64]	; 0x40
			pxNewQueue->xRxLock = queueUNLOCKED;
			pxNewQueue->xTxLock = queueUNLOCKED;

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
  406aae:	4e08      	ldr	r6, [pc, #32]	; (406ad0 <xQueueCreateMutex+0x48>)
  406ab0:	3010      	adds	r0, #16
  406ab2:	47b0      	blx	r6
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
  406ab4:	f104 0024 	add.w	r0, r4, #36	; 0x24
  406ab8:	47b0      	blx	r6

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
  406aba:	4629      	mov	r1, r5
  406abc:	462a      	mov	r2, r5
  406abe:	462b      	mov	r3, r5
  406ac0:	4620      	mov	r0, r4
  406ac2:	4d04      	ldr	r5, [pc, #16]	; (406ad4 <xQueueCreateMutex+0x4c>)
  406ac4:	47a8      	blx	r5
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
  406ac6:	4620      	mov	r0, r4
  406ac8:	bd70      	pop	{r4, r5, r6, pc}
  406aca:	bf00      	nop
  406acc:	00406779 	.word	0x00406779
  406ad0:	004065a1 	.word	0x004065a1
  406ad4:	00406979 	.word	0x00406979

00406ad8 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
  406ad8:	b570      	push	{r4, r5, r6, lr}
  406ada:	4604      	mov	r4, r0
  406adc:	4616      	mov	r6, r2
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  406ade:	f04f 0000 	mov.w	r0, #0
  406ae2:	f380 8811 	msr	BASEPRI, r0
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
  406ae6:	6ba5      	ldr	r5, [r4, #56]	; 0x38
  406ae8:	6be0      	ldr	r0, [r4, #60]	; 0x3c
  406aea:	4285      	cmp	r5, r0
  406aec:	d306      	bcc.n	406afc <xQueueGenericSendFromISR+0x24>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
  406aee:	2300      	movs	r3, #0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
  406af0:	f04f 0000 	mov.w	r0, #0
  406af4:	f380 8811 	msr	BASEPRI, r0

	return xReturn;
}
  406af8:	4618      	mov	r0, r3
  406afa:	bd70      	pop	{r4, r5, r6, pc}
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  406afc:	461a      	mov	r2, r3
  406afe:	4620      	mov	r0, r4
  406b00:	4b0a      	ldr	r3, [pc, #40]	; (406b2c <xQueueGenericSendFromISR+0x54>)
  406b02:	4798      	blx	r3

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
  406b04:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  406b06:	1c5a      	adds	r2, r3, #1
  406b08:	d003      	beq.n	406b12 <xQueueGenericSendFromISR+0x3a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
  406b0a:	3301      	adds	r3, #1
  406b0c:	64a3      	str	r3, [r4, #72]	; 0x48
			}

			xReturn = pdPASS;
  406b0e:	2301      	movs	r3, #1
  406b10:	e7ee      	b.n	406af0 <xQueueGenericSendFromISR+0x18>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  406b12:	6a63      	ldr	r3, [r4, #36]	; 0x24
  406b14:	2b00      	cmp	r3, #0
  406b16:	d0fa      	beq.n	406b0e <xQueueGenericSendFromISR+0x36>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  406b18:	f104 0024 	add.w	r0, r4, #36	; 0x24
  406b1c:	4b04      	ldr	r3, [pc, #16]	; (406b30 <xQueueGenericSendFromISR+0x58>)
  406b1e:	4798      	blx	r3
  406b20:	2800      	cmp	r0, #0
  406b22:	d0f4      	beq.n	406b0e <xQueueGenericSendFromISR+0x36>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
  406b24:	2301      	movs	r3, #1
  406b26:	6033      	str	r3, [r6, #0]
  406b28:	e7e2      	b.n	406af0 <xQueueGenericSendFromISR+0x18>
  406b2a:	bf00      	nop
  406b2c:	004067c1 	.word	0x004067c1
  406b30:	00407601 	.word	0x00407601

00406b34 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
  406b34:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  406b38:	4f46      	ldr	r7, [pc, #280]	; (406c54 <xQueueGenericReceive+0x120>)
  406b3a:	4d47      	ldr	r5, [pc, #284]	; (406c58 <xQueueGenericReceive+0x124>)
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
  406b3c:	f8df a140 	ldr.w	sl, [pc, #320]	; 406c80 <xQueueGenericReceive+0x14c>
		taskEXIT_CRITICAL();

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
  406b40:	f8df 9140 	ldr.w	r9, [pc, #320]	; 406c84 <xQueueGenericReceive+0x150>
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
  406b44:	b087      	sub	sp, #28
  406b46:	4604      	mov	r4, r0
  406b48:	9203      	str	r2, [sp, #12]
  406b4a:	9101      	str	r1, [sp, #4]
  406b4c:	9302      	str	r3, [sp, #8]

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
  406b4e:	46b8      	mov	r8, r7
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
  406b50:	2600      	movs	r6, #0
  406b52:	e02a      	b.n	406baa <xQueueGenericReceive+0x76>
  406b54:	ae04      	add	r6, sp, #16
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
  406b56:	47b8      	blx	r7

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
  406b58:	47c8      	blx	r9
		prvLockQueue( pxQueue );
  406b5a:	47a8      	blx	r5
  406b5c:	6c63      	ldr	r3, [r4, #68]	; 0x44
  406b5e:	3301      	adds	r3, #1
  406b60:	bf04      	itt	eq
  406b62:	2300      	moveq	r3, #0
  406b64:	6463      	streq	r3, [r4, #68]	; 0x44
  406b66:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  406b68:	3301      	adds	r3, #1
  406b6a:	bf04      	itt	eq
  406b6c:	2300      	moveq	r3, #0
  406b6e:	64a3      	streq	r3, [r4, #72]	; 0x48
  406b70:	47b8      	blx	r7

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  406b72:	4630      	mov	r0, r6
  406b74:	a903      	add	r1, sp, #12
  406b76:	4b39      	ldr	r3, [pc, #228]	; (406c5c <xQueueGenericReceive+0x128>)
  406b78:	4798      	blx	r3
  406b7a:	2800      	cmp	r0, #0
  406b7c:	d14d      	bne.n	406c1a <xQueueGenericReceive+0xe6>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
  406b7e:	47a8      	blx	r5
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
  406b80:	f8d4 b038 	ldr.w	fp, [r4, #56]	; 0x38

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
  406b84:	4e34      	ldr	r6, [pc, #208]	; (406c58 <xQueueGenericReceive+0x124>)
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
	taskEXIT_CRITICAL();
  406b86:	47c0      	blx	r8
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
  406b88:	f1bb 0f00 	cmp.w	fp, #0
  406b8c:	d119      	bne.n	406bc2 <xQueueGenericReceive+0x8e>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  406b8e:	6823      	ldr	r3, [r4, #0]
  406b90:	b303      	cbz	r3, 406bd4 <xQueueGenericReceive+0xa0>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
  406b92:	f104 0024 	add.w	r0, r4, #36	; 0x24
  406b96:	9903      	ldr	r1, [sp, #12]
  406b98:	4b31      	ldr	r3, [pc, #196]	; (406c60 <xQueueGenericReceive+0x12c>)
  406b9a:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
  406b9c:	4b31      	ldr	r3, [pc, #196]	; (406c64 <xQueueGenericReceive+0x130>)
  406b9e:	4620      	mov	r0, r4
  406ba0:	4798      	blx	r3
				if( !xTaskResumeAll() )
  406ba2:	4b31      	ldr	r3, [pc, #196]	; (406c68 <xQueueGenericReceive+0x134>)
  406ba4:	4798      	blx	r3
  406ba6:	b190      	cbz	r0, 406bce <xQueueGenericReceive+0x9a>
  406ba8:	2601      	movs	r6, #1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
  406baa:	47a8      	blx	r5
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
  406bac:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  406bae:	b9bb      	cbnz	r3, 406be0 <xQueueGenericReceive+0xac>
				taskEXIT_CRITICAL();
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
  406bb0:	9803      	ldr	r0, [sp, #12]
  406bb2:	2800      	cmp	r0, #0
  406bb4:	d02b      	beq.n	406c0e <xQueueGenericReceive+0xda>
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
  406bb6:	2e00      	cmp	r6, #0
  406bb8:	d1cc      	bne.n	406b54 <xQueueGenericReceive+0x20>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
  406bba:	ae04      	add	r6, sp, #16
  406bbc:	4630      	mov	r0, r6
  406bbe:	47d0      	blx	sl
  406bc0:	e7c9      	b.n	406b56 <xQueueGenericReceive+0x22>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
  406bc2:	4620      	mov	r0, r4
  406bc4:	4b27      	ldr	r3, [pc, #156]	; (406c64 <xQueueGenericReceive+0x130>)
  406bc6:	4798      	blx	r3
				( void ) xTaskResumeAll();
  406bc8:	4b27      	ldr	r3, [pc, #156]	; (406c68 <xQueueGenericReceive+0x134>)
  406bca:	4798      	blx	r3
  406bcc:	e7ec      	b.n	406ba8 <xQueueGenericReceive+0x74>

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
				prvUnlockQueue( pxQueue );
				if( !xTaskResumeAll() )
				{
					portYIELD_WITHIN_API();
  406bce:	4b27      	ldr	r3, [pc, #156]	; (406c6c <xQueueGenericReceive+0x138>)
  406bd0:	4798      	blx	r3
  406bd2:	e7e9      	b.n	406ba8 <xQueueGenericReceive+0x74>

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
					{
						portENTER_CRITICAL();
  406bd4:	47b0      	blx	r6
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
  406bd6:	6860      	ldr	r0, [r4, #4]
  406bd8:	4b25      	ldr	r3, [pc, #148]	; (406c70 <xQueueGenericReceive+0x13c>)
  406bda:	4798      	blx	r3
						}
						portEXIT_CRITICAL();
  406bdc:	47c0      	blx	r8
  406bde:	e7d8      	b.n	406b92 <xQueueGenericReceive+0x5e>
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );
  406be0:	4b24      	ldr	r3, [pc, #144]	; (406c74 <xQueueGenericReceive+0x140>)
  406be2:	9901      	ldr	r1, [sp, #4]
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
  406be4:	68e5      	ldr	r5, [r4, #12]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
  406be6:	4620      	mov	r0, r4
  406be8:	4798      	blx	r3

				if( xJustPeeking == pdFALSE )
  406bea:	9b02      	ldr	r3, [sp, #8]
  406bec:	b9f3      	cbnz	r3, 406c2c <xQueueGenericReceive+0xf8>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
  406bee:	6ba2      	ldr	r2, [r4, #56]	; 0x38

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  406bf0:	6823      	ldr	r3, [r4, #0]
				if( xJustPeeking == pdFALSE )
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
  406bf2:	3a01      	subs	r2, #1
  406bf4:	63a2      	str	r2, [r4, #56]	; 0x38

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  406bf6:	b343      	cbz	r3, 406c4a <xQueueGenericReceive+0x116>
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  406bf8:	6923      	ldr	r3, [r4, #16]
  406bfa:	b1d3      	cbz	r3, 406c32 <xQueueGenericReceive+0xfe>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
  406bfc:	f104 0010 	add.w	r0, r4, #16
  406c00:	4b1d      	ldr	r3, [pc, #116]	; (406c78 <xQueueGenericReceive+0x144>)
  406c02:	4798      	blx	r3
  406c04:	2801      	cmp	r0, #1
  406c06:	d114      	bne.n	406c32 <xQueueGenericReceive+0xfe>
						{
							portYIELD_WITHIN_API();
  406c08:	4b18      	ldr	r3, [pc, #96]	; (406c6c <xQueueGenericReceive+0x138>)
  406c0a:	4798      	blx	r3
  406c0c:	e011      	b.n	406c32 <xQueueGenericReceive+0xfe>
			{
				if( xTicksToWait == ( portTickType ) 0 )
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
  406c0e:	9000      	str	r0, [sp, #0]
  406c10:	47b8      	blx	r7
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
  406c12:	9800      	ldr	r0, [sp, #0]
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
  406c14:	b007      	add	sp, #28
  406c16:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
  406c1a:	4620      	mov	r0, r4
  406c1c:	4b11      	ldr	r3, [pc, #68]	; (406c64 <xQueueGenericReceive+0x130>)
  406c1e:	4798      	blx	r3
			( void ) xTaskResumeAll();
  406c20:	4b11      	ldr	r3, [pc, #68]	; (406c68 <xQueueGenericReceive+0x134>)
  406c22:	4798      	blx	r3
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
  406c24:	2000      	movs	r0, #0
		}
	}
}
  406c26:	b007      	add	sp, #28
  406c28:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  406c2c:	6a63      	ldr	r3, [r4, #36]	; 0x24
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
  406c2e:	60e5      	str	r5, [r4, #12]

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  406c30:	b923      	cbnz	r3, 406c3c <xQueueGenericReceive+0x108>
						}
					}

				}

				taskEXIT_CRITICAL();
  406c32:	47b8      	blx	r7
				return pdPASS;
  406c34:	2001      	movs	r0, #1
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
  406c36:	b007      	add	sp, #28
  406c38:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  406c3c:	f104 0024 	add.w	r0, r4, #36	; 0x24
  406c40:	4b0d      	ldr	r3, [pc, #52]	; (406c78 <xQueueGenericReceive+0x144>)
  406c42:	4798      	blx	r3
  406c44:	2800      	cmp	r0, #0
  406c46:	d0f4      	beq.n	406c32 <xQueueGenericReceive+0xfe>
  406c48:	e7de      	b.n	406c08 <xQueueGenericReceive+0xd4>
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
  406c4a:	4b0c      	ldr	r3, [pc, #48]	; (406c7c <xQueueGenericReceive+0x148>)
  406c4c:	4798      	blx	r3
  406c4e:	6060      	str	r0, [r4, #4]
  406c50:	e7d2      	b.n	406bf8 <xQueueGenericReceive+0xc4>
  406c52:	bf00      	nop
  406c54:	004066fd 	.word	0x004066fd
  406c58:	004066e5 	.word	0x004066e5
  406c5c:	00407689 	.word	0x00407689
  406c60:	00407579 	.word	0x00407579
  406c64:	0040685d 	.word	0x0040685d
  406c68:	004071f9 	.word	0x004071f9
  406c6c:	004066d5 	.word	0x004066d5
  406c70:	00407765 	.word	0x00407765
  406c74:	00406835 	.word	0x00406835
  406c78:	00407601 	.word	0x00407601
  406c7c:	0040773d 	.word	0x0040773d
  406c80:	00407671 	.word	0x00407671
  406c84:	00407091 	.word	0x00407091

00406c88 <uxQueueMessagesWaiting>:
	return xReturn;
}
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
  406c88:	b510      	push	{r4, lr}
  406c8a:	4604      	mov	r4, r0
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
  406c8c:	4b03      	ldr	r3, [pc, #12]	; (406c9c <uxQueueMessagesWaiting+0x14>)
  406c8e:	4798      	blx	r3
		uxReturn = pxQueue->uxMessagesWaiting;
  406c90:	6ba4      	ldr	r4, [r4, #56]	; 0x38
	taskEXIT_CRITICAL();
  406c92:	4b03      	ldr	r3, [pc, #12]	; (406ca0 <uxQueueMessagesWaiting+0x18>)
  406c94:	4798      	blx	r3

	return uxReturn;
}
  406c96:	4620      	mov	r0, r4
  406c98:	bd10      	pop	{r4, pc}
  406c9a:	bf00      	nop
  406c9c:	004066e5 	.word	0x004066e5
  406ca0:	004066fd 	.word	0x004066fd

00406ca4 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if configUSE_TIMERS == 1

	void vQueueWaitForMessageRestricted( xQueueHandle pxQueue, portTickType xTicksToWait )
	{
  406ca4:	b538      	push	{r3, r4, r5, lr}
  406ca6:	4604      	mov	r4, r0
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
  406ca8:	4b0c      	ldr	r3, [pc, #48]	; (406cdc <vQueueWaitForMessageRestricted+0x38>)
/*-----------------------------------------------------------*/

#if configUSE_TIMERS == 1

	void vQueueWaitForMessageRestricted( xQueueHandle pxQueue, portTickType xTicksToWait )
	{
  406caa:	460d      	mov	r5, r1
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
  406cac:	4798      	blx	r3
  406cae:	6c63      	ldr	r3, [r4, #68]	; 0x44
  406cb0:	3301      	adds	r3, #1
  406cb2:	bf04      	itt	eq
  406cb4:	2300      	moveq	r3, #0
  406cb6:	6463      	streq	r3, [r4, #68]	; 0x44
  406cb8:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  406cba:	3301      	adds	r3, #1
  406cbc:	bf04      	itt	eq
  406cbe:	2300      	moveq	r3, #0
  406cc0:	64a3      	streq	r3, [r4, #72]	; 0x48
  406cc2:	4b07      	ldr	r3, [pc, #28]	; (406ce0 <vQueueWaitForMessageRestricted+0x3c>)
  406cc4:	4798      	blx	r3
		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0U )
  406cc6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  406cc8:	b923      	cbnz	r3, 406cd4 <vQueueWaitForMessageRestricted+0x30>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
  406cca:	4629      	mov	r1, r5
  406ccc:	f104 0024 	add.w	r0, r4, #36	; 0x24
  406cd0:	4b04      	ldr	r3, [pc, #16]	; (406ce4 <vQueueWaitForMessageRestricted+0x40>)
  406cd2:	4798      	blx	r3
		}
		prvUnlockQueue( pxQueue );
  406cd4:	4620      	mov	r0, r4
  406cd6:	4b04      	ldr	r3, [pc, #16]	; (406ce8 <vQueueWaitForMessageRestricted+0x44>)
  406cd8:	4798      	blx	r3
  406cda:	bd38      	pop	{r3, r4, r5, pc}
  406cdc:	004066e5 	.word	0x004066e5
  406ce0:	004066fd 	.word	0x004066fd
  406ce4:	004075c9 	.word	0x004075c9
  406ce8:	0040685d 	.word	0x0040685d

00406cec <prvListTaskWithinSingleList>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed char cStatus )
	{
  406cec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	volatile tskTCB *pxNextTCB, *pxFirstTCB;
	unsigned short usStackRemaining;

		/* Write the details of all the TCB's in pxList into the buffer. */
		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
  406cf0:	684b      	ldr	r3, [r1, #4]
  406cf2:	4f1e      	ldr	r7, [pc, #120]	; (406d6c <prvListTaskWithinSingleList+0x80>)
  406cf4:	685b      	ldr	r3, [r3, #4]
  406cf6:	604b      	str	r3, [r1, #4]
  406cf8:	f101 0608 	add.w	r6, r1, #8
  406cfc:	42b3      	cmp	r3, r6
  406cfe:	bf04      	itt	eq
  406d00:	685b      	ldreq	r3, [r3, #4]
  406d02:	604b      	streq	r3, [r1, #4]
  406d04:	f8d3 900c 	ldr.w	r9, [r3, #12]
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed char cStatus )
	{
  406d08:	b085      	sub	sp, #20
  406d0a:	4688      	mov	r8, r1
  406d0c:	4682      	mov	sl, r0
  406d0e:	4693      	mov	fp, r2

		/* Write the details of all the TCB's in pxList into the buffer. */
		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
		do
		{
			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
  406d10:	685b      	ldr	r3, [r3, #4]
  406d12:	f8c8 3004 	str.w	r3, [r8, #4]
  406d16:	429e      	cmp	r6, r3
  406d18:	bf04      	itt	eq
  406d1a:	6873      	ldreq	r3, [r6, #4]
  406d1c:	f8c8 3004 	streq.w	r3, [r8, #4]
  406d20:	68dd      	ldr	r5, [r3, #12]
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxEndOfStack );
			}
			#else
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
  406d22:	6b2b      	ldr	r3, [r5, #48]	; 0x30

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
  406d24:	781a      	ldrb	r2, [r3, #0]
  406d26:	2aa5      	cmp	r2, #165	; 0xa5

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0;
  406d28:	f04f 0400 	mov.w	r4, #0

		while( *pucStackByte == tskSTACK_FILL_BYTE )
  406d2c:	d106      	bne.n	406d3c <prvListTaskWithinSingleList+0x50>
  406d2e:	f813 2f01 	ldrb.w	r2, [r3, #1]!
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
  406d32:	3401      	adds	r4, #1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
  406d34:	2aa5      	cmp	r2, #165	; 0xa5
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
  406d36:	b2a4      	uxth	r4, r4

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
  406d38:	d0f9      	beq.n	406d2e <prvListTaskWithinSingleList+0x42>
  406d3a:	08a4      	lsrs	r4, r4, #2
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
			}
			#endif

			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, ( unsigned int ) pxNextTCB->uxPriority, usStackRemaining, ( unsigned int ) pxNextTCB->uxTCBNumber );
  406d3c:	6aea      	ldr	r2, [r5, #44]	; 0x2c
  406d3e:	6c6b      	ldr	r3, [r5, #68]	; 0x44
  406d40:	9302      	str	r3, [sp, #8]
  406d42:	e88d 0014 	stmia.w	sp, {r2, r4}
  406d46:	490a      	ldr	r1, [pc, #40]	; (406d70 <prvListTaskWithinSingleList+0x84>)
  406d48:	480a      	ldr	r0, [pc, #40]	; (406d74 <prvListTaskWithinSingleList+0x88>)
  406d4a:	4c0b      	ldr	r4, [pc, #44]	; (406d78 <prvListTaskWithinSingleList+0x8c>)
  406d4c:	f105 0234 	add.w	r2, r5, #52	; 0x34
  406d50:	465b      	mov	r3, fp
  406d52:	47a0      	blx	r4
			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
  406d54:	4650      	mov	r0, sl
  406d56:	4907      	ldr	r1, [pc, #28]	; (406d74 <prvListTaskWithinSingleList+0x88>)
  406d58:	47b8      	blx	r7

		} while( pxNextTCB != pxFirstTCB );
  406d5a:	454d      	cmp	r5, r9
  406d5c:	d002      	beq.n	406d64 <prvListTaskWithinSingleList+0x78>
  406d5e:	f8d8 3004 	ldr.w	r3, [r8, #4]
  406d62:	e7d5      	b.n	406d10 <prvListTaskWithinSingleList+0x24>
	}
  406d64:	b005      	add	sp, #20
  406d66:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  406d6a:	bf00      	nop
  406d6c:	0040c681 	.word	0x0040c681
  406d70:	00416598 	.word	0x00416598
  406d74:	200034bc 	.word	0x200034bc
  406d78:	0040c555 	.word	0x0040c555

00406d7c <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
  406d7c:	b510      	push	{r4, lr}
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
  406d7e:	4b0d      	ldr	r3, [pc, #52]	; (406db4 <prvAddCurrentTaskToDelayedList+0x38>)

	if( xTimeToWake < xTickCount )
  406d80:	4a0d      	ldr	r2, [pc, #52]	; (406db8 <prvAddCurrentTaskToDelayedList+0x3c>)
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
  406d82:	6819      	ldr	r1, [r3, #0]

	if( xTimeToWake < xTickCount )
  406d84:	6812      	ldr	r2, [r2, #0]
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
  406d86:	6048      	str	r0, [r1, #4]

	if( xTimeToWake < xTickCount )
  406d88:	4290      	cmp	r0, r2
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
  406d8a:	4604      	mov	r4, r0
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
  406d8c:	d30b      	bcc.n	406da6 <prvAddCurrentTaskToDelayedList+0x2a>
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  406d8e:	490b      	ldr	r1, [pc, #44]	; (406dbc <prvAddCurrentTaskToDelayedList+0x40>)
  406d90:	4a0b      	ldr	r2, [pc, #44]	; (406dc0 <prvAddCurrentTaskToDelayedList+0x44>)
  406d92:	6808      	ldr	r0, [r1, #0]
  406d94:	6819      	ldr	r1, [r3, #0]
  406d96:	3104      	adds	r1, #4
  406d98:	4790      	blx	r2

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
  406d9a:	4b0a      	ldr	r3, [pc, #40]	; (406dc4 <prvAddCurrentTaskToDelayedList+0x48>)
  406d9c:	681a      	ldr	r2, [r3, #0]
  406d9e:	4294      	cmp	r4, r2
		{
			xNextTaskUnblockTime = xTimeToWake;
  406da0:	bf38      	it	cc
  406da2:	601c      	strcc	r4, [r3, #0]
  406da4:	bd10      	pop	{r4, pc}
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  406da6:	4908      	ldr	r1, [pc, #32]	; (406dc8 <prvAddCurrentTaskToDelayedList+0x4c>)
  406da8:	4a05      	ldr	r2, [pc, #20]	; (406dc0 <prvAddCurrentTaskToDelayedList+0x44>)
  406daa:	6808      	ldr	r0, [r1, #0]
  406dac:	6819      	ldr	r1, [r3, #0]
  406dae:	3104      	adds	r1, #4
  406db0:	4790      	blx	r2
  406db2:	bd10      	pop	{r4, pc}
  406db4:	200034b8 	.word	0x200034b8
  406db8:	200033cc 	.word	0x200033cc
  406dbc:	2000348c 	.word	0x2000348c
  406dc0:	004065dd 	.word	0x004065dd
  406dc4:	20000138 	.word	0x20000138
  406dc8:	20003470 	.word	0x20003470

00406dcc <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
  406dcc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  406dd0:	b083      	sub	sp, #12
  406dd2:	4681      	mov	r9, r0
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
  406dd4:	f8df 81c4 	ldr.w	r8, [pc, #452]	; 406f9c <xTaskGenericCreate+0x1d0>
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
  406dd8:	9e0d      	ldr	r6, [sp, #52]	; 0x34
  406dda:	9c0e      	ldr	r4, [sp, #56]	; 0x38
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
  406ddc:	204c      	movs	r0, #76	; 0x4c
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
  406dde:	468a      	mov	sl, r1
  406de0:	4615      	mov	r5, r2
  406de2:	469b      	mov	fp, r3
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
  406de4:	47c0      	blx	r8

	if( pxNewTCB != NULL )
  406de6:	4607      	mov	r7, r0
  406de8:	2800      	cmp	r0, #0
  406dea:	f000 8087 	beq.w	406efc <xTaskGenericCreate+0x130>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
  406dee:	2c00      	cmp	r4, #0
  406df0:	d079      	beq.n	406ee6 <xTaskGenericCreate+0x11a>
  406df2:	6304      	str	r4, [r0, #48]	; 0x30
  406df4:	00aa      	lsls	r2, r5, #2
  406df6:	4620      	mov	r0, r4
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
  406df8:	21a5      	movs	r1, #165	; 0xa5
  406dfa:	4b53      	ldr	r3, [pc, #332]	; (406f48 <xTaskGenericCreate+0x17c>)
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
  406dfc:	4c53      	ldr	r4, [pc, #332]	; (406f4c <xTaskGenericCreate+0x180>)
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
  406dfe:	4798      	blx	r3
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
  406e00:	f105 4580 	add.w	r5, r5, #1073741824	; 0x40000000
  406e04:	6b38      	ldr	r0, [r7, #48]	; 0x30
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
  406e06:	4b52      	ldr	r3, [pc, #328]	; (406f50 <xTaskGenericCreate+0x184>)
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
  406e08:	3d01      	subs	r5, #1
  406e0a:	eb00 0585 	add.w	r5, r0, r5, lsl #2
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
  406e0e:	4651      	mov	r1, sl
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
  406e10:	f025 0a07 	bic.w	sl, r5, #7
  406e14:	9d0c      	ldr	r5, [sp, #48]	; 0x30
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
  406e16:	2210      	movs	r2, #16
  406e18:	f107 0034 	add.w	r0, r7, #52	; 0x34
  406e1c:	4798      	blx	r3
  406e1e:	2d07      	cmp	r5, #7
  406e20:	bf28      	it	cs
  406e22:	2507      	movcs	r5, #7
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
  406e24:	2200      	movs	r2, #0
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
  406e26:	f107 0804 	add.w	r8, r7, #4
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
  406e2a:	f887 2043 	strb.w	r2, [r7, #67]	; 0x43
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
  406e2e:	62fd      	str	r5, [r7, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
  406e30:	64bd      	str	r5, [r7, #72]	; 0x48
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
  406e32:	4640      	mov	r0, r8
  406e34:	47a0      	blx	r4
	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
  406e36:	f1c5 0508 	rsb	r5, r5, #8
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
  406e3a:	f107 0018 	add.w	r0, r7, #24
  406e3e:	47a0      	blx	r4
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
  406e40:	4650      	mov	r0, sl
	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
  406e42:	61bd      	str	r5, [r7, #24]
	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
	vListInitialiseItem( &( pxTCB->xEventListItem ) );

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
  406e44:	613f      	str	r7, [r7, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
  406e46:	627f      	str	r7, [r7, #36]	; 0x24
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
  406e48:	4649      	mov	r1, r9
  406e4a:	465a      	mov	r2, fp
  406e4c:	4c41      	ldr	r4, [pc, #260]	; (406f54 <xTaskGenericCreate+0x188>)
  406e4e:	47a0      	blx	r4
  406e50:	6038      	str	r0, [r7, #0]
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
  406e52:	b106      	cbz	r6, 406e56 <xTaskGenericCreate+0x8a>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
  406e54:	6037      	str	r7, [r6, #0]
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
  406e56:	4a40      	ldr	r2, [pc, #256]	; (406f58 <xTaskGenericCreate+0x18c>)
		{
			uxCurrentNumberOfTasks++;
			if( pxCurrentTCB == NULL )
  406e58:	4c40      	ldr	r4, [pc, #256]	; (406f5c <xTaskGenericCreate+0x190>)
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
  406e5a:	4790      	blx	r2
		{
			uxCurrentNumberOfTasks++;
  406e5c:	4a40      	ldr	r2, [pc, #256]	; (406f60 <xTaskGenericCreate+0x194>)
  406e5e:	6811      	ldr	r1, [r2, #0]
  406e60:	3101      	adds	r1, #1
  406e62:	6011      	str	r1, [r2, #0]
			if( pxCurrentTCB == NULL )
  406e64:	6821      	ldr	r1, [r4, #0]
  406e66:	2900      	cmp	r1, #0
  406e68:	d035      	beq.n	406ed6 <xTaskGenericCreate+0x10a>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
  406e6a:	4e3e      	ldr	r6, [pc, #248]	; (406f64 <xTaskGenericCreate+0x198>)
  406e6c:	6832      	ldr	r2, [r6, #0]
  406e6e:	b32a      	cbz	r2, 406ebc <xTaskGenericCreate+0xf0>
  406e70:	f8df 912c 	ldr.w	r9, [pc, #300]	; 406fa0 <xTaskGenericCreate+0x1d4>
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
  406e74:	493c      	ldr	r1, [pc, #240]	; (406f68 <xTaskGenericCreate+0x19c>)
  406e76:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  406e78:	680d      	ldr	r5, [r1, #0]
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );
  406e7a:	483c      	ldr	r0, [pc, #240]	; (406f6c <xTaskGenericCreate+0x1a0>)
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
  406e7c:	42aa      	cmp	r2, r5
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
  406e7e:	bf88      	it	hi
  406e80:	600a      	strhi	r2, [r1, #0]
			}

			#if ( configUSE_TRACE_FACILITY == 1 )
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
  406e82:	493b      	ldr	r1, [pc, #236]	; (406f70 <xTaskGenericCreate+0x1a4>)
			}
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );
  406e84:	6803      	ldr	r3, [r0, #0]
			}

			#if ( configUSE_TRACE_FACILITY == 1 )
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
  406e86:	680d      	ldr	r5, [r1, #0]
  406e88:	647d      	str	r5, [r7, #68]	; 0x44
			}
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );
  406e8a:	429a      	cmp	r2, r3
  406e8c:	bf88      	it	hi
  406e8e:	6002      	strhi	r2, [r0, #0]
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
  406e90:	3501      	adds	r5, #1

			prvAddTaskToReadyQueue( pxNewTCB );
  406e92:	eb02 0082 	add.w	r0, r2, r2, lsl #2
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
  406e96:	600d      	str	r5, [r1, #0]

			prvAddTaskToReadyQueue( pxNewTCB );
  406e98:	eb09 0080 	add.w	r0, r9, r0, lsl #2
  406e9c:	4641      	mov	r1, r8
  406e9e:	4b35      	ldr	r3, [pc, #212]	; (406f74 <xTaskGenericCreate+0x1a8>)
  406ea0:	4798      	blx	r3

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
  406ea2:	4b35      	ldr	r3, [pc, #212]	; (406f78 <xTaskGenericCreate+0x1ac>)
  406ea4:	4798      	blx	r3
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
  406ea6:	6833      	ldr	r3, [r6, #0]
  406ea8:	b123      	cbz	r3, 406eb4 <xTaskGenericCreate+0xe8>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
  406eaa:	6823      	ldr	r3, [r4, #0]
  406eac:	9a0c      	ldr	r2, [sp, #48]	; 0x30
  406eae:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  406eb0:	429a      	cmp	r2, r3
  406eb2:	d80c      	bhi.n	406ece <xTaskGenericCreate+0x102>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
  406eb4:	2001      	movs	r0, #1
			}
		}
	}

	return xReturn;
}
  406eb6:	b003      	add	sp, #12
  406eb8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
  406ebc:	6822      	ldr	r2, [r4, #0]
  406ebe:	980c      	ldr	r0, [sp, #48]	; 0x30
  406ec0:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
  406ec2:	f8df 90dc 	ldr.w	r9, [pc, #220]	; 406fa0 <xTaskGenericCreate+0x1d4>
  406ec6:	4290      	cmp	r0, r2
					{
						pxCurrentTCB = pxNewTCB;
  406ec8:	bf28      	it	cs
  406eca:	6027      	strcs	r7, [r4, #0]
  406ecc:	e7d2      	b.n	406e74 <xTaskGenericCreate+0xa8>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
			{
				portYIELD_WITHIN_API();
  406ece:	4b2b      	ldr	r3, [pc, #172]	; (406f7c <xTaskGenericCreate+0x1b0>)
  406ed0:	4798      	blx	r3
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
  406ed2:	2001      	movs	r0, #1
  406ed4:	e7ef      	b.n	406eb6 <xTaskGenericCreate+0xea>
			uxCurrentNumberOfTasks++;
			if( pxCurrentTCB == NULL )
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
  406ed6:	6027      	str	r7, [r4, #0]

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
  406ed8:	6812      	ldr	r2, [r2, #0]
  406eda:	f8df 90c4 	ldr.w	r9, [pc, #196]	; 406fa0 <xTaskGenericCreate+0x1d4>
  406ede:	2a01      	cmp	r2, #1
  406ee0:	d011      	beq.n	406f06 <xTaskGenericCreate+0x13a>
  406ee2:	4e20      	ldr	r6, [pc, #128]	; (406f64 <xTaskGenericCreate+0x198>)
  406ee4:	e7c6      	b.n	406e74 <xTaskGenericCreate+0xa8>
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
  406ee6:	00aa      	lsls	r2, r5, #2
  406ee8:	4610      	mov	r0, r2
  406eea:	9201      	str	r2, [sp, #4]
  406eec:	47c0      	blx	r8
  406eee:	6338      	str	r0, [r7, #48]	; 0x30

		if( pxNewTCB->pxStack == NULL )
  406ef0:	9a01      	ldr	r2, [sp, #4]
  406ef2:	2800      	cmp	r0, #0
  406ef4:	d180      	bne.n	406df8 <xTaskGenericCreate+0x2c>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
  406ef6:	4638      	mov	r0, r7
  406ef8:	4b21      	ldr	r3, [pc, #132]	; (406f80 <xTaskGenericCreate+0x1b4>)
  406efa:	4798      	blx	r3
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
  406efc:	f04f 30ff 	mov.w	r0, #4294967295
			}
		}
	}

	return xReturn;
}
  406f00:	b003      	add	sp, #12
  406f02:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  406f06:	f8df a09c 	ldr.w	sl, [pc, #156]	; 406fa4 <xTaskGenericCreate+0x1d8>
  406f0a:	464d      	mov	r5, r9
  406f0c:	f109 06a0 	add.w	r6, r9, #160	; 0xa0
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
  406f10:	4628      	mov	r0, r5
  406f12:	3514      	adds	r5, #20
  406f14:	47d0      	blx	sl

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
  406f16:	42b5      	cmp	r5, r6
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
  406f18:	f8df b088 	ldr.w	fp, [pc, #136]	; 406fa4 <xTaskGenericCreate+0x1d8>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
  406f1c:	d1f8      	bne.n	406f10 <xTaskGenericCreate+0x144>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
  406f1e:	f8df a088 	ldr.w	sl, [pc, #136]	; 406fa8 <xTaskGenericCreate+0x1dc>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
  406f22:	4d18      	ldr	r5, [pc, #96]	; (406f84 <xTaskGenericCreate+0x1b8>)
  406f24:	4e0f      	ldr	r6, [pc, #60]	; (406f64 <xTaskGenericCreate+0x198>)
	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
  406f26:	4650      	mov	r0, sl
  406f28:	47d8      	blx	fp
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
  406f2a:	4628      	mov	r0, r5
  406f2c:	47d8      	blx	fp
	vListInitialise( ( xList * ) &xPendingReadyList );
  406f2e:	4816      	ldr	r0, [pc, #88]	; (406f88 <xTaskGenericCreate+0x1bc>)
  406f30:	47d8      	blx	fp

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
  406f32:	4816      	ldr	r0, [pc, #88]	; (406f8c <xTaskGenericCreate+0x1c0>)
  406f34:	47d8      	blx	fp
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
  406f36:	4816      	ldr	r0, [pc, #88]	; (406f90 <xTaskGenericCreate+0x1c4>)
  406f38:	47d8      	blx	fp
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
  406f3a:	4916      	ldr	r1, [pc, #88]	; (406f94 <xTaskGenericCreate+0x1c8>)
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
  406f3c:	4a16      	ldr	r2, [pc, #88]	; (406f98 <xTaskGenericCreate+0x1cc>)
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
  406f3e:	f8c1 a000 	str.w	sl, [r1]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
  406f42:	6015      	str	r5, [r2, #0]
  406f44:	e796      	b.n	406e74 <xTaskGenericCreate+0xa8>
  406f46:	bf00      	nop
  406f48:	0040c31d 	.word	0x0040c31d
  406f4c:	004065b9 	.word	0x004065b9
  406f50:	0040cb1d 	.word	0x0040cb1d
  406f54:	0040663d 	.word	0x0040663d
  406f58:	004066e5 	.word	0x004066e5
  406f5c:	200034b8 	.word	0x200034b8
  406f60:	20003490 	.word	0x20003490
  406f64:	200034a8 	.word	0x200034a8
  406f68:	2000353c 	.word	0x2000353c
  406f6c:	200033c4 	.word	0x200033c4
  406f70:	200034b0 	.word	0x200034b0
  406f74:	004065c1 	.word	0x004065c1
  406f78:	004066fd 	.word	0x004066fd
  406f7c:	004066d5 	.word	0x004066d5
  406f80:	0040679d 	.word	0x0040679d
  406f84:	20003518 	.word	0x20003518
  406f88:	20003494 	.word	0x20003494
  406f8c:	20003474 	.word	0x20003474
  406f90:	200034f0 	.word	0x200034f0
  406f94:	2000348c 	.word	0x2000348c
  406f98:	20003470 	.word	0x20003470
  406f9c:	00406779 	.word	0x00406779
  406fa0:	200033d0 	.word	0x200033d0
  406fa4:	004065a1 	.word	0x004065a1
  406fa8:	20003504 	.word	0x20003504

00406fac <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
  406fac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
  406fae:	4b15      	ldr	r3, [pc, #84]	; (407004 <vTaskDelete+0x58>)
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
  406fb0:	4604      	mov	r4, r0
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
  406fb2:	4798      	blx	r3
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
  406fb4:	4b14      	ldr	r3, [pc, #80]	; (407008 <vTaskDelete+0x5c>)
  406fb6:	681a      	ldr	r2, [r3, #0]
  406fb8:	4294      	cmp	r4, r2
  406fba:	d01d      	beq.n	406ff8 <vTaskDelete+0x4c>
  406fbc:	4627      	mov	r7, r4
			{
				pxTaskToDelete = NULL;
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
  406fbe:	b1dc      	cbz	r4, 406ff8 <vTaskDelete+0x4c>

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
  406fc0:	1d25      	adds	r5, r4, #4
  406fc2:	4628      	mov	r0, r5
  406fc4:	4e11      	ldr	r6, [pc, #68]	; (40700c <vTaskDelete+0x60>)
  406fc6:	47b0      	blx	r6

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer )
  406fc8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  406fca:	b113      	cbz	r3, 406fd2 <vTaskDelete+0x26>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
  406fcc:	f104 0018 	add.w	r0, r4, #24
  406fd0:	47b0      	blx	r6
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
  406fd2:	4629      	mov	r1, r5
  406fd4:	480e      	ldr	r0, [pc, #56]	; (407010 <vTaskDelete+0x64>)
  406fd6:	4b0f      	ldr	r3, [pc, #60]	; (407014 <vTaskDelete+0x68>)
  406fd8:	4798      	blx	r3
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
  406fda:	4b0f      	ldr	r3, [pc, #60]	; (407018 <vTaskDelete+0x6c>)
			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
  406fdc:	4a0f      	ldr	r2, [pc, #60]	; (40701c <vTaskDelete+0x70>)

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
  406fde:	6819      	ldr	r1, [r3, #0]
			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
  406fe0:	6814      	ldr	r4, [r2, #0]
			can detect that the task lists need re-generating. */
			uxTaskNumber++;

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
  406fe2:	480f      	ldr	r0, [pc, #60]	; (407020 <vTaskDelete+0x74>)
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
  406fe4:	3101      	adds	r1, #1
			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
  406fe6:	3401      	adds	r4, #1

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
  406fe8:	6019      	str	r1, [r3, #0]
			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
  406fea:	6014      	str	r4, [r2, #0]
			can detect that the task lists need re-generating. */
			uxTaskNumber++;

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
  406fec:	4780      	blx	r0

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
  406fee:	4b0d      	ldr	r3, [pc, #52]	; (407024 <vTaskDelete+0x78>)
  406ff0:	681b      	ldr	r3, [r3, #0]
  406ff2:	b103      	cbz	r3, 406ff6 <vTaskDelete+0x4a>
		{
			if( ( void * ) pxTaskToDelete == NULL )
  406ff4:	b11f      	cbz	r7, 406ffe <vTaskDelete+0x52>
  406ff6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			{
				pxTaskToDelete = NULL;
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
  406ff8:	681c      	ldr	r4, [r3, #0]
  406ffa:	2700      	movs	r7, #0
  406ffc:	e7e0      	b.n	406fc0 <vTaskDelete+0x14>
		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
		{
			if( ( void * ) pxTaskToDelete == NULL )
			{
				portYIELD_WITHIN_API();
  406ffe:	4b0a      	ldr	r3, [pc, #40]	; (407028 <vTaskDelete+0x7c>)
  407000:	4798      	blx	r3
  407002:	e7f8      	b.n	406ff6 <vTaskDelete+0x4a>
  407004:	004066e5 	.word	0x004066e5
  407008:	200034b8 	.word	0x200034b8
  40700c:	00406619 	.word	0x00406619
  407010:	20003474 	.word	0x20003474
  407014:	004065c1 	.word	0x004065c1
  407018:	200034b0 	.word	0x200034b0
  40701c:	200033c8 	.word	0x200033c8
  407020:	004066fd 	.word	0x004066fd
  407024:	200034a8 	.word	0x200034a8
  407028:	004066d5 	.word	0x004066d5

0040702c <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
  40702c:	b530      	push	{r4, r5, lr}
  40702e:	b085      	sub	sp, #20
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
  407030:	2400      	movs	r4, #0
  407032:	9400      	str	r4, [sp, #0]
  407034:	9401      	str	r4, [sp, #4]
  407036:	9402      	str	r4, [sp, #8]
  407038:	9403      	str	r4, [sp, #12]
  40703a:	4623      	mov	r3, r4
  40703c:	480d      	ldr	r0, [pc, #52]	; (407074 <vTaskStartScheduler+0x48>)
  40703e:	490e      	ldr	r1, [pc, #56]	; (407078 <vTaskStartScheduler+0x4c>)
  407040:	4d0e      	ldr	r5, [pc, #56]	; (40707c <vTaskStartScheduler+0x50>)
  407042:	f44f 7280 	mov.w	r2, #256	; 0x100
  407046:	47a8      	blx	r5

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
  407048:	2801      	cmp	r0, #1
  40704a:	d001      	beq.n	407050 <vTaskStartScheduler+0x24>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
  40704c:	b005      	add	sp, #20
  40704e:	bd30      	pop	{r4, r5, pc}

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
		{
			xReturn = xTimerCreateTimerTask();
  407050:	4b0b      	ldr	r3, [pc, #44]	; (407080 <vTaskStartScheduler+0x54>)
  407052:	4798      	blx	r3
		}
	}
	#endif

	if( xReturn == pdPASS )
  407054:	2801      	cmp	r0, #1

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
		{
			xReturn = xTimerCreateTimerTask();
  407056:	4603      	mov	r3, r0
		}
	}
	#endif

	if( xReturn == pdPASS )
  407058:	d1f8      	bne.n	40704c <vTaskStartScheduler+0x20>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
  40705a:	f04f 0000 	mov.w	r0, #0
  40705e:	f380 8811 	msr	BASEPRI, r0

		xSchedulerRunning = pdTRUE;
		xTickCount = ( portTickType ) 0;
  407062:	4908      	ldr	r1, [pc, #32]	; (407084 <vTaskStartScheduler+0x58>)

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();

		xSchedulerRunning = pdTRUE;
  407064:	4808      	ldr	r0, [pc, #32]	; (407088 <vTaskStartScheduler+0x5c>)
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
  407066:	4a09      	ldr	r2, [pc, #36]	; (40708c <vTaskStartScheduler+0x60>)

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();

		xSchedulerRunning = pdTRUE;
  407068:	6003      	str	r3, [r0, #0]
		xTickCount = ( portTickType ) 0;
  40706a:	600c      	str	r4, [r1, #0]
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
  40706c:	4790      	blx	r2
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
  40706e:	b005      	add	sp, #20
  407070:	bd30      	pop	{r4, r5, pc}
  407072:	bf00      	nop
  407074:	0040733d 	.word	0x0040733d
  407078:	004165ac 	.word	0x004165ac
  40707c:	00406dcd 	.word	0x00406dcd
  407080:	004078bd 	.word	0x004078bd
  407084:	200033cc 	.word	0x200033cc
  407088:	200034a8 	.word	0x200034a8
  40708c:	0040668d 	.word	0x0040668d

00407090 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
  407090:	4b02      	ldr	r3, [pc, #8]	; (40709c <vTaskSuspendAll+0xc>)
  407092:	681a      	ldr	r2, [r3, #0]
  407094:	3201      	adds	r2, #1
  407096:	601a      	str	r2, [r3, #0]
  407098:	4770      	bx	lr
  40709a:	bf00      	nop
  40709c:	2000352c 	.word	0x2000352c

004070a0 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
  4070a0:	b510      	push	{r4, lr}
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
  4070a2:	4b04      	ldr	r3, [pc, #16]	; (4070b4 <xTaskGetTickCount+0x14>)
  4070a4:	4798      	blx	r3
	{
		xTicks = xTickCount;
  4070a6:	4a04      	ldr	r2, [pc, #16]	; (4070b8 <xTaskGetTickCount+0x18>)
	}
	taskEXIT_CRITICAL();
  4070a8:	4b04      	ldr	r3, [pc, #16]	; (4070bc <xTaskGetTickCount+0x1c>)
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
	{
		xTicks = xTickCount;
  4070aa:	6814      	ldr	r4, [r2, #0]
	}
	taskEXIT_CRITICAL();
  4070ac:	4798      	blx	r3

	return xTicks;
}
  4070ae:	4620      	mov	r0, r4
  4070b0:	bd10      	pop	{r4, pc}
  4070b2:	bf00      	nop
  4070b4:	004066e5 	.word	0x004066e5
  4070b8:	200033cc 	.word	0x200033cc
  4070bc:	004066fd 	.word	0x004066fd

004070c0 <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
  4070c0:	4b01      	ldr	r3, [pc, #4]	; (4070c8 <uxTaskGetNumberOfTasks+0x8>)
  4070c2:	6818      	ldr	r0, [r3, #0]
}
  4070c4:	4770      	bx	lr
  4070c6:	bf00      	nop
  4070c8:	20003490 	.word	0x20003490

004070cc <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
  4070cc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  4070d0:	4b3e      	ldr	r3, [pc, #248]	; (4071cc <vTaskIncrementTick+0x100>)
  4070d2:	681b      	ldr	r3, [r3, #0]
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
  4070d4:	b083      	sub	sp, #12
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  4070d6:	2b00      	cmp	r3, #0
  4070d8:	d150      	bne.n	40717c <vTaskIncrementTick+0xb0>
	{
		++xTickCount;
  4070da:	4c3d      	ldr	r4, [pc, #244]	; (4071d0 <vTaskIncrementTick+0x104>)
  4070dc:	6823      	ldr	r3, [r4, #0]
  4070de:	3301      	adds	r3, #1
  4070e0:	6023      	str	r3, [r4, #0]
		if( xTickCount == ( portTickType ) 0 )
  4070e2:	6823      	ldr	r3, [r4, #0]
  4070e4:	2b00      	cmp	r3, #0
  4070e6:	d050      	beq.n	40718a <vTaskIncrementTick+0xbe>
  4070e8:	4a3a      	ldr	r2, [pc, #232]	; (4071d4 <vTaskIncrementTick+0x108>)
  4070ea:	9201      	str	r2, [sp, #4]
  4070ec:	6813      	ldr	r3, [r2, #0]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
  4070ee:	6822      	ldr	r2, [r4, #0]
  4070f0:	4937      	ldr	r1, [pc, #220]	; (4071d0 <vTaskIncrementTick+0x104>)
  4070f2:	429a      	cmp	r2, r3
  4070f4:	d346      	bcc.n	407184 <vTaskIncrementTick+0xb8>
  4070f6:	4d38      	ldr	r5, [pc, #224]	; (4071d8 <vTaskIncrementTick+0x10c>)
  4070f8:	682b      	ldr	r3, [r5, #0]
  4070fa:	681b      	ldr	r3, [r3, #0]
  4070fc:	2b00      	cmp	r3, #0
  4070fe:	d036      	beq.n	40716e <vTaskIncrementTick+0xa2>
  407100:	682b      	ldr	r3, [r5, #0]
  407102:	68db      	ldr	r3, [r3, #12]
  407104:	f8d3 b00c 	ldr.w	fp, [r3, #12]
  407108:	6809      	ldr	r1, [r1, #0]
  40710a:	f8db 2004 	ldr.w	r2, [fp, #4]
  40710e:	428a      	cmp	r2, r1
  407110:	d857      	bhi.n	4071c2 <vTaskIncrementTick+0xf6>
  407112:	4f32      	ldr	r7, [pc, #200]	; (4071dc <vTaskIncrementTick+0x110>)
  407114:	4e32      	ldr	r6, [pc, #200]	; (4071e0 <vTaskIncrementTick+0x114>)
  407116:	f8df 90d8 	ldr.w	r9, [pc, #216]	; 4071f0 <vTaskIncrementTick+0x124>
  40711a:	f8df 80d8 	ldr.w	r8, [pc, #216]	; 4071f4 <vTaskIncrementTick+0x128>
  40711e:	e009      	b.n	407134 <vTaskIncrementTick+0x68>
  407120:	4a2d      	ldr	r2, [pc, #180]	; (4071d8 <vTaskIncrementTick+0x10c>)
  407122:	6813      	ldr	r3, [r2, #0]
  407124:	68db      	ldr	r3, [r3, #12]
  407126:	f8d3 b00c 	ldr.w	fp, [r3, #12]
  40712a:	6821      	ldr	r1, [r4, #0]
  40712c:	f8db 2004 	ldr.w	r2, [fp, #4]
  407130:	428a      	cmp	r2, r1
  407132:	d846      	bhi.n	4071c2 <vTaskIncrementTick+0xf6>
  407134:	f10b 0a04 	add.w	sl, fp, #4
  407138:	4650      	mov	r0, sl
  40713a:	47b8      	blx	r7
  40713c:	f8db 2028 	ldr.w	r2, [fp, #40]	; 0x28
  407140:	f10b 0018 	add.w	r0, fp, #24
  407144:	b10a      	cbz	r2, 40714a <vTaskIncrementTick+0x7e>
  407146:	4a25      	ldr	r2, [pc, #148]	; (4071dc <vTaskIncrementTick+0x110>)
  407148:	4790      	blx	r2
  40714a:	f8db 302c 	ldr.w	r3, [fp, #44]	; 0x2c
  40714e:	6832      	ldr	r2, [r6, #0]
  407150:	4293      	cmp	r3, r2
  407152:	eb03 0083 	add.w	r0, r3, r3, lsl #2
  407156:	bf88      	it	hi
  407158:	4a21      	ldrhi	r2, [pc, #132]	; (4071e0 <vTaskIncrementTick+0x114>)
  40715a:	eb09 0080 	add.w	r0, r9, r0, lsl #2
  40715e:	4651      	mov	r1, sl
  407160:	bf88      	it	hi
  407162:	6013      	strhi	r3, [r2, #0]
  407164:	47c0      	blx	r8
  407166:	682b      	ldr	r3, [r5, #0]
  407168:	681b      	ldr	r3, [r3, #0]
  40716a:	2b00      	cmp	r3, #0
  40716c:	d1d8      	bne.n	407120 <vTaskIncrementTick+0x54>
  40716e:	9a01      	ldr	r2, [sp, #4]
  407170:	f04f 33ff 	mov.w	r3, #4294967295
  407174:	6013      	str	r3, [r2, #0]
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
  407176:	b003      	add	sp, #12
  407178:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
	}
	else
	{
		++uxMissedTicks;
  40717c:	4b19      	ldr	r3, [pc, #100]	; (4071e4 <vTaskIncrementTick+0x118>)
  40717e:	681a      	ldr	r2, [r3, #0]
  407180:	3201      	adds	r2, #1
  407182:	601a      	str	r2, [r3, #0]
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
  407184:	b003      	add	sp, #12
  407186:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
  40718a:	4b13      	ldr	r3, [pc, #76]	; (4071d8 <vTaskIncrementTick+0x10c>)
			pxDelayedTaskList = pxOverflowDelayedTaskList;
  40718c:	4916      	ldr	r1, [pc, #88]	; (4071e8 <vTaskIncrementTick+0x11c>)
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
  40718e:	6818      	ldr	r0, [r3, #0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
			pxOverflowDelayedTaskList = pxTemp;
			xNumOfOverflows++;
  407190:	4a16      	ldr	r2, [pc, #88]	; (4071ec <vTaskIncrementTick+0x120>)
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
			pxDelayedTaskList = pxOverflowDelayedTaskList;
  407192:	680d      	ldr	r5, [r1, #0]
  407194:	601d      	str	r5, [r3, #0]
			pxOverflowDelayedTaskList = pxTemp;
  407196:	6008      	str	r0, [r1, #0]
			xNumOfOverflows++;
  407198:	6811      	ldr	r1, [r2, #0]
  40719a:	3101      	adds	r1, #1
  40719c:	6011      	str	r1, [r2, #0]

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  40719e:	681a      	ldr	r2, [r3, #0]
  4071a0:	6812      	ldr	r2, [r2, #0]
  4071a2:	b932      	cbnz	r2, 4071b2 <vTaskIncrementTick+0xe6>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
  4071a4:	4b0b      	ldr	r3, [pc, #44]	; (4071d4 <vTaskIncrementTick+0x108>)
  4071a6:	4a0b      	ldr	r2, [pc, #44]	; (4071d4 <vTaskIncrementTick+0x108>)
  4071a8:	9301      	str	r3, [sp, #4]
  4071aa:	f04f 33ff 	mov.w	r3, #4294967295
  4071ae:	6013      	str	r3, [r2, #0]
  4071b0:	e79d      	b.n	4070ee <vTaskIncrementTick+0x22>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
  4071b2:	681b      	ldr	r3, [r3, #0]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
  4071b4:	4a07      	ldr	r2, [pc, #28]	; (4071d4 <vTaskIncrementTick+0x108>)
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
  4071b6:	68db      	ldr	r3, [r3, #12]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
  4071b8:	9201      	str	r2, [sp, #4]
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
  4071ba:	68db      	ldr	r3, [r3, #12]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
  4071bc:	685b      	ldr	r3, [r3, #4]
  4071be:	6013      	str	r3, [r2, #0]
  4071c0:	e795      	b.n	4070ee <vTaskIncrementTick+0x22>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
  4071c2:	9b01      	ldr	r3, [sp, #4]
  4071c4:	601a      	str	r2, [r3, #0]
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
  4071c6:	b003      	add	sp, #12
  4071c8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4071cc:	2000352c 	.word	0x2000352c
  4071d0:	200033cc 	.word	0x200033cc
  4071d4:	20000138 	.word	0x20000138
  4071d8:	2000348c 	.word	0x2000348c
  4071dc:	00406619 	.word	0x00406619
  4071e0:	200033c4 	.word	0x200033c4
  4071e4:	20003530 	.word	0x20003530
  4071e8:	20003470 	.word	0x20003470
  4071ec:	20003538 	.word	0x20003538
  4071f0:	200033d0 	.word	0x200033d0
  4071f4:	004065c1 	.word	0x004065c1

004071f8 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
  4071f8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
  4071fc:	4b2d      	ldr	r3, [pc, #180]	; (4072b4 <xTaskResumeAll+0xbc>)
  4071fe:	4798      	blx	r3
	{
		--uxSchedulerSuspended;
  407200:	4b2d      	ldr	r3, [pc, #180]	; (4072b8 <xTaskResumeAll+0xc0>)
  407202:	681a      	ldr	r2, [r3, #0]
  407204:	3a01      	subs	r2, #1
  407206:	601a      	str	r2, [r3, #0]

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  407208:	681e      	ldr	r6, [r3, #0]
  40720a:	2e00      	cmp	r6, #0
  40720c:	d13c      	bne.n	407288 <xTaskResumeAll+0x90>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
  40720e:	4b2b      	ldr	r3, [pc, #172]	; (4072bc <xTaskResumeAll+0xc4>)
  407210:	681b      	ldr	r3, [r3, #0]
  407212:	2b00      	cmp	r3, #0
  407214:	d038      	beq.n	407288 <xTaskResumeAll+0x90>
  407216:	f8df 90cc 	ldr.w	r9, [pc, #204]	; 4072e4 <xTaskResumeAll+0xec>
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
  40721a:	4f29      	ldr	r7, [pc, #164]	; (4072c0 <xTaskResumeAll+0xc8>)
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
  40721c:	f8df 80c8 	ldr.w	r8, [pc, #200]	; 4072e8 <xTaskResumeAll+0xf0>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
  407220:	46ca      	mov	sl, r9
  407222:	e01e      	b.n	407262 <xTaskResumeAll+0x6a>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
  407224:	f8da 300c 	ldr.w	r3, [sl, #12]
  407228:	68dc      	ldr	r4, [r3, #12]
					vListRemove( &( pxTCB->xEventListItem ) );
  40722a:	f104 0018 	add.w	r0, r4, #24
					vListRemove( &( pxTCB->xGenericListItem ) );
  40722e:	1d25      	adds	r5, r4, #4
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
  407230:	47b8      	blx	r7
					vListRemove( &( pxTCB->xGenericListItem ) );
  407232:	4628      	mov	r0, r5
  407234:	47b8      	blx	r7
					prvAddTaskToReadyQueue( pxTCB );
  407236:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  407238:	f8d8 e000 	ldr.w	lr, [r8]
  40723c:	4921      	ldr	r1, [pc, #132]	; (4072c4 <xTaskResumeAll+0xcc>)
  40723e:	4a22      	ldr	r2, [pc, #136]	; (4072c8 <xTaskResumeAll+0xd0>)
  407240:	eb03 0083 	add.w	r0, r3, r3, lsl #2
  407244:	4573      	cmp	r3, lr
  407246:	eb01 0080 	add.w	r0, r1, r0, lsl #2
  40724a:	4629      	mov	r1, r5
  40724c:	bf88      	it	hi
  40724e:	f8c8 3000 	strhi.w	r3, [r8]
  407252:	4790      	blx	r2

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  407254:	4b1d      	ldr	r3, [pc, #116]	; (4072cc <xTaskResumeAll+0xd4>)
  407256:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  407258:	681b      	ldr	r3, [r3, #0]
  40725a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
					{
						xYieldRequired = pdTRUE;
  40725c:	429a      	cmp	r2, r3
  40725e:	bf28      	it	cs
  407260:	2601      	movcs	r6, #1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
  407262:	f8d9 3000 	ldr.w	r3, [r9]
  407266:	2b00      	cmp	r3, #0
  407268:	d1dc      	bne.n	407224 <xTaskResumeAll+0x2c>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
  40726a:	4c19      	ldr	r4, [pc, #100]	; (4072d0 <xTaskResumeAll+0xd8>)
  40726c:	6823      	ldr	r3, [r4, #0]
  40726e:	b18b      	cbz	r3, 407294 <xTaskResumeAll+0x9c>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
  407270:	6823      	ldr	r3, [r4, #0]
  407272:	b13b      	cbz	r3, 407284 <xTaskResumeAll+0x8c>
  407274:	4d17      	ldr	r5, [pc, #92]	; (4072d4 <xTaskResumeAll+0xdc>)
					{
						vTaskIncrementTick();
  407276:	47a8      	blx	r5
						--uxMissedTicks;
  407278:	6823      	ldr	r3, [r4, #0]
  40727a:	3b01      	subs	r3, #1
  40727c:	6023      	str	r3, [r4, #0]
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
  40727e:	6823      	ldr	r3, [r4, #0]
  407280:	2b00      	cmp	r3, #0
  407282:	d1f8      	bne.n	407276 <xTaskResumeAll+0x7e>
  407284:	4b14      	ldr	r3, [pc, #80]	; (4072d8 <xTaskResumeAll+0xe0>)
  407286:	e00b      	b.n	4072a0 <xTaskResumeAll+0xa8>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
  407288:	2400      	movs	r4, #0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
  40728a:	4b14      	ldr	r3, [pc, #80]	; (4072dc <xTaskResumeAll+0xe4>)
  40728c:	4798      	blx	r3

	return xAlreadyYielded;
}
  40728e:	4620      	mov	r0, r4
  407290:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
  407294:	2e01      	cmp	r6, #1
  407296:	d0f5      	beq.n	407284 <xTaskResumeAll+0x8c>
  407298:	4b0f      	ldr	r3, [pc, #60]	; (4072d8 <xTaskResumeAll+0xe0>)
  40729a:	681a      	ldr	r2, [r3, #0]
  40729c:	2a01      	cmp	r2, #1
  40729e:	d1f3      	bne.n	407288 <xTaskResumeAll+0x90>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
  4072a0:	2100      	movs	r1, #0
					portYIELD_WITHIN_API();
  4072a2:	4a0f      	ldr	r2, [pc, #60]	; (4072e0 <xTaskResumeAll+0xe8>)
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
  4072a4:	6019      	str	r1, [r3, #0]
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
  4072a6:	2401      	movs	r4, #1
					xMissedYield = pdFALSE;
					portYIELD_WITHIN_API();
  4072a8:	4790      	blx	r2
				}
			}
		}
	}
	taskEXIT_CRITICAL();
  4072aa:	4b0c      	ldr	r3, [pc, #48]	; (4072dc <xTaskResumeAll+0xe4>)
  4072ac:	4798      	blx	r3

	return xAlreadyYielded;
}
  4072ae:	4620      	mov	r0, r4
  4072b0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  4072b4:	004066e5 	.word	0x004066e5
  4072b8:	2000352c 	.word	0x2000352c
  4072bc:	20003490 	.word	0x20003490
  4072c0:	00406619 	.word	0x00406619
  4072c4:	200033d0 	.word	0x200033d0
  4072c8:	004065c1 	.word	0x004065c1
  4072cc:	200034b8 	.word	0x200034b8
  4072d0:	20003530 	.word	0x20003530
  4072d4:	004070cd 	.word	0x004070cd
  4072d8:	200034ac 	.word	0x200034ac
  4072dc:	004066fd 	.word	0x004066fd
  4072e0:	004066d5 	.word	0x004066d5
  4072e4:	20003494 	.word	0x20003494
  4072e8:	200033c4 	.word	0x200033c4

004072ec <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
  4072ec:	b538      	push	{r3, r4, r5, lr}
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
  4072ee:	b910      	cbnz	r0, 4072f6 <vTaskDelay+0xa>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
		{
			portYIELD_WITHIN_API();
  4072f0:	4b0b      	ldr	r3, [pc, #44]	; (407320 <vTaskDelay+0x34>)
  4072f2:	4798      	blx	r3
  4072f4:	bd38      	pop	{r3, r4, r5, pc}

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
  4072f6:	4b0b      	ldr	r3, [pc, #44]	; (407324 <vTaskDelay+0x38>)
				xTimeToWake = xTickCount + xTicksToDelay;

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  4072f8:	490b      	ldr	r1, [pc, #44]	; (407328 <vTaskDelay+0x3c>)

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
  4072fa:	681d      	ldr	r5, [r3, #0]
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
  4072fc:	4c0b      	ldr	r4, [pc, #44]	; (40732c <vTaskDelay+0x40>)

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  4072fe:	4a0c      	ldr	r2, [pc, #48]	; (407330 <vTaskDelay+0x44>)

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
  407300:	3501      	adds	r5, #1
  407302:	601d      	str	r5, [r3, #0]
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
  407304:	6824      	ldr	r4, [r4, #0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  407306:	680b      	ldr	r3, [r1, #0]
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
  407308:	4404      	add	r4, r0

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  40730a:	1d18      	adds	r0, r3, #4
  40730c:	4790      	blx	r2
				prvAddCurrentTaskToDelayedList( xTimeToWake );
  40730e:	4b09      	ldr	r3, [pc, #36]	; (407334 <vTaskDelay+0x48>)
  407310:	4620      	mov	r0, r4
  407312:	4798      	blx	r3
			}
			xAlreadyYielded = xTaskResumeAll();
  407314:	4b08      	ldr	r3, [pc, #32]	; (407338 <vTaskDelay+0x4c>)
  407316:	4798      	blx	r3
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
  407318:	2800      	cmp	r0, #0
  40731a:	d0e9      	beq.n	4072f0 <vTaskDelay+0x4>
  40731c:	bd38      	pop	{r3, r4, r5, pc}
  40731e:	bf00      	nop
  407320:	004066d5 	.word	0x004066d5
  407324:	2000352c 	.word	0x2000352c
  407328:	200034b8 	.word	0x200034b8
  40732c:	200033cc 	.word	0x200033cc
  407330:	00406619 	.word	0x00406619
  407334:	00406d7d 	.word	0x00406d7d
  407338:	004071f9 	.word	0x004071f9

0040733c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
  40733c:	4c1e      	ldr	r4, [pc, #120]	; (4073b8 <prvIdleTask+0x7c>)
  40733e:	4e1f      	ldr	r6, [pc, #124]	; (4073bc <prvIdleTask+0x80>)
  407340:	f8df 8098 	ldr.w	r8, [pc, #152]	; 4073dc <prvIdleTask+0xa0>
  407344:	4d1e      	ldr	r5, [pc, #120]	; (4073c0 <prvIdleTask+0x84>)
  407346:	e92d 4888 	stmdb	sp!, {r3, r7, fp, lr}
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
  40734a:	46a1      	mov	r9, r4
  40734c:	4f1d      	ldr	r7, [pc, #116]	; (4073c4 <prvIdleTask+0x88>)
  40734e:	f8df b090 	ldr.w	fp, [pc, #144]	; 4073e0 <prvIdleTask+0xa4>
  407352:	e002      	b.n	40735a <prvIdleTask+0x1e>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
  407354:	682b      	ldr	r3, [r5, #0]
  407356:	2b01      	cmp	r3, #1
  407358:	d82b      	bhi.n	4073b2 <prvIdleTask+0x76>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
  40735a:	6823      	ldr	r3, [r4, #0]
  40735c:	2b00      	cmp	r3, #0
  40735e:	d0f9      	beq.n	407354 <prvIdleTask+0x18>

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
  407360:	6833      	ldr	r3, [r6, #0]
  407362:	3301      	adds	r3, #1
  407364:	6033      	str	r3, [r6, #0]
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
  407366:	f8d7 a000 	ldr.w	sl, [r7]
			xTaskResumeAll();
  40736a:	47c0      	blx	r8

			if( xListIsEmpty == pdFALSE )
  40736c:	f1ba 0f00 	cmp.w	sl, #0
  407370:	d0f0      	beq.n	407354 <prvIdleTask+0x18>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
  407372:	4a15      	ldr	r2, [pc, #84]	; (4073c8 <prvIdleTask+0x8c>)
  407374:	4790      	blx	r2
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
  407376:	4a13      	ldr	r2, [pc, #76]	; (4073c4 <prvIdleTask+0x88>)
  407378:	68d3      	ldr	r3, [r2, #12]
  40737a:	f8d3 a00c 	ldr.w	sl, [r3, #12]
					vListRemove( &( pxTCB->xGenericListItem ) );
  40737e:	4b13      	ldr	r3, [pc, #76]	; (4073cc <prvIdleTask+0x90>)
  407380:	f10a 0004 	add.w	r0, sl, #4
  407384:	4798      	blx	r3
					--uxCurrentNumberOfTasks;
  407386:	f8db 3000 	ldr.w	r3, [fp]
					--uxTasksDeleted;
				}
				taskEXIT_CRITICAL();
  40738a:	4a11      	ldr	r2, [pc, #68]	; (4073d0 <prvIdleTask+0x94>)

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
  40738c:	3b01      	subs	r3, #1
  40738e:	f8cb 3000 	str.w	r3, [fp]
					--uxTasksDeleted;
  407392:	f8d9 3000 	ldr.w	r3, [r9]
  407396:	3b01      	subs	r3, #1
  407398:	f8c9 3000 	str.w	r3, [r9]
				}
				taskEXIT_CRITICAL();
  40739c:	4790      	blx	r2

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
  40739e:	4b0d      	ldr	r3, [pc, #52]	; (4073d4 <prvIdleTask+0x98>)
  4073a0:	f8da 0030 	ldr.w	r0, [sl, #48]	; 0x30
  4073a4:	4798      	blx	r3
		vPortFree( pxTCB );
  4073a6:	4650      	mov	r0, sl
  4073a8:	4a0a      	ldr	r2, [pc, #40]	; (4073d4 <prvIdleTask+0x98>)
  4073aa:	4790      	blx	r2

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
  4073ac:	682b      	ldr	r3, [r5, #0]
  4073ae:	2b01      	cmp	r3, #1
  4073b0:	d9d3      	bls.n	40735a <prvIdleTask+0x1e>
			{
				taskYIELD();
  4073b2:	4b09      	ldr	r3, [pc, #36]	; (4073d8 <prvIdleTask+0x9c>)
  4073b4:	4798      	blx	r3
  4073b6:	e7d0      	b.n	40735a <prvIdleTask+0x1e>
  4073b8:	200033c8 	.word	0x200033c8
  4073bc:	2000352c 	.word	0x2000352c
  4073c0:	200033d0 	.word	0x200033d0
  4073c4:	20003474 	.word	0x20003474
  4073c8:	004066e5 	.word	0x004066e5
  4073cc:	00406619 	.word	0x00406619
  4073d0:	004066fd 	.word	0x004066fd
  4073d4:	0040679d 	.word	0x0040679d
  4073d8:	004066d5 	.word	0x004066d5
  4073dc:	004071f9 	.word	0x004071f9
  4073e0:	20003490 	.word	0x20003490

004073e4 <vTaskList>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	void vTaskList( signed char *pcWriteBuffer )
	{
  4073e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
  4073e8:	4b25      	ldr	r3, [pc, #148]	; (407480 <vTaskList+0x9c>)
			report the task name, state and stack high water mark. */

			*pcWriteBuffer = ( signed char ) 0x00;
			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );

			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
  4073ea:	4926      	ldr	r1, [pc, #152]	; (407484 <vTaskList+0xa0>)
		{
			/* Run through all the lists that could potentially contain a TCB and
			report the task name, state and stack high water mark. */

			*pcWriteBuffer = ( signed char ) 0x00;
			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
  4073ec:	4a26      	ldr	r2, [pc, #152]	; (407488 <vTaskList+0xa4>)

			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
  4073ee:	680c      	ldr	r4, [r1, #0]

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
  4073f0:	681d      	ldr	r5, [r3, #0]
  4073f2:	4e26      	ldr	r6, [pc, #152]	; (40748c <vTaskList+0xa8>)
		{
			/* Run through all the lists that could potentially contain a TCB and
			report the task name, state and stack high water mark. */

			*pcWriteBuffer = ( signed char ) 0x00;
			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
  4073f4:	8811      	ldrh	r1, [r2, #0]
  4073f6:	7892      	ldrb	r2, [r2, #2]
			{
				uxQueue--;

				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
				{
					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tskREADY_CHAR );
  4073f8:	f8df 80a4 	ldr.w	r8, [pc, #164]	; 4074a0 <vTaskList+0xbc>
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	void vTaskList( signed char *pcWriteBuffer )
	{
  4073fc:	4607      	mov	r7, r0

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
  4073fe:	3501      	adds	r5, #1
  407400:	eb04 0084 	add.w	r0, r4, r4, lsl #2
  407404:	601d      	str	r5, [r3, #0]
		{
			/* Run through all the lists that could potentially contain a TCB and
			report the task name, state and stack high water mark. */

			*pcWriteBuffer = ( signed char ) 0x00;
			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
  407406:	8039      	strh	r1, [r7, #0]
  407408:	70ba      	strb	r2, [r7, #2]

			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
  40740a:	3401      	adds	r4, #1
  40740c:	eb06 0580 	add.w	r5, r6, r0, lsl #2
  407410:	e001      	b.n	407416 <vTaskList+0x32>
  407412:	3d14      	subs	r5, #20

				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
				{
					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tskREADY_CHAR );
				}
			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
  407414:	b16c      	cbz	r4, 407432 <vTaskList+0x4e>

			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;

			do
			{
				uxQueue--;
  407416:	3c01      	subs	r4, #1

				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
  407418:	eb04 0384 	add.w	r3, r4, r4, lsl #2
  40741c:	f856 3023 	ldr.w	r3, [r6, r3, lsl #2]
  407420:	2b00      	cmp	r3, #0
  407422:	d0f6      	beq.n	407412 <vTaskList+0x2e>
				{
					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tskREADY_CHAR );
  407424:	4629      	mov	r1, r5
  407426:	4638      	mov	r0, r7
  407428:	2252      	movs	r2, #82	; 0x52
  40742a:	47c0      	blx	r8
  40742c:	3d14      	subs	r5, #20
				}
			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
  40742e:	2c00      	cmp	r4, #0
  407430:	d1f1      	bne.n	407416 <vTaskList+0x32>

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
  407432:	4b17      	ldr	r3, [pc, #92]	; (407490 <vTaskList+0xac>)
  407434:	681a      	ldr	r2, [r3, #0]
  407436:	6812      	ldr	r2, [r2, #0]
  407438:	b9e2      	cbnz	r2, 407474 <vTaskList+0x90>
			{
				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
			}

			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
  40743a:	4b16      	ldr	r3, [pc, #88]	; (407494 <vTaskList+0xb0>)
  40743c:	681a      	ldr	r2, [r3, #0]
  40743e:	6812      	ldr	r2, [r2, #0]
  407440:	b992      	cbnz	r2, 407468 <vTaskList+0x84>
				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_CHAR );
			}

			#if( INCLUDE_vTaskDelete == 1 )
			{
				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
  407442:	4915      	ldr	r1, [pc, #84]	; (407498 <vTaskList+0xb4>)
  407444:	680b      	ldr	r3, [r1, #0]
  407446:	b953      	cbnz	r3, 40745e <vTaskList+0x7a>
			}
			#endif

			#if ( INCLUDE_vTaskSuspend == 1 )
			{
				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
  407448:	4914      	ldr	r1, [pc, #80]	; (40749c <vTaskList+0xb8>)
  40744a:	680b      	ldr	r3, [r1, #0]
  40744c:	b11b      	cbz	r3, 407456 <vTaskList+0x72>
				{
					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &xSuspendedTaskList, tskSUSPENDED_CHAR );
  40744e:	4638      	mov	r0, r7
  407450:	2253      	movs	r2, #83	; 0x53
  407452:	4b13      	ldr	r3, [pc, #76]	; (4074a0 <vTaskList+0xbc>)
  407454:	4798      	blx	r3
				}
			}
			#endif
		}
		xTaskResumeAll();
  407456:	4b13      	ldr	r3, [pc, #76]	; (4074a4 <vTaskList+0xc0>)
  407458:	4798      	blx	r3
  40745a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

			#if( INCLUDE_vTaskDelete == 1 )
			{
				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
				{
					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &xTasksWaitingTermination, tskDELETED_CHAR );
  40745e:	4638      	mov	r0, r7
  407460:	2244      	movs	r2, #68	; 0x44
  407462:	4b0f      	ldr	r3, [pc, #60]	; (4074a0 <vTaskList+0xbc>)
  407464:	4798      	blx	r3
  407466:	e7ef      	b.n	407448 <vTaskList+0x64>
				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
			}

			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
			{
				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_CHAR );
  407468:	6819      	ldr	r1, [r3, #0]
  40746a:	4b0d      	ldr	r3, [pc, #52]	; (4074a0 <vTaskList+0xbc>)
  40746c:	4638      	mov	r0, r7
  40746e:	2242      	movs	r2, #66	; 0x42
  407470:	4798      	blx	r3
  407472:	e7e6      	b.n	407442 <vTaskList+0x5e>
				}
			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
			{
				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
  407474:	6819      	ldr	r1, [r3, #0]
  407476:	4b0a      	ldr	r3, [pc, #40]	; (4074a0 <vTaskList+0xbc>)
  407478:	4638      	mov	r0, r7
  40747a:	2242      	movs	r2, #66	; 0x42
  40747c:	4798      	blx	r3
  40747e:	e7dc      	b.n	40743a <vTaskList+0x56>
  407480:	2000352c 	.word	0x2000352c
  407484:	2000353c 	.word	0x2000353c
  407488:	00415bf0 	.word	0x00415bf0
  40748c:	200033d0 	.word	0x200033d0
  407490:	2000348c 	.word	0x2000348c
  407494:	20003470 	.word	0x20003470
  407498:	20003474 	.word	0x20003474
  40749c:	200034f0 	.word	0x200034f0
  4074a0:	00406ced 	.word	0x00406ced
  4074a4:	004071f9 	.word	0x004071f9

004074a8 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
  4074a8:	b430      	push	{r4, r5}
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
  4074aa:	4b29      	ldr	r3, [pc, #164]	; (407550 <vTaskSwitchContext+0xa8>)
  4074ac:	681b      	ldr	r3, [r3, #0]
  4074ae:	2b00      	cmp	r3, #0
  4074b0:	d134      	bne.n	40751c <vTaskSwitchContext+0x74>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
  4074b2:	4b28      	ldr	r3, [pc, #160]	; (407554 <vTaskSwitchContext+0xac>)
  4074b4:	4928      	ldr	r1, [pc, #160]	; (407558 <vTaskSwitchContext+0xb0>)
  4074b6:	681a      	ldr	r2, [r3, #0]
  4074b8:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  4074bc:	0092      	lsls	r2, r2, #2
  4074be:	588a      	ldr	r2, [r1, r2]
  4074c0:	b94a      	cbnz	r2, 4074d6 <vTaskSwitchContext+0x2e>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
  4074c2:	681a      	ldr	r2, [r3, #0]
  4074c4:	3a01      	subs	r2, #1
  4074c6:	601a      	str	r2, [r3, #0]

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
  4074c8:	681a      	ldr	r2, [r3, #0]
  4074ca:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  4074ce:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
  4074d2:	2a00      	cmp	r2, #0
  4074d4:	d0f5      	beq.n	4074c2 <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
  4074d6:	681b      	ldr	r3, [r3, #0]
  4074d8:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  4074dc:	eb01 0183 	add.w	r1, r1, r3, lsl #2
  4074e0:	f101 0208 	add.w	r2, r1, #8
  4074e4:	684b      	ldr	r3, [r1, #4]
  4074e6:	685b      	ldr	r3, [r3, #4]
  4074e8:	604b      	str	r3, [r1, #4]
  4074ea:	4293      	cmp	r3, r2
  4074ec:	d02c      	beq.n	407548 <vTaskSwitchContext+0xa0>

		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
  4074ee:	491b      	ldr	r1, [pc, #108]	; (40755c <vTaskSwitchContext+0xb4>)
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
  4074f0:	4a1b      	ldr	r2, [pc, #108]	; (407560 <vTaskSwitchContext+0xb8>)

		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
  4074f2:	6808      	ldr	r0, [r1, #0]
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
  4074f4:	68db      	ldr	r3, [r3, #12]
  4074f6:	6013      	str	r3, [r2, #0]

		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
  4074f8:	b170      	cbz	r0, 407518 <vTaskSwitchContext+0x70>
  4074fa:	6813      	ldr	r3, [r2, #0]
  4074fc:	4819      	ldr	r0, [pc, #100]	; (407564 <vTaskSwitchContext+0xbc>)
  4074fe:	6c5c      	ldr	r4, [r3, #68]	; 0x44
  407500:	6803      	ldr	r3, [r0, #0]
  407502:	429c      	cmp	r4, r3
  407504:	d008      	beq.n	407518 <vTaskSwitchContext+0x70>
  407506:	4b18      	ldr	r3, [pc, #96]	; (407568 <vTaskSwitchContext+0xc0>)
  407508:	4d18      	ldr	r5, [pc, #96]	; (40756c <vTaskSwitchContext+0xc4>)
  40750a:	681c      	ldr	r4, [r3, #0]
  40750c:	682d      	ldr	r5, [r5, #0]
  40750e:	3408      	adds	r4, #8
  407510:	42a5      	cmp	r5, r4
  407512:	d808      	bhi.n	407526 <vTaskSwitchContext+0x7e>
  407514:	2300      	movs	r3, #0
  407516:	600b      	str	r3, [r1, #0]
	}
}
  407518:	bc30      	pop	{r4, r5}
  40751a:	4770      	bx	lr
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
  40751c:	4b14      	ldr	r3, [pc, #80]	; (407570 <vTaskSwitchContext+0xc8>)
  40751e:	2201      	movs	r2, #1
  407520:	601a      	str	r2, [r3, #0]
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );

		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
  407522:	bc30      	pop	{r4, r5}
  407524:	4770      	bx	lr
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );

		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
  407526:	4913      	ldr	r1, [pc, #76]	; (407574 <vTaskSwitchContext+0xcc>)
  407528:	6812      	ldr	r2, [r2, #0]
  40752a:	681c      	ldr	r4, [r3, #0]
  40752c:	680d      	ldr	r5, [r1, #0]
  40752e:	6819      	ldr	r1, [r3, #0]
  407530:	6c52      	ldr	r2, [r2, #68]	; 0x44
  407532:	6002      	str	r2, [r0, #0]
  407534:	3104      	adds	r1, #4
  407536:	6019      	str	r1, [r3, #0]
  407538:	6818      	ldr	r0, [r3, #0]
  40753a:	6819      	ldr	r1, [r3, #0]
  40753c:	6025      	str	r5, [r4, #0]
  40753e:	3104      	adds	r1, #4
  407540:	6002      	str	r2, [r0, #0]
  407542:	6019      	str	r1, [r3, #0]
	}
}
  407544:	bc30      	pop	{r4, r5}
  407546:	4770      	bx	lr
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
  407548:	685b      	ldr	r3, [r3, #4]
  40754a:	604b      	str	r3, [r1, #4]
  40754c:	e7cf      	b.n	4074ee <vTaskSwitchContext+0x46>
  40754e:	bf00      	nop
  407550:	2000352c 	.word	0x2000352c
  407554:	200033c4 	.word	0x200033c4
  407558:	200033d0 	.word	0x200033d0
  40755c:	20003488 	.word	0x20003488
  407560:	200034b8 	.word	0x200034b8
  407564:	20000134 	.word	0x20000134
  407568:	200034b4 	.word	0x200034b4
  40756c:	20003534 	.word	0x20003534
  407570:	200034ac 	.word	0x200034ac
  407574:	200033cc 	.word	0x200033cc

00407578 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
  407578:	b538      	push	{r3, r4, r5, lr}
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
  40757a:	4c0c      	ldr	r4, [pc, #48]	; (4075ac <vTaskPlaceOnEventList+0x34>)
  40757c:	4b0c      	ldr	r3, [pc, #48]	; (4075b0 <vTaskPlaceOnEventList+0x38>)
  40757e:	6822      	ldr	r2, [r4, #0]
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
  407580:	460d      	mov	r5, r1
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
  407582:	f102 0118 	add.w	r1, r2, #24
  407586:	4798      	blx	r3

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  407588:	6820      	ldr	r0, [r4, #0]
  40758a:	4b0a      	ldr	r3, [pc, #40]	; (4075b4 <vTaskPlaceOnEventList+0x3c>)
  40758c:	3004      	adds	r0, #4
  40758e:	4798      	blx	r3


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
  407590:	1c6b      	adds	r3, r5, #1
  407592:	d005      	beq.n	4075a0 <vTaskPlaceOnEventList+0x28>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
  407594:	4a08      	ldr	r2, [pc, #32]	; (4075b8 <vTaskPlaceOnEventList+0x40>)
			prvAddCurrentTaskToDelayedList( xTimeToWake );
  407596:	4b09      	ldr	r3, [pc, #36]	; (4075bc <vTaskPlaceOnEventList+0x44>)
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
  407598:	6810      	ldr	r0, [r2, #0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
  40759a:	4428      	add	r0, r5
  40759c:	4798      	blx	r3
  40759e:	bd38      	pop	{r3, r4, r5, pc}
		if( xTicksToWait == portMAX_DELAY )
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  4075a0:	6821      	ldr	r1, [r4, #0]
  4075a2:	4807      	ldr	r0, [pc, #28]	; (4075c0 <vTaskPlaceOnEventList+0x48>)
  4075a4:	4b07      	ldr	r3, [pc, #28]	; (4075c4 <vTaskPlaceOnEventList+0x4c>)
  4075a6:	3104      	adds	r1, #4
  4075a8:	4798      	blx	r3
  4075aa:	bd38      	pop	{r3, r4, r5, pc}
  4075ac:	200034b8 	.word	0x200034b8
  4075b0:	004065dd 	.word	0x004065dd
  4075b4:	00406619 	.word	0x00406619
  4075b8:	200033cc 	.word	0x200033cc
  4075bc:	00406d7d 	.word	0x00406d7d
  4075c0:	200034f0 	.word	0x200034f0
  4075c4:	004065c1 	.word	0x004065c1

004075c8 <vTaskPlaceOnEventListRestricted>:
/*-----------------------------------------------------------*/

#if configUSE_TIMERS == 1

	void vTaskPlaceOnEventListRestricted( const xList * const pxEventList, portTickType xTicksToWait )
	{
  4075c8:	b538      	push	{r3, r4, r5, lr}

		/* Place the event list item of the TCB in the appropriate event list.
		In this case it is assume that this is the only task that is going to
		be waiting on this event list, so the faster vListInsertEnd() function
		can be used in place of vListInsert. */
		vListInsertEnd( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
  4075ca:	4c08      	ldr	r4, [pc, #32]	; (4075ec <vTaskPlaceOnEventListRestricted+0x24>)
  4075cc:	4b08      	ldr	r3, [pc, #32]	; (4075f0 <vTaskPlaceOnEventListRestricted+0x28>)
  4075ce:	6822      	ldr	r2, [r4, #0]
/*-----------------------------------------------------------*/

#if configUSE_TIMERS == 1

	void vTaskPlaceOnEventListRestricted( const xList * const pxEventList, portTickType xTicksToWait )
	{
  4075d0:	460d      	mov	r5, r1

		/* Place the event list item of the TCB in the appropriate event list.
		In this case it is assume that this is the only task that is going to
		be waiting on this event list, so the faster vListInsertEnd() function
		can be used in place of vListInsert. */
		vListInsertEnd( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
  4075d2:	f102 0118 	add.w	r1, r2, #24
  4075d6:	4798      	blx	r3

		/* We must remove this task from the ready list before adding it to the
		blocked list as the same list item is used for both lists.  This
		function is called form a critical section. */
		vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  4075d8:	6820      	ldr	r0, [r4, #0]
  4075da:	4b06      	ldr	r3, [pc, #24]	; (4075f4 <vTaskPlaceOnEventListRestricted+0x2c>)
  4075dc:	3004      	adds	r0, #4
  4075de:	4798      	blx	r3

		/* Calculate the time at which the task should be woken if the event does
		not occur.  This may overflow but this doesn't matter. */
		xTimeToWake = xTickCount + xTicksToWait;
  4075e0:	4a05      	ldr	r2, [pc, #20]	; (4075f8 <vTaskPlaceOnEventListRestricted+0x30>)
		prvAddCurrentTaskToDelayedList( xTimeToWake );
  4075e2:	4b06      	ldr	r3, [pc, #24]	; (4075fc <vTaskPlaceOnEventListRestricted+0x34>)
		function is called form a critical section. */
		vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );

		/* Calculate the time at which the task should be woken if the event does
		not occur.  This may overflow but this doesn't matter. */
		xTimeToWake = xTickCount + xTicksToWait;
  4075e4:	6810      	ldr	r0, [r2, #0]
		prvAddCurrentTaskToDelayedList( xTimeToWake );
  4075e6:	4428      	add	r0, r5
  4075e8:	4798      	blx	r3
  4075ea:	bd38      	pop	{r3, r4, r5, pc}
  4075ec:	200034b8 	.word	0x200034b8
  4075f0:	004065c1 	.word	0x004065c1
  4075f4:	00406619 	.word	0x00406619
  4075f8:	200033cc 	.word	0x200033cc
  4075fc:	00406d7d 	.word	0x00406d7d

00407600 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
  407600:	b570      	push	{r4, r5, r6, lr}
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
  407602:	68c3      	ldr	r3, [r0, #12]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
  407604:	4e13      	ldr	r6, [pc, #76]	; (407654 <xTaskRemoveFromEventList+0x54>)
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
  407606:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
  407608:	f104 0518 	add.w	r5, r4, #24
  40760c:	4628      	mov	r0, r5
  40760e:	47b0      	blx	r6

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  407610:	4b11      	ldr	r3, [pc, #68]	; (407658 <xTaskRemoveFromEventList+0x58>)
  407612:	681b      	ldr	r3, [r3, #0]
  407614:	b9cb      	cbnz	r3, 40764a <xTaskRemoveFromEventList+0x4a>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
  407616:	1d25      	adds	r5, r4, #4
  407618:	4628      	mov	r0, r5
  40761a:	47b0      	blx	r6
		prvAddTaskToReadyQueue( pxUnblockedTCB );
  40761c:	4a0f      	ldr	r2, [pc, #60]	; (40765c <xTaskRemoveFromEventList+0x5c>)
  40761e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  407620:	6811      	ldr	r1, [r2, #0]
  407622:	480f      	ldr	r0, [pc, #60]	; (407660 <xTaskRemoveFromEventList+0x60>)
  407624:	428b      	cmp	r3, r1
  407626:	bf88      	it	hi
  407628:	6013      	strhi	r3, [r2, #0]
  40762a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  40762e:	4a0d      	ldr	r2, [pc, #52]	; (407664 <xTaskRemoveFromEventList+0x64>)
  407630:	4629      	mov	r1, r5
  407632:	eb00 0083 	add.w	r0, r0, r3, lsl #2
  407636:	4790      	blx	r2
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
  407638:	4b0b      	ldr	r3, [pc, #44]	; (407668 <xTaskRemoveFromEventList+0x68>)
  40763a:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
  40763c:	681b      	ldr	r3, [r3, #0]
  40763e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
  407640:	4298      	cmp	r0, r3
  407642:	bf34      	ite	cc
  407644:	2000      	movcc	r0, #0
  407646:	2001      	movcs	r0, #1
  407648:	bd70      	pop	{r4, r5, r6, pc}
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
  40764a:	4629      	mov	r1, r5
  40764c:	4807      	ldr	r0, [pc, #28]	; (40766c <xTaskRemoveFromEventList+0x6c>)
  40764e:	4b05      	ldr	r3, [pc, #20]	; (407664 <xTaskRemoveFromEventList+0x64>)
  407650:	4798      	blx	r3
  407652:	e7f1      	b.n	407638 <xTaskRemoveFromEventList+0x38>
  407654:	00406619 	.word	0x00406619
  407658:	2000352c 	.word	0x2000352c
  40765c:	200033c4 	.word	0x200033c4
  407660:	200033d0 	.word	0x200033d0
  407664:	004065c1 	.word	0x004065c1
  407668:	200034b8 	.word	0x200034b8
  40766c:	20003494 	.word	0x20003494

00407670 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
  407670:	4a03      	ldr	r2, [pc, #12]	; (407680 <vTaskSetTimeOutState+0x10>)
	pxTimeOut->xTimeOnEntering = xTickCount;
  407672:	4b04      	ldr	r3, [pc, #16]	; (407684 <vTaskSetTimeOutState+0x14>)
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
  407674:	6812      	ldr	r2, [r2, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
  407676:	681b      	ldr	r3, [r3, #0]
  407678:	e880 000c 	stmia.w	r0, {r2, r3}
  40767c:	4770      	bx	lr
  40767e:	bf00      	nop
  407680:	20003538 	.word	0x20003538
  407684:	200033cc 	.word	0x200033cc

00407688 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
  407688:	b570      	push	{r4, r5, r6, lr}
  40768a:	460d      	mov	r5, r1
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
  40768c:	4b19      	ldr	r3, [pc, #100]	; (4076f4 <xTaskCheckForTimeOut+0x6c>)
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
  40768e:	4604      	mov	r4, r0
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
  407690:	4798      	blx	r3
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
  407692:	682b      	ldr	r3, [r5, #0]
  407694:	1c5a      	adds	r2, r3, #1
  407696:	d028      	beq.n	4076ea <xTaskCheckForTimeOut+0x62>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
  407698:	4817      	ldr	r0, [pc, #92]	; (4076f8 <xTaskCheckForTimeOut+0x70>)
  40769a:	6822      	ldr	r2, [r4, #0]
  40769c:	6801      	ldr	r1, [r0, #0]
  40769e:	428a      	cmp	r2, r1
  4076a0:	d01b      	beq.n	4076da <xTaskCheckForTimeOut+0x52>
  4076a2:	4916      	ldr	r1, [pc, #88]	; (4076fc <xTaskCheckForTimeOut+0x74>)
  4076a4:	6862      	ldr	r2, [r4, #4]
  4076a6:	680e      	ldr	r6, [r1, #0]
  4076a8:	42b2      	cmp	r2, r6
  4076aa:	d911      	bls.n	4076d0 <xTaskCheckForTimeOut+0x48>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
  4076ac:	680e      	ldr	r6, [r1, #0]
  4076ae:	4913      	ldr	r1, [pc, #76]	; (4076fc <xTaskCheckForTimeOut+0x74>)
  4076b0:	1ab6      	subs	r6, r6, r2
  4076b2:	42b3      	cmp	r3, r6
  4076b4:	d90c      	bls.n	4076d0 <xTaskCheckForTimeOut+0x48>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
  4076b6:	680e      	ldr	r6, [r1, #0]
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
  4076b8:	6800      	ldr	r0, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
  4076ba:	6809      	ldr	r1, [r1, #0]
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
  4076bc:	1b9b      	subs	r3, r3, r6
  4076be:	441a      	add	r2, r3
  4076c0:	602a      	str	r2, [r5, #0]
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
  4076c2:	4b0f      	ldr	r3, [pc, #60]	; (407700 <xTaskCheckForTimeOut+0x78>)

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
	pxTimeOut->xTimeOnEntering = xTickCount;
  4076c4:	e884 0003 	stmia.w	r4, {r0, r1}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
  4076c8:	2500      	movs	r5, #0
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
  4076ca:	4798      	blx	r3

	return xReturn;
}
  4076cc:	4628      	mov	r0, r5
  4076ce:	bd70      	pop	{r4, r5, r6, pc}
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
  4076d0:	2501      	movs	r5, #1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
  4076d2:	4b0b      	ldr	r3, [pc, #44]	; (407700 <xTaskCheckForTimeOut+0x78>)
  4076d4:	4798      	blx	r3

	return xReturn;
}
  4076d6:	4628      	mov	r0, r5
  4076d8:	bd70      	pop	{r4, r5, r6, pc}
  4076da:	4908      	ldr	r1, [pc, #32]	; (4076fc <xTaskCheckForTimeOut+0x74>)
  4076dc:	6862      	ldr	r2, [r4, #4]
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
  4076de:	680e      	ldr	r6, [r1, #0]
  4076e0:	4906      	ldr	r1, [pc, #24]	; (4076fc <xTaskCheckForTimeOut+0x74>)
  4076e2:	1ab6      	subs	r6, r6, r2
  4076e4:	42b3      	cmp	r3, r6
  4076e6:	d8e6      	bhi.n	4076b6 <xTaskCheckForTimeOut+0x2e>
  4076e8:	e7f2      	b.n	4076d0 <xTaskCheckForTimeOut+0x48>
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
			{
				xReturn = pdFALSE;
  4076ea:	2500      	movs	r5, #0
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
  4076ec:	4b04      	ldr	r3, [pc, #16]	; (407700 <xTaskCheckForTimeOut+0x78>)
  4076ee:	4798      	blx	r3

	return xReturn;
}
  4076f0:	4628      	mov	r0, r5
  4076f2:	bd70      	pop	{r4, r5, r6, pc}
  4076f4:	004066e5 	.word	0x004066e5
  4076f8:	20003538 	.word	0x20003538
  4076fc:	200033cc 	.word	0x200033cc
  407700:	004066fd 	.word	0x004066fd

00407704 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
  407704:	4b01      	ldr	r3, [pc, #4]	; (40770c <vTaskMissedYield+0x8>)
  407706:	2201      	movs	r2, #1
  407708:	601a      	str	r2, [r3, #0]
  40770a:	4770      	bx	lr
  40770c:	200034ac 	.word	0x200034ac

00407710 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
  407710:	b168      	cbz	r0, 40772e <uxTaskGetStackHighWaterMark+0x1e>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
  407712:	6b03      	ldr	r3, [r0, #48]	; 0x30

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
  407714:	781a      	ldrb	r2, [r3, #0]
  407716:	2aa5      	cmp	r2, #165	; 0xa5

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0;
  407718:	f04f 0000 	mov.w	r0, #0

		while( *pucStackByte == tskSTACK_FILL_BYTE )
  40771c:	d10a      	bne.n	407734 <uxTaskGetStackHighWaterMark+0x24>
  40771e:	f813 2f01 	ldrb.w	r2, [r3, #1]!
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
  407722:	3001      	adds	r0, #1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
  407724:	2aa5      	cmp	r2, #165	; 0xa5
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
  407726:	b280      	uxth	r0, r0

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
  407728:	d0f9      	beq.n	40771e <uxTaskGetStackHighWaterMark+0xe>
  40772a:	0880      	lsrs	r0, r0, #2
  40772c:	4770      	bx	lr
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
  40772e:	4b02      	ldr	r3, [pc, #8]	; (407738 <uxTaskGetStackHighWaterMark+0x28>)
  407730:	6818      	ldr	r0, [r3, #0]
  407732:	e7ee      	b.n	407712 <uxTaskGetStackHighWaterMark+0x2>
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
  407734:	4770      	bx	lr
  407736:	bf00      	nop
  407738:	200034b8 	.word	0x200034b8

0040773c <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
  40773c:	4b01      	ldr	r3, [pc, #4]	; (407744 <xTaskGetCurrentTaskHandle+0x8>)
  40773e:	6818      	ldr	r0, [r3, #0]

		return xReturn;
	}
  407740:	4770      	bx	lr
  407742:	bf00      	nop
  407744:	200034b8 	.word	0x200034b8

00407748 <xTaskGetSchedulerState>:

	portBASE_TYPE xTaskGetSchedulerState( void )
	{
	portBASE_TYPE xReturn;

		if( xSchedulerRunning == pdFALSE )
  407748:	4b04      	ldr	r3, [pc, #16]	; (40775c <xTaskGetSchedulerState+0x14>)
  40774a:	6818      	ldr	r0, [r3, #0]
  40774c:	b128      	cbz	r0, 40775a <xTaskGetSchedulerState+0x12>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  40774e:	4b04      	ldr	r3, [pc, #16]	; (407760 <xTaskGetSchedulerState+0x18>)
  407750:	681b      	ldr	r3, [r3, #0]
  407752:	2b00      	cmp	r3, #0
			{
				xReturn = taskSCHEDULER_RUNNING;
  407754:	bf14      	ite	ne
  407756:	2002      	movne	r0, #2
  407758:	2001      	moveq	r0, #1
				xReturn = taskSCHEDULER_SUSPENDED;
			}
		}

		return xReturn;
	}
  40775a:	4770      	bx	lr
  40775c:	200034a8 	.word	0x200034a8
  407760:	2000352c 	.word	0x2000352c

00407764 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
  407764:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
  407766:	4d16      	ldr	r5, [pc, #88]	; (4077c0 <vTaskPriorityInherit+0x5c>)
  407768:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  40776a:	682a      	ldr	r2, [r5, #0]
  40776c:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
  40776e:	4293      	cmp	r3, r2
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
  407770:	4604      	mov	r4, r0
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
  407772:	d20f      	bcs.n	407794 <vTaskPriorityInherit+0x30>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
  407774:	682a      	ldr	r2, [r5, #0]

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
  407776:	4e13      	ldr	r6, [pc, #76]	; (4077c4 <vTaskPriorityInherit+0x60>)
		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
  407778:	6ad1      	ldr	r1, [r2, #44]	; 0x2c

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
  40777a:	6942      	ldr	r2, [r0, #20]
  40777c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  407780:	eb06 0383 	add.w	r3, r6, r3, lsl #2
		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
  407784:	f1c1 0108 	rsb	r1, r1, #8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
  407788:	429a      	cmp	r2, r3
		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
  40778a:	6181      	str	r1, [r0, #24]

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
  40778c:	d003      	beq.n	407796 <vTaskPriorityInherit+0x32>
				prvAddTaskToReadyQueue( pxTCB );
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  40778e:	682b      	ldr	r3, [r5, #0]
  407790:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  407792:	62c3      	str	r3, [r0, #44]	; 0x2c
  407794:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
  407796:	1d07      	adds	r7, r0, #4
  407798:	4638      	mov	r0, r7
  40779a:	4b0b      	ldr	r3, [pc, #44]	; (4077c8 <vTaskPriorityInherit+0x64>)
  40779c:	4798      	blx	r3

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  40779e:	682b      	ldr	r3, [r5, #0]
				prvAddTaskToReadyQueue( pxTCB );
  4077a0:	4a0a      	ldr	r2, [pc, #40]	; (4077cc <vTaskPriorityInherit+0x68>)
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
			{
				vListRemove( &( pxTCB->xGenericListItem ) );

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  4077a2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
				prvAddTaskToReadyQueue( pxTCB );
  4077a4:	6811      	ldr	r1, [r2, #0]
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
			{
				vListRemove( &( pxTCB->xGenericListItem ) );

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  4077a6:	62e3      	str	r3, [r4, #44]	; 0x2c
				prvAddTaskToReadyQueue( pxTCB );
  4077a8:	428b      	cmp	r3, r1
  4077aa:	eb03 0083 	add.w	r0, r3, r3, lsl #2
  4077ae:	bf88      	it	hi
  4077b0:	6013      	strhi	r3, [r2, #0]
  4077b2:	eb06 0080 	add.w	r0, r6, r0, lsl #2
  4077b6:	4639      	mov	r1, r7
  4077b8:	4b05      	ldr	r3, [pc, #20]	; (4077d0 <vTaskPriorityInherit+0x6c>)
  4077ba:	4798      	blx	r3
  4077bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  4077be:	bf00      	nop
  4077c0:	200034b8 	.word	0x200034b8
  4077c4:	200033d0 	.word	0x200033d0
  4077c8:	00406619 	.word	0x00406619
  4077cc:	200033c4 	.word	0x200033c4
  4077d0:	004065c1 	.word	0x004065c1

004077d4 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
  4077d4:	b538      	push	{r3, r4, r5, lr}
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
  4077d6:	4604      	mov	r4, r0
  4077d8:	b1c8      	cbz	r0, 40780e <vTaskPriorityDisinherit+0x3a>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
  4077da:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
  4077dc:	6c83      	ldr	r3, [r0, #72]	; 0x48
  4077de:	429a      	cmp	r2, r3
  4077e0:	d015      	beq.n	40780e <vTaskPriorityDisinherit+0x3a>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
  4077e2:	1d05      	adds	r5, r0, #4
  4077e4:	4628      	mov	r0, r5
  4077e6:	4b0a      	ldr	r3, [pc, #40]	; (407810 <vTaskPriorityDisinherit+0x3c>)
  4077e8:	4798      	blx	r3

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
				prvAddTaskToReadyQueue( pxTCB );
  4077ea:	4a0a      	ldr	r2, [pc, #40]	; (407814 <vTaskPriorityDisinherit+0x40>)
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
  4077ec:	6ca3      	ldr	r3, [r4, #72]	; 0x48
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
				prvAddTaskToReadyQueue( pxTCB );
  4077ee:	6811      	ldr	r1, [r2, #0]
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
  4077f0:	62e3      	str	r3, [r4, #44]	; 0x2c
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
  4077f2:	f1c3 0008 	rsb	r0, r3, #8
				prvAddTaskToReadyQueue( pxTCB );
  4077f6:	428b      	cmp	r3, r1
				vListRemove( &( pxTCB->xGenericListItem ) );

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
  4077f8:	61a0      	str	r0, [r4, #24]
				prvAddTaskToReadyQueue( pxTCB );
  4077fa:	4807      	ldr	r0, [pc, #28]	; (407818 <vTaskPriorityDisinherit+0x44>)
  4077fc:	bf88      	it	hi
  4077fe:	6013      	strhi	r3, [r2, #0]
  407800:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  407804:	4a05      	ldr	r2, [pc, #20]	; (40781c <vTaskPriorityDisinherit+0x48>)
  407806:	4629      	mov	r1, r5
  407808:	eb00 0083 	add.w	r0, r0, r3, lsl #2
  40780c:	4790      	blx	r2
  40780e:	bd38      	pop	{r3, r4, r5, pc}
  407810:	00406619 	.word	0x00406619
  407814:	200033c4 	.word	0x200033c4
  407818:	200033d0 	.word	0x200033d0
  40781c:	004065c1 	.word	0x004065c1

00407820 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
  407820:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
	{
		if( xTimerQueue == NULL )
  407822:	4c0d      	ldr	r4, [pc, #52]	; (407858 <prvCheckForValidListAndQueue+0x38>)
static void prvCheckForValidListAndQueue( void )
{
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
  407824:	4b0d      	ldr	r3, [pc, #52]	; (40785c <prvCheckForValidListAndQueue+0x3c>)
  407826:	4798      	blx	r3
	{
		if( xTimerQueue == NULL )
  407828:	6823      	ldr	r3, [r4, #0]
  40782a:	b113      	cbz	r3, 407832 <prvCheckForValidListAndQueue+0x12>
			pxCurrentTimerList = &xActiveTimerList1;
			pxOverflowTimerList = &xActiveTimerList2;
			xTimerQueue = xQueueCreate( ( unsigned portBASE_TYPE ) configTIMER_QUEUE_LENGTH, sizeof( xTIMER_MESSAGE ) );
		}
	}
	taskEXIT_CRITICAL();
  40782c:	4b0c      	ldr	r3, [pc, #48]	; (407860 <prvCheckForValidListAndQueue+0x40>)
  40782e:	4798      	blx	r3
  407830:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	initialised. */
	taskENTER_CRITICAL();
	{
		if( xTimerQueue == NULL )
		{
			vListInitialise( &xActiveTimerList1 );
  407832:	4e0c      	ldr	r6, [pc, #48]	; (407864 <prvCheckForValidListAndQueue+0x44>)
			vListInitialise( &xActiveTimerList2 );
  407834:	4d0c      	ldr	r5, [pc, #48]	; (407868 <prvCheckForValidListAndQueue+0x48>)
	initialised. */
	taskENTER_CRITICAL();
	{
		if( xTimerQueue == NULL )
		{
			vListInitialise( &xActiveTimerList1 );
  407836:	4f0d      	ldr	r7, [pc, #52]	; (40786c <prvCheckForValidListAndQueue+0x4c>)
  407838:	4630      	mov	r0, r6
  40783a:	47b8      	blx	r7
			vListInitialise( &xActiveTimerList2 );
  40783c:	4628      	mov	r0, r5
  40783e:	47b8      	blx	r7
			pxCurrentTimerList = &xActiveTimerList1;
  407840:	490b      	ldr	r1, [pc, #44]	; (407870 <prvCheckForValidListAndQueue+0x50>)
			pxOverflowTimerList = &xActiveTimerList2;
  407842:	4a0c      	ldr	r2, [pc, #48]	; (407874 <prvCheckForValidListAndQueue+0x54>)
	{
		if( xTimerQueue == NULL )
		{
			vListInitialise( &xActiveTimerList1 );
			vListInitialise( &xActiveTimerList2 );
			pxCurrentTimerList = &xActiveTimerList1;
  407844:	600e      	str	r6, [r1, #0]
			pxOverflowTimerList = &xActiveTimerList2;
			xTimerQueue = xQueueCreate( ( unsigned portBASE_TYPE ) configTIMER_QUEUE_LENGTH, sizeof( xTIMER_MESSAGE ) );
  407846:	4b0c      	ldr	r3, [pc, #48]	; (407878 <prvCheckForValidListAndQueue+0x58>)
		if( xTimerQueue == NULL )
		{
			vListInitialise( &xActiveTimerList1 );
			vListInitialise( &xActiveTimerList2 );
			pxCurrentTimerList = &xActiveTimerList1;
			pxOverflowTimerList = &xActiveTimerList2;
  407848:	6015      	str	r5, [r2, #0]
			xTimerQueue = xQueueCreate( ( unsigned portBASE_TYPE ) configTIMER_QUEUE_LENGTH, sizeof( xTIMER_MESSAGE ) );
  40784a:	210c      	movs	r1, #12
  40784c:	200f      	movs	r0, #15
  40784e:	4798      	blx	r3
		}
	}
	taskEXIT_CRITICAL();
  407850:	4b03      	ldr	r3, [pc, #12]	; (407860 <prvCheckForValidListAndQueue+0x40>)
		{
			vListInitialise( &xActiveTimerList1 );
			vListInitialise( &xActiveTimerList2 );
			pxCurrentTimerList = &xActiveTimerList1;
			pxOverflowTimerList = &xActiveTimerList2;
			xTimerQueue = xQueueCreate( ( unsigned portBASE_TYPE ) configTIMER_QUEUE_LENGTH, sizeof( xTIMER_MESSAGE ) );
  407852:	6020      	str	r0, [r4, #0]
		}
	}
	taskEXIT_CRITICAL();
  407854:	4798      	blx	r3
  407856:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  407858:	2000356c 	.word	0x2000356c
  40785c:	004066e5 	.word	0x004066e5
  407860:	004066fd 	.word	0x004066fd
  407864:	20003544 	.word	0x20003544
  407868:	20003558 	.word	0x20003558
  40786c:	004065a1 	.word	0x004065a1
  407870:	20003540 	.word	0x20003540
  407874:	20003574 	.word	0x20003574
  407878:	00406901 	.word	0x00406901

0040787c <prvInsertTimerInActiveList>:
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, portTickType xTimeNow, portTickType xCommandTime )
{
  40787c:	b510      	push	{r4, lr}
  40787e:	4604      	mov	r4, r0
portBASE_TYPE xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );

	if( xNextExpiryTime <= xTimeNow )
  407880:	4291      	cmp	r1, r2
static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, portTickType xTimeNow, portTickType xCommandTime )
{
portBASE_TYPE xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
  407882:	6120      	str	r0, [r4, #16]

static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, portTickType xTimeNow, portTickType xCommandTime )
{
portBASE_TYPE xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
  407884:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );

	if( xNextExpiryTime <= xTimeNow )
  407886:	d805      	bhi.n	407894 <prvInsertTimerInActiveList+0x18>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( portTickType ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks )
  407888:	6981      	ldr	r1, [r0, #24]
  40788a:	1ad2      	subs	r2, r2, r3
  40788c:	428a      	cmp	r2, r1
  40788e:	d30c      	bcc.n	4078aa <prvInsertTimerInActiveList+0x2e>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
  407890:	2001      	movs	r0, #1
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
		}
	}

	return xProcessTimerNow;
}
  407892:	bd10      	pop	{r4, pc}
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
  407894:	429a      	cmp	r2, r3
  407896:	d201      	bcs.n	40789c <prvInsertTimerInActiveList+0x20>
  407898:	4299      	cmp	r1, r3
  40789a:	d2f9      	bcs.n	407890 <prvInsertTimerInActiveList+0x14>
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
  40789c:	4a04      	ldr	r2, [pc, #16]	; (4078b0 <prvInsertTimerInActiveList+0x34>)
  40789e:	6810      	ldr	r0, [r2, #0]
  4078a0:	4b04      	ldr	r3, [pc, #16]	; (4078b4 <prvInsertTimerInActiveList+0x38>)
  4078a2:	1d21      	adds	r1, r4, #4
  4078a4:	4798      	blx	r3
}
/*-----------------------------------------------------------*/

static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, portTickType xTimeNow, portTickType xCommandTime )
{
portBASE_TYPE xProcessTimerNow = pdFALSE;
  4078a6:	2000      	movs	r0, #0
  4078a8:	bd10      	pop	{r4, pc}
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
  4078aa:	4a03      	ldr	r2, [pc, #12]	; (4078b8 <prvInsertTimerInActiveList+0x3c>)
  4078ac:	e7f7      	b.n	40789e <prvInsertTimerInActiveList+0x22>
  4078ae:	bf00      	nop
  4078b0:	20003540 	.word	0x20003540
  4078b4:	004065dd 	.word	0x004065dd
  4078b8:	20003574 	.word	0x20003574

004078bc <xTimerCreateTimerTask>:
static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty ) PRIVILEGED_FUNCTION;

/*-----------------------------------------------------------*/

portBASE_TYPE xTimerCreateTimerTask( void )
{
  4078bc:	b510      	push	{r4, lr}

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
  4078be:	4b0a      	ldr	r3, [pc, #40]	; (4078e8 <xTimerCreateTimerTask+0x2c>)
static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty ) PRIVILEGED_FUNCTION;

/*-----------------------------------------------------------*/

portBASE_TYPE xTimerCreateTimerTask( void )
{
  4078c0:	b084      	sub	sp, #16

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
  4078c2:	4798      	blx	r3

	if( xTimerQueue != NULL )
  4078c4:	4b09      	ldr	r3, [pc, #36]	; (4078ec <xTimerCreateTimerTask+0x30>)
  4078c6:	6818      	ldr	r0, [r3, #0]
  4078c8:	b158      	cbz	r0, 4078e2 <xTimerCreateTimerTask+0x26>
	{
		xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) configTIMER_TASK_STACK_DEPTH, NULL, ( unsigned portBASE_TYPE ) configTIMER_TASK_PRIORITY, NULL);
  4078ca:	2300      	movs	r3, #0
  4078cc:	2201      	movs	r2, #1
  4078ce:	e88d 000c 	stmia.w	sp, {r2, r3}
  4078d2:	9302      	str	r3, [sp, #8]
  4078d4:	9303      	str	r3, [sp, #12]
  4078d6:	4806      	ldr	r0, [pc, #24]	; (4078f0 <xTimerCreateTimerTask+0x34>)
  4078d8:	4906      	ldr	r1, [pc, #24]	; (4078f4 <xTimerCreateTimerTask+0x38>)
  4078da:	4c07      	ldr	r4, [pc, #28]	; (4078f8 <xTimerCreateTimerTask+0x3c>)
  4078dc:	f44f 7280 	mov.w	r2, #256	; 0x100
  4078e0:	47a0      	blx	r4
	}

	configASSERT( xReturn );
	return xReturn;
}
  4078e2:	b004      	add	sp, #16
  4078e4:	bd10      	pop	{r4, pc}
  4078e6:	bf00      	nop
  4078e8:	00407821 	.word	0x00407821
  4078ec:	2000356c 	.word	0x2000356c
  4078f0:	00407a31 	.word	0x00407a31
  4078f4:	004165b4 	.word	0x004165b4
  4078f8:	00406dcd 	.word	0x00406dcd

004078fc <xTimerCreate>:
/*-----------------------------------------------------------*/

xTimerHandle xTimerCreate( const signed char *pcTimerName, portTickType xTimerPeriodInTicks, unsigned portBASE_TYPE uxAutoReload, void *pvTimerID, tmrTIMER_CALLBACK pxCallbackFunction )
{
  4078fc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
xTIMER *pxNewTimer;

	/* Allocate the timer structure. */
	if( xTimerPeriodInTicks == ( portTickType ) 0U )
  407900:	460d      	mov	r5, r1
	return xReturn;
}
/*-----------------------------------------------------------*/

xTimerHandle xTimerCreate( const signed char *pcTimerName, portTickType xTimerPeriodInTicks, unsigned portBASE_TYPE uxAutoReload, void *pvTimerID, tmrTIMER_CALLBACK pxCallbackFunction )
{
  407902:	4680      	mov	r8, r0
  407904:	4617      	mov	r7, r2
  407906:	461e      	mov	r6, r3
xTIMER *pxNewTimer;

	/* Allocate the timer structure. */
	if( xTimerPeriodInTicks == ( portTickType ) 0U )
  407908:	b199      	cbz	r1, 407932 <xTimerCreate+0x36>
		pxNewTimer = NULL;
		configASSERT( ( xTimerPeriodInTicks > 0 ) );
	}
	else
	{
		pxNewTimer = ( xTIMER * ) pvPortMalloc( sizeof( xTIMER ) );
  40790a:	2028      	movs	r0, #40	; 0x28
  40790c:	4b0b      	ldr	r3, [pc, #44]	; (40793c <xTimerCreate+0x40>)
  40790e:	4798      	blx	r3
		if( pxNewTimer != NULL )
  407910:	4604      	mov	r4, r0
  407912:	b158      	cbz	r0, 40792c <xTimerCreate+0x30>
		{
			/* Ensure the infrastructure used by the timer service task has been
			created/initialised. */
			prvCheckForValidListAndQueue();
  407914:	4b0a      	ldr	r3, [pc, #40]	; (407940 <xTimerCreate+0x44>)
  407916:	4798      	blx	r3
			/* Initialise the timer structure members using the function parameters. */
			pxNewTimer->pcTimerName = pcTimerName;
			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
			pxNewTimer->uxAutoReload = uxAutoReload;
			pxNewTimer->pvTimerID = pvTimerID;
			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
  407918:	9b06      	ldr	r3, [sp, #24]
  40791a:	6263      	str	r3, [r4, #36]	; 0x24
			/* Ensure the infrastructure used by the timer service task has been
			created/initialised. */
			prvCheckForValidListAndQueue();

			/* Initialise the timer structure members using the function parameters. */
			pxNewTimer->pcTimerName = pcTimerName;
  40791c:	f8c4 8000 	str.w	r8, [r4]
			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
  407920:	61a5      	str	r5, [r4, #24]
			pxNewTimer->uxAutoReload = uxAutoReload;
  407922:	61e7      	str	r7, [r4, #28]
			pxNewTimer->pvTimerID = pvTimerID;
  407924:	6226      	str	r6, [r4, #32]
			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
			vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
  407926:	1d20      	adds	r0, r4, #4
  407928:	4b06      	ldr	r3, [pc, #24]	; (407944 <xTimerCreate+0x48>)
  40792a:	4798      	blx	r3
			traceTIMER_CREATE_FAILED();
		}
	}

	return ( xTimerHandle ) pxNewTimer;
}
  40792c:	4620      	mov	r0, r4
  40792e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
xTIMER *pxNewTimer;

	/* Allocate the timer structure. */
	if( xTimerPeriodInTicks == ( portTickType ) 0U )
	{
		pxNewTimer = NULL;
  407932:	460c      	mov	r4, r1
			traceTIMER_CREATE_FAILED();
		}
	}

	return ( xTimerHandle ) pxNewTimer;
}
  407934:	4620      	mov	r0, r4
  407936:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40793a:	bf00      	nop
  40793c:	00406779 	.word	0x00406779
  407940:	00407821 	.word	0x00407821
  407944:	004065b9 	.word	0x004065b9

00407948 <xTimerGenericCommand>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOptionalValue, portBASE_TYPE *pxHigherPriorityTaskWoken, portTickType xBlockTime )
{
  407948:	b530      	push	{r4, r5, lr}
portBASE_TYPE xReturn = pdFAIL;
xTIMER_MESSAGE xMessage;

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
  40794a:	4d12      	ldr	r5, [pc, #72]	; (407994 <xTimerGenericCommand+0x4c>)
  40794c:	682c      	ldr	r4, [r5, #0]
	return ( xTimerHandle ) pxNewTimer;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOptionalValue, portBASE_TYPE *pxHigherPriorityTaskWoken, portTickType xBlockTime )
{
  40794e:	b087      	sub	sp, #28
portBASE_TYPE xReturn = pdFAIL;
xTIMER_MESSAGE xMessage;

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
  407950:	b1bc      	cbz	r4, 407982 <xTimerGenericCommand+0x3a>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
  407952:	9103      	str	r1, [sp, #12]
		xMessage.xMessageValue = xOptionalValue;
  407954:	9204      	str	r2, [sp, #16]
		xMessage.pxTimer = ( xTIMER * ) xTimer;
  407956:	9005      	str	r0, [sp, #20]

		if( pxHigherPriorityTaskWoken == NULL )
  407958:	b13b      	cbz	r3, 40796a <xTimerGenericCommand+0x22>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
  40795a:	4620      	mov	r0, r4
  40795c:	461a      	mov	r2, r3
  40795e:	a903      	add	r1, sp, #12
  407960:	2300      	movs	r3, #0
  407962:	4c0d      	ldr	r4, [pc, #52]	; (407998 <xTimerGenericCommand+0x50>)
  407964:	47a0      	blx	r4

		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
	}

	return xReturn;
}
  407966:	b007      	add	sp, #28
  407968:	bd30      	pop	{r4, r5, pc}
		xMessage.xMessageValue = xOptionalValue;
		xMessage.pxTimer = ( xTIMER * ) xTimer;

		if( pxHigherPriorityTaskWoken == NULL )
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
  40796a:	9301      	str	r3, [sp, #4]
  40796c:	4a0b      	ldr	r2, [pc, #44]	; (40799c <xTimerGenericCommand+0x54>)
  40796e:	4790      	blx	r2
  407970:	2801      	cmp	r0, #1
  407972:	9b01      	ldr	r3, [sp, #4]
  407974:	d008      	beq.n	407988 <xTimerGenericCommand+0x40>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xBlockTime );
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
  407976:	461a      	mov	r2, r3
  407978:	6828      	ldr	r0, [r5, #0]
  40797a:	4c09      	ldr	r4, [pc, #36]	; (4079a0 <xTimerGenericCommand+0x58>)
  40797c:	a903      	add	r1, sp, #12
  40797e:	47a0      	blx	r4
  407980:	e7f1      	b.n	407966 <xTimerGenericCommand+0x1e>
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOptionalValue, portBASE_TYPE *pxHigherPriorityTaskWoken, portTickType xBlockTime )
{
portBASE_TYPE xReturn = pdFAIL;
  407982:	4620      	mov	r0, r4

		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
	}

	return xReturn;
}
  407984:	b007      	add	sp, #28
  407986:	bd30      	pop	{r4, r5, pc}

		if( pxHigherPriorityTaskWoken == NULL )
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xBlockTime );
  407988:	6828      	ldr	r0, [r5, #0]
  40798a:	4c05      	ldr	r4, [pc, #20]	; (4079a0 <xTimerGenericCommand+0x58>)
  40798c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  40798e:	a903      	add	r1, sp, #12
  407990:	47a0      	blx	r4
  407992:	e7e8      	b.n	407966 <xTimerGenericCommand+0x1e>
  407994:	2000356c 	.word	0x2000356c
  407998:	00406ad9 	.word	0x00406ad9
  40799c:	00407749 	.word	0x00407749
  4079a0:	00406979 	.word	0x00406979

004079a4 <prvSwitchTimerLists.isra.1>:
		}
	}
}
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( portTickType xLastTime )
  4079a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4079a8:	4e1c      	ldr	r6, [pc, #112]	; (407a1c <prvSwitchTimerLists.isra.1+0x78>)
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );

		/* Remove the timer from the list. */
		pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
		vListRemove( &( pxTimer->xTimerListItem ) );
  4079aa:	4f1d      	ldr	r7, [pc, #116]	; (407a20 <prvSwitchTimerLists.isra.1+0x7c>)
		}
	}
}
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( portTickType xLastTime )
  4079ac:	b083      	sub	sp, #12

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
  4079ae:	46b0      	mov	r8, r6
  4079b0:	e00d      	b.n	4079ce <prvSwitchTimerLists.isra.1+0x2a>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
  4079b2:	68da      	ldr	r2, [r3, #12]
  4079b4:	f8d2 9000 	ldr.w	r9, [r2]

		/* Remove the timer from the list. */
		pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
  4079b8:	68db      	ldr	r3, [r3, #12]
  4079ba:	68dc      	ldr	r4, [r3, #12]
		vListRemove( &( pxTimer->xTimerListItem ) );
  4079bc:	1d25      	adds	r5, r4, #4
  4079be:	4628      	mov	r0, r5
  4079c0:	47b8      	blx	r7

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
  4079c2:	6a63      	ldr	r3, [r4, #36]	; 0x24
  4079c4:	4620      	mov	r0, r4
  4079c6:	4798      	blx	r3

		if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
  4079c8:	69e3      	ldr	r3, [r4, #28]
  4079ca:	2b01      	cmp	r3, #1
  4079cc:	d00b      	beq.n	4079e6 <prvSwitchTimerLists.isra.1+0x42>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
  4079ce:	6833      	ldr	r3, [r6, #0]
  4079d0:	4912      	ldr	r1, [pc, #72]	; (407a1c <prvSwitchTimerLists.isra.1+0x78>)
  4079d2:	681a      	ldr	r2, [r3, #0]
  4079d4:	2a00      	cmp	r2, #0
  4079d6:	d1ec      	bne.n	4079b2 <prvSwitchTimerLists.isra.1+0xe>
			}
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
  4079d8:	4a12      	ldr	r2, [pc, #72]	; (407a24 <prvSwitchTimerLists.isra.1+0x80>)
  4079da:	6810      	ldr	r0, [r2, #0]
  4079dc:	6008      	str	r0, [r1, #0]
	pxOverflowTimerList = pxTemp;
  4079de:	6013      	str	r3, [r2, #0]
}
  4079e0:	b003      	add	sp, #12
  4079e2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
  4079e6:	69a3      	ldr	r3, [r4, #24]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
  4079e8:	f8df c03c 	ldr.w	ip, [pc, #60]	; 407a28 <prvSwitchTimerLists.isra.1+0x84>
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
			if( xReloadTime > xNextExpireTime )
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
  4079ec:	f8df a03c 	ldr.w	sl, [pc, #60]	; 407a2c <prvSwitchTimerLists.isra.1+0x88>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
  4079f0:	eb09 0b03 	add.w	fp, r9, r3
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
  4079f4:	f04f 0e00 	mov.w	lr, #0
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
			if( xReloadTime > xNextExpireTime )
  4079f8:	45cb      	cmp	fp, r9
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
  4079fa:	4671      	mov	r1, lr
  4079fc:	4620      	mov	r0, r4
  4079fe:	464a      	mov	r2, r9
  407a00:	4673      	mov	r3, lr
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
			if( xReloadTime > xNextExpireTime )
  407a02:	d907      	bls.n	407a14 <prvSwitchTimerLists.isra.1+0x70>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
  407a04:	f8c4 b004 	str.w	fp, [r4, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
  407a08:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
  407a0a:	f8d8 0000 	ldr.w	r0, [r8]
  407a0e:	4629      	mov	r1, r5
  407a10:	47d0      	blx	sl
  407a12:	e7dc      	b.n	4079ce <prvSwitchTimerLists.isra.1+0x2a>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
  407a14:	f8cd e000 	str.w	lr, [sp]
  407a18:	47e0      	blx	ip
  407a1a:	e7d8      	b.n	4079ce <prvSwitchTimerLists.isra.1+0x2a>
  407a1c:	20003540 	.word	0x20003540
  407a20:	00406619 	.word	0x00406619
  407a24:	20003574 	.word	0x20003574
  407a28:	00407949 	.word	0x00407949
  407a2c:	004065dd 	.word	0x004065dd

00407a30 <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
  407a30:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  407a34:	f8df 817c 	ldr.w	r8, [pc, #380]	; 407bb4 <prvTimerTask+0x184>
  407a38:	f8df 917c 	ldr.w	r9, [pc, #380]	; 407bb8 <prvTimerTask+0x188>
  407a3c:	4e52      	ldr	r6, [pc, #328]	; (407b88 <prvTimerTask+0x158>)
  407a3e:	f8df a17c 	ldr.w	sl, [pc, #380]	; 407bbc <prvTimerTask+0x18c>
  407a42:	4f52      	ldr	r7, [pc, #328]	; (407b8c <prvTimerTask+0x15c>)
  407a44:	b089      	sub	sp, #36	; 0x24
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
  407a46:	4a52      	ldr	r2, [pc, #328]	; (407b90 <prvTimerTask+0x160>)
  407a48:	6813      	ldr	r3, [r2, #0]
  407a4a:	681d      	ldr	r5, [r3, #0]
  407a4c:	f1d5 0501 	rsbs	r5, r5, #1
  407a50:	bf38      	it	cc
  407a52:	2500      	movcc	r5, #0
	if( *pxListWasEmpty == pdFALSE )
  407a54:	2d00      	cmp	r5, #0
  407a56:	d15b      	bne.n	407b10 <prvTimerTask+0xe0>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
  407a58:	68db      	ldr	r3, [r3, #12]
  407a5a:	f8d3 b000 	ldr.w	fp, [r3]
static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty )
{
portTickType xTimeNow;
portBASE_TYPE xTimerListsWereSwitched;

	vTaskSuspendAll();
  407a5e:	4b4d      	ldr	r3, [pc, #308]	; (407b94 <prvTimerTask+0x164>)
static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched )
{
portTickType xTimeNow;
static portTickType xLastTime = ( portTickType ) 0U;

	xTimeNow = xTaskGetTickCount();
  407a60:	4c4d      	ldr	r4, [pc, #308]	; (407b98 <prvTimerTask+0x168>)
static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty )
{
portTickType xTimeNow;
portBASE_TYPE xTimerListsWereSwitched;

	vTaskSuspendAll();
  407a62:	4798      	blx	r3
static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched )
{
portTickType xTimeNow;
static portTickType xLastTime = ( portTickType ) 0U;

	xTimeNow = xTaskGetTickCount();
  407a64:	47a0      	blx	r4

	if( xTimeNow < xLastTime )
  407a66:	4a4d      	ldr	r2, [pc, #308]	; (407b9c <prvTimerTask+0x16c>)
  407a68:	6813      	ldr	r3, [r2, #0]
  407a6a:	4298      	cmp	r0, r3
static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched )
{
portTickType xTimeNow;
static portTickType xLastTime = ( portTickType ) 0U;

	xTimeNow = xTaskGetTickCount();
  407a6c:	4604      	mov	r4, r0

	if( xTimeNow < xLastTime )
  407a6e:	d355      	bcc.n	407b1c <prvTimerTask+0xec>
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
	}

	xLastTime = xTimeNow;
  407a70:	4a4a      	ldr	r2, [pc, #296]	; (407b9c <prvTimerTask+0x16c>)
  407a72:	6010      	str	r0, [r2, #0]
		prvSampelTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
		if( xTimerListsWereSwitched == pdFALSE )
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
  407a74:	b90d      	cbnz	r5, 407a7a <prvTimerTask+0x4a>
  407a76:	45a3      	cmp	fp, r4
  407a78:	d95a      	bls.n	407b30 <prvTimerTask+0x100>
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
  407a7a:	ebc4 010b 	rsb	r1, r4, fp
  407a7e:	6830      	ldr	r0, [r6, #0]
  407a80:	4a47      	ldr	r2, [pc, #284]	; (407ba0 <prvTimerTask+0x170>)
  407a82:	4790      	blx	r2

				if( xTaskResumeAll() == pdFALSE )
  407a84:	4b47      	ldr	r3, [pc, #284]	; (407ba4 <prvTimerTask+0x174>)
  407a86:	4798      	blx	r3
  407a88:	2800      	cmp	r0, #0
  407a8a:	d04e      	beq.n	407b2a <prvTimerTask+0xfa>
static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched )
{
portTickType xTimeNow;
static portTickType xLastTime = ( portTickType ) 0U;

	xTimeNow = xTaskGetTickCount();
  407a8c:	4a42      	ldr	r2, [pc, #264]	; (407b98 <prvTimerTask+0x168>)

	if( xTimeNow < xLastTime )
  407a8e:	4c43      	ldr	r4, [pc, #268]	; (407b9c <prvTimerTask+0x16c>)
static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched )
{
portTickType xTimeNow;
static portTickType xLastTime = ( portTickType ) 0U;

	xTimeNow = xTaskGetTickCount();
  407a90:	4790      	blx	r2

	if( xTimeNow < xLastTime )
  407a92:	6823      	ldr	r3, [r4, #0]
  407a94:	4298      	cmp	r0, r3
static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched )
{
portTickType xTimeNow;
static portTickType xLastTime = ( portTickType ) 0U;

	xTimeNow = xTaskGetTickCount();
  407a96:	4683      	mov	fp, r0

	if( xTimeNow < xLastTime )
  407a98:	d33d      	bcc.n	407b16 <prvTimerTask+0xe6>
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
	}

	xLastTime = xTimeNow;
  407a9a:	4b40      	ldr	r3, [pc, #256]	; (407b9c <prvTimerTask+0x16c>)
  407a9c:	f8c3 b000 	str.w	fp, [r3]

	/* In this case the xTimerListsWereSwitched parameter is not used, but it
	must be present in the function call. */
	xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
  407aa0:	2200      	movs	r2, #0
  407aa2:	4613      	mov	r3, r2
  407aa4:	6830      	ldr	r0, [r6, #0]
  407aa6:	a905      	add	r1, sp, #20
  407aa8:	47b8      	blx	r7
  407aaa:	2800      	cmp	r0, #0
  407aac:	d0cb      	beq.n	407a46 <prvTimerTask+0x16>
	{
		pxTimer = xMessage.pxTimer;
  407aae:	9c07      	ldr	r4, [sp, #28]

		/* Is the timer already in a list of active timers?  When the command
		is trmCOMMAND_PROCESS_TIMER_OVERFLOW, the timer will be NULL as the
		command is to the task rather than to an individual timer. */
		if( pxTimer != NULL )
  407ab0:	b11c      	cbz	r4, 407aba <prvTimerTask+0x8a>
		{
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
  407ab2:	6963      	ldr	r3, [r4, #20]
  407ab4:	b10b      	cbz	r3, 407aba <prvTimerTask+0x8a>
			{
				/* The timer is in a list, remove it. */
				vListRemove( &( pxTimer->xTimerListItem ) );
  407ab6:	1d20      	adds	r0, r4, #4
  407ab8:	47c0      	blx	r8
			}
		}

		traceTIMER_COMMAND_RECEIVED( pxTimer, xMessage.xMessageID, xMessage.xMessageValue );

		switch( xMessage.xMessageID )
  407aba:	9d05      	ldr	r5, [sp, #20]
  407abc:	2d02      	cmp	r5, #2
  407abe:	d01f      	beq.n	407b00 <prvTimerTask+0xd0>
  407ac0:	2d03      	cmp	r5, #3
  407ac2:	d01a      	beq.n	407afa <prvTimerTask+0xca>
  407ac4:	2d00      	cmp	r5, #0
  407ac6:	d1eb      	bne.n	407aa0 <prvTimerTask+0x70>
		{
			case tmrCOMMAND_START :
				/* Start or restart a timer. */
				if( prvInsertTimerInActiveList( pxTimer,  xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.xMessageValue ) == pdTRUE )
  407ac8:	9a06      	ldr	r2, [sp, #24]
  407aca:	69a1      	ldr	r1, [r4, #24]
  407acc:	4613      	mov	r3, r2
  407ace:	4411      	add	r1, r2
  407ad0:	4620      	mov	r0, r4
  407ad2:	465a      	mov	r2, fp
  407ad4:	47c8      	blx	r9
  407ad6:	2801      	cmp	r0, #1
  407ad8:	d1e2      	bne.n	407aa0 <prvTimerTask+0x70>
				{
					/* The timer expired before it was added to the active timer
					list.  Process it now. */
					pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
  407ada:	6a63      	ldr	r3, [r4, #36]	; 0x24
  407adc:	4620      	mov	r0, r4
  407ade:	4798      	blx	r3

					if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
  407ae0:	69e3      	ldr	r3, [r4, #28]
  407ae2:	2b01      	cmp	r3, #1
  407ae4:	d1dc      	bne.n	407aa0 <prvTimerTask+0x70>
					{
						xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
  407ae6:	69a2      	ldr	r2, [r4, #24]
  407ae8:	9b06      	ldr	r3, [sp, #24]
  407aea:	9500      	str	r5, [sp, #0]
  407aec:	441a      	add	r2, r3
  407aee:	4629      	mov	r1, r5
  407af0:	4620      	mov	r0, r4
  407af2:	462b      	mov	r3, r5
  407af4:	4c2c      	ldr	r4, [pc, #176]	; (407ba8 <prvTimerTask+0x178>)
  407af6:	47a0      	blx	r4
  407af8:	e7d2      	b.n	407aa0 <prvTimerTask+0x70>
				break;

			case tmrCOMMAND_DELETE :
				/* The timer has already been removed from the active list,
				just free up the memory. */
				vPortFree( pxTimer );
  407afa:	4620      	mov	r0, r4
  407afc:	47d0      	blx	sl
  407afe:	e7cf      	b.n	407aa0 <prvTimerTask+0x70>
				/* The timer has already been removed from the active list.
				There is nothing to do here. */
				break;

			case tmrCOMMAND_CHANGE_PERIOD :
				pxTimer->xTimerPeriodInTicks = xMessage.xMessageValue;
  407b00:	9906      	ldr	r1, [sp, #24]
  407b02:	61a1      	str	r1, [r4, #24]
				configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
				prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
  407b04:	4620      	mov	r0, r4
  407b06:	4459      	add	r1, fp
  407b08:	465a      	mov	r2, fp
  407b0a:	465b      	mov	r3, fp
  407b0c:	47c8      	blx	r9
  407b0e:	e7c7      	b.n	407aa0 <prvTimerTask+0x70>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( portTickType ) 0U;
  407b10:	f04f 0b00 	mov.w	fp, #0
  407b14:	e7a3      	b.n	407a5e <prvTimerTask+0x2e>

	xTimeNow = xTaskGetTickCount();

	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists( xLastTime );
  407b16:	4a25      	ldr	r2, [pc, #148]	; (407bac <prvTimerTask+0x17c>)
  407b18:	4790      	blx	r2
  407b1a:	e7be      	b.n	407a9a <prvTimerTask+0x6a>
  407b1c:	4b23      	ldr	r3, [pc, #140]	; (407bac <prvTimerTask+0x17c>)
  407b1e:	4798      	blx	r3
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
	}

	xLastTime = xTimeNow;
  407b20:	4a1e      	ldr	r2, [pc, #120]	; (407b9c <prvTimerTask+0x16c>)
				}
			}
		}
		else
		{
			xTaskResumeAll();
  407b22:	4b20      	ldr	r3, [pc, #128]	; (407ba4 <prvTimerTask+0x174>)
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
	}

	xLastTime = xTimeNow;
  407b24:	6014      	str	r4, [r2, #0]
				}
			}
		}
		else
		{
			xTaskResumeAll();
  407b26:	4798      	blx	r3
  407b28:	e7b0      	b.n	407a8c <prvTimerTask+0x5c>
				{
					/* Yield to wait for either a command to arrive, or the block time
					to expire.  If a command arrived between the critical section being
					exited and this yield then the yield will not cause the task
					to block. */
					portYIELD_WITHIN_API();
  407b2a:	4c21      	ldr	r4, [pc, #132]	; (407bb0 <prvTimerTask+0x180>)
  407b2c:	47a0      	blx	r4
  407b2e:	e7ad      	b.n	407a8c <prvTimerTask+0x5c>
		if( xTimerListsWereSwitched == pdFALSE )
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
			{
				xTaskResumeAll();
  407b30:	4a1c      	ldr	r2, [pc, #112]	; (407ba4 <prvTimerTask+0x174>)
  407b32:	4790      	blx	r2
xTIMER *pxTimer;
portBASE_TYPE xResult;

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
  407b34:	4a16      	ldr	r2, [pc, #88]	; (407b90 <prvTimerTask+0x160>)
  407b36:	6813      	ldr	r3, [r2, #0]
  407b38:	68db      	ldr	r3, [r3, #12]
  407b3a:	f8d3 c00c 	ldr.w	ip, [r3, #12]
	vListRemove( &( pxTimer->xTimerListItem ) );
  407b3e:	f8cd c00c 	str.w	ip, [sp, #12]
  407b42:	f10c 0004 	add.w	r0, ip, #4
  407b46:	47c0      	blx	r8
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
  407b48:	f8dd c00c 	ldr.w	ip, [sp, #12]
  407b4c:	f8dc 301c 	ldr.w	r3, [ip, #28]
  407b50:	2b01      	cmp	r3, #1
  407b52:	d004      	beq.n	407b5e <prvTimerTask+0x12e>
			( void ) xResult;
		}
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
  407b54:	f8dc 3024 	ldr.w	r3, [ip, #36]	; 0x24
  407b58:	4660      	mov	r0, ip
  407b5a:	4798      	blx	r3
  407b5c:	e796      	b.n	407a8c <prvTimerTask+0x5c>
		a time relative to anything other than the current time.  It
		will therefore be inserted into the correct list relative to
		the time this task thinks it is now, even if a command to
		switch lists due to a tick count overflow is already waiting in
		the timer queue. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
  407b5e:	f8dc 1018 	ldr.w	r1, [ip, #24]
  407b62:	4660      	mov	r0, ip
  407b64:	4622      	mov	r2, r4
  407b66:	4459      	add	r1, fp
  407b68:	465b      	mov	r3, fp
  407b6a:	47c8      	blx	r9
  407b6c:	2801      	cmp	r0, #1
  407b6e:	f8dd c00c 	ldr.w	ip, [sp, #12]
  407b72:	d1ef      	bne.n	407b54 <prvTimerTask+0x124>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
  407b74:	4660      	mov	r0, ip
  407b76:	4629      	mov	r1, r5
  407b78:	9500      	str	r5, [sp, #0]
  407b7a:	465a      	mov	r2, fp
  407b7c:	462b      	mov	r3, r5
  407b7e:	4c0a      	ldr	r4, [pc, #40]	; (407ba8 <prvTimerTask+0x178>)
  407b80:	47a0      	blx	r4
  407b82:	f8dd c00c 	ldr.w	ip, [sp, #12]
  407b86:	e7e5      	b.n	407b54 <prvTimerTask+0x124>
  407b88:	2000356c 	.word	0x2000356c
  407b8c:	00406b35 	.word	0x00406b35
  407b90:	20003540 	.word	0x20003540
  407b94:	00407091 	.word	0x00407091
  407b98:	004070a1 	.word	0x004070a1
  407b9c:	20003570 	.word	0x20003570
  407ba0:	00406ca5 	.word	0x00406ca5
  407ba4:	004071f9 	.word	0x004071f9
  407ba8:	00407949 	.word	0x00407949
  407bac:	004079a5 	.word	0x004079a5
  407bb0:	004066d5 	.word	0x004066d5
  407bb4:	00406619 	.word	0x00406619
  407bb8:	0040787d 	.word	0x0040787d
  407bbc:	0040679d 	.word	0x0040679d

00407bc0 <xTimerIsTimerActive>:
	taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerIsTimerActive( xTimerHandle xTimer )
{
  407bc0:	b510      	push	{r4, lr}
  407bc2:	4604      	mov	r4, r0
portBASE_TYPE xTimerIsInActiveList;
xTIMER *pxTimer = ( xTIMER * ) xTimer;

	/* Is the timer in the list of active timers? */
	taskENTER_CRITICAL();
  407bc4:	4b04      	ldr	r3, [pc, #16]	; (407bd8 <xTimerIsTimerActive+0x18>)
  407bc6:	4798      	blx	r3
	{
		/* Checking to see if it is in the NULL list in effect checks to see if
		it is referenced from either the current or the overflow timer lists in
		one go, but the logic has to be reversed, hence the '!'. */
		xTimerIsInActiveList = !( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) );
  407bc8:	6964      	ldr	r4, [r4, #20]
	}
	taskEXIT_CRITICAL();
  407bca:	4b04      	ldr	r3, [pc, #16]	; (407bdc <xTimerIsTimerActive+0x1c>)
	taskENTER_CRITICAL();
	{
		/* Checking to see if it is in the NULL list in effect checks to see if
		it is referenced from either the current or the overflow timer lists in
		one go, but the logic has to be reversed, hence the '!'. */
		xTimerIsInActiveList = !( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) );
  407bcc:	3400      	adds	r4, #0
  407bce:	bf18      	it	ne
  407bd0:	2401      	movne	r4, #1
	}
	taskEXIT_CRITICAL();
  407bd2:	4798      	blx	r3

	return xTimerIsInActiveList;
}
  407bd4:	4620      	mov	r0, r4
  407bd6:	bd10      	pop	{r4, pc}
  407bd8:	004066e5 	.word	0x004066e5
  407bdc:	004066fd 	.word	0x004066fd

00407be0 <usart_serial_getchar>:
 * \param p_usart   Base address of the USART instance.
 * \param data   Data to read
 *
 */
static inline void usart_serial_getchar(usart_if p_usart, uint8_t *data)
{
  407be0:	b570      	push	{r4, r5, r6, lr}
	if (UART == (Uart*)p_usart) {
		while (uart_read((Uart*)p_usart, data));
	}
#else
# ifdef UART0
	if (UART0 == (Uart*)p_usart) {
  407be2:	4b1b      	ldr	r3, [pc, #108]	; (407c50 <usart_serial_getchar+0x70>)
 * \param p_usart   Base address of the USART instance.
 * \param data   Data to read
 *
 */
static inline void usart_serial_getchar(usart_if p_usart, uint8_t *data)
{
  407be4:	b082      	sub	sp, #8
	uint32_t val = 0;
  407be6:	2200      	movs	r2, #0
	if (UART == (Uart*)p_usart) {
		while (uart_read((Uart*)p_usart, data));
	}
#else
# ifdef UART0
	if (UART0 == (Uart*)p_usart) {
  407be8:	4298      	cmp	r0, r3
 * \param p_usart   Base address of the USART instance.
 * \param data   Data to read
 *
 */
static inline void usart_serial_getchar(usart_if p_usart, uint8_t *data)
{
  407bea:	460c      	mov	r4, r1
	uint32_t val = 0;
  407bec:	9201      	str	r2, [sp, #4]
	if (UART == (Uart*)p_usart) {
		while (uart_read((Uart*)p_usart, data));
	}
#else
# ifdef UART0
	if (UART0 == (Uart*)p_usart) {
  407bee:	d01f      	beq.n	407c30 <usart_serial_getchar+0x50>
		while (uart_read((Uart*)p_usart, data));
	}
# endif
# ifdef UART1
	if (UART1 == (Uart*)p_usart) {
  407bf0:	4b18      	ldr	r3, [pc, #96]	; (407c54 <usart_serial_getchar+0x74>)
  407bf2:	4298      	cmp	r0, r3
  407bf4:	d024      	beq.n	407c40 <usart_serial_getchar+0x60>
		while (usart_read(p_usart, &val));
		*data = (uint8_t)(val & 0xFF);
	}
#else
# ifdef USART0
	if (USART0 == p_usart) {
  407bf6:	4b18      	ldr	r3, [pc, #96]	; (407c58 <usart_serial_getchar+0x78>)
  407bf8:	4298      	cmp	r0, r3
  407bfa:	d00f      	beq.n	407c1c <usart_serial_getchar+0x3c>
		while (usart_read(p_usart, &val));
		*data = (uint8_t)(val & 0xFF);
	}
# endif
# ifdef USART1
	if (USART1 == p_usart) {
  407bfc:	4b17      	ldr	r3, [pc, #92]	; (407c5c <usart_serial_getchar+0x7c>)
  407bfe:	4298      	cmp	r0, r3
  407c00:	d001      	beq.n	407c06 <usart_serial_getchar+0x26>
		*data = (uint8_t)(val & 0xFF);
	}
# endif
#endif /* ifdef USART */

}
  407c02:	b002      	add	sp, #8
  407c04:	bd70      	pop	{r4, r5, r6, pc}
  407c06:	4e16      	ldr	r6, [pc, #88]	; (407c60 <usart_serial_getchar+0x80>)
  407c08:	ad01      	add	r5, sp, #4
		*data = (uint8_t)(val & 0xFF);
	}
# endif
# ifdef USART1
	if (USART1 == p_usart) {
		while (usart_read(p_usart, &val));
  407c0a:	4814      	ldr	r0, [pc, #80]	; (407c5c <usart_serial_getchar+0x7c>)
  407c0c:	4629      	mov	r1, r5
  407c0e:	47b0      	blx	r6
  407c10:	2800      	cmp	r0, #0
  407c12:	d1fa      	bne.n	407c0a <usart_serial_getchar+0x2a>
		*data = (uint8_t)(val & 0xFF);
  407c14:	9b01      	ldr	r3, [sp, #4]
  407c16:	7023      	strb	r3, [r4, #0]
		*data = (uint8_t)(val & 0xFF);
	}
# endif
#endif /* ifdef USART */

}
  407c18:	b002      	add	sp, #8
  407c1a:	bd70      	pop	{r4, r5, r6, pc}
  407c1c:	4e10      	ldr	r6, [pc, #64]	; (407c60 <usart_serial_getchar+0x80>)
  407c1e:	ad01      	add	r5, sp, #4
		*data = (uint8_t)(val & 0xFF);
	}
#else
# ifdef USART0
	if (USART0 == p_usart) {
		while (usart_read(p_usart, &val));
  407c20:	480d      	ldr	r0, [pc, #52]	; (407c58 <usart_serial_getchar+0x78>)
  407c22:	4629      	mov	r1, r5
  407c24:	47b0      	blx	r6
  407c26:	2800      	cmp	r0, #0
  407c28:	d1fa      	bne.n	407c20 <usart_serial_getchar+0x40>
	}
# endif
# ifdef USART1
	if (USART1 == p_usart) {
		while (usart_read(p_usart, &val));
		*data = (uint8_t)(val & 0xFF);
  407c2a:	9b01      	ldr	r3, [sp, #4]
  407c2c:	7023      	strb	r3, [r4, #0]
  407c2e:	e7f3      	b.n	407c18 <usart_serial_getchar+0x38>
  407c30:	4d0c      	ldr	r5, [pc, #48]	; (407c64 <usart_serial_getchar+0x84>)
		while (uart_read((Uart*)p_usart, data));
	}
#else
# ifdef UART0
	if (UART0 == (Uart*)p_usart) {
		while (uart_read((Uart*)p_usart, data));
  407c32:	4807      	ldr	r0, [pc, #28]	; (407c50 <usart_serial_getchar+0x70>)
  407c34:	4621      	mov	r1, r4
  407c36:	47a8      	blx	r5
  407c38:	2800      	cmp	r0, #0
  407c3a:	d1fa      	bne.n	407c32 <usart_serial_getchar+0x52>
		*data = (uint8_t)(val & 0xFF);
	}
# endif
#endif /* ifdef USART */

}
  407c3c:	b002      	add	sp, #8
  407c3e:	bd70      	pop	{r4, r5, r6, pc}
  407c40:	4d08      	ldr	r5, [pc, #32]	; (407c64 <usart_serial_getchar+0x84>)
		while (uart_read((Uart*)p_usart, data));
	}
# endif
# ifdef UART1
	if (UART1 == (Uart*)p_usart) {
		while (uart_read((Uart*)p_usart, data));
  407c42:	4804      	ldr	r0, [pc, #16]	; (407c54 <usart_serial_getchar+0x74>)
  407c44:	4621      	mov	r1, r4
  407c46:	47a8      	blx	r5
  407c48:	2800      	cmp	r0, #0
  407c4a:	d1fa      	bne.n	407c42 <usart_serial_getchar+0x62>
		*data = (uint8_t)(val & 0xFF);
	}
# endif
#endif /* ifdef USART */

}
  407c4c:	b002      	add	sp, #8
  407c4e:	bd70      	pop	{r4, r5, r6, pc}
  407c50:	400e0600 	.word	0x400e0600
  407c54:	400e0800 	.word	0x400e0800
  407c58:	40024000 	.word	0x40024000
  407c5c:	40028000 	.word	0x40028000
  407c60:	00403e8d 	.word	0x00403e8d
  407c64:	00403d7d 	.word	0x00403d7d

00407c68 <usart_serial_putchar>:
 *   \retval 1  The character was written.
 *   \retval 0  The function timed out before the USART transmitter became
 * ready to send.
 */
static inline int usart_serial_putchar(usart_if p_usart, const uint8_t c)
{
  407c68:	b538      	push	{r3, r4, r5, lr}
		while (uart_write((Uart*)p_usart, c)!=0);
		return 1;
	}
#else
# ifdef UART0
	if (UART0 == (Uart*)p_usart) {
  407c6a:	4b17      	ldr	r3, [pc, #92]	; (407cc8 <usart_serial_putchar+0x60>)
  407c6c:	4298      	cmp	r0, r3
 *   \retval 1  The character was written.
 *   \retval 0  The function timed out before the USART transmitter became
 * ready to send.
 */
static inline int usart_serial_putchar(usart_if p_usart, const uint8_t c)
{
  407c6e:	460c      	mov	r4, r1
		while (uart_write((Uart*)p_usart, c)!=0);
		return 1;
	}
#else
# ifdef UART0
	if (UART0 == (Uart*)p_usart) {
  407c70:	d012      	beq.n	407c98 <usart_serial_putchar+0x30>
		while (uart_write((Uart*)p_usart, c)!=0);
		return 1;
	}
# endif
# ifdef UART1
	if (UART1 == (Uart*)p_usart) {
  407c72:	4b16      	ldr	r3, [pc, #88]	; (407ccc <usart_serial_putchar+0x64>)
  407c74:	4298      	cmp	r0, r3
  407c76:	d017      	beq.n	407ca8 <usart_serial_putchar+0x40>
		while (usart_write(p_usart, c)!=0);
		return 1;
	}
#else
# ifdef USART0
	if (USART0 == p_usart) {
  407c78:	4b15      	ldr	r3, [pc, #84]	; (407cd0 <usart_serial_putchar+0x68>)
  407c7a:	4298      	cmp	r0, r3
  407c7c:	d01c      	beq.n	407cb8 <usart_serial_putchar+0x50>
		while (usart_write(p_usart, c)!=0);
		return 1;
	}
# endif
# ifdef USART1
	if (USART1 == p_usart) {
  407c7e:	4b15      	ldr	r3, [pc, #84]	; (407cd4 <usart_serial_putchar+0x6c>)
  407c80:	4298      	cmp	r0, r3
  407c82:	d001      	beq.n	407c88 <usart_serial_putchar+0x20>
		return 1;
	}
# endif
#endif /* ifdef USART */

	return 0;
  407c84:	2000      	movs	r0, #0
}
  407c86:	bd38      	pop	{r3, r4, r5, pc}
  407c88:	4d13      	ldr	r5, [pc, #76]	; (407cd8 <usart_serial_putchar+0x70>)
		return 1;
	}
# endif
# ifdef USART1
	if (USART1 == p_usart) {
		while (usart_write(p_usart, c)!=0);
  407c8a:	4812      	ldr	r0, [pc, #72]	; (407cd4 <usart_serial_putchar+0x6c>)
  407c8c:	4621      	mov	r1, r4
  407c8e:	47a8      	blx	r5
  407c90:	2800      	cmp	r0, #0
  407c92:	d1fa      	bne.n	407c8a <usart_serial_putchar+0x22>
	}
#else
# ifdef UART0
	if (UART0 == (Uart*)p_usart) {
		while (uart_write((Uart*)p_usart, c)!=0);
		return 1;
  407c94:	2001      	movs	r0, #1
  407c96:	bd38      	pop	{r3, r4, r5, pc}
  407c98:	4d10      	ldr	r5, [pc, #64]	; (407cdc <usart_serial_putchar+0x74>)
		return 1;
	}
#else
# ifdef UART0
	if (UART0 == (Uart*)p_usart) {
		while (uart_write((Uart*)p_usart, c)!=0);
  407c9a:	480b      	ldr	r0, [pc, #44]	; (407cc8 <usart_serial_putchar+0x60>)
  407c9c:	4621      	mov	r1, r4
  407c9e:	47a8      	blx	r5
  407ca0:	2800      	cmp	r0, #0
  407ca2:	d1fa      	bne.n	407c9a <usart_serial_putchar+0x32>
		return 1;
  407ca4:	2001      	movs	r0, #1
  407ca6:	bd38      	pop	{r3, r4, r5, pc}
  407ca8:	4d0c      	ldr	r5, [pc, #48]	; (407cdc <usart_serial_putchar+0x74>)
	}
# endif
# ifdef UART1
	if (UART1 == (Uart*)p_usart) {
		while (uart_write((Uart*)p_usart, c)!=0);
  407caa:	4808      	ldr	r0, [pc, #32]	; (407ccc <usart_serial_putchar+0x64>)
  407cac:	4621      	mov	r1, r4
  407cae:	47a8      	blx	r5
  407cb0:	2800      	cmp	r0, #0
  407cb2:	d1fa      	bne.n	407caa <usart_serial_putchar+0x42>
	}
#else
# ifdef UART0
	if (UART0 == (Uart*)p_usart) {
		while (uart_write((Uart*)p_usart, c)!=0);
		return 1;
  407cb4:	2001      	movs	r0, #1
  407cb6:	bd38      	pop	{r3, r4, r5, pc}
  407cb8:	4d07      	ldr	r5, [pc, #28]	; (407cd8 <usart_serial_putchar+0x70>)
		return 1;
	}
#else
# ifdef USART0
	if (USART0 == p_usart) {
		while (usart_write(p_usart, c)!=0);
  407cba:	4805      	ldr	r0, [pc, #20]	; (407cd0 <usart_serial_putchar+0x68>)
  407cbc:	4621      	mov	r1, r4
  407cbe:	47a8      	blx	r5
  407cc0:	2800      	cmp	r0, #0
  407cc2:	d1fa      	bne.n	407cba <usart_serial_putchar+0x52>
	}
#else
# ifdef UART0
	if (UART0 == (Uart*)p_usart) {
		while (uart_write((Uart*)p_usart, c)!=0);
		return 1;
  407cc4:	2001      	movs	r0, #1
  407cc6:	bd38      	pop	{r3, r4, r5, pc}
  407cc8:	400e0600 	.word	0x400e0600
  407ccc:	400e0800 	.word	0x400e0800
  407cd0:	40024000 	.word	0x40024000
  407cd4:	40028000 	.word	0x40028000
  407cd8:	00403e79 	.word	0x00403e79
  407cdc:	00403d6d 	.word	0x00403d6d

00407ce0 <initAllUarts>:
		initAllUarts();
		configureWatchDog();
}

void initAllUarts()
{
  407ce0:	b510      	push	{r4, lr}
	if(drv_uart_init(&uart0Config) != STATUS_PASS)
  407ce2:	4809      	ldr	r0, [pc, #36]	; (407d08 <initAllUarts+0x28>)
  407ce4:	4c09      	ldr	r4, [pc, #36]	; (407d0c <initAllUarts+0x2c>)
  407ce6:	47a0      	blx	r4
  407ce8:	b100      	cbz	r0, 407cec <initAllUarts+0xc>
  407cea:	e7fe      	b.n	407cea <initAllUarts+0xa>
	{
		while(1); //spin here
	}
	if(drv_uart_init(&uart1Config) != STATUS_PASS)
  407cec:	4808      	ldr	r0, [pc, #32]	; (407d10 <initAllUarts+0x30>)
  407cee:	47a0      	blx	r4
  407cf0:	b100      	cbz	r0, 407cf4 <initAllUarts+0x14>
  407cf2:	e7fe      	b.n	407cf2 <initAllUarts+0x12>
	{
		while(1); //spin here
	}		
	if(drv_uart_init(&usart0Config) != STATUS_PASS)
  407cf4:	4807      	ldr	r0, [pc, #28]	; (407d14 <initAllUarts+0x34>)
  407cf6:	47a0      	blx	r4
  407cf8:	b100      	cbz	r0, 407cfc <initAllUarts+0x1c>
  407cfa:	e7fe      	b.n	407cfa <initAllUarts+0x1a>
	{
		while(1); //spin here
	}
	if(drv_uart_init(&usart1Config) != STATUS_PASS)
  407cfc:	4806      	ldr	r0, [pc, #24]	; (407d18 <initAllUarts+0x38>)
  407cfe:	47a0      	blx	r4
  407d00:	b100      	cbz	r0, 407d04 <initAllUarts+0x24>
  407d02:	e7fe      	b.n	407d02 <initAllUarts+0x22>
  407d04:	bd10      	pop	{r4, pc}
  407d06:	bf00      	nop
  407d08:	20000154 	.word	0x20000154
  407d0c:	00408b5d 	.word	0x00408b5d
  407d10:	20000188 	.word	0x20000188
  407d14:	2000016c 	.word	0x2000016c
  407d18:	2000013c 	.word	0x2000013c

00407d1c <deInitAllUarts>:
		while(1); //spin here
	}
}

void deInitAllUarts()
{
  407d1c:	b510      	push	{r4, lr}
	drv_uart_deInit(&uart0Config);
  407d1e:	4805      	ldr	r0, [pc, #20]	; (407d34 <deInitAllUarts+0x18>)
  407d20:	4c05      	ldr	r4, [pc, #20]	; (407d38 <deInitAllUarts+0x1c>)
  407d22:	47a0      	blx	r4
	drv_uart_deInit(&uart1Config);
  407d24:	4805      	ldr	r0, [pc, #20]	; (407d3c <deInitAllUarts+0x20>)
  407d26:	47a0      	blx	r4
	drv_uart_deInit(&usart0Config);
  407d28:	4805      	ldr	r0, [pc, #20]	; (407d40 <deInitAllUarts+0x24>)
  407d2a:	47a0      	blx	r4
	drv_uart_deInit(&usart1Config);
  407d2c:	4805      	ldr	r0, [pc, #20]	; (407d44 <deInitAllUarts+0x28>)
  407d2e:	47a0      	blx	r4
  407d30:	bd10      	pop	{r4, pc}
  407d32:	bf00      	nop
  407d34:	20000154 	.word	0x20000154
  407d38:	00408ed1 	.word	0x00408ed1
  407d3c:	20000188 	.word	0x20000188
  407d40:	2000016c 	.word	0x2000016c
  407d44:	2000013c 	.word	0x2000013c

00407d48 <WDT_Handler>:

/**
 *  \brief Handler for watchdog interrupt.
 */
void WDT_Handler(void)
{
  407d48:	b508      	push	{r3, lr}

	/* Clear status bit to acknowledge interrupt by dummy read. */
	wdt_get_status(WDT);
  407d4a:	4803      	ldr	r0, [pc, #12]	; (407d58 <WDT_Handler+0x10>)
  407d4c:	4b03      	ldr	r3, [pc, #12]	; (407d5c <WDT_Handler+0x14>)
  407d4e:	4798      	blx	r3

	debugPrintString("Restarting system!!!\r");
  407d50:	4803      	ldr	r0, [pc, #12]	; (407d60 <WDT_Handler+0x18>)
  407d52:	4b04      	ldr	r3, [pc, #16]	; (407d64 <WDT_Handler+0x1c>)
  407d54:	4798      	blx	r3
  407d56:	bd08      	pop	{r3, pc}
  407d58:	400e1450 	.word	0x400e1450
  407d5c:	0040b2e5 	.word	0x0040b2e5
  407d60:	004165bc 	.word	0x004165bc
  407d64:	004008c9 	.word	0x004008c9

00407d68 <configureWatchDog>:
/**
 * powerOnInit(void)
 * @brief Initialize the watchdog timer, only done once on power up. 
 */
void configureWatchDog()
{
  407d68:	b510      	push	{r4, lr}
	pmc_enable_periph_clk(ID_WDT);
  407d6a:	4b0f      	ldr	r3, [pc, #60]	; (407da8 <configureWatchDog+0x40>)
  407d6c:	2004      	movs	r0, #4
  407d6e:	4798      	blx	r3
	/* Get timeout value. */
	uint32_t timeout_value = wdt_get_timeout_value(WDT_PERIOD * 1000,
  407d70:	4b0e      	ldr	r3, [pc, #56]	; (407dac <configureWatchDog+0x44>)
  407d72:	480f      	ldr	r0, [pc, #60]	; (407db0 <configureWatchDog+0x48>)
  407d74:	f44f 4100 	mov.w	r1, #32768	; 0x8000
  407d78:	4798      	blx	r3
			BOARD_FREQ_SLCK_XTAL);
	if (timeout_value == WDT_INVALID_ARGUMENT) {
  407d7a:	f64f 73ff 	movw	r3, #65535	; 0xffff
  407d7e:	4298      	cmp	r0, r3
  407d80:	d100      	bne.n	407d84 <configureWatchDog+0x1c>
  407d82:	e7fe      	b.n	407d82 <configureWatchDog+0x1a>
	uint32_t wdt_mode = WDT_MR_WDRSTEN | WDT_MR_WDFIEN |  /* Enable WDT fault interrupt. */
			WDT_MR_WDDBGHLT  |  /* WDT stops in debug state. */
			WDT_MR_WDIDLEHLT;   /* WDT stops in idle state. */
	
	/* Initialize WDT with the given parameters. */
	wdt_init(WDT, wdt_mode, timeout_value, timeout_value);
  407d84:	b282      	uxth	r2, r0
  407d86:	4613      	mov	r3, r2
  407d88:	f04f 2130 	mov.w	r1, #805318656	; 0x30003000
  407d8c:	4809      	ldr	r0, [pc, #36]	; (407db4 <configureWatchDog+0x4c>)
  407d8e:	4c0a      	ldr	r4, [pc, #40]	; (407db8 <configureWatchDog+0x50>)
  407d90:	47a0      	blx	r4

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
  407d92:	4b0a      	ldr	r3, [pc, #40]	; (407dbc <configureWatchDog+0x54>)
  407d94:	2210      	movs	r2, #16
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
  407d96:	2100      	movs	r1, #0

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
  407d98:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
  407d9c:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
  407da0:	f883 1304 	strb.w	r1, [r3, #772]	; 0x304
    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
  407da4:	601a      	str	r2, [r3, #0]
  407da6:	bd10      	pop	{r4, pc}
  407da8:	0040b231 	.word	0x0040b231
  407dac:	0040b289 	.word	0x0040b289
  407db0:	00989680 	.word	0x00989680
  407db4:	400e1450 	.word	0x400e1450
  407db8:	0040b2b1 	.word	0x0040b2b1
  407dbc:	e000e100 	.word	0xe000e100

00407dc0 <powerOnInit>:
/**
 * powerOnInit(void)
 * @brief Initialize the board after power up. 
 */
void powerOnInit(void) 
{		
  407dc0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
		static FRESULT res;
		Ctrl_status status;

		//configure the gpio
		drv_gpio_initializeAll();
  407dc4:	4b2a      	ldr	r3, [pc, #168]	; (407e70 <powerOnInit+0xb0>)
		loadSerialNumberFromNvm();
		drv_led_init(&ledConfiguration);
		drv_led_set(DRV_LED_WHITE,DRV_LED_SOLID);
  407dc6:	4f2b      	ldr	r7, [pc, #172]	; (407e74 <powerOnInit+0xb4>)
  407dc8:	4c2b      	ldr	r4, [pc, #172]	; (407e78 <powerOnInit+0xb8>)
/**
 * powerOnInit(void)
 * @brief Initialize the board after power up. 
 */
void powerOnInit(void) 
{		
  407dca:	b085      	sub	sp, #20
		static FRESULT res;
		Ctrl_status status;

		//configure the gpio
		drv_gpio_initializeAll();
  407dcc:	4798      	blx	r3
		loadSerialNumberFromNvm();
  407dce:	4b2b      	ldr	r3, [pc, #172]	; (407e7c <powerOnInit+0xbc>)
  407dd0:	4798      	blx	r3
		drv_led_init(&ledConfiguration);
  407dd2:	4b2b      	ldr	r3, [pc, #172]	; (407e80 <powerOnInit+0xc0>)
  407dd4:	482b      	ldr	r0, [pc, #172]	; (407e84 <powerOnInit+0xc4>)
  407dd6:	4798      	blx	r3
		drv_led_set(DRV_LED_WHITE,DRV_LED_SOLID);
  407dd8:	2101      	movs	r1, #1
  407dda:	2004      	movs	r0, #4
  407ddc:	47b8      	blx	r7
		vTaskDelay(200);
  407dde:	20c8      	movs	r0, #200	; 0xc8
  407de0:	4b29      	ldr	r3, [pc, #164]	; (407e88 <powerOnInit+0xc8>)
  407de2:	4798      	blx	r3
		
		pmc_switch_sclk_to_32kxtal(PMC_OSC_XTAL);
  407de4:	2000      	movs	r0, #0
  407de6:	4b29      	ldr	r3, [pc, #164]	; (407e8c <powerOnInit+0xcc>)
  407de8:	4798      	blx	r3
		while (!pmc_osc_is_ready_32kxtal());
  407dea:	47a0      	blx	r4
  407dec:	2800      	cmp	r0, #0
  407dee:	d0fc      	beq.n	407dea <powerOnInit+0x2a>
		rtc_set_hour_mode(RTC, 0);
  407df0:	2100      	movs	r1, #0
  407df2:	4827      	ldr	r0, [pc, #156]	; (407e90 <powerOnInit+0xd0>)
  407df4:	4b27      	ldr	r3, [pc, #156]	; (407e94 <powerOnInit+0xd4>)
 * \param opt         Options needed to set up RS232 communication (see \ref usart_options_t).
 *
 */
static inline void stdio_serial_init(volatile void *usart, const usart_serial_options_t *opt)
{
	stdio_base = (void *)usart;
  407df6:	4e28      	ldr	r6, [pc, #160]	; (407e98 <powerOnInit+0xd8>)
	ptr_put = (int (*)(void volatile*,char))&usart_serial_putchar;
  407df8:	f8df 80c8 	ldr.w	r8, [pc, #200]	; 407ec4 <powerOnInit+0x104>
	fdevopen((int (*)(char, FILE*))(_write),(int (*)(FILE*))(_read));
#  endif
#  if UC3 || SAM
	// For AVR32 and SAM GCC
	// Specify that stdout and stdin should not be buffered.
	setbuf(stdout, NULL);
  407dfc:	4d27      	ldr	r5, [pc, #156]	; (407e9c <powerOnInit+0xdc>)
 *
 */
static inline void stdio_serial_init(volatile void *usart, const usart_serial_options_t *opt)
{
	stdio_base = (void *)usart;
	ptr_put = (int (*)(void volatile*,char))&usart_serial_putchar;
  407dfe:	f8df 90c8 	ldr.w	r9, [pc, #200]	; 407ec8 <powerOnInit+0x108>
	fdevopen((int (*)(char, FILE*))(_write),(int (*)(FILE*))(_read));
#  endif
#  if UC3 || SAM
	// For AVR32 and SAM GCC
	// Specify that stdout and stdin should not be buffered.
	setbuf(stdout, NULL);
  407e02:	4c27      	ldr	r4, [pc, #156]	; (407ea0 <powerOnInit+0xe0>)
  407e04:	4798      	blx	r3
		rtc_clear_date_alarm(RTC);
  407e06:	4822      	ldr	r0, [pc, #136]	; (407e90 <powerOnInit+0xd0>)
  407e08:	4b26      	ldr	r3, [pc, #152]	; (407ea4 <powerOnInit+0xe4>)
  407e0a:	4798      	blx	r3
		rtc_clear_time_alarm(RTC);		
  407e0c:	4b26      	ldr	r3, [pc, #152]	; (407ea8 <powerOnInit+0xe8>)
  407e0e:	4820      	ldr	r0, [pc, #128]	; (407e90 <powerOnInit+0xd0>)
  407e10:	4798      	blx	r3
		drv_led_set(DRV_LED_OFF,DRV_LED_SOLID);
  407e12:	2101      	movs	r1, #1
  407e14:	2006      	movs	r0, #6
  407e16:	47b8      	blx	r7
 * \param opt         Options needed to set up RS232 communication (see \ref usart_options_t).
 *
 */
static inline void stdio_serial_init(volatile void *usart, const usart_serial_options_t *opt)
{
	stdio_base = (void *)usart;
  407e18:	4a24      	ldr	r2, [pc, #144]	; (407eac <powerOnInit+0xec>)
	ptr_put = (int (*)(void volatile*,char))&usart_serial_putchar;
	ptr_get = (void (*)(void volatile*,char*))&usart_serial_getchar;
  407e1a:	f8df e0b0 	ldr.w	lr, [pc, #176]	; 407ecc <powerOnInit+0x10c>
  407e1e:	f8df c0b0 	ldr.w	ip, [pc, #176]	; 407ed0 <powerOnInit+0x110>
 * \param opt         Options needed to set up RS232 communication (see \ref usart_options_t).
 *
 */
static inline void stdio_serial_init(volatile void *usart, const usart_serial_options_t *opt)
{
	stdio_base = (void *)usart;
  407e22:	6016      	str	r6, [r2, #0]
		usart_serial_options_t *opt)
{
#if ((!SAM4L) && (!SAMG55))
	sam_uart_opt_t uart_settings;
	uart_settings.ul_mck = sysclk_get_peripheral_hz();
	uart_settings.ul_baudrate = opt->baudrate;
  407e24:	f44f 31e1 	mov.w	r1, #115200	; 0x1c200
	uart_settings.ul_mode = opt->paritytype;
  407e28:	f44f 6200 	mov.w	r2, #2048	; 0x800
static inline void usart_serial_init(usart_if p_usart,
		usart_serial_options_t *opt)
{
#if ((!SAM4L) && (!SAMG55))
	sam_uart_opt_t uart_settings;
	uart_settings.ul_mck = sysclk_get_peripheral_hz();
  407e2c:	4f20      	ldr	r7, [pc, #128]	; (407eb0 <powerOnInit+0xf0>)
 *
 * \param ul_id Id (number) of the peripheral clock.
 */
static inline void sysclk_enable_peripheral_clock(uint32_t ul_id)
{
	pmc_enable_periph_clk(ul_id);
  407e2e:	4b21      	ldr	r3, [pc, #132]	; (407eb4 <powerOnInit+0xf4>)
	ptr_put = (int (*)(void volatile*,char))&usart_serial_putchar;
	ptr_get = (void (*)(void volatile*,char*))&usart_serial_getchar;
  407e30:	f8ce c000 	str.w	ip, [lr]
  407e34:	2008      	movs	r0, #8
	uart_settings.ul_baudrate = opt->baudrate;
	uart_settings.ul_mode = opt->paritytype;
  407e36:	9203      	str	r2, [sp, #12]
		usart_serial_options_t *opt)
{
#if ((!SAM4L) && (!SAMG55))
	sam_uart_opt_t uart_settings;
	uart_settings.ul_mck = sysclk_get_peripheral_hz();
	uart_settings.ul_baudrate = opt->baudrate;
  407e38:	9102      	str	r1, [sp, #8]
 *
 */
static inline void stdio_serial_init(volatile void *usart, const usart_serial_options_t *opt)
{
	stdio_base = (void *)usart;
	ptr_put = (int (*)(void volatile*,char))&usart_serial_putchar;
  407e3a:	f8c8 9000 	str.w	r9, [r8]
static inline void usart_serial_init(usart_if p_usart,
		usart_serial_options_t *opt)
{
#if ((!SAM4L) && (!SAMG55))
	sam_uart_opt_t uart_settings;
	uart_settings.ul_mck = sysclk_get_peripheral_hz();
  407e3e:	9701      	str	r7, [sp, #4]
  407e40:	4798      	blx	r3
#else
# ifdef UART0
	if (UART0 == (Uart*)p_usart) {
		sysclk_enable_peripheral_clock(ID_UART0);
		/* Configure UART */
		uart_init((Uart*)p_usart, &uart_settings);
  407e42:	a901      	add	r1, sp, #4
  407e44:	4630      	mov	r0, r6
  407e46:	4b1c      	ldr	r3, [pc, #112]	; (407eb8 <powerOnInit+0xf8>)
  407e48:	4798      	blx	r3
	fdevopen((int (*)(char, FILE*))(_write),(int (*)(FILE*))(_read));
#  endif
#  if UC3 || SAM
	// For AVR32 and SAM GCC
	// Specify that stdout and stdin should not be buffered.
	setbuf(stdout, NULL);
  407e4a:	682b      	ldr	r3, [r5, #0]
  407e4c:	2100      	movs	r1, #0
  407e4e:	6898      	ldr	r0, [r3, #8]
  407e50:	47a0      	blx	r4
	setbuf(stdin, NULL);
  407e52:	682b      	ldr	r3, [r5, #0]
  407e54:	2100      	movs	r1, #0
  407e56:	6858      	ldr	r0, [r3, #4]
  407e58:	47a0      	blx	r4
	#else
	stdio_serial_init(UART0, &usart_serial_options);
	#endif
	/* Specify that stdout should not be buffered. */
	#if defined(__GNUC__)
		setbuf(stdout, NULL);
  407e5a:	682b      	ldr	r3, [r5, #0]
  407e5c:	2100      	movs	r1, #0
  407e5e:	6898      	ldr	r0, [r3, #8]
  407e60:	47a0      	blx	r4
		rtc_clear_time_alarm(RTC);		
		drv_led_set(DRV_LED_OFF,DRV_LED_SOLID);
		//drv_gpio_ConfigureBLEForProgramming(); 

		configure_console();		
		initAllUarts();
  407e62:	4b16      	ldr	r3, [pc, #88]	; (407ebc <powerOnInit+0xfc>)
  407e64:	4798      	blx	r3
		configureWatchDog();
  407e66:	4b16      	ldr	r3, [pc, #88]	; (407ec0 <powerOnInit+0x100>)
  407e68:	4798      	blx	r3
}
  407e6a:	b005      	add	sp, #20
  407e6c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  407e70:	0040874d 	.word	0x0040874d
  407e74:	00400699 	.word	0x00400699
  407e78:	0040b191 	.word	0x0040b191
  407e7c:	00407f39 	.word	0x00407f39
  407e80:	00400651 	.word	0x00400651
  407e84:	20000184 	.word	0x20000184
  407e88:	004072ed 	.word	0x004072ed
  407e8c:	0040b16d 	.word	0x0040b16d
  407e90:	400e1460 	.word	0x400e1460
  407e94:	00403ad1 	.word	0x00403ad1
  407e98:	400e0600 	.word	0x400e0600
  407e9c:	20000b30 	.word	0x20000b30
  407ea0:	0040c3dd 	.word	0x0040c3dd
  407ea4:	00403d19 	.word	0x00403d19
  407ea8:	00403d11 	.word	0x00403d11
  407eac:	20003e10 	.word	0x20003e10
  407eb0:	07270e00 	.word	0x07270e00
  407eb4:	0040b231 	.word	0x0040b231
  407eb8:	00403d25 	.word	0x00403d25
  407ebc:	00407ce1 	.word	0x00407ce1
  407ec0:	00407d69 	.word	0x00407d69
  407ec4:	20003e0c 	.word	0x20003e0c
  407ec8:	00407c69 	.word	0x00407c69
  407ecc:	20003e08 	.word	0x20003e08
  407ed0:	00407be1 	.word	0x00407be1

00407ed4 <itoa>:
 *  Author: sean
 * Copyright Heddoko(TM) 2015, all rights reserved
 */ 

int itoa(int value, char* sp, int radix)
{
  407ed4:	b4f0      	push	{r4, r5, r6, r7}
	 char tmp[16];		// be careful with the length of the buffer
	 char *tp = tmp;
	 int i;
	 unsigned v;

	 int sign = (radix == 10 && value < 0);
  407ed6:	2a0a      	cmp	r2, #10
 *  Author: sean
 * Copyright Heddoko(TM) 2015, all rights reserved
 */ 

int itoa(int value, char* sp, int radix)
{
  407ed8:	b084      	sub	sp, #16
	 char tmp[16];		// be careful with the length of the buffer
	 char *tp = tmp;
	 int i;
	 unsigned v;

	 int sign = (radix == 10 && value < 0);
  407eda:	d028      	beq.n	407f2e <itoa+0x5a>
	 if (sign)
		 v = -value;
	 else
		v = (unsigned)value;
  407edc:	2700      	movs	r7, #0
	 while (v || tp == tmp)
	 {
		 i = v % radix;
		 v /= radix;	// v/=radix uses less CPU clocks than v=v/radix does
		 if (i < 10)
			*tp++ = i+'0';
  407ede:	466e      	mov	r6, sp
  407ee0:	466b      	mov	r3, sp
	 if (sign)
		 v = -value;
	 else
		v = (unsigned)value;

	 while (v || tp == tmp)
  407ee2:	b938      	cbnz	r0, 407ef4 <itoa+0x20>
  407ee4:	42b3      	cmp	r3, r6
  407ee6:	d110      	bne.n	407f0a <itoa+0x36>
	 {
		 i = v % radix;
  407ee8:	4604      	mov	r4, r0
		 v /= radix;	// v/=radix uses less CPU clocks than v=v/radix does
		 if (i < 10)
			*tp++ = i+'0';
  407eea:	3430      	adds	r4, #48	; 0x30
  407eec:	701c      	strb	r4, [r3, #0]
  407eee:	3301      	adds	r3, #1
	 if (sign)
		 v = -value;
	 else
		v = (unsigned)value;

	 while (v || tp == tmp)
  407ef0:	2800      	cmp	r0, #0
  407ef2:	d0f7      	beq.n	407ee4 <itoa+0x10>
	 {
		 i = v % radix;
  407ef4:	fbb0 f5f2 	udiv	r5, r0, r2
  407ef8:	fb02 0415 	mls	r4, r2, r5, r0
		 v /= radix;	// v/=radix uses less CPU clocks than v=v/radix does
		 if (i < 10)
  407efc:	2c09      	cmp	r4, #9
		v = (unsigned)value;

	 while (v || tp == tmp)
	 {
		 i = v % radix;
		 v /= radix;	// v/=radix uses less CPU clocks than v=v/radix does
  407efe:	4628      	mov	r0, r5
		 if (i < 10)
  407f00:	ddf3      	ble.n	407eea <itoa+0x16>
			*tp++ = i+'0';
		 else
			*tp++ = i + 'a' - 10;
  407f02:	3457      	adds	r4, #87	; 0x57
  407f04:	701c      	strb	r4, [r3, #0]
  407f06:	3301      	adds	r3, #1
  407f08:	e7eb      	b.n	407ee2 <itoa+0xe>
	 }

	 int len = tp - tmp;
  407f0a:	1b98      	subs	r0, r3, r6

	 if (sign)
  407f0c:	b11f      	cbz	r7, 407f16 <itoa+0x42>
	 {
		 *sp++ = '-';
  407f0e:	222d      	movs	r2, #45	; 0x2d
  407f10:	700a      	strb	r2, [r1, #0]
		 len++;
  407f12:	3001      	adds	r0, #1

	 int len = tp - tmp;

	 if (sign)
	 {
		 *sp++ = '-';
  407f14:	3101      	adds	r1, #1
		 len++;
	 }

	 while (tp > tmp)
  407f16:	42b3      	cmp	r3, r6
  407f18:	d906      	bls.n	407f28 <itoa+0x54>
  407f1a:	3901      	subs	r1, #1
	 *sp++ = *--tp;
  407f1c:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
  407f20:	f801 2f01 	strb.w	r2, [r1, #1]!
	 {
		 *sp++ = '-';
		 len++;
	 }

	 while (tp > tmp)
  407f24:	42b3      	cmp	r3, r6
  407f26:	d1f9      	bne.n	407f1c <itoa+0x48>
	 *sp++ = *--tp;

	 return len;
  407f28:	b004      	add	sp, #16
  407f2a:	bcf0      	pop	{r4, r5, r6, r7}
  407f2c:	4770      	bx	lr
	 char tmp[16];		// be careful with the length of the buffer
	 char *tp = tmp;
	 int i;
	 unsigned v;

	 int sign = (radix == 10 && value < 0);
  407f2e:	2800      	cmp	r0, #0
  407f30:	dad4      	bge.n	407edc <itoa+0x8>
	 if (sign)
		 v = -value;
  407f32:	4240      	negs	r0, r0
	 char tmp[16];		// be careful with the length of the buffer
	 char *tp = tmp;
	 int i;
	 unsigned v;

	 int sign = (radix == 10 && value < 0);
  407f34:	2701      	movs	r7, #1
  407f36:	e7d2      	b.n	407ede <itoa+0xa>

00407f38 <loadSerialNumberFromNvm>:
 * @brief Get one line from the buffer
 */
nvmSettings_t nvmSettings; 
extern drv_led_config_t ledConfiguration;
void loadSerialNumberFromNvm()
{
  407f38:	b510      	push	{r4, lr}
	if(flash_read_user_signature(&nvmSettings, sizeof(nvmSettings)) == 0)
  407f3a:	4c18      	ldr	r4, [pc, #96]	; (407f9c <loadSerialNumberFromNvm+0x64>)
  407f3c:	4b18      	ldr	r3, [pc, #96]	; (407fa0 <loadSerialNumberFromNvm+0x68>)
  407f3e:	4620      	mov	r0, r4
  407f40:	2118      	movs	r1, #24
  407f42:	4798      	blx	r3
  407f44:	b9d0      	cbnz	r0, 407f7c <loadSerialNumberFromNvm+0x44>
	{
		if(nvmSettings.suitNumber[0] == 'S')
  407f46:	7823      	ldrb	r3, [r4, #0]
  407f48:	2b53      	cmp	r3, #83	; 0x53
  407f4a:	d020      	beq.n	407f8e <loadSerialNumberFromNvm+0x56>
		{
			strncpy(brainSettings.suitNumber, nvmSettings.suitNumber, sizeof(nvmSettings.suitNumber));
		}
		else
		{
			debugPrintString("Serial number not set\r\n");
  407f4c:	4815      	ldr	r0, [pc, #84]	; (407fa4 <loadSerialNumberFromNvm+0x6c>)
  407f4e:	4b16      	ldr	r3, [pc, #88]	; (407fa8 <loadSerialNumberFromNvm+0x70>)
  407f50:	4798      	blx	r3
			strncpy(brainSettings.suitNumber, "SXXXXX", 50);
  407f52:	4816      	ldr	r0, [pc, #88]	; (407fac <loadSerialNumberFromNvm+0x74>)
  407f54:	4916      	ldr	r1, [pc, #88]	; (407fb0 <loadSerialNumberFromNvm+0x78>)
  407f56:	4b17      	ldr	r3, [pc, #92]	; (407fb4 <loadSerialNumberFromNvm+0x7c>)
  407f58:	2232      	movs	r2, #50	; 0x32
  407f5a:	4798      	blx	r3
 */
status_t checkLedConfig(drv_led_config_t* ledConfig)
{
	uint8_t sum = 0;
	
	sum = ledConfig->redLed + ledConfig->greenLed + ledConfig->blueLed;
  407f5c:	7d21      	ldrb	r1, [r4, #20]
  407f5e:	7da2      	ldrb	r2, [r4, #22]
  407f60:	7d63      	ldrb	r3, [r4, #21]
  407f62:	1850      	adds	r0, r2, r1
  407f64:	4418      	add	r0, r3
	if (sum != (DRV_GPIO_PIN_RED_LED + DRV_GPIO_PIN_GREEN_LED + DRV_GPIO_PIN_BLUE_LED))
  407f66:	b2c0      	uxtb	r0, r0
  407f68:	2827      	cmp	r0, #39	; 0x27
  407f6a:	d00b      	beq.n	407f84 <loadSerialNumberFromNvm+0x4c>
			debugPrintString("Serial number not set\r\n");
			strncpy(brainSettings.suitNumber, "SXXXXX", 50);
		}
		if (checkLedConfig(&nvmSettings.ledConfiguration) != STATUS_PASS)
		{
			ledConfiguration.redLed = DRV_GPIO_PIN_RED_LED;
  407f6c:	4b12      	ldr	r3, [pc, #72]	; (407fb8 <loadSerialNumberFromNvm+0x80>)
  407f6e:	200e      	movs	r0, #14
			ledConfiguration.greenLed = DRV_GPIO_PIN_GREEN_LED;
  407f70:	210c      	movs	r1, #12
			ledConfiguration.blueLed = DRV_GPIO_PIN_BLUE_LED;
  407f72:	220d      	movs	r2, #13
			debugPrintString("Serial number not set\r\n");
			strncpy(brainSettings.suitNumber, "SXXXXX", 50);
		}
		if (checkLedConfig(&nvmSettings.ledConfiguration) != STATUS_PASS)
		{
			ledConfiguration.redLed = DRV_GPIO_PIN_RED_LED;
  407f74:	7018      	strb	r0, [r3, #0]
			ledConfiguration.greenLed = DRV_GPIO_PIN_GREEN_LED;
  407f76:	7099      	strb	r1, [r3, #2]
			ledConfiguration.blueLed = DRV_GPIO_PIN_BLUE_LED;
  407f78:	705a      	strb	r2, [r3, #1]
  407f7a:	bd10      	pop	{r4, pc}
			ledConfiguration.blueLed = nvmSettings.ledConfiguration.blueLed;
		}
	}
	else
	{
		debugPrintString("failed to load nvm settings"); 
  407f7c:	480f      	ldr	r0, [pc, #60]	; (407fbc <loadSerialNumberFromNvm+0x84>)
  407f7e:	4b0a      	ldr	r3, [pc, #40]	; (407fa8 <loadSerialNumberFromNvm+0x70>)
  407f80:	4798      	blx	r3
  407f82:	bd10      	pop	{r4, pc}
			ledConfiguration.greenLed = DRV_GPIO_PIN_GREEN_LED;
			ledConfiguration.blueLed = DRV_GPIO_PIN_BLUE_LED;
		}
		else
		{
			ledConfiguration.redLed = nvmSettings.ledConfiguration.redLed;
  407f84:	480c      	ldr	r0, [pc, #48]	; (407fb8 <loadSerialNumberFromNvm+0x80>)
  407f86:	7001      	strb	r1, [r0, #0]
			ledConfiguration.greenLed = nvmSettings.ledConfiguration.greenLed;
  407f88:	7082      	strb	r2, [r0, #2]
			ledConfiguration.blueLed = nvmSettings.ledConfiguration.blueLed;
  407f8a:	7043      	strb	r3, [r0, #1]
  407f8c:	bd10      	pop	{r4, pc}
{
	if(flash_read_user_signature(&nvmSettings, sizeof(nvmSettings)) == 0)
	{
		if(nvmSettings.suitNumber[0] == 'S')
		{
			strncpy(brainSettings.suitNumber, nvmSettings.suitNumber, sizeof(nvmSettings.suitNumber));
  407f8e:	4b09      	ldr	r3, [pc, #36]	; (407fb4 <loadSerialNumberFromNvm+0x7c>)
  407f90:	4806      	ldr	r0, [pc, #24]	; (407fac <loadSerialNumberFromNvm+0x74>)
  407f92:	4621      	mov	r1, r4
  407f94:	2210      	movs	r2, #16
  407f96:	4798      	blx	r3
  407f98:	e7e0      	b.n	407f5c <loadSerialNumberFromNvm+0x24>
  407f9a:	bf00      	nop
  407f9c:	20003e14 	.word	0x20003e14
  407fa0:	0040034d 	.word	0x0040034d
  407fa4:	004165d4 	.word	0x004165d4
  407fa8:	004008c9 	.word	0x004008c9
  407fac:	200001b4 	.word	0x200001b4
  407fb0:	004165ec 	.word	0x004165ec
  407fb4:	0040cb1d 	.word	0x0040cb1d
  407fb8:	20000184 	.word	0x20000184
  407fbc:	004165f4 	.word	0x004165f4

00407fc0 <saveNvmSettings>:
		debugPrintString("failed to load nvm settings"); 
	}
}

status_t saveNvmSettings()
{
  407fc0:	b510      	push	{r4, lr}
	status_t status = STATUS_PASS;
	flash_erase_user_signature();	//erase is mandatory before writing.
  407fc2:	4b0c      	ldr	r3, [pc, #48]	; (407ff4 <saveNvmSettings+0x34>)
  407fc4:	4798      	blx	r3
	/*strncpy(tempSettingString, serialNumber, 50);*/
	if(flash_write_user_signature(&nvmSettings, sizeof(nvmSettings)) == 0)	
  407fc6:	4b0c      	ldr	r3, [pc, #48]	; (407ff8 <saveNvmSettings+0x38>)
  407fc8:	480c      	ldr	r0, [pc, #48]	; (407ffc <saveNvmSettings+0x3c>)
  407fca:	2118      	movs	r1, #24
  407fcc:	4798      	blx	r3
  407fce:	4603      	mov	r3, r0
  407fd0:	b138      	cbz	r0, 407fe2 <saveNvmSettings+0x22>
	{
		debugPrintString("saved nvm settings\r\n"); 
	}
	else
	{
		debugPrintString("failed to save nvm settings\r\n"); 
  407fd2:	480b      	ldr	r0, [pc, #44]	; (408000 <saveNvmSettings+0x40>)
  407fd4:	4b0b      	ldr	r3, [pc, #44]	; (408004 <saveNvmSettings+0x44>)
  407fd6:	4798      	blx	r3
		status = STATUS_FAIL;
  407fd8:	2401      	movs	r4, #1
	}
	loadSerialNumberFromNvm();
  407fda:	4b0b      	ldr	r3, [pc, #44]	; (408008 <saveNvmSettings+0x48>)
  407fdc:	4798      	blx	r3
	return status; 
}
  407fde:	4620      	mov	r0, r4
  407fe0:	bd10      	pop	{r4, pc}
	status_t status = STATUS_PASS;
	flash_erase_user_signature();	//erase is mandatory before writing.
	/*strncpy(tempSettingString, serialNumber, 50);*/
	if(flash_write_user_signature(&nvmSettings, sizeof(nvmSettings)) == 0)	
	{
		debugPrintString("saved nvm settings\r\n"); 
  407fe2:	480a      	ldr	r0, [pc, #40]	; (40800c <saveNvmSettings+0x4c>)
  407fe4:	4a07      	ldr	r2, [pc, #28]	; (408004 <saveNvmSettings+0x44>)
	}
}

status_t saveNvmSettings()
{
	status_t status = STATUS_PASS;
  407fe6:	461c      	mov	r4, r3
	flash_erase_user_signature();	//erase is mandatory before writing.
	/*strncpy(tempSettingString, serialNumber, 50);*/
	if(flash_write_user_signature(&nvmSettings, sizeof(nvmSettings)) == 0)	
	{
		debugPrintString("saved nvm settings\r\n"); 
  407fe8:	4790      	blx	r2
	else
	{
		debugPrintString("failed to save nvm settings\r\n"); 
		status = STATUS_FAIL;
	}
	loadSerialNumberFromNvm();
  407fea:	4b07      	ldr	r3, [pc, #28]	; (408008 <saveNvmSettings+0x48>)
  407fec:	4798      	blx	r3
	return status; 
}
  407fee:	4620      	mov	r0, r4
  407ff0:	bd10      	pop	{r4, pc}
  407ff2:	bf00      	nop
  407ff4:	004003d5 	.word	0x004003d5
  407ff8:	00400379 	.word	0x00400379
  407ffc:	20003e14 	.word	0x20003e14
  408000:	00416628 	.word	0x00416628
  408004:	004008c9 	.word	0x004008c9
  408008:	00407f39 	.word	0x00407f39
  40800c:	00416610 	.word	0x00416610

00408010 <getLineFromBuf>:
/**
 * getLineFromBuf(char* bufPtr, char* resp, size_t respSize)
 * @brief Get one line from the buffer
 */
status_t getLineFromBuf(char* bufPtr, char* resp, size_t respSize)
{
  408010:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	status_t result = STATUS_FAIL; 
	int bufLen = strlen(bufPtr); 
  408014:	4b12      	ldr	r3, [pc, #72]	; (408060 <getLineFromBuf+0x50>)
/**
 * getLineFromBuf(char* bufPtr, char* resp, size_t respSize)
 * @brief Get one line from the buffer
 */
status_t getLineFromBuf(char* bufPtr, char* resp, size_t respSize)
{
  408016:	4688      	mov	r8, r1
  408018:	4617      	mov	r7, r2
  40801a:	4606      	mov	r6, r0
	status_t result = STATUS_FAIL; 
	int bufLen = strlen(bufPtr); 
  40801c:	4798      	blx	r3
	int i = 0;
	if(bufLen == 0)
  40801e:	2800      	cmp	r0, #0
  408020:	dd13      	ble.n	40804a <getLineFromBuf+0x3a>
	{
		return STATUS_FAIL; 
	}
	for(i = 0; i < bufLen && i<respSize; i++)
  408022:	b197      	cbz	r7, 40804a <getLineFromBuf+0x3a>
	{
		resp[i] = bufPtr[i]; 
  408024:	7833      	ldrb	r3, [r6, #0]
  408026:	f888 3000 	strb.w	r3, [r8]
		if(resp[i] == '\n')
  40802a:	2b0a      	cmp	r3, #10
  40802c:	d016      	beq.n	40805c <getLineFromBuf+0x4c>
  40802e:	4645      	mov	r5, r8
  408030:	2300      	movs	r3, #0
  408032:	e007      	b.n	408044 <getLineFromBuf+0x34>
	int i = 0;
	if(bufLen == 0)
	{
		return STATUS_FAIL; 
	}
	for(i = 0; i < bufLen && i<respSize; i++)
  408034:	42bb      	cmp	r3, r7
  408036:	d008      	beq.n	40804a <getLineFromBuf+0x3a>
	{
		resp[i] = bufPtr[i]; 
  408038:	f816 4f01 	ldrb.w	r4, [r6, #1]!
  40803c:	f805 4f01 	strb.w	r4, [r5, #1]!
		if(resp[i] == '\n')
  408040:	2c0a      	cmp	r4, #10
  408042:	d005      	beq.n	408050 <getLineFromBuf+0x40>
	int i = 0;
	if(bufLen == 0)
	{
		return STATUS_FAIL; 
	}
	for(i = 0; i < bufLen && i<respSize; i++)
  408044:	3301      	adds	r3, #1
  408046:	4298      	cmp	r0, r3
  408048:	d1f4      	bne.n	408034 <getLineFromBuf+0x24>
	status_t result = STATUS_FAIL; 
	int bufLen = strlen(bufPtr); 
	int i = 0;
	if(bufLen == 0)
	{
		return STATUS_FAIL; 
  40804a:	2001      	movs	r0, #1
  40804c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  408050:	3301      	adds	r3, #1
	{
		resp[i] = bufPtr[i]; 
		if(resp[i] == '\n')
		{
			result = STATUS_PASS;
			resp[i+1] = 0; //terminate the string! 
  408052:	2000      	movs	r0, #0
  408054:	f808 0003 	strb.w	r0, [r8, r3]
			break; 			
  408058:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return STATUS_FAIL; 
	}
	for(i = 0; i < bufLen && i<respSize; i++)
	{
		resp[i] = bufPtr[i]; 
		if(resp[i] == '\n')
  40805c:	2301      	movs	r3, #1
  40805e:	e7f8      	b.n	408052 <getLineFromBuf+0x42>
  408060:	0040c9a5 	.word	0x0040c9a5

00408064 <decryptBuf>:
/**
 * decryptBuf(uint8_t* buffer, uint16_t length)
 * @brief Decrypt the input buffer and save its updated contents
 */
void decryptBuf(uint8_t* buffer, uint16_t length)
{
  408064:	b470      	push	{r4, r5, r6}
	uint8_t shift = 0;
	//decryption part
	for (int i = 0; i < length; i++)
  408066:	b1e9      	cbz	r1, 4080a4 <decryptBuf+0x40>
  408068:	2400      	movs	r4, #0
	{
		shift = i % 7;
		if (shift == 0)
		{
			shift = 3;
  40806a:	2303      	movs	r3, #3
{
	uint8_t shift = 0;
	//decryption part
	for (int i = 0; i < length; i++)
	{
		shift = i % 7;
  40806c:	4d0e      	ldr	r5, [pc, #56]	; (4080a8 <decryptBuf+0x44>)
  40806e:	e004      	b.n	40807a <decryptBuf+0x16>
  408070:	1ae3      	subs	r3, r4, r3
		if (shift == 0)
		{
			shift = 3;
  408072:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
  408076:	bf08      	it	eq
  408078:	2303      	moveq	r3, #3
 */
uint8_t rotr32 (uint8_t value, unsigned int count)
{
	const unsigned int mask = (CHAR_BIT*sizeof(value)-1);
	count &= mask;
	return (value>>count) | (value<<( (-count) & mask ));
  40807a:	5d02      	ldrb	r2, [r0, r4]
  40807c:	425e      	negs	r6, r3
  40807e:	f006 0607 	and.w	r6, r6, #7
  408082:	fa02 f606 	lsl.w	r6, r2, r6
  408086:	fa42 f303 	asr.w	r3, r2, r3
  40808a:	4333      	orrs	r3, r6
		shift = i % 7;
		if (shift == 0)
		{
			shift = 3;
		}
		buffer[i] = rotr32(buffer[i], shift);
  40808c:	5503      	strb	r3, [r0, r4]
 */
void decryptBuf(uint8_t* buffer, uint16_t length)
{
	uint8_t shift = 0;
	//decryption part
	for (int i = 0; i < length; i++)
  40808e:	3401      	adds	r4, #1
	{
		shift = i % 7;
  408090:	fb84 2305 	smull	r2, r3, r4, r5
  408094:	18e2      	adds	r2, r4, r3
  408096:	17e3      	asrs	r3, r4, #31
  408098:	ebc3 03a2 	rsb	r3, r3, r2, asr #2
 */
void decryptBuf(uint8_t* buffer, uint16_t length)
{
	uint8_t shift = 0;
	//decryption part
	for (int i = 0; i < length; i++)
  40809c:	428c      	cmp	r4, r1
	{
		shift = i % 7;
  40809e:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 */
void decryptBuf(uint8_t* buffer, uint16_t length)
{
	uint8_t shift = 0;
	//decryption part
	for (int i = 0; i < length; i++)
  4080a2:	dbe5      	blt.n	408070 <decryptBuf+0xc>
			shift = 3;
		}
		buffer[i] = rotr32(buffer[i], shift);
	}
	//printf("Decrypted string:\r\n%s\r\n", buffer);	//Debug prints
}
  4080a4:	bc70      	pop	{r4, r5, r6}
  4080a6:	4770      	bx	lr
  4080a8:	92492493 	.word	0x92492493

004080ac <loadSettings>:
/**
 * loadSettings(char* filename)
 * @brief Load configuration from SD-card file to memory
 */
status_t loadSettings(char* filename)
{	
  4080ac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	status_t result = STATUS_PASS;
	static FIL configFileObj;
	packetReceivedMask = 0;
	accelPacketReceivedMask = 0;
  4080b0:	49a7      	ldr	r1, [pc, #668]	; (408350 <loadSettings+0x2a4>)
 */
status_t loadSettings(char* filename)
{	
	status_t result = STATUS_PASS;
	static FIL configFileObj;
	packetReceivedMask = 0;
  4080b2:	f8df a310 	ldr.w	sl, [pc, #784]	; 4083c4 <loadSettings+0x318>
	accelPacketReceivedMask = 0;
	debugPrintString("Opening SD Card to read\r\n");
  4080b6:	4aa7      	ldr	r2, [pc, #668]	; (408354 <loadSettings+0x2a8>)
	//initialize the suitNumber
	//strncpy(brainSettings.suitNumber, "S0001", 10);
	strncpy(brainSettings.channelmap, "FFFFFFFF1F", 10);	//default for the channel mapping
	strncpy(brainSettings.fileName, "MovementLog", 12);	//default for the fileName
	//initialize the run time settings to their defaults. 
	brainSettings.debugPackets = false; 
  4080b8:	f8df 82dc 	ldr.w	r8, [pc, #732]	; 408398 <loadSettings+0x2ec>
	brainSettings.autoTurnOff = true; 
	#ifdef DEBUG
	brainSettings.debugPrintsEnabled = true;
	#endif
	filename[0] = LUN_ID_SD_MMC_0_MEM + '0'; //is this necessary? 
	FRESULT res = f_open(&configFileObj, (char const *)filename, FA_OPEN_EXISTING | FA_READ);
  4080bc:	4da6      	ldr	r5, [pc, #664]	; (408358 <loadSettings+0x2ac>)
/**
 * loadSettings(char* filename)
 * @brief Load configuration from SD-card file to memory
 */
status_t loadSettings(char* filename)
{	
  4080be:	4607      	mov	r7, r0
	status_t result = STATUS_PASS;
	static FIL configFileObj;
	packetReceivedMask = 0;
  4080c0:	2400      	movs	r4, #0
/**
 * loadSettings(char* filename)
 * @brief Load configuration from SD-card file to memory
 */
status_t loadSettings(char* filename)
{	
  4080c2:	b0e7      	sub	sp, #412	; 0x19c
	status_t result = STATUS_PASS;
	static FIL configFileObj;
	packetReceivedMask = 0;
	accelPacketReceivedMask = 0;
	debugPrintString("Opening SD Card to read\r\n");
  4080c4:	48a5      	ldr	r0, [pc, #660]	; (40835c <loadSettings+0x2b0>)
status_t loadSettings(char* filename)
{	
	status_t result = STATUS_PASS;
	static FIL configFileObj;
	packetReceivedMask = 0;
	accelPacketReceivedMask = 0;
  4080c6:	800c      	strh	r4, [r1, #0]
 */
status_t loadSettings(char* filename)
{	
	status_t result = STATUS_PASS;
	static FIL configFileObj;
	packetReceivedMask = 0;
  4080c8:	f8aa 4000 	strh.w	r4, [sl]
	accelPacketReceivedMask = 0;
	debugPrintString("Opening SD Card to read\r\n");
  4080cc:	4790      	blx	r2
	//initialize the suitNumber
	//strncpy(brainSettings.suitNumber, "S0001", 10);
	strncpy(brainSettings.channelmap, "FFFFFFFF1F", 10);	//default for the channel mapping
  4080ce:	4aa4      	ldr	r2, [pc, #656]	; (408360 <loadSettings+0x2b4>)
	strncpy(brainSettings.fileName, "MovementLog", 12);	//default for the fileName
	//initialize the run time settings to their defaults. 
	brainSettings.debugPackets = false; 
  4080d0:	f888 409d 	strb.w	r4, [r8, #157]	; 0x9d
	packetReceivedMask = 0;
	accelPacketReceivedMask = 0;
	debugPrintString("Opening SD Card to read\r\n");
	//initialize the suitNumber
	//strncpy(brainSettings.suitNumber, "S0001", 10);
	strncpy(brainSettings.channelmap, "FFFFFFFF1F", 10);	//default for the channel mapping
  4080d4:	ca07      	ldmia	r2, {r0, r1, r2}
  4080d6:	f108 06a0 	add.w	r6, r8, #160	; 0xa0
  4080da:	4634      	mov	r4, r6
  4080dc:	c403      	stmia	r4!, {r0, r1}
	strncpy(brainSettings.fileName, "MovementLog", 12);	//default for the fileName
  4080de:	4ba1      	ldr	r3, [pc, #644]	; (408364 <loadSettings+0x2b8>)
	packetReceivedMask = 0;
	accelPacketReceivedMask = 0;
	debugPrintString("Opening SD Card to read\r\n");
	//initialize the suitNumber
	//strncpy(brainSettings.suitNumber, "S0001", 10);
	strncpy(brainSettings.channelmap, "FFFFFFFF1F", 10);	//default for the channel mapping
  4080e0:	8022      	strh	r2, [r4, #0]
	strncpy(brainSettings.fileName, "MovementLog", 12);	//default for the fileName
  4080e2:	cb07      	ldmia	r3!, {r0, r1, r2}
	//initialize the run time settings to their defaults. 
	brainSettings.debugPackets = false; 
	brainSettings.autoTurnOff = true; 
  4080e4:	2401      	movs	r4, #1
	#ifdef DEBUG
	brainSettings.debugPrintsEnabled = true;
	#endif
	filename[0] = LUN_ID_SD_MMC_0_MEM + '0'; //is this necessary? 
  4080e6:	f04f 0e30 	mov.w	lr, #48	; 0x30
	accelPacketReceivedMask = 0;
	debugPrintString("Opening SD Card to read\r\n");
	//initialize the suitNumber
	//strncpy(brainSettings.suitNumber, "S0001", 10);
	strncpy(brainSettings.channelmap, "FFFFFFFF1F", 10);	//default for the channel mapping
	strncpy(brainSettings.fileName, "MovementLog", 12);	//default for the fileName
  4080ea:	f8c8 003a 	str.w	r0, [r8, #58]	; 0x3a
  4080ee:	f8c8 103e 	str.w	r1, [r8, #62]	; 0x3e
  4080f2:	f8c8 2042 	str.w	r2, [r8, #66]	; 0x42
	//initialize the run time settings to their defaults. 
	brainSettings.debugPackets = false; 
	brainSettings.autoTurnOff = true; 
  4080f6:	f888 409e 	strb.w	r4, [r8, #158]	; 0x9e
	#ifdef DEBUG
	brainSettings.debugPrintsEnabled = true;
  4080fa:	f888 409f 	strb.w	r4, [r8, #159]	; 0x9f
	#endif
	filename[0] = LUN_ID_SD_MMC_0_MEM + '0'; //is this necessary? 
	FRESULT res = f_open(&configFileObj, (char const *)filename, FA_OPEN_EXISTING | FA_READ);
  4080fe:	4639      	mov	r1, r7
	brainSettings.debugPackets = false; 
	brainSettings.autoTurnOff = true; 
	#ifdef DEBUG
	brainSettings.debugPrintsEnabled = true;
	#endif
	filename[0] = LUN_ID_SD_MMC_0_MEM + '0'; //is this necessary? 
  408100:	f887 e000 	strb.w	lr, [r7]
	FRESULT res = f_open(&configFileObj, (char const *)filename, FA_OPEN_EXISTING | FA_READ);
  408104:	4622      	mov	r2, r4
  408106:	4628      	mov	r0, r5
  408108:	4b97      	ldr	r3, [pc, #604]	; (408368 <loadSettings+0x2bc>)
  40810a:	4798      	blx	r3
	if (res != FR_OK)
  40810c:	4607      	mov	r7, r0
  40810e:	2800      	cmp	r0, #0
  408110:	f040 80d1 	bne.w	4082b6 <loadSettings+0x20a>
	{
		return STATUS_FAIL;
	}
	//read the whole file into a buffer
	char buf[MAX_CONFIG_FILE_SIZE] = {0}; 	 
  408114:	a81b      	add	r0, sp, #108	; 0x6c
  408116:	4639      	mov	r1, r7
  408118:	f44f 7296 	mov.w	r2, #300	; 0x12c
  40811c:	4b93      	ldr	r3, [pc, #588]	; (40836c <loadSettings+0x2c0>)
  40811e:	4798      	blx	r3
	uint16_t bytes_read = 0, total_bytes_read = 0;	
	while(total_bytes_read < configFileObj.fsize && res == FR_OK)
  408120:	68ec      	ldr	r4, [r5, #12]
	{
		return STATUS_FAIL;
	}
	//read the whole file into a buffer
	char buf[MAX_CONFIG_FILE_SIZE] = {0}; 	 
	uint16_t bytes_read = 0, total_bytes_read = 0;	
  408122:	f8ad 7016 	strh.w	r7, [sp, #22]
	while(total_bytes_read < configFileObj.fsize && res == FR_OK)
  408126:	b1ac      	cbz	r4, 408154 <loadSettings+0xa8>
  408128:	4639      	mov	r1, r7
	{
		return STATUS_FAIL;
	}
	//read the whole file into a buffer
	char buf[MAX_CONFIG_FILE_SIZE] = {0}; 	 
	uint16_t bytes_read = 0, total_bytes_read = 0;	
  40812a:	460c      	mov	r4, r1
  40812c:	4f90      	ldr	r7, [pc, #576]	; (408370 <loadSettings+0x2c4>)
  40812e:	e000      	b.n	408132 <loadSettings+0x86>
	while(total_bytes_read < configFileObj.fsize && res == FR_OK)
  408130:	b980      	cbnz	r0, 408154 <loadSettings+0xa8>
	{
		res = f_read(&configFileObj, buf+total_bytes_read, MAX_CONFIG_FILE_SIZE - total_bytes_read, &bytes_read);
  408132:	f10d 0c6c 	add.w	ip, sp, #108	; 0x6c
  408136:	f5c4 7296 	rsb	r2, r4, #300	; 0x12c
  40813a:	4461      	add	r1, ip
  40813c:	f10d 0316 	add.w	r3, sp, #22
  408140:	4885      	ldr	r0, [pc, #532]	; (408358 <loadSettings+0x2ac>)
  408142:	47b8      	blx	r7
		total_bytes_read += bytes_read; 
  408144:	f8bd 2016 	ldrh.w	r2, [sp, #22]
		return STATUS_FAIL;
	}
	//read the whole file into a buffer
	char buf[MAX_CONFIG_FILE_SIZE] = {0}; 	 
	uint16_t bytes_read = 0, total_bytes_read = 0;	
	while(total_bytes_read < configFileObj.fsize && res == FR_OK)
  408148:	68eb      	ldr	r3, [r5, #12]
	{
		res = f_read(&configFileObj, buf+total_bytes_read, MAX_CONFIG_FILE_SIZE - total_bytes_read, &bytes_read);
		total_bytes_read += bytes_read; 
  40814a:	4414      	add	r4, r2
  40814c:	b2a4      	uxth	r4, r4
		return STATUS_FAIL;
	}
	//read the whole file into a buffer
	char buf[MAX_CONFIG_FILE_SIZE] = {0}; 	 
	uint16_t bytes_read = 0, total_bytes_read = 0;	
	while(total_bytes_read < configFileObj.fsize && res == FR_OK)
  40814e:	429c      	cmp	r4, r3
  408150:	4621      	mov	r1, r4
  408152:	d3ed      	bcc.n	408130 <loadSettings+0x84>
		res = f_read(&configFileObj, buf+total_bytes_read, MAX_CONFIG_FILE_SIZE - total_bytes_read, &bytes_read);
		total_bytes_read += bytes_read; 
	}
	char* bufPtr = 0;	//set pointer to start of buffer
	//Decrypt the data
	if (strncmp(buf, "ee", 2) == 0)		//check if the file is encrypted
  408154:	a81b      	add	r0, sp, #108	; 0x6c
  408156:	4987      	ldr	r1, [pc, #540]	; (408374 <loadSettings+0x2c8>)
  408158:	4b87      	ldr	r3, [pc, #540]	; (408378 <loadSettings+0x2cc>)
  40815a:	2202      	movs	r2, #2
  40815c:	4798      	blx	r3
  40815e:	2800      	cmp	r0, #0
  408160:	f000 80ad 	beq.w	4082be <loadSettings+0x212>
		bufPtr = buf + 2;
		decryptBuf(bufPtr, total_bytes_read);
	}
	else
	{
		bufPtr = buf;
  408164:	ad1b      	add	r5, sp, #108	; 0x6c
	}
	//now parse the file and 
	status_t step_status = STATUS_PASS;
	char line[50] = {0}; 
  408166:	2400      	movs	r4, #0
	char temp[50] = {0}; 
	int NumberOfNods = 0;	
	if(getLineFromBuf(bufPtr, line, sizeof(line)) == PASS)
  408168:	a90e      	add	r1, sp, #56	; 0x38
  40816a:	4628      	mov	r0, r5
  40816c:	2232      	movs	r2, #50	; 0x32
  40816e:	4b83      	ldr	r3, [pc, #524]	; (40837c <loadSettings+0x2d0>)
	{
		bufPtr = buf;
	}
	//now parse the file and 
	status_t step_status = STATUS_PASS;
	char line[50] = {0}; 
  408170:	940f      	str	r4, [sp, #60]	; 0x3c
  408172:	9410      	str	r4, [sp, #64]	; 0x40
  408174:	9411      	str	r4, [sp, #68]	; 0x44
  408176:	9412      	str	r4, [sp, #72]	; 0x48
  408178:	9413      	str	r4, [sp, #76]	; 0x4c
  40817a:	9414      	str	r4, [sp, #80]	; 0x50
  40817c:	940e      	str	r4, [sp, #56]	; 0x38
  40817e:	9415      	str	r4, [sp, #84]	; 0x54
	char temp[50] = {0}; 
	int NumberOfNods = 0;	
  408180:	9406      	str	r4, [sp, #24]
	{
		bufPtr = buf;
	}
	//now parse the file and 
	status_t step_status = STATUS_PASS;
	char line[50] = {0}; 
  408182:	9416      	str	r4, [sp, #88]	; 0x58
  408184:	9417      	str	r4, [sp, #92]	; 0x5c
  408186:	9418      	str	r4, [sp, #96]	; 0x60
  408188:	9419      	str	r4, [sp, #100]	; 0x64
  40818a:	f8ad 4068 	strh.w	r4, [sp, #104]	; 0x68
	char temp[50] = {0}; 
	int NumberOfNods = 0;	
	if(getLineFromBuf(bufPtr, line, sizeof(line)) == PASS)
  40818e:	4798      	blx	r3
  408190:	2800      	cmp	r0, #0
  408192:	f000 809b 	beq.w	4082cc <loadSettings+0x220>
		strcat(brainSettings.channelmap, "\r\n");	//Add CR+LF at the end of the srting
		strcat(brainSettings.imuSet, "\r\n");
		bufPtr += strlen(line); 		
	}
	brainSettings.numberOfAccelFrames = 0; 
	brainSettings.numberOfImus = NumberOfNods; 
  408196:	9906      	ldr	r1, [sp, #24]
	//initialize the expectedNumberOfNods
	quinticConfig[0].expectedNumberOfNods = 0;
  408198:	f8df c22c 	ldr.w	ip, [pc, #556]	; 4083c8 <loadSettings+0x31c>
		}
		strcat(brainSettings.channelmap, "\r\n");	//Add CR+LF at the end of the srting
		strcat(brainSettings.imuSet, "\r\n");
		bufPtr += strlen(line); 		
	}
	brainSettings.numberOfAccelFrames = 0; 
  40819c:	f8df 81f8 	ldr.w	r8, [pc, #504]	; 408398 <loadSettings+0x2ec>
  4081a0:	2300      	movs	r3, #0
	int i=0, j=0; 
	int quinticIndex = 0; 
	int imuId = 0;
	char tempMACAddress[20] = {0}; 
	//packetReceivedMask = 0; //reset the mask	
	for(i = 0; i < NumberOfNods; i++)
  4081a2:	4299      	cmp	r1, r3
	quinticConfig[1].expectedNumberOfNods = 0;
	quinticConfig[2].expectedNumberOfNods = 0;	
	int i=0, j=0; 
	int quinticIndex = 0; 
	int imuId = 0;
	char tempMACAddress[20] = {0}; 
  4081a4:	930a      	str	r3, [sp, #40]	; 0x28
  4081a6:	930b      	str	r3, [sp, #44]	; 0x2c
  4081a8:	930c      	str	r3, [sp, #48]	; 0x30
		}
		strcat(brainSettings.channelmap, "\r\n");	//Add CR+LF at the end of the srting
		strcat(brainSettings.imuSet, "\r\n");
		bufPtr += strlen(line); 		
	}
	brainSettings.numberOfAccelFrames = 0; 
  4081aa:	f8c8 30b4 	str.w	r3, [r8, #180]	; 0xb4
	quinticConfig[1].expectedNumberOfNods = 0;
	quinticConfig[2].expectedNumberOfNods = 0;	
	int i=0, j=0; 
	int quinticIndex = 0; 
	int imuId = 0;
	char tempMACAddress[20] = {0}; 
  4081ae:	930d      	str	r3, [sp, #52]	; 0x34
		bufPtr += strlen(line); 		
	}
	brainSettings.numberOfAccelFrames = 0; 
	brainSettings.numberOfImus = NumberOfNods; 
	//initialize the expectedNumberOfNods
	quinticConfig[0].expectedNumberOfNods = 0;
  4081b0:	f8cc 3018 	str.w	r3, [ip, #24]
	quinticConfig[1].expectedNumberOfNods = 0;
  4081b4:	f8cc 3054 	str.w	r3, [ip, #84]	; 0x54
	quinticConfig[2].expectedNumberOfNods = 0;	
  4081b8:	f8cc 3090 	str.w	r3, [ip, #144]	; 0x90
	int i=0, j=0; 
	int quinticIndex = 0; 
  4081bc:	9307      	str	r3, [sp, #28]
	int imuId = 0;
  4081be:	9308      	str	r3, [sp, #32]
	char tempMACAddress[20] = {0}; 
  4081c0:	9309      	str	r3, [sp, #36]	; 0x24
		strcat(brainSettings.channelmap, "\r\n");	//Add CR+LF at the end of the srting
		strcat(brainSettings.imuSet, "\r\n");
		bufPtr += strlen(line); 		
	}
	brainSettings.numberOfAccelFrames = 0; 
	brainSettings.numberOfImus = NumberOfNods; 
  4081c2:	f8c8 1004 	str.w	r1, [r8, #4]
	int i=0, j=0; 
	int quinticIndex = 0; 
	int imuId = 0;
	char tempMACAddress[20] = {0}; 
	//packetReceivedMask = 0; //reset the mask	
	for(i = 0; i < NumberOfNods; i++)
  4081c6:	dd60      	ble.n	40828a <loadSettings+0x1de>
					debugPrintStringInt("received incorrect imuId",imuId); 
					break;	
				}
				packetReceivedMask |= (1<<imuId);
				accelPacketReceivedMask |= (1<<imuId);
				imuConfig[imuId].imuId = imuId; 
  4081c8:	4e6d      	ldr	r6, [pc, #436]	; (408380 <loadSettings+0x2d4>)
	int i=0, j=0; 
	int quinticIndex = 0; 
	int imuId = 0;
	char tempMACAddress[20] = {0}; 
	//packetReceivedMask = 0; //reset the mask	
	for(i = 0; i < NumberOfNods; i++)
  4081ca:	4699      	mov	r9, r3
  4081cc:	e052      	b.n	408274 <loadSettings+0x1c8>
	{
		if(getLineFromBuf(bufPtr, line,sizeof(line)) == STATUS_PASS)
		{			
			if(sscanf(line,"%d,%d,%s\r\n",&quinticIndex, &imuId, tempMACAddress) < 2)
  4081ce:	ac09      	add	r4, sp, #36	; 0x24
  4081d0:	9400      	str	r4, [sp, #0]
  4081d2:	a80e      	add	r0, sp, #56	; 0x38
  4081d4:	f8df 81c8 	ldr.w	r8, [pc, #456]	; 4083a0 <loadSettings+0x2f4>
  4081d8:	47c0      	blx	r8
  4081da:	42b8      	cmp	r0, r7
					break;	
				}
				packetReceivedMask |= (1<<imuId);
				accelPacketReceivedMask |= (1<<imuId);
				imuConfig[imuId].imuId = imuId; 
				snprintf(imuConfig[imuId].macAddress,20, "%s\r\n",tempMACAddress); 
  4081dc:	f04f 0114 	mov.w	r1, #20
  4081e0:	4a68      	ldr	r2, [pc, #416]	; (408384 <loadSettings+0x2d8>)
  4081e2:	ab09      	add	r3, sp, #36	; 0x24
	//packetReceivedMask = 0; //reset the mask	
	for(i = 0; i < NumberOfNods; i++)
	{
		if(getLineFromBuf(bufPtr, line,sizeof(line)) == STATUS_PASS)
		{			
			if(sscanf(line,"%d,%d,%s\r\n",&quinticIndex, &imuId, tempMACAddress) < 2)
  4081e4:	f340 809c 	ble.w	408320 <loadSettings+0x274>
				debugPrintString("failed to parse IMU settings\r\n"); 
				break;
			}
			else
			{
				if(imuId < 0 || imuId > 9)
  4081e8:	9c08      	ldr	r4, [sp, #32]
					debugPrintStringInt("received incorrect imuId",imuId); 
					break;	
				}
				packetReceivedMask |= (1<<imuId);
				accelPacketReceivedMask |= (1<<imuId);
				imuConfig[imuId].imuId = imuId; 
  4081ea:	ebc4 0ec4 	rsb	lr, r4, r4, lsl #3
				if(imuId < 0 || imuId > 9)
				{
					debugPrintStringInt("received incorrect imuId",imuId); 
					break;	
				}
				packetReceivedMask |= (1<<imuId);
  4081ee:	fa07 fc04 	lsl.w	ip, r7, r4
				accelPacketReceivedMask |= (1<<imuId);
				imuConfig[imuId].imuId = imuId; 
  4081f2:	eb06 00ce 	add.w	r0, r6, lr, lsl #3
				debugPrintString("failed to parse IMU settings\r\n"); 
				break;
			}
			else
			{
				if(imuId < 0 || imuId > 9)
  4081f6:	2c09      	cmp	r4, #9
				{
					debugPrintStringInt("received incorrect imuId",imuId); 
					break;	
				}
				packetReceivedMask |= (1<<imuId);
  4081f8:	fa1f fc8c 	uxth.w	ip, ip
				accelPacketReceivedMask |= (1<<imuId);
				imuConfig[imuId].imuId = imuId; 
				snprintf(imuConfig[imuId].macAddress,20, "%s\r\n",tempMACAddress); 
  4081fc:	f100 0004 	add.w	r0, r0, #4
				debugPrintString("failed to parse IMU settings\r\n"); 
				break;
			}
			else
			{
				if(imuId < 0 || imuId > 9)
  408200:	f200 8093 	bhi.w	40832a <loadSettings+0x27e>
				{
					debugPrintStringInt("received incorrect imuId",imuId); 
					break;	
				}
				packetReceivedMask |= (1<<imuId);
				accelPacketReceivedMask |= (1<<imuId);
  408204:	f8df 8148 	ldr.w	r8, [pc, #328]	; 408350 <loadSettings+0x2a4>
				if(imuId < 0 || imuId > 9)
				{
					debugPrintStringInt("received incorrect imuId",imuId); 
					break;	
				}
				packetReceivedMask |= (1<<imuId);
  408208:	f8ba b000 	ldrh.w	fp, [sl]
				accelPacketReceivedMask |= (1<<imuId);
  40820c:	f8b8 8000 	ldrh.w	r8, [r8]
				imuConfig[imuId].imuId = imuId; 
  408210:	f846 403e 	str.w	r4, [r6, lr, lsl #3]
				{
					debugPrintStringInt("received incorrect imuId",imuId); 
					break;	
				}
				packetReceivedMask |= (1<<imuId);
				accelPacketReceivedMask |= (1<<imuId);
  408214:	4c4e      	ldr	r4, [pc, #312]	; (408350 <loadSettings+0x2a4>)
				if(imuId < 0 || imuId > 9)
				{
					debugPrintStringInt("received incorrect imuId",imuId); 
					break;	
				}
				packetReceivedMask |= (1<<imuId);
  408216:	ea4c 0b0b 	orr.w	fp, ip, fp
				accelPacketReceivedMask |= (1<<imuId);
  40821a:	ea4c 0c08 	orr.w	ip, ip, r8
				imuConfig[imuId].imuId = imuId; 
				snprintf(imuConfig[imuId].macAddress,20, "%s\r\n",tempMACAddress); 
  40821e:	f8df 81ac 	ldr.w	r8, [pc, #428]	; 4083cc <loadSettings+0x320>
				{
					debugPrintStringInt("received incorrect imuId",imuId); 
					break;	
				}
				packetReceivedMask |= (1<<imuId);
				accelPacketReceivedMask |= (1<<imuId);
  408222:	f8a4 c000 	strh.w	ip, [r4]
				if(imuId < 0 || imuId > 9)
				{
					debugPrintStringInt("received incorrect imuId",imuId); 
					break;	
				}
				packetReceivedMask |= (1<<imuId);
  408226:	f8aa b000 	strh.w	fp, [sl]
				accelPacketReceivedMask |= (1<<imuId);
				imuConfig[imuId].imuId = imuId; 
				snprintf(imuConfig[imuId].macAddress,20, "%s\r\n",tempMACAddress); 
  40822a:	47c0      	blx	r8
				imuConfig[imuId].imuValid = true;
  40822c:	9908      	ldr	r1, [sp, #32]
				
				if(quinticIndex < 0 || quinticIndex > 2)
  40822e:	9b07      	ldr	r3, [sp, #28]
				{
					debugPrintStringInt("failed to assign IMU ",i); 
					break;
				}
				if(quinticConfig[quinticIndex].expectedNumberOfNods >= MAX_NUMBER_OF_IMUS)
  408230:	f8df 8194 	ldr.w	r8, [pc, #404]	; 4083c8 <loadSettings+0x31c>
			}
			//debugPrintStringInt("loaded settings for IMU ",imuConfig[imuId].imuId);
			//debugPrintStringInt("On quintic ",quinticIndex);
			//debugPrintString(imuConfig[imuId].macAddress);
			//printf("loaded settings for IMU %d on Q%d, %s",imuConfig[imuId].imuId,quinticIndex, imuConfig[imuId].macAddress);
			bufPtr += strlen(line); 
  408234:	f8df c16c 	ldr.w	ip, [pc, #364]	; 4083a4 <loadSettings+0x2f8>
				}
				packetReceivedMask |= (1<<imuId);
				accelPacketReceivedMask |= (1<<imuId);
				imuConfig[imuId].imuId = imuId; 
				snprintf(imuConfig[imuId].macAddress,20, "%s\r\n",tempMACAddress); 
				imuConfig[imuId].imuValid = true;
  408238:	ebc1 04c1 	rsb	r4, r1, r1, lsl #3
  40823c:	eb06 04c4 	add.w	r4, r6, r4, lsl #3
				if(quinticIndex < 0 || quinticIndex > 2)
				{
					debugPrintStringInt("failed to assign IMU ",i); 
					break;
				}
				if(quinticConfig[quinticIndex].expectedNumberOfNods >= MAX_NUMBER_OF_IMUS)
  408240:	ebc3 1203 	rsb	r2, r3, r3, lsl #4
				accelPacketReceivedMask |= (1<<imuId);
				imuConfig[imuId].imuId = imuId; 
				snprintf(imuConfig[imuId].macAddress,20, "%s\r\n",tempMACAddress); 
				imuConfig[imuId].imuValid = true;
				
				if(quinticIndex < 0 || quinticIndex > 2)
  408244:	2b02      	cmp	r3, #2
				{
					debugPrintStringInt("failed to assign IMU ",i); 
					break;
				}
				if(quinticConfig[quinticIndex].expectedNumberOfNods >= MAX_NUMBER_OF_IMUS)
  408246:	eb08 0e82 	add.w	lr, r8, r2, lsl #2
			}
			//debugPrintStringInt("loaded settings for IMU ",imuConfig[imuId].imuId);
			//debugPrintStringInt("On quintic ",quinticIndex);
			//debugPrintString(imuConfig[imuId].macAddress);
			//printf("loaded settings for IMU %d on Q%d, %s",imuConfig[imuId].imuId,quinticIndex, imuConfig[imuId].macAddress);
			bufPtr += strlen(line); 
  40824a:	a80e      	add	r0, sp, #56	; 0x38
				}
				packetReceivedMask |= (1<<imuId);
				accelPacketReceivedMask |= (1<<imuId);
				imuConfig[imuId].imuId = imuId; 
				snprintf(imuConfig[imuId].macAddress,20, "%s\r\n",tempMACAddress); 
				imuConfig[imuId].imuValid = true;
  40824c:	61a7      	str	r7, [r4, #24]
				
				if(quinticIndex < 0 || quinticIndex > 2)
  40824e:	d871      	bhi.n	408334 <loadSettings+0x288>
				{
					debugPrintStringInt("failed to assign IMU ",i); 
					break;
				}
				if(quinticConfig[quinticIndex].expectedNumberOfNods >= MAX_NUMBER_OF_IMUS)
  408250:	f8de 3018 	ldr.w	r3, [lr, #24]
  408254:	2b09      	cmp	r3, #9
				{
					debugPrintStringInt("failed to assign IMU ",imuId);
					break;
				}
				quinticConfig[quinticIndex].imuArray[quinticConfig[quinticIndex].expectedNumberOfNods++] = &imuConfig[imuId]; 
  408256:	441a      	add	r2, r3
  408258:	f103 0701 	add.w	r7, r3, #1
	int i=0, j=0; 
	int quinticIndex = 0; 
	int imuId = 0;
	char tempMACAddress[20] = {0}; 
	//packetReceivedMask = 0; //reset the mask	
	for(i = 0; i < NumberOfNods; i++)
  40825c:	f109 0901 	add.w	r9, r9, #1
				if(quinticIndex < 0 || quinticIndex > 2)
				{
					debugPrintStringInt("failed to assign IMU ",i); 
					break;
				}
				if(quinticConfig[quinticIndex].expectedNumberOfNods >= MAX_NUMBER_OF_IMUS)
  408260:	dc6d      	bgt.n	40833e <loadSettings+0x292>
				{
					debugPrintStringInt("failed to assign IMU ",imuId);
					break;
				}
				quinticConfig[quinticIndex].imuArray[quinticConfig[quinticIndex].expectedNumberOfNods++] = &imuConfig[imuId]; 
  408262:	f8ce 7018 	str.w	r7, [lr, #24]
  408266:	f848 4022 	str.w	r4, [r8, r2, lsl #2]
			}
			//debugPrintStringInt("loaded settings for IMU ",imuConfig[imuId].imuId);
			//debugPrintStringInt("On quintic ",quinticIndex);
			//debugPrintString(imuConfig[imuId].macAddress);
			//printf("loaded settings for IMU %d on Q%d, %s",imuConfig[imuId].imuId,quinticIndex, imuConfig[imuId].macAddress);
			bufPtr += strlen(line); 
  40826a:	47e0      	blx	ip
	int i=0, j=0; 
	int quinticIndex = 0; 
	int imuId = 0;
	char tempMACAddress[20] = {0}; 
	//packetReceivedMask = 0; //reset the mask	
	for(i = 0; i < NumberOfNods; i++)
  40826c:	9b06      	ldr	r3, [sp, #24]
  40826e:	454b      	cmp	r3, r9
			}
			//debugPrintStringInt("loaded settings for IMU ",imuConfig[imuId].imuId);
			//debugPrintStringInt("On quintic ",quinticIndex);
			//debugPrintString(imuConfig[imuId].macAddress);
			//printf("loaded settings for IMU %d on Q%d, %s",imuConfig[imuId].imuId,quinticIndex, imuConfig[imuId].macAddress);
			bufPtr += strlen(line); 
  408270:	4405      	add	r5, r0
	int i=0, j=0; 
	int quinticIndex = 0; 
	int imuId = 0;
	char tempMACAddress[20] = {0}; 
	//packetReceivedMask = 0; //reset the mask	
	for(i = 0; i < NumberOfNods; i++)
  408272:	dd0a      	ble.n	40828a <loadSettings+0x1de>
	{
		if(getLineFromBuf(bufPtr, line,sizeof(line)) == STATUS_PASS)
  408274:	a90e      	add	r1, sp, #56	; 0x38
  408276:	2232      	movs	r2, #50	; 0x32
  408278:	4b40      	ldr	r3, [pc, #256]	; (40837c <loadSettings+0x2d0>)
  40827a:	4628      	mov	r0, r5
  40827c:	4798      	blx	r3
				if(imuId < 0 || imuId > 9)
				{
					debugPrintStringInt("received incorrect imuId",imuId); 
					break;	
				}
				packetReceivedMask |= (1<<imuId);
  40827e:	2701      	movs	r7, #1
	//packetReceivedMask = 0; //reset the mask	
	for(i = 0; i < NumberOfNods; i++)
	{
		if(getLineFromBuf(bufPtr, line,sizeof(line)) == STATUS_PASS)
		{			
			if(sscanf(line,"%d,%d,%s\r\n",&quinticIndex, &imuId, tempMACAddress) < 2)
  408280:	4941      	ldr	r1, [pc, #260]	; (408388 <loadSettings+0x2dc>)
  408282:	aa07      	add	r2, sp, #28
  408284:	ab08      	add	r3, sp, #32
	int imuId = 0;
	char tempMACAddress[20] = {0}; 
	//packetReceivedMask = 0; //reset the mask	
	for(i = 0; i < NumberOfNods; i++)
	{
		if(getLineFromBuf(bufPtr, line,sizeof(line)) == STATUS_PASS)
  408286:	2800      	cmp	r0, #0
  408288:	d0a1      	beq.n	4081ce <loadSettings+0x122>
		//for(j=0;j<quinticConfig[i].expectedNumberOfNods;j++)
		//{
			//quinticConfig[i].imuMask[j] = '1'; 
		//}
	//}	
	debugPrintString("Closing the file\r\n");
  40828a:	4840      	ldr	r0, [pc, #256]	; (40838c <loadSettings+0x2e0>)
  40828c:	4c31      	ldr	r4, [pc, #196]	; (408354 <loadSettings+0x2a8>)
  40828e:	47a0      	blx	r4
	res = f_close(&configFileObj);
  408290:	4831      	ldr	r0, [pc, #196]	; (408358 <loadSettings+0x2ac>)
  408292:	4b3f      	ldr	r3, [pc, #252]	; (408390 <loadSettings+0x2e4>)
  408294:	4798      	blx	r3
	if (res != FR_OK)
  408296:	2800      	cmp	r0, #0
  408298:	d13c      	bne.n	408314 <loadSettings+0x268>
		debugPrintString("Error: Cannot Close file\r\n");
		return STATUS_FAIL;
	}
	brainSettings.isLoaded = 1; 	
		
	packetReceivedMask |= 1<<9; //add mask for fabric sense
  40829a:	f8ba 2000 	ldrh.w	r2, [sl]
	if (res != FR_OK)
	{		
		debugPrintString("Error: Cannot Close file\r\n");
		return STATUS_FAIL;
	}
	brainSettings.isLoaded = 1; 	
  40829e:	f8df c0f8 	ldr.w	ip, [pc, #248]	; 408398 <loadSettings+0x2ec>
  4082a2:	2301      	movs	r3, #1
		
	packetReceivedMask |= 1<<9; //add mask for fabric sense
  4082a4:	f442 7200 	orr.w	r2, r2, #512	; 0x200
  4082a8:	f8aa 2000 	strh.w	r2, [sl]
	if (res != FR_OK)
	{		
		debugPrintString("Error: Cannot Close file\r\n");
		return STATUS_FAIL;
	}
	brainSettings.isLoaded = 1; 	
  4082ac:	f8cc 3000 	str.w	r3, [ip]
		
	packetReceivedMask |= 1<<9; //add mask for fabric sense
	return STATUS_PASS; 
}
  4082b0:	b067      	add	sp, #412	; 0x19c
  4082b2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	#endif
	filename[0] = LUN_ID_SD_MMC_0_MEM + '0'; //is this necessary? 
	FRESULT res = f_open(&configFileObj, (char const *)filename, FA_OPEN_EXISTING | FA_READ);
	if (res != FR_OK)
	{
		return STATUS_FAIL;
  4082b6:	4620      	mov	r0, r4
	}
	brainSettings.isLoaded = 1; 	
		
	packetReceivedMask |= 1<<9; //add mask for fabric sense
	return STATUS_PASS; 
}
  4082b8:	b067      	add	sp, #412	; 0x19c
  4082ba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	char* bufPtr = 0;	//set pointer to start of buffer
	//Decrypt the data
	if (strncmp(buf, "ee", 2) == 0)		//check if the file is encrypted
	{
		bufPtr = buf + 2;
		decryptBuf(bufPtr, total_bytes_read);
  4082be:	f10d 006e 	add.w	r0, sp, #110	; 0x6e
  4082c2:	4621      	mov	r1, r4
  4082c4:	4b33      	ldr	r3, [pc, #204]	; (408394 <loadSettings+0x2e8>)
	}
	char* bufPtr = 0;	//set pointer to start of buffer
	//Decrypt the data
	if (strncmp(buf, "ee", 2) == 0)		//check if the file is encrypted
	{
		bufPtr = buf + 2;
  4082c6:	4605      	mov	r5, r0
		decryptBuf(bufPtr, total_bytes_read);
  4082c8:	4798      	blx	r3
  4082ca:	e74c      	b.n	408166 <loadSettings+0xba>
	char line[50] = {0}; 
	char temp[50] = {0}; 
	int NumberOfNods = 0;	
	if(getLineFromBuf(bufPtr, line, sizeof(line)) == PASS)
	{
		if(sscanf(line, "%s ,%d, %s ,\r\n", brainSettings.imuSet, &NumberOfNods, brainSettings.channelmap) < 2)
  4082cc:	4c32      	ldr	r4, [pc, #200]	; (408398 <loadSettings+0x2ec>)
  4082ce:	9600      	str	r6, [sp, #0]
  4082d0:	f104 0289 	add.w	r2, r4, #137	; 0x89
  4082d4:	a80e      	add	r0, sp, #56	; 0x38
  4082d6:	4931      	ldr	r1, [pc, #196]	; (40839c <loadSettings+0x2f0>)
  4082d8:	4e31      	ldr	r6, [pc, #196]	; (4083a0 <loadSettings+0x2f4>)
  4082da:	ab06      	add	r3, sp, #24
  4082dc:	47b0      	blx	r6
  4082de:	2801      	cmp	r0, #1
  4082e0:	dd31      	ble.n	408346 <loadSettings+0x29a>
		{
			debugPrintString("failed to read settings\r\n");
			return STATUS_FAIL; 
		}
		strcat(brainSettings.channelmap, "\r\n");	//Add CR+LF at the end of the srting
  4082e2:	4e30      	ldr	r6, [pc, #192]	; (4083a4 <loadSettings+0x2f8>)
  4082e4:	f104 00a0 	add.w	r0, r4, #160	; 0xa0
  4082e8:	47b0      	blx	r6
  4082ea:	4b2f      	ldr	r3, [pc, #188]	; (4083a8 <loadSettings+0x2fc>)
  4082ec:	30a0      	adds	r0, #160	; 0xa0
  4082ee:	1822      	adds	r2, r4, r0
  4082f0:	f8b3 8000 	ldrh.w	r8, [r3]
  4082f4:	789f      	ldrb	r7, [r3, #2]
  4082f6:	f824 8000 	strh.w	r8, [r4, r0]
		strcat(brainSettings.imuSet, "\r\n");
  4082fa:	f104 0089 	add.w	r0, r4, #137	; 0x89
		if(sscanf(line, "%s ,%d, %s ,\r\n", brainSettings.imuSet, &NumberOfNods, brainSettings.channelmap) < 2)
		{
			debugPrintString("failed to read settings\r\n");
			return STATUS_FAIL; 
		}
		strcat(brainSettings.channelmap, "\r\n");	//Add CR+LF at the end of the srting
  4082fe:	7097      	strb	r7, [r2, #2]
		strcat(brainSettings.imuSet, "\r\n");
  408300:	47b0      	blx	r6
  408302:	3088      	adds	r0, #136	; 0x88
  408304:	4404      	add	r4, r0
		bufPtr += strlen(line); 		
  408306:	a80e      	add	r0, sp, #56	; 0x38
		{
			debugPrintString("failed to read settings\r\n");
			return STATUS_FAIL; 
		}
		strcat(brainSettings.channelmap, "\r\n");	//Add CR+LF at the end of the srting
		strcat(brainSettings.imuSet, "\r\n");
  408308:	f8a4 8001 	strh.w	r8, [r4, #1]
  40830c:	70e7      	strb	r7, [r4, #3]
		bufPtr += strlen(line); 		
  40830e:	47b0      	blx	r6
  408310:	4405      	add	r5, r0
  408312:	e740      	b.n	408196 <loadSettings+0xea>
	//}	
	debugPrintString("Closing the file\r\n");
	res = f_close(&configFileObj);
	if (res != FR_OK)
	{		
		debugPrintString("Error: Cannot Close file\r\n");
  408314:	4825      	ldr	r0, [pc, #148]	; (4083ac <loadSettings+0x300>)
  408316:	47a0      	blx	r4
		return STATUS_FAIL;
  408318:	2001      	movs	r0, #1
	}
	brainSettings.isLoaded = 1; 	
		
	packetReceivedMask |= 1<<9; //add mask for fabric sense
	return STATUS_PASS; 
}
  40831a:	b067      	add	sp, #412	; 0x19c
  40831c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	{
		if(getLineFromBuf(bufPtr, line,sizeof(line)) == STATUS_PASS)
		{			
			if(sscanf(line,"%d,%d,%s\r\n",&quinticIndex, &imuId, tempMACAddress) < 2)
			{
				debugPrintString("failed to parse IMU settings\r\n"); 
  408320:	4823      	ldr	r0, [pc, #140]	; (4083b0 <loadSettings+0x304>)
  408322:	f8df c030 	ldr.w	ip, [pc, #48]	; 408354 <loadSettings+0x2a8>
  408326:	47e0      	blx	ip
				break;
  408328:	e7af      	b.n	40828a <loadSettings+0x1de>
			}
			else
			{
				if(imuId < 0 || imuId > 9)
				{
					debugPrintStringInt("received incorrect imuId",imuId); 
  40832a:	4621      	mov	r1, r4
  40832c:	4821      	ldr	r0, [pc, #132]	; (4083b4 <loadSettings+0x308>)
  40832e:	4b22      	ldr	r3, [pc, #136]	; (4083b8 <loadSettings+0x30c>)
  408330:	4798      	blx	r3
					break;	
  408332:	e7aa      	b.n	40828a <loadSettings+0x1de>
				snprintf(imuConfig[imuId].macAddress,20, "%s\r\n",tempMACAddress); 
				imuConfig[imuId].imuValid = true;
				
				if(quinticIndex < 0 || quinticIndex > 2)
				{
					debugPrintStringInt("failed to assign IMU ",i); 
  408334:	4649      	mov	r1, r9
  408336:	4821      	ldr	r0, [pc, #132]	; (4083bc <loadSettings+0x310>)
  408338:	4b1f      	ldr	r3, [pc, #124]	; (4083b8 <loadSettings+0x30c>)
  40833a:	4798      	blx	r3
					break;
  40833c:	e7a5      	b.n	40828a <loadSettings+0x1de>
				}
				if(quinticConfig[quinticIndex].expectedNumberOfNods >= MAX_NUMBER_OF_IMUS)
				{
					debugPrintStringInt("failed to assign IMU ",imuId);
  40833e:	481f      	ldr	r0, [pc, #124]	; (4083bc <loadSettings+0x310>)
  408340:	4b1d      	ldr	r3, [pc, #116]	; (4083b8 <loadSettings+0x30c>)
  408342:	4798      	blx	r3
					break;
  408344:	e7a1      	b.n	40828a <loadSettings+0x1de>
	int NumberOfNods = 0;	
	if(getLineFromBuf(bufPtr, line, sizeof(line)) == PASS)
	{
		if(sscanf(line, "%s ,%d, %s ,\r\n", brainSettings.imuSet, &NumberOfNods, brainSettings.channelmap) < 2)
		{
			debugPrintString("failed to read settings\r\n");
  408346:	481e      	ldr	r0, [pc, #120]	; (4083c0 <loadSettings+0x314>)
  408348:	4c02      	ldr	r4, [pc, #8]	; (408354 <loadSettings+0x2a8>)
  40834a:	47a0      	blx	r4
			return STATUS_FAIL; 
  40834c:	2001      	movs	r0, #1
  40834e:	e7af      	b.n	4082b0 <loadSettings+0x204>
  408350:	2000387c 	.word	0x2000387c
  408354:	004008c9 	.word	0x004008c9
  408358:	20003578 	.word	0x20003578
  40835c:	00416648 	.word	0x00416648
  408360:	00416664 	.word	0x00416664
  408364:	00416670 	.word	0x00416670
  408368:	00405599 	.word	0x00405599
  40836c:	0040c31d 	.word	0x0040c31d
  408370:	0040583d 	.word	0x0040583d
  408374:	0041667c 	.word	0x0041667c
  408378:	0040ca69 	.word	0x0040ca69
  40837c:	00408011 	.word	0x00408011
  408380:	2000031c 	.word	0x2000031c
  408384:	00415228 	.word	0x00415228
  408388:	004166ac 	.word	0x004166ac
  40838c:	0041670c 	.word	0x0041670c
  408390:	00405c85 	.word	0x00405c85
  408394:	00408065 	.word	0x00408065
  408398:	200001ac 	.word	0x200001ac
  40839c:	00416680 	.word	0x00416680
  4083a0:	0040c5a1 	.word	0x0040c5a1
  4083a4:	0040c9a5 	.word	0x0040c9a5
  4083a8:	00415bf0 	.word	0x00415bf0
  4083ac:	00416720 	.word	0x00416720
  4083b0:	004166b8 	.word	0x004166b8
  4083b4:	004166d8 	.word	0x004166d8
  4083b8:	004007b5 	.word	0x004007b5
  4083bc:	004166f4 	.word	0x004166f4
  4083c0:	00416690 	.word	0x00416690
  4083c4:	200037a0 	.word	0x200037a0
  4083c8:	20000264 	.word	0x20000264
  4083cc:	0040c4ed 	.word	0x0040c4ed

004083d0 <drv_gpio_int_cd>:
 * @brief Interrupt routine for SD Card Detect
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_cd(uint32_t ul_id, uint32_t ul_mask)
{
  4083d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_SD_CD].pinId);
  4083d2:	4e0b      	ldr	r6, [pc, #44]	; (408400 <drv_gpio_int_cd+0x30>)
  4083d4:	4b0b      	ldr	r3, [pc, #44]	; (408404 <drv_gpio_int_cd+0x34>)
  4083d6:	f8d6 0100 	ldr.w	r0, [r6, #256]	; 0x100
	pio_disable_interrupt(PIOB, PinMask);
  4083da:	4d0b      	ldr	r5, [pc, #44]	; (408408 <drv_gpio_int_cd+0x38>)
 * @brief Interrupt routine for SD Card Detect
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_cd(uint32_t ul_id, uint32_t ul_mask)
{
  4083dc:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_SD_CD].pinId);
  4083de:	4798      	blx	r3
	pio_disable_interrupt(PIOB, PinMask);
  4083e0:	4b0a      	ldr	r3, [pc, #40]	; (40840c <drv_gpio_int_cd+0x3c>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_cd(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_SD_CD].pinId);
  4083e2:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOB, PinMask);
  4083e4:	4601      	mov	r1, r0
  4083e6:	4628      	mov	r0, r5
  4083e8:	4798      	blx	r3
	uint32_t ReadIsr = PIOB->PIO_ISR;
	if (PinMask == ul_mask)
  4083ea:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_cd(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_SD_CD].pinId);
	pio_disable_interrupt(PIOB, PinMask);
	uint32_t ReadIsr = PIOB->PIO_ISR;
  4083ec:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_SD_CD].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOB, PinMask);
  4083ee:	4806      	ldr	r0, [pc, #24]	; (408408 <drv_gpio_int_cd+0x38>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_SD_CD].pinId);
	pio_disable_interrupt(PIOB, PinMask);
	uint32_t ReadIsr = PIOB->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_SD_CD].gpioSetFlag = 1;
  4083f0:	bf04      	itt	eq
  4083f2:	2301      	moveq	r3, #1
  4083f4:	f886 310e 	strbeq.w	r3, [r6, #270]	; 0x10e
	}
	pio_enable_interrupt(PIOB, PinMask);
  4083f8:	4621      	mov	r1, r4
  4083fa:	4b05      	ldr	r3, [pc, #20]	; (408410 <drv_gpio_int_cd+0x40>)
  4083fc:	4798      	blx	r3
  4083fe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  408400:	2000054c 	.word	0x2000054c
  408404:	0040b019 	.word	0x0040b019
  408408:	400e1000 	.word	0x400e1000
  40840c:	0040ae55 	.word	0x0040ae55
  408410:	0040ae4d 	.word	0x0040ae4d

00408414 <drv_gpio_int_lbo>:
 * @brief Interrupt routine for Low Battery Out
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_lbo(uint32_t ul_id, uint32_t ul_mask)
{
  408414:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_LBO].pinId);
  408416:	4e0b      	ldr	r6, [pc, #44]	; (408444 <drv_gpio_int_lbo+0x30>)
  408418:	4b0b      	ldr	r3, [pc, #44]	; (408448 <drv_gpio_int_lbo+0x34>)
  40841a:	f8d6 00f0 	ldr.w	r0, [r6, #240]	; 0xf0
	pio_disable_interrupt(PIOA, PinMask);
  40841e:	4d0b      	ldr	r5, [pc, #44]	; (40844c <drv_gpio_int_lbo+0x38>)
 * @brief Interrupt routine for Low Battery Out
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_lbo(uint32_t ul_id, uint32_t ul_mask)
{
  408420:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_LBO].pinId);
  408422:	4798      	blx	r3
	pio_disable_interrupt(PIOA, PinMask);
  408424:	4b0a      	ldr	r3, [pc, #40]	; (408450 <drv_gpio_int_lbo+0x3c>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_lbo(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_LBO].pinId);
  408426:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOA, PinMask);
  408428:	4601      	mov	r1, r0
  40842a:	4628      	mov	r0, r5
  40842c:	4798      	blx	r3
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
  40842e:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_lbo(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_LBO].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
  408430:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_LBO].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOA, PinMask);
  408432:	4806      	ldr	r0, [pc, #24]	; (40844c <drv_gpio_int_lbo+0x38>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_LBO].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_LBO].gpioSetFlag = 1;
  408434:	bf04      	itt	eq
  408436:	2301      	moveq	r3, #1
  408438:	f886 30fe 	strbeq.w	r3, [r6, #254]	; 0xfe
	}
	pio_enable_interrupt(PIOA, PinMask);
  40843c:	4621      	mov	r1, r4
  40843e:	4b05      	ldr	r3, [pc, #20]	; (408454 <drv_gpio_int_lbo+0x40>)
  408440:	4798      	blx	r3
  408442:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  408444:	2000054c 	.word	0x2000054c
  408448:	0040b019 	.word	0x0040b019
  40844c:	400e0e00 	.word	0x400e0e00
  408450:	0040ae55 	.word	0x0040ae55
  408454:	0040ae4d 	.word	0x0040ae4d

00408458 <drv_gpio_int_dc2>:
 * @brief Interrupt routine for Jack-2 Detect
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_dc2(uint32_t ul_id, uint32_t ul_mask)
{
  408458:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC2].pinId);
  40845a:	4e0b      	ldr	r6, [pc, #44]	; (408488 <drv_gpio_int_dc2+0x30>)
  40845c:	4b0b      	ldr	r3, [pc, #44]	; (40848c <drv_gpio_int_dc2+0x34>)
  40845e:	6e30      	ldr	r0, [r6, #96]	; 0x60
	pio_disable_interrupt(PIOA, PinMask);
  408460:	4d0b      	ldr	r5, [pc, #44]	; (408490 <drv_gpio_int_dc2+0x38>)
 * @brief Interrupt routine for Jack-2 Detect
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_dc2(uint32_t ul_id, uint32_t ul_mask)
{
  408462:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC2].pinId);
  408464:	4798      	blx	r3
	pio_disable_interrupt(PIOA, PinMask);
  408466:	4b0b      	ldr	r3, [pc, #44]	; (408494 <drv_gpio_int_dc2+0x3c>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_dc2(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC2].pinId);
  408468:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOA, PinMask);
  40846a:	4601      	mov	r1, r0
  40846c:	4628      	mov	r0, r5
  40846e:	4798      	blx	r3
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
  408470:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_dc2(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC2].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
  408472:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_JC_DC2].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOA, PinMask);
  408474:	4806      	ldr	r0, [pc, #24]	; (408490 <drv_gpio_int_dc2+0x38>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC2].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_JC_DC2].gpioSetFlag = 1;
  408476:	bf04      	itt	eq
  408478:	2301      	moveq	r3, #1
  40847a:	f886 306e 	strbeq.w	r3, [r6, #110]	; 0x6e
	}
	pio_enable_interrupt(PIOA, PinMask);
  40847e:	4621      	mov	r1, r4
  408480:	4b05      	ldr	r3, [pc, #20]	; (408498 <drv_gpio_int_dc2+0x40>)
  408482:	4798      	blx	r3
  408484:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  408486:	bf00      	nop
  408488:	2000054c 	.word	0x2000054c
  40848c:	0040b019 	.word	0x0040b019
  408490:	400e0e00 	.word	0x400e0e00
  408494:	0040ae55 	.word	0x0040ae55
  408498:	0040ae4d 	.word	0x0040ae4d

0040849c <drv_gpio_int_dc1>:
 * @brief Interrupt routine for Jack-1 Detect
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_dc1(uint32_t ul_id, uint32_t ul_mask)
{
  40849c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC1].pinId);
  40849e:	4e0b      	ldr	r6, [pc, #44]	; (4084cc <drv_gpio_int_dc1+0x30>)
  4084a0:	4b0b      	ldr	r3, [pc, #44]	; (4084d0 <drv_gpio_int_dc1+0x34>)
  4084a2:	6d30      	ldr	r0, [r6, #80]	; 0x50
	pio_disable_interrupt(PIOA, PinMask);
  4084a4:	4d0b      	ldr	r5, [pc, #44]	; (4084d4 <drv_gpio_int_dc1+0x38>)
 * @brief Interrupt routine for Jack-1 Detect
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_dc1(uint32_t ul_id, uint32_t ul_mask)
{
  4084a6:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC1].pinId);
  4084a8:	4798      	blx	r3
	pio_disable_interrupt(PIOA, PinMask);
  4084aa:	4b0b      	ldr	r3, [pc, #44]	; (4084d8 <drv_gpio_int_dc1+0x3c>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_dc1(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC1].pinId);
  4084ac:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOA, PinMask);
  4084ae:	4601      	mov	r1, r0
  4084b0:	4628      	mov	r0, r5
  4084b2:	4798      	blx	r3
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
  4084b4:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_dc1(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC1].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
  4084b6:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_JC_DC1].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOA, PinMask);
  4084b8:	4806      	ldr	r0, [pc, #24]	; (4084d4 <drv_gpio_int_dc1+0x38>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC1].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_JC_DC1].gpioSetFlag = 1;
  4084ba:	bf04      	itt	eq
  4084bc:	2301      	moveq	r3, #1
  4084be:	f886 305e 	strbeq.w	r3, [r6, #94]	; 0x5e
	}
	pio_enable_interrupt(PIOA, PinMask);
  4084c2:	4621      	mov	r1, r4
  4084c4:	4b05      	ldr	r3, [pc, #20]	; (4084dc <drv_gpio_int_dc1+0x40>)
  4084c6:	4798      	blx	r3
  4084c8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  4084ca:	bf00      	nop
  4084cc:	2000054c 	.word	0x2000054c
  4084d0:	0040b019 	.word	0x0040b019
  4084d4:	400e0e00 	.word	0x400e0e00
  4084d8:	0040ae55 	.word	0x0040ae55
  4084dc:	0040ae4d 	.word	0x0040ae4d

004084e0 <drv_gpio_int_oc2>:
 * @brief Interrupt routine for Jack-2 Over Current
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_oc2(uint32_t ul_id, uint32_t ul_mask)
{
  4084e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC2].pinId);
  4084e2:	4e0b      	ldr	r6, [pc, #44]	; (408510 <drv_gpio_int_oc2+0x30>)
  4084e4:	4b0b      	ldr	r3, [pc, #44]	; (408514 <drv_gpio_int_oc2+0x34>)
  4084e6:	6c30      	ldr	r0, [r6, #64]	; 0x40
	pio_disable_interrupt(PIOA, PinMask);
  4084e8:	4d0b      	ldr	r5, [pc, #44]	; (408518 <drv_gpio_int_oc2+0x38>)
 * @brief Interrupt routine for Jack-2 Over Current
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_oc2(uint32_t ul_id, uint32_t ul_mask)
{
  4084ea:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC2].pinId);
  4084ec:	4798      	blx	r3
	pio_disable_interrupt(PIOA, PinMask);
  4084ee:	4b0b      	ldr	r3, [pc, #44]	; (40851c <drv_gpio_int_oc2+0x3c>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_oc2(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC2].pinId);
  4084f0:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOA, PinMask);
  4084f2:	4601      	mov	r1, r0
  4084f4:	4628      	mov	r0, r5
  4084f6:	4798      	blx	r3
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
  4084f8:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_oc2(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC2].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
  4084fa:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_JC_OC2].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOA, PinMask);
  4084fc:	4806      	ldr	r0, [pc, #24]	; (408518 <drv_gpio_int_oc2+0x38>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC2].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_JC_OC2].gpioSetFlag = 1;
  4084fe:	bf04      	itt	eq
  408500:	2301      	moveq	r3, #1
  408502:	f886 304e 	strbeq.w	r3, [r6, #78]	; 0x4e
	}
	pio_enable_interrupt(PIOA, PinMask);
  408506:	4621      	mov	r1, r4
  408508:	4b05      	ldr	r3, [pc, #20]	; (408520 <drv_gpio_int_oc2+0x40>)
  40850a:	4798      	blx	r3
  40850c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  40850e:	bf00      	nop
  408510:	2000054c 	.word	0x2000054c
  408514:	0040b019 	.word	0x0040b019
  408518:	400e0e00 	.word	0x400e0e00
  40851c:	0040ae55 	.word	0x0040ae55
  408520:	0040ae4d 	.word	0x0040ae4d

00408524 <drv_gpio_int_oc1>:
 * @brief Interrupt routine for Jack-1 Over Current
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_oc1(uint32_t ul_id, uint32_t ul_mask)
{
  408524:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC1].pinId);
  408526:	4e0b      	ldr	r6, [pc, #44]	; (408554 <drv_gpio_int_oc1+0x30>)
  408528:	4b0b      	ldr	r3, [pc, #44]	; (408558 <drv_gpio_int_oc1+0x34>)
  40852a:	6b30      	ldr	r0, [r6, #48]	; 0x30
	pio_disable_interrupt(PIOA, PinMask);
  40852c:	4d0b      	ldr	r5, [pc, #44]	; (40855c <drv_gpio_int_oc1+0x38>)
 * @brief Interrupt routine for Jack-1 Over Current
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_oc1(uint32_t ul_id, uint32_t ul_mask)
{
  40852e:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC1].pinId);
  408530:	4798      	blx	r3
	pio_disable_interrupt(PIOA, PinMask);
  408532:	4b0b      	ldr	r3, [pc, #44]	; (408560 <drv_gpio_int_oc1+0x3c>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_oc1(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC1].pinId);
  408534:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOA, PinMask);
  408536:	4601      	mov	r1, r0
  408538:	4628      	mov	r0, r5
  40853a:	4798      	blx	r3
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
  40853c:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_oc1(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC1].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
  40853e:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_JC_OC1].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOA, PinMask);
  408540:	4806      	ldr	r0, [pc, #24]	; (40855c <drv_gpio_int_oc1+0x38>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC1].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_JC_OC1].gpioSetFlag = 1;
  408542:	bf04      	itt	eq
  408544:	2301      	moveq	r3, #1
  408546:	f886 303e 	strbeq.w	r3, [r6, #62]	; 0x3e
	}
	pio_enable_interrupt(PIOA, PinMask);
  40854a:	4621      	mov	r1, r4
  40854c:	4b05      	ldr	r3, [pc, #20]	; (408564 <drv_gpio_int_oc1+0x40>)
  40854e:	4798      	blx	r3
  408550:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  408552:	bf00      	nop
  408554:	2000054c 	.word	0x2000054c
  408558:	0040b019 	.word	0x0040b019
  40855c:	400e0e00 	.word	0x400e0e00
  408560:	0040ae55 	.word	0x0040ae55
  408564:	0040ae4d 	.word	0x0040ae4d

00408568 <drv_gpio_int_sw2>:
 * @brief Interrupt routine for Action Switch-2
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_sw2(uint32_t ul_id, uint32_t ul_mask)
{
  408568:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW2].pinId);
  40856a:	4e0b      	ldr	r6, [pc, #44]	; (408598 <drv_gpio_int_sw2+0x30>)
  40856c:	4b0b      	ldr	r3, [pc, #44]	; (40859c <drv_gpio_int_sw2+0x34>)
  40856e:	6a30      	ldr	r0, [r6, #32]
	pio_disable_interrupt(PIOA, PinMask);
  408570:	4d0b      	ldr	r5, [pc, #44]	; (4085a0 <drv_gpio_int_sw2+0x38>)
 * @brief Interrupt routine for Action Switch-2
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_sw2(uint32_t ul_id, uint32_t ul_mask)
{
  408572:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW2].pinId);
  408574:	4798      	blx	r3
	pio_disable_interrupt(PIOA, PinMask);
  408576:	4b0b      	ldr	r3, [pc, #44]	; (4085a4 <drv_gpio_int_sw2+0x3c>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_sw2(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW2].pinId);
  408578:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOA, PinMask);
  40857a:	4601      	mov	r1, r0
  40857c:	4628      	mov	r0, r5
  40857e:	4798      	blx	r3
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
  408580:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_sw2(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW2].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
  408582:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_AC_SW2].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOA, PinMask);
  408584:	4806      	ldr	r0, [pc, #24]	; (4085a0 <drv_gpio_int_sw2+0x38>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW2].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_AC_SW2].gpioSetFlag = 1;
  408586:	bf04      	itt	eq
  408588:	2301      	moveq	r3, #1
  40858a:	f886 302e 	strbeq.w	r3, [r6, #46]	; 0x2e
	}
	pio_enable_interrupt(PIOA, PinMask);
  40858e:	4621      	mov	r1, r4
  408590:	4b05      	ldr	r3, [pc, #20]	; (4085a8 <drv_gpio_int_sw2+0x40>)
  408592:	4798      	blx	r3
  408594:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  408596:	bf00      	nop
  408598:	2000054c 	.word	0x2000054c
  40859c:	0040b019 	.word	0x0040b019
  4085a0:	400e0e00 	.word	0x400e0e00
  4085a4:	0040ae55 	.word	0x0040ae55
  4085a8:	0040ae4d 	.word	0x0040ae4d

004085ac <drv_gpio_int_sw1>:
 * @brief Interrupt routine for Action Switch-1
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_sw1(uint32_t ul_id, uint32_t ul_mask)
{
  4085ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW1].pinId);
  4085ae:	4e0a      	ldr	r6, [pc, #40]	; (4085d8 <drv_gpio_int_sw1+0x2c>)
  4085b0:	4b0a      	ldr	r3, [pc, #40]	; (4085dc <drv_gpio_int_sw1+0x30>)
  4085b2:	6930      	ldr	r0, [r6, #16]
	pio_disable_interrupt(PIOA, PinMask);
  4085b4:	4d0a      	ldr	r5, [pc, #40]	; (4085e0 <drv_gpio_int_sw1+0x34>)
 * @brief Interrupt routine for Action Switch-1
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_sw1(uint32_t ul_id, uint32_t ul_mask)
{
  4085b6:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW1].pinId);
  4085b8:	4798      	blx	r3
	pio_disable_interrupt(PIOA, PinMask);
  4085ba:	4b0a      	ldr	r3, [pc, #40]	; (4085e4 <drv_gpio_int_sw1+0x38>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_sw1(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW1].pinId);
  4085bc:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOA, PinMask);
  4085be:	4601      	mov	r1, r0
  4085c0:	4628      	mov	r0, r5
  4085c2:	4798      	blx	r3
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
  4085c4:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_sw1(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW1].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
  4085c6:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_AC_SW1].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOA, PinMask);
  4085c8:	4805      	ldr	r0, [pc, #20]	; (4085e0 <drv_gpio_int_sw1+0x34>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW1].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_AC_SW1].gpioSetFlag = 1;
  4085ca:	bf04      	itt	eq
  4085cc:	2301      	moveq	r3, #1
  4085ce:	77b3      	strbeq	r3, [r6, #30]
	}
	pio_enable_interrupt(PIOA, PinMask);
  4085d0:	4621      	mov	r1, r4
  4085d2:	4b05      	ldr	r3, [pc, #20]	; (4085e8 <drv_gpio_int_sw1+0x3c>)
  4085d4:	4798      	blx	r3
  4085d6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  4085d8:	2000054c 	.word	0x2000054c
  4085dc:	0040b019 	.word	0x0040b019
  4085e0:	400e0e00 	.word	0x400e0e00
  4085e4:	0040ae55 	.word	0x0040ae55
  4085e8:	0040ae4d 	.word	0x0040ae4d

004085ec <drv_gpio_int_pw>:
 * @brief Interrupt routine for Power Switch
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_pw(uint32_t ul_id, uint32_t ul_mask)
{
  4085ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_PW_SW].pinId);
  4085ee:	4e0a      	ldr	r6, [pc, #40]	; (408618 <drv_gpio_int_pw+0x2c>)
  4085f0:	4b0a      	ldr	r3, [pc, #40]	; (40861c <drv_gpio_int_pw+0x30>)
  4085f2:	6830      	ldr	r0, [r6, #0]
	pio_disable_interrupt(PIOA, PinMask);
  4085f4:	4d0a      	ldr	r5, [pc, #40]	; (408620 <drv_gpio_int_pw+0x34>)
 * @brief Interrupt routine for Power Switch
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_pw(uint32_t ul_id, uint32_t ul_mask)
{
  4085f6:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_PW_SW].pinId);
  4085f8:	4798      	blx	r3
	pio_disable_interrupt(PIOA, PinMask);
  4085fa:	4b0a      	ldr	r3, [pc, #40]	; (408624 <drv_gpio_int_pw+0x38>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_pw(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_PW_SW].pinId);
  4085fc:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOA, PinMask);
  4085fe:	4601      	mov	r1, r0
  408600:	4628      	mov	r0, r5
  408602:	4798      	blx	r3
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
  408604:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_pw(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_PW_SW].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
  408606:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_PW_SW].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOA, PinMask);
  408608:	4805      	ldr	r0, [pc, #20]	; (408620 <drv_gpio_int_pw+0x34>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_PW_SW].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_PW_SW].gpioSetFlag = 1;
  40860a:	bf04      	itt	eq
  40860c:	2301      	moveq	r3, #1
  40860e:	73b3      	strbeq	r3, [r6, #14]
	}
	pio_enable_interrupt(PIOA, PinMask);
  408610:	4621      	mov	r1, r4
  408612:	4b05      	ldr	r3, [pc, #20]	; (408628 <drv_gpio_int_pw+0x3c>)
  408614:	4798      	blx	r3
  408616:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  408618:	2000054c 	.word	0x2000054c
  40861c:	0040b019 	.word	0x0040b019
  408620:	400e0e00 	.word	0x400e0e00
  408624:	0040ae55 	.word	0x0040ae55
  408628:	0040ae4d 	.word	0x0040ae4d

0040862c <drv_gpio_config>:
 * @brief Set and configure all GPIOs
 * @param drv_gpio_config_t* gpioConfig
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t drv_gpio_config(drv_gpio_config_t* gpioConfig)
{
  40862c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	status_t status = STATUS_PASS;
	unsigned long PinFlag = 0;	
	if(gpioConfig->pinMode == DRV_GPIO_PIN_MODE_INPUT)	//Check if input or output
  408630:	7903      	ldrb	r3, [r0, #4]
  408632:	2b01      	cmp	r3, #1
 * @brief Set and configure all GPIOs
 * @param drv_gpio_config_t* gpioConfig
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t drv_gpio_config(drv_gpio_config_t* gpioConfig)
{
  408634:	b082      	sub	sp, #8
  408636:	4604      	mov	r4, r0
	status_t status = STATUS_PASS;
	unsigned long PinFlag = 0;	
	if(gpioConfig->pinMode == DRV_GPIO_PIN_MODE_INPUT)	//Check if input or output
  408638:	d011      	beq.n	40865e <drv_gpio_config+0x32>
		p_pio->PIO_PPDDR |= PinMask; 
		
	}
	else	//The pin is output
	{
		if (gpioConfig->initialPinState == DRV_GPIO_PIN_STATE_HIGH)
  40863a:	7942      	ldrb	r2, [r0, #5]
		else
		{
			PinFlag |= PIO_TYPE_PIO_OUTPUT_0;	//set default pin state
		}
		
		pmc_enable_periph_clk(gpioConfig->pinId);
  40863c:	4b36      	ldr	r3, [pc, #216]	; (408718 <drv_gpio_config+0xec>)
  40863e:	6800      	ldr	r0, [r0, #0]
	}
	else	//The pin is output
	{
		if (gpioConfig->initialPinState == DRV_GPIO_PIN_STATE_HIGH)
		{
			PinFlag |= PIO_TYPE_PIO_OUTPUT_1;	//set default pin state
  408640:	2a01      	cmp	r2, #1
  408642:	bf14      	ite	ne
  408644:	f04f 5540 	movne.w	r5, #805306368	; 0x30000000
  408648:	f04f 5560 	moveq.w	r5, #939524096	; 0x38000000
		else
		{
			PinFlag |= PIO_TYPE_PIO_OUTPUT_0;	//set default pin state
		}
		
		pmc_enable_periph_clk(gpioConfig->pinId);
  40864c:	4798      	blx	r3
		pio_configure_pin(gpioConfig->pinId, PinFlag);
  40864e:	4629      	mov	r1, r5
  408650:	6820      	ldr	r0, [r4, #0]
  408652:	4b32      	ldr	r3, [pc, #200]	; (40871c <drv_gpio_config+0xf0>)
  408654:	4798      	blx	r3
	}
	
	return status;
}
  408656:	2000      	movs	r0, #0
  408658:	b002      	add	sp, #8
  40865a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	status_t status = STATUS_PASS;
	unsigned long PinFlag = 0;	
	if(gpioConfig->pinMode == DRV_GPIO_PIN_MODE_INPUT)	//Check if input or output
	{
		PinFlag |= PIO_TYPE_PIO_INPUT;	//Set as input
		if (gpioConfig->pullUpEnabled == TRUE)
  40865e:	7b02      	ldrb	r2, [r0, #12]
{
	status_t status = STATUS_PASS;
	unsigned long PinFlag = 0;	
	if(gpioConfig->pinMode == DRV_GPIO_PIN_MODE_INPUT)	//Check if input or output
	{
		PinFlag |= PIO_TYPE_PIO_INPUT;	//Set as input
  408660:	4f2f      	ldr	r7, [pc, #188]	; (408720 <drv_gpio_config+0xf4>)
		if (gpioConfig->pullUpEnabled == TRUE)
		{
			PinFlag |= PIO_PULLUP;	//enable the pull up
		}
		
		if (gpioConfig->debounceEnabled == TRUE)
  408662:	7b43      	ldrb	r3, [r0, #13]
{
	status_t status = STATUS_PASS;
	unsigned long PinFlag = 0;	
	if(gpioConfig->pinMode == DRV_GPIO_PIN_MODE_INPUT)	//Check if input or output
	{
		PinFlag |= PIO_TYPE_PIO_INPUT;	//Set as input
  408664:	2a01      	cmp	r2, #1
  408666:	bf18      	it	ne
  408668:	f04f 5720 	movne.w	r7, #671088640	; 0x28000000
		if (gpioConfig->pullUpEnabled == TRUE)
		{
			PinFlag |= PIO_PULLUP;	//enable the pull up
		}
		
		if (gpioConfig->debounceEnabled == TRUE)
  40866c:	2b01      	cmp	r3, #1
  40866e:	d03c      	beq.n	4086ea <drv_gpio_config+0xbe>
  408670:	4d2c      	ldr	r5, [pc, #176]	; (408724 <drv_gpio_config+0xf8>)
  408672:	4e2d      	ldr	r6, [pc, #180]	; (408728 <drv_gpio_config+0xfc>)
			Pio *p_pio = pio_get_pin_group(gpioConfig->pinId);
			uint32_t PinMask = pio_get_pin_group_mask(gpioConfig->pinId);	//PinMask
			pio_set_debounce_filter(p_pio, PinMask, DEBOUNCE_PERIOD);
		}
		
		pmc_enable_periph_clk(gpioConfig->pinId);	
  408674:	4b28      	ldr	r3, [pc, #160]	; (408718 <drv_gpio_config+0xec>)
  408676:	6820      	ldr	r0, [r4, #0]
  408678:	4798      	blx	r3
		pio_configure_pin(gpioConfig->pinId, PinFlag);
  40867a:	4b28      	ldr	r3, [pc, #160]	; (40871c <drv_gpio_config+0xf0>)
  40867c:	6820      	ldr	r0, [r4, #0]
  40867e:	4639      	mov	r1, r7
  408680:	4798      	blx	r3
		 
		PinFlag = 0;	//Reset the PinFlag to use it to configure interrupt
		switch(gpioConfig->interruptType)	//set interrupt configuration flag
  408682:	79a3      	ldrb	r3, [r4, #6]
  408684:	2b03      	cmp	r3, #3
  408686:	d829      	bhi.n	4086dc <drv_gpio_config+0xb0>
  408688:	4a28      	ldr	r2, [pc, #160]	; (40872c <drv_gpio_config+0x100>)
				break;
			case DRV_GPIO_INTERRUPT_NONE :
			default:
				break;
		}
		Pio *p_pio = pio_get_pin_group(gpioConfig->pinId);	//peripheral ID
  40868a:	6820      	ldr	r0, [r4, #0]
  40868c:	f852 7023 	ldr.w	r7, [r2, r3, lsl #2]
  408690:	47a8      	blx	r5
  408692:	4605      	mov	r5, r0
		uint32_t PinMask = pio_get_pin_group_mask(gpioConfig->pinId);	//PinMask
  408694:	6820      	ldr	r0, [r4, #0]
  408696:	47b0      	blx	r6
		if (PinFlag & (PIO_IT_RISE_EDGE | PIO_IT_FALL_EDGE | PIO_IT_HIGH_LEVEL | PIO_IT_LOW_LEVEL))	//if set as interrupt, enable and configure it
  408698:	f017 0f70 	tst.w	r7, #112	; 0x70
			case DRV_GPIO_INTERRUPT_NONE :
			default:
				break;
		}
		Pio *p_pio = pio_get_pin_group(gpioConfig->pinId);	//peripheral ID
		uint32_t PinMask = pio_get_pin_group_mask(gpioConfig->pinId);	//PinMask
  40869c:	4606      	mov	r6, r0
		if (PinFlag & (PIO_IT_RISE_EDGE | PIO_IT_FALL_EDGE | PIO_IT_HIGH_LEVEL | PIO_IT_LOW_LEVEL))	//if set as interrupt, enable and configure it
  40869e:	d014      	beq.n	4086ca <drv_gpio_config+0x9e>
		{			
			uint32_t PinPio = pio_get_pin_group_id(gpioConfig->pinId);	//Pin ID
  4086a0:	6820      	ldr	r0, [r4, #0]
  4086a2:	4b23      	ldr	r3, [pc, #140]	; (408730 <drv_gpio_config+0x104>)
  4086a4:	4798      	blx	r3
			pio_handler_set(p_pio, PinPio, PinMask, PinFlag, gpioConfig->interruptHandler);
  4086a6:	68a3      	ldr	r3, [r4, #8]
  4086a8:	9300      	str	r3, [sp, #0]
		}
		Pio *p_pio = pio_get_pin_group(gpioConfig->pinId);	//peripheral ID
		uint32_t PinMask = pio_get_pin_group_mask(gpioConfig->pinId);	//PinMask
		if (PinFlag & (PIO_IT_RISE_EDGE | PIO_IT_FALL_EDGE | PIO_IT_HIGH_LEVEL | PIO_IT_LOW_LEVEL))	//if set as interrupt, enable and configure it
		{			
			uint32_t PinPio = pio_get_pin_group_id(gpioConfig->pinId);	//Pin ID
  4086aa:	4601      	mov	r1, r0
			pio_handler_set(p_pio, PinPio, PinMask, PinFlag, gpioConfig->interruptHandler);
  4086ac:	463b      	mov	r3, r7
  4086ae:	4632      	mov	r2, r6
  4086b0:	4628      	mov	r0, r5
  4086b2:	4c20      	ldr	r4, [pc, #128]	; (408734 <drv_gpio_config+0x108>)
  4086b4:	47a0      	blx	r4
			pio_enable_interrupt(p_pio, PinMask);
  4086b6:	4b20      	ldr	r3, [pc, #128]	; (408738 <drv_gpio_config+0x10c>)
  4086b8:	4628      	mov	r0, r5
  4086ba:	4631      	mov	r1, r6
  4086bc:	4798      	blx	r3
			if (p_pio == PIOA)
  4086be:	4b1f      	ldr	r3, [pc, #124]	; (40873c <drv_gpio_config+0x110>)
  4086c0:	429d      	cmp	r5, r3
  4086c2:	d024      	beq.n	40870e <drv_gpio_config+0xe2>
			{
				NVIC_EnableIRQ(PIOA_IRQn);
			}
			else if (p_pio == PIOB)
  4086c4:	4b1e      	ldr	r3, [pc, #120]	; (408740 <drv_gpio_config+0x114>)
  4086c6:	429d      	cmp	r5, r3
  4086c8:	d01c      	beq.n	408704 <drv_gpio_config+0xd8>
			{
				NVIC_EnableIRQ(PIOB_IRQn);
			}
		}
		//turn off any pulldown resistors
		p_pio->PIO_PPDDR |= PinMask; 
  4086ca:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
		pmc_enable_periph_clk(gpioConfig->pinId);
		pio_configure_pin(gpioConfig->pinId, PinFlag);
	}
	
	return status;
}
  4086ce:	2000      	movs	r0, #0
			{
				NVIC_EnableIRQ(PIOB_IRQn);
			}
		}
		//turn off any pulldown resistors
		p_pio->PIO_PPDDR |= PinMask; 
  4086d0:	431e      	orrs	r6, r3
  4086d2:	f8c5 6090 	str.w	r6, [r5, #144]	; 0x90
		pmc_enable_periph_clk(gpioConfig->pinId);
		pio_configure_pin(gpioConfig->pinId, PinFlag);
	}
	
	return status;
}
  4086d6:	b002      	add	sp, #8
  4086d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				break;
			case DRV_GPIO_INTERRUPT_NONE :
			default:
				break;
		}
		Pio *p_pio = pio_get_pin_group(gpioConfig->pinId);	//peripheral ID
  4086dc:	6820      	ldr	r0, [r4, #0]
  4086de:	47a8      	blx	r5
  4086e0:	4605      	mov	r5, r0
		uint32_t PinMask = pio_get_pin_group_mask(gpioConfig->pinId);	//PinMask
  4086e2:	6820      	ldr	r0, [r4, #0]
  4086e4:	47b0      	blx	r6
  4086e6:	4606      	mov	r6, r0
  4086e8:	e7ef      	b.n	4086ca <drv_gpio_config+0x9e>
		}
		
		if (gpioConfig->debounceEnabled == TRUE)
		{
			//PinFlag |= PIO_DEBOUNCE;	//enable debounce filter
			Pio *p_pio = pio_get_pin_group(gpioConfig->pinId);
  4086ea:	4d0e      	ldr	r5, [pc, #56]	; (408724 <drv_gpio_config+0xf8>)
  4086ec:	6800      	ldr	r0, [r0, #0]
			uint32_t PinMask = pio_get_pin_group_mask(gpioConfig->pinId);	//PinMask
  4086ee:	4e0e      	ldr	r6, [pc, #56]	; (408728 <drv_gpio_config+0xfc>)
		}
		
		if (gpioConfig->debounceEnabled == TRUE)
		{
			//PinFlag |= PIO_DEBOUNCE;	//enable debounce filter
			Pio *p_pio = pio_get_pin_group(gpioConfig->pinId);
  4086f0:	47a8      	blx	r5
  4086f2:	4680      	mov	r8, r0
			uint32_t PinMask = pio_get_pin_group_mask(gpioConfig->pinId);	//PinMask
  4086f4:	6820      	ldr	r0, [r4, #0]
  4086f6:	47b0      	blx	r6
			pio_set_debounce_filter(p_pio, PinMask, DEBOUNCE_PERIOD);
  4086f8:	2205      	movs	r2, #5
		
		if (gpioConfig->debounceEnabled == TRUE)
		{
			//PinFlag |= PIO_DEBOUNCE;	//enable debounce filter
			Pio *p_pio = pio_get_pin_group(gpioConfig->pinId);
			uint32_t PinMask = pio_get_pin_group_mask(gpioConfig->pinId);	//PinMask
  4086fa:	4601      	mov	r1, r0
			pio_set_debounce_filter(p_pio, PinMask, DEBOUNCE_PERIOD);
  4086fc:	4b11      	ldr	r3, [pc, #68]	; (408744 <drv_gpio_config+0x118>)
  4086fe:	4640      	mov	r0, r8
  408700:	4798      	blx	r3
  408702:	e7b7      	b.n	408674 <drv_gpio_config+0x48>
  408704:	4b10      	ldr	r3, [pc, #64]	; (408748 <drv_gpio_config+0x11c>)
  408706:	f44f 5280 	mov.w	r2, #4096	; 0x1000
  40870a:	601a      	str	r2, [r3, #0]
  40870c:	e7dd      	b.n	4086ca <drv_gpio_config+0x9e>
  40870e:	4b0e      	ldr	r3, [pc, #56]	; (408748 <drv_gpio_config+0x11c>)
  408710:	f44f 6200 	mov.w	r2, #2048	; 0x800
  408714:	601a      	str	r2, [r3, #0]
  408716:	e7d8      	b.n	4086ca <drv_gpio_config+0x9e>
  408718:	0040b231 	.word	0x0040b231
  40871c:	0040aebd 	.word	0x0040aebd
  408720:	28000001 	.word	0x28000001
  408724:	0040b001 	.word	0x0040b001
  408728:	0040b019 	.word	0x0040b019
  40872c:	0041673c 	.word	0x0041673c
  408730:	0040b011 	.word	0x0040b011
  408734:	0040b09d 	.word	0x0040b09d
  408738:	0040ae4d 	.word	0x0040ae4d
  40873c:	400e0e00 	.word	0x400e0e00
  408740:	400e1000 	.word	0x400e1000
  408744:	0040ad49 	.word	0x0040ad49
  408748:	e000e100 	.word	0xe000e100

0040874c <drv_gpio_initializeAll>:
 * @brief initialize all GPIO
 * @param 
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/	
status_t drv_gpio_initializeAll(void)
{
  40874c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	status_t status = STATUS_PASS; 
	int numGpio = sizeof(gpioConfig)/sizeof(drv_gpio_config_t); 
	int i = 0; 
	//Change the PB10 and PB11 to be configured as GPIO and not USB DDM and DDP 
	MATRIX->CCFG_SYSIO |= CCFG_SYSIO_SYSIO10 | CCFG_SYSIO_SYSIO11;	
  40874e:	4b0b      	ldr	r3, [pc, #44]	; (40877c <drv_gpio_initializeAll+0x30>)
  408750:	4c0b      	ldr	r4, [pc, #44]	; (408780 <drv_gpio_initializeAll+0x34>)
  408752:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
  408756:	4f0b      	ldr	r7, [pc, #44]	; (408784 <drv_gpio_initializeAll+0x38>)
  408758:	f442 6240 	orr.w	r2, r2, #3072	; 0xc00
  40875c:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
  408760:	f504 7698 	add.w	r6, r4, #304	; 0x130
 * @param 
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/	
status_t drv_gpio_initializeAll(void)
{
	status_t status = STATUS_PASS; 
  408764:	2500      	movs	r5, #0
	int i = 0; 
	//Change the PB10 and PB11 to be configured as GPIO and not USB DDM and DDP 
	MATRIX->CCFG_SYSIO |= CCFG_SYSIO_SYSIO10 | CCFG_SYSIO_SYSIO11;	
	for(i = 0; i < numGpio ; i++)
	{
		if(drv_gpio_config(&gpioConfig[i]) != STATUS_PASS)
  408766:	4620      	mov	r0, r4
  408768:	47b8      	blx	r7
  40876a:	3410      	adds	r4, #16
		{
			//printf("failed to initialize GPIO at index %d", i);
			status |= STATUS_FAIL;
  40876c:	2800      	cmp	r0, #0
  40876e:	bf18      	it	ne
  408770:	2501      	movne	r5, #1
	status_t status = STATUS_PASS; 
	int numGpio = sizeof(gpioConfig)/sizeof(drv_gpio_config_t); 
	int i = 0; 
	//Change the PB10 and PB11 to be configured as GPIO and not USB DDM and DDP 
	MATRIX->CCFG_SYSIO |= CCFG_SYSIO_SYSIO10 | CCFG_SYSIO_SYSIO11;	
	for(i = 0; i < numGpio ; i++)
  408772:	42b4      	cmp	r4, r6
  408774:	d1f7      	bne.n	408766 <drv_gpio_initializeAll+0x1a>
	//drv_gpio_config(&gpioConfig[DRV_GPIO_PIN_BLE_RST2]);
	//drv_gpio_config(&gpioConfig[DRV_GPIO_PIN_BLE_RST3]);
	
	
	return status; 
}
  408776:	4628      	mov	r0, r5
  408778:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  40877a:	bf00      	nop
  40877c:	400e0200 	.word	0x400e0200
  408780:	2000054c 	.word	0x2000054c
  408784:	0040862d 	.word	0x0040862d

00408788 <drv_gpio_ConfigureBLEForProgramming>:
 * @brief Set the GPIO for Rx and Tx of all UARTs to High Impedance
 * @param 
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/	
status_t drv_gpio_ConfigureBLEForProgramming(void)
{
  408788:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40878a:	4c07      	ldr	r4, [pc, #28]	; (4087a8 <drv_gpio_ConfigureBLEForProgramming+0x20>)
  40878c:	4f07      	ldr	r7, [pc, #28]	; (4087ac <drv_gpio_ConfigureBLEForProgramming+0x24>)
  40878e:	f104 0660 	add.w	r6, r4, #96	; 0x60
	status_t status = STATUS_PASS;
  408792:	2500      	movs	r5, #0
	int numGpio = sizeof(programmingGpioConfig)/sizeof(drv_gpio_config_t);
	int i = 0;

	for(i = 0; i < numGpio ; i++)
	{
		if(drv_gpio_config(&programmingGpioConfig[i]) != STATUS_PASS)
  408794:	4620      	mov	r0, r4
  408796:	47b8      	blx	r7
  408798:	3410      	adds	r4, #16
		{
			status |= STATUS_FAIL;
  40879a:	2800      	cmp	r0, #0
  40879c:	bf18      	it	ne
  40879e:	2501      	movne	r5, #1
{
	status_t status = STATUS_PASS;
	int numGpio = sizeof(programmingGpioConfig)/sizeof(drv_gpio_config_t);
	int i = 0;

	for(i = 0; i < numGpio ; i++)
  4087a0:	42b4      	cmp	r4, r6
  4087a2:	d1f7      	bne.n	408794 <drv_gpio_ConfigureBLEForProgramming+0xc>
		{
			status |= STATUS_FAIL;
		}
	}	
	return status;
}
  4087a4:	4628      	mov	r0, r5
  4087a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  4087a8:	2000067c 	.word	0x2000067c
  4087ac:	0040862d 	.word	0x0040862d

004087b0 <drv_gpio_setPinState>:
 * @brief Set a GPIO to HIGH or LOW
 * @param drv_gpio_pins_t pin, drv_gpio_pin_state_t state
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t drv_gpio_setPinState(drv_gpio_pins_t pin, drv_gpio_pin_state_t state)
{
  4087b0:	b538      	push	{r3, r4, r5, lr}
	status_t status = STATUS_PASS;
	uint32_t pinFlag = 0x00; 
	if(gpioConfig[pin].pinMode != DRV_GPIO_PIN_MODE_OUTPUT)
  4087b2:	4c18      	ldr	r4, [pc, #96]	; (408814 <drv_gpio_setPinState+0x64>)
  4087b4:	0105      	lsls	r5, r0, #4
  4087b6:	1963      	adds	r3, r4, r5
  4087b8:	791a      	ldrb	r2, [r3, #4]
  4087ba:	b972      	cbnz	r2, 4087da <drv_gpio_setPinState+0x2a>
	{
		return STATUS_FAIL;
	}
	if(gpioConfig[pin].currentPinState == DRV_GPIO_PIN_STATE_PULLED_HIGH || gpioConfig[pin].currentPinState == DRV_GPIO_PIN_STATE_PULLED_LOW)
  4087bc:	7bdb      	ldrb	r3, [r3, #15]
  4087be:	3b02      	subs	r3, #2
  4087c0:	2b01      	cmp	r3, #1
  4087c2:	d90c      	bls.n	4087de <drv_gpio_setPinState+0x2e>
			pio_configure_pin(gpioConfig->pinId, pinFlag);			
		}
	}
	//the output should be in the right state. 
	
	switch(state)
  4087c4:	2901      	cmp	r1, #1
  4087c6:	d01f      	beq.n	408808 <drv_gpio_setPinState+0x58>
  4087c8:	d312      	bcc.n	4087f0 <drv_gpio_setPinState+0x40>
  4087ca:	2902      	cmp	r1, #2
  4087cc:	d115      	bne.n	4087fa <drv_gpio_setPinState+0x4a>
		case DRV_GPIO_PIN_STATE_LOW:
			pio_set_pin_low(gpioConfig[pin].pinId);
		break;
		case DRV_GPIO_PIN_STATE_PULLED_HIGH:
			pinFlag |= PIO_TYPE_PIO_INPUT | PIO_PULLUP;	//Set as input with pull up. 
			pio_configure_pin(gpioConfig->pinId, pinFlag);
  4087ce:	6820      	ldr	r0, [r4, #0]
  4087d0:	4911      	ldr	r1, [pc, #68]	; (408818 <drv_gpio_setPinState+0x68>)
  4087d2:	4b12      	ldr	r3, [pc, #72]	; (40881c <drv_gpio_setPinState+0x6c>)
  4087d4:	4798      	blx	r3
	}
	
	


	return status;
  4087d6:	2000      	movs	r0, #0
			pio_set_pin_low(gpioConfig[pin].pinId);
		break;
		case DRV_GPIO_PIN_STATE_PULLED_HIGH:
			pinFlag |= PIO_TYPE_PIO_INPUT | PIO_PULLUP;	//Set as input with pull up. 
			pio_configure_pin(gpioConfig->pinId, pinFlag);
		break;
  4087d8:	bd38      	pop	{r3, r4, r5, pc}
{
	status_t status = STATUS_PASS;
	uint32_t pinFlag = 0x00; 
	if(gpioConfig[pin].pinMode != DRV_GPIO_PIN_MODE_OUTPUT)
	{
		return STATUS_FAIL;
  4087da:	2001      	movs	r0, #1
  4087dc:	bd38      	pop	{r3, r4, r5, pc}
	}
	if(gpioConfig[pin].currentPinState == DRV_GPIO_PIN_STATE_PULLED_HIGH || gpioConfig[pin].currentPinState == DRV_GPIO_PIN_STATE_PULLED_LOW)
	{
		if(state == DRV_GPIO_PIN_STATE_HIGH )
  4087de:	2901      	cmp	r1, #1
  4087e0:	d00d      	beq.n	4087fe <drv_gpio_setPinState+0x4e>
		{
			//we have to set the pin back to an output
			pinFlag |= PIO_TYPE_PIO_OUTPUT_1;
			pio_configure_pin(gpioConfig->pinId, pinFlag);
		}
		else if(state == DRV_GPIO_PIN_STATE_LOW)
  4087e2:	2900      	cmp	r1, #0
  4087e4:	d1ee      	bne.n	4087c4 <drv_gpio_setPinState+0x14>
		{
			pinFlag |= PIO_TYPE_PIO_OUTPUT_0;
			pio_configure_pin(gpioConfig->pinId, pinFlag);			
  4087e6:	6820      	ldr	r0, [r4, #0]
  4087e8:	4b0c      	ldr	r3, [pc, #48]	; (40881c <drv_gpio_setPinState+0x6c>)
  4087ea:	f04f 5140 	mov.w	r1, #805306368	; 0x30000000
  4087ee:	4798      	blx	r3
	{
		case DRV_GPIO_PIN_STATE_HIGH:
			pio_set_pin_high(gpioConfig[pin].pinId);
		break;
		case DRV_GPIO_PIN_STATE_LOW:
			pio_set_pin_low(gpioConfig[pin].pinId);
  4087f0:	5960      	ldr	r0, [r4, r5]
  4087f2:	4b0b      	ldr	r3, [pc, #44]	; (408820 <drv_gpio_setPinState+0x70>)
  4087f4:	4798      	blx	r3
	}
	
	


	return status;
  4087f6:	2000      	movs	r0, #0
		case DRV_GPIO_PIN_STATE_HIGH:
			pio_set_pin_high(gpioConfig[pin].pinId);
		break;
		case DRV_GPIO_PIN_STATE_LOW:
			pio_set_pin_low(gpioConfig[pin].pinId);
		break;
  4087f8:	bd38      	pop	{r3, r4, r5, pc}
	}
	
	


	return status;
  4087fa:	2000      	movs	r0, #0
}
  4087fc:	bd38      	pop	{r3, r4, r5, pc}
	{
		if(state == DRV_GPIO_PIN_STATE_HIGH )
		{
			//we have to set the pin back to an output
			pinFlag |= PIO_TYPE_PIO_OUTPUT_1;
			pio_configure_pin(gpioConfig->pinId, pinFlag);
  4087fe:	6820      	ldr	r0, [r4, #0]
  408800:	4b06      	ldr	r3, [pc, #24]	; (40881c <drv_gpio_setPinState+0x6c>)
  408802:	f04f 5160 	mov.w	r1, #939524096	; 0x38000000
  408806:	4798      	blx	r3
	//the output should be in the right state. 
	
	switch(state)
	{
		case DRV_GPIO_PIN_STATE_HIGH:
			pio_set_pin_high(gpioConfig[pin].pinId);
  408808:	5960      	ldr	r0, [r4, r5]
  40880a:	4b06      	ldr	r3, [pc, #24]	; (408824 <drv_gpio_setPinState+0x74>)
  40880c:	4798      	blx	r3
	}
	
	


	return status;
  40880e:	2000      	movs	r0, #0
	
	switch(state)
	{
		case DRV_GPIO_PIN_STATE_HIGH:
			pio_set_pin_high(gpioConfig[pin].pinId);
		break;
  408810:	bd38      	pop	{r3, r4, r5, pc}
  408812:	bf00      	nop
  408814:	2000054c 	.word	0x2000054c
  408818:	28000001 	.word	0x28000001
  40881c:	0040aebd 	.word	0x0040aebd
  408820:	0040ae7d 	.word	0x0040ae7d
  408824:	0040ae61 	.word	0x0040ae61

00408828 <drv_gpio_getPinState>:
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t drv_gpio_getPinState(drv_gpio_pins_t pin, drv_gpio_pin_state_t* state)
{
	status_t status = STATUS_PASS;
	bool value = ioport_get_pin_level(gpioConfig[pin].pinId);
  408828:	4b0a      	ldr	r3, [pc, #40]	; (408854 <drv_gpio_getPinState+0x2c>)
  40882a:	0100      	lsls	r0, r0, #4
  40882c:	5818      	ldr	r0, [r3, r0]
typedef uint32_t ioport_port_t;
typedef uint32_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 5;
  40882e:	0943      	lsrs	r3, r0, #5
	} else {
		return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
		       (IOPORT_PIO_OFFSET * port));
	}
#else
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  408830:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  408834:	f203 7307 	addw	r3, r3, #1799	; 0x707
  408838:	025b      	lsls	r3, r3, #9
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
  40883a:	f000 001f 	and.w	r0, r0, #31
	base->PIO_CODR = mask & ~level;
}

__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	return arch_ioport_pin_to_base(pin)->PIO_PDSR & arch_ioport_pin_to_mask(pin);
  40883e:	6bda      	ldr	r2, [r3, #60]	; 0x3c
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
  408840:	2301      	movs	r3, #1
  408842:	fa03 f000 	lsl.w	r0, r3, r0
	if (value == false)
  408846:	4002      	ands	r2, r0
	{
		*state = DRV_GPIO_PIN_STATE_LOW;
  408848:	bf08      	it	eq
  40884a:	4613      	moveq	r3, r2
  40884c:	700b      	strb	r3, [r1, #0]
	else
	{
		*state = DRV_GPIO_PIN_STATE_HIGH;
	}
	return status;
}
  40884e:	2000      	movs	r0, #0
  408850:	4770      	bx	lr
  408852:	bf00      	nop
  408854:	2000054c 	.word	0x2000054c

00408858 <drv_gpio_togglePin>:
 * @brief Toggle a GPIO level
 * @param drv_gpio_pins_t pin
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t drv_gpio_togglePin(drv_gpio_pins_t pin)
{
  408858:	b508      	push	{r3, lr}
	status_t status = STATUS_PASS;
	pio_toggle_pin(gpioConfig[pin].pinId);
  40885a:	4a03      	ldr	r2, [pc, #12]	; (408868 <drv_gpio_togglePin+0x10>)
  40885c:	4b03      	ldr	r3, [pc, #12]	; (40886c <drv_gpio_togglePin+0x14>)
  40885e:	0100      	lsls	r0, r0, #4
  408860:	5810      	ldr	r0, [r2, r0]
  408862:	4798      	blx	r3
	return status;
}
  408864:	2000      	movs	r0, #0
  408866:	bd08      	pop	{r3, pc}
  408868:	2000054c 	.word	0x2000054c
  40886c:	0040ae99 	.word	0x0040ae99

00408870 <drv_gpio_config_interrupt>:
 * @brief Set Interrupt Configuration for the requested pin
 * @param drv_gpio_pins_t pinId, unsigned long pinFlag
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t drv_gpio_config_interrupt(drv_gpio_pins_t pin, drv_gpio_interrupt_t pinInt)
{
  408870:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	status_t status = STATUS_FAIL;
	unsigned long PinFlag = 0;
	Pio *p_pio = pio_get_pin_group(gpioConfig[pin].pinId);	//peripheral ID
  408872:	0105      	lsls	r5, r0, #4
  408874:	4e11      	ldr	r6, [pc, #68]	; (4088bc <drv_gpio_config_interrupt+0x4c>)
  408876:	4b12      	ldr	r3, [pc, #72]	; (4088c0 <drv_gpio_config_interrupt+0x50>)
  408878:	5970      	ldr	r0, [r6, r5]
 * @brief Set Interrupt Configuration for the requested pin
 * @param drv_gpio_pins_t pinId, unsigned long pinFlag
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t drv_gpio_config_interrupt(drv_gpio_pins_t pin, drv_gpio_interrupt_t pinInt)
{
  40887a:	460c      	mov	r4, r1
	status_t status = STATUS_FAIL;
	unsigned long PinFlag = 0;
	Pio *p_pio = pio_get_pin_group(gpioConfig[pin].pinId);	//peripheral ID
  40887c:	4798      	blx	r3
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[pin].pinId);	//PinMask
  40887e:	4b11      	ldr	r3, [pc, #68]	; (4088c4 <drv_gpio_config_interrupt+0x54>)
 ***********************************************************************************************/
status_t drv_gpio_config_interrupt(drv_gpio_pins_t pin, drv_gpio_interrupt_t pinInt)
{
	status_t status = STATUS_FAIL;
	unsigned long PinFlag = 0;
	Pio *p_pio = pio_get_pin_group(gpioConfig[pin].pinId);	//peripheral ID
  408880:	4607      	mov	r7, r0
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[pin].pinId);	//PinMask
  408882:	5970      	ldr	r0, [r6, r5]
  408884:	4798      	blx	r3
  408886:	4601      	mov	r1, r0
	if (pinInt == DRV_GPIO_INTERRUPT_HIGH_EDGE)
  408888:	b17c      	cbz	r4, 4088aa <drv_gpio_config_interrupt+0x3a>
	{
		PinFlag = PIO_IT_RISE_EDGE | PIO_IT_AIME;
		status = STATUS_PASS;
	} 
	else if(pinInt == DRV_GPIO_INTERRUPT_LOW_EDGE)
  40888a:	2c01      	cmp	r4, #1
  40888c:	d00f      	beq.n	4088ae <drv_gpio_config_interrupt+0x3e>
	{
		PinFlag = PIO_IT_FALL_EDGE | PIO_IT_AIME;
		status = STATUS_PASS;
	}
	else if (pinInt == DRV_GPIO_INTERRUPT_HIGH_LVL)
  40888e:	2c02      	cmp	r4, #2
  408890:	d010      	beq.n	4088b4 <drv_gpio_config_interrupt+0x44>
	{
		PinFlag = PIO_IT_HIGH_LEVEL | PIO_IT_AIME;
		status = STATUS_PASS;
	}
	else if (pinInt == DRV_GPIO_INTERRUPT_LOW_LVL)
  408892:	2c03      	cmp	r4, #3
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t drv_gpio_config_interrupt(drv_gpio_pins_t pin, drv_gpio_interrupt_t pinInt)
{
	status_t status = STATUS_FAIL;
	unsigned long PinFlag = 0;
  408894:	bf0c      	ite	eq
  408896:	2210      	moveq	r2, #16
  408898:	2200      	movne	r2, #0
  40889a:	bf0c      	ite	eq
  40889c:	2400      	moveq	r4, #0
  40889e:	2401      	movne	r4, #1
	else if (pinInt == DRV_GPIO_INTERRUPT_LOW_LVL)
	{
		PinFlag = PIO_IT_LOW_LEVEL | PIO_IT_AIME;
		status = STATUS_PASS;
	}
	pio_configure_interrupt(p_pio, PinMask, PinFlag);
  4088a0:	4638      	mov	r0, r7
  4088a2:	4b09      	ldr	r3, [pc, #36]	; (4088c8 <drv_gpio_config_interrupt+0x58>)
  4088a4:	4798      	blx	r3
	return status;
}
  4088a6:	4620      	mov	r0, r4
  4088a8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	unsigned long PinFlag = 0;
	Pio *p_pio = pio_get_pin_group(gpioConfig[pin].pinId);	//peripheral ID
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[pin].pinId);	//PinMask
	if (pinInt == DRV_GPIO_INTERRUPT_HIGH_EDGE)
	{
		PinFlag = PIO_IT_RISE_EDGE | PIO_IT_AIME;
  4088aa:	2270      	movs	r2, #112	; 0x70
  4088ac:	e7f8      	b.n	4088a0 <drv_gpio_config_interrupt+0x30>
		status = STATUS_PASS;
	} 
	else if(pinInt == DRV_GPIO_INTERRUPT_LOW_EDGE)
	{
		PinFlag = PIO_IT_FALL_EDGE | PIO_IT_AIME;
  4088ae:	2250      	movs	r2, #80	; 0x50
		status = STATUS_PASS;
  4088b0:	2400      	movs	r4, #0
  4088b2:	e7f5      	b.n	4088a0 <drv_gpio_config_interrupt+0x30>
	}
	else if (pinInt == DRV_GPIO_INTERRUPT_HIGH_LVL)
	{
		PinFlag = PIO_IT_HIGH_LEVEL | PIO_IT_AIME;
  4088b4:	2230      	movs	r2, #48	; 0x30
		status = STATUS_PASS;
  4088b6:	2400      	movs	r4, #0
  4088b8:	e7f2      	b.n	4088a0 <drv_gpio_config_interrupt+0x30>
  4088ba:	bf00      	nop
  4088bc:	2000054c 	.word	0x2000054c
  4088c0:	0040b001 	.word	0x0040b001
  4088c4:	0040b019 	.word	0x0040b019
  4088c8:	0040ae25 	.word	0x0040ae25

004088cc <drv_gpio_check_Int>:
 * @return gpioSetFlag
 ***********************************************************************************************/
bool drv_gpio_check_Int(drv_gpio_pins_t pin)
{
	bool returnVal;
	returnVal = gpioConfig[pin].gpioSetFlag;
  4088cc:	4b04      	ldr	r3, [pc, #16]	; (4088e0 <drv_gpio_check_Int+0x14>)
  4088ce:	eb03 1000 	add.w	r0, r3, r0, lsl #4
  4088d2:	f100 0308 	add.w	r3, r0, #8
	gpioConfig[pin].gpioSetFlag = 0;
  4088d6:	2200      	movs	r2, #0
 * @return gpioSetFlag
 ***********************************************************************************************/
bool drv_gpio_check_Int(drv_gpio_pins_t pin)
{
	bool returnVal;
	returnVal = gpioConfig[pin].gpioSetFlag;
  4088d8:	7b80      	ldrb	r0, [r0, #14]
	gpioConfig[pin].gpioSetFlag = 0;
  4088da:	719a      	strb	r2, [r3, #6]
	return	returnVal;
}
  4088dc:	4770      	bx	lr
  4088de:	bf00      	nop
  4088e0:	2000054c 	.word	0x2000054c

004088e4 <drv_gpio_clear_Int>:
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
bool drv_gpio_clear_Int(drv_gpio_pins_t pin)
{
	status_t status = STATUS_PASS;
	gpioConfig[pin].gpioSetFlag = 0;
  4088e4:	4b03      	ldr	r3, [pc, #12]	; (4088f4 <drv_gpio_clear_Int+0x10>)
  4088e6:	eb03 1000 	add.w	r0, r3, r0, lsl #4
  4088ea:	f100 0308 	add.w	r3, r0, #8
  4088ee:	2000      	movs	r0, #0
  4088f0:	7198      	strb	r0, [r3, #6]
	return status;
}
  4088f2:	4770      	bx	lr
  4088f4:	2000054c 	.word	0x2000054c

004088f8 <drv_gpio_enable_interrupt>:
 * @brief Enable the interrupt on a particular pin
 * @param drv_gpio_pins_t pin
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t drv_gpio_enable_interrupt(drv_gpio_pins_t pin)
{
  4088f8:	b570      	push	{r4, r5, r6, lr}
	status_t status = STATUS_PASS;
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[pin].pinId);
  4088fa:	0104      	lsls	r4, r0, #4
  4088fc:	4d0f      	ldr	r5, [pc, #60]	; (40893c <drv_gpio_enable_interrupt+0x44>)
  4088fe:	4b10      	ldr	r3, [pc, #64]	; (408940 <drv_gpio_enable_interrupt+0x48>)
  408900:	5928      	ldr	r0, [r5, r4]
  408902:	4798      	blx	r3
	Pio *p_pio = pio_get_pin_group(gpioConfig[pin].pinId);
  408904:	4b0f      	ldr	r3, [pc, #60]	; (408944 <drv_gpio_enable_interrupt+0x4c>)
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t drv_gpio_enable_interrupt(drv_gpio_pins_t pin)
{
	status_t status = STATUS_PASS;
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[pin].pinId);
  408906:	4606      	mov	r6, r0
	Pio *p_pio = pio_get_pin_group(gpioConfig[pin].pinId);
  408908:	5928      	ldr	r0, [r5, r4]
  40890a:	4798      	blx	r3
	pio_enable_interrupt(p_pio, PinMask);
  40890c:	4b0e      	ldr	r3, [pc, #56]	; (408948 <drv_gpio_enable_interrupt+0x50>)
  40890e:	4631      	mov	r1, r6
 ***********************************************************************************************/
status_t drv_gpio_enable_interrupt(drv_gpio_pins_t pin)
{
	status_t status = STATUS_PASS;
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[pin].pinId);
	Pio *p_pio = pio_get_pin_group(gpioConfig[pin].pinId);
  408910:	4604      	mov	r4, r0
	pio_enable_interrupt(p_pio, PinMask);
  408912:	4798      	blx	r3
	if (p_pio == PIOA)
  408914:	4b0d      	ldr	r3, [pc, #52]	; (40894c <drv_gpio_enable_interrupt+0x54>)
  408916:	429c      	cmp	r4, r3
  408918:	d00a      	beq.n	408930 <drv_gpio_enable_interrupt+0x38>
	{
		NVIC_EnableIRQ(PIOA_IRQn);
	}
	else if (p_pio == PIOB)
  40891a:	4b0d      	ldr	r3, [pc, #52]	; (408950 <drv_gpio_enable_interrupt+0x58>)
  40891c:	429c      	cmp	r4, r3
  40891e:	d001      	beq.n	408924 <drv_gpio_enable_interrupt+0x2c>
	{
		NVIC_EnableIRQ(PIOB_IRQn);
	}
	return status;
}
  408920:	2000      	movs	r0, #0
  408922:	bd70      	pop	{r4, r5, r6, pc}
  408924:	4b0b      	ldr	r3, [pc, #44]	; (408954 <drv_gpio_enable_interrupt+0x5c>)
  408926:	f44f 5280 	mov.w	r2, #4096	; 0x1000
  40892a:	601a      	str	r2, [r3, #0]
  40892c:	2000      	movs	r0, #0
  40892e:	bd70      	pop	{r4, r5, r6, pc}
  408930:	4b08      	ldr	r3, [pc, #32]	; (408954 <drv_gpio_enable_interrupt+0x5c>)
  408932:	f44f 6200 	mov.w	r2, #2048	; 0x800
  408936:	601a      	str	r2, [r3, #0]
  408938:	2000      	movs	r0, #0
  40893a:	bd70      	pop	{r4, r5, r6, pc}
  40893c:	2000054c 	.word	0x2000054c
  408940:	0040b019 	.word	0x0040b019
  408944:	0040b001 	.word	0x0040b001
  408948:	0040ae4d 	.word	0x0040ae4d
  40894c:	400e0e00 	.word	0x400e0e00
  408950:	400e1000 	.word	0x400e1000
  408954:	e000e100 	.word	0xe000e100

00408958 <drv_gpio_disable_interrupt_all>:
 * @brief Disable interrupts on every gpio pin of every port
 * @param drv_gpio_pins_t pin
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t drv_gpio_disable_interrupt_all(void)
{
  408958:	b538      	push	{r3, r4, r5, lr}
	status_t status = STATUS_PASS;
	pio_disable_interrupt(PIOA, ALL_INTERRUPT_MASK);
  40895a:	480a      	ldr	r0, [pc, #40]	; (408984 <drv_gpio_disable_interrupt_all+0x2c>)
  40895c:	4d0a      	ldr	r5, [pc, #40]	; (408988 <drv_gpio_disable_interrupt_all+0x30>)

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
  40895e:	4c0b      	ldr	r4, [pc, #44]	; (40898c <drv_gpio_disable_interrupt_all+0x34>)
  408960:	f04f 31ff 	mov.w	r1, #4294967295
  408964:	47a8      	blx	r5
  408966:	f44f 6300 	mov.w	r3, #2048	; 0x800
  40896a:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
	NVIC_DisableIRQ(PIOA_IRQn);
	pio_disable_interrupt(PIOB, ALL_INTERRUPT_MASK);
  40896e:	4808      	ldr	r0, [pc, #32]	; (408990 <drv_gpio_disable_interrupt_all+0x38>)
  408970:	f04f 31ff 	mov.w	r1, #4294967295
  408974:	47a8      	blx	r5
  408976:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  40897a:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
	NVIC_DisableIRQ(PIOB_IRQn);
	return status;
}
  40897e:	2000      	movs	r0, #0
  408980:	bd38      	pop	{r3, r4, r5, pc}
  408982:	bf00      	nop
  408984:	400e0e00 	.word	0x400e0e00
  408988:	0040ae55 	.word	0x0040ae55
  40898c:	e000e100 	.word	0xe000e100
  408990:	400e1000 	.word	0x400e1000

00408994 <uart_process_byte>:
	}		
	return status;
}

static void uart_process_byte(Usart *p_usart, drv_uart_memory_buf_t* memBuf)
{
  408994:	b510      	push	{r4, lr}
	uint32_t val = 0;
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
  408996:	f8b1 3204 	ldrh.w	r3, [r1, #516]	; 0x204
	}		
	return status;
}

static void uart_process_byte(Usart *p_usart, drv_uart_memory_buf_t* memBuf)
{
  40899a:	b082      	sub	sp, #8
	uint32_t val = 0;
  40899c:	2200      	movs	r2, #0
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
  40899e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
	}		
	return status;
}

static void uart_process_byte(Usart *p_usart, drv_uart_memory_buf_t* memBuf)
{
  4089a2:	460c      	mov	r4, r1
	uint32_t val = 0;
  4089a4:	9201      	str	r2, [sp, #4]
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
  4089a6:	d028      	beq.n	4089fa <uart_process_byte+0x66>
		memBuf->uart_rx_fifo_ovf_flag = 1;                     // set the overflow flag
		//the buffer is full, but we have to clear the interrupt
		memBuf->uart_rx_fifo_dropped_bytes++; //our data stream will be out of sync now...
		usart_getchar(p_usart,&val);		
	}
	else if(memBuf->rx_fifo.num_bytes < FIFO_BUFFER_SIZE)  // if there's room in the sw buffer
  4089a8:	d30c      	bcc.n	4089c4 <uart_process_byte+0x30>
	}
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE)
	{      // if sw buffer just filled up
		memBuf->uart_rx_fifo_full_flag = 1;                    // set the RX FIFO full flag
	}
	if(memBuf->rx_fifo.i_last == FIFO_BUFFER_SIZE)
  4089aa:	f8b4 3202 	ldrh.w	r3, [r4, #514]	; 0x202
  4089ae:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
	{         // if the index has reached the end of the buffer,
		memBuf->rx_fifo.i_last = 0;                            // roll over the index counter
  4089b2:	bf04      	itt	eq
  4089b4:	2300      	moveq	r3, #0
  4089b6:	f8a4 3202 	strheq.w	r3, [r4, #514]	; 0x202
	}
	memBuf->uart_rx_fifo_not_empty_flag = 1;                 // set received-data flag	
  4089ba:	2301      	movs	r3, #1
  4089bc:	f884 3207 	strb.w	r3, [r4, #519]	; 0x207
}
  4089c0:	b002      	add	sp, #8
  4089c2:	bd10      	pop	{r4, pc}
		usart_getchar(p_usart,&val);		
	}
	else if(memBuf->rx_fifo.num_bytes < FIFO_BUFFER_SIZE)  // if there's room in the sw buffer
	{		
		//while((UART0->UART_SR & UART_SR_RXRDY) == 0);
		if(usart_getchar(p_usart,&val) == STATUS_PASS)
  4089c4:	a901      	add	r1, sp, #4
  4089c6:	4b14      	ldr	r3, [pc, #80]	; (408a18 <uart_process_byte+0x84>)
  4089c8:	4798      	blx	r3
  4089ca:	b140      	cbz	r0, 4089de <uart_process_byte+0x4a>
  4089cc:	f8b4 3204 	ldrh.w	r3, [r4, #516]	; 0x204
		//if(p_usart == UART1)
		//{
			//usart_putchar(UART0, val);
		//}
	}
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE)
  4089d0:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
	{      // if sw buffer just filled up
		memBuf->uart_rx_fifo_full_flag = 1;                    // set the RX FIFO full flag
  4089d4:	bf04      	itt	eq
  4089d6:	2301      	moveq	r3, #1
  4089d8:	f884 3208 	strbeq.w	r3, [r4, #520]	; 0x208
  4089dc:	e7e5      	b.n	4089aa <uart_process_byte+0x16>
	else if(memBuf->rx_fifo.num_bytes < FIFO_BUFFER_SIZE)  // if there's room in the sw buffer
	{		
		//while((UART0->UART_SR & UART_SR_RXRDY) == 0);
		if(usart_getchar(p_usart,&val) == STATUS_PASS)
		{		
			memBuf->rx_fifo.data_buf[memBuf->rx_fifo.i_last] = (uint8_t)val;
  4089de:	f8b4 2202 	ldrh.w	r2, [r4, #514]	; 0x202
  4089e2:	9b01      	ldr	r3, [sp, #4]
  4089e4:	54a3      	strb	r3, [r4, r2]
			memBuf->rx_fifo.i_last++;                              // increment the index of the most recently added element
			memBuf->rx_fifo.num_bytes++;                           // increment the bytes counter
  4089e6:	f8b4 3204 	ldrh.w	r3, [r4, #516]	; 0x204
  4089ea:	3301      	adds	r3, #1
	{		
		//while((UART0->UART_SR & UART_SR_RXRDY) == 0);
		if(usart_getchar(p_usart,&val) == STATUS_PASS)
		{		
			memBuf->rx_fifo.data_buf[memBuf->rx_fifo.i_last] = (uint8_t)val;
			memBuf->rx_fifo.i_last++;                              // increment the index of the most recently added element
  4089ec:	3201      	adds	r2, #1
			memBuf->rx_fifo.num_bytes++;                           // increment the bytes counter
  4089ee:	b29b      	uxth	r3, r3
	{		
		//while((UART0->UART_SR & UART_SR_RXRDY) == 0);
		if(usart_getchar(p_usart,&val) == STATUS_PASS)
		{		
			memBuf->rx_fifo.data_buf[memBuf->rx_fifo.i_last] = (uint8_t)val;
			memBuf->rx_fifo.i_last++;                              // increment the index of the most recently added element
  4089f0:	f8a4 2202 	strh.w	r2, [r4, #514]	; 0x202
			memBuf->rx_fifo.num_bytes++;                           // increment the bytes counter
  4089f4:	f8a4 3204 	strh.w	r3, [r4, #516]	; 0x204
  4089f8:	e7ea      	b.n	4089d0 <uart_process_byte+0x3c>
	uint32_t val = 0;
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
	{
		memBuf->uart_rx_fifo_ovf_flag = 1;                     // set the overflow flag
		//the buffer is full, but we have to clear the interrupt
		memBuf->uart_rx_fifo_dropped_bytes++; //our data stream will be out of sync now...
  4089fa:	f8d1 320c 	ldr.w	r3, [r1, #524]	; 0x20c
		usart_getchar(p_usart,&val);		
  4089fe:	4a06      	ldr	r2, [pc, #24]	; (408a18 <uart_process_byte+0x84>)
	uint32_t val = 0;
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
	{
		memBuf->uart_rx_fifo_ovf_flag = 1;                     // set the overflow flag
		//the buffer is full, but we have to clear the interrupt
		memBuf->uart_rx_fifo_dropped_bytes++; //our data stream will be out of sync now...
  408a00:	3301      	adds	r3, #1
static void uart_process_byte(Usart *p_usart, drv_uart_memory_buf_t* memBuf)
{
	uint32_t val = 0;
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
	{
		memBuf->uart_rx_fifo_ovf_flag = 1;                     // set the overflow flag
  408a02:	2101      	movs	r1, #1
		//the buffer is full, but we have to clear the interrupt
		memBuf->uart_rx_fifo_dropped_bytes++; //our data stream will be out of sync now...
  408a04:	f8c4 320c 	str.w	r3, [r4, #524]	; 0x20c
static void uart_process_byte(Usart *p_usart, drv_uart_memory_buf_t* memBuf)
{
	uint32_t val = 0;
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
	{
		memBuf->uart_rx_fifo_ovf_flag = 1;                     // set the overflow flag
  408a08:	f884 1209 	strb.w	r1, [r4, #521]	; 0x209
		//the buffer is full, but we have to clear the interrupt
		memBuf->uart_rx_fifo_dropped_bytes++; //our data stream will be out of sync now...
		usart_getchar(p_usart,&val);		
  408a0c:	a901      	add	r1, sp, #4
  408a0e:	4790      	blx	r2
  408a10:	f8b4 3204 	ldrh.w	r3, [r4, #516]	; 0x204
  408a14:	e7dc      	b.n	4089d0 <uart_process_byte+0x3c>
  408a16:	bf00      	nop
  408a18:	00403ea5 	.word	0x00403ea5

00408a1c <uart_process_tx_byte>:
	}
	memBuf->uart_rx_fifo_not_empty_flag = 1;                 // set received-data flag	
}

static void uart_process_tx_byte(Usart *p_usart, drv_uart_memory_buf_t* memBuf)
{
  408a1c:	b570      	push	{r4, r5, r6, lr}
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE)
  408a1e:	f8b1 3414 	ldrh.w	r3, [r1, #1044]	; 0x414
  408a22:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
	}
	memBuf->uart_rx_fifo_not_empty_flag = 1;                 // set received-data flag	
}

static void uart_process_tx_byte(Usart *p_usart, drv_uart_memory_buf_t* memBuf)
{
  408a26:	460c      	mov	r4, r1
  408a28:	4602      	mov	r2, r0
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE)
  408a2a:	d00f      	beq.n	408a4c <uart_process_tx_byte+0x30>
	{ // if the sw buffer is full
		memBuf->uart_tx_fifo_full_flag = 0;               // clear the buffer full flag because we are about to make room
	}
	if(memBuf->tx_fifo.num_bytes > 0)
  408a2c:	b98b      	cbnz	r3, 408a52 <uart_process_tx_byte+0x36>
		memBuf->tx_fifo.i_first++;                        // increment the index of the oldest element
		memBuf->tx_fifo.num_bytes--;                      // decrement the bytes counter
	}
	else
	{   // tx sw buffer is empty
		memBuf->uart_tx_fifo_not_empty_flag = 0;          // clear the tx flag
  408a2e:	f881 3416 	strb.w	r3, [r1, #1046]	; 0x416
		uart_disable_interrupt(p_usart,UART_IER_TXEMPTY); //the buffer is empty, stop the interrupt. 
  408a32:	f44f 7100 	mov.w	r1, #512	; 0x200
  408a36:	4b23      	ldr	r3, [pc, #140]	; (408ac4 <uart_process_tx_byte+0xa8>)
  408a38:	4798      	blx	r3
  408a3a:	f8b4 2410 	ldrh.w	r2, [r4, #1040]	; 0x410
	}
	if(memBuf->tx_fifo.i_first == FIFO_BUFFER_SIZE)
  408a3e:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
	{   // if the index has reached the end of the buffer,
		memBuf->tx_fifo.i_first = 0;                      // roll over the index counter
  408a42:	bf04      	itt	eq
  408a44:	2300      	moveq	r3, #0
  408a46:	f8a4 3410 	strheq.w	r3, [r4, #1040]	; 0x410
  408a4a:	bd70      	pop	{r4, r5, r6, pc}

static void uart_process_tx_byte(Usart *p_usart, drv_uart_memory_buf_t* memBuf)
{
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE)
	{ // if the sw buffer is full
		memBuf->uart_tx_fifo_full_flag = 0;               // clear the buffer full flag because we are about to make room
  408a4c:	2100      	movs	r1, #0
  408a4e:	f884 1417 	strb.w	r1, [r4, #1047]	; 0x417
	}
	if(memBuf->tx_fifo.num_bytes > 0)
	{
		// if data exists in the sw buffer
		usart_serial_putchar(p_usart,memBuf->tx_fifo.data_buf[memBuf->tx_fifo.i_first]); // send the next value from buffer
  408a52:	f8b4 1410 	ldrh.w	r1, [r4, #1040]	; 0x410
		while (uart_write((Uart*)p_usart, c)!=0);
		return 1;
	}
#else
# ifdef UART0
	if (UART0 == (Uart*)p_usart) {
  408a56:	481c      	ldr	r0, [pc, #112]	; (408ac8 <uart_process_tx_byte+0xac>)
  408a58:	1865      	adds	r5, r4, r1
  408a5a:	4282      	cmp	r2, r0
  408a5c:	f895 5210 	ldrb.w	r5, [r5, #528]	; 0x210
  408a60:	d010      	beq.n	408a84 <uart_process_tx_byte+0x68>
		while (uart_write((Uart*)p_usart, c)!=0);
		return 1;
	}
# endif
# ifdef UART1
	if (UART1 == (Uart*)p_usart) {
  408a62:	481a      	ldr	r0, [pc, #104]	; (408acc <uart_process_tx_byte+0xb0>)
  408a64:	4282      	cmp	r2, r0
  408a66:	d01f      	beq.n	408aa8 <uart_process_tx_byte+0x8c>
		while (usart_write(p_usart, c)!=0);
		return 1;
	}
#else
# ifdef USART0
	if (USART0 == p_usart) {
  408a68:	4819      	ldr	r0, [pc, #100]	; (408ad0 <uart_process_tx_byte+0xb4>)
  408a6a:	4282      	cmp	r2, r0
  408a6c:	d023      	beq.n	408ab6 <uart_process_tx_byte+0x9a>
		while (usart_write(p_usart, c)!=0);
		return 1;
	}
# endif
# ifdef USART1
	if (USART1 == p_usart) {
  408a6e:	4819      	ldr	r0, [pc, #100]	; (408ad4 <uart_process_tx_byte+0xb8>)
  408a70:	4282      	cmp	r2, r0
  408a72:	d012      	beq.n	408a9a <uart_process_tx_byte+0x7e>
		memBuf->tx_fifo.i_first++;                        // increment the index of the oldest element
  408a74:	1c4a      	adds	r2, r1, #1
  408a76:	b292      	uxth	r2, r2
		memBuf->tx_fifo.num_bytes--;                      // decrement the bytes counter
  408a78:	3b01      	subs	r3, #1
	}
	if(memBuf->tx_fifo.num_bytes > 0)
	{
		// if data exists in the sw buffer
		usart_serial_putchar(p_usart,memBuf->tx_fifo.data_buf[memBuf->tx_fifo.i_first]); // send the next value from buffer
		memBuf->tx_fifo.i_first++;                        // increment the index of the oldest element
  408a7a:	f8a4 2410 	strh.w	r2, [r4, #1040]	; 0x410
		memBuf->tx_fifo.num_bytes--;                      // decrement the bytes counter
  408a7e:	f8a4 3414 	strh.w	r3, [r4, #1044]	; 0x414
  408a82:	e7dc      	b.n	408a3e <uart_process_tx_byte+0x22>
  408a84:	4e14      	ldr	r6, [pc, #80]	; (408ad8 <uart_process_tx_byte+0xbc>)
		return 1;
	}
#else
# ifdef UART0
	if (UART0 == (Uart*)p_usart) {
		while (uart_write((Uart*)p_usart, c)!=0);
  408a86:	4810      	ldr	r0, [pc, #64]	; (408ac8 <uart_process_tx_byte+0xac>)
  408a88:	4629      	mov	r1, r5
  408a8a:	47b0      	blx	r6
  408a8c:	2800      	cmp	r0, #0
  408a8e:	d1fa      	bne.n	408a86 <uart_process_tx_byte+0x6a>
  408a90:	f8b4 1410 	ldrh.w	r1, [r4, #1040]	; 0x410
  408a94:	f8b4 3414 	ldrh.w	r3, [r4, #1044]	; 0x414
  408a98:	e7ec      	b.n	408a74 <uart_process_tx_byte+0x58>
  408a9a:	4e10      	ldr	r6, [pc, #64]	; (408adc <uart_process_tx_byte+0xc0>)
		return 1;
	}
# endif
# ifdef USART1
	if (USART1 == p_usart) {
		while (usart_write(p_usart, c)!=0);
  408a9c:	480d      	ldr	r0, [pc, #52]	; (408ad4 <uart_process_tx_byte+0xb8>)
  408a9e:	4629      	mov	r1, r5
  408aa0:	47b0      	blx	r6
  408aa2:	2800      	cmp	r0, #0
  408aa4:	d1fa      	bne.n	408a9c <uart_process_tx_byte+0x80>
  408aa6:	e7f3      	b.n	408a90 <uart_process_tx_byte+0x74>
  408aa8:	4e0b      	ldr	r6, [pc, #44]	; (408ad8 <uart_process_tx_byte+0xbc>)
		return 1;
	}
# endif
# ifdef UART1
	if (UART1 == (Uart*)p_usart) {
		while (uart_write((Uart*)p_usart, c)!=0);
  408aaa:	4808      	ldr	r0, [pc, #32]	; (408acc <uart_process_tx_byte+0xb0>)
  408aac:	4629      	mov	r1, r5
  408aae:	47b0      	blx	r6
  408ab0:	2800      	cmp	r0, #0
  408ab2:	d1fa      	bne.n	408aaa <uart_process_tx_byte+0x8e>
  408ab4:	e7ec      	b.n	408a90 <uart_process_tx_byte+0x74>
  408ab6:	4e09      	ldr	r6, [pc, #36]	; (408adc <uart_process_tx_byte+0xc0>)
		return 1;
	}
#else
# ifdef USART0
	if (USART0 == p_usart) {
		while (usart_write(p_usart, c)!=0);
  408ab8:	4805      	ldr	r0, [pc, #20]	; (408ad0 <uart_process_tx_byte+0xb4>)
  408aba:	4629      	mov	r1, r5
  408abc:	47b0      	blx	r6
  408abe:	2800      	cmp	r0, #0
  408ac0:	d1fa      	bne.n	408ab8 <uart_process_tx_byte+0x9c>
  408ac2:	e7e5      	b.n	408a90 <uart_process_tx_byte+0x74>
  408ac4:	00403d65 	.word	0x00403d65
  408ac8:	400e0600 	.word	0x400e0600
  408acc:	400e0800 	.word	0x400e0800
  408ad0:	40024000 	.word	0x40024000
  408ad4:	40028000 	.word	0x40028000
  408ad8:	00403d6d 	.word	0x00403d6d
  408adc:	00403e79 	.word	0x00403e79

00408ae0 <drv_uart_getChar.part.0>:
 * the character from
 * @param *c, the return character
 * @return STATUS_PASS if successful, STATUS_EOF if there were no bytes to read
 *	STATUS_FAIL if there is an error
 ***********************************************************************************************/	
status_t drv_uart_getChar(drv_uart_config_t* uartConfig, char* c)
  408ae0:	b538      	push	{r3, r4, r5, lr}
  408ae2:	4604      	mov	r4, r0
{
	status_t status = STATUS_PASS;
	
	if(uartMemBuf[uartConfig->mem_index].uart_rx_fifo_not_empty_flag == 1) //check if the buffer has information in it
	{
		usart_disable_interrupt(uartConfig->p_usart, UART_IER_RXRDY);
  408ae4:	4b1a      	ldr	r3, [pc, #104]	; (408b50 <drv_uart_getChar.part.0+0x70>)
  408ae6:	6800      	ldr	r0, [r0, #0]
 * the character from
 * @param *c, the return character
 * @return STATUS_PASS if successful, STATUS_EOF if there were no bytes to read
 *	STATUS_FAIL if there is an error
 ***********************************************************************************************/	
status_t drv_uart_getChar(drv_uart_config_t* uartConfig, char* c)
  408ae8:	460d      	mov	r5, r1
{
	status_t status = STATUS_PASS;
	
	if(uartMemBuf[uartConfig->mem_index].uart_rx_fifo_not_empty_flag == 1) //check if the buffer has information in it
	{
		usart_disable_interrupt(uartConfig->p_usart, UART_IER_RXRDY);
  408aea:	2101      	movs	r1, #1
  408aec:	4798      	blx	r3
		//disable the interrupts so we don't fuck up the pointers		
		status = uart_get_byte(&(uartMemBuf[uartConfig->mem_index]), c); //get the byte from the buffer	
  408aee:	6962      	ldr	r2, [r4, #20]
  408af0:	4818      	ldr	r0, [pc, #96]	; (408b54 <drv_uart_getChar.part.0+0x74>)
  408af2:	eb02 1242 	add.w	r2, r2, r2, lsl #5
  408af6:	eb00 1342 	add.w	r3, r0, r2, lsl #5

//static functions
static int uart_get_byte(drv_uart_memory_buf_t* memBuf, char* c)
{
	status_t status = STATUS_PASS;
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE)
  408afa:	f8b3 2204 	ldrh.w	r2, [r3, #516]	; 0x204
  408afe:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
  408b02:	d011      	beq.n	408b28 <drv_uart_getChar.part.0+0x48>
	{ // if the sw buffer is full
		memBuf->uart_rx_fifo_full_flag = 0;               // clear the buffer full flag because we are about to make room
	}
	if(memBuf->rx_fifo.num_bytes > 0)
  408b04:	b99a      	cbnz	r2, 408b2e <drv_uart_getChar.part.0+0x4e>
  408b06:	f8b3 1200 	ldrh.w	r1, [r3, #512]	; 0x200
		memBuf->rx_fifo.i_first++;                        // increment the index of the oldest element
		memBuf->rx_fifo.num_bytes--;                      // decrement the bytes counter
	}
	else
	{                                      // RX sw buffer is empty
		memBuf->uart_rx_fifo_not_empty_flag = 0;          // clear the rx flag
  408b0a:	f883 2207 	strb.w	r2, [r3, #519]	; 0x207
		status = STATUS_EOF;
  408b0e:	2502      	movs	r5, #2
	}
	if(memBuf->rx_fifo.i_first == FIFO_BUFFER_SIZE)
  408b10:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
	{   // if the index has reached the end of the buffer,
		memBuf->rx_fifo.i_first = 0;                      // roll over the index counter
  408b14:	bf04      	itt	eq
  408b16:	2200      	moveq	r2, #0
  408b18:	f8a3 2200 	strheq.w	r2, [r3, #512]	; 0x200
	{
		usart_disable_interrupt(uartConfig->p_usart, UART_IER_RXRDY);
		//disable the interrupts so we don't fuck up the pointers		
		status = uart_get_byte(&(uartMemBuf[uartConfig->mem_index]), c); //get the byte from the buffer	
		//re-enable the interrupts
		usart_enable_interrupt(uartConfig->p_usart, UART_IER_RXRDY);				
  408b1c:	6820      	ldr	r0, [r4, #0]
  408b1e:	4b0e      	ldr	r3, [pc, #56]	; (408b58 <drv_uart_getChar.part.0+0x78>)
  408b20:	2101      	movs	r1, #1
  408b22:	4798      	blx	r3
	{
		status = STATUS_EOF; //there's no data return End Of File status code.
	}
	
	return status;	
}
  408b24:	4628      	mov	r0, r5
  408b26:	bd38      	pop	{r3, r4, r5, pc}
static int uart_get_byte(drv_uart_memory_buf_t* memBuf, char* c)
{
	status_t status = STATUS_PASS;
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE)
	{ // if the sw buffer is full
		memBuf->uart_rx_fifo_full_flag = 0;               // clear the buffer full flag because we are about to make room
  408b28:	2200      	movs	r2, #0
  408b2a:	f883 2208 	strb.w	r2, [r3, #520]	; 0x208
	}
	if(memBuf->rx_fifo.num_bytes > 0)
	{
		// if data exists in the sw buffer
		*c = memBuf->rx_fifo.data_buf[memBuf->rx_fifo.i_first]; // grab the oldest element in the buffer
  408b2e:	f8b3 2200 	ldrh.w	r2, [r3, #512]	; 0x200
  408b32:	5c9a      	ldrb	r2, [r3, r2]
  408b34:	702a      	strb	r2, [r5, #0]
		memBuf->rx_fifo.i_first++;                        // increment the index of the oldest element
  408b36:	f8b3 1200 	ldrh.w	r1, [r3, #512]	; 0x200
		memBuf->rx_fifo.num_bytes--;                      // decrement the bytes counter
  408b3a:	f8b3 2204 	ldrh.w	r2, [r3, #516]	; 0x204
	}
	if(memBuf->rx_fifo.num_bytes > 0)
	{
		// if data exists in the sw buffer
		*c = memBuf->rx_fifo.data_buf[memBuf->rx_fifo.i_first]; // grab the oldest element in the buffer
		memBuf->rx_fifo.i_first++;                        // increment the index of the oldest element
  408b3e:	3101      	adds	r1, #1
  408b40:	b289      	uxth	r1, r1
		memBuf->rx_fifo.num_bytes--;                      // decrement the bytes counter
  408b42:	3a01      	subs	r2, #1
	}
	if(memBuf->rx_fifo.num_bytes > 0)
	{
		// if data exists in the sw buffer
		*c = memBuf->rx_fifo.data_buf[memBuf->rx_fifo.i_first]; // grab the oldest element in the buffer
		memBuf->rx_fifo.i_first++;                        // increment the index of the oldest element
  408b44:	f8a3 1200 	strh.w	r1, [r3, #512]	; 0x200
		memBuf->rx_fifo.num_bytes--;                      // decrement the bytes counter
  408b48:	f8a3 2204 	strh.w	r2, [r3, #516]	; 0x204


//static functions
static int uart_get_byte(drv_uart_memory_buf_t* memBuf, char* c)
{
	status_t status = STATUS_PASS;
  408b4c:	2500      	movs	r5, #0
  408b4e:	e7df      	b.n	408b10 <drv_uart_getChar.part.0+0x30>
  408b50:	00403e75 	.word	0x00403e75
  408b54:	20003e2c 	.word	0x20003e2c
  408b58:	00403e71 	.word	0x00403e71

00408b5c <drv_uart_init>:
 * @brief initialize uart driver and circular buffer
 * @param uartConfig, the configuration structure for the uart, contains settings.  
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/	
status_t drv_uart_init(drv_uart_config_t* uartConfig)
{
  408b5c:	b5f0      	push	{r4, r5, r6, r7, lr}
	status_t status = STATUS_PASS; 
	
	if(uartConfig->p_usart == UART0)
  408b5e:	4ba7      	ldr	r3, [pc, #668]	; (408dfc <drv_uart_init+0x2a0>)
  408b60:	6804      	ldr	r4, [r0, #0]
  408b62:	429c      	cmp	r4, r3
 * @brief initialize uart driver and circular buffer
 * @param uartConfig, the configuration structure for the uart, contains settings.  
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/	
status_t drv_uart_init(drv_uart_config_t* uartConfig)
{
  408b64:	b08b      	sub	sp, #44	; 0x2c
  408b66:	4605      	mov	r5, r0
	status_t status = STATUS_PASS; 
	
	if(uartConfig->p_usart == UART0)
  408b68:	f000 80e7 	beq.w	408d3a <drv_uart_init+0x1de>
	{
		uartConfig->mem_index = 0;
	}
	else if(uartConfig->p_usart == UART1)
  408b6c:	4ba4      	ldr	r3, [pc, #656]	; (408e00 <drv_uart_init+0x2a4>)
  408b6e:	429c      	cmp	r4, r3
  408b70:	f000 80e6 	beq.w	408d40 <drv_uart_init+0x1e4>
	{	
		uartConfig->mem_index = 1;
	}
	else if(uartConfig->p_usart == USART0)
  408b74:	4ba3      	ldr	r3, [pc, #652]	; (408e04 <drv_uart_init+0x2a8>)
  408b76:	429c      	cmp	r4, r3
  408b78:	f000 80e5 	beq.w	408d46 <drv_uart_init+0x1ea>
	{	
		uartConfig->mem_index = 2;
	}
	else if(uartConfig->p_usart == USART1)
  408b7c:	4ba2      	ldr	r3, [pc, #648]	; (408e08 <drv_uart_init+0x2ac>)
  408b7e:	429c      	cmp	r4, r3
  408b80:	d002      	beq.n	408b88 <drv_uart_init+0x2c>
		uartConfig->mem_index = 3;
	}
	else
	{
		//ERROR! The config settings have an invalid UART pointer
		return STATUS_FAIL;
  408b82:	2001      	movs	r0, #1
	uartMemBuf[uartConfig->mem_index].uart_tx_fifo_not_empty_flag = 0;
	uartMemBuf[uartConfig->mem_index].uart_tx_fifo_ovf_flag = 0;
	uartMemBuf[uartConfig->mem_index].tx_fifo.num_bytes = 0;
	
	return status; 
}
  408b84:	b00b      	add	sp, #44	; 0x2c
  408b86:	bdf0      	pop	{r4, r5, r6, r7, pc}
		uartConfig->mem_index = 2;
	}
	else if(uartConfig->p_usart == USART1)
	{

		uartConfig->mem_index = 3;
  408b88:	2303      	movs	r3, #3
  408b8a:	6143      	str	r3, [r0, #20]
	{
		//ERROR! an incorrect buffer index has been used.  
		return STATUS_FAIL; 
	}
	//make sure the buffer isn't already initialized. 
	if(uartMemBuf[uartConfig->mem_index].isinit == true)
  408b8c:	4e9f      	ldr	r6, [pc, #636]	; (408e0c <drv_uart_init+0x2b0>)
  408b8e:	eb03 1343 	add.w	r3, r3, r3, lsl #5
  408b92:	eb06 1343 	add.w	r3, r6, r3, lsl #5
  408b96:	f503 7300 	add.w	r3, r3, #512	; 0x200
  408b9a:	799b      	ldrb	r3, [r3, #6]
  408b9c:	2b01      	cmp	r3, #1
  408b9e:	d0f0      	beq.n	408b82 <drv_uart_init+0x26>
		/* Configure UART */
		uart_init((Uart*)p_usart, &uart_settings);
	}
#else
# ifdef UART0
	if (UART0 == (Uart*)p_usart) {
  408ba0:	4896      	ldr	r0, [pc, #600]	; (408dfc <drv_uart_init+0x2a0>)
{
#if ((!SAM4L) && (!SAMG55))
	sam_uart_opt_t uart_settings;
	uart_settings.ul_mck = sysclk_get_peripheral_hz();
	uart_settings.ul_baudrate = opt->baudrate;
	uart_settings.ul_mode = opt->paritytype;
  408ba2:	68eb      	ldr	r3, [r5, #12]
		usart_serial_options_t *opt)
{
#if ((!SAM4L) && (!SAMG55))
	sam_uart_opt_t uart_settings;
	uart_settings.ul_mck = sysclk_get_peripheral_hz();
	uart_settings.ul_baudrate = opt->baudrate;
  408ba4:	6869      	ldr	r1, [r5, #4]
static inline void usart_serial_init(usart_if p_usart,
		usart_serial_options_t *opt)
{
#if ((!SAM4L) && (!SAMG55))
	sam_uart_opt_t uart_settings;
	uart_settings.ul_mck = sysclk_get_peripheral_hz();
  408ba6:	4f9a      	ldr	r7, [pc, #616]	; (408e10 <drv_uart_init+0x2b4>)

	sam_usart_opt_t usart_settings;
	usart_settings.baudrate = opt->baudrate;
	usart_settings.char_length = opt->charlength;
	usart_settings.parity_type = opt->paritytype;
	usart_settings.stop_bits= opt->stopbits;
  408ba8:	f895 c010 	ldrb.w	ip, [r5, #16]
{
#if ((!SAM4L) && (!SAMG55))
	sam_uart_opt_t uart_settings;
	uart_settings.ul_mck = sysclk_get_peripheral_hz();
	uart_settings.ul_baudrate = opt->baudrate;
	uart_settings.ul_mode = opt->paritytype;
  408bac:	9303      	str	r3, [sp, #12]
	sam_usart_opt_t usart_settings;
	usart_settings.baudrate = opt->baudrate;
	usart_settings.char_length = opt->charlength;
	usart_settings.parity_type = opt->paritytype;
	usart_settings.stop_bits= opt->stopbits;
	usart_settings.channel_mode= US_MR_CHMODE_NORMAL;
  408bae:	2200      	movs	r2, #0
#endif

	sam_usart_opt_t usart_settings;
	usart_settings.baudrate = opt->baudrate;
	usart_settings.char_length = opt->charlength;
	usart_settings.parity_type = opt->paritytype;
  408bb0:	9306      	str	r3, [sp, #24]
		/* Configure UART */
		uart_init((Uart*)p_usart, &uart_settings);
	}
#else
# ifdef UART0
	if (UART0 == (Uart*)p_usart) {
  408bb2:	4284      	cmp	r4, r0
	uart_settings.ul_mode = opt->paritytype;
#endif

	sam_usart_opt_t usart_settings;
	usart_settings.baudrate = opt->baudrate;
	usart_settings.char_length = opt->charlength;
  408bb4:	68ab      	ldr	r3, [r5, #8]
static inline void usart_serial_init(usart_if p_usart,
		usart_serial_options_t *opt)
{
#if ((!SAM4L) && (!SAMG55))
	sam_uart_opt_t uart_settings;
	uart_settings.ul_mck = sysclk_get_peripheral_hz();
  408bb6:	9701      	str	r7, [sp, #4]
	uart_settings.ul_baudrate = opt->baudrate;
  408bb8:	9102      	str	r1, [sp, #8]
	uart_settings.ul_mode = opt->paritytype;
#endif

	sam_usart_opt_t usart_settings;
	usart_settings.baudrate = opt->baudrate;
  408bba:	9104      	str	r1, [sp, #16]
	usart_settings.char_length = opt->charlength;
  408bbc:	9305      	str	r3, [sp, #20]
	usart_settings.parity_type = opt->paritytype;
	usart_settings.stop_bits= opt->stopbits;
  408bbe:	f8cd c01c 	str.w	ip, [sp, #28]
	usart_settings.channel_mode= US_MR_CHMODE_NORMAL;
  408bc2:	9208      	str	r2, [sp, #32]
  408bc4:	bf08      	it	eq
  408bc6:	2008      	moveq	r0, #8
		/* Configure UART */
		uart_init((Uart*)p_usart, &uart_settings);
	}
#else
# ifdef UART0
	if (UART0 == (Uart*)p_usart) {
  408bc8:	f000 80d1 	beq.w	408d6e <drv_uart_init+0x212>
		/* Configure UART */
		uart_init((Uart*)p_usart, &uart_settings);
	}
# endif
# ifdef UART1
	if (UART1 == (Uart*)p_usart) {
  408bcc:	4b8c      	ldr	r3, [pc, #560]	; (408e00 <drv_uart_init+0x2a4>)
  408bce:	429c      	cmp	r4, r3
  408bd0:	f000 80cc 	beq.w	408d6c <drv_uart_init+0x210>
		usart_enable_tx(p_usart);
		usart_enable_rx(p_usart);
	}
#else
# ifdef USART0
	if (USART0 == p_usart) {
  408bd4:	4b8b      	ldr	r3, [pc, #556]	; (408e04 <drv_uart_init+0x2a8>)
  408bd6:	429c      	cmp	r4, r3
  408bd8:	bf08      	it	eq
  408bda:	200e      	moveq	r0, #14
  408bdc:	f000 80b7 	beq.w	408d4e <drv_uart_init+0x1f2>
		usart_enable_tx(p_usart);
		usart_enable_rx(p_usart);
	}
# endif
# ifdef USART1
	if (USART1 == p_usart) {
  408be0:	4b89      	ldr	r3, [pc, #548]	; (408e08 <drv_uart_init+0x2ac>)
  408be2:	429c      	cmp	r4, r3
  408be4:	f000 80b2 	beq.w	408d4c <drv_uart_init+0x1f0>
	//initialize the UART hardware 
	usart_serial_init(uartConfig->p_usart, &uartConfig->uart_options);
	
	//setup interrupts for the UART
	/* Disable all the interrupts. */
	usart_disable_interrupt(uartConfig->p_usart, ALL_INTERRUPT_MASK);
  408be8:	4b8a      	ldr	r3, [pc, #552]	; (408e14 <drv_uart_init+0x2b8>)
  408bea:	4620      	mov	r0, r4
  408bec:	f04f 31ff 	mov.w	r1, #4294967295
  408bf0:	4798      	blx	r3
	/* Configure and enable interrupt of USART. */
	if(uartConfig->p_usart == UART0)
  408bf2:	682b      	ldr	r3, [r5, #0]
  408bf4:	4a81      	ldr	r2, [pc, #516]	; (408dfc <drv_uart_init+0x2a0>)
  408bf6:	4293      	cmp	r3, r2
  408bf8:	f000 80c1 	beq.w	408d7e <drv_uart_init+0x222>
		PIOA->PIO_ABCDSR[0] &= ~(PIO_PA9A_URXD0 | PIO_PA10A_UTXD0);
		PIOA->PIO_ABCDSR[1] &= ~(PIO_PA9A_URXD0 | PIO_PA10A_UTXD0);
		PIOA->PIO_PDR        =  (PIO_PA9A_URXD0 | PIO_PA10A_UTXD0);				
		NVIC_EnableIRQ(UART0_IRQn);
	}
	else if(uartConfig->p_usart == UART1)
  408bfc:	4a80      	ldr	r2, [pc, #512]	; (408e00 <drv_uart_init+0x2a4>)
  408bfe:	4293      	cmp	r3, r2
  408c00:	f000 80d3 	beq.w	408daa <drv_uart_init+0x24e>
		PIOB->PIO_ABCDSR[0] &= ~(PIO_PB2A_URXD1 | PIO_PB3A_UTXD1);
		PIOB->PIO_ABCDSR[1] &= ~(PIO_PB2A_URXD1 | PIO_PB3A_UTXD1);
		PIOB->PIO_PDR        =  (PIO_PB2A_URXD1 | PIO_PB3A_UTXD1);			
		NVIC_EnableIRQ(UART1_IRQn);
	}
	else if(uartConfig->p_usart == USART0)
  408c04:	4a7f      	ldr	r2, [pc, #508]	; (408e04 <drv_uart_init+0x2a8>)
  408c06:	4293      	cmp	r3, r2
  408c08:	f000 80e4 	beq.w	408dd4 <drv_uart_init+0x278>
		PIOA->PIO_CODR   =  (PIO_PA2);
		PIOA->PIO_OER    =  (PIO_PA2);
		PIOA->PIO_PER    =  (PIO_PA2);	
		NVIC_EnableIRQ(USART0_IRQn);
	}
	else if(uartConfig->p_usart == USART1)
  408c0c:	4a7e      	ldr	r2, [pc, #504]	; (408e08 <drv_uart_init+0x2ac>)
  408c0e:	4293      	cmp	r3, r2
  408c10:	d1b7      	bne.n	408b82 <drv_uart_init+0x26>
  408c12:	4b81      	ldr	r3, [pc, #516]	; (408e18 <drv_uart_init+0x2bc>)
  408c14:	200b      	movs	r0, #11
  408c16:	4798      	blx	r3
	{		
		/* Configure USART1 Pins (PA22 = TX, PA21 = RX). */
		sysclk_enable_peripheral_clock(ID_PIOA);
		PIOA->PIO_IDR        =  (PIO_PA21A_RXD1 | PIO_PA22A_TXD1);
  408c18:	4b80      	ldr	r3, [pc, #512]	; (408e1c <drv_uart_init+0x2c0>)
    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
  408c1a:	4881      	ldr	r0, [pc, #516]	; (408e20 <drv_uart_init+0x2c4>)
  408c1c:	f44f 01c0 	mov.w	r1, #6291456	; 0x600000
  408c20:	6459      	str	r1, [r3, #68]	; 0x44
		PIOA->PIO_PUDR       =  (PIO_PA21A_RXD1 |  PIO_PA22A_TXD1);
  408c22:	6619      	str	r1, [r3, #96]	; 0x60
		PIOA->PIO_ABCDSR[0] &= ~(PIO_PA21A_RXD1 | PIO_PA22A_TXD1);
  408c24:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  408c26:	f422 02c0 	bic.w	r2, r2, #6291456	; 0x600000
  408c2a:	671a      	str	r2, [r3, #112]	; 0x70
		PIOA->PIO_ABCDSR[1] &= ~(PIO_PA21A_RXD1 | PIO_PA22A_TXD1);
  408c2c:	6f5f      	ldr	r7, [r3, #116]	; 0x74
		PIOA->PIO_PDR        =  (PIO_PA21A_RXD1 | PIO_PA22A_TXD1);
	
		/* configure USART1 enable Pin (PA23) */
		PIOA->PIO_PUDR   =  (PIO_PA23);
  408c2e:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
		/* Configure USART1 Pins (PA22 = TX, PA21 = RX). */
		sysclk_enable_peripheral_clock(ID_PIOA);
		PIOA->PIO_IDR        =  (PIO_PA21A_RXD1 | PIO_PA22A_TXD1);
		PIOA->PIO_PUDR       =  (PIO_PA21A_RXD1 |  PIO_PA22A_TXD1);
		PIOA->PIO_ABCDSR[0] &= ~(PIO_PA21A_RXD1 | PIO_PA22A_TXD1);
		PIOA->PIO_ABCDSR[1] &= ~(PIO_PA21A_RXD1 | PIO_PA22A_TXD1);
  408c32:	f427 07c0 	bic.w	r7, r7, #6291456	; 0x600000
  408c36:	f44f 4400 	mov.w	r4, #32768	; 0x8000
  408c3a:	675f      	str	r7, [r3, #116]	; 0x74
		PIOA->PIO_PDR        =  (PIO_PA21A_RXD1 | PIO_PA22A_TXD1);
  408c3c:	6059      	str	r1, [r3, #4]
	
		/* configure USART1 enable Pin (PA23) */
		PIOA->PIO_PUDR   =  (PIO_PA23);
  408c3e:	661a      	str	r2, [r3, #96]	; 0x60
		PIOA->PIO_CODR   =  (PIO_PA23);
  408c40:	635a      	str	r2, [r3, #52]	; 0x34
		PIOA->PIO_OER    =  (PIO_PA23);
  408c42:	611a      	str	r2, [r3, #16]
		PIOA->PIO_PER    =  (PIO_PA23);		
  408c44:	601a      	str	r2, [r3, #0]
  408c46:	6004      	str	r4, [r0, #0]
	else
	{
		//ERROR! The config settings have an invalid UART pointer
		return STATUS_FAIL;
	}
	uartMemBuf[uartConfig->mem_index].isinit = true;
  408c48:	696b      	ldr	r3, [r5, #20]
	usart_enable_interrupt(uartConfig->p_usart, UART_IER_RXRDY | UART_SR_TXEMPTY); //enable RXRDY interrupt	
  408c4a:	4a76      	ldr	r2, [pc, #472]	; (408e24 <drv_uart_init+0x2c8>)
	
	//clear the buffer
	memset(uartMemBuf[uartConfig->mem_index].rx_fifo.data_buf, 0,FIFO_BUFFER_SIZE);
  408c4c:	4f76      	ldr	r7, [pc, #472]	; (408e28 <drv_uart_init+0x2cc>)
	else
	{
		//ERROR! The config settings have an invalid UART pointer
		return STATUS_FAIL;
	}
	uartMemBuf[uartConfig->mem_index].isinit = true;
  408c4e:	eb03 1343 	add.w	r3, r3, r3, lsl #5
  408c52:	eb06 1343 	add.w	r3, r6, r3, lsl #5
  408c56:	2101      	movs	r1, #1
  408c58:	f883 1206 	strb.w	r1, [r3, #518]	; 0x206
	usart_enable_interrupt(uartConfig->p_usart, UART_IER_RXRDY | UART_SR_TXEMPTY); //enable RXRDY interrupt	
  408c5c:	6828      	ldr	r0, [r5, #0]
  408c5e:	f240 2101 	movw	r1, #513	; 0x201
  408c62:	4790      	blx	r2
	
	//clear the buffer
	memset(uartMemBuf[uartConfig->mem_index].rx_fifo.data_buf, 0,FIFO_BUFFER_SIZE);
  408c64:	696b      	ldr	r3, [r5, #20]
  408c66:	eb03 1043 	add.w	r0, r3, r3, lsl #5
  408c6a:	eb06 1040 	add.w	r0, r6, r0, lsl #5
  408c6e:	2100      	movs	r1, #0
  408c70:	f44f 7200 	mov.w	r2, #512	; 0x200
  408c74:	47b8      	blx	r7
	uartMemBuf[uartConfig->mem_index].rx_fifo.i_first = 0;
  408c76:	696b      	ldr	r3, [r5, #20]
  408c78:	eb03 1343 	add.w	r3, r3, r3, lsl #5
  408c7c:	eb06 1343 	add.w	r3, r6, r3, lsl #5
  408c80:	2400      	movs	r4, #0
  408c82:	f8a3 4200 	strh.w	r4, [r3, #512]	; 0x200
	uartMemBuf[uartConfig->mem_index].rx_fifo.i_last = 0;
  408c86:	696b      	ldr	r3, [r5, #20]
  408c88:	eb03 1343 	add.w	r3, r3, r3, lsl #5
  408c8c:	eb06 1343 	add.w	r3, r6, r3, lsl #5
	uartMemBuf[uartConfig->mem_index].uart_rx_fifo_full_flag = 0;
	uartMemBuf[uartConfig->mem_index].uart_rx_fifo_not_empty_flag = 0;
	uartMemBuf[uartConfig->mem_index].uart_rx_fifo_ovf_flag = 0;
	uartMemBuf[uartConfig->mem_index].rx_fifo.num_bytes = 0;

	memset(uartMemBuf[uartConfig->mem_index].tx_fifo.data_buf, 0,FIFO_BUFFER_SIZE);
  408c90:	f44f 7200 	mov.w	r2, #512	; 0x200
	usart_enable_interrupt(uartConfig->p_usart, UART_IER_RXRDY | UART_SR_TXEMPTY); //enable RXRDY interrupt	
	
	//clear the buffer
	memset(uartMemBuf[uartConfig->mem_index].rx_fifo.data_buf, 0,FIFO_BUFFER_SIZE);
	uartMemBuf[uartConfig->mem_index].rx_fifo.i_first = 0;
	uartMemBuf[uartConfig->mem_index].rx_fifo.i_last = 0;
  408c94:	f8a3 4202 	strh.w	r4, [r3, #514]	; 0x202
	uartMemBuf[uartConfig->mem_index].uart_rx_fifo_full_flag = 0;
  408c98:	696b      	ldr	r3, [r5, #20]
  408c9a:	eb03 1343 	add.w	r3, r3, r3, lsl #5
  408c9e:	eb06 1343 	add.w	r3, r6, r3, lsl #5
	uartMemBuf[uartConfig->mem_index].uart_rx_fifo_not_empty_flag = 0;
	uartMemBuf[uartConfig->mem_index].uart_rx_fifo_ovf_flag = 0;
	uartMemBuf[uartConfig->mem_index].rx_fifo.num_bytes = 0;

	memset(uartMemBuf[uartConfig->mem_index].tx_fifo.data_buf, 0,FIFO_BUFFER_SIZE);
  408ca2:	4621      	mov	r1, r4
	
	//clear the buffer
	memset(uartMemBuf[uartConfig->mem_index].rx_fifo.data_buf, 0,FIFO_BUFFER_SIZE);
	uartMemBuf[uartConfig->mem_index].rx_fifo.i_first = 0;
	uartMemBuf[uartConfig->mem_index].rx_fifo.i_last = 0;
	uartMemBuf[uartConfig->mem_index].uart_rx_fifo_full_flag = 0;
  408ca4:	f883 4208 	strb.w	r4, [r3, #520]	; 0x208
	uartMemBuf[uartConfig->mem_index].uart_rx_fifo_not_empty_flag = 0;
  408ca8:	696b      	ldr	r3, [r5, #20]
  408caa:	eb03 1343 	add.w	r3, r3, r3, lsl #5
  408cae:	eb06 1343 	add.w	r3, r6, r3, lsl #5
  408cb2:	4413      	add	r3, r2
  408cb4:	71dc      	strb	r4, [r3, #7]
	uartMemBuf[uartConfig->mem_index].uart_rx_fifo_ovf_flag = 0;
  408cb6:	696b      	ldr	r3, [r5, #20]
  408cb8:	eb03 1343 	add.w	r3, r3, r3, lsl #5
  408cbc:	eb06 1343 	add.w	r3, r6, r3, lsl #5
  408cc0:	f883 4209 	strb.w	r4, [r3, #521]	; 0x209
	uartMemBuf[uartConfig->mem_index].rx_fifo.num_bytes = 0;
  408cc4:	696b      	ldr	r3, [r5, #20]
  408cc6:	eb03 1343 	add.w	r3, r3, r3, lsl #5
  408cca:	eb06 1343 	add.w	r3, r6, r3, lsl #5
  408cce:	4413      	add	r3, r2
  408cd0:	809c      	strh	r4, [r3, #4]

	memset(uartMemBuf[uartConfig->mem_index].tx_fifo.data_buf, 0,FIFO_BUFFER_SIZE);
  408cd2:	696b      	ldr	r3, [r5, #20]
  408cd4:	eb03 1343 	add.w	r3, r3, r3, lsl #5
  408cd8:	eb06 1043 	add.w	r0, r6, r3, lsl #5
  408cdc:	f500 7004 	add.w	r0, r0, #528	; 0x210
  408ce0:	47b8      	blx	r7
	uartMemBuf[uartConfig->mem_index].tx_fifo.i_first = 0;
  408ce2:	696b      	ldr	r3, [r5, #20]
  408ce4:	eb03 1343 	add.w	r3, r3, r3, lsl #5
  408ce8:	eb06 1343 	add.w	r3, r6, r3, lsl #5
	uartMemBuf[uartConfig->mem_index].uart_tx_fifo_full_flag = 0;
	uartMemBuf[uartConfig->mem_index].uart_tx_fifo_not_empty_flag = 0;
	uartMemBuf[uartConfig->mem_index].uart_tx_fifo_ovf_flag = 0;
	uartMemBuf[uartConfig->mem_index].tx_fifo.num_bytes = 0;
	
	return status; 
  408cec:	4620      	mov	r0, r4
	uartMemBuf[uartConfig->mem_index].uart_rx_fifo_not_empty_flag = 0;
	uartMemBuf[uartConfig->mem_index].uart_rx_fifo_ovf_flag = 0;
	uartMemBuf[uartConfig->mem_index].rx_fifo.num_bytes = 0;

	memset(uartMemBuf[uartConfig->mem_index].tx_fifo.data_buf, 0,FIFO_BUFFER_SIZE);
	uartMemBuf[uartConfig->mem_index].tx_fifo.i_first = 0;
  408cee:	f8a3 4410 	strh.w	r4, [r3, #1040]	; 0x410
	uartMemBuf[uartConfig->mem_index].tx_fifo.i_last = 0;
  408cf2:	696b      	ldr	r3, [r5, #20]
  408cf4:	eb03 1343 	add.w	r3, r3, r3, lsl #5
  408cf8:	eb06 1343 	add.w	r3, r6, r3, lsl #5
  408cfc:	f8a3 4412 	strh.w	r4, [r3, #1042]	; 0x412
	uartMemBuf[uartConfig->mem_index].uart_tx_fifo_full_flag = 0;
  408d00:	696b      	ldr	r3, [r5, #20]
  408d02:	eb03 1343 	add.w	r3, r3, r3, lsl #5
  408d06:	eb06 1343 	add.w	r3, r6, r3, lsl #5
  408d0a:	f883 4417 	strb.w	r4, [r3, #1047]	; 0x417
	uartMemBuf[uartConfig->mem_index].uart_tx_fifo_not_empty_flag = 0;
  408d0e:	696b      	ldr	r3, [r5, #20]
  408d10:	eb03 1343 	add.w	r3, r3, r3, lsl #5
  408d14:	eb06 1343 	add.w	r3, r6, r3, lsl #5
  408d18:	f883 4416 	strb.w	r4, [r3, #1046]	; 0x416
	uartMemBuf[uartConfig->mem_index].uart_tx_fifo_ovf_flag = 0;
  408d1c:	696b      	ldr	r3, [r5, #20]
  408d1e:	eb03 1343 	add.w	r3, r3, r3, lsl #5
  408d22:	eb06 1343 	add.w	r3, r6, r3, lsl #5
  408d26:	f883 4418 	strb.w	r4, [r3, #1048]	; 0x418
	uartMemBuf[uartConfig->mem_index].tx_fifo.num_bytes = 0;
  408d2a:	696b      	ldr	r3, [r5, #20]
  408d2c:	eb03 1343 	add.w	r3, r3, r3, lsl #5
  408d30:	eb06 1643 	add.w	r6, r6, r3, lsl #5
  408d34:	f8a6 4414 	strh.w	r4, [r6, #1044]	; 0x414
	
	return status; 
  408d38:	e724      	b.n	408b84 <drv_uart_init+0x28>
{
	status_t status = STATUS_PASS; 
	
	if(uartConfig->p_usart == UART0)
	{
		uartConfig->mem_index = 0;
  408d3a:	2300      	movs	r3, #0
  408d3c:	6143      	str	r3, [r0, #20]
  408d3e:	e725      	b.n	408b8c <drv_uart_init+0x30>
	}
	else if(uartConfig->p_usart == UART1)
	{	
		uartConfig->mem_index = 1;
  408d40:	2301      	movs	r3, #1
  408d42:	6143      	str	r3, [r0, #20]
  408d44:	e722      	b.n	408b8c <drv_uart_init+0x30>
	}
	else if(uartConfig->p_usart == USART0)
	{	
		uartConfig->mem_index = 2;
  408d46:	2302      	movs	r3, #2
  408d48:	6143      	str	r3, [r0, #20]
  408d4a:	e71f      	b.n	408b8c <drv_uart_init+0x30>
  408d4c:	200f      	movs	r0, #15
  408d4e:	4b32      	ldr	r3, [pc, #200]	; (408e18 <drv_uart_init+0x2bc>)
  408d50:	4798      	blx	r3
		flexcom_set_opmode(FLEXCOM1, FLEXCOM_USART);
#else
		sysclk_enable_peripheral_clock(ID_USART1);
#endif
		/* Configure USART */
		usart_init_rs232(p_usart, &usart_settings,
  408d52:	463a      	mov	r2, r7
  408d54:	a904      	add	r1, sp, #16
  408d56:	4620      	mov	r0, r4
  408d58:	4b34      	ldr	r3, [pc, #208]	; (408e2c <drv_uart_init+0x2d0>)
  408d5a:	4798      	blx	r3
		/* Configure USART */
		usart_init_rs232(p_usart, &usart_settings,
				sysclk_get_peripheral_bus_hz(p_usart));
#endif
		/* Enable the receiver and transmitter. */
		usart_enable_tx(p_usart);
  408d5c:	4620      	mov	r0, r4
  408d5e:	4b34      	ldr	r3, [pc, #208]	; (408e30 <drv_uart_init+0x2d4>)
  408d60:	4798      	blx	r3
		usart_enable_rx(p_usart);
  408d62:	4620      	mov	r0, r4
  408d64:	4b33      	ldr	r3, [pc, #204]	; (408e34 <drv_uart_init+0x2d8>)
  408d66:	4798      	blx	r3
  408d68:	682c      	ldr	r4, [r5, #0]
  408d6a:	e73d      	b.n	408be8 <drv_uart_init+0x8c>
  408d6c:	2009      	movs	r0, #9
  408d6e:	4b2a      	ldr	r3, [pc, #168]	; (408e18 <drv_uart_init+0x2bc>)
  408d70:	4798      	blx	r3
# endif
# ifdef UART1
	if (UART1 == (Uart*)p_usart) {
		sysclk_enable_peripheral_clock(ID_UART1);
		/* Configure UART */
		uart_init((Uart*)p_usart, &uart_settings);
  408d72:	4620      	mov	r0, r4
  408d74:	a901      	add	r1, sp, #4
  408d76:	4b30      	ldr	r3, [pc, #192]	; (408e38 <drv_uart_init+0x2dc>)
  408d78:	4798      	blx	r3
  408d7a:	682c      	ldr	r4, [r5, #0]
  408d7c:	e734      	b.n	408be8 <drv_uart_init+0x8c>
  408d7e:	4b26      	ldr	r3, [pc, #152]	; (408e18 <drv_uart_init+0x2bc>)
  408d80:	200b      	movs	r0, #11
  408d82:	4798      	blx	r3
	usart_disable_interrupt(uartConfig->p_usart, ALL_INTERRUPT_MASK);
	/* Configure and enable interrupt of USART. */
	if(uartConfig->p_usart == UART0)
	{
		sysclk_enable_peripheral_clock(ID_PIOA);
		PIOA->PIO_IDR        =  (PIO_PA9A_URXD0 | PIO_PA10A_UTXD0);
  408d84:	4b25      	ldr	r3, [pc, #148]	; (408e1c <drv_uart_init+0x2c0>)
  408d86:	4926      	ldr	r1, [pc, #152]	; (408e20 <drv_uart_init+0x2c4>)
  408d88:	f44f 62c0 	mov.w	r2, #1536	; 0x600
  408d8c:	645a      	str	r2, [r3, #68]	; 0x44
		PIOA->PIO_PUDR       =  (PIO_PA9A_URXD0 | PIO_PA10A_UTXD0);
  408d8e:	661a      	str	r2, [r3, #96]	; 0x60
		PIOA->PIO_ABCDSR[0] &= ~(PIO_PA9A_URXD0 | PIO_PA10A_UTXD0);
  408d90:	6f18      	ldr	r0, [r3, #112]	; 0x70
  408d92:	f420 60c0 	bic.w	r0, r0, #1536	; 0x600
  408d96:	6718      	str	r0, [r3, #112]	; 0x70
		PIOA->PIO_ABCDSR[1] &= ~(PIO_PA9A_URXD0 | PIO_PA10A_UTXD0);
  408d98:	6f5c      	ldr	r4, [r3, #116]	; 0x74
  408d9a:	f44f 7080 	mov.w	r0, #256	; 0x100
  408d9e:	f424 64c0 	bic.w	r4, r4, #1536	; 0x600
  408da2:	675c      	str	r4, [r3, #116]	; 0x74
		PIOA->PIO_PDR        =  (PIO_PA9A_URXD0 | PIO_PA10A_UTXD0);				
  408da4:	605a      	str	r2, [r3, #4]
  408da6:	6008      	str	r0, [r1, #0]
  408da8:	e74e      	b.n	408c48 <drv_uart_init+0xec>
  408daa:	4b1b      	ldr	r3, [pc, #108]	; (408e18 <drv_uart_init+0x2bc>)
  408dac:	200c      	movs	r0, #12
  408dae:	4798      	blx	r3
		NVIC_EnableIRQ(UART0_IRQn);
	}
	else if(uartConfig->p_usart == UART1)
	{
		sysclk_enable_peripheral_clock(ID_PIOB);
		PIOB->PIO_IDR        =  (PIO_PB2A_URXD1 | PIO_PB3A_UTXD1);
  408db0:	4b22      	ldr	r3, [pc, #136]	; (408e3c <drv_uart_init+0x2e0>)
  408db2:	491b      	ldr	r1, [pc, #108]	; (408e20 <drv_uart_init+0x2c4>)
  408db4:	220c      	movs	r2, #12
  408db6:	645a      	str	r2, [r3, #68]	; 0x44
		PIOB->PIO_PUDR       =  (PIO_PB2A_URXD1 | PIO_PB3A_UTXD1);
  408db8:	661a      	str	r2, [r3, #96]	; 0x60
		PIOB->PIO_ABCDSR[0] &= ~(PIO_PB2A_URXD1 | PIO_PB3A_UTXD1);
  408dba:	6f18      	ldr	r0, [r3, #112]	; 0x70
  408dbc:	f020 000c 	bic.w	r0, r0, #12
  408dc0:	6718      	str	r0, [r3, #112]	; 0x70
		PIOB->PIO_ABCDSR[1] &= ~(PIO_PB2A_URXD1 | PIO_PB3A_UTXD1);
  408dc2:	6f5c      	ldr	r4, [r3, #116]	; 0x74
  408dc4:	f44f 7000 	mov.w	r0, #512	; 0x200
  408dc8:	f024 040c 	bic.w	r4, r4, #12
  408dcc:	675c      	str	r4, [r3, #116]	; 0x74
		PIOB->PIO_PDR        =  (PIO_PB2A_URXD1 | PIO_PB3A_UTXD1);			
  408dce:	605a      	str	r2, [r3, #4]
  408dd0:	6008      	str	r0, [r1, #0]
  408dd2:	e739      	b.n	408c48 <drv_uart_init+0xec>
  408dd4:	4b10      	ldr	r3, [pc, #64]	; (408e18 <drv_uart_init+0x2bc>)
  408dd6:	200b      	movs	r0, #11
  408dd8:	4798      	blx	r3
	}
	else if(uartConfig->p_usart == USART0)
	{
		/* Configure USART0 Pins (PA6 = TX, PA5 = RX). */
		sysclk_enable_peripheral_clock(ID_PIOA);
		PIOA->PIO_IDR        =  (PIO_PA5A_RXD0 | PIO_PA6A_TXD0);
  408dda:	4b10      	ldr	r3, [pc, #64]	; (408e1c <drv_uart_init+0x2c0>)
  408ddc:	4810      	ldr	r0, [pc, #64]	; (408e20 <drv_uart_init+0x2c4>)
  408dde:	2160      	movs	r1, #96	; 0x60
  408de0:	6459      	str	r1, [r3, #68]	; 0x44
		PIOA->PIO_PUDR       =  (PIO_PA5A_RXD0 | PIO_PA6A_TXD0);
  408de2:	6619      	str	r1, [r3, #96]	; 0x60
		PIOA->PIO_ABCDSR[0] &= ~(PIO_PA5A_RXD0 | PIO_PA6A_TXD0 | PIO_PA2B_SCK0);
  408de4:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  408de6:	f022 0264 	bic.w	r2, r2, #100	; 0x64
  408dea:	671a      	str	r2, [r3, #112]	; 0x70
		PIOA->PIO_ABCDSR[1] &= ~(PIO_PA5A_RXD0 | PIO_PA6A_TXD0 | PIO_PA2B_SCK0);
  408dec:	6f5f      	ldr	r7, [r3, #116]	; 0x74
		PIOA->PIO_PDR        =  (PIO_PA5A_RXD0 | PIO_PA6A_TXD0);
	
		/* configure USART0 enable Pin (PA2) Peripheral-B */
		PIOA->PIO_PUDR   =  (PIO_PA2);
  408dee:	2204      	movs	r2, #4
		/* Configure USART0 Pins (PA6 = TX, PA5 = RX). */
		sysclk_enable_peripheral_clock(ID_PIOA);
		PIOA->PIO_IDR        =  (PIO_PA5A_RXD0 | PIO_PA6A_TXD0);
		PIOA->PIO_PUDR       =  (PIO_PA5A_RXD0 | PIO_PA6A_TXD0);
		PIOA->PIO_ABCDSR[0] &= ~(PIO_PA5A_RXD0 | PIO_PA6A_TXD0 | PIO_PA2B_SCK0);
		PIOA->PIO_ABCDSR[1] &= ~(PIO_PA5A_RXD0 | PIO_PA6A_TXD0 | PIO_PA2B_SCK0);
  408df0:	f027 0764 	bic.w	r7, r7, #100	; 0x64
  408df4:	f44f 4480 	mov.w	r4, #16384	; 0x4000
  408df8:	e71f      	b.n	408c3a <drv_uart_init+0xde>
  408dfa:	bf00      	nop
  408dfc:	400e0600 	.word	0x400e0600
  408e00:	400e0800 	.word	0x400e0800
  408e04:	40024000 	.word	0x40024000
  408e08:	40028000 	.word	0x40028000
  408e0c:	20003e2c 	.word	0x20003e2c
  408e10:	07270e00 	.word	0x07270e00
  408e14:	00403e75 	.word	0x00403e75
  408e18:	0040b231 	.word	0x0040b231
  408e1c:	400e0e00 	.word	0x400e0e00
  408e20:	e000e100 	.word	0xe000e100
  408e24:	00403e71 	.word	0x00403e71
  408e28:	0040c31d 	.word	0x0040c31d
  408e2c:	00403de9 	.word	0x00403de9
  408e30:	00403e61 	.word	0x00403e61
  408e34:	00403e69 	.word	0x00403e69
  408e38:	00403d25 	.word	0x00403d25
  408e3c:	400e1000 	.word	0x400e1000

00408e40 <drv_uart_putChar>:
 * the character
 * @param c, the character that will be sent through the uart. 
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/	
status_t drv_uart_putChar(drv_uart_config_t* uartConfig, char c)
{
  408e40:	b538      	push	{r3, r4, r5, lr}
  408e42:	4604      	mov	r4, r0
	status_t status = STATUS_PASS;
	//disable the interrupts so we don't fuck up the pointers	
	usart_disable_interrupt(uartConfig->p_usart, UART_IER_TXEMPTY);	
  408e44:	4b1f      	ldr	r3, [pc, #124]	; (408ec4 <drv_uart_putChar+0x84>)
  408e46:	6800      	ldr	r0, [r0, #0]
 * the character
 * @param c, the character that will be sent through the uart. 
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/	
status_t drv_uart_putChar(drv_uart_config_t* uartConfig, char c)
{
  408e48:	460d      	mov	r5, r1
	status_t status = STATUS_PASS;
	//disable the interrupts so we don't fuck up the pointers	
	usart_disable_interrupt(uartConfig->p_usart, UART_IER_TXEMPTY);	
  408e4a:	f44f 7100 	mov.w	r1, #512	; 0x200
  408e4e:	4798      	blx	r3
	uint32_t val = 0;
	drv_uart_memory_buf_t* memBuf = &uartMemBuf[uartConfig->mem_index]; 
  408e50:	6962      	ldr	r2, [r4, #20]
  408e52:	481d      	ldr	r0, [pc, #116]	; (408ec8 <drv_uart_putChar+0x88>)
  408e54:	eb02 1242 	add.w	r2, r2, r2, lsl #5
  408e58:	eb00 1342 	add.w	r3, r0, r2, lsl #5
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
  408e5c:	f8b3 2414 	ldrh.w	r2, [r3, #1044]	; 0x414
  408e60:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
  408e64:	d021      	beq.n	408eaa <drv_uart_putChar+0x6a>
	{
		memBuf->uart_tx_fifo_ovf_flag = 1;                     // set the overflow flag
		memBuf->uart_tx_fifo_dropped_bytes++; //our data stream will be out of sync now...	
	}
	else if(memBuf->tx_fifo.num_bytes < FIFO_BUFFER_SIZE)  // if there's room in the sw buffer
  408e66:	d20e      	bcs.n	408e86 <drv_uart_putChar+0x46>
	{
		memBuf->tx_fifo.data_buf[memBuf->tx_fifo.i_last] = c;
  408e68:	f8b3 1412 	ldrh.w	r1, [r3, #1042]	; 0x412
		memBuf->tx_fifo.i_last++;                              // increment the index of the most recently added element
		memBuf->tx_fifo.num_bytes++;                           // increment the bytes counter
  408e6c:	3201      	adds	r2, #1
		memBuf->uart_tx_fifo_ovf_flag = 1;                     // set the overflow flag
		memBuf->uart_tx_fifo_dropped_bytes++; //our data stream will be out of sync now...	
	}
	else if(memBuf->tx_fifo.num_bytes < FIFO_BUFFER_SIZE)  // if there's room in the sw buffer
	{
		memBuf->tx_fifo.data_buf[memBuf->tx_fifo.i_last] = c;
  408e6e:	1858      	adds	r0, r3, r1
		memBuf->tx_fifo.i_last++;                              // increment the index of the most recently added element
		memBuf->tx_fifo.num_bytes++;                           // increment the bytes counter
  408e70:	b292      	uxth	r2, r2
		memBuf->uart_tx_fifo_dropped_bytes++; //our data stream will be out of sync now...	
	}
	else if(memBuf->tx_fifo.num_bytes < FIFO_BUFFER_SIZE)  // if there's room in the sw buffer
	{
		memBuf->tx_fifo.data_buf[memBuf->tx_fifo.i_last] = c;
		memBuf->tx_fifo.i_last++;                              // increment the index of the most recently added element
  408e72:	3101      	adds	r1, #1
		//if(uartConfig->p_usart == UART1)
		//{
			//usart_putchar(UART0, c);
		//}
	}
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE)
  408e74:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
		memBuf->uart_tx_fifo_ovf_flag = 1;                     // set the overflow flag
		memBuf->uart_tx_fifo_dropped_bytes++; //our data stream will be out of sync now...	
	}
	else if(memBuf->tx_fifo.num_bytes < FIFO_BUFFER_SIZE)  // if there's room in the sw buffer
	{
		memBuf->tx_fifo.data_buf[memBuf->tx_fifo.i_last] = c;
  408e78:	f880 5210 	strb.w	r5, [r0, #528]	; 0x210
		memBuf->tx_fifo.i_last++;                              // increment the index of the most recently added element
		memBuf->tx_fifo.num_bytes++;                           // increment the bytes counter
  408e7c:	f8a3 2414 	strh.w	r2, [r3, #1044]	; 0x414
		memBuf->uart_tx_fifo_dropped_bytes++; //our data stream will be out of sync now...	
	}
	else if(memBuf->tx_fifo.num_bytes < FIFO_BUFFER_SIZE)  // if there's room in the sw buffer
	{
		memBuf->tx_fifo.data_buf[memBuf->tx_fifo.i_last] = c;
		memBuf->tx_fifo.i_last++;                              // increment the index of the most recently added element
  408e80:	f8a3 1412 	strh.w	r1, [r3, #1042]	; 0x412
		//if(uartConfig->p_usart == UART1)
		//{
			//usart_putchar(UART0, c);
		//}
	}
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE)
  408e84:	d019      	beq.n	408eba <drv_uart_putChar+0x7a>
	{      // if sw buffer just filled up
		memBuf->uart_tx_fifo_full_flag = 1;                    // set the tx FIFO full flag
	}
	if(memBuf->tx_fifo.i_last == FIFO_BUFFER_SIZE)
  408e86:	f8b3 2412 	ldrh.w	r2, [r3, #1042]	; 0x412
  408e8a:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
	{         // if the index has reached the end of the buffer,
		memBuf->tx_fifo.i_last = 0;                            // roll over the index counter
  408e8e:	bf04      	itt	eq
  408e90:	2200      	moveq	r2, #0
  408e92:	f8a3 2412 	strheq.w	r2, [r3, #1042]	; 0x412
	}
	memBuf->uart_tx_fifo_not_empty_flag = 1;                 // set tx-data ready flag	
  408e96:	2201      	movs	r2, #1
  408e98:	f883 2416 	strb.w	r2, [r3, #1046]	; 0x416
	//re-enable the interrupts
	usart_enable_interrupt(uartConfig->p_usart, UART_IER_TXEMPTY);		
  408e9c:	6820      	ldr	r0, [r4, #0]
  408e9e:	4b0b      	ldr	r3, [pc, #44]	; (408ecc <drv_uart_putChar+0x8c>)
  408ea0:	f44f 7100 	mov.w	r1, #512	; 0x200
  408ea4:	4798      	blx	r3
	return status;	
}
  408ea6:	2000      	movs	r0, #0
  408ea8:	bd38      	pop	{r3, r4, r5, pc}
	uint32_t val = 0;
	drv_uart_memory_buf_t* memBuf = &uartMemBuf[uartConfig->mem_index]; 
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
	{
		memBuf->uart_tx_fifo_ovf_flag = 1;                     // set the overflow flag
		memBuf->uart_tx_fifo_dropped_bytes++; //our data stream will be out of sync now...	
  408eaa:	f8d3 241c 	ldr.w	r2, [r3, #1052]	; 0x41c
	usart_disable_interrupt(uartConfig->p_usart, UART_IER_TXEMPTY);	
	uint32_t val = 0;
	drv_uart_memory_buf_t* memBuf = &uartMemBuf[uartConfig->mem_index]; 
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
	{
		memBuf->uart_tx_fifo_ovf_flag = 1;                     // set the overflow flag
  408eae:	2101      	movs	r1, #1
		memBuf->uart_tx_fifo_dropped_bytes++; //our data stream will be out of sync now...	
  408eb0:	440a      	add	r2, r1
  408eb2:	f8c3 241c 	str.w	r2, [r3, #1052]	; 0x41c
	usart_disable_interrupt(uartConfig->p_usart, UART_IER_TXEMPTY);	
	uint32_t val = 0;
	drv_uart_memory_buf_t* memBuf = &uartMemBuf[uartConfig->mem_index]; 
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
	{
		memBuf->uart_tx_fifo_ovf_flag = 1;                     // set the overflow flag
  408eb6:	f883 1418 	strb.w	r1, [r3, #1048]	; 0x418
			//usart_putchar(UART0, c);
		//}
	}
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE)
	{      // if sw buffer just filled up
		memBuf->uart_tx_fifo_full_flag = 1;                    // set the tx FIFO full flag
  408eba:	2201      	movs	r2, #1
  408ebc:	f883 2417 	strb.w	r2, [r3, #1047]	; 0x417
  408ec0:	e7e1      	b.n	408e86 <drv_uart_putChar+0x46>
  408ec2:	bf00      	nop
  408ec4:	00403e75 	.word	0x00403e75
  408ec8:	20003e2c 	.word	0x20003e2c
  408ecc:	00403e71 	.word	0x00403e71

00408ed0 <drv_uart_deInit>:
 * @brief puts the uart driver in a deinitialized state
 * @param uartConfig, the configuration structure for the uart, 
 * @return STATUS_PASS if successful,	STATUS_FAIL if there is an error
 ***********************************************************************************************/	
status_t drv_uart_deInit(drv_uart_config_t* uartConfig)
{
  408ed0:	b510      	push	{r4, lr}
  408ed2:	4604      	mov	r4, r0
	status_t status = STATUS_PASS;
	/* Disable all the interrupts. */
	usart_disable_interrupt(uartConfig->p_usart, ALL_INTERRUPT_MASK);
  408ed4:	f04f 31ff 	mov.w	r1, #4294967295
  408ed8:	6800      	ldr	r0, [r0, #0]
  408eda:	4b06      	ldr	r3, [pc, #24]	; (408ef4 <drv_uart_deInit+0x24>)
  408edc:	4798      	blx	r3
	uartMemBuf[uartConfig->mem_index].isinit = false;	
  408ede:	6963      	ldr	r3, [r4, #20]
  408ee0:	4a05      	ldr	r2, [pc, #20]	; (408ef8 <drv_uart_deInit+0x28>)
  408ee2:	eb03 1343 	add.w	r3, r3, r3, lsl #5
  408ee6:	eb02 1343 	add.w	r3, r2, r3, lsl #5
  408eea:	2000      	movs	r0, #0
  408eec:	f883 0206 	strb.w	r0, [r3, #518]	; 0x206
	return status;	
}
  408ef0:	bd10      	pop	{r4, pc}
  408ef2:	bf00      	nop
  408ef4:	00403e75 	.word	0x00403e75
  408ef8:	20003e2c 	.word	0x20003e2c

00408efc <drv_uart_isInit>:
 * @param uartConfig, the configuration structure for the uart
 * @return STATUS_PASS if the driver is initialized,	STATUS_FAIL if not
 ***********************************************************************************************/	
status_t drv_uart_isInit(drv_uart_config_t* uartConfig)
{
	if(uartMemBuf[uartConfig->mem_index].isinit)
  408efc:	6943      	ldr	r3, [r0, #20]
  408efe:	4a06      	ldr	r2, [pc, #24]	; (408f18 <drv_uart_isInit+0x1c>)
  408f00:	eb03 1343 	add.w	r3, r3, r3, lsl #5
  408f04:	eb02 1343 	add.w	r3, r2, r3, lsl #5
  408f08:	f893 0206 	ldrb.w	r0, [r3, #518]	; 0x206
	}
	else
	{
		return STATUS_FAIL; 
	}
}
  408f0c:	f1d0 0001 	rsbs	r0, r0, #1
  408f10:	bf38      	it	cc
  408f12:	2000      	movcc	r0, #0
  408f14:	4770      	bx	lr
  408f16:	bf00      	nop
  408f18:	20003e2c 	.word	0x20003e2c

00408f1c <drv_uart_getDroppedBytes>:
uint32_t drv_uart_getDroppedBytes(drv_uart_config_t* uartConfig)
{
	return uartMemBuf[uartConfig->mem_index].uart_rx_fifo_dropped_bytes;
  408f1c:	6943      	ldr	r3, [r0, #20]
  408f1e:	4a04      	ldr	r2, [pc, #16]	; (408f30 <drv_uart_getDroppedBytes+0x14>)
  408f20:	eb03 1343 	add.w	r3, r3, r3, lsl #5
  408f24:	eb02 1343 	add.w	r3, r2, r3, lsl #5
  408f28:	f8d3 020c 	ldr.w	r0, [r3, #524]	; 0x20c
}
  408f2c:	4770      	bx	lr
  408f2e:	bf00      	nop
  408f30:	20003e2c 	.word	0x20003e2c

00408f34 <drv_uart_getline>:
 * @param str the pointer to the buffer where the string will be stored
 * @param strSize the size of the buffer that can be used to store the string
 * @return STATUS_PASS if a string is returned,	STATUS_FAIL if the string found is larger than the buffer. 
 ***********************************************************************************************/	
status_t drv_uart_getline(drv_uart_config_t* uartConfig, char* str, size_t strSize)
{
  408f34:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  408f38:	4d1c      	ldr	r5, [pc, #112]	; (408fac <drv_uart_getline+0x78>)
  408f3a:	f8df 9078 	ldr.w	r9, [pc, #120]	; 408fb4 <drv_uart_getline+0x80>
			//vTaskDelay(1);
		}
		else
		{
			//taskYIELD(); 
			vTaskDelay(1); //let the other processes do stuff	
  408f3e:	4e1c      	ldr	r6, [pc, #112]	; (408fb0 <drv_uart_getline+0x7c>)
 * @param str the pointer to the buffer where the string will be stored
 * @param strSize the size of the buffer that can be used to store the string
 * @return STATUS_PASS if a string is returned,	STATUS_FAIL if the string found is larger than the buffer. 
 ***********************************************************************************************/	
status_t drv_uart_getline(drv_uart_config_t* uartConfig, char* str, size_t strSize)
{
  408f40:	b083      	sub	sp, #12
  408f42:	4604      	mov	r4, r0
  408f44:	4688      	mov	r8, r1
  408f46:	4617      	mov	r7, r2
	status_t result = STATUS_PASS;
	char val;
	int pointer = 0;
  408f48:	f04f 0a00 	mov.w	sl, #0
  408f4c:	e001      	b.n	408f52 <drv_uart_getline+0x1e>
			//vTaskDelay(1);
		}
		else
		{
			//taskYIELD(); 
			vTaskDelay(1); //let the other processes do stuff	
  408f4e:	2001      	movs	r0, #1
  408f50:	47b0      	blx	r6
 ***********************************************************************************************/	
status_t drv_uart_getChar(drv_uart_config_t* uartConfig, char* c)
{
	status_t status = STATUS_PASS;
	
	if(uartMemBuf[uartConfig->mem_index].uart_rx_fifo_not_empty_flag == 1) //check if the buffer has information in it
  408f52:	6963      	ldr	r3, [r4, #20]
  408f54:	eb03 1343 	add.w	r3, r3, r3, lsl #5
  408f58:	eb05 1343 	add.w	r3, r5, r3, lsl #5
  408f5c:	f893 b207 	ldrb.w	fp, [r3, #519]	; 0x207
  408f60:	fa5f fb8b 	uxtb.w	fp, fp
  408f64:	f1bb 0f01 	cmp.w	fp, #1
  408f68:	d1f1      	bne.n	408f4e <drv_uart_getline+0x1a>
  408f6a:	4620      	mov	r0, r4
  408f6c:	f10d 0107 	add.w	r1, sp, #7
  408f70:	47c8      	blx	r9
	char val;
	int pointer = 0;
	while(1) //TODO add timeout
	{
		result = drv_uart_getChar(uartConfig,&val);
		if(result != STATUS_EOF && val != NULL)
  408f72:	2802      	cmp	r0, #2
		{
			if(pointer < strSize)
  408f74:	4652      	mov	r2, sl
	char val;
	int pointer = 0;
	while(1) //TODO add timeout
	{
		result = drv_uart_getChar(uartConfig,&val);
		if(result != STATUS_EOF && val != NULL)
  408f76:	d0ea      	beq.n	408f4e <drv_uart_getline+0x1a>
  408f78:	f89d 3007 	ldrb.w	r3, [sp, #7]
  408f7c:	2b00      	cmp	r3, #0
  408f7e:	d0e6      	beq.n	408f4e <drv_uart_getline+0x1a>
		{
			if(pointer < strSize)
  408f80:	45ba      	cmp	sl, r7
			{
				str[pointer++] = val; //add the result;
  408f82:	f10a 0a01 	add.w	sl, sl, #1
	while(1) //TODO add timeout
	{
		result = drv_uart_getChar(uartConfig,&val);
		if(result != STATUS_EOF && val != NULL)
		{
			if(pointer < strSize)
  408f86:	d209      	bcs.n	408f9c <drv_uart_getline+0x68>
			{
				str[pointer++] = val; //add the result;
				if(val == '\n')
  408f88:	2b0a      	cmp	r3, #10
		result = drv_uart_getChar(uartConfig,&val);
		if(result != STATUS_EOF && val != NULL)
		{
			if(pointer < strSize)
			{
				str[pointer++] = val; //add the result;
  408f8a:	f808 3002 	strb.w	r3, [r8, r2]
				if(val == '\n')
  408f8e:	d1e0      	bne.n	408f52 <drv_uart_getline+0x1e>
				{
					str[pointer] = NULL; //terminate the string
  408f90:	2000      	movs	r0, #0
  408f92:	f808 000a 	strb.w	r0, [r8, sl]
			vTaskDelay(1); //let the other processes do stuff	
		}
		
	}
	return result; 
}
  408f96:	b003      	add	sp, #12
  408f98:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			}
			else
			{
				//we overwrote the buffer
				result = STATUS_FAIL;
				str[strSize - 1] = NULL; //terminate what's in the buffer.
  408f9c:	4447      	add	r7, r8
  408f9e:	2300      	movs	r3, #0
				}
			}
			else
			{
				//we overwrote the buffer
				result = STATUS_FAIL;
  408fa0:	4658      	mov	r0, fp
				str[strSize - 1] = NULL; //terminate what's in the buffer.
  408fa2:	f807 3c01 	strb.w	r3, [r7, #-1]
			vTaskDelay(1); //let the other processes do stuff	
		}
		
	}
	return result; 
}
  408fa6:	b003      	add	sp, #12
  408fa8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  408fac:	20003e2c 	.word	0x20003e2c
  408fb0:	004072ed 	.word	0x004072ed
  408fb4:	00408ae1 	.word	0x00408ae1

00408fb8 <drv_uart_getlineTimed>:
 * @param strSize the size of the buffer that can be used to store the string
 * @param maxTime the maximum time in ticks the function should wait for the response. 
 * @return STATUS_PASS if a string is returned,	STATUS_FAIL if the string found is larger than the buffer, or timed out
 ***********************************************************************************************/	
status_t drv_uart_getlineTimed(drv_uart_config_t* uartConfig, char* str, size_t strSize, uint32_t maxTime)
{
  408fb8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	status_t result = STATUS_PASS;
	char val;
	int pointer = 0;
	uint32_t startTime = sgSysTickCount; 
  408fbc:	4d1f      	ldr	r5, [pc, #124]	; (40903c <drv_uart_getlineTimed+0x84>)
  408fbe:	4e20      	ldr	r6, [pc, #128]	; (409040 <drv_uart_getlineTimed+0x88>)
  408fc0:	682f      	ldr	r7, [r5, #0]
 * @param strSize the size of the buffer that can be used to store the string
 * @param maxTime the maximum time in ticks the function should wait for the response. 
 * @return STATUS_PASS if a string is returned,	STATUS_FAIL if the string found is larger than the buffer, or timed out
 ***********************************************************************************************/	
status_t drv_uart_getlineTimed(drv_uart_config_t* uartConfig, char* str, size_t strSize, uint32_t maxTime)
{
  408fc2:	b083      	sub	sp, #12
  408fc4:	4604      	mov	r4, r0
  408fc6:	4689      	mov	r9, r1
  408fc8:	4690      	mov	r8, r2
			}
		}
		else
		{
			//check if we've timed out yet... 
			if(sgSysTickCount > (startTime + maxTime))
  408fca:	441f      	add	r7, r3
 ***********************************************************************************************/	
status_t drv_uart_getlineTimed(drv_uart_config_t* uartConfig, char* str, size_t strSize, uint32_t maxTime)
{
	status_t result = STATUS_PASS;
	char val;
	int pointer = 0;
  408fcc:	f04f 0a00 	mov.w	sl, #0
 ***********************************************************************************************/	
status_t drv_uart_getChar(drv_uart_config_t* uartConfig, char* c)
{
	status_t status = STATUS_PASS;
	
	if(uartMemBuf[uartConfig->mem_index].uart_rx_fifo_not_empty_flag == 1) //check if the buffer has information in it
  408fd0:	6963      	ldr	r3, [r4, #20]
  408fd2:	eb03 1343 	add.w	r3, r3, r3, lsl #5
  408fd6:	eb06 1343 	add.w	r3, r6, r3, lsl #5
  408fda:	f893 c207 	ldrb.w	ip, [r3, #519]	; 0x207
  408fde:	fa5f fb8c 	uxtb.w	fp, ip
  408fe2:	f1bb 0f01 	cmp.w	fp, #1
  408fe6:	d007      	beq.n	408ff8 <drv_uart_getlineTimed+0x40>
			}
		}
		else
		{
			//check if we've timed out yet... 
			if(sgSysTickCount > (startTime + maxTime))
  408fe8:	682b      	ldr	r3, [r5, #0]
  408fea:	429f      	cmp	r7, r3
			{
				//return fail, we've timed out. 
				result = STATUS_FAIL; 
  408fec:	f04f 0001 	mov.w	r0, #1
			}
		}
		else
		{
			//check if we've timed out yet... 
			if(sgSysTickCount > (startTime + maxTime))
  408ff0:	d319      	bcc.n	409026 <drv_uart_getlineTimed+0x6e>
			{
				//return fail, we've timed out. 
				result = STATUS_FAIL; 
				break;
			}
			vTaskDelay(1); //let the other processes do stuff	
  408ff2:	4b14      	ldr	r3, [pc, #80]	; (409044 <drv_uart_getlineTimed+0x8c>)
  408ff4:	4798      	blx	r3
  408ff6:	e7eb      	b.n	408fd0 <drv_uart_getlineTimed+0x18>
  408ff8:	f10d 0107 	add.w	r1, sp, #7
  408ffc:	4620      	mov	r0, r4
  408ffe:	4b12      	ldr	r3, [pc, #72]	; (409048 <drv_uart_getlineTimed+0x90>)
  409000:	4798      	blx	r3
	int pointer = 0;
	uint32_t startTime = sgSysTickCount; 
	while(1) //TODO add timeout
	{
		result = drv_uart_getChar(uartConfig,&val);
		if(result != STATUS_EOF && val != NULL)
  409002:	2802      	cmp	r0, #2
		{
			if(pointer < strSize)
  409004:	4651      	mov	r1, sl
	int pointer = 0;
	uint32_t startTime = sgSysTickCount; 
	while(1) //TODO add timeout
	{
		result = drv_uart_getChar(uartConfig,&val);
		if(result != STATUS_EOF && val != NULL)
  409006:	d0ef      	beq.n	408fe8 <drv_uart_getlineTimed+0x30>
  409008:	f89d 3007 	ldrb.w	r3, [sp, #7]
  40900c:	2b00      	cmp	r3, #0
  40900e:	d0eb      	beq.n	408fe8 <drv_uart_getlineTimed+0x30>
		{
			if(pointer < strSize)
  409010:	45c2      	cmp	sl, r8
			{
				str[pointer++] = val; //add the result;
  409012:	f10a 0a01 	add.w	sl, sl, #1
	while(1) //TODO add timeout
	{
		result = drv_uart_getChar(uartConfig,&val);
		if(result != STATUS_EOF && val != NULL)
		{
			if(pointer < strSize)
  409016:	d209      	bcs.n	40902c <drv_uart_getlineTimed+0x74>
			{
				str[pointer++] = val; //add the result;
				if(val == '\n')
  409018:	2b0a      	cmp	r3, #10
		result = drv_uart_getChar(uartConfig,&val);
		if(result != STATUS_EOF && val != NULL)
		{
			if(pointer < strSize)
			{
				str[pointer++] = val; //add the result;
  40901a:	f809 3001 	strb.w	r3, [r9, r1]
				if(val == '\n')
  40901e:	d1d7      	bne.n	408fd0 <drv_uart_getlineTimed+0x18>
				{
					str[pointer] = NULL; //terminate the string
  409020:	2000      	movs	r0, #0
  409022:	f809 000a 	strb.w	r0, [r9, sl]
			vTaskDelay(1); //let the other processes do stuff	
		}
		
	}
	return result; 
}
  409026:	b003      	add	sp, #12
  409028:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			}
			else
			{
				//we overwrote the buffer
				result = STATUS_FAIL;
				str[strSize - 1] = NULL; //terminate what's in the buffer.
  40902c:	44c8      	add	r8, r9
  40902e:	2300      	movs	r3, #0
				}
			}
			else
			{
				//we overwrote the buffer
				result = STATUS_FAIL;
  409030:	4658      	mov	r0, fp
				str[strSize - 1] = NULL; //terminate what's in the buffer.
  409032:	f808 3c01 	strb.w	r3, [r8, #-1]
			vTaskDelay(1); //let the other processes do stuff	
		}
		
	}
	return result; 
}
  409036:	b003      	add	sp, #12
  409038:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40903c:	20003970 	.word	0x20003970
  409040:	20003e2c 	.word	0x20003e2c
  409044:	004072ed 	.word	0x004072ed
  409048:	00408ae1 	.word	0x00408ae1

0040904c <drv_uart_putString>:
	*strLength = pointer;
	return result; 
}

void drv_uart_putString(drv_uart_config_t* uartConfig, char* str)
{
  40904c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	int i=0;
	int size = strlen(str);
  409050:	4b09      	ldr	r3, [pc, #36]	; (409078 <drv_uart_putString+0x2c>)
	*strLength = pointer;
	return result; 
}

void drv_uart_putString(drv_uart_config_t* uartConfig, char* str)
{
  409052:	4606      	mov	r6, r0
	int i=0;
	int size = strlen(str);
  409054:	4608      	mov	r0, r1
	*strLength = pointer;
	return result; 
}

void drv_uart_putString(drv_uart_config_t* uartConfig, char* str)
{
  409056:	460d      	mov	r5, r1
	int i=0;
	int size = strlen(str);
  409058:	4798      	blx	r3

	for (i=0;i<size;)
  40905a:	1e07      	subs	r7, r0, #0
  40905c:	dd09      	ble.n	409072 <drv_uart_putString+0x26>
  40905e:	f8df 801c 	ldr.w	r8, [pc, #28]	; 40907c <drv_uart_putString+0x30>
  409062:	2400      	movs	r4, #0
	{
		if(drv_uart_putChar(uartConfig, str[i]) == STATUS_PASS)
  409064:	4630      	mov	r0, r6
  409066:	5d29      	ldrb	r1, [r5, r4]
  409068:	47c0      	blx	r8
  40906a:	b900      	cbnz	r0, 40906e <drv_uart_putString+0x22>
		{
			i++; //increment only if PASS is returned (it means the data has been sent)
  40906c:	3401      	adds	r4, #1
void drv_uart_putString(drv_uart_config_t* uartConfig, char* str)
{
	int i=0;
	int size = strlen(str);

	for (i=0;i<size;)
  40906e:	42a7      	cmp	r7, r4
  409070:	dcf8      	bgt.n	409064 <drv_uart_putString+0x18>
  409072:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  409076:	bf00      	nop
  409078:	0040c9a5 	.word	0x0040c9a5
  40907c:	00408e41 	.word	0x00408e41

00409080 <drv_uart_putData>:
		}		
	}
}

void drv_uart_putData(drv_uart_config_t* uartConfig, char* str, size_t length)
{
  409080:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	int i=0;
	for (i=0;i<length;)
	{
		if(drv_uart_putChar(uartConfig, str[i]) == STATUS_PASS)
  409084:	4f09      	ldr	r7, [pc, #36]	; (4090ac <drv_uart_putData+0x2c>)
		}		
	}
}

void drv_uart_putData(drv_uart_config_t* uartConfig, char* str, size_t length)
{
  409086:	4606      	mov	r6, r0
  409088:	4688      	mov	r8, r1
  40908a:	4615      	mov	r5, r2
	int i=0;
	for (i=0;i<length;)
  40908c:	2400      	movs	r4, #0
  40908e:	42ac      	cmp	r4, r5
	{
		if(drv_uart_putChar(uartConfig, str[i]) == STATUS_PASS)
  409090:	4630      	mov	r0, r6
}

void drv_uart_putData(drv_uart_config_t* uartConfig, char* str, size_t length)
{
	int i=0;
	for (i=0;i<length;)
  409092:	d208      	bcs.n	4090a6 <drv_uart_putData+0x26>
	{
		if(drv_uart_putChar(uartConfig, str[i]) == STATUS_PASS)
  409094:	f818 1004 	ldrb.w	r1, [r8, r4]
  409098:	47b8      	blx	r7
  40909a:	2800      	cmp	r0, #0
  40909c:	d1f7      	bne.n	40908e <drv_uart_putData+0xe>
		{
			i++; //increment only if PASS is returned (it means the data has been sent)
  40909e:	3401      	adds	r4, #1
}

void drv_uart_putData(drv_uart_config_t* uartConfig, char* str, size_t length)
{
	int i=0;
	for (i=0;i<length;)
  4090a0:	42ac      	cmp	r4, r5
	{
		if(drv_uart_putChar(uartConfig, str[i]) == STATUS_PASS)
  4090a2:	4630      	mov	r0, r6
}

void drv_uart_putData(drv_uart_config_t* uartConfig, char* str, size_t length)
{
	int i=0;
	for (i=0;i<length;)
  4090a4:	d3f6      	bcc.n	409094 <drv_uart_putData+0x14>
		if(drv_uart_putChar(uartConfig, str[i]) == STATUS_PASS)
		{
			i++; //increment only if PASS is returned (it means the data has been sent)
		}
	}
}
  4090a6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4090aa:	bf00      	nop
  4090ac:	00408e41 	.word	0x00408e41

004090b0 <drv_uart_flushRx>:
	}
	return 0;
}

void drv_uart_flushRx(drv_uart_config_t* uartConfig)
{
  4090b0:	b570      	push	{r4, r5, r6, lr}
 * @param uartConfig, the configuration structure for the uart
 * @return STATUS_PASS if the driver is initialized,	STATUS_FAIL if not
 ***********************************************************************************************/	
status_t drv_uart_isInit(drv_uart_config_t* uartConfig)
{
	if(uartMemBuf[uartConfig->mem_index].isinit)
  4090b2:	6943      	ldr	r3, [r0, #20]
  4090b4:	4d24      	ldr	r5, [pc, #144]	; (409148 <drv_uart_flushRx+0x98>)
  4090b6:	eb03 1343 	add.w	r3, r3, r3, lsl #5
  4090ba:	eb05 1343 	add.w	r3, r5, r3, lsl #5
  4090be:	f503 7300 	add.w	r3, r3, #512	; 0x200
	}
	return 0;
}

void drv_uart_flushRx(drv_uart_config_t* uartConfig)
{
  4090c2:	4604      	mov	r4, r0
 * @param uartConfig, the configuration structure for the uart
 * @return STATUS_PASS if the driver is initialized,	STATUS_FAIL if not
 ***********************************************************************************************/	
status_t drv_uart_isInit(drv_uart_config_t* uartConfig)
{
	if(uartMemBuf[uartConfig->mem_index].isinit)
  4090c4:	799b      	ldrb	r3, [r3, #6]
  4090c6:	2b00      	cmp	r3, #0
  4090c8:	d03c      	beq.n	409144 <drv_uart_flushRx+0x94>
void drv_uart_flushRx(drv_uart_config_t* uartConfig)
{
	//clear the buffer
	if(drv_uart_isInit(uartConfig) == STATUS_PASS)
	{	
		usart_disable_interrupt(uartConfig->p_usart, UART_IER_RXRDY);
  4090ca:	6800      	ldr	r0, [r0, #0]
  4090cc:	4b1f      	ldr	r3, [pc, #124]	; (40914c <drv_uart_flushRx+0x9c>)
		uartMemBuf[uartConfig->mem_index].rx_fifo.num_bytes = 0;
		uartMemBuf[uartConfig->mem_index].uart_rx_fifo_full_flag = 0;
		uartMemBuf[uartConfig->mem_index].uart_rx_fifo_not_empty_flag = 0;
		uartMemBuf[uartConfig->mem_index].uart_rx_fifo_ovf_flag = 0;		
		//re-enable the interrupts
		usart_enable_interrupt(uartConfig->p_usart, UART_IER_RXRDY);	
  4090ce:	4e20      	ldr	r6, [pc, #128]	; (409150 <drv_uart_flushRx+0xa0>)
void drv_uart_flushRx(drv_uart_config_t* uartConfig)
{
	//clear the buffer
	if(drv_uart_isInit(uartConfig) == STATUS_PASS)
	{	
		usart_disable_interrupt(uartConfig->p_usart, UART_IER_RXRDY);
  4090d0:	2101      	movs	r1, #1
  4090d2:	4798      	blx	r3
		//disable the interrupts so we don't fuck up the pointers				
		memset(uartMemBuf[uartConfig->mem_index].rx_fifo.data_buf, 0,FIFO_BUFFER_SIZE);
  4090d4:	6960      	ldr	r0, [r4, #20]
  4090d6:	4b1f      	ldr	r3, [pc, #124]	; (409154 <drv_uart_flushRx+0xa4>)
  4090d8:	eb00 1040 	add.w	r0, r0, r0, lsl #5
  4090dc:	eb05 1040 	add.w	r0, r5, r0, lsl #5
  4090e0:	2100      	movs	r1, #0
  4090e2:	f44f 7200 	mov.w	r2, #512	; 0x200
  4090e6:	4798      	blx	r3
		uartMemBuf[uartConfig->mem_index].rx_fifo.i_first = 0;
  4090e8:	6963      	ldr	r3, [r4, #20]
  4090ea:	eb03 1343 	add.w	r3, r3, r3, lsl #5
  4090ee:	eb05 1243 	add.w	r2, r5, r3, lsl #5
  4090f2:	2300      	movs	r3, #0
  4090f4:	f8a2 3200 	strh.w	r3, [r2, #512]	; 0x200
		uartMemBuf[uartConfig->mem_index].rx_fifo.i_last = 0;
  4090f8:	6962      	ldr	r2, [r4, #20]
  4090fa:	eb02 1242 	add.w	r2, r2, r2, lsl #5
  4090fe:	eb05 1242 	add.w	r2, r5, r2, lsl #5
		uartMemBuf[uartConfig->mem_index].rx_fifo.num_bytes = 0;
		uartMemBuf[uartConfig->mem_index].uart_rx_fifo_full_flag = 0;
		uartMemBuf[uartConfig->mem_index].uart_rx_fifo_not_empty_flag = 0;
		uartMemBuf[uartConfig->mem_index].uart_rx_fifo_ovf_flag = 0;		
		//re-enable the interrupts
		usart_enable_interrupt(uartConfig->p_usart, UART_IER_RXRDY);	
  409102:	2101      	movs	r1, #1
	{	
		usart_disable_interrupt(uartConfig->p_usart, UART_IER_RXRDY);
		//disable the interrupts so we don't fuck up the pointers				
		memset(uartMemBuf[uartConfig->mem_index].rx_fifo.data_buf, 0,FIFO_BUFFER_SIZE);
		uartMemBuf[uartConfig->mem_index].rx_fifo.i_first = 0;
		uartMemBuf[uartConfig->mem_index].rx_fifo.i_last = 0;
  409104:	f8a2 3202 	strh.w	r3, [r2, #514]	; 0x202
		uartMemBuf[uartConfig->mem_index].rx_fifo.num_bytes = 0;
  409108:	6962      	ldr	r2, [r4, #20]
  40910a:	eb02 1242 	add.w	r2, r2, r2, lsl #5
  40910e:	eb05 1242 	add.w	r2, r5, r2, lsl #5
  409112:	f8a2 3204 	strh.w	r3, [r2, #516]	; 0x204
		uartMemBuf[uartConfig->mem_index].uart_rx_fifo_full_flag = 0;
  409116:	6962      	ldr	r2, [r4, #20]
  409118:	eb02 1242 	add.w	r2, r2, r2, lsl #5
  40911c:	eb05 1242 	add.w	r2, r5, r2, lsl #5
  409120:	f882 3208 	strb.w	r3, [r2, #520]	; 0x208
		uartMemBuf[uartConfig->mem_index].uart_rx_fifo_not_empty_flag = 0;
  409124:	6962      	ldr	r2, [r4, #20]
  409126:	eb02 1242 	add.w	r2, r2, r2, lsl #5
  40912a:	eb05 1242 	add.w	r2, r5, r2, lsl #5
  40912e:	f882 3207 	strb.w	r3, [r2, #519]	; 0x207
		uartMemBuf[uartConfig->mem_index].uart_rx_fifo_ovf_flag = 0;		
  409132:	6962      	ldr	r2, [r4, #20]
  409134:	eb02 1242 	add.w	r2, r2, r2, lsl #5
  409138:	eb05 1542 	add.w	r5, r5, r2, lsl #5
  40913c:	f885 3209 	strb.w	r3, [r5, #521]	; 0x209
		//re-enable the interrupts
		usart_enable_interrupt(uartConfig->p_usart, UART_IER_RXRDY);	
  409140:	6820      	ldr	r0, [r4, #0]
  409142:	47b0      	blx	r6
  409144:	bd70      	pop	{r4, r5, r6, pc}
  409146:	bf00      	nop
  409148:	20003e2c 	.word	0x20003e2c
  40914c:	00403e75 	.word	0x00403e75
  409150:	00403e71 	.word	0x00403e71
  409154:	0040c31d 	.word	0x0040c31d

00409158 <UART0_Handler>:
	}
}

// interrupt handlers
void UART0_Handler()
{	
  409158:	b510      	push	{r4, lr}
	//if(uartMemBuf[0].isinit) //only handle the interrupt if the driver is initialized. 
	//{
		//uart_process_byte(UART0, &(uartMemBuf[0]));	
	//}
	uint32_t status = uart_get_status(UART0); 
  40915a:	480c      	ldr	r0, [pc, #48]	; (40918c <UART0_Handler+0x34>)
  40915c:	4b0c      	ldr	r3, [pc, #48]	; (409190 <UART0_Handler+0x38>)
  40915e:	4798      	blx	r3
	if(status & UART_SR_RXRDY > 0)
  409160:	07c2      	lsls	r2, r0, #31
{	
	//if(uartMemBuf[0].isinit) //only handle the interrupt if the driver is initialized. 
	//{
		//uart_process_byte(UART0, &(uartMemBuf[0]));	
	//}
	uint32_t status = uart_get_status(UART0); 
  409162:	4604      	mov	r4, r0
	if(status & UART_SR_RXRDY > 0)
  409164:	d503      	bpl.n	40916e <UART0_Handler+0x16>
	{	
		if(uartMemBuf[0].isinit) //only handle the interrupt if the driver is initialized.
  409166:	490b      	ldr	r1, [pc, #44]	; (409194 <UART0_Handler+0x3c>)
  409168:	f891 3206 	ldrb.w	r3, [r1, #518]	; 0x206
  40916c:	b953      	cbnz	r3, 409184 <UART0_Handler+0x2c>
		{
			uart_process_byte(UART0, &(uartMemBuf[0]));
		}
	}
	
	if(status & UART_SR_TXEMPTY)
  40916e:	05a3      	lsls	r3, r4, #22
  409170:	d503      	bpl.n	40917a <UART0_Handler+0x22>
	{
		if(uartMemBuf[0].isinit) //only handle the interrupt if the driver is initialized.
  409172:	4908      	ldr	r1, [pc, #32]	; (409194 <UART0_Handler+0x3c>)
  409174:	f891 3206 	ldrb.w	r3, [r1, #518]	; 0x206
  409178:	b903      	cbnz	r3, 40917c <UART0_Handler+0x24>
  40917a:	bd10      	pop	{r4, pc}
		{
			uart_process_tx_byte(UART0, &(uartMemBuf[0])); 	
  40917c:	4803      	ldr	r0, [pc, #12]	; (40918c <UART0_Handler+0x34>)
  40917e:	4b06      	ldr	r3, [pc, #24]	; (409198 <UART0_Handler+0x40>)
  409180:	4798      	blx	r3
  409182:	bd10      	pop	{r4, pc}
	uint32_t status = uart_get_status(UART0); 
	if(status & UART_SR_RXRDY > 0)
	{	
		if(uartMemBuf[0].isinit) //only handle the interrupt if the driver is initialized.
		{
			uart_process_byte(UART0, &(uartMemBuf[0]));
  409184:	4801      	ldr	r0, [pc, #4]	; (40918c <UART0_Handler+0x34>)
  409186:	4b05      	ldr	r3, [pc, #20]	; (40919c <UART0_Handler+0x44>)
  409188:	4798      	blx	r3
  40918a:	e7f0      	b.n	40916e <UART0_Handler+0x16>
  40918c:	400e0600 	.word	0x400e0600
  409190:	00403d69 	.word	0x00403d69
  409194:	20003e2c 	.word	0x20003e2c
  409198:	00408a1d 	.word	0x00408a1d
  40919c:	00408995 	.word	0x00408995

004091a0 <UART1_Handler>:
		}
	}	
}

void UART1_Handler()
{
  4091a0:	b510      	push	{r4, lr}
	uint32_t status = uart_get_status(UART1); 
  4091a2:	480e      	ldr	r0, [pc, #56]	; (4091dc <UART1_Handler+0x3c>)
  4091a4:	4b0e      	ldr	r3, [pc, #56]	; (4091e0 <UART1_Handler+0x40>)
  4091a6:	4798      	blx	r3
	if(status & UART_SR_RXRDY > 0)
  4091a8:	07c2      	lsls	r2, r0, #31
	}	
}

void UART1_Handler()
{
	uint32_t status = uart_get_status(UART1); 
  4091aa:	4604      	mov	r4, r0
	if(status & UART_SR_RXRDY > 0)
  4091ac:	d503      	bpl.n	4091b6 <UART1_Handler+0x16>
	{	
		if(uartMemBuf[1].isinit) //only handle the interrupt if the driver is initialized.
  4091ae:	490d      	ldr	r1, [pc, #52]	; (4091e4 <UART1_Handler+0x44>)
  4091b0:	f891 3626 	ldrb.w	r3, [r1, #1574]	; 0x626
  4091b4:	b963      	cbnz	r3, 4091d0 <UART1_Handler+0x30>
		{
			uart_process_byte(UART1, &(uartMemBuf[1]));
		}
	}
	
	if(status & UART_SR_TXEMPTY)
  4091b6:	05a3      	lsls	r3, r4, #22
  4091b8:	d503      	bpl.n	4091c2 <UART1_Handler+0x22>
	{
		if(uartMemBuf[1].isinit) //only handle the interrupt if the driver is initialized.
  4091ba:	490a      	ldr	r1, [pc, #40]	; (4091e4 <UART1_Handler+0x44>)
  4091bc:	f891 3626 	ldrb.w	r3, [r1, #1574]	; 0x626
  4091c0:	b903      	cbnz	r3, 4091c4 <UART1_Handler+0x24>
  4091c2:	bd10      	pop	{r4, pc}
		{
			uart_process_tx_byte(UART1, &(uartMemBuf[1])); 	
  4091c4:	f501 6184 	add.w	r1, r1, #1056	; 0x420
  4091c8:	4804      	ldr	r0, [pc, #16]	; (4091dc <UART1_Handler+0x3c>)
  4091ca:	4b07      	ldr	r3, [pc, #28]	; (4091e8 <UART1_Handler+0x48>)
  4091cc:	4798      	blx	r3
  4091ce:	bd10      	pop	{r4, pc}
	uint32_t status = uart_get_status(UART1); 
	if(status & UART_SR_RXRDY > 0)
	{	
		if(uartMemBuf[1].isinit) //only handle the interrupt if the driver is initialized.
		{
			uart_process_byte(UART1, &(uartMemBuf[1]));
  4091d0:	f501 6184 	add.w	r1, r1, #1056	; 0x420
  4091d4:	4801      	ldr	r0, [pc, #4]	; (4091dc <UART1_Handler+0x3c>)
  4091d6:	4b05      	ldr	r3, [pc, #20]	; (4091ec <UART1_Handler+0x4c>)
  4091d8:	4798      	blx	r3
  4091da:	e7ec      	b.n	4091b6 <UART1_Handler+0x16>
  4091dc:	400e0800 	.word	0x400e0800
  4091e0:	00403d69 	.word	0x00403d69
  4091e4:	20003e2c 	.word	0x20003e2c
  4091e8:	00408a1d 	.word	0x00408a1d
  4091ec:	00408995 	.word	0x00408995

004091f0 <USART0_Handler>:
		}
	}
}

void USART0_Handler()
{
  4091f0:	b510      	push	{r4, lr}
	//if(uartMemBuf[2].isinit) //only handle the interrupt if the driver is initialized.
	//{
		//uart_process_byte(USART0, &(uartMemBuf[2]));
	//}
	uint32_t status = uart_get_status(USART0); 
  4091f2:	480e      	ldr	r0, [pc, #56]	; (40922c <USART0_Handler+0x3c>)
  4091f4:	4b0e      	ldr	r3, [pc, #56]	; (409230 <USART0_Handler+0x40>)
  4091f6:	4798      	blx	r3
	if(status & UART_SR_RXRDY > 0)
  4091f8:	07c2      	lsls	r2, r0, #31
{
	//if(uartMemBuf[2].isinit) //only handle the interrupt if the driver is initialized.
	//{
		//uart_process_byte(USART0, &(uartMemBuf[2]));
	//}
	uint32_t status = uart_get_status(USART0); 
  4091fa:	4604      	mov	r4, r0
	if(status & UART_SR_RXRDY > 0)
  4091fc:	d503      	bpl.n	409206 <USART0_Handler+0x16>
	{	
		if(uartMemBuf[2].isinit) //only handle the interrupt if the driver is initialized.
  4091fe:	490d      	ldr	r1, [pc, #52]	; (409234 <USART0_Handler+0x44>)
  409200:	f891 3a46 	ldrb.w	r3, [r1, #2630]	; 0xa46
  409204:	b963      	cbnz	r3, 409220 <USART0_Handler+0x30>
		{
			uart_process_byte(USART0, &(uartMemBuf[2]));
		}
	}
	
	if(status & UART_SR_TXEMPTY)
  409206:	05a3      	lsls	r3, r4, #22
  409208:	d503      	bpl.n	409212 <USART0_Handler+0x22>
	{
		if(uartMemBuf[2].isinit) //only handle the interrupt if the driver is initialized.
  40920a:	490a      	ldr	r1, [pc, #40]	; (409234 <USART0_Handler+0x44>)
  40920c:	f891 3a46 	ldrb.w	r3, [r1, #2630]	; 0xa46
  409210:	b903      	cbnz	r3, 409214 <USART0_Handler+0x24>
  409212:	bd10      	pop	{r4, pc}
		{
			uart_process_tx_byte(USART0, &(uartMemBuf[2])); 	
  409214:	f501 6104 	add.w	r1, r1, #2112	; 0x840
  409218:	4804      	ldr	r0, [pc, #16]	; (40922c <USART0_Handler+0x3c>)
  40921a:	4b07      	ldr	r3, [pc, #28]	; (409238 <USART0_Handler+0x48>)
  40921c:	4798      	blx	r3
  40921e:	bd10      	pop	{r4, pc}
	uint32_t status = uart_get_status(USART0); 
	if(status & UART_SR_RXRDY > 0)
	{	
		if(uartMemBuf[2].isinit) //only handle the interrupt if the driver is initialized.
		{
			uart_process_byte(USART0, &(uartMemBuf[2]));
  409220:	f501 6104 	add.w	r1, r1, #2112	; 0x840
  409224:	4801      	ldr	r0, [pc, #4]	; (40922c <USART0_Handler+0x3c>)
  409226:	4b05      	ldr	r3, [pc, #20]	; (40923c <USART0_Handler+0x4c>)
  409228:	4798      	blx	r3
  40922a:	e7ec      	b.n	409206 <USART0_Handler+0x16>
  40922c:	40024000 	.word	0x40024000
  409230:	00403d69 	.word	0x00403d69
  409234:	20003e2c 	.word	0x20003e2c
  409238:	00408a1d 	.word	0x00408a1d
  40923c:	00408995 	.word	0x00408995

00409240 <USART1_Handler>:
		}
	}	
}

void USART1_Handler()
{
  409240:	b510      	push	{r4, lr}
	//if(uartMemBuf[3].isinit) //only handle the interrupt if the driver is initialized.
	//{
		//uart_process_byte(USART1, &(uartMemBuf[3]));
	//}
	uint32_t status = uart_get_status(USART1); 
  409242:	480e      	ldr	r0, [pc, #56]	; (40927c <USART1_Handler+0x3c>)
  409244:	4b0e      	ldr	r3, [pc, #56]	; (409280 <USART1_Handler+0x40>)
  409246:	4798      	blx	r3
	if(status & UART_SR_RXRDY > 0)
  409248:	07c2      	lsls	r2, r0, #31
{
	//if(uartMemBuf[3].isinit) //only handle the interrupt if the driver is initialized.
	//{
		//uart_process_byte(USART1, &(uartMemBuf[3]));
	//}
	uint32_t status = uart_get_status(USART1); 
  40924a:	4604      	mov	r4, r0
	if(status & UART_SR_RXRDY > 0)
  40924c:	d503      	bpl.n	409256 <USART1_Handler+0x16>
	{	
		if(uartMemBuf[3].isinit) //only handle the interrupt if the driver is initialized.
  40924e:	490d      	ldr	r1, [pc, #52]	; (409284 <USART1_Handler+0x44>)
  409250:	f891 3e66 	ldrb.w	r3, [r1, #3686]	; 0xe66
  409254:	b963      	cbnz	r3, 409270 <USART1_Handler+0x30>
		{
			uart_process_byte(USART1, &(uartMemBuf[3]));
		}
	}
	
	if(status & UART_SR_TXEMPTY)
  409256:	05a3      	lsls	r3, r4, #22
  409258:	d503      	bpl.n	409262 <USART1_Handler+0x22>
	{
		if(uartMemBuf[3].isinit) //only handle the interrupt if the driver is initialized.
  40925a:	490a      	ldr	r1, [pc, #40]	; (409284 <USART1_Handler+0x44>)
  40925c:	f891 3e66 	ldrb.w	r3, [r1, #3686]	; 0xe66
  409260:	b903      	cbnz	r3, 409264 <USART1_Handler+0x24>
  409262:	bd10      	pop	{r4, pc}
		{
			uart_process_tx_byte(USART1, &(uartMemBuf[3])); 	
  409264:	f501 6146 	add.w	r1, r1, #3168	; 0xc60
  409268:	4804      	ldr	r0, [pc, #16]	; (40927c <USART1_Handler+0x3c>)
  40926a:	4b07      	ldr	r3, [pc, #28]	; (409288 <USART1_Handler+0x48>)
  40926c:	4798      	blx	r3
  40926e:	bd10      	pop	{r4, pc}
	uint32_t status = uart_get_status(USART1); 
	if(status & UART_SR_RXRDY > 0)
	{	
		if(uartMemBuf[3].isinit) //only handle the interrupt if the driver is initialized.
		{
			uart_process_byte(USART1, &(uartMemBuf[3]));
  409270:	f501 6146 	add.w	r1, r1, #3168	; 0xc60
  409274:	4801      	ldr	r0, [pc, #4]	; (40927c <USART1_Handler+0x3c>)
  409276:	4b05      	ldr	r3, [pc, #20]	; (40928c <USART1_Handler+0x4c>)
  409278:	4798      	blx	r3
  40927a:	e7ec      	b.n	409256 <USART1_Handler+0x16>
  40927c:	40028000 	.word	0x40028000
  409280:	00403d69 	.word	0x00403d69
  409284:	20003e2c 	.word	0x20003e2c
  409288:	00408a1d 	.word	0x00408a1d
  40928c:	00408995 	.word	0x00408995

00409290 <vframeTimeOutTimerCallback>:
//static function declarations
static status_t processPackets(); 

void vframeTimeOutTimerCallback()
{
	vframeTimeOutFlag = 1;
  409290:	4b01      	ldr	r3, [pc, #4]	; (409298 <vframeTimeOutTimerCallback+0x8>)
  409292:	2201      	movs	r2, #1
  409294:	701a      	strb	r2, [r3, #0]
  409296:	4770      	bx	lr
  409298:	20003870 	.word	0x20003870

0040929c <processPackets>:
 * @brief process the incoming packets and create a full frame. 
 * @param 
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error 
 ***********************************************************************************************/	
static status_t processPackets()
{
  40929c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	int entryBufferIdx = 0; 
	int res = 0; 
	int numberBytes = 0; 
	//char* entryBuffer = NULL; 	
	
	entryBufferIdx = snprintf(entryBuffer, 17 ,"%010d,%04x,", sgSysTickCount,packetReceivedFlags);
  4092a0:	4a48      	ldr	r2, [pc, #288]	; (4093c4 <processPackets+0x128>)
  4092a2:	4b49      	ldr	r3, [pc, #292]	; (4093c8 <processPackets+0x12c>)
  4092a4:	8812      	ldrh	r2, [r2, #0]
  4092a6:	4849      	ldr	r0, [pc, #292]	; (4093cc <processPackets+0x130>)
  4092a8:	681b      	ldr	r3, [r3, #0]
  4092aa:	4d49      	ldr	r5, [pc, #292]	; (4093d0 <processPackets+0x134>)
  4092ac:	f8df 9144 	ldr.w	r9, [pc, #324]	; 4093f4 <processPackets+0x158>
 * @brief process the incoming packets and create a full frame. 
 * @param 
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error 
 ***********************************************************************************************/	
static status_t processPackets()
{
  4092b0:	b083      	sub	sp, #12
	int entryBufferIdx = 0; 
	int res = 0; 
	int numberBytes = 0; 
	//char* entryBuffer = NULL; 	
	
	entryBufferIdx = snprintf(entryBuffer, 17 ,"%010d,%04x,", sgSysTickCount,packetReceivedFlags);
  4092b2:	2111      	movs	r1, #17
  4092b4:	9200      	str	r2, [sp, #0]
  4092b6:	4a47      	ldr	r2, [pc, #284]	; (4093d4 <processPackets+0x138>)
  4092b8:	4604      	mov	r4, r0
  4092ba:	47a8      	blx	r5
  4092bc:	2700      	movs	r7, #0
					}
						
					if(entryBuffer[entryBufferIdx-1] == 0)
					{
						//if that entry is empty/NULL, fill it in with '0's
						entryBuffer[entryBufferIdx-1] = '0'; 
  4092be:	2630      	movs	r6, #48	; 0x30
					}
				}
				if(j != IMU_PACKET_LENGTH-1)
				{
					entryBuffer[entryBufferIdx++] = ';';	
  4092c0:	f04f 083b 	mov.w	r8, #59	; 0x3b
					entryBuffer[entryBufferIdx++] = ';';
				}
			}				
		}			
		 			
		entryBuffer[entryBufferIdx++] = ',';		
  4092c4:	f04f 0b2c 	mov.w	fp, #44	; 0x2c
	
	entryBufferIdx = snprintf(entryBuffer, 17 ,"%010d,%04x,", sgSysTickCount,packetReceivedFlags);
	for(i = 0; i < 10; i++) //sensor reading
	{
		//if imu or acceleration process this way, 
		if(i < NUMBER_OF_SENSORS -1)
  4092c8:	f240 1a3b 	movw	sl, #315	; 0x13b
  4092cc:	1a3d      	subs	r5, r7, r0
  4092ce:	444d      	add	r5, r9
  4092d0:	1d01      	adds	r1, r0, #4
  4092d2:	f100 0c0f 	add.w	ip, r0, #15
  4092d6:	f100 0e0a 	add.w	lr, r0, #10
					entryBuffer[entryBufferIdx++] = ';';
				}
			}				
		}			
		 			
		entryBuffer[entryBufferIdx++] = ',';		
  4092da:	4603      	mov	r3, r0
  4092dc:	18ea      	adds	r2, r5, r3
				for(k = 0; k < IMU_PACKET_DATA_SIZE; k++) //reading bytes
				{				
					//copy the asci data to the entry buffer
					if(packetBuffer[i].data != NULL)
					{
						entryBuffer[entryBufferIdx++] = packetBuffer[i].data[(j*4)+k];	
  4092de:	78d2      	ldrb	r2, [r2, #3]
					else
					{
						entryBuffer[entryBufferIdx++] = 0;
					}
						
					if(entryBuffer[entryBufferIdx-1] == 0)
  4092e0:	b1ba      	cbz	r2, 409312 <processPackets+0x76>
				for(k = 0; k < IMU_PACKET_DATA_SIZE; k++) //reading bytes
				{				
					//copy the asci data to the entry buffer
					if(packetBuffer[i].data != NULL)
					{
						entryBuffer[entryBufferIdx++] = packetBuffer[i].data[(j*4)+k];	
  4092e2:	54e2      	strb	r2, [r4, r3]
  4092e4:	3301      	adds	r3, #1
		//if imu or acceleration process this way, 
		if(i < NUMBER_OF_SENSORS -1)
		{			
			for(j=0; j < IMU_PACKET_LENGTH; j++) //reading value
			{
				for(k = 0; k < IMU_PACKET_DATA_SIZE; k++) //reading bytes
  4092e6:	428b      	cmp	r3, r1
  4092e8:	d1f8      	bne.n	4092dc <processPackets+0x40>
					{
						//if that entry is empty/NULL, fill it in with '0's
						entryBuffer[entryBufferIdx-1] = '0'; 
					}
				}
				if(j != IMU_PACKET_LENGTH-1)
  4092ea:	4570      	cmp	r0, lr
  4092ec:	d067      	beq.n	4093be <processPackets+0x122>
  4092ee:	3005      	adds	r0, #5
	for(i = 0; i < 10; i++) //sensor reading
	{
		//if imu or acceleration process this way, 
		if(i < NUMBER_OF_SENSORS -1)
		{			
			for(j=0; j < IMU_PACKET_LENGTH; j++) //reading value
  4092f0:	4560      	cmp	r0, ip
						entryBuffer[entryBufferIdx-1] = '0'; 
					}
				}
				if(j != IMU_PACKET_LENGTH-1)
				{
					entryBuffer[entryBufferIdx++] = ';';	
  4092f2:	f804 8001 	strb.w	r8, [r4, r1]
  4092f6:	f105 35ff 	add.w	r5, r5, #4294967295
  4092fa:	f101 0105 	add.w	r1, r1, #5
	for(i = 0; i < 10; i++) //sensor reading
	{
		//if imu or acceleration process this way, 
		if(i < NUMBER_OF_SENSORS -1)
		{			
			for(j=0; j < IMU_PACKET_LENGTH; j++) //reading value
  4092fe:	d1ec      	bne.n	4092da <processPackets+0x3e>
  409300:	3723      	adds	r7, #35	; 0x23
	
	entryBufferIdx = snprintf(entryBuffer, 17 ,"%010d,%04x,", sgSysTickCount,packetReceivedFlags);
	for(i = 0; i < 10; i++) //sensor reading
	{
		//if imu or acceleration process this way, 
		if(i < NUMBER_OF_SENSORS -1)
  409302:	4557      	cmp	r7, sl
					entryBuffer[entryBufferIdx++] = ';';
				}
			}				
		}			
		 			
		entryBuffer[entryBufferIdx++] = ',';		
  409304:	f804 b000 	strb.w	fp, [r4, r0]
  409308:	f100 0501 	add.w	r5, r0, #1
	
	entryBufferIdx = snprintf(entryBuffer, 17 ,"%010d,%04x,", sgSysTickCount,packetReceivedFlags);
	for(i = 0; i < 10; i++) //sensor reading
	{
		//if imu or acceleration process this way, 
		if(i < NUMBER_OF_SENSORS -1)
  40930c:	d003      	beq.n	409316 <processPackets+0x7a>
					entryBuffer[entryBufferIdx++] = ';';
				}
			}				
		}			
		 			
		entryBuffer[entryBufferIdx++] = ',';		
  40930e:	4628      	mov	r0, r5
  409310:	e7dc      	b.n	4092cc <processPackets+0x30>
					}
						
					if(entryBuffer[entryBufferIdx-1] == 0)
					{
						//if that entry is empty/NULL, fill it in with '0's
						entryBuffer[entryBufferIdx-1] = '0'; 
  409312:	54e6      	strb	r6, [r4, r3]
  409314:	e7e6      	b.n	4092e4 <processPackets+0x48>
  409316:	1d41      	adds	r1, r0, #5
  409318:	f100 0e1a 	add.w	lr, r0, #26
  40931c:	ebc5 0909 	rsb	r9, r5, r9
  409320:	3015      	adds	r0, #21
						entryBuffer[entryBufferIdx++] = 0;
					}
					if(entryBuffer[entryBufferIdx-1] == 0)
					{
						//if that entry is empty/NULL, fill it in with '0's
						entryBuffer[entryBufferIdx-1] = '0';
  409322:	2630      	movs	r6, #48	; 0x30
					}
				}
				if(j != FS_PACKET_LENGTH-1)
				{
					entryBuffer[entryBufferIdx++] = ';';
  409324:	273b      	movs	r7, #59	; 0x3b
				}
			}				
		}			
		 			
		entryBuffer[entryBufferIdx++] = ',';		
  409326:	462b      	mov	r3, r5
  409328:	eb09 0203 	add.w	r2, r9, r3
				for(k = 0; k < FS_PACKET_DATA_SIZE; k++) //reading bytes
				{
					if(packetBuffer[i].data != NULL)
					{
						//copy the ascii data to the entry buffer
						entryBuffer[entryBufferIdx++] = packetBuffer[i].data[(j*4)+k];							
  40932c:	f892 213e 	ldrb.w	r2, [r2, #318]	; 0x13e
					else
					{
						//there is no data, set to zero. 
						entryBuffer[entryBufferIdx++] = 0;
					}
					if(entryBuffer[entryBufferIdx-1] == 0)
  409330:	2a00      	cmp	r2, #0
  409332:	d039      	beq.n	4093a8 <processPackets+0x10c>
				for(k = 0; k < FS_PACKET_DATA_SIZE; k++) //reading bytes
				{
					if(packetBuffer[i].data != NULL)
					{
						//copy the ascii data to the entry buffer
						entryBuffer[entryBufferIdx++] = packetBuffer[i].data[(j*4)+k];							
  409334:	54e2      	strb	r2, [r4, r3]
  409336:	3301      	adds	r3, #1
		}
		else //if stretch sense data, add it differently.
		{
			for(j=0; j < FS_PACKET_LENGTH; j++) //reading value
			{
				for(k = 0; k < FS_PACKET_DATA_SIZE; k++) //reading bytes
  409338:	4299      	cmp	r1, r3
  40933a:	d1f5      	bne.n	409328 <processPackets+0x8c>
					{
						//if that entry is empty/NULL, fill it in with '0's
						entryBuffer[entryBufferIdx-1] = '0';
					}
				}
				if(j != FS_PACKET_LENGTH-1)
  40933c:	4285      	cmp	r5, r0
  40933e:	d03c      	beq.n	4093ba <processPackets+0x11e>
  409340:	3505      	adds	r5, #5
				}			
			}
		}
		else //if stretch sense data, add it differently.
		{
			for(j=0; j < FS_PACKET_LENGTH; j++) //reading value
  409342:	4575      	cmp	r5, lr
						entryBuffer[entryBufferIdx-1] = '0';
					}
				}
				if(j != FS_PACKET_LENGTH-1)
				{
					entryBuffer[entryBufferIdx++] = ';';
  409344:	5467      	strb	r7, [r4, r1]
  409346:	f109 39ff 	add.w	r9, r9, #4294967295
  40934a:	f101 0105 	add.w	r1, r1, #5
				}			
			}
		}
		else //if stretch sense data, add it differently.
		{
			for(j=0; j < FS_PACKET_LENGTH; j++) //reading value
  40934e:	d1ea      	bne.n	409326 <processPackets+0x8a>
		}			
		 			
		entryBuffer[entryBufferIdx++] = ',';		
		
	}
	if(brainSettings.debugPackets)
  409350:	4b21      	ldr	r3, [pc, #132]	; (4093d8 <processPackets+0x13c>)
  409352:	f893 309d 	ldrb.w	r3, [r3, #157]	; 0x9d
					entryBuffer[entryBufferIdx++] = ';';
				}
			}				
		}			
		 			
		entryBuffer[entryBufferIdx++] = ',';		
  409356:	222c      	movs	r2, #44	; 0x2c
  409358:	5562      	strb	r2, [r4, r5]
  40935a:	1c6e      	adds	r6, r5, #1
		
	}
	if(brainSettings.debugPackets)
  40935c:	bb33      	cbnz	r3, 4093ac <processPackets+0x110>
	{
		memset(packetBuffer, 0x00, sizeof(packetBuffer));
	}	
	if (buttonEvent)
  40935e:	4b1f      	ldr	r3, [pc, #124]	; (4093dc <processPackets+0x140>)
  409360:	781a      	ldrb	r2, [r3, #0]
  409362:	b12a      	cbz	r2, 409370 <processPackets+0xd4>
	{
		memcpy(entryBuffer+entryBufferIdx, "BTN,", 4);
  409364:	491e      	ldr	r1, [pc, #120]	; (4093e0 <processPackets+0x144>)
		entryBufferIdx += 4;
		buttonEvent = FALSE;
  409366:	2200      	movs	r2, #0
	{
		memset(packetBuffer, 0x00, sizeof(packetBuffer));
	}	
	if (buttonEvent)
	{
		memcpy(entryBuffer+entryBufferIdx, "BTN,", 4);
  409368:	6808      	ldr	r0, [r1, #0]
  40936a:	51a0      	str	r0, [r4, r6]
		entryBufferIdx += 4;
		buttonEvent = FALSE;
  40936c:	701a      	strb	r2, [r3, #0]
		memset(packetBuffer, 0x00, sizeof(packetBuffer));
	}	
	if (buttonEvent)
	{
		memcpy(entryBuffer+entryBufferIdx, "BTN,", 4);
		entryBufferIdx += 4;
  40936e:	1d6e      	adds	r6, r5, #5
		buttonEvent = FALSE;
	}
	entryBuffer[entryBufferIdx++] = '\r';
	entryBuffer[entryBufferIdx++] = '\n';
  409370:	19a2      	adds	r2, r4, r6
  409372:	1cb7      	adds	r7, r6, #2
	{
		memcpy(entryBuffer+entryBufferIdx, "BTN,", 4);
		entryBufferIdx += 4;
		buttonEvent = FALSE;
	}
	entryBuffer[entryBufferIdx++] = '\r';
  409374:	f04f 0c0d 	mov.w	ip, #13
	entryBuffer[entryBufferIdx++] = '\n';
  409378:	f04f 0e0a 	mov.w	lr, #10
	entryBuffer[entryBufferIdx] = 0; //terminate the string
  40937c:	2500      	movs	r5, #0
		
	sendPacket(entryBuffer,entryBufferIdx); //don't want to print the null
  40937e:	4639      	mov	r1, r7
  409380:	4812      	ldr	r0, [pc, #72]	; (4093cc <processPackets+0x130>)
  409382:	4b18      	ldr	r3, [pc, #96]	; (4093e4 <processPackets+0x148>)
	{
		memcpy(entryBuffer+entryBufferIdx, "BTN,", 4);
		entryBufferIdx += 4;
		buttonEvent = FALSE;
	}
	entryBuffer[entryBufferIdx++] = '\r';
  409384:	f804 c006 	strb.w	ip, [r4, r6]
	entryBuffer[entryBufferIdx++] = '\n';
  409388:	f882 e001 	strb.w	lr, [r2, #1]
	entryBuffer[entryBufferIdx] = 0; //terminate the string
  40938c:	55e5      	strb	r5, [r4, r7]
		
	sendPacket(entryBuffer,entryBufferIdx); //don't want to print the null
  40938e:	4798      	blx	r3
	totalFramesWritten++;	
  409390:	4b15      	ldr	r3, [pc, #84]	; (4093e8 <processPackets+0x14c>)
	//write the entry to file
	task_sdCardWriteEntry(entryBuffer,entryBufferIdx);
  409392:	4a16      	ldr	r2, [pc, #88]	; (4093ec <processPackets+0x150>)
	entryBuffer[entryBufferIdx++] = '\r';
	entryBuffer[entryBufferIdx++] = '\n';
	entryBuffer[entryBufferIdx] = 0; //terminate the string
		
	sendPacket(entryBuffer,entryBufferIdx); //don't want to print the null
	totalFramesWritten++;	
  409394:	681c      	ldr	r4, [r3, #0]
	//write the entry to file
	task_sdCardWriteEntry(entryBuffer,entryBufferIdx);
  409396:	480d      	ldr	r0, [pc, #52]	; (4093cc <processPackets+0x130>)
  409398:	4639      	mov	r1, r7
	entryBuffer[entryBufferIdx++] = '\r';
	entryBuffer[entryBufferIdx++] = '\n';
	entryBuffer[entryBufferIdx] = 0; //terminate the string
		
	sendPacket(entryBuffer,entryBufferIdx); //don't want to print the null
	totalFramesWritten++;	
  40939a:	3401      	adds	r4, #1
  40939c:	601c      	str	r4, [r3, #0]
	//write the entry to file
	task_sdCardWriteEntry(entryBuffer,entryBufferIdx);
  40939e:	4790      	blx	r2
	entryBufferIdx = 0; //reset pointer.		

	return status; 
  4093a0:	4628      	mov	r0, r5
  4093a2:	b003      	add	sp, #12
  4093a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
						entryBuffer[entryBufferIdx++] = 0;
					}
					if(entryBuffer[entryBufferIdx-1] == 0)
					{
						//if that entry is empty/NULL, fill it in with '0's
						entryBuffer[entryBufferIdx-1] = '0';
  4093a8:	54e6      	strb	r6, [r4, r3]
  4093aa:	e7c4      	b.n	409336 <processPackets+0x9a>
		entryBuffer[entryBufferIdx++] = ',';		
		
	}
	if(brainSettings.debugPackets)
	{
		memset(packetBuffer, 0x00, sizeof(packetBuffer));
  4093ac:	4b10      	ldr	r3, [pc, #64]	; (4093f0 <processPackets+0x154>)
  4093ae:	4811      	ldr	r0, [pc, #68]	; (4093f4 <processPackets+0x158>)
  4093b0:	2100      	movs	r1, #0
  4093b2:	f44f 72af 	mov.w	r2, #350	; 0x15e
  4093b6:	4798      	blx	r3
  4093b8:	e7d1      	b.n	40935e <processPackets+0xc2>
				for(k = 0; k < FS_PACKET_DATA_SIZE; k++) //reading bytes
				{
					if(packetBuffer[i].data != NULL)
					{
						//copy the ascii data to the entry buffer
						entryBuffer[entryBufferIdx++] = packetBuffer[i].data[(j*4)+k];							
  4093ba:	460d      	mov	r5, r1
  4093bc:	e7c8      	b.n	409350 <processPackets+0xb4>
				for(k = 0; k < IMU_PACKET_DATA_SIZE; k++) //reading bytes
				{				
					//copy the asci data to the entry buffer
					if(packetBuffer[i].data != NULL)
					{
						entryBuffer[entryBufferIdx++] = packetBuffer[i].data[(j*4)+k];	
  4093be:	4618      	mov	r0, r3
  4093c0:	e79e      	b.n	409300 <processPackets+0x64>
  4093c2:	bf00      	nop
  4093c4:	2000386c 	.word	0x2000386c
  4093c8:	20003970 	.word	0x20003970
  4093cc:	200037a4 	.word	0x200037a4
  4093d0:	0040c4ed 	.word	0x0040c4ed
  4093d4:	0041674c 	.word	0x0041674c
  4093d8:	200001ac 	.word	0x200001ac
  4093dc:	2000386e 	.word	0x2000386e
  4093e0:	00416758 	.word	0x00416758
  4093e4:	0040118d 	.word	0x0040118d
  4093e8:	20003880 	.word	0x20003880
  4093ec:	004011a9 	.word	0x004011a9
  4093f0:	0040c31d 	.word	0x0040c31d
  4093f4:	20004ec4 	.word	0x20004ec4

004093f8 <task_dataHandler>:
 * @brief Handles the incoming data from IMUs
 * @param void *pvParameters
 * @return 
 ***********************************************************************************************/
void task_dataHandler(void *pvParameters)
{
  4093f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

	//setup the queue
	queue_dataHandler = xQueueCreate( 50, sizeof(dataPacket_t));
  4093fc:	2032      	movs	r0, #50	; 0x32
 * @brief Handles the incoming data from IMUs
 * @param void *pvParameters
 * @return 
 ***********************************************************************************************/
void task_dataHandler(void *pvParameters)
{
  4093fe:	b08f      	sub	sp, #60	; 0x3c

	//setup the queue
	queue_dataHandler = xQueueCreate( 50, sizeof(dataPacket_t));
  409400:	2123      	movs	r1, #35	; 0x23
  409402:	4bb6      	ldr	r3, [pc, #728]	; (4096dc <task_dataHandler+0x2e4>)
  409404:	4eb6      	ldr	r6, [pc, #728]	; (4096e0 <task_dataHandler+0x2e8>)
  409406:	4798      	blx	r3
  409408:	6030      	str	r0, [r6, #0]
	if(queue_dataHandler == 0)
  40940a:	2800      	cmp	r0, #0
  40940c:	f000 8203 	beq.w	409816 <task_dataHandler+0x41e>
		debugPrintString("an error has occurred, data handler queue failure\r\n"); 
		return; 
	}
	int timerId = 0;

	frameTimeOutTimer = xTimerCreate("Frame Time Out Timer", (PACKET_WAIT_TIMEOUT/portTICK_RATE_MS), pdFALSE, NULL, vframeTimeOutTimerCallback);
  409410:	4bb4      	ldr	r3, [pc, #720]	; (4096e4 <task_dataHandler+0x2ec>)
  409412:	9300      	str	r3, [sp, #0]
  409414:	2200      	movs	r2, #0
  409416:	2116      	movs	r1, #22
  409418:	4613      	mov	r3, r2
  40941a:	48b3      	ldr	r0, [pc, #716]	; (4096e8 <task_dataHandler+0x2f0>)
  40941c:	4cb3      	ldr	r4, [pc, #716]	; (4096ec <task_dataHandler+0x2f4>)
  40941e:	47a0      	blx	r4
  409420:	49b3      	ldr	r1, [pc, #716]	; (4096f0 <task_dataHandler+0x2f8>)
  409422:	6008      	str	r0, [r1, #0]
	if (frameTimeOutTimer == NULL)
  409424:	2800      	cmp	r0, #0
  409426:	f000 81f2 	beq.w	40980e <task_dataHandler+0x416>
  40942a:	f10d 0c34 	add.w	ip, sp, #52	; 0x34
  40942e:	f8df 8308 	ldr.w	r8, [pc, #776]	; 409738 <task_dataHandler+0x340>
  409432:	4cb0      	ldr	r4, [pc, #704]	; (4096f4 <task_dataHandler+0x2fc>)
  409434:	4db0      	ldr	r5, [pc, #704]	; (4096f8 <task_dataHandler+0x300>)
  409436:	4fb1      	ldr	r7, [pc, #708]	; (4096fc <task_dataHandler+0x304>)
  409438:	f8cd c00c 	str.w	ip, [sp, #12]
	dataPacket_t packet; 
	int i =0; 
	//int index = dataFrameTail; 
	while(1)
	{		
		if(xQueueReceive( queue_dataHandler, &( packet ), 1000) == TRUE)
  40943c:	6830      	ldr	r0, [r6, #0]
  40943e:	f8df c2fc 	ldr.w	ip, [pc, #764]	; 40973c <task_dataHandler+0x344>
  409442:	a905      	add	r1, sp, #20
  409444:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  409448:	2300      	movs	r3, #0
  40944a:	47e0      	blx	ip
  40944c:	2801      	cmp	r0, #1
  40944e:	4681      	mov	r9, r0
  409450:	d159      	bne.n	409506 <task_dataHandler+0x10e>
		{			
			//handle packet
			if(packet.type == DATA_PACKET_TYPE_IMU && accelFramesToWrite == 0)
  409452:	f89d 3014 	ldrb.w	r3, [sp, #20]
  409456:	2b00      	cmp	r3, #0
  409458:	f040 8093 	bne.w	409582 <task_dataHandler+0x18a>
  40945c:	f8d8 3000 	ldr.w	r3, [r8]
  409460:	2b00      	cmp	r3, #0
  409462:	d161      	bne.n	409528 <task_dataHandler+0x130>
			{
				if(packetReceivedFlags & (uint16_t)(1 << packet.imuId))
  409464:	f89d 2015 	ldrb.w	r2, [sp, #21]
  409468:	f8b5 a000 	ldrh.w	sl, [r5]
  40946c:	fa00 f902 	lsl.w	r9, r0, r2
  409470:	ea1a 0f09 	tst.w	sl, r9
  409474:	f000 816a 	beq.w	40974c <task_dataHandler+0x354>
				{
					//we've already received data for this sensor, copy over it...
						memcpy(&packetBuffer[packet.imuId],&packet, sizeof(dataPacket_t));
  409478:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  40947c:	f8df c2a8 	ldr.w	ip, [pc, #680]	; 409728 <task_dataHandler+0x330>
  409480:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
  409484:	4494      	add	ip, r2
  409486:	f10d 0914 	add.w	r9, sp, #20
  40948a:	46ce      	mov	lr, r9
  40948c:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
  409490:	f8cc 0000 	str.w	r0, [ip]
  409494:	f8cc 1004 	str.w	r1, [ip, #4]
  409498:	f8cc 2008 	str.w	r2, [ip, #8]
  40949c:	f8cc 300c 	str.w	r3, [ip, #12]
  4094a0:	9803      	ldr	r0, [sp, #12]
  4094a2:	4586      	cmp	lr, r0
  4094a4:	46f1      	mov	r9, lr
  4094a6:	f10c 0c10 	add.w	ip, ip, #16
  4094aa:	d1ee      	bne.n	40948a <task_dataHandler+0x92>
						imuConfig[packet.imuIndex].stats.droppedPackets++; //we're dropping a packet. 	TODO must fix this case	
  4094ac:	f89d 3016 	ldrb.w	r3, [sp, #22]
  4094b0:	4993      	ldr	r1, [pc, #588]	; (409700 <task_dataHandler+0x308>)
			if(packet.type == DATA_PACKET_TYPE_IMU && accelFramesToWrite == 0)
			{
				if(packetReceivedFlags & (uint16_t)(1 << packet.imuId))
				{
					//we've already received data for this sensor, copy over it...
						memcpy(&packetBuffer[packet.imuId],&packet, sizeof(dataPacket_t));
  4094b2:	f8be 2000 	ldrh.w	r2, [lr]
  4094b6:	f89e 0002 	ldrb.w	r0, [lr, #2]
  4094ba:	f8ac 2000 	strh.w	r2, [ip]
						imuConfig[packet.imuIndex].stats.droppedPackets++; //we're dropping a packet. 	TODO must fix this case	
  4094be:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
  4094c2:	eb01 02c3 	add.w	r2, r1, r3, lsl #3
  4094c6:	4653      	mov	r3, sl
  4094c8:	6a91      	ldr	r1, [r2, #40]	; 0x28
			if(packet.type == DATA_PACKET_TYPE_IMU && accelFramesToWrite == 0)
			{
				if(packetReceivedFlags & (uint16_t)(1 << packet.imuId))
				{
					//we've already received data for this sensor, copy over it...
						memcpy(&packetBuffer[packet.imuId],&packet, sizeof(dataPacket_t));
  4094ca:	f88c 0002 	strb.w	r0, [ip, #2]
						imuConfig[packet.imuIndex].stats.droppedPackets++; //we're dropping a packet. 	TODO must fix this case	
  4094ce:	3101      	adds	r1, #1
  4094d0:	6291      	str	r1, [r2, #40]	; 0x28
				{
					buttonEvent = TRUE;
				}
			}
			
			if((packetReceivedFlags == packetReceivedMask) || (vframeTimeOutFlag == 1))
  4094d2:	498c      	ldr	r1, [pc, #560]	; (409704 <task_dataHandler+0x30c>)
  4094d4:	880a      	ldrh	r2, [r1, #0]
  4094d6:	b292      	uxth	r2, r2
  4094d8:	429a      	cmp	r2, r3
  4094da:	d02b      	beq.n	409534 <task_dataHandler+0x13c>
  4094dc:	f8df c234 	ldr.w	ip, [pc, #564]	; 409714 <task_dataHandler+0x31c>
  4094e0:	f89c 2000 	ldrb.w	r2, [ip]
  4094e4:	2a01      	cmp	r2, #1
  4094e6:	f000 8095 	beq.w	409614 <task_dataHandler+0x21c>
					//clear flag at the end
					packetReceivedFlags = 0x0000;
				}				
			}				
			//if we're currently writing 
			if(accelFramesToWrite > 0)
  4094ea:	f8d8 3000 	ldr.w	r3, [r8]
  4094ee:	b153      	cbz	r3, 409506 <task_dataHandler+0x10e>
			{
				if(accelPacketReceivedFlags == accelPacketReceivedMask)
  4094f0:	4a85      	ldr	r2, [pc, #532]	; (409708 <task_dataHandler+0x310>)
  4094f2:	f8df c238 	ldr.w	ip, [pc, #568]	; 40972c <task_dataHandler+0x334>
  4094f6:	8813      	ldrh	r3, [r2, #0]
  4094f8:	f8bc 2000 	ldrh.w	r2, [ip]
  4094fc:	b29b      	uxth	r3, r3
  4094fe:	429a      	cmp	r2, r3
  409500:	46e1      	mov	r9, ip
  409502:	f000 814c 	beq.w	40979e <task_dataHandler+0x3a6>
						task_stateMachine_EnqueueEvent(SYS_EVENT_GET_ACCEL_DATA_COMPLETE,0x00); 
					}
				}
			}						
		}		
		vTaskDelay(1);
  409506:	2001      	movs	r0, #1
  409508:	47b8      	blx	r7
	}
  40950a:	e797      	b.n	40943c <task_dataHandler+0x44>
					memcpy(&packetBuffer[NUMBER_OF_SENSORS -1],&packet, sizeof(dataPacket_t));
					packetReceivedFlags |= (1 << NUMBER_OF_SENSORS -1); //set flag
				}				
			}
			
			else if (packet.type == DATA_PACKET_TYPE_BUTTON && getCurrentState() == SYS_STATE_RECORDING)	//process the button event only while recording
  40950c:	2b05      	cmp	r3, #5
  40950e:	d10b      	bne.n	409528 <task_dataHandler+0x130>
  409510:	4b7e      	ldr	r3, [pc, #504]	; (40970c <task_dataHandler+0x314>)
  409512:	4798      	blx	r3
  409514:	2804      	cmp	r0, #4
  409516:	d107      	bne.n	409528 <task_dataHandler+0x130>
			{
				if (sentFirstFrame == TRUE)
  409518:	f8df c200 	ldr.w	ip, [pc, #512]	; 40971c <task_dataHandler+0x324>
  40951c:	f89c 3000 	ldrb.w	r3, [ip]
  409520:	b113      	cbz	r3, 409528 <task_dataHandler+0x130>
				{
					buttonEvent = TRUE;
  409522:	487b      	ldr	r0, [pc, #492]	; (409710 <task_dataHandler+0x318>)
  409524:	f880 9000 	strb.w	r9, [r0]
  409528:	882b      	ldrh	r3, [r5, #0]
				}
			}
			
			if((packetReceivedFlags == packetReceivedMask) || (vframeTimeOutFlag == 1))
  40952a:	4976      	ldr	r1, [pc, #472]	; (409704 <task_dataHandler+0x30c>)
  40952c:	880a      	ldrh	r2, [r1, #0]
  40952e:	b292      	uxth	r2, r2
  409530:	429a      	cmp	r2, r3
  409532:	d1d3      	bne.n	4094dc <task_dataHandler+0xe4>
			{
				
				if(vframeTimeOutFlag == 1)
  409534:	4877      	ldr	r0, [pc, #476]	; (409714 <task_dataHandler+0x31c>)
  409536:	7802      	ldrb	r2, [r0, #0]
  409538:	2a01      	cmp	r2, #1
  40953a:	d06b      	beq.n	409614 <task_dataHandler+0x21c>
							missingSensorPacketCounts[i] = 0;
						}						
					}					
				}
 				vframeTimeOutFlag = 0; 	
 				xTimerReset(frameTimeOutTimer, 0);
  40953c:	496c      	ldr	r1, [pc, #432]	; (4096f0 <task_dataHandler+0x2f8>)
						{
							missingSensorPacketCounts[i] = 0;
						}						
					}					
				}
 				vframeTimeOutFlag = 0; 	
  40953e:	4a75      	ldr	r2, [pc, #468]	; (409714 <task_dataHandler+0x31c>)
 				xTimerReset(frameTimeOutTimer, 0);
  409540:	4b75      	ldr	r3, [pc, #468]	; (409718 <task_dataHandler+0x320>)
  409542:	f8d1 a000 	ldr.w	sl, [r1]
						{
							missingSensorPacketCounts[i] = 0;
						}						
					}					
				}
 				vframeTimeOutFlag = 0; 	
  409546:	f04f 0900 	mov.w	r9, #0
  40954a:	f882 9000 	strb.w	r9, [r2]
 				xTimerReset(frameTimeOutTimer, 0);
  40954e:	4798      	blx	r3
  409550:	464b      	mov	r3, r9
  409552:	4602      	mov	r2, r0
  409554:	f8cd 9000 	str.w	r9, [sp]
  409558:	4650      	mov	r0, sl
  40955a:	4649      	mov	r1, r9
  40955c:	f8df c1e0 	ldr.w	ip, [pc, #480]	; 409740 <task_dataHandler+0x348>
  409560:	47e0      	blx	ip
 				if (packetReceivedFlags == packetReceivedMask)
  409562:	4868      	ldr	r0, [pc, #416]	; (409704 <task_dataHandler+0x30c>)
  409564:	882a      	ldrh	r2, [r5, #0]
  409566:	8803      	ldrh	r3, [r0, #0]
  409568:	b29b      	uxth	r3, r3
  40956a:	429a      	cmp	r2, r3
  40956c:	f000 812c 	beq.w	4097c8 <task_dataHandler+0x3d0>
						drv_led_set(DRV_LED_RED, DRV_LED_SOLID);	
						sentFirstFrame = TRUE;
					}	 				
					sentReconnectToQuintics = FALSE; 
 				}
 				if (sentFirstFrame == TRUE)
  409570:	486a      	ldr	r0, [pc, #424]	; (40971c <task_dataHandler+0x324>)
  409572:	7803      	ldrb	r3, [r0, #0]
  409574:	2b00      	cmp	r3, #0
  409576:	d0b8      	beq.n	4094ea <task_dataHandler+0xf2>
 				{
					processPackets();
  409578:	4969      	ldr	r1, [pc, #420]	; (409720 <task_dataHandler+0x328>)
  40957a:	4788      	blx	r1
					//clear flag at the end
					packetReceivedFlags = 0x0000;
  40957c:	2300      	movs	r3, #0
  40957e:	802b      	strh	r3, [r5, #0]
  409580:	e7b3      	b.n	4094ea <task_dataHandler+0xf2>
						memcpy(&packetBuffer[packet.imuId],&packet, sizeof(dataPacket_t));
						packetReceivedFlags |= (1 << packet.imuId); //set flag
					}
				}	
			}
			else if(packet.type == DATA_PACKET_TYPE_ACCEL && accelFramesToWrite > 0)
  409582:	2b03      	cmp	r3, #3
  409584:	d06c      	beq.n	409660 <task_dataHandler+0x268>
			{
				memcpy(&packetBuffer[packet.imuId],&packet, sizeof(dataPacket_t));
				accelPacketReceivedFlags |= (1 << packet.imuId); //set flag								
			}
			
			else if(packet.type == DATA_PACKET_TYPE_SS && accelFramesToWrite == 0)
  409586:	2b01      	cmp	r3, #1
  409588:	d1c0      	bne.n	40950c <task_dataHandler+0x114>
  40958a:	f8d8 3000 	ldr.w	r3, [r8]
  40958e:	2b00      	cmp	r3, #0
  409590:	d1ca      	bne.n	409528 <task_dataHandler+0x130>
			{
				if(packetReceivedFlags & (uint16_t)(1 << NUMBER_OF_SENSORS -1))
  409592:	f8b5 9000 	ldrh.w	r9, [r5]
				{
					//we've already received data for this sensor, process all the bytes as is.	
					memcpy(&packetBuffer[NUMBER_OF_SENSORS -1],&packet, sizeof(dataPacket_t));				
  409596:	f8df c1ac 	ldr.w	ip, [pc, #428]	; 409744 <task_dataHandler+0x34c>
				accelPacketReceivedFlags |= (1 << packet.imuId); //set flag								
			}
			
			else if(packet.type == DATA_PACKET_TYPE_SS && accelFramesToWrite == 0)
			{
				if(packetReceivedFlags & (uint16_t)(1 << NUMBER_OF_SENSORS -1))
  40959a:	f419 7f00 	tst.w	r9, #512	; 0x200
				{
					//we've already received data for this sensor, process all the bytes as is.	
					memcpy(&packetBuffer[NUMBER_OF_SENSORS -1],&packet, sizeof(dataPacket_t));				
  40959e:	f10d 0a14 	add.w	sl, sp, #20
				accelPacketReceivedFlags |= (1 << packet.imuId); //set flag								
			}
			
			else if(packet.type == DATA_PACKET_TYPE_SS && accelFramesToWrite == 0)
			{
				if(packetReceivedFlags & (uint16_t)(1 << NUMBER_OF_SENSORS -1))
  4095a2:	d01a      	beq.n	4095da <task_dataHandler+0x1e2>
				{
					//we've already received data for this sensor, process all the bytes as is.	
					memcpy(&packetBuffer[NUMBER_OF_SENSORS -1],&packet, sizeof(dataPacket_t));				
  4095a4:	46d6      	mov	lr, sl
  4095a6:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
  4095aa:	f8cc 0000 	str.w	r0, [ip]
  4095ae:	f8cc 1004 	str.w	r1, [ip, #4]
  4095b2:	f8cc 2008 	str.w	r2, [ip, #8]
  4095b6:	f8cc 300c 	str.w	r3, [ip, #12]
  4095ba:	9903      	ldr	r1, [sp, #12]
  4095bc:	458e      	cmp	lr, r1
  4095be:	46f2      	mov	sl, lr
  4095c0:	f10c 0c10 	add.w	ip, ip, #16
  4095c4:	d1ee      	bne.n	4095a4 <task_dataHandler+0x1ac>
  4095c6:	f8be 3000 	ldrh.w	r3, [lr]
  4095ca:	f89e 2002 	ldrb.w	r2, [lr, #2]
  4095ce:	f88c 2002 	strb.w	r2, [ip, #2]
  4095d2:	f8ac 3000 	strh.w	r3, [ip]
  4095d6:	464b      	mov	r3, r9
  4095d8:	e77b      	b.n	4094d2 <task_dataHandler+0xda>
				}
				else
				{
					//FabSense data always stored at end of buffer
					memcpy(&packetBuffer[NUMBER_OF_SENSORS -1],&packet, sizeof(dataPacket_t));
  4095da:	46d6      	mov	lr, sl
  4095dc:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
  4095e0:	f8cc 0000 	str.w	r0, [ip]
  4095e4:	f8cc 1004 	str.w	r1, [ip, #4]
  4095e8:	f8cc 2008 	str.w	r2, [ip, #8]
  4095ec:	f8cc 300c 	str.w	r3, [ip, #12]
  4095f0:	9a03      	ldr	r2, [sp, #12]
  4095f2:	4596      	cmp	lr, r2
  4095f4:	46f2      	mov	sl, lr
  4095f6:	f10c 0c10 	add.w	ip, ip, #16
  4095fa:	d1ee      	bne.n	4095da <task_dataHandler+0x1e2>
  4095fc:	f8be 1000 	ldrh.w	r1, [lr]
  409600:	f89e 2002 	ldrb.w	r2, [lr, #2]
					packetReceivedFlags |= (1 << NUMBER_OF_SENSORS -1); //set flag
  409604:	f449 7300 	orr.w	r3, r9, #512	; 0x200
  409608:	802b      	strh	r3, [r5, #0]
					memcpy(&packetBuffer[NUMBER_OF_SENSORS -1],&packet, sizeof(dataPacket_t));				
				}
				else
				{
					//FabSense data always stored at end of buffer
					memcpy(&packetBuffer[NUMBER_OF_SENSORS -1],&packet, sizeof(dataPacket_t));
  40960a:	f8ac 1000 	strh.w	r1, [ip]
  40960e:	f88c 2002 	strb.w	r2, [ip, #2]
  409612:	e75e      	b.n	4094d2 <task_dataHandler+0xda>
				{
					//make sure the index is alright. 
					if(packet.imuId < NUMBER_OF_SENSORS)
					{
						memcpy(&packetBuffer[packet.imuId],&packet, sizeof(dataPacket_t));
						packetReceivedFlags |= (1 << packet.imuId); //set flag
  409614:	f04f 0a00 	mov.w	sl, #0
  409618:	46d1      	mov	r9, sl
								}
							}	
						}
						else
						{
							missingSensorPacketCounts[i] = 0;
  40961a:	46d3      	mov	fp, sl
  40961c:	e019      	b.n	409652 <task_dataHandler+0x25a>
					//since this is an incomplete frame, tally the total lost frames count
					for(i=0;i<NUMBER_OF_SENSORS;i++)
					{
						if(((packetReceivedFlags >> i) & 0x0001) == 0)
						{
							missingSensorPacketCounts[i]++;
  40961e:	f834 300a 	ldrh.w	r3, [r4, sl]
  409622:	3301      	adds	r3, #1
  409624:	b29b      	uxth	r3, r3
							if(missingSensorPacketCounts[i] > PACKET_LOSS_COUNT_FOR_RECONNECT)
  409626:	2b14      	cmp	r3, #20
					//since this is an incomplete frame, tally the total lost frames count
					for(i=0;i<NUMBER_OF_SENSORS;i++)
					{
						if(((packetReceivedFlags >> i) & 0x0001) == 0)
						{
							missingSensorPacketCounts[i]++;
  409628:	f824 300a 	strh.w	r3, [r4, sl]
							if(missingSensorPacketCounts[i] > PACKET_LOSS_COUNT_FOR_RECONNECT)
  40962c:	d908      	bls.n	409640 <task_dataHandler+0x248>
							{
								//send the connect command. 								
								if(sentReconnectToQuintics == FALSE)
  40962e:	493d      	ldr	r1, [pc, #244]	; (409724 <task_dataHandler+0x32c>)
  409630:	780a      	ldrb	r2, [r1, #0]
								{							
									sentReconnectToQuintics = TRUE;
  409632:	2101      	movs	r1, #1
						{
							missingSensorPacketCounts[i]++;
							if(missingSensorPacketCounts[i] > PACKET_LOSS_COUNT_FOR_RECONNECT)
							{
								//send the connect command. 								
								if(sentReconnectToQuintics == FALSE)
  409634:	b90a      	cbnz	r2, 40963a <task_dataHandler+0x242>
								{							
									sentReconnectToQuintics = TRUE;
  409636:	4a3b      	ldr	r2, [pc, #236]	; (409724 <task_dataHandler+0x32c>)
  409638:	7011      	strb	r1, [r2, #0]
								}
								if (missingSensorPacketCounts[i] >= PACKET_LOSS_COUNT_FOR_ERROR)	//if sensor stays disconnected for more than 100 frames
  40963a:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
  40963e:	d241      	bcs.n	4096c4 <task_dataHandler+0x2cc>
			{
				
				if(vframeTimeOutFlag == 1)
				{
					//since this is an incomplete frame, tally the total lost frames count
					for(i=0;i<NUMBER_OF_SENSORS;i++)
  409640:	f109 0901 	add.w	r9, r9, #1
  409644:	f1b9 0f0a 	cmp.w	r9, #10
  409648:	f10a 0a02 	add.w	sl, sl, #2
  40964c:	f43f af76 	beq.w	40953c <task_dataHandler+0x144>
  409650:	882b      	ldrh	r3, [r5, #0]
					{
						if(((packetReceivedFlags >> i) & 0x0001) == 0)
  409652:	fa43 f309 	asr.w	r3, r3, r9
  409656:	07db      	lsls	r3, r3, #31
  409658:	d5e1      	bpl.n	40961e <task_dataHandler+0x226>
								}
							}	
						}
						else
						{
							missingSensorPacketCounts[i] = 0;
  40965a:	f824 b00a 	strh.w	fp, [r4, sl]
  40965e:	e7ef      	b.n	409640 <task_dataHandler+0x248>
						memcpy(&packetBuffer[packet.imuId],&packet, sizeof(dataPacket_t));
						packetReceivedFlags |= (1 << packet.imuId); //set flag
					}
				}	
			}
			else if(packet.type == DATA_PACKET_TYPE_ACCEL && accelFramesToWrite > 0)
  409660:	f8d8 3000 	ldr.w	r3, [r8]
  409664:	2b00      	cmp	r3, #0
  409666:	f43f af5f 	beq.w	409528 <task_dataHandler+0x130>
			{
				memcpy(&packetBuffer[packet.imuId],&packet, sizeof(dataPacket_t));
  40966a:	f89d a015 	ldrb.w	sl, [sp, #21]
  40966e:	4b2e      	ldr	r3, [pc, #184]	; (409728 <task_dataHandler+0x330>)
  409670:	eb0a 0c8a 	add.w	ip, sl, sl, lsl #2
  409674:	ebcc 0ccc 	rsb	ip, ip, ip, lsl #3
  409678:	449c      	add	ip, r3
  40967a:	f10d 0914 	add.w	r9, sp, #20
  40967e:	46ce      	mov	lr, r9
  409680:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
  409684:	f8cc 0000 	str.w	r0, [ip]
  409688:	f8cc 1004 	str.w	r1, [ip, #4]
  40968c:	f8cc 2008 	str.w	r2, [ip, #8]
  409690:	f8cc 300c 	str.w	r3, [ip, #12]
  409694:	9803      	ldr	r0, [sp, #12]
  409696:	4586      	cmp	lr, r0
  409698:	46f1      	mov	r9, lr
  40969a:	f10c 0c10 	add.w	ip, ip, #16
  40969e:	d1ee      	bne.n	40967e <task_dataHandler+0x286>
				accelPacketReceivedFlags |= (1 << packet.imuId); //set flag								
  4096a0:	4a22      	ldr	r2, [pc, #136]	; (40972c <task_dataHandler+0x334>)
  4096a2:	4822      	ldr	r0, [pc, #136]	; (40972c <task_dataHandler+0x334>)
  4096a4:	8813      	ldrh	r3, [r2, #0]
					}
				}	
			}
			else if(packet.type == DATA_PACKET_TYPE_ACCEL && accelFramesToWrite > 0)
			{
				memcpy(&packetBuffer[packet.imuId],&packet, sizeof(dataPacket_t));
  4096a6:	f8be 2000 	ldrh.w	r2, [lr]
				accelPacketReceivedFlags |= (1 << packet.imuId); //set flag								
  4096aa:	2101      	movs	r1, #1
  4096ac:	fa01 f10a 	lsl.w	r1, r1, sl
  4096b0:	4319      	orrs	r1, r3
					}
				}	
			}
			else if(packet.type == DATA_PACKET_TYPE_ACCEL && accelFramesToWrite > 0)
			{
				memcpy(&packetBuffer[packet.imuId],&packet, sizeof(dataPacket_t));
  4096b2:	f89e 3002 	ldrb.w	r3, [lr, #2]
				accelPacketReceivedFlags |= (1 << packet.imuId); //set flag								
  4096b6:	8001      	strh	r1, [r0, #0]
					}
				}	
			}
			else if(packet.type == DATA_PACKET_TYPE_ACCEL && accelFramesToWrite > 0)
			{
				memcpy(&packetBuffer[packet.imuId],&packet, sizeof(dataPacket_t));
  4096b8:	f8ac 2000 	strh.w	r2, [ip]
  4096bc:	f88c 3002 	strb.w	r3, [ip, #2]
  4096c0:	882b      	ldrh	r3, [r5, #0]
  4096c2:	e732      	b.n	40952a <task_dataHandler+0x132>
									sentReconnectToQuintics = TRUE;
								}
								if (missingSensorPacketCounts[i] >= PACKET_LOSS_COUNT_FOR_ERROR)	//if sensor stays disconnected for more than 100 frames
								{
									missingSensorPacketCounts[i] = 0;
									debugPrintStringInt("Connection try out\r\n", i);
  4096c4:	4649      	mov	r1, r9
  4096c6:	481a      	ldr	r0, [pc, #104]	; (409730 <task_dataHandler+0x338>)
								{							
									sentReconnectToQuintics = TRUE;
								}
								if (missingSensorPacketCounts[i] >= PACKET_LOSS_COUNT_FOR_ERROR)	//if sensor stays disconnected for more than 100 frames
								{
									missingSensorPacketCounts[i] = 0;
  4096c8:	f824 b00a 	strh.w	fp, [r4, sl]
									debugPrintStringInt("Connection try out\r\n", i);
  4096cc:	4b19      	ldr	r3, [pc, #100]	; (409734 <task_dataHandler+0x33c>)
  4096ce:	4798      	blx	r3
									task_stateMachine_EnqueueEvent(SYS_EVENT_IMU_DISCONNECT, 0x00);	//Send IMU_DISCONNECT event
  4096d0:	2100      	movs	r1, #0
  4096d2:	f8df c074 	ldr.w	ip, [pc, #116]	; 409748 <task_dataHandler+0x350>
  4096d6:	2006      	movs	r0, #6
  4096d8:	47e0      	blx	ip
  4096da:	e7b1      	b.n	409640 <task_dataHandler+0x248>
  4096dc:	00406901 	.word	0x00406901
  4096e0:	20003874 	.word	0x20003874
  4096e4:	00409291 	.word	0x00409291
  4096e8:	00416794 	.word	0x00416794
  4096ec:	004078fd 	.word	0x004078fd
  4096f0:	20004ec0 	.word	0x20004ec0
  4096f4:	20004eac 	.word	0x20004eac
  4096f8:	2000386c 	.word	0x2000386c
  4096fc:	004072ed 	.word	0x004072ed
  409700:	2000031c 	.word	0x2000031c
  409704:	200037a0 	.word	0x200037a0
  409708:	2000387c 	.word	0x2000387c
  40970c:	00401c29 	.word	0x00401c29
  409710:	2000386e 	.word	0x2000386e
  409714:	20003870 	.word	0x20003870
  409718:	004070a1 	.word	0x004070a1
  40971c:	20003878 	.word	0x20003878
  409720:	0040929d 	.word	0x0040929d
  409724:	2000386f 	.word	0x2000386f
  409728:	20004ec4 	.word	0x20004ec4
  40972c:	2000387a 	.word	0x2000387a
  409730:	004167cc 	.word	0x004167cc
  409734:	004007b5 	.word	0x004007b5
  409738:	20003884 	.word	0x20003884
  40973c:	00406b35 	.word	0x00406b35
  409740:	00407949 	.word	0x00407949
  409744:	20004fff 	.word	0x20004fff
  409748:	00401a99 	.word	0x00401a99
						imuConfig[packet.imuIndex].stats.droppedPackets++; //we're dropping a packet. 	TODO must fix this case	
				}
				else
				{
					//make sure the index is alright. 
					if(packet.imuId < NUMBER_OF_SENSORS)
  40974c:	2a09      	cmp	r2, #9
  40974e:	d855      	bhi.n	4097fc <task_dataHandler+0x404>
					{
						memcpy(&packetBuffer[packet.imuId],&packet, sizeof(dataPacket_t));
  409750:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  409754:	f8df c0cc 	ldr.w	ip, [pc, #204]	; 409824 <task_dataHandler+0x42c>
  409758:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
  40975c:	4494      	add	ip, r2
  40975e:	f10d 0b14 	add.w	fp, sp, #20
  409762:	46de      	mov	lr, fp
  409764:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
  409768:	f8cc 0000 	str.w	r0, [ip]
  40976c:	f8cc 1004 	str.w	r1, [ip, #4]
  409770:	f8cc 2008 	str.w	r2, [ip, #8]
  409774:	f8cc 300c 	str.w	r3, [ip, #12]
  409778:	9a03      	ldr	r2, [sp, #12]
  40977a:	4596      	cmp	lr, r2
  40977c:	46f3      	mov	fp, lr
  40977e:	f10c 0c10 	add.w	ip, ip, #16
  409782:	d1ee      	bne.n	409762 <task_dataHandler+0x36a>
						packetReceivedFlags |= (1 << packet.imuId); //set flag
  409784:	ea49 030a 	orr.w	r3, r9, sl
				else
				{
					//make sure the index is alright. 
					if(packet.imuId < NUMBER_OF_SENSORS)
					{
						memcpy(&packetBuffer[packet.imuId],&packet, sizeof(dataPacket_t));
  409788:	f8be 1000 	ldrh.w	r1, [lr]
  40978c:	f89e 2002 	ldrb.w	r2, [lr, #2]
						packetReceivedFlags |= (1 << packet.imuId); //set flag
  409790:	b29b      	uxth	r3, r3
  409792:	802b      	strh	r3, [r5, #0]
				else
				{
					//make sure the index is alright. 
					if(packet.imuId < NUMBER_OF_SENSORS)
					{
						memcpy(&packetBuffer[packet.imuId],&packet, sizeof(dataPacket_t));
  409794:	f8ac 1000 	strh.w	r1, [ip]
  409798:	f88c 2002 	strb.w	r2, [ip, #2]
  40979c:	e699      	b.n	4094d2 <task_dataHandler+0xda>
			if(accelFramesToWrite > 0)
			{
				if(accelPacketReceivedFlags == accelPacketReceivedMask)
				{
					//set the last packet to be stretchsense. 
					packetBuffer[NUMBER_OF_SENSORS -1].type = DATA_PACKET_TYPE_SS; 
  40979e:	4821      	ldr	r0, [pc, #132]	; (409824 <task_dataHandler+0x42c>)
					processPackets(); 
  4097a0:	4921      	ldr	r1, [pc, #132]	; (409828 <task_dataHandler+0x430>)
			if(accelFramesToWrite > 0)
			{
				if(accelPacketReceivedFlags == accelPacketReceivedMask)
				{
					//set the last packet to be stretchsense. 
					packetBuffer[NUMBER_OF_SENSORS -1].type = DATA_PACKET_TYPE_SS; 
  4097a2:	2301      	movs	r3, #1
  4097a4:	f880 313b 	strb.w	r3, [r0, #315]	; 0x13b
					processPackets(); 
  4097a8:	4788      	blx	r1
					//clear flag at the end
					accelPacketReceivedFlags = 0x0000;
					accelFramesToWrite--;
  4097aa:	4a20      	ldr	r2, [pc, #128]	; (40982c <task_dataHandler+0x434>)
  4097ac:	6813      	ldr	r3, [r2, #0]
  4097ae:	3b01      	subs	r3, #1
  4097b0:	6013      	str	r3, [r2, #0]
					if(accelFramesToWrite == 0)
  4097b2:	6811      	ldr	r1, [r2, #0]
				{
					//set the last packet to be stretchsense. 
					packetBuffer[NUMBER_OF_SENSORS -1].type = DATA_PACKET_TYPE_SS; 
					processPackets(); 
					//clear flag at the end
					accelPacketReceivedFlags = 0x0000;
  4097b4:	2300      	movs	r3, #0
  4097b6:	f8a9 3000 	strh.w	r3, [r9]
					accelFramesToWrite--;
					if(accelFramesToWrite == 0)
  4097ba:	2900      	cmp	r1, #0
  4097bc:	f47f aea3 	bne.w	409506 <task_dataHandler+0x10e>
					{
						task_stateMachine_EnqueueEvent(SYS_EVENT_GET_ACCEL_DATA_COMPLETE,0x00); 
  4097c0:	4b1b      	ldr	r3, [pc, #108]	; (409830 <task_dataHandler+0x438>)
  4097c2:	200d      	movs	r0, #13
  4097c4:	4798      	blx	r3
  4097c6:	e69e      	b.n	409506 <task_dataHandler+0x10e>
 				xTimerReset(frameTimeOutTimer, 0);
 				if (packetReceivedFlags == packetReceivedMask)
 				{
					//set all the missing packet counts to zero. 
					memset(missingSensorPacketCounts, 0,sizeof(missingSensorPacketCounts)); 					
					if(sentFirstFrame == FALSE)
  4097c8:	491a      	ldr	r1, [pc, #104]	; (409834 <task_dataHandler+0x43c>)
 				vframeTimeOutFlag = 0; 	
 				xTimerReset(frameTimeOutTimer, 0);
 				if (packetReceivedFlags == packetReceivedMask)
 				{
					//set all the missing packet counts to zero. 
					memset(missingSensorPacketCounts, 0,sizeof(missingSensorPacketCounts)); 					
  4097ca:	4a1b      	ldr	r2, [pc, #108]	; (409838 <task_dataHandler+0x440>)
					if(sentFirstFrame == FALSE)
  4097cc:	7808      	ldrb	r0, [r1, #0]
 				vframeTimeOutFlag = 0; 	
 				xTimerReset(frameTimeOutTimer, 0);
 				if (packetReceivedFlags == packetReceivedMask)
 				{
					//set all the missing packet counts to zero. 
					memset(missingSensorPacketCounts, 0,sizeof(missingSensorPacketCounts)); 					
  4097ce:	f8c4 9000 	str.w	r9, [r4]
  4097d2:	f8c2 9000 	str.w	r9, [r2]
  4097d6:	f8c2 9004 	str.w	r9, [r2, #4]
  4097da:	f8c2 9008 	str.w	r9, [r2, #8]
  4097de:	f8c2 900c 	str.w	r9, [r2, #12]
					if(sentFirstFrame == FALSE)
  4097e2:	f8df 9050 	ldr.w	r9, [pc, #80]	; 409834 <task_dataHandler+0x43c>
  4097e6:	b158      	cbz	r0, 409800 <task_dataHandler+0x408>
					{
						drv_led_set(DRV_LED_RED, DRV_LED_SOLID);	
						sentFirstFrame = TRUE;
					}	 				
					sentReconnectToQuintics = FALSE; 
  4097e8:	f8df c060 	ldr.w	ip, [pc, #96]	; 40984c <task_dataHandler+0x454>
 				}
 				if (sentFirstFrame == TRUE)
 				{
					processPackets();
  4097ec:	490e      	ldr	r1, [pc, #56]	; (409828 <task_dataHandler+0x430>)
					if(sentFirstFrame == FALSE)
					{
						drv_led_set(DRV_LED_RED, DRV_LED_SOLID);	
						sentFirstFrame = TRUE;
					}	 				
					sentReconnectToQuintics = FALSE; 
  4097ee:	2300      	movs	r3, #0
  4097f0:	f88c 3000 	strb.w	r3, [ip]
 				}
 				if (sentFirstFrame == TRUE)
 				{
					processPackets();
  4097f4:	4788      	blx	r1
					//clear flag at the end
					packetReceivedFlags = 0x0000;
  4097f6:	2300      	movs	r3, #0
  4097f8:	802b      	strh	r3, [r5, #0]
  4097fa:	e676      	b.n	4094ea <task_dataHandler+0xf2>
		if(xQueueReceive( queue_dataHandler, &( packet ), 1000) == TRUE)
		{			
			//handle packet
			if(packet.type == DATA_PACKET_TYPE_IMU && accelFramesToWrite == 0)
			{
				if(packetReceivedFlags & (uint16_t)(1 << packet.imuId))
  4097fc:	4653      	mov	r3, sl
  4097fe:	e668      	b.n	4094d2 <task_dataHandler+0xda>
 				{
					//set all the missing packet counts to zero. 
					memset(missingSensorPacketCounts, 0,sizeof(missingSensorPacketCounts)); 					
					if(sentFirstFrame == FALSE)
					{
						drv_led_set(DRV_LED_RED, DRV_LED_SOLID);	
  409800:	2101      	movs	r1, #1
  409802:	4a0e      	ldr	r2, [pc, #56]	; (40983c <task_dataHandler+0x444>)
  409804:	4790      	blx	r2
						sentFirstFrame = TRUE;
  409806:	2301      	movs	r3, #1
  409808:	f889 3000 	strb.w	r3, [r9]
  40980c:	e7ec      	b.n	4097e8 <task_dataHandler+0x3f0>
	int timerId = 0;

	frameTimeOutTimer = xTimerCreate("Frame Time Out Timer", (PACKET_WAIT_TIMEOUT/portTICK_RATE_MS), pdFALSE, NULL, vframeTimeOutTimerCallback);
	if (frameTimeOutTimer == NULL)
	{
		debugPrintString("Failed to create timer task\r\n");
  40980e:	480c      	ldr	r0, [pc, #48]	; (409840 <task_dataHandler+0x448>)
  409810:	4b0c      	ldr	r3, [pc, #48]	; (409844 <task_dataHandler+0x44c>)
  409812:	4798      	blx	r3
  409814:	e609      	b.n	40942a <task_dataHandler+0x32>
	//setup the queue
	queue_dataHandler = xQueueCreate( 50, sizeof(dataPacket_t));
	if(queue_dataHandler == 0)
	{
		// Queue was not created this is an error!
		debugPrintString("an error has occurred, data handler queue failure\r\n"); 
  409816:	480c      	ldr	r0, [pc, #48]	; (409848 <task_dataHandler+0x450>)
  409818:	4b0a      	ldr	r3, [pc, #40]	; (409844 <task_dataHandler+0x44c>)
  40981a:	4798      	blx	r3
			}						
		}		
		vTaskDelay(1);
	}
	
}
  40981c:	b00f      	add	sp, #60	; 0x3c
  40981e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  409822:	bf00      	nop
  409824:	20004ec4 	.word	0x20004ec4
  409828:	0040929d 	.word	0x0040929d
  40982c:	20003884 	.word	0x20003884
  409830:	00401a99 	.word	0x00401a99
  409834:	20003878 	.word	0x20003878
  409838:	20004eb0 	.word	0x20004eb0
  40983c:	00400699 	.word	0x00400699
  409840:	004167ac 	.word	0x004167ac
  409844:	004008c9 	.word	0x004008c9
  409848:	00416760 	.word	0x00416760
  40984c:	2000386f 	.word	0x2000386f

00409850 <task_dataProcessor_startGetAccelData>:

void task_dataProcessor_startGetAccelData(uint32_t numberOfFrames)
{
  409850:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	//this function resets the flags and clears the memory buffers before a recording.  
	sentFirstFrame = FALSE; //the system will only start streaming once all the sensor have checked in.
	memset(packetBuffer, 0x00, sizeof(packetBuffer));	
  409854:	4e19      	ldr	r6, [pc, #100]	; (4098bc <task_dataProcessor_startGetAccelData+0x6c>)
}

void task_dataProcessor_startGetAccelData(uint32_t numberOfFrames)
{
	//this function resets the flags and clears the memory buffers before a recording.  
	sentFirstFrame = FALSE; //the system will only start streaming once all the sensor have checked in.
  409856:	4d1a      	ldr	r5, [pc, #104]	; (4098c0 <task_dataProcessor_startGetAccelData+0x70>)
	memset(packetBuffer, 0x00, sizeof(packetBuffer));	
  409858:	4b1a      	ldr	r3, [pc, #104]	; (4098c4 <task_dataProcessor_startGetAccelData+0x74>)
	packetBuffer[NUMBER_OF_SENSORS -1].type = DATA_PACKET_TYPE_SS; 
	accelPacketReceivedFlags = 0x0000;
	packetReceivedFlags = 0x0000; // Set it to 0x0000 to indicate its an acceleration frame. 
	memset(missingSensorPacketCounts, 0,sizeof(missingSensorPacketCounts));
	accelFramesToWrite = numberOfFrames;
  40985a:	f8df a078 	ldr.w	sl, [pc, #120]	; 4098d4 <task_dataProcessor_startGetAccelData+0x84>
{
	//this function resets the flags and clears the memory buffers before a recording.  
	sentFirstFrame = FALSE; //the system will only start streaming once all the sensor have checked in.
	memset(packetBuffer, 0x00, sizeof(packetBuffer));	
	packetBuffer[NUMBER_OF_SENSORS -1].type = DATA_PACKET_TYPE_SS; 
	accelPacketReceivedFlags = 0x0000;
  40985e:	f8df 9078 	ldr.w	r9, [pc, #120]	; 4098d8 <task_dataProcessor_startGetAccelData+0x88>
}

void task_dataProcessor_startGetAccelData(uint32_t numberOfFrames)
{
	//this function resets the flags and clears the memory buffers before a recording.  
	sentFirstFrame = FALSE; //the system will only start streaming once all the sensor have checked in.
  409862:	2400      	movs	r4, #0
	}
	
}

void task_dataProcessor_startGetAccelData(uint32_t numberOfFrames)
{
  409864:	b082      	sub	sp, #8
  409866:	4680      	mov	r8, r0
	//this function resets the flags and clears the memory buffers before a recording.  
	sentFirstFrame = FALSE; //the system will only start streaming once all the sensor have checked in.
	memset(packetBuffer, 0x00, sizeof(packetBuffer));	
  409868:	4621      	mov	r1, r4
  40986a:	4630      	mov	r0, r6
  40986c:	f44f 72af 	mov.w	r2, #350	; 0x15e
}

void task_dataProcessor_startGetAccelData(uint32_t numberOfFrames)
{
	//this function resets the flags and clears the memory buffers before a recording.  
	sentFirstFrame = FALSE; //the system will only start streaming once all the sensor have checked in.
  409870:	702c      	strb	r4, [r5, #0]
	memset(packetBuffer, 0x00, sizeof(packetBuffer));	
  409872:	4798      	blx	r3
	packetBuffer[NUMBER_OF_SENSORS -1].type = DATA_PACKET_TYPE_SS; 
	accelPacketReceivedFlags = 0x0000;
	packetReceivedFlags = 0x0000; // Set it to 0x0000 to indicate its an acceleration frame. 
	memset(missingSensorPacketCounts, 0,sizeof(missingSensorPacketCounts));
  409874:	4b14      	ldr	r3, [pc, #80]	; (4098c8 <task_dataProcessor_startGetAccelData+0x78>)
	accelFramesToWrite = numberOfFrames;
	xTimerStop(frameTimeOutTimer, 0);
  409876:	4a15      	ldr	r2, [pc, #84]	; (4098cc <task_dataProcessor_startGetAccelData+0x7c>)
	//this function resets the flags and clears the memory buffers before a recording.  
	sentFirstFrame = FALSE; //the system will only start streaming once all the sensor have checked in.
	memset(packetBuffer, 0x00, sizeof(packetBuffer));	
	packetBuffer[NUMBER_OF_SENSORS -1].type = DATA_PACKET_TYPE_SS; 
	accelPacketReceivedFlags = 0x0000;
	packetReceivedFlags = 0x0000; // Set it to 0x0000 to indicate its an acceleration frame. 
  409878:	f8df e060 	ldr.w	lr, [pc, #96]	; 4098dc <task_dataProcessor_startGetAccelData+0x8c>
	memset(missingSensorPacketCounts, 0,sizeof(missingSensorPacketCounts));
	accelFramesToWrite = numberOfFrames;
	xTimerStop(frameTimeOutTimer, 0);
  40987c:	6810      	ldr	r0, [r2, #0]
  40987e:	9400      	str	r4, [sp, #0]
	sentFirstFrame = FALSE; //the system will only start streaming once all the sensor have checked in.
	memset(packetBuffer, 0x00, sizeof(packetBuffer));	
	packetBuffer[NUMBER_OF_SENSORS -1].type = DATA_PACKET_TYPE_SS; 
	accelPacketReceivedFlags = 0x0000;
	packetReceivedFlags = 0x0000; // Set it to 0x0000 to indicate its an acceleration frame. 
	memset(missingSensorPacketCounts, 0,sizeof(missingSensorPacketCounts));
  409880:	461d      	mov	r5, r3
void task_dataProcessor_startGetAccelData(uint32_t numberOfFrames)
{
	//this function resets the flags and clears the memory buffers before a recording.  
	sentFirstFrame = FALSE; //the system will only start streaming once all the sensor have checked in.
	memset(packetBuffer, 0x00, sizeof(packetBuffer));	
	packetBuffer[NUMBER_OF_SENSORS -1].type = DATA_PACKET_TYPE_SS; 
  409882:	2701      	movs	r7, #1
	accelPacketReceivedFlags = 0x0000;
	packetReceivedFlags = 0x0000; // Set it to 0x0000 to indicate its an acceleration frame. 
	memset(missingSensorPacketCounts, 0,sizeof(missingSensorPacketCounts));
  409884:	f845 4b04 	str.w	r4, [r5], #4
  409888:	3504      	adds	r5, #4
  40988a:	605c      	str	r4, [r3, #4]
  40988c:	f845 4b04 	str.w	r4, [r5], #4
  409890:	f845 4b04 	str.w	r4, [r5], #4
	accelFramesToWrite = numberOfFrames;
	xTimerStop(frameTimeOutTimer, 0);
  409894:	4623      	mov	r3, r4
  409896:	4639      	mov	r1, r7
  409898:	4622      	mov	r2, r4
  40989a:	f8df c044 	ldr.w	ip, [pc, #68]	; 4098e0 <task_dataProcessor_startGetAccelData+0x90>
	//this function resets the flags and clears the memory buffers before a recording.  
	sentFirstFrame = FALSE; //the system will only start streaming once all the sensor have checked in.
	memset(packetBuffer, 0x00, sizeof(packetBuffer));	
	packetBuffer[NUMBER_OF_SENSORS -1].type = DATA_PACKET_TYPE_SS; 
	accelPacketReceivedFlags = 0x0000;
	packetReceivedFlags = 0x0000; // Set it to 0x0000 to indicate its an acceleration frame. 
  40989e:	f8ae 4000 	strh.w	r4, [lr]
	memset(missingSensorPacketCounts, 0,sizeof(missingSensorPacketCounts));
  4098a2:	602c      	str	r4, [r5, #0]
	accelFramesToWrite = numberOfFrames;
  4098a4:	f8ca 8000 	str.w	r8, [sl]
void task_dataProcessor_startGetAccelData(uint32_t numberOfFrames)
{
	//this function resets the flags and clears the memory buffers before a recording.  
	sentFirstFrame = FALSE; //the system will only start streaming once all the sensor have checked in.
	memset(packetBuffer, 0x00, sizeof(packetBuffer));	
	packetBuffer[NUMBER_OF_SENSORS -1].type = DATA_PACKET_TYPE_SS; 
  4098a8:	f886 713b 	strb.w	r7, [r6, #315]	; 0x13b
	accelPacketReceivedFlags = 0x0000;
  4098ac:	f8a9 4000 	strh.w	r4, [r9]
	packetReceivedFlags = 0x0000; // Set it to 0x0000 to indicate its an acceleration frame. 
	memset(missingSensorPacketCounts, 0,sizeof(missingSensorPacketCounts));
	accelFramesToWrite = numberOfFrames;
	xTimerStop(frameTimeOutTimer, 0);
  4098b0:	47e0      	blx	ip
	vframeTimeOutFlag = 0;
  4098b2:	4b07      	ldr	r3, [pc, #28]	; (4098d0 <task_dataProcessor_startGetAccelData+0x80>)
  4098b4:	701c      	strb	r4, [r3, #0]
}
  4098b6:	b002      	add	sp, #8
  4098b8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  4098bc:	20004ec4 	.word	0x20004ec4
  4098c0:	20003878 	.word	0x20003878
  4098c4:	0040c31d 	.word	0x0040c31d
  4098c8:	20004eac 	.word	0x20004eac
  4098cc:	20004ec0 	.word	0x20004ec0
  4098d0:	20003870 	.word	0x20003870
  4098d4:	20003884 	.word	0x20003884
  4098d8:	2000387a 	.word	0x2000387a
  4098dc:	2000386c 	.word	0x2000386c
  4098e0:	00407949 	.word	0x00407949

004098e4 <task_dataProcessor_startRecording>:

void task_dataProcessor_startRecording()
{
  4098e4:	b530      	push	{r4, r5, lr}
	//this function resets the flags and clears the memory buffers before a recording. 
	sentFirstFrame = FALSE; //the system will only start streaming once all the sensor have checked in. 
  4098e6:	2400      	movs	r4, #0
  4098e8:	4d13      	ldr	r5, [pc, #76]	; (409938 <task_dataProcessor_startRecording+0x54>)
	memset(packetBuffer, 0x00, sizeof(packetBuffer));
  4098ea:	4b14      	ldr	r3, [pc, #80]	; (40993c <task_dataProcessor_startRecording+0x58>)
  4098ec:	4814      	ldr	r0, [pc, #80]	; (409940 <task_dataProcessor_startRecording+0x5c>)
}

void task_dataProcessor_startRecording()
{
	//this function resets the flags and clears the memory buffers before a recording. 
	sentFirstFrame = FALSE; //the system will only start streaming once all the sensor have checked in. 
  4098ee:	702c      	strb	r4, [r5, #0]
	xTimerStop(frameTimeOutTimer, 0);
	vframeTimeOutFlag = 0;
}

void task_dataProcessor_startRecording()
{
  4098f0:	b083      	sub	sp, #12
	//this function resets the flags and clears the memory buffers before a recording. 
	sentFirstFrame = FALSE; //the system will only start streaming once all the sensor have checked in. 
	memset(packetBuffer, 0x00, sizeof(packetBuffer));
  4098f2:	4621      	mov	r1, r4
  4098f4:	f44f 72af 	mov.w	r2, #350	; 0x15e
  4098f8:	4798      	blx	r3
	packetReceivedFlags = 0x0000;
	memset(missingSensorPacketCounts, 0,sizeof(missingSensorPacketCounts)); 
  4098fa:	4a12      	ldr	r2, [pc, #72]	; (409944 <task_dataProcessor_startRecording+0x60>)
void task_dataProcessor_startRecording()
{
	//this function resets the flags and clears the memory buffers before a recording. 
	sentFirstFrame = FALSE; //the system will only start streaming once all the sensor have checked in. 
	memset(packetBuffer, 0x00, sizeof(packetBuffer));
	packetReceivedFlags = 0x0000;
  4098fc:	4b12      	ldr	r3, [pc, #72]	; (409948 <task_dataProcessor_startRecording+0x64>)
	memset(missingSensorPacketCounts, 0,sizeof(missingSensorPacketCounts)); 
	xTimerReset(frameTimeOutTimer, 0);
  4098fe:	4913      	ldr	r1, [pc, #76]	; (40994c <task_dataProcessor_startRecording+0x68>)
void task_dataProcessor_startRecording()
{
	//this function resets the flags and clears the memory buffers before a recording. 
	sentFirstFrame = FALSE; //the system will only start streaming once all the sensor have checked in. 
	memset(packetBuffer, 0x00, sizeof(packetBuffer));
	packetReceivedFlags = 0x0000;
  409900:	801c      	strh	r4, [r3, #0]
	memset(missingSensorPacketCounts, 0,sizeof(missingSensorPacketCounts)); 
  409902:	4613      	mov	r3, r2
	xTimerReset(frameTimeOutTimer, 0);
  409904:	680d      	ldr	r5, [r1, #0]
{
	//this function resets the flags and clears the memory buffers before a recording. 
	sentFirstFrame = FALSE; //the system will only start streaming once all the sensor have checked in. 
	memset(packetBuffer, 0x00, sizeof(packetBuffer));
	packetReceivedFlags = 0x0000;
	memset(missingSensorPacketCounts, 0,sizeof(missingSensorPacketCounts)); 
  409906:	f843 4b04 	str.w	r4, [r3], #4
  40990a:	3304      	adds	r3, #4
  40990c:	6054      	str	r4, [r2, #4]
  40990e:	f843 4b04 	str.w	r4, [r3], #4
  409912:	f843 4b04 	str.w	r4, [r3], #4
	xTimerReset(frameTimeOutTimer, 0);
  409916:	490e      	ldr	r1, [pc, #56]	; (409950 <task_dataProcessor_startRecording+0x6c>)
{
	//this function resets the flags and clears the memory buffers before a recording. 
	sentFirstFrame = FALSE; //the system will only start streaming once all the sensor have checked in. 
	memset(packetBuffer, 0x00, sizeof(packetBuffer));
	packetReceivedFlags = 0x0000;
	memset(missingSensorPacketCounts, 0,sizeof(missingSensorPacketCounts)); 
  409918:	601c      	str	r4, [r3, #0]
	xTimerReset(frameTimeOutTimer, 0);
  40991a:	4788      	blx	r1
  40991c:	4623      	mov	r3, r4
  40991e:	4602      	mov	r2, r0
  409920:	9400      	str	r4, [sp, #0]
  409922:	4628      	mov	r0, r5
  409924:	4621      	mov	r1, r4
  409926:	4d0b      	ldr	r5, [pc, #44]	; (409954 <task_dataProcessor_startRecording+0x70>)
  409928:	47a8      	blx	r5
	vframeTimeOutFlag = 0;
  40992a:	4a0b      	ldr	r2, [pc, #44]	; (409958 <task_dataProcessor_startRecording+0x74>)
	accelFramesToWrite = 0; //make sure the accelFramesToWrite is zero. 
  40992c:	4b0b      	ldr	r3, [pc, #44]	; (40995c <task_dataProcessor_startRecording+0x78>)
	sentFirstFrame = FALSE; //the system will only start streaming once all the sensor have checked in. 
	memset(packetBuffer, 0x00, sizeof(packetBuffer));
	packetReceivedFlags = 0x0000;
	memset(missingSensorPacketCounts, 0,sizeof(missingSensorPacketCounts)); 
	xTimerReset(frameTimeOutTimer, 0);
	vframeTimeOutFlag = 0;
  40992e:	7014      	strb	r4, [r2, #0]
	accelFramesToWrite = 0; //make sure the accelFramesToWrite is zero. 
  409930:	601c      	str	r4, [r3, #0]
}
  409932:	b003      	add	sp, #12
  409934:	bd30      	pop	{r4, r5, pc}
  409936:	bf00      	nop
  409938:	20003878 	.word	0x20003878
  40993c:	0040c31d 	.word	0x0040c31d
  409940:	20004ec4 	.word	0x20004ec4
  409944:	20004eac 	.word	0x20004eac
  409948:	2000386c 	.word	0x2000386c
  40994c:	20004ec0 	.word	0x20004ec0
  409950:	004070a1 	.word	0x004070a1
  409954:	00407949 	.word	0x00407949
  409958:	20003870 	.word	0x20003870
  40995c:	20003884 	.word	0x20003884

00409960 <task_fabSenseHandler>:
 *	function. 
 * @param pvParameters, void pointer to structure containing fabric sense configuration. 
 * @return void
 ***********************************************************************************************/
void task_fabSenseHandler(void *pvParameters)
{
  409960:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	//cast void pointer to fabric sense config type.
	fabricSenseConfig_t *fsConfig = (fabricSenseConfig_t*)pvParameters;
	//check that uart device is initialized
	if(drv_uart_isInit(fsConfig->uartDevice) != STATUS_PASS)
  409964:	4b2c      	ldr	r3, [pc, #176]	; (409a18 <task_fabSenseHandler+0xb8>)
  409966:	6880      	ldr	r0, [r0, #8]
 *	function. 
 * @param pvParameters, void pointer to structure containing fabric sense configuration. 
 * @return void
 ***********************************************************************************************/
void task_fabSenseHandler(void *pvParameters)
{
  409968:	b0ca      	sub	sp, #296	; 0x128
	//cast void pointer to fabric sense config type.
	fabricSenseConfig_t *fsConfig = (fabricSenseConfig_t*)pvParameters;
	//check that uart device is initialized
	if(drv_uart_isInit(fsConfig->uartDevice) != STATUS_PASS)
  40996a:	4798      	blx	r3
  40996c:	4601      	mov	r1, r0
  40996e:	2800      	cmp	r0, #0
  409970:	d14b      	bne.n	409a0a <task_fabSenseHandler+0xaa>
		//return; 
	//} 
	dataPacket_t packet;
	packet.type = DATA_PACKET_TYPE_SS;
	//main loop of task, this is where we request information and store it.
	char buf[FS_RESPONSE_BUF_SIZE] = {0};
  409972:	22ff      	movs	r2, #255	; 0xff
  409974:	4b29      	ldr	r3, [pc, #164]	; (409a1c <task_fabSenseHandler+0xbc>)
  409976:	4e2a      	ldr	r6, [pc, #168]	; (409a20 <task_fabSenseHandler+0xc0>)
  409978:	4f2a      	ldr	r7, [pc, #168]	; (409a24 <task_fabSenseHandler+0xc4>)
  40997a:	f8df 80bc 	ldr.w	r8, [pc, #188]	; 409a38 <task_fabSenseHandler+0xd8>
  40997e:	f8df 90bc 	ldr.w	r9, [pc, #188]	; 409a3c <task_fabSenseHandler+0xdc>
	//{
		////this is an error, we should do something here!
		//return; 
	//} 
	dataPacket_t packet;
	packet.type = DATA_PACKET_TYPE_SS;
  409982:	2401      	movs	r4, #1
	//main loop of task, this is where we request information and store it.
	char buf[FS_RESPONSE_BUF_SIZE] = {0};
  409984:	a80a      	add	r0, sp, #40	; 0x28
	//{
		////this is an error, we should do something here!
		//return; 
	//} 
	dataPacket_t packet;
	packet.type = DATA_PACKET_TYPE_SS;
  409986:	f88d 4004 	strb.w	r4, [sp, #4]
	//main loop of task, this is where we request information and store it.
	char buf[FS_RESPONSE_BUF_SIZE] = {0};
  40998a:	4798      	blx	r3
	uint8_t numPacketsReceived = 0; 
	uint8_t dataSize = 0;
	uint32_t sequenceNumber = 0;
	uint32_t packetsReceived = 0; 
	packetReceivedMask |= 1<<9; //add mask for fabric sense
  40998c:	4b26      	ldr	r3, [pc, #152]	; (409a28 <task_fabSenseHandler+0xc8>)
  40998e:	881a      	ldrh	r2, [r3, #0]
  409990:	f442 7200 	orr.w	r2, r2, #512	; 0x200
  409994:	801a      	strh	r2, [r3, #0]
	while(1)
	{
		if(enableRecording)
		{		
			#ifdef CREATE_DUMMY_PACKETS
			vTaskDelay(20); 
  409996:	46b2      	mov	sl, r6
	uint32_t sequenceNumber = 0;
	uint32_t packetsReceived = 0; 
	packetReceivedMask |= 1<<9; //add mask for fabric sense
	while(1)
	{
		if(enableRecording)
  409998:	783b      	ldrb	r3, [r7, #0]
		{		
			#ifdef CREATE_DUMMY_PACKETS
			vTaskDelay(20); 
  40999a:	2014      	movs	r0, #20
	uint32_t sequenceNumber = 0;
	uint32_t packetsReceived = 0; 
	packetReceivedMask |= 1<<9; //add mask for fabric sense
	while(1)
	{
		if(enableRecording)
  40999c:	2b00      	cmp	r3, #0
  40999e:	d031      	beq.n	409a04 <task_fabSenseHandler+0xa4>

void createDummyFabSensePacket(char* dataPacket, size_t maxPacketSize, uint32_t seqNum)
{
	//int i = 0; 
	//snprintf(dataPacket, maxPacketSize, "%04dBBBBCCCCDDDDEEEE%08d\r\n",seqNum%10000, sgSysTickCount); 
	strcpy(dataPacket, "1234BBBBCCCCDDDDEEEE\r\n");
  4099a0:	4d22      	ldr	r5, [pc, #136]	; (409a2c <task_fabSenseHandler+0xcc>)
	while(1)
	{
		if(enableRecording)
		{		
			#ifdef CREATE_DUMMY_PACKETS
			vTaskDelay(20); 
  4099a2:	47b0      	blx	r6

void createDummyFabSensePacket(char* dataPacket, size_t maxPacketSize, uint32_t seqNum)
{
	//int i = 0; 
	//snprintf(dataPacket, maxPacketSize, "%04dBBBBCCCCDDDDEEEE%08d\r\n",seqNum%10000, sgSysTickCount); 
	strcpy(dataPacket, "1234BBBBCCCCDDDDEEEE\r\n");
  4099a4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  4099a6:	ac0a      	add	r4, sp, #40	; 0x28
  4099a8:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  4099aa:	e895 0003 	ldmia.w	r5, {r0, r1}
  4099ae:	f844 0b04 	str.w	r0, [r4], #4
  4099b2:	f824 1b02 	strh.w	r1, [r4], #2
  4099b6:	0c09      	lsrs	r1, r1, #16
  4099b8:	7021      	strb	r1, [r4, #0]
		if(enableRecording)
		{		
			#ifdef CREATE_DUMMY_PACKETS
			vTaskDelay(20); 
			createDummyFabSensePacket(buf, FS_RESPONSE_BUF_SIZE, sequenceNumber++); 
			memcpy(packet.data, buf, 23);
  4099ba:	ac0a      	add	r4, sp, #40	; 0x28
  4099bc:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
			//enqueue the packet for the data processor.
			if(queue_dataHandler != NULL)
  4099be:	f8d8 e000 	ldr.w	lr, [r8]
		if(enableRecording)
		{		
			#ifdef CREATE_DUMMY_PACKETS
			vTaskDelay(20); 
			createDummyFabSensePacket(buf, FS_RESPONSE_BUF_SIZE, sequenceNumber++); 
			memcpy(packet.data, buf, 23);
  4099c2:	88a5      	ldrh	r5, [r4, #4]
  4099c4:	f8cd 0007 	str.w	r0, [sp, #7]
  4099c8:	6820      	ldr	r0, [r4, #0]
  4099ca:	79a4      	ldrb	r4, [r4, #6]
  4099cc:	f8cd 100b 	str.w	r1, [sp, #11]
  4099d0:	f8cd 200f 	str.w	r2, [sp, #15]
  4099d4:	f8cd 3013 	str.w	r3, [sp, #19]
  4099d8:	f8cd 0017 	str.w	r0, [sp, #23]
			//enqueue the packet for the data processor.
			if(queue_dataHandler != NULL)
			{
				if(xQueueSendToBack( queue_dataHandler,( void * ) &packet,10 ) != TRUE)
  4099dc:	a901      	add	r1, sp, #4
  4099de:	220a      	movs	r2, #10
  4099e0:	2300      	movs	r3, #0
  4099e2:	4670      	mov	r0, lr
		if(enableRecording)
		{		
			#ifdef CREATE_DUMMY_PACKETS
			vTaskDelay(20); 
			createDummyFabSensePacket(buf, FS_RESPONSE_BUF_SIZE, sequenceNumber++); 
			memcpy(packet.data, buf, 23);
  4099e4:	f8ad 501b 	strh.w	r5, [sp, #27]
  4099e8:	f88d 401d 	strb.w	r4, [sp, #29]
			//enqueue the packet for the data processor.
			if(queue_dataHandler != NULL)
  4099ec:	f1be 0f00 	cmp.w	lr, #0
  4099f0:	d0d2      	beq.n	409998 <task_fabSenseHandler+0x38>
			{
				if(xQueueSendToBack( queue_dataHandler,( void * ) &packet,10 ) != TRUE)
  4099f2:	47c8      	blx	r9
  4099f4:	2801      	cmp	r0, #1
  4099f6:	d0cf      	beq.n	409998 <task_fabSenseHandler+0x38>
				{					
					vTaskDelay(1);
  4099f8:	2001      	movs	r0, #1
  4099fa:	47d0      	blx	sl
	uint32_t sequenceNumber = 0;
	uint32_t packetsReceived = 0; 
	packetReceivedMask |= 1<<9; //add mask for fabric sense
	while(1)
	{
		if(enableRecording)
  4099fc:	783b      	ldrb	r3, [r7, #0]
		{		
			#ifdef CREATE_DUMMY_PACKETS
			vTaskDelay(20); 
  4099fe:	2014      	movs	r0, #20
	uint32_t sequenceNumber = 0;
	uint32_t packetsReceived = 0; 
	packetReceivedMask |= 1<<9; //add mask for fabric sense
	while(1)
	{
		if(enableRecording)
  409a00:	2b00      	cmp	r3, #0
  409a02:	d1cd      	bne.n	4099a0 <task_fabSenseHandler+0x40>
			#endif
	
		}
		else
		{
			vTaskDelay(10); 
  409a04:	200a      	movs	r0, #10
  409a06:	47b0      	blx	r6
  409a08:	e7c6      	b.n	409998 <task_fabSenseHandler+0x38>
	fabricSenseConfig_t *fsConfig = (fabricSenseConfig_t*)pvParameters;
	//check that uart device is initialized
	if(drv_uart_isInit(fsConfig->uartDevice) != STATUS_PASS)
	{
		//the UART driver has not been initialized, this should be done before starting this task!
		debugPrintString("FATAL: uart not initialized for FS\r\n");
  409a0a:	4809      	ldr	r0, [pc, #36]	; (409a30 <task_fabSenseHandler+0xd0>)
  409a0c:	4b09      	ldr	r3, [pc, #36]	; (409a34 <task_fabSenseHandler+0xd4>)
  409a0e:	4e04      	ldr	r6, [pc, #16]	; (409a20 <task_fabSenseHandler+0xc0>)
  409a10:	4798      	blx	r3
		//spin forever, this is a fatal error.  
		while(1)
		{
			vTaskDelay(1);
  409a12:	2001      	movs	r0, #1
  409a14:	47b0      	blx	r6
  409a16:	e7fc      	b.n	409a12 <task_fabSenseHandler+0xb2>
  409a18:	00408efd 	.word	0x00408efd
  409a1c:	0040c31d 	.word	0x0040c31d
  409a20:	004072ed 	.word	0x004072ed
  409a24:	20001200 	.word	0x20001200
  409a28:	200037a0 	.word	0x200037a0
  409a2c:	0041680c 	.word	0x0041680c
  409a30:	004167e4 	.word	0x004167e4
  409a34:	004008c9 	.word	0x004008c9
  409a38:	20003874 	.word	0x20003874
  409a3c:	00406979 	.word	0x00406979

00409a40 <task_fabSense_init>:
	{
		debugPrintString("Init SS failed!\r\n");	
	}
	
	return result;
}
  409a40:	2000      	movs	r0, #0
  409a42:	4770      	bx	lr

00409a44 <task_fabSense_start>:
 ***********************************************************************************************/
status_t task_fabSense_start(fabricSenseConfig_t* fabSenseConfig)
{
	
	status_t status = STATUS_PASS; 
	packetReceivedMask |= 1<<9;
  409a44:	4b04      	ldr	r3, [pc, #16]	; (409a58 <task_fabSense_start+0x14>)
	#ifndef CREATE_DUMMY_PACKETS
	drv_uart_putString(fabSenseConfig->uartDevice, "#s\r\n");
	#endif
	enableRecording = true; 
  409a46:	4a05      	ldr	r2, [pc, #20]	; (409a5c <task_fabSense_start+0x18>)
 ***********************************************************************************************/
status_t task_fabSense_start(fabricSenseConfig_t* fabSenseConfig)
{
	
	status_t status = STATUS_PASS; 
	packetReceivedMask |= 1<<9;
  409a48:	8818      	ldrh	r0, [r3, #0]
	#ifndef CREATE_DUMMY_PACKETS
	drv_uart_putString(fabSenseConfig->uartDevice, "#s\r\n");
	#endif
	enableRecording = true; 
  409a4a:	2101      	movs	r1, #1
 ***********************************************************************************************/
status_t task_fabSense_start(fabricSenseConfig_t* fabSenseConfig)
{
	
	status_t status = STATUS_PASS; 
	packetReceivedMask |= 1<<9;
  409a4c:	f440 7000 	orr.w	r0, r0, #512	; 0x200
  409a50:	8018      	strh	r0, [r3, #0]
	#ifndef CREATE_DUMMY_PACKETS
	drv_uart_putString(fabSenseConfig->uartDevice, "#s\r\n");
	#endif
	enableRecording = true; 
  409a52:	7011      	strb	r1, [r2, #0]
	return status; 
}
  409a54:	2000      	movs	r0, #0
  409a56:	4770      	bx	lr
  409a58:	200037a0 	.word	0x200037a0
  409a5c:	20001200 	.word	0x20001200

00409a60 <task_fabSense_stop>:
{	
	status_t status = STATUS_PASS;
	#ifndef CREATE_DUMMY_PACKETS
	drv_uart_putString(fabSenseConfig->uartDevice, "#t\r\n");
	#endif	
	enableRecording = false; 
  409a60:	4b01      	ldr	r3, [pc, #4]	; (409a68 <task_fabSense_stop+0x8>)
  409a62:	2000      	movs	r0, #0
  409a64:	7018      	strb	r0, [r3, #0]
	return status;	
}
  409a66:	4770      	bx	lr
  409a68:	20001200 	.word	0x20001200

00409a6c <vSystemResetTimerCallback>:
		task_stateMachine_EnqueueEvent(SYS_EVENT_POWER_SWITCH,0);	
	}
}

void vSystemResetTimerCallback( xTimerHandle xTimer )
{
  409a6c:	b510      	push	{r4, lr}
  409a6e:	b082      	sub	sp, #8
	drv_gpio_pin_state_t pinState1, pinState2;

	drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW1, &pinState1);
  409a70:	f10d 0106 	add.w	r1, sp, #6
  409a74:	4c08      	ldr	r4, [pc, #32]	; (409a98 <vSystemResetTimerCallback+0x2c>)
  409a76:	2001      	movs	r0, #1
  409a78:	47a0      	blx	r4
	drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW2, &pinState2);
  409a7a:	2002      	movs	r0, #2
  409a7c:	f10d 0107 	add.w	r1, sp, #7
  409a80:	47a0      	blx	r4
	//check if both the switches are still pressed
	if ((pinState1 == DRV_GPIO_PIN_STATE_LOW) & (pinState2 == DRV_GPIO_PIN_STATE_LOW))
  409a82:	f89d 3007 	ldrb.w	r3, [sp, #7]
  409a86:	b92b      	cbnz	r3, 409a94 <vSystemResetTimerCallback+0x28>
  409a88:	f89d 3006 	ldrb.w	r3, [sp, #6]
  409a8c:	b913      	cbnz	r3, 409a94 <vSystemResetTimerCallback+0x28>
	{
		//if yes reset the system
		SystemResetTimerFlag = 1;
  409a8e:	4b03      	ldr	r3, [pc, #12]	; (409a9c <vSystemResetTimerCallback+0x30>)
  409a90:	2201      	movs	r2, #1
  409a92:	701a      	strb	r2, [r3, #0]
		//rstc_start_software_reset(RSTC);
	}
}
  409a94:	b002      	add	sp, #8
  409a96:	bd10      	pop	{r4, pc}
  409a98:	00408829 	.word	0x00408829
  409a9c:	200038a2 	.word	0x200038a2

00409aa0 <vResetButtonTimerCallback>:

void vResetButtonTimerCallback (xTimerHandle xTimer)
{
  409aa0:	b500      	push	{lr}
  409aa2:	b083      	sub	sp, #12
	drv_gpio_pin_state_t pinState1;
	drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW2, &pinState1);
  409aa4:	4b06      	ldr	r3, [pc, #24]	; (409ac0 <vResetButtonTimerCallback+0x20>)
  409aa6:	2002      	movs	r0, #2
  409aa8:	f10d 0107 	add.w	r1, sp, #7
  409aac:	4798      	blx	r3
	//Check if reset button is still pressed
	if (pinState1 == DRV_GPIO_PIN_STATE_LOW)
  409aae:	f89d 3007 	ldrb.w	r3, [sp, #7]
  409ab2:	b913      	cbnz	r3, 409aba <vResetButtonTimerCallback+0x1a>
	{
		ResetButtonTimerFlag = 1;
  409ab4:	4b03      	ldr	r3, [pc, #12]	; (409ac4 <vResetButtonTimerCallback+0x24>)
  409ab6:	2201      	movs	r2, #1
  409ab8:	701a      	strb	r2, [r3, #0]
	}
}
  409aba:	b003      	add	sp, #12
  409abc:	f85d fb04 	ldr.w	pc, [sp], #4
  409ac0:	00408829 	.word	0x00408829
  409ac4:	200038a0 	.word	0x200038a0

00409ac8 <vSleepTimerCallback>:

//TEMP REMOVE THIS
extern FIL dataLogFile_obj; 

void vSleepTimerCallback( xTimerHandle xTimer )
{
  409ac8:	b510      	push	{r4, lr}
  409aca:	b082      	sub	sp, #8
	drv_gpio_pin_state_t pinState;
	drv_gpio_getPinState(DRV_GPIO_PIN_PW_SW, &pinState);
  409acc:	2000      	movs	r0, #0
  409ace:	f10d 0107 	add.w	r1, sp, #7
  409ad2:	4b08      	ldr	r3, [pc, #32]	; (409af4 <vSleepTimerCallback+0x2c>)
  409ad4:	4798      	blx	r3
	if (pinState == DRV_GPIO_PIN_STATE_LOW)
  409ad6:	f89d 4007 	ldrb.w	r4, [sp, #7]
  409ada:	b94c      	cbnz	r4, 409af0 <vSleepTimerCallback+0x28>
	{
		pwSwitchTimerFlag = 1;
  409adc:	4a06      	ldr	r2, [pc, #24]	; (409af8 <vSleepTimerCallback+0x30>)
		debugPrintString("Sleep mode enabled\r\n");
  409ade:	4807      	ldr	r0, [pc, #28]	; (409afc <vSleepTimerCallback+0x34>)
  409ae0:	4b07      	ldr	r3, [pc, #28]	; (409b00 <vSleepTimerCallback+0x38>)
{
	drv_gpio_pin_state_t pinState;
	drv_gpio_getPinState(DRV_GPIO_PIN_PW_SW, &pinState);
	if (pinState == DRV_GPIO_PIN_STATE_LOW)
	{
		pwSwitchTimerFlag = 1;
  409ae2:	2101      	movs	r1, #1
  409ae4:	7011      	strb	r1, [r2, #0]
		debugPrintString("Sleep mode enabled\r\n");
  409ae6:	4798      	blx	r3
		task_stateMachine_EnqueueEvent(SYS_EVENT_POWER_SWITCH,0);	
  409ae8:	4620      	mov	r0, r4
  409aea:	4621      	mov	r1, r4
  409aec:	4b05      	ldr	r3, [pc, #20]	; (409b04 <vSleepTimerCallback+0x3c>)
  409aee:	4798      	blx	r3
	}
}
  409af0:	b002      	add	sp, #8
  409af2:	bd10      	pop	{r4, pc}
  409af4:	00408829 	.word	0x00408829
  409af8:	200038a1 	.word	0x200038a1
  409afc:	00415b50 	.word	0x00415b50
  409b00:	004008c9 	.word	0x004008c9
  409b04:	00401a99 	.word	0x00401a99

00409b08 <TaskMain>:

/**
 * \brief This task is initialized first to initiate the board peripherals and run the initial tests
 */
void __attribute__((optimize("O0"))) TaskMain(void *pvParameters)
{
  409b08:	b590      	push	{r4, r7, lr}
  409b0a:	b097      	sub	sp, #92	; 0x5c
  409b0c:	af04      	add	r7, sp, #16
  409b0e:	6078      	str	r0, [r7, #4]
	int retCode = 0, vLoopCount = 0, vCycleJcEnCount = 0; 
  409b10:	2300      	movs	r3, #0
  409b12:	63fb      	str	r3, [r7, #60]	; 0x3c
  409b14:	2300      	movs	r3, #0
  409b16:	647b      	str	r3, [r7, #68]	; 0x44
  409b18:	2300      	movs	r3, #0
  409b1a:	643b      	str	r3, [r7, #64]	; 0x40
	drv_gpio_pin_state_t jcDc2 = DRV_GPIO_PIN_STATE_LOW, jcDc1 = DRV_GPIO_PIN_STATE_LOW;
  409b1c:	2300      	movs	r3, #0
  409b1e:	f887 303b 	strb.w	r3, [r7, #59]	; 0x3b
  409b22:	2300      	movs	r3, #0
  409b24:	f887 303a 	strb.w	r3, [r7, #58]	; 0x3a
	UNUSED(pvParameters);
	/*	Create a Semaphore to pass between tasks	*/
	//vSemaphoreCreateBinary(DebugLogSemaphore);
	powerOnInit();
  409b28:	4b94      	ldr	r3, [pc, #592]	; (409d7c <TaskMain+0x274>)
  409b2a:	4798      	blx	r3
	
	SleepTimer = xTimerCreate("Sleep Timer", (SLEEP_ENTRY_WAIT_TIME/portTICK_RATE_MS), pdFALSE, NULL, vSleepTimerCallback);
  409b2c:	4b94      	ldr	r3, [pc, #592]	; (409d80 <TaskMain+0x278>)
  409b2e:	9300      	str	r3, [sp, #0]
  409b30:	4894      	ldr	r0, [pc, #592]	; (409d84 <TaskMain+0x27c>)
  409b32:	f44f 617a 	mov.w	r1, #4000	; 0xfa0
  409b36:	2200      	movs	r2, #0
  409b38:	2300      	movs	r3, #0
  409b3a:	4c93      	ldr	r4, [pc, #588]	; (409d88 <TaskMain+0x280>)
  409b3c:	47a0      	blx	r4
  409b3e:	4602      	mov	r2, r0
  409b40:	4b92      	ldr	r3, [pc, #584]	; (409d8c <TaskMain+0x284>)
  409b42:	601a      	str	r2, [r3, #0]
	if (SleepTimer == NULL)
  409b44:	4b91      	ldr	r3, [pc, #580]	; (409d8c <TaskMain+0x284>)
  409b46:	681b      	ldr	r3, [r3, #0]
  409b48:	2b00      	cmp	r3, #0
  409b4a:	d105      	bne.n	409b58 <TaskMain+0x50>
	{
		printf("Failed to create timer task code %d\r\n", SleepTimer);
  409b4c:	4b8f      	ldr	r3, [pc, #572]	; (409d8c <TaskMain+0x284>)
  409b4e:	681b      	ldr	r3, [r3, #0]
  409b50:	488f      	ldr	r0, [pc, #572]	; (409d90 <TaskMain+0x288>)
  409b52:	4619      	mov	r1, r3
  409b54:	4b8f      	ldr	r3, [pc, #572]	; (409d94 <TaskMain+0x28c>)
  409b56:	4798      	blx	r3
	}
	
	SystemResetTimer = xTimerCreate("System Reset Timer", (FORCED_SYSTEM_RESET_TIMEOUT/portTICK_RATE_MS), pdFALSE, NULL, vSystemResetTimerCallback);
  409b58:	4b8f      	ldr	r3, [pc, #572]	; (409d98 <TaskMain+0x290>)
  409b5a:	9300      	str	r3, [sp, #0]
  409b5c:	488f      	ldr	r0, [pc, #572]	; (409d9c <TaskMain+0x294>)
  409b5e:	f242 7110 	movw	r1, #10000	; 0x2710
  409b62:	2200      	movs	r2, #0
  409b64:	2300      	movs	r3, #0
  409b66:	4c88      	ldr	r4, [pc, #544]	; (409d88 <TaskMain+0x280>)
  409b68:	47a0      	blx	r4
  409b6a:	4602      	mov	r2, r0
  409b6c:	4b8c      	ldr	r3, [pc, #560]	; (409da0 <TaskMain+0x298>)
  409b6e:	601a      	str	r2, [r3, #0]
	if (SystemResetTimer == NULL)
  409b70:	4b8b      	ldr	r3, [pc, #556]	; (409da0 <TaskMain+0x298>)
  409b72:	681b      	ldr	r3, [r3, #0]
  409b74:	2b00      	cmp	r3, #0
  409b76:	d105      	bne.n	409b84 <TaskMain+0x7c>
	{
		printf("Failed to create timer task code %d\r\n", SystemResetTimer);
  409b78:	4b89      	ldr	r3, [pc, #548]	; (409da0 <TaskMain+0x298>)
  409b7a:	681b      	ldr	r3, [r3, #0]
  409b7c:	4884      	ldr	r0, [pc, #528]	; (409d90 <TaskMain+0x288>)
  409b7e:	4619      	mov	r1, r3
  409b80:	4b84      	ldr	r3, [pc, #528]	; (409d94 <TaskMain+0x28c>)
  409b82:	4798      	blx	r3
	}
	
	ResetButtonTimer = xTimerCreate("Reset button timer", (RESET_SW_LONG_PRESS_DELAY/portTICK_RATE_MS), pdFALSE	, NULL, vResetButtonTimerCallback);
  409b84:	4b87      	ldr	r3, [pc, #540]	; (409da4 <TaskMain+0x29c>)
  409b86:	9300      	str	r3, [sp, #0]
  409b88:	4887      	ldr	r0, [pc, #540]	; (409da8 <TaskMain+0x2a0>)
  409b8a:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
  409b8e:	2200      	movs	r2, #0
  409b90:	2300      	movs	r3, #0
  409b92:	4c7d      	ldr	r4, [pc, #500]	; (409d88 <TaskMain+0x280>)
  409b94:	47a0      	blx	r4
  409b96:	4602      	mov	r2, r0
  409b98:	4b84      	ldr	r3, [pc, #528]	; (409dac <TaskMain+0x2a4>)
  409b9a:	601a      	str	r2, [r3, #0]
	if (ResetButtonTimer == NULL)
  409b9c:	4b83      	ldr	r3, [pc, #524]	; (409dac <TaskMain+0x2a4>)
  409b9e:	681b      	ldr	r3, [r3, #0]
  409ba0:	2b00      	cmp	r3, #0
  409ba2:	d105      	bne.n	409bb0 <TaskMain+0xa8>
	{
		printf("Failed to create reset button timer task code %d\r\n", ResetButtonTimer);
  409ba4:	4b81      	ldr	r3, [pc, #516]	; (409dac <TaskMain+0x2a4>)
  409ba6:	681b      	ldr	r3, [r3, #0]
  409ba8:	4881      	ldr	r0, [pc, #516]	; (409db0 <TaskMain+0x2a8>)
  409baa:	4619      	mov	r1, r3
  409bac:	4b79      	ldr	r3, [pc, #484]	; (409d94 <TaskMain+0x28c>)
  409bae:	4798      	blx	r3
	}
	
	retCode = xTaskCreate(task_quinticHandler, "Q1", TASK_QUINTIC_STACK_SIZE, (void*)&quinticConfig[0], TASK_QUINTIC_PRIORITY, &quinticConfig[0].taskHandle );
  409bb0:	2305      	movs	r3, #5
  409bb2:	9300      	str	r3, [sp, #0]
  409bb4:	4b7f      	ldr	r3, [pc, #508]	; (409db4 <TaskMain+0x2ac>)
  409bb6:	9301      	str	r3, [sp, #4]
  409bb8:	2300      	movs	r3, #0
  409bba:	9302      	str	r3, [sp, #8]
  409bbc:	2300      	movs	r3, #0
  409bbe:	9303      	str	r3, [sp, #12]
  409bc0:	487d      	ldr	r0, [pc, #500]	; (409db8 <TaskMain+0x2b0>)
  409bc2:	497e      	ldr	r1, [pc, #504]	; (409dbc <TaskMain+0x2b4>)
  409bc4:	f240 1277 	movw	r2, #375	; 0x177
  409bc8:	4b7d      	ldr	r3, [pc, #500]	; (409dc0 <TaskMain+0x2b8>)
  409bca:	4c7e      	ldr	r4, [pc, #504]	; (409dc4 <TaskMain+0x2bc>)
  409bcc:	47a0      	blx	r4
  409bce:	63f8      	str	r0, [r7, #60]	; 0x3c
	if (retCode != pdPASS)
  409bd0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  409bd2:	2b01      	cmp	r3, #1
  409bd4:	d003      	beq.n	409bde <TaskMain+0xd6>
	{
		printf("Failed to create Q1 task code %d\r\n", retCode);
  409bd6:	487c      	ldr	r0, [pc, #496]	; (409dc8 <TaskMain+0x2c0>)
  409bd8:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
  409bda:	4b6e      	ldr	r3, [pc, #440]	; (409d94 <TaskMain+0x28c>)
  409bdc:	4798      	blx	r3
	}
	#ifdef USE_ALL_QUINTICS
	retCode = xTaskCreate(task_quinticHandler, "Q2", TASK_QUINTIC_STACK_SIZE, (void*)&quinticConfig[1], TASK_QUINTIC_PRIORITY, &quinticConfig[1].taskHandle );
  409bde:	2305      	movs	r3, #5
  409be0:	9300      	str	r3, [sp, #0]
  409be2:	4b7a      	ldr	r3, [pc, #488]	; (409dcc <TaskMain+0x2c4>)
  409be4:	9301      	str	r3, [sp, #4]
  409be6:	2300      	movs	r3, #0
  409be8:	9302      	str	r3, [sp, #8]
  409bea:	2300      	movs	r3, #0
  409bec:	9303      	str	r3, [sp, #12]
  409bee:	4872      	ldr	r0, [pc, #456]	; (409db8 <TaskMain+0x2b0>)
  409bf0:	4977      	ldr	r1, [pc, #476]	; (409dd0 <TaskMain+0x2c8>)
  409bf2:	f240 1277 	movw	r2, #375	; 0x177
  409bf6:	4b77      	ldr	r3, [pc, #476]	; (409dd4 <TaskMain+0x2cc>)
  409bf8:	4c72      	ldr	r4, [pc, #456]	; (409dc4 <TaskMain+0x2bc>)
  409bfa:	47a0      	blx	r4
  409bfc:	63f8      	str	r0, [r7, #60]	; 0x3c
	if (retCode != pdPASS)
  409bfe:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  409c00:	2b01      	cmp	r3, #1
  409c02:	d003      	beq.n	409c0c <TaskMain+0x104>
	{
		printf("Failed to create Q2 task code %d\r\n", retCode);
  409c04:	4874      	ldr	r0, [pc, #464]	; (409dd8 <TaskMain+0x2d0>)
  409c06:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
  409c08:	4b62      	ldr	r3, [pc, #392]	; (409d94 <TaskMain+0x28c>)
  409c0a:	4798      	blx	r3
	}
	#endif
	retCode = xTaskCreate(task_quinticHandler, "Q3", TASK_QUINTIC_STACK_SIZE, (void*)&quinticConfig[2], TASK_QUINTIC_PRIORITY, &quinticConfig[2].taskHandle );
  409c0c:	2305      	movs	r3, #5
  409c0e:	9300      	str	r3, [sp, #0]
  409c10:	4b72      	ldr	r3, [pc, #456]	; (409ddc <TaskMain+0x2d4>)
  409c12:	9301      	str	r3, [sp, #4]
  409c14:	2300      	movs	r3, #0
  409c16:	9302      	str	r3, [sp, #8]
  409c18:	2300      	movs	r3, #0
  409c1a:	9303      	str	r3, [sp, #12]
  409c1c:	4866      	ldr	r0, [pc, #408]	; (409db8 <TaskMain+0x2b0>)
  409c1e:	4970      	ldr	r1, [pc, #448]	; (409de0 <TaskMain+0x2d8>)
  409c20:	f240 1277 	movw	r2, #375	; 0x177
  409c24:	4b6f      	ldr	r3, [pc, #444]	; (409de4 <TaskMain+0x2dc>)
  409c26:	4c67      	ldr	r4, [pc, #412]	; (409dc4 <TaskMain+0x2bc>)
  409c28:	47a0      	blx	r4
  409c2a:	63f8      	str	r0, [r7, #60]	; 0x3c
	if (retCode != pdPASS)
  409c2c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  409c2e:	2b01      	cmp	r3, #1
  409c30:	d003      	beq.n	409c3a <TaskMain+0x132>
	{
		printf("Failed to create Q3 task code %d\r\n", retCode);
  409c32:	486d      	ldr	r0, [pc, #436]	; (409de8 <TaskMain+0x2e0>)
  409c34:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
  409c36:	4b57      	ldr	r3, [pc, #348]	; (409d94 <TaskMain+0x28c>)
  409c38:	4798      	blx	r3
	}
	
	retCode = xTaskCreate(task_fabSenseHandler, "FS", TASK_FABSENSE_STACK_SIZE,(void*)&fsConfig, TASK_FABSENSE_PRIORITY, &fabSenseTaskHandle);
  409c3a:	2305      	movs	r3, #5
  409c3c:	9300      	str	r3, [sp, #0]
  409c3e:	4b6b      	ldr	r3, [pc, #428]	; (409dec <TaskMain+0x2e4>)
  409c40:	9301      	str	r3, [sp, #4]
  409c42:	2300      	movs	r3, #0
  409c44:	9302      	str	r3, [sp, #8]
  409c46:	2300      	movs	r3, #0
  409c48:	9303      	str	r3, [sp, #12]
  409c4a:	4869      	ldr	r0, [pc, #420]	; (409df0 <TaskMain+0x2e8>)
  409c4c:	4969      	ldr	r1, [pc, #420]	; (409df4 <TaskMain+0x2ec>)
  409c4e:	f44f 7280 	mov.w	r2, #256	; 0x100
  409c52:	4b69      	ldr	r3, [pc, #420]	; (409df8 <TaskMain+0x2f0>)
  409c54:	4c5b      	ldr	r4, [pc, #364]	; (409dc4 <TaskMain+0x2bc>)
  409c56:	47a0      	blx	r4
  409c58:	63f8      	str	r0, [r7, #60]	; 0x3c
	if (retCode != pdPASS)
  409c5a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  409c5c:	2b01      	cmp	r3, #1
  409c5e:	d003      	beq.n	409c68 <TaskMain+0x160>
	{
		printf("Failed to create fabric sense task code %d\r\n", retCode);
  409c60:	4866      	ldr	r0, [pc, #408]	; (409dfc <TaskMain+0x2f4>)
  409c62:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
  409c64:	4b4b      	ldr	r3, [pc, #300]	; (409d94 <TaskMain+0x28c>)
  409c66:	4798      	blx	r3
	}

	retCode = xTaskCreate(task_commandHandler, "cmd", TASK_SERIAL_RECEIVE_STACK_SIZE,(void*)&cmdConfig, TASK_SERIAL_RECEIVE_PRIORITY, &cmdHandlerTaskHandle );
  409c68:	2306      	movs	r3, #6
  409c6a:	9300      	str	r3, [sp, #0]
  409c6c:	4b64      	ldr	r3, [pc, #400]	; (409e00 <TaskMain+0x2f8>)
  409c6e:	9301      	str	r3, [sp, #4]
  409c70:	2300      	movs	r3, #0
  409c72:	9302      	str	r3, [sp, #8]
  409c74:	2300      	movs	r3, #0
  409c76:	9303      	str	r3, [sp, #12]
  409c78:	4862      	ldr	r0, [pc, #392]	; (409e04 <TaskMain+0x2fc>)
  409c7a:	4963      	ldr	r1, [pc, #396]	; (409e08 <TaskMain+0x300>)
  409c7c:	f240 2271 	movw	r2, #625	; 0x271
  409c80:	4b62      	ldr	r3, [pc, #392]	; (409e0c <TaskMain+0x304>)
  409c82:	4c50      	ldr	r4, [pc, #320]	; (409dc4 <TaskMain+0x2bc>)
  409c84:	47a0      	blx	r4
  409c86:	63f8      	str	r0, [r7, #60]	; 0x3c
	if (retCode != pdPASS)
  409c88:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  409c8a:	2b01      	cmp	r3, #1
  409c8c:	d003      	beq.n	409c96 <TaskMain+0x18e>
	{
		printf("Failed to Serial handler task code %d\r\n", retCode);
  409c8e:	4860      	ldr	r0, [pc, #384]	; (409e10 <TaskMain+0x308>)
  409c90:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
  409c92:	4b40      	ldr	r3, [pc, #256]	; (409d94 <TaskMain+0x28c>)
  409c94:	4798      	blx	r3
	}
	retCode = xTaskCreate(task_dataHandler, "DH", TASK_DATA_HANDLER_STACK_SIZE, NULL, TASK_DATA_HANDLER_PRIORITY, &dataHandlerTaskHandle );
  409c96:	2307      	movs	r3, #7
  409c98:	9300      	str	r3, [sp, #0]
  409c9a:	4b5e      	ldr	r3, [pc, #376]	; (409e14 <TaskMain+0x30c>)
  409c9c:	9301      	str	r3, [sp, #4]
  409c9e:	2300      	movs	r3, #0
  409ca0:	9302      	str	r3, [sp, #8]
  409ca2:	2300      	movs	r3, #0
  409ca4:	9303      	str	r3, [sp, #12]
  409ca6:	485c      	ldr	r0, [pc, #368]	; (409e18 <TaskMain+0x310>)
  409ca8:	495c      	ldr	r1, [pc, #368]	; (409e1c <TaskMain+0x314>)
  409caa:	f240 22ee 	movw	r2, #750	; 0x2ee
  409cae:	2300      	movs	r3, #0
  409cb0:	4c44      	ldr	r4, [pc, #272]	; (409dc4 <TaskMain+0x2bc>)
  409cb2:	47a0      	blx	r4
  409cb4:	63f8      	str	r0, [r7, #60]	; 0x3c
	if (retCode != pdPASS)
  409cb6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  409cb8:	2b01      	cmp	r3, #1
  409cba:	d003      	beq.n	409cc4 <TaskMain+0x1bc>
	{
		printf("Failed to create data handler task code %d\r\n", retCode);
  409cbc:	4858      	ldr	r0, [pc, #352]	; (409e20 <TaskMain+0x318>)
  409cbe:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
  409cc0:	4b34      	ldr	r3, [pc, #208]	; (409d94 <TaskMain+0x28c>)
  409cc2:	4798      	blx	r3
	}	
	retCode = xTaskCreate(task_sdCardHandler, "SD", TASK_SD_CARD_WRITE_STACK_SIZE, NULL, TASK_SD_CARD_WRITE_PRIORITY, &sdCardTaskHandle );
  409cc4:	2304      	movs	r3, #4
  409cc6:	9300      	str	r3, [sp, #0]
  409cc8:	4b56      	ldr	r3, [pc, #344]	; (409e24 <TaskMain+0x31c>)
  409cca:	9301      	str	r3, [sp, #4]
  409ccc:	2300      	movs	r3, #0
  409cce:	9302      	str	r3, [sp, #8]
  409cd0:	2300      	movs	r3, #0
  409cd2:	9303      	str	r3, [sp, #12]
  409cd4:	4854      	ldr	r0, [pc, #336]	; (409e28 <TaskMain+0x320>)
  409cd6:	4955      	ldr	r1, [pc, #340]	; (409e2c <TaskMain+0x324>)
  409cd8:	f44f 7200 	mov.w	r2, #512	; 0x200
  409cdc:	2300      	movs	r3, #0
  409cde:	4c39      	ldr	r4, [pc, #228]	; (409dc4 <TaskMain+0x2bc>)
  409ce0:	47a0      	blx	r4
  409ce2:	63f8      	str	r0, [r7, #60]	; 0x3c
	if (retCode != pdPASS)
  409ce4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  409ce6:	2b01      	cmp	r3, #1
  409ce8:	d003      	beq.n	409cf2 <TaskMain+0x1ea>
	{
		printf("Failed to create sd card task code %d\r\n", retCode);
  409cea:	4851      	ldr	r0, [pc, #324]	; (409e30 <TaskMain+0x328>)
  409cec:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
  409cee:	4b29      	ldr	r3, [pc, #164]	; (409d94 <TaskMain+0x28c>)
  409cf0:	4798      	blx	r3
	}
	retCode = xTaskCreate(task_stateMachineHandler, "SM", TASK_STATE_MACHINE_STACK_SIZE, NULL, TASK_STATE_MACHINE_PRIORITY, &stateMachineTaskHandle );
  409cf2:	2303      	movs	r3, #3
  409cf4:	9300      	str	r3, [sp, #0]
  409cf6:	4b4f      	ldr	r3, [pc, #316]	; (409e34 <TaskMain+0x32c>)
  409cf8:	9301      	str	r3, [sp, #4]
  409cfa:	2300      	movs	r3, #0
  409cfc:	9302      	str	r3, [sp, #8]
  409cfe:	2300      	movs	r3, #0
  409d00:	9303      	str	r3, [sp, #12]
  409d02:	484d      	ldr	r0, [pc, #308]	; (409e38 <TaskMain+0x330>)
  409d04:	494d      	ldr	r1, [pc, #308]	; (409e3c <TaskMain+0x334>)
  409d06:	f44f 7240 	mov.w	r2, #768	; 0x300
  409d0a:	2300      	movs	r3, #0
  409d0c:	4c2d      	ldr	r4, [pc, #180]	; (409dc4 <TaskMain+0x2bc>)
  409d0e:	47a0      	blx	r4
  409d10:	63f8      	str	r0, [r7, #60]	; 0x3c
	if (retCode != pdPASS)
  409d12:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  409d14:	2b01      	cmp	r3, #1
  409d16:	d003      	beq.n	409d20 <TaskMain+0x218>
	{
		printf("Failed to state machine task code %d\r\n", retCode);
  409d18:	4849      	ldr	r0, [pc, #292]	; (409e40 <TaskMain+0x338>)
  409d1a:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
  409d1c:	4b1d      	ldr	r3, [pc, #116]	; (409d94 <TaskMain+0x28c>)
  409d1e:	4798      	blx	r3
	}
	
	uint8_t interval = 0;
  409d20:	2300      	movs	r3, #0
  409d22:	f887 3039 	strb.w	r3, [r7, #57]	; 0x39
	for (;;) 
	{
		/*	Hardware Test routine	*/
		wdt_restart(WDT);
  409d26:	4847      	ldr	r0, [pc, #284]	; (409e44 <TaskMain+0x33c>)
  409d28:	4b47      	ldr	r3, [pc, #284]	; (409e48 <TaskMain+0x340>)
  409d2a:	4798      	blx	r3
 ***********************************************************************************************/
static void checkInputGpio(void)
{
	dataPacket_t packet;
	//TODO maybe the enqueueing of event should be done in the interrupts??
	if ((drv_gpio_check_Int(DRV_GPIO_PIN_PW_SW) == 1) || (pwSwitchTimerFlag == 1))
  409d2c:	2000      	movs	r0, #0
  409d2e:	4b47      	ldr	r3, [pc, #284]	; (409e4c <TaskMain+0x344>)
  409d30:	4798      	blx	r3
  409d32:	4603      	mov	r3, r0
  409d34:	2b00      	cmp	r3, #0
  409d36:	d104      	bne.n	409d42 <TaskMain+0x23a>
  409d38:	4b45      	ldr	r3, [pc, #276]	; (409e50 <TaskMain+0x348>)
  409d3a:	781b      	ldrb	r3, [r3, #0]
  409d3c:	2b01      	cmp	r3, #1
  409d3e:	f040 80b3 	bne.w	409ea8 <TaskMain+0x3a0>
	{
		unsigned long PinFlag;		
		if (pwSwToggle == FALSE)
  409d42:	4b44      	ldr	r3, [pc, #272]	; (409e54 <TaskMain+0x34c>)
  409d44:	781b      	ldrb	r3, [r3, #0]
  409d46:	2b00      	cmp	r3, #0
  409d48:	f040 808d 	bne.w	409e66 <TaskMain+0x35e>
		{
			pwSwitchTimerFlag = 0;
  409d4c:	4b40      	ldr	r3, [pc, #256]	; (409e50 <TaskMain+0x348>)
  409d4e:	2200      	movs	r2, #0
  409d50:	701a      	strb	r2, [r3, #0]
			drv_gpio_config_interrupt(DRV_GPIO_PIN_PW_SW, DRV_GPIO_INTERRUPT_HIGH_EDGE);	//Power pin pressed; configure interrupt for Rising edge
  409d52:	2000      	movs	r0, #0
  409d54:	2100      	movs	r1, #0
  409d56:	4b40      	ldr	r3, [pc, #256]	; (409e58 <TaskMain+0x350>)
  409d58:	4798      	blx	r3
			xTimerReset(SleepTimer, 0);
  409d5a:	4b0c      	ldr	r3, [pc, #48]	; (409d8c <TaskMain+0x284>)
  409d5c:	681c      	ldr	r4, [r3, #0]
  409d5e:	4b3f      	ldr	r3, [pc, #252]	; (409e5c <TaskMain+0x354>)
  409d60:	4798      	blx	r3
  409d62:	4603      	mov	r3, r0
  409d64:	2200      	movs	r2, #0
  409d66:	9200      	str	r2, [sp, #0]
  409d68:	4620      	mov	r0, r4
  409d6a:	2100      	movs	r1, #0
  409d6c:	461a      	mov	r2, r3
  409d6e:	2300      	movs	r3, #0
  409d70:	4c3b      	ldr	r4, [pc, #236]	; (409e60 <TaskMain+0x358>)
  409d72:	47a0      	blx	r4
			pwSwToggle = TRUE;
  409d74:	4b37      	ldr	r3, [pc, #220]	; (409e54 <TaskMain+0x34c>)
  409d76:	2201      	movs	r2, #1
  409d78:	701a      	strb	r2, [r3, #0]
  409d7a:	e073      	b.n	409e64 <TaskMain+0x35c>
  409d7c:	00407dc1 	.word	0x00407dc1
  409d80:	00409ac9 	.word	0x00409ac9
  409d84:	00416824 	.word	0x00416824
  409d88:	004078fd 	.word	0x004078fd
  409d8c:	20005030 	.word	0x20005030
  409d90:	00416830 	.word	0x00416830
  409d94:	0040bba9 	.word	0x0040bba9
  409d98:	00409a6d 	.word	0x00409a6d
  409d9c:	00416858 	.word	0x00416858
  409da0:	20005028 	.word	0x20005028
  409da4:	00409aa1 	.word	0x00409aa1
  409da8:	0041686c 	.word	0x0041686c
  409dac:	20005024 	.word	0x20005024
  409db0:	00416880 	.word	0x00416880
  409db4:	20000290 	.word	0x20000290
  409db8:	0040a591 	.word	0x0040a591
  409dbc:	004168b4 	.word	0x004168b4
  409dc0:	20000264 	.word	0x20000264
  409dc4:	00406dcd 	.word	0x00406dcd
  409dc8:	004168b8 	.word	0x004168b8
  409dcc:	200002cc 	.word	0x200002cc
  409dd0:	004168dc 	.word	0x004168dc
  409dd4:	200002a0 	.word	0x200002a0
  409dd8:	004168e0 	.word	0x004168e0
  409ddc:	20000308 	.word	0x20000308
  409de0:	00416904 	.word	0x00416904
  409de4:	200002dc 	.word	0x200002dc
  409de8:	00416908 	.word	0x00416908
  409dec:	20003898 	.word	0x20003898
  409df0:	00409961 	.word	0x00409961
  409df4:	0041692c 	.word	0x0041692c
  409df8:	200001a0 	.word	0x200001a0
  409dfc:	00416930 	.word	0x00416930
  409e00:	20003894 	.word	0x20003894
  409e04:	00400995 	.word	0x00400995
  409e08:	00416960 	.word	0x00416960
  409e0c:	20000318 	.word	0x20000318
  409e10:	00416964 	.word	0x00416964
  409e14:	20003890 	.word	0x20003890
  409e18:	004093f9 	.word	0x004093f9
  409e1c:	0041698c 	.word	0x0041698c
  409e20:	00416990 	.word	0x00416990
  409e24:	2000388c 	.word	0x2000388c
  409e28:	0040174d 	.word	0x0040174d
  409e2c:	004169c0 	.word	0x004169c0
  409e30:	004169c4 	.word	0x004169c4
  409e34:	20003888 	.word	0x20003888
  409e38:	004026b5 	.word	0x004026b5
  409e3c:	004169ec 	.word	0x004169ec
  409e40:	004169f0 	.word	0x004169f0
  409e44:	400e1450 	.word	0x400e1450
  409e48:	0040b2d1 	.word	0x0040b2d1
  409e4c:	004088cd 	.word	0x004088cd
  409e50:	200038a1 	.word	0x200038a1
  409e54:	200038a3 	.word	0x200038a3
  409e58:	00408871 	.word	0x00408871
  409e5c:	004070a1 	.word	0x004070a1
  409e60:	00407949 	.word	0x00407949
  409e64:	e020      	b.n	409ea8 <TaskMain+0x3a0>
		}
		else if((pwSwToggle == TRUE)||(pwSwitchTimerFlag == 1))
  409e66:	2b00      	cmp	r3, #0
  409e68:	d103      	bne.n	409e72 <TaskMain+0x36a>
  409e6a:	4b8a      	ldr	r3, [pc, #552]	; (40a094 <TaskMain+0x58c>)
  409e6c:	781b      	ldrb	r3, [r3, #0]
  409e6e:	2b01      	cmp	r3, #1
  409e70:	d11a      	bne.n	409ea8 <TaskMain+0x3a0>
		{
			xTimerStop(SleepTimer, 0);
  409e72:	4b89      	ldr	r3, [pc, #548]	; (40a098 <TaskMain+0x590>)
  409e74:	681b      	ldr	r3, [r3, #0]
  409e76:	2200      	movs	r2, #0
  409e78:	9200      	str	r2, [sp, #0]
  409e7a:	4618      	mov	r0, r3
  409e7c:	2101      	movs	r1, #1
  409e7e:	2200      	movs	r2, #0
  409e80:	2300      	movs	r3, #0
  409e82:	4c86      	ldr	r4, [pc, #536]	; (40a09c <TaskMain+0x594>)
  409e84:	47a0      	blx	r4
			drv_gpio_config_interrupt(DRV_GPIO_ID_PIN_PW_SW, DRV_GPIO_INTERRUPT_LOW_EDGE);	//Power pin released; configure interrupt for Falling edge
  409e86:	2000      	movs	r0, #0
  409e88:	2101      	movs	r1, #1
  409e8a:	4b85      	ldr	r3, [pc, #532]	; (40a0a0 <TaskMain+0x598>)
  409e8c:	4798      	blx	r3
			pwSwToggle = FALSE;
  409e8e:	4b85      	ldr	r3, [pc, #532]	; (40a0a4 <TaskMain+0x59c>)
  409e90:	2200      	movs	r2, #0
  409e92:	701a      	strb	r2, [r3, #0]
			if (pwSwitchTimerFlag != 1)
  409e94:	4b7f      	ldr	r3, [pc, #508]	; (40a094 <TaskMain+0x58c>)
  409e96:	781b      	ldrb	r3, [r3, #0]
  409e98:	2b01      	cmp	r3, #1
  409e9a:	d002      	beq.n	409ea2 <TaskMain+0x39a>
			{
				debugPrintString("PW SW pressed\r\n");
  409e9c:	4882      	ldr	r0, [pc, #520]	; (40a0a8 <TaskMain+0x5a0>)
  409e9e:	4b83      	ldr	r3, [pc, #524]	; (40a0ac <TaskMain+0x5a4>)
  409ea0:	4798      	blx	r3
			}
			pwSwitchTimerFlag = 0;
  409ea2:	4b7c      	ldr	r3, [pc, #496]	; (40a094 <TaskMain+0x58c>)
  409ea4:	2200      	movs	r2, #0
  409ea6:	701a      	strb	r2, [r3, #0]
		}
	}	
	
	if ((drv_gpio_check_Int(DRV_GPIO_PIN_AC_SW1) == 1) || (SystemResetTimerFlag == 1))
  409ea8:	2001      	movs	r0, #1
  409eaa:	4b81      	ldr	r3, [pc, #516]	; (40a0b0 <TaskMain+0x5a8>)
  409eac:	4798      	blx	r3
  409eae:	4603      	mov	r3, r0
  409eb0:	2b00      	cmp	r3, #0
  409eb2:	d103      	bne.n	409ebc <TaskMain+0x3b4>
  409eb4:	4b7f      	ldr	r3, [pc, #508]	; (40a0b4 <TaskMain+0x5ac>)
  409eb6:	781b      	ldrb	r3, [r3, #0]
  409eb8:	2b01      	cmp	r3, #1
  409eba:	d154      	bne.n	409f66 <TaskMain+0x45e>
	{
		//task_stateMachine_EnqueueEvent(SYS_EVENT_RECORD_SWITCH,0); 
		if (recordSwToggle == FALSE)
  409ebc:	4b7e      	ldr	r3, [pc, #504]	; (40a0b8 <TaskMain+0x5b0>)
  409ebe:	781b      	ldrb	r3, [r3, #0]
  409ec0:	2b00      	cmp	r3, #0
  409ec2:	d11e      	bne.n	409f02 <TaskMain+0x3fa>
		{
			recordSwSet = TRUE;	//set the flag to as the pin is pulled low
  409ec4:	4b7d      	ldr	r3, [pc, #500]	; (40a0bc <TaskMain+0x5b4>)
  409ec6:	2201      	movs	r2, #1
  409ec8:	701a      	strb	r2, [r3, #0]
			if (resetSwSet == TRUE)	//check if reset switch was previously pressed
  409eca:	4b7d      	ldr	r3, [pc, #500]	; (40a0c0 <TaskMain+0x5b8>)
  409ecc:	781b      	ldrb	r3, [r3, #0]
  409ece:	2b00      	cmp	r3, #0
  409ed0:	d00f      	beq.n	409ef2 <TaskMain+0x3ea>
			{
				//initiate the timer as both the switches are pressed
				SystemResetTimerFlag = 0;
  409ed2:	4b78      	ldr	r3, [pc, #480]	; (40a0b4 <TaskMain+0x5ac>)
  409ed4:	2200      	movs	r2, #0
  409ed6:	701a      	strb	r2, [r3, #0]
				xTimerReset(SystemResetTimer, 0);
  409ed8:	4b7a      	ldr	r3, [pc, #488]	; (40a0c4 <TaskMain+0x5bc>)
  409eda:	681c      	ldr	r4, [r3, #0]
  409edc:	4b7a      	ldr	r3, [pc, #488]	; (40a0c8 <TaskMain+0x5c0>)
  409ede:	4798      	blx	r3
  409ee0:	4603      	mov	r3, r0
  409ee2:	2200      	movs	r2, #0
  409ee4:	9200      	str	r2, [sp, #0]
  409ee6:	4620      	mov	r0, r4
  409ee8:	2100      	movs	r1, #0
  409eea:	461a      	mov	r2, r3
  409eec:	2300      	movs	r3, #0
  409eee:	4c6b      	ldr	r4, [pc, #428]	; (40a09c <TaskMain+0x594>)
  409ef0:	47a0      	blx	r4
			}
			drv_gpio_config_interrupt(DRV_GPIO_PIN_AC_SW1, DRV_GPIO_INTERRUPT_HIGH_EDGE);	//Record pin pressed; configure interrupt for Rising edge
  409ef2:	2001      	movs	r0, #1
  409ef4:	2100      	movs	r1, #0
  409ef6:	4b6a      	ldr	r3, [pc, #424]	; (40a0a0 <TaskMain+0x598>)
  409ef8:	4798      	blx	r3
			recordSwToggle = TRUE;
  409efa:	4b6f      	ldr	r3, [pc, #444]	; (40a0b8 <TaskMain+0x5b0>)
  409efc:	2201      	movs	r2, #1
  409efe:	701a      	strb	r2, [r3, #0]
  409f00:	e031      	b.n	409f66 <TaskMain+0x45e>
		}
		else if((recordSwToggle == TRUE) || (SystemResetTimerFlag == 1))
  409f02:	2b00      	cmp	r3, #0
  409f04:	d103      	bne.n	409f0e <TaskMain+0x406>
  409f06:	4b6b      	ldr	r3, [pc, #428]	; (40a0b4 <TaskMain+0x5ac>)
  409f08:	781b      	ldrb	r3, [r3, #0]
  409f0a:	2b01      	cmp	r3, #1
  409f0c:	d12b      	bne.n	409f66 <TaskMain+0x45e>
		{
			recordSwSet = FALSE;
  409f0e:	4b6b      	ldr	r3, [pc, #428]	; (40a0bc <TaskMain+0x5b4>)
  409f10:	2200      	movs	r2, #0
  409f12:	701a      	strb	r2, [r3, #0]
			xTimerStop(SystemResetTimer, 0);
  409f14:	4b6b      	ldr	r3, [pc, #428]	; (40a0c4 <TaskMain+0x5bc>)
  409f16:	681b      	ldr	r3, [r3, #0]
  409f18:	2200      	movs	r2, #0
  409f1a:	9200      	str	r2, [sp, #0]
  409f1c:	4618      	mov	r0, r3
  409f1e:	2101      	movs	r1, #1
  409f20:	2200      	movs	r2, #0
  409f22:	2300      	movs	r3, #0
  409f24:	4c5d      	ldr	r4, [pc, #372]	; (40a09c <TaskMain+0x594>)
  409f26:	47a0      	blx	r4
			drv_gpio_config_interrupt(DRV_GPIO_PIN_AC_SW1, DRV_GPIO_INTERRUPT_LOW_EDGE);	//Record pin released; configure interrupt for Falling edge
  409f28:	2001      	movs	r0, #1
  409f2a:	2101      	movs	r1, #1
  409f2c:	4b5c      	ldr	r3, [pc, #368]	; (40a0a0 <TaskMain+0x598>)
  409f2e:	4798      	blx	r3
			recordSwToggle = FALSE;
  409f30:	4b61      	ldr	r3, [pc, #388]	; (40a0b8 <TaskMain+0x5b0>)
  409f32:	2200      	movs	r2, #0
  409f34:	701a      	strb	r2, [r3, #0]
			if (SystemResetTimerFlag == 1)
  409f36:	4b5f      	ldr	r3, [pc, #380]	; (40a0b4 <TaskMain+0x5ac>)
  409f38:	781b      	ldrb	r3, [r3, #0]
  409f3a:	2b01      	cmp	r3, #1
  409f3c:	d109      	bne.n	409f52 <TaskMain+0x44a>
			{
				debugPrintString("System reset triggered\r\n");
  409f3e:	4863      	ldr	r0, [pc, #396]	; (40a0cc <TaskMain+0x5c4>)
  409f40:	4b5a      	ldr	r3, [pc, #360]	; (40a0ac <TaskMain+0x5a4>)
  409f42:	4798      	blx	r3
				vTaskDelay(200); //wait for the log to be written
  409f44:	20c8      	movs	r0, #200	; 0xc8
  409f46:	4b62      	ldr	r3, [pc, #392]	; (40a0d0 <TaskMain+0x5c8>)
  409f48:	4798      	blx	r3
				rstc_start_software_reset(RSTC);
  409f4a:	4862      	ldr	r0, [pc, #392]	; (40a0d4 <TaskMain+0x5cc>)
  409f4c:	4b62      	ldr	r3, [pc, #392]	; (40a0d8 <TaskMain+0x5d0>)
  409f4e:	4798      	blx	r3
  409f50:	e006      	b.n	409f60 <TaskMain+0x458>
			}
			else
			{
				task_stateMachine_EnqueueEvent(SYS_EVENT_RECORD_SWITCH,0);
  409f52:	2002      	movs	r0, #2
  409f54:	2100      	movs	r1, #0
  409f56:	4b61      	ldr	r3, [pc, #388]	; (40a0dc <TaskMain+0x5d4>)
  409f58:	4798      	blx	r3
				debugPrintString("Record switch pressed\r\n");
  409f5a:	4861      	ldr	r0, [pc, #388]	; (40a0e0 <TaskMain+0x5d8>)
  409f5c:	4b53      	ldr	r3, [pc, #332]	; (40a0ac <TaskMain+0x5a4>)
  409f5e:	4798      	blx	r3
			}
			SystemResetTimerFlag = 0;
  409f60:	4b54      	ldr	r3, [pc, #336]	; (40a0b4 <TaskMain+0x5ac>)
  409f62:	2200      	movs	r2, #0
  409f64:	701a      	strb	r2, [r3, #0]
		}
	}	
	
	if ((drv_gpio_check_Int(DRV_GPIO_PIN_AC_SW2) == 1) || (SystemResetTimerFlag == 1) || (ResetButtonTimerFlag == 1))
  409f66:	2002      	movs	r0, #2
  409f68:	4b51      	ldr	r3, [pc, #324]	; (40a0b0 <TaskMain+0x5a8>)
  409f6a:	4798      	blx	r3
  409f6c:	4603      	mov	r3, r0
  409f6e:	2b00      	cmp	r3, #0
  409f70:	d108      	bne.n	409f84 <TaskMain+0x47c>
  409f72:	4b50      	ldr	r3, [pc, #320]	; (40a0b4 <TaskMain+0x5ac>)
  409f74:	781b      	ldrb	r3, [r3, #0]
  409f76:	2b01      	cmp	r3, #1
  409f78:	d004      	beq.n	409f84 <TaskMain+0x47c>
  409f7a:	4b5a      	ldr	r3, [pc, #360]	; (40a0e4 <TaskMain+0x5dc>)
  409f7c:	781b      	ldrb	r3, [r3, #0]
  409f7e:	2b01      	cmp	r3, #1
  409f80:	f040 80c9 	bne.w	40a116 <TaskMain+0x60e>
	{
		//task_stateMachine_EnqueueEvent(SYS_EVENT_RESET_SWITCH,0); 		
		if (resetSwToggle == FALSE)
  409f84:	4b58      	ldr	r3, [pc, #352]	; (40a0e8 <TaskMain+0x5e0>)
  409f86:	781b      	ldrb	r3, [r3, #0]
  409f88:	2b00      	cmp	r3, #0
  409f8a:	d12e      	bne.n	409fea <TaskMain+0x4e2>
		{
			resetSwSet = TRUE;	//set the flag to as the pin is pulled low
  409f8c:	4b4c      	ldr	r3, [pc, #304]	; (40a0c0 <TaskMain+0x5b8>)
  409f8e:	2201      	movs	r2, #1
  409f90:	701a      	strb	r2, [r3, #0]
			if (recordSwSet == TRUE)	//check if record switch was previously pressed
  409f92:	4b4a      	ldr	r3, [pc, #296]	; (40a0bc <TaskMain+0x5b4>)
  409f94:	781b      	ldrb	r3, [r3, #0]
  409f96:	2b00      	cmp	r3, #0
  409f98:	d00f      	beq.n	409fba <TaskMain+0x4b2>
			{
				//initiate the timer as both the switches are pressed
				SystemResetTimerFlag = 0;
  409f9a:	4b46      	ldr	r3, [pc, #280]	; (40a0b4 <TaskMain+0x5ac>)
  409f9c:	2200      	movs	r2, #0
  409f9e:	701a      	strb	r2, [r3, #0]
				xTimerReset(SystemResetTimer, 0);
  409fa0:	4b48      	ldr	r3, [pc, #288]	; (40a0c4 <TaskMain+0x5bc>)
  409fa2:	681c      	ldr	r4, [r3, #0]
  409fa4:	4b48      	ldr	r3, [pc, #288]	; (40a0c8 <TaskMain+0x5c0>)
  409fa6:	4798      	blx	r3
  409fa8:	4603      	mov	r3, r0
  409faa:	2200      	movs	r2, #0
  409fac:	9200      	str	r2, [sp, #0]
  409fae:	4620      	mov	r0, r4
  409fb0:	2100      	movs	r1, #0
  409fb2:	461a      	mov	r2, r3
  409fb4:	2300      	movs	r3, #0
  409fb6:	4c39      	ldr	r4, [pc, #228]	; (40a09c <TaskMain+0x594>)
  409fb8:	47a0      	blx	r4
			}
			//initiate the Reset button timer and clear the flag
			ResetButtonTimerFlag = 0;
  409fba:	4b4a      	ldr	r3, [pc, #296]	; (40a0e4 <TaskMain+0x5dc>)
  409fbc:	2200      	movs	r2, #0
  409fbe:	701a      	strb	r2, [r3, #0]
			xTimerReset(ResetButtonTimer, 0);
  409fc0:	4b4a      	ldr	r3, [pc, #296]	; (40a0ec <TaskMain+0x5e4>)
  409fc2:	681c      	ldr	r4, [r3, #0]
  409fc4:	4b40      	ldr	r3, [pc, #256]	; (40a0c8 <TaskMain+0x5c0>)
  409fc6:	4798      	blx	r3
  409fc8:	4603      	mov	r3, r0
  409fca:	2200      	movs	r2, #0
  409fcc:	9200      	str	r2, [sp, #0]
  409fce:	4620      	mov	r0, r4
  409fd0:	2100      	movs	r1, #0
  409fd2:	461a      	mov	r2, r3
  409fd4:	2300      	movs	r3, #0
  409fd6:	4c31      	ldr	r4, [pc, #196]	; (40a09c <TaskMain+0x594>)
  409fd8:	47a0      	blx	r4
			drv_gpio_config_interrupt(DRV_GPIO_PIN_AC_SW2, DRV_GPIO_INTERRUPT_HIGH_EDGE);	//Reset pin pressed; configure interrupt for Rising edge
  409fda:	2002      	movs	r0, #2
  409fdc:	2100      	movs	r1, #0
  409fde:	4b30      	ldr	r3, [pc, #192]	; (40a0a0 <TaskMain+0x598>)
  409fe0:	4798      	blx	r3
			resetSwToggle = TRUE;
  409fe2:	4b41      	ldr	r3, [pc, #260]	; (40a0e8 <TaskMain+0x5e0>)
  409fe4:	2201      	movs	r2, #1
  409fe6:	701a      	strb	r2, [r3, #0]
  409fe8:	e095      	b.n	40a116 <TaskMain+0x60e>
		}
		else if((resetSwToggle == TRUE) || (SystemResetTimerFlag == 1) || (ResetButtonTimerFlag == 1))
  409fea:	2b00      	cmp	r3, #0
  409fec:	d108      	bne.n	40a000 <TaskMain+0x4f8>
  409fee:	4b31      	ldr	r3, [pc, #196]	; (40a0b4 <TaskMain+0x5ac>)
  409ff0:	781b      	ldrb	r3, [r3, #0]
  409ff2:	2b01      	cmp	r3, #1
  409ff4:	d004      	beq.n	40a000 <TaskMain+0x4f8>
  409ff6:	4b3b      	ldr	r3, [pc, #236]	; (40a0e4 <TaskMain+0x5dc>)
  409ff8:	781b      	ldrb	r3, [r3, #0]
  409ffa:	2b01      	cmp	r3, #1
  409ffc:	f040 808b 	bne.w	40a116 <TaskMain+0x60e>
		{
			resetSwSet = FALSE;
  40a000:	4b2f      	ldr	r3, [pc, #188]	; (40a0c0 <TaskMain+0x5b8>)
  40a002:	2200      	movs	r2, #0
  40a004:	701a      	strb	r2, [r3, #0]
			if (SystemResetTimerFlag == 1)
  40a006:	4b2b      	ldr	r3, [pc, #172]	; (40a0b4 <TaskMain+0x5ac>)
  40a008:	781b      	ldrb	r3, [r3, #0]
  40a00a:	2b01      	cmp	r3, #1
  40a00c:	d109      	bne.n	40a022 <TaskMain+0x51a>
			{
				xTimerStop(SystemResetTimer, 0);	//only stop SystemReset timer if it was its event
  40a00e:	4b2d      	ldr	r3, [pc, #180]	; (40a0c4 <TaskMain+0x5bc>)
  40a010:	681b      	ldr	r3, [r3, #0]
  40a012:	2200      	movs	r2, #0
  40a014:	9200      	str	r2, [sp, #0]
  40a016:	4618      	mov	r0, r3
  40a018:	2101      	movs	r1, #1
  40a01a:	2200      	movs	r2, #0
  40a01c:	2300      	movs	r3, #0
  40a01e:	4c1f      	ldr	r4, [pc, #124]	; (40a09c <TaskMain+0x594>)
  40a020:	47a0      	blx	r4
			}
			if (ResetButtonTimerFlag == 1)
  40a022:	4b30      	ldr	r3, [pc, #192]	; (40a0e4 <TaskMain+0x5dc>)
  40a024:	781b      	ldrb	r3, [r3, #0]
  40a026:	2b01      	cmp	r3, #1
  40a028:	d109      	bne.n	40a03e <TaskMain+0x536>
			{
				xTimerStop(ResetButtonTimer, 0);	//only stop ResetButton timer if it was its event
  40a02a:	4b30      	ldr	r3, [pc, #192]	; (40a0ec <TaskMain+0x5e4>)
  40a02c:	681b      	ldr	r3, [r3, #0]
  40a02e:	2200      	movs	r2, #0
  40a030:	9200      	str	r2, [sp, #0]
  40a032:	4618      	mov	r0, r3
  40a034:	2101      	movs	r1, #1
  40a036:	2200      	movs	r2, #0
  40a038:	2300      	movs	r3, #0
  40a03a:	4c18      	ldr	r4, [pc, #96]	; (40a09c <TaskMain+0x594>)
  40a03c:	47a0      	blx	r4
			}
			drv_gpio_config_interrupt(DRV_GPIO_PIN_AC_SW2, DRV_GPIO_INTERRUPT_LOW_EDGE);	//Reset pin released; configure interrupt for Falling edge
  40a03e:	2002      	movs	r0, #2
  40a040:	2101      	movs	r1, #1
  40a042:	4b17      	ldr	r3, [pc, #92]	; (40a0a0 <TaskMain+0x598>)
  40a044:	4798      	blx	r3
			resetSwToggle = FALSE;
  40a046:	4b28      	ldr	r3, [pc, #160]	; (40a0e8 <TaskMain+0x5e0>)
  40a048:	2200      	movs	r2, #0
  40a04a:	701a      	strb	r2, [r3, #0]
			if (SystemResetTimerFlag == 1)
  40a04c:	4b19      	ldr	r3, [pc, #100]	; (40a0b4 <TaskMain+0x5ac>)
  40a04e:	781b      	ldrb	r3, [r3, #0]
  40a050:	2b01      	cmp	r3, #1
  40a052:	d106      	bne.n	40a062 <TaskMain+0x55a>
			{
				debugPrintString("System reset triggered\r\n");
  40a054:	481d      	ldr	r0, [pc, #116]	; (40a0cc <TaskMain+0x5c4>)
  40a056:	4b15      	ldr	r3, [pc, #84]	; (40a0ac <TaskMain+0x5a4>)
  40a058:	4798      	blx	r3
				rstc_start_software_reset(RSTC);
  40a05a:	481e      	ldr	r0, [pc, #120]	; (40a0d4 <TaskMain+0x5cc>)
  40a05c:	4b1e      	ldr	r3, [pc, #120]	; (40a0d8 <TaskMain+0x5d0>)
  40a05e:	4798      	blx	r3
  40a060:	e053      	b.n	40a10a <TaskMain+0x602>
			}
			else
			{
				if (!ResetButtonTimerFlag)
  40a062:	4b20      	ldr	r3, [pc, #128]	; (40a0e4 <TaskMain+0x5dc>)
  40a064:	781b      	ldrb	r3, [r3, #0]
  40a066:	2b00      	cmp	r3, #0
  40a068:	d148      	bne.n	40a0fc <TaskMain+0x5f4>
				{
					//Pass an event to dataProcessor to log button press
					packet.type = DATA_PACKET_TYPE_BUTTON;
  40a06a:	2305      	movs	r3, #5
  40a06c:	723b      	strb	r3, [r7, #8]
					if (queue_dataHandler != NULL)
  40a06e:	4b20      	ldr	r3, [pc, #128]	; (40a0f0 <TaskMain+0x5e8>)
  40a070:	681b      	ldr	r3, [r3, #0]
  40a072:	2b00      	cmp	r3, #0
  40a074:	d049      	beq.n	40a10a <TaskMain+0x602>
					{
						if(xQueueSendToBack( queue_dataHandler,( void * ) &packet,5) != TRUE)
  40a076:	f107 0208 	add.w	r2, r7, #8
  40a07a:	4618      	mov	r0, r3
  40a07c:	4611      	mov	r1, r2
  40a07e:	2205      	movs	r2, #5
  40a080:	2300      	movs	r3, #0
  40a082:	4c1c      	ldr	r4, [pc, #112]	; (40a0f4 <TaskMain+0x5ec>)
  40a084:	47a0      	blx	r4
  40a086:	4603      	mov	r3, r0
  40a088:	2b01      	cmp	r3, #1
  40a08a:	d03e      	beq.n	40a10a <TaskMain+0x602>
						{
							//error failed to queue the packet.
							debugPrintString("Queue Full Dropped packet\r\n");
  40a08c:	481a      	ldr	r0, [pc, #104]	; (40a0f8 <TaskMain+0x5f0>)
  40a08e:	4b07      	ldr	r3, [pc, #28]	; (40a0ac <TaskMain+0x5a4>)
  40a090:	4798      	blx	r3
  40a092:	e03a      	b.n	40a10a <TaskMain+0x602>
  40a094:	200038a1 	.word	0x200038a1
  40a098:	20005030 	.word	0x20005030
  40a09c:	00407949 	.word	0x00407949
  40a0a0:	00408871 	.word	0x00408871
  40a0a4:	200038a3 	.word	0x200038a3
  40a0a8:	00416a18 	.word	0x00416a18
  40a0ac:	004008c9 	.word	0x004008c9
  40a0b0:	004088cd 	.word	0x004088cd
  40a0b4:	200038a2 	.word	0x200038a2
  40a0b8:	2000389e 	.word	0x2000389e
  40a0bc:	2000389c 	.word	0x2000389c
  40a0c0:	2000389d 	.word	0x2000389d
  40a0c4:	20005028 	.word	0x20005028
  40a0c8:	004070a1 	.word	0x004070a1
  40a0cc:	00416a28 	.word	0x00416a28
  40a0d0:	004072ed 	.word	0x004072ed
  40a0d4:	400e1400 	.word	0x400e1400
  40a0d8:	004003ed 	.word	0x004003ed
  40a0dc:	00401a99 	.word	0x00401a99
  40a0e0:	00416a44 	.word	0x00416a44
  40a0e4:	200038a0 	.word	0x200038a0
  40a0e8:	2000389f 	.word	0x2000389f
  40a0ec:	20005024 	.word	0x20005024
  40a0f0:	20003874 	.word	0x20003874
  40a0f4:	00406979 	.word	0x00406979
  40a0f8:	00416a5c 	.word	0x00416a5c
						}
					}
				}
				else
				{
					task_stateMachine_EnqueueEvent(SYS_EVENT_RESET_SWITCH,0);
  40a0fc:	2001      	movs	r0, #1
  40a0fe:	2100      	movs	r1, #0
  40a100:	4b84      	ldr	r3, [pc, #528]	; (40a314 <TaskMain+0x80c>)
  40a102:	4798      	blx	r3
					debugPrintString("Reset switch pressed\r\n");
  40a104:	4884      	ldr	r0, [pc, #528]	; (40a318 <TaskMain+0x810>)
  40a106:	4b85      	ldr	r3, [pc, #532]	; (40a31c <TaskMain+0x814>)
  40a108:	4798      	blx	r3
				}
			}
			ResetButtonTimerFlag = 0;
  40a10a:	4b85      	ldr	r3, [pc, #532]	; (40a320 <TaskMain+0x818>)
  40a10c:	2200      	movs	r2, #0
  40a10e:	701a      	strb	r2, [r3, #0]
			SystemResetTimerFlag = 0;
  40a110:	4b84      	ldr	r3, [pc, #528]	; (40a324 <TaskMain+0x81c>)
  40a112:	2200      	movs	r2, #0
  40a114:	701a      	strb	r2, [r3, #0]
		}
	}	
	if (drv_gpio_check_Int(DRV_GPIO_PIN_JC_OC1) == 1)
  40a116:	2003      	movs	r0, #3
  40a118:	4b83      	ldr	r3, [pc, #524]	; (40a328 <TaskMain+0x820>)
  40a11a:	4798      	blx	r3
  40a11c:	4603      	mov	r3, r0
  40a11e:	2b00      	cmp	r3, #0
  40a120:	d002      	beq.n	40a128 <TaskMain+0x620>
	{
		//task_stateMachine_EnqueueEvent(SYS_EVENT_OVER_CURRENT,1);
		debugPrintString("Jack 1 Over current\r\n");
  40a122:	4882      	ldr	r0, [pc, #520]	; (40a32c <TaskMain+0x824>)
  40a124:	4b7d      	ldr	r3, [pc, #500]	; (40a31c <TaskMain+0x814>)
  40a126:	4798      	blx	r3
	}	
	if (drv_gpio_check_Int(DRV_GPIO_PIN_JC_OC2) == 1)
  40a128:	2004      	movs	r0, #4
  40a12a:	4b7f      	ldr	r3, [pc, #508]	; (40a328 <TaskMain+0x820>)
  40a12c:	4798      	blx	r3
  40a12e:	4603      	mov	r3, r0
  40a130:	2b00      	cmp	r3, #0
  40a132:	d002      	beq.n	40a13a <TaskMain+0x632>
	{
		//task_stateMachine_EnqueueEvent(SYS_EVENT_OVER_CURRENT,2);
		debugPrintString("Jack 2 Over current\r\n");
  40a134:	487e      	ldr	r0, [pc, #504]	; (40a330 <TaskMain+0x828>)
  40a136:	4b79      	ldr	r3, [pc, #484]	; (40a31c <TaskMain+0x814>)
  40a138:	4798      	blx	r3
	}	
	if (drv_gpio_check_Int(DRV_GPIO_PIN_JC_DC1) == 1)
  40a13a:	2005      	movs	r0, #5
  40a13c:	4b7a      	ldr	r3, [pc, #488]	; (40a328 <TaskMain+0x820>)
  40a13e:	4798      	blx	r3
  40a140:	4603      	mov	r3, r0
  40a142:	2b00      	cmp	r3, #0
  40a144:	d002      	beq.n	40a14c <TaskMain+0x644>
	{
		//task_stateMachine_EnqueueEvent(SYS_EVENT_JACK_DETECT,1);
		debugPrintString("Jack 1 removed\r\n");	//inserted or removed?
  40a146:	487b      	ldr	r0, [pc, #492]	; (40a334 <TaskMain+0x82c>)
  40a148:	4b74      	ldr	r3, [pc, #464]	; (40a31c <TaskMain+0x814>)
  40a14a:	4798      	blx	r3
	}	
	if (drv_gpio_check_Int(DRV_GPIO_PIN_JC_DC2) == 1)
  40a14c:	2006      	movs	r0, #6
  40a14e:	4b76      	ldr	r3, [pc, #472]	; (40a328 <TaskMain+0x820>)
  40a150:	4798      	blx	r3
  40a152:	4603      	mov	r3, r0
  40a154:	2b00      	cmp	r3, #0
  40a156:	d002      	beq.n	40a15e <TaskMain+0x656>
	{
		//task_stateMachine_EnqueueEvent(SYS_EVENT_JACK_DETECT,2);
		debugPrintString("Jack 2 removed\r\n");	//inserted or removed?
  40a158:	4877      	ldr	r0, [pc, #476]	; (40a338 <TaskMain+0x830>)
  40a15a:	4b70      	ldr	r3, [pc, #448]	; (40a31c <TaskMain+0x814>)
  40a15c:	4798      	blx	r3
	}	
	if (drv_gpio_check_Int(DRV_GPIO_PIN_LBO) == 1)
  40a15e:	200f      	movs	r0, #15
  40a160:	4b71      	ldr	r3, [pc, #452]	; (40a328 <TaskMain+0x820>)
  40a162:	4798      	blx	r3
  40a164:	4603      	mov	r3, r0
  40a166:	2b00      	cmp	r3, #0
  40a168:	d006      	beq.n	40a178 <TaskMain+0x670>
	{
		#ifndef USES_NEW_POWER_BOARD
		debugPrintString("Battery Low\r\n");
  40a16a:	4874      	ldr	r0, [pc, #464]	; (40a33c <TaskMain+0x834>)
  40a16c:	4b6b      	ldr	r3, [pc, #428]	; (40a31c <TaskMain+0x814>)
  40a16e:	4798      	blx	r3
		task_stateMachine_EnqueueEvent(SYS_EVENT_LOW_BATTERY,0);
  40a170:	2009      	movs	r0, #9
  40a172:	2100      	movs	r1, #0
  40a174:	4b67      	ldr	r3, [pc, #412]	; (40a314 <TaskMain+0x80c>)
  40a176:	4798      	blx	r3
		#endif
	}

	if (drv_gpio_check_Int(DRV_GPIO_PIN_SD_CD) == 1)
  40a178:	2010      	movs	r0, #16
  40a17a:	4b6b      	ldr	r3, [pc, #428]	; (40a328 <TaskMain+0x820>)
  40a17c:	4798      	blx	r3
  40a17e:	4603      	mov	r3, r0
  40a180:	2b00      	cmp	r3, #0
  40a182:	d01e      	beq.n	40a1c2 <TaskMain+0x6ba>
	{
		drv_gpio_pin_state_t sdCdPinState;
		drv_gpio_getPinState(DRV_GPIO_PIN_SD_CD, &sdCdPinState);
  40a184:	f107 032d 	add.w	r3, r7, #45	; 0x2d
  40a188:	2010      	movs	r0, #16
  40a18a:	4619      	mov	r1, r3
  40a18c:	4b6c      	ldr	r3, [pc, #432]	; (40a340 <TaskMain+0x838>)
  40a18e:	4798      	blx	r3
		if (sdCdPinState == DRV_GPIO_PIN_STATE_LOW)
  40a190:	f897 302d 	ldrb.w	r3, [r7, #45]	; 0x2d
  40a194:	2b00      	cmp	r3, #0
  40a196:	d10b      	bne.n	40a1b0 <TaskMain+0x6a8>
		{
			debugPrintString("SD-card removed\r\n");
  40a198:	486a      	ldr	r0, [pc, #424]	; (40a344 <TaskMain+0x83c>)
  40a19a:	4b60      	ldr	r3, [pc, #384]	; (40a31c <TaskMain+0x814>)
  40a19c:	4798      	blx	r3
			//SD card not present, set the respective event
			task_stateMachine_EnqueueEvent(SYS_EVENT_SD_FILE_ERROR,0);
  40a19e:	2005      	movs	r0, #5
  40a1a0:	2100      	movs	r1, #0
  40a1a2:	4b5c      	ldr	r3, [pc, #368]	; (40a314 <TaskMain+0x80c>)
  40a1a4:	4798      	blx	r3
			//reconfigure the SD-card interrupt to look for insertion of card
			drv_gpio_config_interrupt(DRV_GPIO_PIN_SD_CD, DRV_GPIO_INTERRUPT_HIGH_EDGE);
  40a1a6:	2010      	movs	r0, #16
  40a1a8:	2100      	movs	r1, #0
  40a1aa:	4b67      	ldr	r3, [pc, #412]	; (40a348 <TaskMain+0x840>)
  40a1ac:	4798      	blx	r3
  40a1ae:	e008      	b.n	40a1c2 <TaskMain+0x6ba>
		}
		else if (sdCdPinState == DRV_GPIO_PIN_STATE_HIGH)
  40a1b0:	2b01      	cmp	r3, #1
  40a1b2:	d106      	bne.n	40a1c2 <TaskMain+0x6ba>
		{
			debugPrintString("SD-card inserted\r\n");
  40a1b4:	4865      	ldr	r0, [pc, #404]	; (40a34c <TaskMain+0x844>)
  40a1b6:	4b59      	ldr	r3, [pc, #356]	; (40a31c <TaskMain+0x814>)
  40a1b8:	4798      	blx	r3
			//SD card present or inserted, set the respective event
			//drv_gpio_config_interrupt(DRV_GPIO_PIN_SD_CD, DRV_GPIO_INTERRUPT_LOW_EDGE);	//set in reloadConfigSettings()
			task_stateMachine_EnqueueEvent(SYS_EVENT_SD_CARD_DETECT,0);
  40a1ba:	2004      	movs	r0, #4
  40a1bc:	2100      	movs	r1, #0
  40a1be:	4b55      	ldr	r3, [pc, #340]	; (40a314 <TaskMain+0x80c>)
  40a1c0:	4798      	blx	r3
	for (;;) 
	{
		/*	Hardware Test routine	*/
		wdt_restart(WDT);
		checkInputGpio();
		if (getCurrentState() != (SYS_STATE_OFF))
  40a1c2:	4b63      	ldr	r3, [pc, #396]	; (40a350 <TaskMain+0x848>)
  40a1c4:	4798      	blx	r3
  40a1c6:	4603      	mov	r3, r0
  40a1c8:	2b00      	cmp	r3, #0
  40a1ca:	f000 80fb 	beq.w	40a3c4 <TaskMain+0x8bc>
  40a1ce:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  40a1d0:	637b      	str	r3, [r7, #52]	; 0x34
 * @return void
 ***********************************************************************************************/
static void checkRtosStack(int loopCount)
{
	unsigned portBASE_TYPE vHighWaterMark;
 	switch (loopCount)
  40a1d2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  40a1d4:	2b07      	cmp	r3, #7
  40a1d6:	f200 80ed 	bhi.w	40a3b4 <TaskMain+0x8ac>
  40a1da:	a201      	add	r2, pc, #4	; (adr r2, 40a1e0 <TaskMain+0x6d8>)
  40a1dc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40a1e0:	0040a201 	.word	0x0040a201
  40a1e4:	0040a229 	.word	0x0040a229
  40a1e8:	0040a251 	.word	0x0040a251
  40a1ec:	0040a27b 	.word	0x0040a27b
  40a1f0:	0040a2a3 	.word	0x0040a2a3
  40a1f4:	0040a2c9 	.word	0x0040a2c9
  40a1f8:	0040a2ef 	.word	0x0040a2ef
  40a1fc:	0040a391 	.word	0x0040a391
 	{
	 	case 0:
	 		vHighWaterMark = uxTaskGetStackHighWaterMark(quinticConfig[0].taskHandle);
  40a200:	4b54      	ldr	r3, [pc, #336]	; (40a354 <TaskMain+0x84c>)
  40a202:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  40a204:	4618      	mov	r0, r3
  40a206:	4b54      	ldr	r3, [pc, #336]	; (40a358 <TaskMain+0x850>)
  40a208:	4798      	blx	r3
  40a20a:	6338      	str	r0, [r7, #48]	; 0x30
	 		//if (vHighWaterMark < 100)
	 		//{
				 if (vHighWaterMark < vTaskStackSize[0])
  40a20c:	4b53      	ldr	r3, [pc, #332]	; (40a35c <TaskMain+0x854>)
  40a20e:	681b      	ldr	r3, [r3, #0]
  40a210:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  40a212:	429a      	cmp	r2, r3
  40a214:	f080 80ce 	bcs.w	40a3b4 <TaskMain+0x8ac>
				 {
					 debugPrintStringInt("Quintic task Q0 stack new high water mark\r\n", vHighWaterMark);
  40a218:	6b3c      	ldr	r4, [r7, #48]	; 0x30
  40a21a:	4851      	ldr	r0, [pc, #324]	; (40a360 <TaskMain+0x858>)
  40a21c:	4621      	mov	r1, r4
  40a21e:	4b51      	ldr	r3, [pc, #324]	; (40a364 <TaskMain+0x85c>)
  40a220:	4798      	blx	r3
					 vTaskStackSize[0] = vHighWaterMark;
  40a222:	4b4e      	ldr	r3, [pc, #312]	; (40a35c <TaskMain+0x854>)
  40a224:	601c      	str	r4, [r3, #0]
  40a226:	e0c5      	b.n	40a3b4 <TaskMain+0x8ac>
				 }
	 		//}
	 	break;
	 	case 1:
		 #ifdef USE_ALL_QUINTICS
		 	vHighWaterMark = uxTaskGetStackHighWaterMark(quinticConfig[1].taskHandle);
  40a228:	4b4a      	ldr	r3, [pc, #296]	; (40a354 <TaskMain+0x84c>)
  40a22a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  40a22c:	4618      	mov	r0, r3
  40a22e:	4b4a      	ldr	r3, [pc, #296]	; (40a358 <TaskMain+0x850>)
  40a230:	4798      	blx	r3
  40a232:	6338      	str	r0, [r7, #48]	; 0x30
		 	//if (vHighWaterMark < 100)
		 	//{
			 	 if (vHighWaterMark < vTaskStackSize[1])
  40a234:	4b49      	ldr	r3, [pc, #292]	; (40a35c <TaskMain+0x854>)
  40a236:	685b      	ldr	r3, [r3, #4]
  40a238:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  40a23a:	429a      	cmp	r2, r3
  40a23c:	f080 80ba 	bcs.w	40a3b4 <TaskMain+0x8ac>
			 	 {
				 	 debugPrintStringInt("Quintic task Q1 stack new high water mark\r\n", vHighWaterMark);
  40a240:	6b3c      	ldr	r4, [r7, #48]	; 0x30
  40a242:	4849      	ldr	r0, [pc, #292]	; (40a368 <TaskMain+0x860>)
  40a244:	4621      	mov	r1, r4
  40a246:	4b47      	ldr	r3, [pc, #284]	; (40a364 <TaskMain+0x85c>)
  40a248:	4798      	blx	r3
				 	 vTaskStackSize[1] = vHighWaterMark;
  40a24a:	4b44      	ldr	r3, [pc, #272]	; (40a35c <TaskMain+0x854>)
  40a24c:	605c      	str	r4, [r3, #4]
  40a24e:	e0b1      	b.n	40a3b4 <TaskMain+0x8ac>
			 	 }
		 	//}
		#endif
	 	break;
		case 2:
			vHighWaterMark = uxTaskGetStackHighWaterMark(quinticConfig[2].taskHandle);
  40a250:	4b40      	ldr	r3, [pc, #256]	; (40a354 <TaskMain+0x84c>)
  40a252:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
  40a256:	4618      	mov	r0, r3
  40a258:	4b3f      	ldr	r3, [pc, #252]	; (40a358 <TaskMain+0x850>)
  40a25a:	4798      	blx	r3
  40a25c:	6338      	str	r0, [r7, #48]	; 0x30
			//if (vHighWaterMark < 100)
			//{
				if (vHighWaterMark < vTaskStackSize[2])
  40a25e:	4b3f      	ldr	r3, [pc, #252]	; (40a35c <TaskMain+0x854>)
  40a260:	689b      	ldr	r3, [r3, #8]
  40a262:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  40a264:	429a      	cmp	r2, r3
  40a266:	f080 80a5 	bcs.w	40a3b4 <TaskMain+0x8ac>
				{
					debugPrintStringInt("Quintic task Q2 stack new high water mark\r\n", vHighWaterMark);
  40a26a:	6b3c      	ldr	r4, [r7, #48]	; 0x30
  40a26c:	483f      	ldr	r0, [pc, #252]	; (40a36c <TaskMain+0x864>)
  40a26e:	4621      	mov	r1, r4
  40a270:	4b3c      	ldr	r3, [pc, #240]	; (40a364 <TaskMain+0x85c>)
  40a272:	4798      	blx	r3
					vTaskStackSize[2] = vHighWaterMark;
  40a274:	4b39      	ldr	r3, [pc, #228]	; (40a35c <TaskMain+0x854>)
  40a276:	609c      	str	r4, [r3, #8]
  40a278:	e09c      	b.n	40a3b4 <TaskMain+0x8ac>
				}
			//}
		break;
		case 3:
		 	vHighWaterMark = uxTaskGetStackHighWaterMark(fabSenseTaskHandle);
  40a27a:	4b3d      	ldr	r3, [pc, #244]	; (40a370 <TaskMain+0x868>)
  40a27c:	681b      	ldr	r3, [r3, #0]
  40a27e:	4618      	mov	r0, r3
  40a280:	4b35      	ldr	r3, [pc, #212]	; (40a358 <TaskMain+0x850>)
  40a282:	4798      	blx	r3
  40a284:	6338      	str	r0, [r7, #48]	; 0x30
		 	//if (vHighWaterMark < 100)
		 	//{
				if (vHighWaterMark < vTaskStackSize[3])
  40a286:	4b35      	ldr	r3, [pc, #212]	; (40a35c <TaskMain+0x854>)
  40a288:	68db      	ldr	r3, [r3, #12]
  40a28a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  40a28c:	429a      	cmp	r2, r3
  40a28e:	f080 8091 	bcs.w	40a3b4 <TaskMain+0x8ac>
				{
			 		debugPrintStringInt("Fabric Sense task stack new high water mark\r\n", vHighWaterMark);
  40a292:	6b3c      	ldr	r4, [r7, #48]	; 0x30
  40a294:	4837      	ldr	r0, [pc, #220]	; (40a374 <TaskMain+0x86c>)
  40a296:	4621      	mov	r1, r4
  40a298:	4b32      	ldr	r3, [pc, #200]	; (40a364 <TaskMain+0x85c>)
  40a29a:	4798      	blx	r3
					vTaskStackSize[3] = vHighWaterMark;
  40a29c:	4b2f      	ldr	r3, [pc, #188]	; (40a35c <TaskMain+0x854>)
  40a29e:	60dc      	str	r4, [r3, #12]
  40a2a0:	e088      	b.n	40a3b4 <TaskMain+0x8ac>
				}
		 	//}
	 	break;
		case 4:
			vHighWaterMark = uxTaskGetStackHighWaterMark(cmdHandlerTaskHandle);
  40a2a2:	4b35      	ldr	r3, [pc, #212]	; (40a378 <TaskMain+0x870>)
  40a2a4:	681b      	ldr	r3, [r3, #0]
  40a2a6:	4618      	mov	r0, r3
  40a2a8:	4b2b      	ldr	r3, [pc, #172]	; (40a358 <TaskMain+0x850>)
  40a2aa:	4798      	blx	r3
  40a2ac:	6338      	str	r0, [r7, #48]	; 0x30
			//if (vHighWaterMark < 100)
			//{
				if (vHighWaterMark < vTaskStackSize[4])
  40a2ae:	4b2b      	ldr	r3, [pc, #172]	; (40a35c <TaskMain+0x854>)
  40a2b0:	691b      	ldr	r3, [r3, #16]
  40a2b2:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  40a2b4:	429a      	cmp	r2, r3
  40a2b6:	d27d      	bcs.n	40a3b4 <TaskMain+0x8ac>
				{
					debugPrintStringInt("Command-Handler task stack new high water mark\r\n", vHighWaterMark);
  40a2b8:	6b3c      	ldr	r4, [r7, #48]	; 0x30
  40a2ba:	4830      	ldr	r0, [pc, #192]	; (40a37c <TaskMain+0x874>)
  40a2bc:	4621      	mov	r1, r4
  40a2be:	4b29      	ldr	r3, [pc, #164]	; (40a364 <TaskMain+0x85c>)
  40a2c0:	4798      	blx	r3
					vTaskStackSize[4] = vHighWaterMark;
  40a2c2:	4b26      	ldr	r3, [pc, #152]	; (40a35c <TaskMain+0x854>)
  40a2c4:	611c      	str	r4, [r3, #16]
  40a2c6:	e075      	b.n	40a3b4 <TaskMain+0x8ac>
				}
			//}
		break;
		case 5:
			vHighWaterMark = uxTaskGetStackHighWaterMark(dataHandlerTaskHandle);
  40a2c8:	4b2d      	ldr	r3, [pc, #180]	; (40a380 <TaskMain+0x878>)
  40a2ca:	681b      	ldr	r3, [r3, #0]
  40a2cc:	4618      	mov	r0, r3
  40a2ce:	4b22      	ldr	r3, [pc, #136]	; (40a358 <TaskMain+0x850>)
  40a2d0:	4798      	blx	r3
  40a2d2:	6338      	str	r0, [r7, #48]	; 0x30
			//if (vHighWaterMark < 100)
			//{
				if (vHighWaterMark < vTaskStackSize[5])
  40a2d4:	4b21      	ldr	r3, [pc, #132]	; (40a35c <TaskMain+0x854>)
  40a2d6:	695b      	ldr	r3, [r3, #20]
  40a2d8:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  40a2da:	429a      	cmp	r2, r3
  40a2dc:	d26a      	bcs.n	40a3b4 <TaskMain+0x8ac>
				{
					debugPrintStringInt("Data-Handler task stack new high water mark\r\n", vHighWaterMark);
  40a2de:	6b3c      	ldr	r4, [r7, #48]	; 0x30
  40a2e0:	4828      	ldr	r0, [pc, #160]	; (40a384 <TaskMain+0x87c>)
  40a2e2:	4621      	mov	r1, r4
  40a2e4:	4b1f      	ldr	r3, [pc, #124]	; (40a364 <TaskMain+0x85c>)
  40a2e6:	4798      	blx	r3
					vTaskStackSize[5] = vHighWaterMark;
  40a2e8:	4b1c      	ldr	r3, [pc, #112]	; (40a35c <TaskMain+0x854>)
  40a2ea:	615c      	str	r4, [r3, #20]
  40a2ec:	e062      	b.n	40a3b4 <TaskMain+0x8ac>
				}
			//}
		break;
		case 6:
			vHighWaterMark = uxTaskGetStackHighWaterMark(sdCardTaskHandle);
  40a2ee:	4b26      	ldr	r3, [pc, #152]	; (40a388 <TaskMain+0x880>)
  40a2f0:	681b      	ldr	r3, [r3, #0]
  40a2f2:	4618      	mov	r0, r3
  40a2f4:	4b18      	ldr	r3, [pc, #96]	; (40a358 <TaskMain+0x850>)
  40a2f6:	4798      	blx	r3
  40a2f8:	6338      	str	r0, [r7, #48]	; 0x30
			//if (vHighWaterMark < 100)
			//{
				if (vHighWaterMark < vTaskStackSize[6])
  40a2fa:	4b18      	ldr	r3, [pc, #96]	; (40a35c <TaskMain+0x854>)
  40a2fc:	699b      	ldr	r3, [r3, #24]
  40a2fe:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  40a300:	429a      	cmp	r2, r3
  40a302:	d257      	bcs.n	40a3b4 <TaskMain+0x8ac>
				{
					debugPrintStringInt("SD-card task stack new high water mark\r\n", vHighWaterMark);
  40a304:	6b3c      	ldr	r4, [r7, #48]	; 0x30
  40a306:	4821      	ldr	r0, [pc, #132]	; (40a38c <TaskMain+0x884>)
  40a308:	4621      	mov	r1, r4
  40a30a:	4b16      	ldr	r3, [pc, #88]	; (40a364 <TaskMain+0x85c>)
  40a30c:	4798      	blx	r3
					vTaskStackSize[6] = vHighWaterMark;
  40a30e:	4b13      	ldr	r3, [pc, #76]	; (40a35c <TaskMain+0x854>)
  40a310:	619c      	str	r4, [r3, #24]
  40a312:	e04f      	b.n	40a3b4 <TaskMain+0x8ac>
  40a314:	00401a99 	.word	0x00401a99
  40a318:	00416a78 	.word	0x00416a78
  40a31c:	004008c9 	.word	0x004008c9
  40a320:	200038a0 	.word	0x200038a0
  40a324:	200038a2 	.word	0x200038a2
  40a328:	004088cd 	.word	0x004088cd
  40a32c:	00416a90 	.word	0x00416a90
  40a330:	00416aa8 	.word	0x00416aa8
  40a334:	00416ac0 	.word	0x00416ac0
  40a338:	00416ad4 	.word	0x00416ad4
  40a33c:	00416ae8 	.word	0x00416ae8
  40a340:	00408829 	.word	0x00408829
  40a344:	00416af8 	.word	0x00416af8
  40a348:	00408871 	.word	0x00408871
  40a34c:	00416b0c 	.word	0x00416b0c
  40a350:	00401c29 	.word	0x00401c29
  40a354:	20000264 	.word	0x20000264
  40a358:	00407711 	.word	0x00407711
  40a35c:	200006dc 	.word	0x200006dc
  40a360:	00416b20 	.word	0x00416b20
  40a364:	004007b5 	.word	0x004007b5
  40a368:	00416b4c 	.word	0x00416b4c
  40a36c:	00416b78 	.word	0x00416b78
  40a370:	20003898 	.word	0x20003898
  40a374:	00416ba4 	.word	0x00416ba4
  40a378:	20003894 	.word	0x20003894
  40a37c:	00416bd4 	.word	0x00416bd4
  40a380:	20003890 	.word	0x20003890
  40a384:	00416c08 	.word	0x00416c08
  40a388:	2000388c 	.word	0x2000388c
  40a38c:	00416c38 	.word	0x00416c38
				}
			//}
		break;
		case 7:
			vHighWaterMark = uxTaskGetStackHighWaterMark(stateMachineTaskHandle);
  40a390:	4b3a      	ldr	r3, [pc, #232]	; (40a47c <TaskMain+0x974>)
  40a392:	681b      	ldr	r3, [r3, #0]
  40a394:	4618      	mov	r0, r3
  40a396:	4b3a      	ldr	r3, [pc, #232]	; (40a480 <TaskMain+0x978>)
  40a398:	4798      	blx	r3
  40a39a:	6338      	str	r0, [r7, #48]	; 0x30
			//if (vHighWaterMark < 100)
			//{
				if (vHighWaterMark < vTaskStackSize[7])
  40a39c:	4b39      	ldr	r3, [pc, #228]	; (40a484 <TaskMain+0x97c>)
  40a39e:	69db      	ldr	r3, [r3, #28]
  40a3a0:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  40a3a2:	429a      	cmp	r2, r3
  40a3a4:	d206      	bcs.n	40a3b4 <TaskMain+0x8ac>
				{
					debugPrintStringInt("State-Machine task stack new high water mark\r\n", vHighWaterMark);
  40a3a6:	6b3c      	ldr	r4, [r7, #48]	; 0x30
  40a3a8:	4837      	ldr	r0, [pc, #220]	; (40a488 <TaskMain+0x980>)
  40a3aa:	4621      	mov	r1, r4
  40a3ac:	4b37      	ldr	r3, [pc, #220]	; (40a48c <TaskMain+0x984>)
  40a3ae:	4798      	blx	r3
					vTaskStackSize[7] = vHighWaterMark;
  40a3b0:	4b34      	ldr	r3, [pc, #208]	; (40a484 <TaskMain+0x97c>)
  40a3b2:	61dc      	str	r4, [r3, #28]
		wdt_restart(WDT);
		checkInputGpio();
		if (getCurrentState() != (SYS_STATE_OFF))
		{
			checkRtosStack(vLoopCount);
			(vLoopCount)++;
  40a3b4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  40a3b6:	3301      	adds	r3, #1
  40a3b8:	647b      	str	r3, [r7, #68]	; 0x44
			 if (vLoopCount > 7)
  40a3ba:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  40a3bc:	2b07      	cmp	r3, #7
  40a3be:	dd01      	ble.n	40a3c4 <TaskMain+0x8bc>
			 {
				 vLoopCount = 0;
  40a3c0:	2300      	movs	r3, #0
  40a3c2:	647b      	str	r3, [r7, #68]	; 0x44
			 }
		}
		if (vCycleJcEnCount == 10)
  40a3c4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  40a3c6:	2b0a      	cmp	r3, #10
  40a3c8:	d151      	bne.n	40a46e <TaskMain+0x966>
 * @param void
 * @return void
 ***********************************************************************************************/
static void checkJackDetects(void)
{
	drv_gpio_pin_state_t jcDc1 = DRV_GPIO_PIN_STATE_LOW, jcDc2 = DRV_GPIO_PIN_STATE_LOW;
  40a3ca:	2300      	movs	r3, #0
  40a3cc:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
  40a3d0:	2300      	movs	r3, #0
  40a3d2:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
	//Check for Jack Detects
	drv_gpio_getPinState(DRV_GPIO_PIN_JC_DC1, &jcDc1);
  40a3d6:	f107 032f 	add.w	r3, r7, #47	; 0x2f
  40a3da:	2005      	movs	r0, #5
  40a3dc:	4619      	mov	r1, r3
  40a3de:	4b2c      	ldr	r3, [pc, #176]	; (40a490 <TaskMain+0x988>)
  40a3e0:	4798      	blx	r3
	drv_gpio_getPinState(DRV_GPIO_PIN_JC_DC2, &jcDc2);
  40a3e2:	f107 032e 	add.w	r3, r7, #46	; 0x2e
  40a3e6:	2006      	movs	r0, #6
  40a3e8:	4619      	mov	r1, r3
  40a3ea:	4b29      	ldr	r3, [pc, #164]	; (40a490 <TaskMain+0x988>)
  40a3ec:	4798      	blx	r3
	//if there are no jacks in the socket move back to cycling state
	if (jcDc2 == DRV_GPIO_PIN_STATE_LOW && jcDc1 == DRV_GPIO_PIN_STATE_LOW)
  40a3ee:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
  40a3f2:	2b00      	cmp	r3, #0
  40a3f4:	d107      	bne.n	40a406 <TaskMain+0x8fe>
  40a3f6:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  40a3fa:	2b00      	cmp	r3, #0
  40a3fc:	d103      	bne.n	40a406 <TaskMain+0x8fe>
	{
		//either one of the jacks is not present.
		cycleJcEn = TRUE;
  40a3fe:	4b25      	ldr	r3, [pc, #148]	; (40a494 <TaskMain+0x98c>)
  40a400:	2201      	movs	r2, #1
  40a402:	701a      	strb	r2, [r3, #0]
  40a404:	e002      	b.n	40a40c <TaskMain+0x904>
		drv_led_set(DRV_LED_TURQUOISE, DRV_LED_FLASH);
		#endif
	} 
	else
	{
		cycleJcEn = FALSE;
  40a406:	4b23      	ldr	r3, [pc, #140]	; (40a494 <TaskMain+0x98c>)
  40a408:	2200      	movs	r2, #0
  40a40a:	701a      	strb	r2, [r3, #0]
	}
	
	if (cycleJcEn == TRUE)
  40a40c:	4b21      	ldr	r3, [pc, #132]	; (40a494 <TaskMain+0x98c>)
  40a40e:	781b      	ldrb	r3, [r3, #0]
  40a410:	2b00      	cmp	r3, #0
  40a412:	d02a      	beq.n	40a46a <TaskMain+0x962>
	{
		//Drive the Jack enables low as they are active low.
		drv_gpio_setPinState(DRV_GPIO_PIN_JC_EN1, DRV_GPIO_PIN_STATE_LOW);
  40a414:	2007      	movs	r0, #7
  40a416:	2100      	movs	r1, #0
  40a418:	4b1f      	ldr	r3, [pc, #124]	; (40a498 <TaskMain+0x990>)
  40a41a:	4798      	blx	r3
		drv_gpio_setPinState(DRV_GPIO_PIN_JC_EN2, DRV_GPIO_PIN_STATE_LOW);
  40a41c:	2008      	movs	r0, #8
  40a41e:	2100      	movs	r1, #0
  40a420:	4b1d      	ldr	r3, [pc, #116]	; (40a498 <TaskMain+0x990>)
  40a422:	4798      	blx	r3
		vTaskDelay(10);
  40a424:	200a      	movs	r0, #10
  40a426:	4b1d      	ldr	r3, [pc, #116]	; (40a49c <TaskMain+0x994>)
  40a428:	4798      	blx	r3
	
		//Check for Jack Detects
		drv_gpio_getPinState(DRV_GPIO_PIN_JC_DC1, &jcDc1);
  40a42a:	f107 032f 	add.w	r3, r7, #47	; 0x2f
  40a42e:	2005      	movs	r0, #5
  40a430:	4619      	mov	r1, r3
  40a432:	4b17      	ldr	r3, [pc, #92]	; (40a490 <TaskMain+0x988>)
  40a434:	4798      	blx	r3
		drv_gpio_getPinState(DRV_GPIO_PIN_JC_DC2, &jcDc2);
  40a436:	f107 032e 	add.w	r3, r7, #46	; 0x2e
  40a43a:	2006      	movs	r0, #6
  40a43c:	4619      	mov	r1, r3
  40a43e:	4b14      	ldr	r3, [pc, #80]	; (40a490 <TaskMain+0x988>)
  40a440:	4798      	blx	r3
	
		if (jcDc2 == DRV_GPIO_PIN_STATE_HIGH || jcDc1 == DRV_GPIO_PIN_STATE_HIGH)
  40a442:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
  40a446:	2b01      	cmp	r3, #1
  40a448:	d003      	beq.n	40a452 <TaskMain+0x94a>
  40a44a:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  40a44e:	2b01      	cmp	r3, #1
  40a450:	d103      	bne.n	40a45a <TaskMain+0x952>
		{
			//either one of the jacks detected, stop cycling of jack enables
			cycleJcEn = FALSE;
  40a452:	4b10      	ldr	r3, [pc, #64]	; (40a494 <TaskMain+0x98c>)
  40a454:	2200      	movs	r2, #0
  40a456:	701a      	strb	r2, [r3, #0]
  40a458:	e007      	b.n	40a46a <TaskMain+0x962>
			#endif
		}
	
		else
		{
			drv_gpio_setPinState(DRV_GPIO_PIN_JC_EN1, DRV_GPIO_PIN_STATE_HIGH);
  40a45a:	2007      	movs	r0, #7
  40a45c:	2101      	movs	r1, #1
  40a45e:	4b0e      	ldr	r3, [pc, #56]	; (40a498 <TaskMain+0x990>)
  40a460:	4798      	blx	r3
			drv_gpio_setPinState(DRV_GPIO_PIN_JC_EN2, DRV_GPIO_PIN_STATE_HIGH);
  40a462:	2008      	movs	r0, #8
  40a464:	2101      	movs	r1, #1
  40a466:	4b0c      	ldr	r3, [pc, #48]	; (40a498 <TaskMain+0x990>)
  40a468:	4798      	blx	r3
		}
		if (vCycleJcEnCount == 10)
		{
			//Check for Jack Detects every 1000ms
			checkJackDetects();
			vCycleJcEnCount = 0;
  40a46a:	2300      	movs	r3, #0
  40a46c:	643b      	str	r3, [r7, #64]	; 0x40
		}
		vCycleJcEnCount++;		
  40a46e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  40a470:	3301      	adds	r3, #1
  40a472:	643b      	str	r3, [r7, #64]	; 0x40
		vTaskDelay(100);
  40a474:	2064      	movs	r0, #100	; 0x64
  40a476:	4b09      	ldr	r3, [pc, #36]	; (40a49c <TaskMain+0x994>)
  40a478:	4798      	blx	r3
	}
  40a47a:	e454      	b.n	409d26 <TaskMain+0x21e>
  40a47c:	20003888 	.word	0x20003888
  40a480:	00407711 	.word	0x00407711
  40a484:	200006dc 	.word	0x200006dc
  40a488:	00416c64 	.word	0x00416c64
  40a48c:	004007b5 	.word	0x004007b5
  40a490:	00408829 	.word	0x00408829
  40a494:	200006fc 	.word	0x200006fc
  40a498:	004087b1 	.word	0x004087b1
  40a49c:	004072ed 	.word	0x004072ed

0040a4a0 <toggleJackEnables>:
 * @param drv_gpio_pin_state_t pinState
 * @return void
 ***********************************************************************************************/
void toggleJackEnables(drv_gpio_pin_state_t pinState)
{
	if (pinState == DRV_GPIO_PIN_STATE_HIGH)
  40a4a0:	2801      	cmp	r0, #1
 * @brief Toggles the Jack enables to High or Low
 * @param drv_gpio_pin_state_t pinState
 * @return void
 ***********************************************************************************************/
void toggleJackEnables(drv_gpio_pin_state_t pinState)
{
  40a4a2:	b538      	push	{r3, r4, r5, lr}
  40a4a4:	4604      	mov	r4, r0
	if (pinState == DRV_GPIO_PIN_STATE_HIGH)
  40a4a6:	d004      	beq.n	40a4b2 <toggleJackEnables+0x12>
		drv_gpio_setPinState(DRV_GPIO_PIN_JC_EN2, DRV_GPIO_PIN_STATE_HIGH);
		#ifdef TEST_JACK_DETECTS
		drv_led_set(DRV_LED_OFF, DRV_LED_SOLID);
		#endif
	}
	else if (pinState == DRV_GPIO_PIN_STATE_LOW)
  40a4a8:	b910      	cbnz	r0, 40a4b0 <toggleJackEnables+0x10>
	{
		//start polling the jack detects by cycling jack enables
		cycleJcEn = TRUE;
  40a4aa:	4b07      	ldr	r3, [pc, #28]	; (40a4c8 <toggleJackEnables+0x28>)
  40a4ac:	2201      	movs	r2, #1
  40a4ae:	701a      	strb	r2, [r3, #0]
  40a4b0:	bd38      	pop	{r3, r4, r5, pc}
void toggleJackEnables(drv_gpio_pin_state_t pinState)
{
	if (pinState == DRV_GPIO_PIN_STATE_HIGH)
	{
		//Disable the jack enables and stop cycling them.
		cycleJcEn = FALSE;
  40a4b2:	4b05      	ldr	r3, [pc, #20]	; (40a4c8 <toggleJackEnables+0x28>)
		drv_gpio_setPinState(DRV_GPIO_PIN_JC_EN1, DRV_GPIO_PIN_STATE_HIGH);
  40a4b4:	4d05      	ldr	r5, [pc, #20]	; (40a4cc <toggleJackEnables+0x2c>)
void toggleJackEnables(drv_gpio_pin_state_t pinState)
{
	if (pinState == DRV_GPIO_PIN_STATE_HIGH)
	{
		//Disable the jack enables and stop cycling them.
		cycleJcEn = FALSE;
  40a4b6:	2200      	movs	r2, #0
		drv_gpio_setPinState(DRV_GPIO_PIN_JC_EN1, DRV_GPIO_PIN_STATE_HIGH);
  40a4b8:	4621      	mov	r1, r4
  40a4ba:	2007      	movs	r0, #7
void toggleJackEnables(drv_gpio_pin_state_t pinState)
{
	if (pinState == DRV_GPIO_PIN_STATE_HIGH)
	{
		//Disable the jack enables and stop cycling them.
		cycleJcEn = FALSE;
  40a4bc:	701a      	strb	r2, [r3, #0]
		drv_gpio_setPinState(DRV_GPIO_PIN_JC_EN1, DRV_GPIO_PIN_STATE_HIGH);
  40a4be:	47a8      	blx	r5
		drv_gpio_setPinState(DRV_GPIO_PIN_JC_EN2, DRV_GPIO_PIN_STATE_HIGH);
  40a4c0:	4621      	mov	r1, r4
  40a4c2:	2008      	movs	r0, #8
  40a4c4:	47a8      	blx	r5
  40a4c6:	bd38      	pop	{r3, r4, r5, pc}
  40a4c8:	200006fc 	.word	0x200006fc
  40a4cc:	004087b1 	.word	0x004087b1

0040a4d0 <sendString>:
 * @brief Send a string to requested serial port
 * @param drv_uart_config_t* uartConfig, char* cmd 
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
static status_t sendString(drv_uart_config_t* uartConfig, char* cmd)
{
  40a4d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	int len = strlen(cmd); 
  40a4d4:	4b09      	ldr	r3, [pc, #36]	; (40a4fc <sendString+0x2c>)
 * @brief Send a string to requested serial port
 * @param drv_uart_config_t* uartConfig, char* cmd 
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
static status_t sendString(drv_uart_config_t* uartConfig, char* cmd)
{
  40a4d6:	4606      	mov	r6, r0
	int len = strlen(cmd); 
  40a4d8:	4608      	mov	r0, r1
 * @brief Send a string to requested serial port
 * @param drv_uart_config_t* uartConfig, char* cmd 
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
static status_t sendString(drv_uart_config_t* uartConfig, char* cmd)
{
  40a4da:	460d      	mov	r5, r1
	int len = strlen(cmd); 
  40a4dc:	4798      	blx	r3
	int i = 0; 
	for(;i<len;)
  40a4de:	1e07      	subs	r7, r0, #0
  40a4e0:	dd09      	ble.n	40a4f6 <sendString+0x26>
  40a4e2:	f8df 801c 	ldr.w	r8, [pc, #28]	; 40a500 <sendString+0x30>
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
static status_t sendString(drv_uart_config_t* uartConfig, char* cmd)
{
	int len = strlen(cmd); 
	int i = 0; 
  40a4e6:	2400      	movs	r4, #0
	for(;i<len;)
	{
		if(drv_uart_putChar(uartConfig,cmd[i]) == STATUS_PASS) //returns pass only when char sent
  40a4e8:	4630      	mov	r0, r6
  40a4ea:	5d29      	ldrb	r1, [r5, r4]
  40a4ec:	47c0      	blx	r8
  40a4ee:	b900      	cbnz	r0, 40a4f2 <sendString+0x22>
		{
			i++;
  40a4f0:	3401      	adds	r4, #1
 ***********************************************************************************************/
static status_t sendString(drv_uart_config_t* uartConfig, char* cmd)
{
	int len = strlen(cmd); 
	int i = 0; 
	for(;i<len;)
  40a4f2:	42a7      	cmp	r7, r4
  40a4f4:	dcf8      	bgt.n	40a4e8 <sendString+0x18>
		{
			i++;
		}
	}
	return STATUS_PASS; 
}
  40a4f6:	2000      	movs	r0, #0
  40a4f8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40a4fc:	0040c9a5 	.word	0x0040c9a5
  40a500:	00408e41 	.word	0x00408e41

0040a504 <getAck>:
 * @brief Look for an acknowledge from a Quintic
 * @param drv_uart_config_t* uartConfig
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
static status_t getAck(drv_uart_config_t* uartConfig)
{
  40a504:	b510      	push	{r4, lr}
  40a506:	b0c0      	sub	sp, #256	; 0x100
  40a508:	4604      	mov	r4, r0
	status_t result = STATUS_FAIL; 
	char buf[CMD_RESPONSE_BUF_SIZE] = {0}; //should move to static buffer for each quintic?
  40a50a:	2100      	movs	r1, #0
  40a50c:	22ff      	movs	r2, #255	; 0xff
  40a50e:	4b0a      	ldr	r3, [pc, #40]	; (40a538 <getAck+0x34>)
  40a510:	4668      	mov	r0, sp
  40a512:	4798      	blx	r3
	/*result = drv_uart_getline(uartConfig, buf,CMD_RESPONSE_BUF_SIZE);*/
	result = drv_uart_getlineTimed(uartConfig, buf, CMD_RESPONSE_BUF_SIZE, 1000);
  40a514:	4620      	mov	r0, r4
  40a516:	4669      	mov	r1, sp
  40a518:	22ff      	movs	r2, #255	; 0xff
  40a51a:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
  40a51e:	4c07      	ldr	r4, [pc, #28]	; (40a53c <getAck+0x38>)
  40a520:	47a0      	blx	r4
	if(result == STATUS_PASS)
  40a522:	b930      	cbnz	r0, 40a532 <getAck+0x2e>
	{
		if(strcmp(buf,QCMD_QN_ACK) != 0)
  40a524:	4668      	mov	r0, sp
  40a526:	4906      	ldr	r1, [pc, #24]	; (40a540 <getAck+0x3c>)
  40a528:	4b06      	ldr	r3, [pc, #24]	; (40a544 <getAck+0x40>)
  40a52a:	4798      	blx	r3
  40a52c:	3000      	adds	r0, #0
  40a52e:	bf18      	it	ne
  40a530:	2001      	movne	r0, #1
		{
			result = STATUS_FAIL;
		}
	}
	return result; 
}
  40a532:	b040      	add	sp, #256	; 0x100
  40a534:	bd10      	pop	{r4, pc}
  40a536:	bf00      	nop
  40a538:	0040c31d 	.word	0x0040c31d
  40a53c:	00408fb9 	.word	0x00408fb9
  40a540:	00416ca8 	.word	0x00416ca8
  40a544:	0040c6cd 	.word	0x0040c6cd

0040a548 <getResponse.constprop.0>:
 * getResponse(drv_uart_config_t* uartConfig, char* expectedResponse)
 * @brief Look for a response from a Quintic
 * @param drv_uart_config_t* uartConfig, char* expectedResponse
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
static status_t getResponse(drv_uart_config_t* uartConfig, char* expectedResponse)
  40a548:	b510      	push	{r4, lr}
  40a54a:	b0c0      	sub	sp, #256	; 0x100
  40a54c:	4604      	mov	r4, r0
{
	status_t result = STATUS_FAIL;
	char buf[CMD_RESPONSE_BUF_SIZE] = {0}; //should move to static buffer for each quintic?
  40a54e:	2100      	movs	r1, #0
  40a550:	22ff      	movs	r2, #255	; 0xff
  40a552:	4b0b      	ldr	r3, [pc, #44]	; (40a580 <getResponse.constprop.0+0x38>)
  40a554:	4668      	mov	r0, sp
  40a556:	4798      	blx	r3
	if(drv_uart_getlineTimed(uartConfig, buf,CMD_RESPONSE_BUF_SIZE, 2000) == STATUS_PASS)
  40a558:	4620      	mov	r0, r4
  40a55a:	4669      	mov	r1, sp
  40a55c:	22ff      	movs	r2, #255	; 0xff
  40a55e:	f44f 63fa 	mov.w	r3, #2000	; 0x7d0
  40a562:	4c08      	ldr	r4, [pc, #32]	; (40a584 <getResponse.constprop.0+0x3c>)
  40a564:	47a0      	blx	r4
  40a566:	b940      	cbnz	r0, 40a57a <getResponse.constprop.0+0x32>
	{
		if(strcmp(buf,expectedResponse) == 0)
  40a568:	4668      	mov	r0, sp
  40a56a:	4907      	ldr	r1, [pc, #28]	; (40a588 <getResponse.constprop.0+0x40>)
  40a56c:	4b07      	ldr	r3, [pc, #28]	; (40a58c <getResponse.constprop.0+0x44>)
  40a56e:	4798      	blx	r3
 * @param drv_uart_config_t* uartConfig, char* expectedResponse
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
static status_t getResponse(drv_uart_config_t* uartConfig, char* expectedResponse)
{
	status_t result = STATUS_FAIL;
  40a570:	3000      	adds	r0, #0
  40a572:	bf18      	it	ne
  40a574:	2001      	movne	r0, #1
		{
			result = STATUS_PASS;
		}
	}
	return result;     
}
  40a576:	b040      	add	sp, #256	; 0x100
  40a578:	bd10      	pop	{r4, pc}
 * @param drv_uart_config_t* uartConfig, char* expectedResponse
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
static status_t getResponse(drv_uart_config_t* uartConfig, char* expectedResponse)
{
	status_t result = STATUS_FAIL;
  40a57a:	2001      	movs	r0, #1
		{
			result = STATUS_PASS;
		}
	}
	return result;     
}
  40a57c:	b040      	add	sp, #256	; 0x100
  40a57e:	bd10      	pop	{r4, pc}
  40a580:	0040c31d 	.word	0x0040c31d
  40a584:	00408fb9 	.word	0x00408fb9
  40a588:	00416cb0 	.word	0x00416cb0
  40a58c:	0040c6cd 	.word	0x0040c6cd

0040a590 <task_quinticHandler>:
 *	function. 
 * @param pvParameters, void pointer to structure containing quintic and imu configuration. 
 * @return void
 ***********************************************************************************************/
void task_quinticHandler(void *pvParameters)
{
  40a590:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40a594:	4983      	ldr	r1, [pc, #524]	; (40a7a4 <task_quinticHandler+0x214>)
  40a596:	2300      	movs	r3, #0
  40a598:	680d      	ldr	r5, [r1, #0]
  40a59a:	b0cb      	sub	sp, #300	; 0x12c
  40a59c:	4604      	mov	r4, r0
	for(i = 0 ; i < QUINTIC_MAX_NUMBER_OF_IMUS ; i++)
	{
		//qConfig->imuArray[i]->bufferEnd = 0;
		//qConfig->imuArray[i]->bufferHead = 0;
		//memset(qConfig->imuArray[i]->packetBuffer, 0 , IMU_BUFFER_SIZE*IMU_PACKET_LENGTH); 	
		qConfig->imuArray[i]->stats.avgPacketTime = 0;
  40a59e:	461a      	mov	r2, r3
  40a5a0:	58e1      	ldr	r1, [r4, r3]
  40a5a2:	634a      	str	r2, [r1, #52]	; 0x34
		qConfig->imuArray[i]->stats.droppedPackets = 0;
  40a5a4:	58e1      	ldr	r1, [r4, r3]
  40a5a6:	628a      	str	r2, [r1, #40]	; 0x28
		qConfig->imuArray[i]->stats.lastPacketTime = sgSysTickCount;
  40a5a8:	58e1      	ldr	r1, [r4, r3]
  40a5aa:	62cd      	str	r5, [r1, #44]	; 0x2c
		qConfig->imuArray[i]->stats.maxPacketTime = 0;
  40a5ac:	58e1      	ldr	r1, [r4, r3]
  40a5ae:	630a      	str	r2, [r1, #48]	; 0x30
		qConfig->imuArray[i]->stats.packetCnt = 0;
  40a5b0:	58e1      	ldr	r1, [r4, r3]
  40a5b2:	3304      	adds	r3, #4
	//cast void pointer to quintic config type. 
	quinticConfiguration_t *qConfig = (quinticConfiguration_t*)pvParameters; 
	//initialize all structures ,check everything is alright
	int i = 0;
	//initialize all buffers and pointers to zero
	for(i = 0 ; i < QUINTIC_MAX_NUMBER_OF_IMUS ; i++)
  40a5b4:	2b14      	cmp	r3, #20
		//memset(qConfig->imuArray[i]->packetBuffer, 0 , IMU_BUFFER_SIZE*IMU_PACKET_LENGTH); 	
		qConfig->imuArray[i]->stats.avgPacketTime = 0;
		qConfig->imuArray[i]->stats.droppedPackets = 0;
		qConfig->imuArray[i]->stats.lastPacketTime = sgSysTickCount;
		qConfig->imuArray[i]->stats.maxPacketTime = 0;
		qConfig->imuArray[i]->stats.packetCnt = 0;
  40a5b6:	624a      	str	r2, [r1, #36]	; 0x24
	//cast void pointer to quintic config type. 
	quinticConfiguration_t *qConfig = (quinticConfiguration_t*)pvParameters; 
	//initialize all structures ,check everything is alright
	int i = 0;
	//initialize all buffers and pointers to zero
	for(i = 0 ; i < QUINTIC_MAX_NUMBER_OF_IMUS ; i++)
  40a5b8:	d1f2      	bne.n	40a5a0 <task_quinticHandler+0x10>
		qConfig->imuArray[i]->stats.lastPacketTime = sgSysTickCount;
		qConfig->imuArray[i]->stats.maxPacketTime = 0;
		qConfig->imuArray[i]->stats.packetCnt = 0;
	}
	
	if(drv_uart_isInit(qConfig->uartDevice) != STATUS_PASS)
  40a5ba:	4b7b      	ldr	r3, [pc, #492]	; (40a7a8 <task_quinticHandler+0x218>)
  40a5bc:	6960      	ldr	r0, [r4, #20]
  40a5be:	4798      	blx	r3
  40a5c0:	4603      	mov	r3, r0
  40a5c2:	2800      	cmp	r0, #0
  40a5c4:	f040 80eb 	bne.w	40a79e <task_quinticHandler+0x20e>
	#else
	#endif 
	dataPacket_t packet; 
	packet.type = DATA_PACKET_TYPE_IMU; 
	//main loop of task, this is where we request information and store it. 
	char buf[CMD_RESPONSE_BUF_SIZE] = {0}; 
  40a5c8:	4601      	mov	r1, r0
  40a5ca:	22ff      	movs	r2, #255	; 0xff
  40a5cc:	a80a      	add	r0, sp, #40	; 0x28
  40a5ce:	f8df c218 	ldr.w	ip, [pc, #536]	; 40a7e8 <task_quinticHandler+0x258>
	#ifdef DEBUG_DUMMY_DATA

	#else
	#endif 
	dataPacket_t packet; 
	packet.type = DATA_PACKET_TYPE_IMU; 
  40a5d2:	f88d 3004 	strb.w	r3, [sp, #4]
	//main loop of task, this is where we request information and store it. 
	char buf[CMD_RESPONSE_BUF_SIZE] = {0}; 
  40a5d6:	47e0      	blx	ip
	int packetNumber = 0;
	uint32_t timeNow = 0;
	int index = -1; 
	qConfig->isinit = true;
  40a5d8:	2301      	movs	r3, #1
  40a5da:	4d74      	ldr	r5, [pc, #464]	; (40a7ac <task_quinticHandler+0x21c>)
  40a5dc:	4f74      	ldr	r7, [pc, #464]	; (40a7b0 <task_quinticHandler+0x220>)
  40a5de:	f8df 920c 	ldr.w	r9, [pc, #524]	; 40a7ec <task_quinticHandler+0x25c>
  40a5e2:	f8df b20c 	ldr.w	fp, [pc, #524]	; 40a7f0 <task_quinticHandler+0x260>
  40a5e6:	4e73      	ldr	r6, [pc, #460]	; (40a7b4 <task_quinticHandler+0x224>)
  40a5e8:	6263      	str	r3, [r4, #36]	; 0x24
  40a5ea:	f10d 0a34 	add.w	sl, sp, #52	; 0x34
  40a5ee:	e024      	b.n	40a63a <task_quinticHandler+0xaa>
				if(buf[0] == '&') //euler data
				{
					index = getIndex(buf[1]); 
					packet.type = DATA_PACKET_TYPE_IMU; 
				}
				else if(buf[0] == '@') //acceleration data
  40a5f0:	2b40      	cmp	r3, #64	; 0x40
  40a5f2:	f000 8089 	beq.w	40a708 <task_quinticHandler+0x178>
				{
					index = getIndex(buf[1]);
					packet.type = DATA_PACKET_TYPE_ACCEL;  					
				}
				else if (strncmp(buf, "DiscResp", 8) == 0)
  40a5f6:	a80a      	add	r0, sp, #40	; 0x28
  40a5f8:	496f      	ldr	r1, [pc, #444]	; (40a7b8 <task_quinticHandler+0x228>)
  40a5fa:	f8df 81f0 	ldr.w	r8, [pc, #496]	; 40a7ec <task_quinticHandler+0x25c>
  40a5fe:	2208      	movs	r2, #8
  40a600:	47c8      	blx	r9
  40a602:	2800      	cmp	r0, #0
  40a604:	f000 8093 	beq.w	40a72e <task_quinticHandler+0x19e>
					}
					//task_stateMachine_EnqueueEvent(SYS_EVENT_IMU_DISCONNECT, qConfig->qId);
					//send the connect string twice, try to get it to reconnect to the missing NOD. 
					sendString(qConfig->uartDevice, "connect\r\n");
				}
				else if (strncmp(buf, "ConnResp", 8) == 0)
  40a608:	a80a      	add	r0, sp, #40	; 0x28
  40a60a:	496c      	ldr	r1, [pc, #432]	; (40a7bc <task_quinticHandler+0x22c>)
  40a60c:	2208      	movs	r2, #8
  40a60e:	47c0      	blx	r8
  40a610:	2800      	cmp	r0, #0
  40a612:	f000 8088 	beq.w	40a726 <task_quinticHandler+0x196>
				{
					debugPrintStringInt(buf,qConfig->qId);
				}
				else if(strncmp(buf, "AppStart\r\n",10) == 0)
  40a616:	a80a      	add	r0, sp, #40	; 0x28
  40a618:	4969      	ldr	r1, [pc, #420]	; (40a7c0 <task_quinticHandler+0x230>)
  40a61a:	220a      	movs	r2, #10
  40a61c:	47c0      	blx	r8
  40a61e:	2800      	cmp	r0, #0
  40a620:	f000 80ab 	beq.w	40a77a <task_quinticHandler+0x1ea>
					{				
						debugPrintStringInt("Quintic Crashed!",qConfig->qId); 
						task_stateMachine_EnqueueEvent(SYS_EVENT_IMU_DISCONNECT, qConfig->qId);	
					}
				}
				else if ((strncmp(buf, "RSSI", 4) == 0))
  40a624:	a80a      	add	r0, sp, #40	; 0x28
  40a626:	4967      	ldr	r1, [pc, #412]	; (40a7c4 <task_quinticHandler+0x234>)
  40a628:	2204      	movs	r2, #4
  40a62a:	47c0      	blx	r8
  40a62c:	2800      	cmp	r0, #0
  40a62e:	d07a      	beq.n	40a726 <task_quinticHandler+0x196>
					debugPrintStringInt(buf,qConfig->qId);
				}
				else
				{				
					//this is a corrupt packet, increment the count. 
					qConfig->corruptPacketCnt++;
  40a630:	69e3      	ldr	r3, [r4, #28]
  40a632:	3301      	adds	r3, #1
  40a634:	61e3      	str	r3, [r4, #28]
					}				
				}
			}
		}
		//taskYIELD();
		vTaskDelay(1);
  40a636:	2001      	movs	r0, #1
  40a638:	47b0      	blx	r6
	qConfig->isinit = true;
	char debugString[50]; 
	while(1)
	{
		#ifndef DEBUG_DUMMY_DATA
		if(getCurrentState() != SYS_STATE_RESET)
  40a63a:	47a8      	blx	r5
  40a63c:	2802      	cmp	r0, #2
  40a63e:	d0fa      	beq.n	40a636 <task_quinticHandler+0xa6>
		{		
			if(drv_uart_getlineTimed(qConfig->uartDevice, buf, CMD_RESPONSE_BUF_SIZE, 400) == STATUS_PASS)
  40a640:	6960      	ldr	r0, [r4, #20]
  40a642:	a90a      	add	r1, sp, #40	; 0x28
  40a644:	22ff      	movs	r2, #255	; 0xff
  40a646:	f44f 73c8 	mov.w	r3, #400	; 0x190
  40a64a:	47b8      	blx	r7
  40a64c:	2800      	cmp	r0, #0
  40a64e:	d1f2      	bne.n	40a636 <task_quinticHandler+0xa6>
			{
				index = -1; 
				if(buf[0] == '&') //euler data
  40a650:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
  40a654:	2b26      	cmp	r3, #38	; 0x26
  40a656:	d1cb      	bne.n	40a5f0 <task_quinticHandler+0x60>
  40a658:	f89d 3029 	ldrb.w	r3, [sp, #41]	; 0x29
  40a65c:	3b30      	subs	r3, #48	; 0x30
  40a65e:	b2db      	uxtb	r3, r3
  40a660:	2b04      	cmp	r3, #4
  40a662:	f200 8082 	bhi.w	40a76a <task_quinticHandler+0x1da>
  40a666:	4a58      	ldr	r2, [pc, #352]	; (40a7c8 <task_quinticHandler+0x238>)
  40a668:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  40a66c:	461a      	mov	r2, r3
				{
					index = getIndex(buf[1]); 
					packet.type = DATA_PACKET_TYPE_IMU; 
  40a66e:	2100      	movs	r1, #0
  40a670:	f88d 1004 	strb.w	r1, [sp, #4]
					//this is a corrupt packet, increment the count. 
					qConfig->corruptPacketCnt++;
					//vTaskDelay(10);
				}
				//validate the index
				if((index >= 0 && index <= 4) && (index <= qConfig->expectedNumberOfNods))
  40a674:	2a04      	cmp	r2, #4
  40a676:	d8de      	bhi.n	40a636 <task_quinticHandler+0xa6>
  40a678:	69a2      	ldr	r2, [r4, #24]
  40a67a:	4293      	cmp	r3, r2
  40a67c:	dcdb      	bgt.n	40a636 <task_quinticHandler+0xa6>
				{
					packet.imuId = qConfig->imuArray[index]->imuId; 
  40a67e:	f854 2023 	ldr.w	r2, [r4, r3, lsl #2]
					packet.imuIndex = packet.imuId; 
					qConfig->imuArray[index]->stats.packetCnt++; //increment the packets received count
					//disable the average packet time by default. 
					if(brainSettings.debugPackets == true)
  40a682:	f8df c170 	ldr.w	ip, [pc, #368]	; 40a7f4 <task_quinticHandler+0x264>
				//validate the index
				if((index >= 0 && index <= 4) && (index <= qConfig->expectedNumberOfNods))
				{
					packet.imuId = qConfig->imuArray[index]->imuId; 
					packet.imuIndex = packet.imuId; 
					qConfig->imuArray[index]->stats.packetCnt++; //increment the packets received count
  40a686:	6a50      	ldr	r0, [r2, #36]	; 0x24
					//vTaskDelay(10);
				}
				//validate the index
				if((index >= 0 && index <= 4) && (index <= qConfig->expectedNumberOfNods))
				{
					packet.imuId = qConfig->imuArray[index]->imuId; 
  40a688:	7811      	ldrb	r1, [r2, #0]
  40a68a:	f88d 1005 	strb.w	r1, [sp, #5]
					packet.imuIndex = packet.imuId; 
					qConfig->imuArray[index]->stats.packetCnt++; //increment the packets received count
  40a68e:	3001      	adds	r0, #1
  40a690:	6250      	str	r0, [r2, #36]	; 0x24
					//disable the average packet time by default. 
					if(brainSettings.debugPackets == true)
  40a692:	f89c 209d 	ldrb.w	r2, [ip, #157]	; 0x9d
				}
				//validate the index
				if((index >= 0 && index <= 4) && (index <= qConfig->expectedNumberOfNods))
				{
					packet.imuId = qConfig->imuArray[index]->imuId; 
					packet.imuIndex = packet.imuId; 
  40a696:	f88d 1006 	strb.w	r1, [sp, #6]
  40a69a:	ea4f 0883 	mov.w	r8, r3, lsl #2
					qConfig->imuArray[index]->stats.packetCnt++; //increment the packets received count
					//disable the average packet time by default. 
					if(brainSettings.debugPackets == true)
  40a69e:	b172      	cbz	r2, 40a6be <task_quinticHandler+0x12e>
					{						
						timeNow = sgSysTickCount; 
						//calculate the new running average packet time --> (average + (last packet received time - current Time)/2)
						qConfig->imuArray[index]->stats.avgPacketTime = (qConfig->imuArray[index]->stats.avgPacketTime + ( timeNow - qConfig->imuArray[index]->stats.lastPacketTime ))>>1;
  40a6a0:	f854 2023 	ldr.w	r2, [r4, r3, lsl #2]
					packet.imuIndex = packet.imuId; 
					qConfig->imuArray[index]->stats.packetCnt++; //increment the packets received count
					//disable the average packet time by default. 
					if(brainSettings.debugPackets == true)
					{						
						timeNow = sgSysTickCount; 
  40a6a4:	483f      	ldr	r0, [pc, #252]	; (40a7a4 <task_quinticHandler+0x214>)
						//calculate the new running average packet time --> (average + (last packet received time - current Time)/2)
						qConfig->imuArray[index]->stats.avgPacketTime = (qConfig->imuArray[index]->stats.avgPacketTime + ( timeNow - qConfig->imuArray[index]->stats.lastPacketTime ))>>1;
  40a6a6:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
					packet.imuIndex = packet.imuId; 
					qConfig->imuArray[index]->stats.packetCnt++; //increment the packets received count
					//disable the average packet time by default. 
					if(brainSettings.debugPackets == true)
					{						
						timeNow = sgSysTickCount; 
  40a6a8:	f8d0 e000 	ldr.w	lr, [r0]
						//calculate the new running average packet time --> (average + (last packet received time - current Time)/2)
						qConfig->imuArray[index]->stats.avgPacketTime = (qConfig->imuArray[index]->stats.avgPacketTime + ( timeNow - qConfig->imuArray[index]->stats.lastPacketTime ))>>1;
  40a6ac:	6b50      	ldr	r0, [r2, #52]	; 0x34
  40a6ae:	4470      	add	r0, lr
  40a6b0:	1a41      	subs	r1, r0, r1
  40a6b2:	0849      	lsrs	r1, r1, #1
  40a6b4:	6351      	str	r1, [r2, #52]	; 0x34
						qConfig->imuArray[index]->stats.lastPacketTime = timeNow; 				
  40a6b6:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
  40a6ba:	f8c3 e02c 	str.w	lr, [r3, #44]	; 0x2c
					}
					memcpy(packet.data,buf+2, 12+1);				
  40a6be:	f8dd 302a 	ldr.w	r3, [sp, #42]	; 0x2a
					if(queue_dataHandler != NULL)
  40a6c2:	4942      	ldr	r1, [pc, #264]	; (40a7cc <task_quinticHandler+0x23c>)
						timeNow = sgSysTickCount; 
						//calculate the new running average packet time --> (average + (last packet received time - current Time)/2)
						qConfig->imuArray[index]->stats.avgPacketTime = (qConfig->imuArray[index]->stats.avgPacketTime + ( timeNow - qConfig->imuArray[index]->stats.lastPacketTime ))>>1;
						qConfig->imuArray[index]->stats.lastPacketTime = timeNow; 				
					}
					memcpy(packet.data,buf+2, 12+1);				
  40a6c4:	f8cd 3007 	str.w	r3, [sp, #7]
  40a6c8:	f8dd 302e 	ldr.w	r3, [sp, #46]	; 0x2e
  40a6cc:	f8cd 300b 	str.w	r3, [sp, #11]
					if(queue_dataHandler != NULL)
  40a6d0:	6808      	ldr	r0, [r1, #0]
						timeNow = sgSysTickCount; 
						//calculate the new running average packet time --> (average + (last packet received time - current Time)/2)
						qConfig->imuArray[index]->stats.avgPacketTime = (qConfig->imuArray[index]->stats.avgPacketTime + ( timeNow - qConfig->imuArray[index]->stats.lastPacketTime ))>>1;
						qConfig->imuArray[index]->stats.lastPacketTime = timeNow; 				
					}
					memcpy(packet.data,buf+2, 12+1);				
  40a6d2:	f8dd 3032 	ldr.w	r3, [sp, #50]	; 0x32
  40a6d6:	f8cd 300f 	str.w	r3, [sp, #15]
  40a6da:	f89d 3036 	ldrb.w	r3, [sp, #54]	; 0x36
  40a6de:	f88d 3013 	strb.w	r3, [sp, #19]
					if(queue_dataHandler != NULL)
  40a6e2:	2800      	cmp	r0, #0
  40a6e4:	d0a7      	beq.n	40a636 <task_quinticHandler+0xa6>
					{
						if(xQueueSendToBack( queue_dataHandler,( void * ) &packet,5) != TRUE)
  40a6e6:	a901      	add	r1, sp, #4
  40a6e8:	2205      	movs	r2, #5
  40a6ea:	2300      	movs	r3, #0
  40a6ec:	f8df c108 	ldr.w	ip, [pc, #264]	; 40a7f8 <task_quinticHandler+0x268>
  40a6f0:	47e0      	blx	ip
  40a6f2:	2801      	cmp	r0, #1
  40a6f4:	d09f      	beq.n	40a636 <task_quinticHandler+0xa6>
						{
							//error failed to queue the packet.
							qConfig->imuArray[index]->stats.droppedPackets++;
  40a6f6:	f854 3008 	ldr.w	r3, [r4, r8]
							debugPrintString("Queue Full Dropped packet\r\n");
  40a6fa:	4835      	ldr	r0, [pc, #212]	; (40a7d0 <task_quinticHandler+0x240>)
					if(queue_dataHandler != NULL)
					{
						if(xQueueSendToBack( queue_dataHandler,( void * ) &packet,5) != TRUE)
						{
							//error failed to queue the packet.
							qConfig->imuArray[index]->stats.droppedPackets++;
  40a6fc:	6a9a      	ldr	r2, [r3, #40]	; 0x28
							debugPrintString("Queue Full Dropped packet\r\n");
  40a6fe:	4935      	ldr	r1, [pc, #212]	; (40a7d4 <task_quinticHandler+0x244>)
					if(queue_dataHandler != NULL)
					{
						if(xQueueSendToBack( queue_dataHandler,( void * ) &packet,5) != TRUE)
						{
							//error failed to queue the packet.
							qConfig->imuArray[index]->stats.droppedPackets++;
  40a700:	3201      	adds	r2, #1
  40a702:	629a      	str	r2, [r3, #40]	; 0x28
							debugPrintString("Queue Full Dropped packet\r\n");
  40a704:	4788      	blx	r1
  40a706:	e796      	b.n	40a636 <task_quinticHandler+0xa6>
  40a708:	f89d 3029 	ldrb.w	r3, [sp, #41]	; 0x29
  40a70c:	3b30      	subs	r3, #48	; 0x30
  40a70e:	b2db      	uxtb	r3, r3
  40a710:	2b04      	cmp	r3, #4
  40a712:	d82e      	bhi.n	40a772 <task_quinticHandler+0x1e2>
  40a714:	f8df c0b0 	ldr.w	ip, [pc, #176]	; 40a7c8 <task_quinticHandler+0x238>
  40a718:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
  40a71c:	461a      	mov	r2, r3
					packet.type = DATA_PACKET_TYPE_IMU; 
				}
				else if(buf[0] == '@') //acceleration data
				{
					index = getIndex(buf[1]);
					packet.type = DATA_PACKET_TYPE_ACCEL;  					
  40a71e:	2103      	movs	r1, #3
  40a720:	f88d 1004 	strb.w	r1, [sp, #4]
  40a724:	e7a6      	b.n	40a674 <task_quinticHandler+0xe4>
					//send the connect string twice, try to get it to reconnect to the missing NOD. 
					sendString(qConfig->uartDevice, "connect\r\n");
				}
				else if (strncmp(buf, "ConnResp", 8) == 0)
				{
					debugPrintStringInt(buf,qConfig->qId);
  40a726:	a80a      	add	r0, sp, #40	; 0x28
  40a728:	6aa1      	ldr	r1, [r4, #40]	; 0x28
  40a72a:	47d8      	blx	fp
  40a72c:	e783      	b.n	40a636 <task_quinticHandler+0xa6>
					index = getIndex(buf[1]);
					packet.type = DATA_PACKET_TYPE_ACCEL;  					
				}
				else if (strncmp(buf, "DiscResp", 8) == 0)
				{
					debugPrintStringInt("Disconnection event from Quintic\r\n", qConfig->qId);
  40a72e:	482a      	ldr	r0, [pc, #168]	; (40a7d8 <task_quinticHandler+0x248>)
  40a730:	6aa1      	ldr	r1, [r4, #40]	; 0x28
  40a732:	47d8      	blx	fp
					int i = 0;
					char* bufPtr = buf;
					if(strncmp(buf,"DiscResp", 8) == 0)
  40a734:	a80a      	add	r0, sp, #40	; 0x28
  40a736:	4920      	ldr	r1, [pc, #128]	; (40a7b8 <task_quinticHandler+0x228>)
  40a738:	2208      	movs	r2, #8
  40a73a:	47c0      	blx	r8
  40a73c:	b980      	cbnz	r0, 40a760 <task_quinticHandler+0x1d0>
							{
								qConfig->imuArray[i]->imuConnected = 1;
							}
							else
							{
								qConfig->imuArray[i]->imuConnected = 0;
  40a73e:	4601      	mov	r1, r0
  40a740:	f10d 032f 	add.w	r3, sp, #47	; 0x2f
						bufPtr = buf + 8;
						for (i=0; i<5; i++)
						{
							if (bufPtr[i] == '1')
							{
								qConfig->imuArray[i]->imuConnected = 1;
  40a744:	f04f 0e01 	mov.w	lr, #1
					if(strncmp(buf,"DiscResp", 8) == 0)
					{
						bufPtr = buf + 8;
						for (i=0; i<5; i++)
						{
							if (bufPtr[i] == '1')
  40a748:	f813 2f01 	ldrb.w	r2, [r3, #1]!
  40a74c:	2a31      	cmp	r2, #49	; 0x31
							{
								qConfig->imuArray[i]->imuConnected = 1;
  40a74e:	5822      	ldr	r2, [r4, r0]
  40a750:	bf0c      	ite	eq
  40a752:	f8c2 e020 	streq.w	lr, [r2, #32]
							}
							else
							{
								qConfig->imuArray[i]->imuConnected = 0;
  40a756:	6211      	strne	r1, [r2, #32]
					int i = 0;
					char* bufPtr = buf;
					if(strncmp(buf,"DiscResp", 8) == 0)
					{
						bufPtr = buf + 8;
						for (i=0; i<5; i++)
  40a758:	4553      	cmp	r3, sl
  40a75a:	f100 0004 	add.w	r0, r0, #4
  40a75e:	d1f3      	bne.n	40a748 <task_quinticHandler+0x1b8>
							}
						}
					}
					//task_stateMachine_EnqueueEvent(SYS_EVENT_IMU_DISCONNECT, qConfig->qId);
					//send the connect string twice, try to get it to reconnect to the missing NOD. 
					sendString(qConfig->uartDevice, "connect\r\n");
  40a760:	6960      	ldr	r0, [r4, #20]
  40a762:	491e      	ldr	r1, [pc, #120]	; (40a7dc <task_quinticHandler+0x24c>)
  40a764:	4a1e      	ldr	r2, [pc, #120]	; (40a7e0 <task_quinticHandler+0x250>)
  40a766:	4790      	blx	r2
  40a768:	e765      	b.n	40a636 <task_quinticHandler+0xa6>
			if(drv_uart_getlineTimed(qConfig->uartDevice, buf, CMD_RESPONSE_BUF_SIZE, 400) == STATUS_PASS)
			{
				index = -1; 
				if(buf[0] == '&') //euler data
				{
					index = getIndex(buf[1]); 
  40a76a:	f04f 32ff 	mov.w	r2, #4294967295
  40a76e:	4613      	mov	r3, r2
  40a770:	e77d      	b.n	40a66e <task_quinticHandler+0xde>
					packet.type = DATA_PACKET_TYPE_IMU; 
				}
				else if(buf[0] == '@') //acceleration data
				{
					index = getIndex(buf[1]);
  40a772:	f04f 32ff 	mov.w	r2, #4294967295
  40a776:	4613      	mov	r3, r2
  40a778:	e7d1      	b.n	40a71e <task_quinticHandler+0x18e>
					debugPrintStringInt(buf,qConfig->qId);
				}
				else if(strncmp(buf, "AppStart\r\n",10) == 0)
				{
					//this means that the quintic has restarted, throw an error
					if(getCurrentState() == SYS_STATE_RECORDING || getCurrentState() == SYS_STATE_IDLE)
  40a77a:	4b0c      	ldr	r3, [pc, #48]	; (40a7ac <task_quinticHandler+0x21c>)
  40a77c:	4798      	blx	r3
  40a77e:	2804      	cmp	r0, #4
  40a780:	d004      	beq.n	40a78c <task_quinticHandler+0x1fc>
  40a782:	490a      	ldr	r1, [pc, #40]	; (40a7ac <task_quinticHandler+0x21c>)
  40a784:	4788      	blx	r1
  40a786:	2803      	cmp	r0, #3
  40a788:	f47f af55 	bne.w	40a636 <task_quinticHandler+0xa6>
					{				
						debugPrintStringInt("Quintic Crashed!",qConfig->qId); 
  40a78c:	6aa1      	ldr	r1, [r4, #40]	; 0x28
  40a78e:	4815      	ldr	r0, [pc, #84]	; (40a7e4 <task_quinticHandler+0x254>)
  40a790:	47d8      	blx	fp
						task_stateMachine_EnqueueEvent(SYS_EVENT_IMU_DISCONNECT, qConfig->qId);	
  40a792:	8d21      	ldrh	r1, [r4, #40]	; 0x28
  40a794:	f8df c064 	ldr.w	ip, [pc, #100]	; 40a7fc <task_quinticHandler+0x26c>
  40a798:	2006      	movs	r0, #6
  40a79a:	47e0      	blx	ip
  40a79c:	e74b      	b.n	40a636 <task_quinticHandler+0xa6>
		vTaskDelay(1);
		#else

		#endif
	}	
}
  40a79e:	b04b      	add	sp, #300	; 0x12c
  40a7a0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40a7a4:	20003970 	.word	0x20003970
  40a7a8:	00408efd 	.word	0x00408efd
  40a7ac:	00401c29 	.word	0x00401c29
  40a7b0:	00408fb9 	.word	0x00408fb9
  40a7b4:	004072ed 	.word	0x004072ed
  40a7b8:	00416cbc 	.word	0x00416cbc
  40a7bc:	00416cf8 	.word	0x00416cf8
  40a7c0:	00416cb0 	.word	0x00416cb0
  40a7c4:	00416d18 	.word	0x00416d18
  40a7c8:	00416c94 	.word	0x00416c94
  40a7cc:	20003874 	.word	0x20003874
  40a7d0:	00416d20 	.word	0x00416d20
  40a7d4:	004008c9 	.word	0x004008c9
  40a7d8:	00416cc8 	.word	0x00416cc8
  40a7dc:	00416cec 	.word	0x00416cec
  40a7e0:	0040a4d1 	.word	0x0040a4d1
  40a7e4:	00416d04 	.word	0x00416d04
  40a7e8:	0040c31d 	.word	0x0040c31d
  40a7ec:	0040ca69 	.word	0x0040ca69
  40a7f0:	004007b5 	.word	0x004007b5
  40a7f4:	200001ac 	.word	0x200001ac
  40a7f8:	00406979 	.word	0x00406979
  40a7fc:	00401a99 	.word	0x00401a99

0040a800 <task_quintic_initializeImus>:
 * @brief Start the initializing process for IMUs.
 * @param pvParameters, void pointer to structure containing quintic and imu configuration. 
 * @return void
 ***********************************************************************************************/
void task_quintic_initializeImus(void *pvParameters)
{
  40a800:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40a804:	4604      	mov	r4, r0
  40a806:	b0b1      	sub	sp, #196	; 0xc4
	quinticConfiguration_t *qConfig = (quinticConfiguration_t*)pvParameters;
	status_t result = STATUS_PASS;
	status_t scanSuccess=STATUS_FAIL, connSuccess=STATUS_FAIL;
	int vScanLoopCount=0;
	//reset the quintic here...
	drv_uart_flushRx(qConfig->uartDevice);	//flush the uart first
  40a808:	f8df 82cc 	ldr.w	r8, [pc, #716]	; 40aad8 <task_quintic_initializeImus+0x2d8>
  40a80c:	6940      	ldr	r0, [r0, #20]
	drv_gpio_setPinState(qConfig->resetPin,DRV_GPIO_PIN_STATE_LOW);
  40a80e:	4f9a      	ldr	r7, [pc, #616]	; (40aa78 <task_quintic_initializeImus+0x278>)
	vTaskDelay(100);
  40a810:	4d9a      	ldr	r5, [pc, #616]	; (40aa7c <task_quintic_initializeImus+0x27c>)
	drv_gpio_setPinState(qConfig->resetPin,DRV_GPIO_PIN_STATE_HIGH);
	#ifndef USE_Q1_Q2
	//drv_gpio_setPinState(DRV_GPIO_PIN_JC_EN1, DRV_GPIO_PIN_STATE_HIGH);
	//drv_gpio_setPinState(DRV_GPIO_PIN_JC_EN2, DRV_GPIO_PIN_STATE_HIGH);
	toggleJackEnables(DRV_GPIO_PIN_STATE_HIGH);
  40a812:	4e9b      	ldr	r6, [pc, #620]	; (40aa80 <task_quintic_initializeImus+0x280>)
	quinticConfiguration_t *qConfig = (quinticConfiguration_t*)pvParameters;
	status_t result = STATUS_PASS;
	status_t scanSuccess=STATUS_FAIL, connSuccess=STATUS_FAIL;
	int vScanLoopCount=0;
	//reset the quintic here...
	drv_uart_flushRx(qConfig->uartDevice);	//flush the uart first
  40a814:	47c0      	blx	r8
	drv_gpio_setPinState(qConfig->resetPin,DRV_GPIO_PIN_STATE_LOW);
  40a816:	2100      	movs	r1, #0
  40a818:	f894 0020 	ldrb.w	r0, [r4, #32]
  40a81c:	47b8      	blx	r7
	vTaskDelay(100);
  40a81e:	2064      	movs	r0, #100	; 0x64
  40a820:	47a8      	blx	r5
	drv_gpio_setPinState(qConfig->resetPin,DRV_GPIO_PIN_STATE_HIGH);
  40a822:	2101      	movs	r1, #1
  40a824:	f894 0020 	ldrb.w	r0, [r4, #32]
  40a828:	47b8      	blx	r7
	#ifndef USE_Q1_Q2
	//drv_gpio_setPinState(DRV_GPIO_PIN_JC_EN1, DRV_GPIO_PIN_STATE_HIGH);
	//drv_gpio_setPinState(DRV_GPIO_PIN_JC_EN2, DRV_GPIO_PIN_STATE_HIGH);
	toggleJackEnables(DRV_GPIO_PIN_STATE_HIGH);
  40a82a:	2001      	movs	r0, #1
  40a82c:	47b0      	blx	r6
	#endif
	vTaskDelay(100);
  40a82e:	2064      	movs	r0, #100	; 0x64
  40a830:	47a8      	blx	r5
	#ifndef USE_Q1_Q2
	//drv_gpio_setPinState(DRV_GPIO_PIN_JC_EN1, DRV_GPIO_PIN_STATE_LOW);
	//drv_gpio_setPinState(DRV_GPIO_PIN_JC_EN2, DRV_GPIO_PIN_STATE_LOW);
	toggleJackEnables(DRV_GPIO_PIN_STATE_LOW);
  40a832:	2000      	movs	r0, #0
  40a834:	47b0      	blx	r6
	#endif
	vTaskDelay(100);
  40a836:	2064      	movs	r0, #100	; 0x64
  40a838:	47a8      	blx	r5
	//wait for first ACK
	result = getResponse(qConfig->uartDevice, "AppStart\r\n"); 
  40a83a:	4b92      	ldr	r3, [pc, #584]	; (40aa84 <task_quintic_initializeImus+0x284>)
  40a83c:	6960      	ldr	r0, [r4, #20]
  40a83e:	4798      	blx	r3
  40a840:	4606      	mov	r6, r0
	drv_uart_flushRx(qConfig->uartDevice);	//flush the uart first
  40a842:	6960      	ldr	r0, [r4, #20]
  40a844:	47c0      	blx	r8
	vTaskDelay(10);
  40a846:	200a      	movs	r0, #10
  40a848:	47a8      	blx	r5
	//get quintic ready to receive the
	if (result != STATUS_PASS)
  40a84a:	b166      	cbz	r6, 40a866 <task_quintic_initializeImus+0x66>
	{
		debugPrintString("Did not receive first ACK from Q\r\n");
  40a84c:	488e      	ldr	r0, [pc, #568]	; (40aa88 <task_quintic_initializeImus+0x288>)
  40a84e:	4b8f      	ldr	r3, [pc, #572]	; (40aa8c <task_quintic_initializeImus+0x28c>)
  40a850:	4798      	blx	r3
		task_stateMachine_EnqueueEvent(SYS_EVENT_RESET_FAILED, 0xff);
  40a852:	200b      	movs	r0, #11
  40a854:	21ff      	movs	r1, #255	; 0xff
	}
	else
	{
		//printf("Failed connection to IMUs %d, %d, %d\r\n",qConfig->imuArray[0]->imuId,qConfig->imuArray[1]->imuId,qConfig->imuArray[2]->imuId);
		//result = STATUS_FAIL; 
		task_stateMachine_EnqueueEvent(SYS_EVENT_RESET_FAILED, 0x00);
  40a856:	4b8e      	ldr	r3, [pc, #568]	; (40aa90 <task_quintic_initializeImus+0x290>)
  40a858:	4798      	blx	r3
	}
	vTaskDelete(NULL);
  40a85a:	2000      	movs	r0, #0
  40a85c:	4b8d      	ldr	r3, [pc, #564]	; (40aa94 <task_quintic_initializeImus+0x294>)
  40a85e:	4798      	blx	r3
	//return the result;
	//return result;

}
  40a860:	b031      	add	sp, #196	; 0xc4
  40a862:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		task_stateMachine_EnqueueEvent(SYS_EVENT_RESET_FAILED, 0xff);
		vTaskDelete(NULL);
		return;
	}
	
	sendString(qConfig->uartDevice,QCMD_BEGIN);
  40a866:	498c      	ldr	r1, [pc, #560]	; (40aa98 <task_quintic_initializeImus+0x298>)
  40a868:	6960      	ldr	r0, [r4, #20]
  40a86a:	4f8c      	ldr	r7, [pc, #560]	; (40aa9c <task_quintic_initializeImus+0x29c>)
	vTaskDelay(10);
	result |= getAck(qConfig->uartDevice);
  40a86c:	f8df 9234 	ldr.w	r9, [pc, #564]	; 40aaa4 <task_quintic_initializeImus+0x2a4>
		task_stateMachine_EnqueueEvent(SYS_EVENT_RESET_FAILED, 0xff);
		vTaskDelete(NULL);
		return;
	}
	
	sendString(qConfig->uartDevice,QCMD_BEGIN);
  40a870:	47b8      	blx	r7
	vTaskDelay(10);
  40a872:	200a      	movs	r0, #10
  40a874:	47a8      	blx	r5
	result |= getAck(qConfig->uartDevice);
  40a876:	6960      	ldr	r0, [r4, #20]
  40a878:	47c8      	blx	r9
	if (result != STATUS_PASS)
  40a87a:	b9a8      	cbnz	r0, 40a8a8 <task_quintic_initializeImus+0xa8>
		return;
	}
	
	//send MAC addresses for each NOD	
	int i = 0;
	for(i=0;i<qConfig->expectedNumberOfNods; i++)
  40a87c:	69a3      	ldr	r3, [r4, #24]
  40a87e:	2b00      	cmp	r3, #0
  40a880:	dd15      	ble.n	40a8ae <task_quintic_initializeImus+0xae>
  40a882:	4606      	mov	r6, r0
  40a884:	f1a4 0804 	sub.w	r8, r4, #4
  40a888:	e002      	b.n	40a890 <task_quintic_initializeImus+0x90>
  40a88a:	69a3      	ldr	r3, [r4, #24]
  40a88c:	42b3      	cmp	r3, r6
  40a88e:	dd0e      	ble.n	40a8ae <task_quintic_initializeImus+0xae>
	{
		sendString(qConfig->uartDevice,qConfig->imuArray[i]->macAddress);
  40a890:	f858 1f04 	ldr.w	r1, [r8, #4]!
  40a894:	6960      	ldr	r0, [r4, #20]
  40a896:	3104      	adds	r1, #4
  40a898:	47b8      	blx	r7
		vTaskDelay(10);
  40a89a:	200a      	movs	r0, #10
  40a89c:	47a8      	blx	r5
		result |= getAck(qConfig->uartDevice);
  40a89e:	6960      	ldr	r0, [r4, #20]
		return;
	}
	
	//send MAC addresses for each NOD	
	int i = 0;
	for(i=0;i<qConfig->expectedNumberOfNods; i++)
  40a8a0:	3601      	adds	r6, #1
	{
		sendString(qConfig->uartDevice,qConfig->imuArray[i]->macAddress);
		vTaskDelay(10);
		result |= getAck(qConfig->uartDevice);
  40a8a2:	47c8      	blx	r9
		if (result != STATUS_PASS)
  40a8a4:	2800      	cmp	r0, #0
  40a8a6:	d0f0      	beq.n	40a88a <task_quintic_initializeImus+0x8a>
	sendString(qConfig->uartDevice,QCMD_BEGIN);
	vTaskDelay(10);
	result |= getAck(qConfig->uartDevice);
	if (result != STATUS_PASS)
	{
		task_stateMachine_EnqueueEvent(SYS_EVENT_RESET_FAILED, 0xff);
  40a8a8:	200b      	movs	r0, #11
  40a8aa:	21ff      	movs	r1, #255	; 0xff
  40a8ac:	e7d3      	b.n	40a856 <task_quintic_initializeImus+0x56>
			task_stateMachine_EnqueueEvent(SYS_EVENT_RESET_FAILED, 0xff);
			vTaskDelete(NULL);
			return;
		}
	}
	sendString(qConfig->uartDevice,"end\r\n");
  40a8ae:	497c      	ldr	r1, [pc, #496]	; (40aaa0 <task_quintic_initializeImus+0x2a0>)
  40a8b0:	6960      	ldr	r0, [r4, #20]
  40a8b2:	f8df a1e8 	ldr.w	sl, [pc, #488]	; 40aa9c <task_quintic_initializeImus+0x29c>
	vTaskDelay(10);
  40a8b6:	f8df 81c4 	ldr.w	r8, [pc, #452]	; 40aa7c <task_quintic_initializeImus+0x27c>
	result |= getAck(qConfig->uartDevice);
  40a8ba:	4e7a      	ldr	r6, [pc, #488]	; (40aaa4 <task_quintic_initializeImus+0x2a4>)
			task_stateMachine_EnqueueEvent(SYS_EVENT_RESET_FAILED, 0xff);
			vTaskDelete(NULL);
			return;
		}
	}
	sendString(qConfig->uartDevice,"end\r\n");
  40a8bc:	47b8      	blx	r7
	vTaskDelay(10);
  40a8be:	200a      	movs	r0, #10
  40a8c0:	47a8      	blx	r5
	result |= getAck(qConfig->uartDevice);
  40a8c2:	6960      	ldr	r0, [r4, #20]
  40a8c4:	47c8      	blx	r9
	if (result != STATUS_PASS)
  40a8c6:	4603      	mov	r3, r0
  40a8c8:	2800      	cmp	r0, #0
  40a8ca:	d1ed      	bne.n	40a8a8 <task_quintic_initializeImus+0xa8>
		return;
	}
	
	//send the latest channel mapping to quintics
	char buf[20] = {0};
	strncat(buf, "chmap ", 6);		//append the channel map command to the mask
  40a8cc:	4a76      	ldr	r2, [pc, #472]	; (40aaa8 <task_quintic_initializeImus+0x2a8>)
		vTaskDelete(NULL);
		return;
	}
	
	//send the latest channel mapping to quintics
	char buf[20] = {0};
  40a8ce:	9006      	str	r0, [sp, #24]
	strncat(buf, "chmap ", 6);		//append the channel map command to the mask
  40a8d0:	e892 0003 	ldmia.w	r2, {r0, r1}
	sendString(qConfig->uartDevice, strncat(buf, brainSettings.channelmap, 20-6));
  40a8d4:	f8df c204 	ldr.w	ip, [pc, #516]	; 40aadc <task_quintic_initializeImus+0x2dc>
		return;
	}
	
	//send the latest channel mapping to quintics
	char buf[20] = {0};
	strncat(buf, "chmap ", 6);		//append the channel map command to the mask
  40a8d8:	9005      	str	r0, [sp, #20]
  40a8da:	ea4f 4e11 	mov.w	lr, r1, lsr #16
	sendString(qConfig->uartDevice, strncat(buf, brainSettings.channelmap, 20-6));
  40a8de:	220e      	movs	r2, #14
		return;
	}
	
	//send the latest channel mapping to quintics
	char buf[20] = {0};
	strncat(buf, "chmap ", 6);		//append the channel map command to the mask
  40a8e0:	f8ad 1018 	strh.w	r1, [sp, #24]
	sendString(qConfig->uartDevice, strncat(buf, brainSettings.channelmap, 20-6));
  40a8e4:	a805      	add	r0, sp, #20
  40a8e6:	4971      	ldr	r1, [pc, #452]	; (40aaac <task_quintic_initializeImus+0x2ac>)
		vTaskDelete(NULL);
		return;
	}
	
	//send the latest channel mapping to quintics
	char buf[20] = {0};
  40a8e8:	9307      	str	r3, [sp, #28]
  40a8ea:	9308      	str	r3, [sp, #32]
  40a8ec:	9309      	str	r3, [sp, #36]	; 0x24
	strncat(buf, "chmap ", 6);		//append the channel map command to the mask
  40a8ee:	f88d e01a 	strb.w	lr, [sp, #26]
	sendString(qConfig->uartDevice, strncat(buf, brainSettings.channelmap, 20-6));
  40a8f2:	f8d4 9014 	ldr.w	r9, [r4, #20]
  40a8f6:	47e0      	blx	ip
  40a8f8:	4601      	mov	r1, r0
  40a8fa:	4648      	mov	r0, r9
  40a8fc:	47d0      	blx	sl
	vTaskDelay(10);
  40a8fe:	200a      	movs	r0, #10
  40a900:	47c0      	blx	r8
	result |= getAck(qConfig->uartDevice);
  40a902:	6960      	ldr	r0, [r4, #20]
  40a904:	47b0      	blx	r6
	if (result != STATUS_PASS)
  40a906:	2800      	cmp	r0, #0
  40a908:	d1ce      	bne.n	40a8a8 <task_quintic_initializeImus+0xa8>
 * @return void
 ***********************************************************************************************/
static status_t scanForImus(quinticConfiguration_t* qConfig)
{
	status_t status = STATUS_FAIL; 
	char buf[150] = {0}; 
  40a90a:	4601      	mov	r1, r0
  40a90c:	2296      	movs	r2, #150	; 0x96
  40a90e:	a80a      	add	r0, sp, #40	; 0x28
  40a910:	4b67      	ldr	r3, [pc, #412]	; (40aab0 <task_quintic_initializeImus+0x2b0>)
  40a912:	f8df 91cc 	ldr.w	r9, [pc, #460]	; 40aae0 <task_quintic_initializeImus+0x2e0>
  40a916:	f8df 81cc 	ldr.w	r8, [pc, #460]	; 40aae4 <task_quintic_initializeImus+0x2e4>
  40a91a:	4798      	blx	r3
  40a91c:	f04f 0a05 	mov.w	sl, #5
	char* bufPtr = buf; 
	int vScanLoopCount = 0;
	int presentImuCount = 0;
	do
	{
		sendString(qConfig->uartDevice,QCMD_SCAN); //send the scan command
  40a920:	4964      	ldr	r1, [pc, #400]	; (40aab4 <task_quintic_initializeImus+0x2b4>)
  40a922:	6960      	ldr	r0, [r4, #20]
  40a924:	47b8      	blx	r7
		vTaskDelay(1);
  40a926:	2001      	movs	r0, #1
  40a928:	47a8      	blx	r5
		if(drv_uart_getlineTimed(qConfig->uartDevice, buf, sizeof(buf),16000) == STATUS_PASS)
  40a92a:	6960      	ldr	r0, [r4, #20]
  40a92c:	a90a      	add	r1, sp, #40	; 0x28
  40a92e:	2296      	movs	r2, #150	; 0x96
  40a930:	f44f 537a 	mov.w	r3, #16000	; 0x3e80
  40a934:	47c8      	blx	r9
  40a936:	bb50      	cbnz	r0, 40a98e <task_quintic_initializeImus+0x18e>
		{
			debugPrintStringInt(buf, qConfig->qId);
  40a938:	a80a      	add	r0, sp, #40	; 0x28
  40a93a:	6aa1      	ldr	r1, [r4, #40]	; 0x28
  40a93c:	47c0      	blx	r8
			if(strncmp(buf,"ScanResp",8) == 0)
  40a93e:	a80a      	add	r0, sp, #40	; 0x28
  40a940:	495d      	ldr	r1, [pc, #372]	; (40aab8 <task_quintic_initializeImus+0x2b8>)
  40a942:	4b5e      	ldr	r3, [pc, #376]	; (40aabc <task_quintic_initializeImus+0x2bc>)
  40a944:	2208      	movs	r2, #8
  40a946:	4798      	blx	r3
  40a948:	bb20      	cbnz	r0, 40a994 <task_quintic_initializeImus+0x194>
			{
				bufPtr = buf + 8; 
				presentImuCount = 0;
				for(i=0;i<qConfig->expectedNumberOfNods;i++)
  40a94a:	69a3      	ldr	r3, [r4, #24]
  40a94c:	2b00      	cmp	r3, #0
  40a94e:	dd3c      	ble.n	40a9ca <task_quintic_initializeImus+0x1ca>
				{
					if(bufPtr[i] == '1')
					{
						qConfig->imuArray[i]->imuPresent = 1; 	
  40a950:	f8cd a008 	str.w	sl, [sp, #8]
  40a954:	46a3      	mov	fp, r4
			debugPrintStringInt(buf, qConfig->qId);
			if(strncmp(buf,"ScanResp",8) == 0)
			{
				bufPtr = buf + 8; 
				presentImuCount = 0;
				for(i=0;i<qConfig->expectedNumberOfNods;i++)
  40a956:	4606      	mov	r6, r0
						qConfig->imuArray[i]->imuPresent = 1; 	
						presentImuCount++;					
					}
					else
					{
						qConfig->imuArray[i]->imuPresent = 0; 
  40a958:	4602      	mov	r2, r0
				presentImuCount = 0;
				for(i=0;i<qConfig->expectedNumberOfNods;i++)
				{
					if(bufPtr[i] == '1')
					{
						qConfig->imuArray[i]->imuPresent = 1; 	
  40a95a:	4682      	mov	sl, r0
  40a95c:	4604      	mov	r4, r0
  40a95e:	e009      	b.n	40a974 <task_quintic_initializeImus+0x174>
						presentImuCount++;					
					}
					else
					{
						qConfig->imuArray[i]->imuPresent = 0; 
  40a960:	61ca      	str	r2, [r1, #28]
						if (i < qConfig->expectedNumberOfNods)
  40a962:	f8db 1018 	ldr.w	r1, [fp, #24]
  40a966:	42b1      	cmp	r1, r6
  40a968:	dc1f      	bgt.n	40a9aa <task_quintic_initializeImus+0x1aa>
			debugPrintStringInt(buf, qConfig->qId);
			if(strncmp(buf,"ScanResp",8) == 0)
			{
				bufPtr = buf + 8; 
				presentImuCount = 0;
				for(i=0;i<qConfig->expectedNumberOfNods;i++)
  40a96a:	3601      	adds	r6, #1
  40a96c:	42b1      	cmp	r1, r6
  40a96e:	f104 0404 	add.w	r4, r4, #4
  40a972:	dd24      	ble.n	40a9be <task_quintic_initializeImus+0x1be>
  40a974:	a90a      	add	r1, sp, #40	; 0x28
  40a976:	4431      	add	r1, r6
				{
					if(bufPtr[i] == '1')
  40a978:	7a09      	ldrb	r1, [r1, #8]
  40a97a:	2931      	cmp	r1, #49	; 0x31
					{
						qConfig->imuArray[i]->imuPresent = 1; 	
  40a97c:	f85b 1004 	ldr.w	r1, [fp, r4]
			{
				bufPtr = buf + 8; 
				presentImuCount = 0;
				for(i=0;i<qConfig->expectedNumberOfNods;i++)
				{
					if(bufPtr[i] == '1')
  40a980:	d1ee      	bne.n	40a960 <task_quintic_initializeImus+0x160>
					{
						qConfig->imuArray[i]->imuPresent = 1; 	
  40a982:	2001      	movs	r0, #1
  40a984:	61c8      	str	r0, [r1, #28]
						presentImuCount++;					
  40a986:	4482      	add	sl, r0
  40a988:	f8db 1018 	ldr.w	r1, [fp, #24]
  40a98c:	e7ed      	b.n	40a96a <task_quintic_initializeImus+0x16a>
				}
			}
		}
		else
		{
			debugPrintStringInt("No response on scan\r\n", qConfig->qId);
  40a98e:	484c      	ldr	r0, [pc, #304]	; (40aac0 <task_quintic_initializeImus+0x2c0>)
  40a990:	6aa1      	ldr	r1, [r4, #40]	; 0x28
  40a992:	47c0      	blx	r8
		}		
		vTaskDelay(10);
  40a994:	200a      	movs	r0, #10
  40a996:	47a8      	blx	r5
		vScanLoopCount++;
	}while(vScanLoopCount<=QUINTIC_MAX_SCAN_ATTEMPTS);	
  40a998:	f1ba 0a01 	subs.w	sl, sl, #1
  40a99c:	d1c0      	bne.n	40a920 <task_quintic_initializeImus+0x120>
	}
		
	
	//pass command to implement the new channel map
	//can only be passed after the connection has been established with the IMUs.
	sendString(qConfig->uartDevice, "setMap\r\n");
  40a99e:	4949      	ldr	r1, [pc, #292]	; (40aac4 <task_quintic_initializeImus+0x2c4>)
  40a9a0:	6960      	ldr	r0, [r4, #20]
  40a9a2:	47b8      	blx	r7
	}
	else
	{
		//printf("Failed connection to IMUs %d, %d, %d\r\n",qConfig->imuArray[0]->imuId,qConfig->imuArray[1]->imuId,qConfig->imuArray[2]->imuId);
		//result = STATUS_FAIL; 
		task_stateMachine_EnqueueEvent(SYS_EVENT_RESET_FAILED, 0x00);
  40a9a4:	200b      	movs	r0, #11
  40a9a6:	2100      	movs	r1, #0
  40a9a8:	e755      	b.n	40a856 <task_quintic_initializeImus+0x56>
					else
					{
						qConfig->imuArray[i]->imuPresent = 0; 
						if (i < qConfig->expectedNumberOfNods)
						{
							debugPrintStringInt("Failed on IMU Id\r\n", qConfig->imuArray[i]->imuId);
  40a9aa:	f85b 1004 	ldr.w	r1, [fp, r4]
  40a9ae:	4846      	ldr	r0, [pc, #280]	; (40aac8 <task_quintic_initializeImus+0x2c8>)
  40a9b0:	6809      	ldr	r1, [r1, #0]
  40a9b2:	9200      	str	r2, [sp, #0]
  40a9b4:	47c0      	blx	r8
  40a9b6:	f8db 1018 	ldr.w	r1, [fp, #24]
  40a9ba:	9a00      	ldr	r2, [sp, #0]
  40a9bc:	e7d5      	b.n	40a96a <task_quintic_initializeImus+0x16a>
  40a9be:	465c      	mov	r4, fp
  40a9c0:	46d3      	mov	fp, sl
						}
					}			
				}
				if(presentImuCount >= qConfig->expectedNumberOfNods)
  40a9c2:	4559      	cmp	r1, fp
  40a9c4:	f8dd a008 	ldr.w	sl, [sp, #8]
  40a9c8:	dce4      	bgt.n	40a994 <task_quintic_initializeImus+0x194>
 * @return void
 ***********************************************************************************************/
static status_t connectToImus(quinticConfiguration_t* qConfig)
{
	status_t status = STATUS_FAIL;
	char buf[150] = {0};
  40a9ca:	a80a      	add	r0, sp, #40	; 0x28
  40a9cc:	2100      	movs	r1, #0
  40a9ce:	2296      	movs	r2, #150	; 0x96
  40a9d0:	4b37      	ldr	r3, [pc, #220]	; (40aab0 <task_quintic_initializeImus+0x2b0>)
  40a9d2:	f8df b114 	ldr.w	fp, [pc, #276]	; 40aae8 <task_quintic_initializeImus+0x2e8>
  40a9d6:	4798      	blx	r3
  40a9d8:	2004      	movs	r0, #4
  40a9da:	9003      	str	r0, [sp, #12]

	while(vConnectionLoopCount < 4)
	{
		//flush the buffer before sending the command. 
		//drv_uart_flushRx(qConfig->uartDevice);
		debugPrintStringInt("sent connect\r\n", qConfig->qId);
  40a9dc:	483b      	ldr	r0, [pc, #236]	; (40aacc <task_quintic_initializeImus+0x2cc>)
  40a9de:	6aa1      	ldr	r1, [r4, #40]	; 0x28
  40a9e0:	47c0      	blx	r8
		sendString(qConfig->uartDevice,QCMD_CONNECT); //send the connect command
  40a9e2:	493b      	ldr	r1, [pc, #236]	; (40aad0 <task_quintic_initializeImus+0x2d0>)
  40a9e4:	6960      	ldr	r0, [r4, #20]
  40a9e6:	47b8      	blx	r7
		vTaskDelay(1);
  40a9e8:	2001      	movs	r0, #1
  40a9ea:	47a8      	blx	r5
		//wait for 16 seconds trying to get the connect response from the quintic. 
		startTime = sgSysTickCount; 
  40a9ec:	f8db 3000 	ldr.w	r3, [fp]
  40a9f0:	f503 527a 	add.w	r2, r3, #16000	; 0x3e80
  40a9f4:	9202      	str	r2, [sp, #8]
		while(sgSysTickCount < (startTime + 16000))
  40a9f6:	9a02      	ldr	r2, [sp, #8]
  40a9f8:	429a      	cmp	r2, r3
  40a9fa:	f240 8088 	bls.w	40ab0e <task_quintic_initializeImus+0x30e>
		{
			if(drv_uart_getlineTimed(qConfig->uartDevice, buf, sizeof(buf), 4000) == STATUS_PASS)
  40a9fe:	6960      	ldr	r0, [r4, #20]
  40aa00:	a90a      	add	r1, sp, #40	; 0x28
  40aa02:	2296      	movs	r2, #150	; 0x96
  40aa04:	f44f 637a 	mov.w	r3, #4000	; 0xfa0
  40aa08:	47c8      	blx	r9
  40aa0a:	2800      	cmp	r0, #0
  40aa0c:	d16e      	bne.n	40aaec <task_quintic_initializeImus+0x2ec>
			{
				debugPrintStringInt(buf, qConfig->qId);
  40aa0e:	a80a      	add	r0, sp, #40	; 0x28
  40aa10:	6aa1      	ldr	r1, [r4, #40]	; 0x28
  40aa12:	47c0      	blx	r8
				if(strncmp(buf,"ConnResp",8) == 0)
  40aa14:	a80a      	add	r0, sp, #40	; 0x28
  40aa16:	492f      	ldr	r1, [pc, #188]	; (40aad4 <task_quintic_initializeImus+0x2d4>)
  40aa18:	4b28      	ldr	r3, [pc, #160]	; (40aabc <task_quintic_initializeImus+0x2bc>)
  40aa1a:	2208      	movs	r2, #8
  40aa1c:	4798      	blx	r3
  40aa1e:	2800      	cmp	r0, #0
  40aa20:	d167      	bne.n	40aaf2 <task_quintic_initializeImus+0x2f2>
				{
					bufPtr = buf + 8;
					connectedImuCount = 0;
					for(i=0;i<qConfig->expectedNumberOfNods;i++)
  40aa22:	69a3      	ldr	r3, [r4, #24]
  40aa24:	2b00      	cmp	r3, #0
  40aa26:	dd1f      	ble.n	40aa68 <task_quintic_initializeImus+0x268>
  40aa28:	4682      	mov	sl, r0
  40aa2a:	4602      	mov	r2, r0
  40aa2c:	4606      	mov	r6, r0
							qConfig->imuArray[i]->imuConnected = 1;
							connectedImuCount++;
						}
						else
						{
							qConfig->imuArray[i]->imuConnected = 0;
  40aa2e:	4603      	mov	r3, r0
  40aa30:	e008      	b.n	40aa44 <task_quintic_initializeImus+0x244>
  40aa32:	620b      	str	r3, [r1, #32]
							if (i < qConfig->expectedNumberOfNods)
  40aa34:	69a1      	ldr	r1, [r4, #24]
  40aa36:	42b1      	cmp	r1, r6
  40aa38:	dc5e      	bgt.n	40aaf8 <task_quintic_initializeImus+0x2f8>
				debugPrintStringInt(buf, qConfig->qId);
				if(strncmp(buf,"ConnResp",8) == 0)
				{
					bufPtr = buf + 8;
					connectedImuCount = 0;
					for(i=0;i<qConfig->expectedNumberOfNods;i++)
  40aa3a:	3601      	adds	r6, #1
  40aa3c:	42b1      	cmp	r1, r6
  40aa3e:	f10a 0a04 	add.w	sl, sl, #4
  40aa42:	dd0f      	ble.n	40aa64 <task_quintic_initializeImus+0x264>
  40aa44:	a90a      	add	r1, sp, #40	; 0x28
  40aa46:	4431      	add	r1, r6
					{
						if(bufPtr[i] == '1')
  40aa48:	7a09      	ldrb	r1, [r1, #8]
  40aa4a:	2931      	cmp	r1, #49	; 0x31
						{
							qConfig->imuArray[i]->imuConnected = 1;
  40aa4c:	f854 100a 	ldr.w	r1, [r4, sl]
				{
					bufPtr = buf + 8;
					connectedImuCount = 0;
					for(i=0;i<qConfig->expectedNumberOfNods;i++)
					{
						if(bufPtr[i] == '1')
  40aa50:	d1ef      	bne.n	40aa32 <task_quintic_initializeImus+0x232>
						{
							qConfig->imuArray[i]->imuConnected = 1;
  40aa52:	2001      	movs	r0, #1
  40aa54:	6208      	str	r0, [r1, #32]
  40aa56:	69a1      	ldr	r1, [r4, #24]
				debugPrintStringInt(buf, qConfig->qId);
				if(strncmp(buf,"ConnResp",8) == 0)
				{
					bufPtr = buf + 8;
					connectedImuCount = 0;
					for(i=0;i<qConfig->expectedNumberOfNods;i++)
  40aa58:	3601      	adds	r6, #1
  40aa5a:	42b1      	cmp	r1, r6
					{
						if(bufPtr[i] == '1')
						{
							qConfig->imuArray[i]->imuConnected = 1;
							connectedImuCount++;
  40aa5c:	4402      	add	r2, r0
  40aa5e:	f10a 0a04 	add.w	sl, sl, #4
				debugPrintStringInt(buf, qConfig->qId);
				if(strncmp(buf,"ConnResp",8) == 0)
				{
					bufPtr = buf + 8;
					connectedImuCount = 0;
					for(i=0;i<qConfig->expectedNumberOfNods;i++)
  40aa62:	dcef      	bgt.n	40aa44 <task_quintic_initializeImus+0x244>
							{
								debugPrintStringInt("Failed on IMU Id\r\n", qConfig->imuArray[i]->imuId);
							}
						}
					}
					if(connectedImuCount >= qConfig->expectedNumberOfNods)
  40aa64:	4291      	cmp	r1, r2
  40aa66:	dc44      	bgt.n	40aaf2 <task_quintic_initializeImus+0x2f2>
	}
		
	
	//pass command to implement the new channel map
	//can only be passed after the connection has been established with the IMUs.
	sendString(qConfig->uartDevice, "setMap\r\n");
  40aa68:	6960      	ldr	r0, [r4, #20]
  40aa6a:	4916      	ldr	r1, [pc, #88]	; (40aac4 <task_quintic_initializeImus+0x2c4>)
  40aa6c:	47b8      	blx	r7
	
	if(scanSuccess == STATUS_PASS && connSuccess == STATUS_PASS)
	{		
		//printf("connected to IMUs %d, %d, %d\r\n",qConfig->imuArray[0]->imuId,qConfig->imuArray[1]->imuId,qConfig->imuArray[2]->imuId);
		task_stateMachine_EnqueueEvent(SYS_EVENT_RESET_COMPLETE, qConfig->qId);			
  40aa6e:	8d21      	ldrh	r1, [r4, #40]	; 0x28
  40aa70:	4b07      	ldr	r3, [pc, #28]	; (40aa90 <task_quintic_initializeImus+0x290>)
  40aa72:	200a      	movs	r0, #10
  40aa74:	4798      	blx	r3
  40aa76:	e6f0      	b.n	40a85a <task_quintic_initializeImus+0x5a>
  40aa78:	004087b1 	.word	0x004087b1
  40aa7c:	004072ed 	.word	0x004072ed
  40aa80:	0040a4a1 	.word	0x0040a4a1
  40aa84:	0040a549 	.word	0x0040a549
  40aa88:	00416d3c 	.word	0x00416d3c
  40aa8c:	004008c9 	.word	0x004008c9
  40aa90:	00401a99 	.word	0x00401a99
  40aa94:	00406fad 	.word	0x00406fad
  40aa98:	00416d60 	.word	0x00416d60
  40aa9c:	0040a4d1 	.word	0x0040a4d1
  40aaa0:	00416d68 	.word	0x00416d68
  40aaa4:	0040a505 	.word	0x0040a505
  40aaa8:	00416d70 	.word	0x00416d70
  40aaac:	2000024c 	.word	0x2000024c
  40aab0:	0040c31d 	.word	0x0040c31d
  40aab4:	00416d78 	.word	0x00416d78
  40aab8:	00416d80 	.word	0x00416d80
  40aabc:	0040ca69 	.word	0x0040ca69
  40aac0:	00416da0 	.word	0x00416da0
  40aac4:	00416de4 	.word	0x00416de4
  40aac8:	00416d8c 	.word	0x00416d8c
  40aacc:	00416db8 	.word	0x00416db8
  40aad0:	00416cec 	.word	0x00416cec
  40aad4:	00416cf8 	.word	0x00416cf8
  40aad8:	004090b1 	.word	0x004090b1
  40aadc:	0040ca05 	.word	0x0040ca05
  40aae0:	00408fb9 	.word	0x00408fb9
  40aae4:	004007b5 	.word	0x004007b5
  40aae8:	20003970 	.word	0x20003970
					}
				}			
			}
			else
			{
				debugPrintStringInt("No response on connect\r\n", qConfig->qId);
  40aaec:	480b      	ldr	r0, [pc, #44]	; (40ab1c <task_quintic_initializeImus+0x31c>)
  40aaee:	6aa1      	ldr	r1, [r4, #40]	; 0x28
  40aaf0:	47c0      	blx	r8
  40aaf2:	f8db 3000 	ldr.w	r3, [fp]
  40aaf6:	e77e      	b.n	40a9f6 <task_quintic_initializeImus+0x1f6>
						else
						{
							qConfig->imuArray[i]->imuConnected = 0;
							if (i < qConfig->expectedNumberOfNods)
							{
								debugPrintStringInt("Failed on IMU Id\r\n", qConfig->imuArray[i]->imuId);
  40aaf8:	f854 100a 	ldr.w	r1, [r4, sl]
  40aafc:	4808      	ldr	r0, [pc, #32]	; (40ab20 <task_quintic_initializeImus+0x320>)
  40aafe:	6809      	ldr	r1, [r1, #0]
  40ab00:	e88d 000c 	stmia.w	sp, {r2, r3}
  40ab04:	47c0      	blx	r8
  40ab06:	69a1      	ldr	r1, [r4, #24]
  40ab08:	e89d 000c 	ldmia.w	sp, {r2, r3}
  40ab0c:	e795      	b.n	40aa3a <task_quintic_initializeImus+0x23a>
	char* bufPtr = buf;
	int vConnectionLoopCount = 0;
	int connectedImuCount = 0;
	uint32_t startTime = 0; 

	while(vConnectionLoopCount < 4)
  40ab0e:	9b03      	ldr	r3, [sp, #12]
  40ab10:	3b01      	subs	r3, #1
  40ab12:	9303      	str	r3, [sp, #12]
  40ab14:	f47f af62 	bne.w	40a9dc <task_quintic_initializeImus+0x1dc>
  40ab18:	e741      	b.n	40a99e <task_quintic_initializeImus+0x19e>
  40ab1a:	bf00      	nop
  40ab1c:	00416dc8 	.word	0x00416dc8
  40ab20:	00416d8c 	.word	0x00416d8c

0040ab24 <task_quintic_sendConnectMsg>:
 * @brief Send the connect command to the quintic modules
 * @param quinticConfiguration_t* qConfig 
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t task_quintic_sendConnectMsg(quinticConfiguration_t* qConfig)
{
  40ab24:	b508      	push	{r3, lr}
	//send the start command. 	
	if(qConfig->isinit == 1)
  40ab26:	6a43      	ldr	r3, [r0, #36]	; 0x24
  40ab28:	2b01      	cmp	r3, #1
  40ab2a:	d001      	beq.n	40ab30 <task_quintic_sendConnectMsg+0xc>
	{
		sendString(qConfig->uartDevice, "connect\r\n");	
	}	
	return STATUS_PASS; 
}
  40ab2c:	2000      	movs	r0, #0
  40ab2e:	bd08      	pop	{r3, pc}
status_t task_quintic_sendConnectMsg(quinticConfiguration_t* qConfig)
{
	//send the start command. 	
	if(qConfig->isinit == 1)
	{
		sendString(qConfig->uartDevice, "connect\r\n");	
  40ab30:	4902      	ldr	r1, [pc, #8]	; (40ab3c <task_quintic_sendConnectMsg+0x18>)
  40ab32:	4b03      	ldr	r3, [pc, #12]	; (40ab40 <task_quintic_sendConnectMsg+0x1c>)
  40ab34:	6940      	ldr	r0, [r0, #20]
  40ab36:	4798      	blx	r3
	}	
	return STATUS_PASS; 
}
  40ab38:	2000      	movs	r0, #0
  40ab3a:	bd08      	pop	{r3, pc}
  40ab3c:	00416cec 	.word	0x00416cec
  40ab40:	0040a4d1 	.word	0x0040a4d1

0040ab44 <task_quintic_startRecording>:
 * @brief Send the start command to the IMUs to request Notif data from them
 * @param quinticConfiguration_t* qConfig 
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t task_quintic_startRecording(quinticConfiguration_t* qConfig)
{
  40ab44:	b508      	push	{r3, lr}
	//send the start command. 
	if ((qConfig->isinit) && (qConfig->expectedNumberOfNods > 0))
  40ab46:	6a43      	ldr	r3, [r0, #36]	; 0x24
  40ab48:	b133      	cbz	r3, 40ab58 <task_quintic_startRecording+0x14>
  40ab4a:	6983      	ldr	r3, [r0, #24]
  40ab4c:	2b00      	cmp	r3, #0
  40ab4e:	dd03      	ble.n	40ab58 <task_quintic_startRecording+0x14>
	{	
		sendString(qConfig->uartDevice, "start\r\n");
  40ab50:	6940      	ldr	r0, [r0, #20]
  40ab52:	4902      	ldr	r1, [pc, #8]	; (40ab5c <task_quintic_startRecording+0x18>)
  40ab54:	4b02      	ldr	r3, [pc, #8]	; (40ab60 <task_quintic_startRecording+0x1c>)
  40ab56:	4798      	blx	r3
	}
	return STATUS_PASS; 
}
  40ab58:	2000      	movs	r0, #0
  40ab5a:	bd08      	pop	{r3, pc}
  40ab5c:	00416df0 	.word	0x00416df0
  40ab60:	0040a4d1 	.word	0x0040a4d1

0040ab64 <task_quintic_stopRecording>:
 * @brief Send the stop command to the IMUs to stop Notif data from them
 * @param quinticConfiguration_t* qConfig 
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t task_quintic_stopRecording(quinticConfiguration_t* qConfig)
{
  40ab64:	b510      	push	{r4, lr}
	//send the stop
	if ((qConfig->isinit) && (qConfig->expectedNumberOfNods > 0))
  40ab66:	6a43      	ldr	r3, [r0, #36]	; 0x24
 * @brief Send the stop command to the IMUs to stop Notif data from them
 * @param quinticConfiguration_t* qConfig 
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t task_quintic_stopRecording(quinticConfiguration_t* qConfig)
{
  40ab68:	4604      	mov	r4, r0
	//send the stop
	if ((qConfig->isinit) && (qConfig->expectedNumberOfNods > 0))
  40ab6a:	b163      	cbz	r3, 40ab86 <task_quintic_stopRecording+0x22>
  40ab6c:	6983      	ldr	r3, [r0, #24]
  40ab6e:	2b00      	cmp	r3, #0
  40ab70:	dd09      	ble.n	40ab86 <task_quintic_stopRecording+0x22>
	{	
		sendString(qConfig->uartDevice, "stop\r\n");
  40ab72:	4906      	ldr	r1, [pc, #24]	; (40ab8c <task_quintic_stopRecording+0x28>)
  40ab74:	4b06      	ldr	r3, [pc, #24]	; (40ab90 <task_quintic_stopRecording+0x2c>)
  40ab76:	6940      	ldr	r0, [r0, #20]
  40ab78:	4798      	blx	r3
		//wait for a bit
		vTaskDelay(2);
  40ab7a:	2002      	movs	r0, #2
  40ab7c:	4b05      	ldr	r3, [pc, #20]	; (40ab94 <task_quintic_stopRecording+0x30>)
  40ab7e:	4798      	blx	r3
		//flush the Rx buffer, it'll still have crap in it
		drv_uart_flushRx(qConfig->uartDevice);
  40ab80:	6960      	ldr	r0, [r4, #20]
  40ab82:	4b05      	ldr	r3, [pc, #20]	; (40ab98 <task_quintic_stopRecording+0x34>)
  40ab84:	4798      	blx	r3
	}
	return STATUS_PASS;
}
  40ab86:	2000      	movs	r0, #0
  40ab88:	bd10      	pop	{r4, pc}
  40ab8a:	bf00      	nop
  40ab8c:	00416df8 	.word	0x00416df8
  40ab90:	0040a4d1 	.word	0x0040a4d1
  40ab94:	004072ed 	.word	0x004072ed
  40ab98:	004090b1 	.word	0x004090b1

0040ab9c <task_quintic_checkRssiLevel>:
 * @brief Send the "rssi" command to check RSSI level of each of the connected IMUs
 * @param quinticConfiguration_t* qConfig 
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t task_quintic_checkRssiLevel(quinticConfiguration_t* qConfig)
{
  40ab9c:	b508      	push	{r3, lr}
	if ((qConfig->isinit) && (qConfig->expectedNumberOfNods > 0))
  40ab9e:	6a43      	ldr	r3, [r0, #36]	; 0x24
  40aba0:	b133      	cbz	r3, 40abb0 <task_quintic_checkRssiLevel+0x14>
  40aba2:	6983      	ldr	r3, [r0, #24]
  40aba4:	2b00      	cmp	r3, #0
  40aba6:	dd03      	ble.n	40abb0 <task_quintic_checkRssiLevel+0x14>
	{	
		//send the rssi check command. 	
		sendString(qConfig->uartDevice, "rssi\r\n");
  40aba8:	6940      	ldr	r0, [r0, #20]
  40abaa:	4902      	ldr	r1, [pc, #8]	; (40abb4 <task_quintic_checkRssiLevel+0x18>)
  40abac:	4b02      	ldr	r3, [pc, #8]	; (40abb8 <task_quintic_checkRssiLevel+0x1c>)
  40abae:	4798      	blx	r3
	}
	return STATUS_PASS; 
}
  40abb0:	2000      	movs	r0, #0
  40abb2:	bd08      	pop	{r3, pc}
  40abb4:	00416e00 	.word	0x00416e00
  40abb8:	0040a4d1 	.word	0x0040a4d1

0040abbc <task_quintic_startGetAccelData>:
 * @brief Send the start command to the IMUs to request acceleration data
 * @param quinticConfiguration_t* qConfig 
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t task_quintic_startGetAccelData(quinticConfiguration_t* qConfig)
{
  40abbc:	b538      	push	{r3, r4, r5, lr}
	//send the start command. 
	if ((qConfig->isinit) && (qConfig->expectedNumberOfNods > 0))
  40abbe:	6a43      	ldr	r3, [r0, #36]	; 0x24
 * @brief Send the start command to the IMUs to request acceleration data
 * @param quinticConfiguration_t* qConfig 
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t task_quintic_startGetAccelData(quinticConfiguration_t* qConfig)
{
  40abc0:	4604      	mov	r4, r0
	//send the start command. 
	if ((qConfig->isinit) && (qConfig->expectedNumberOfNods > 0))
  40abc2:	b163      	cbz	r3, 40abde <task_quintic_startGetAccelData+0x22>
  40abc4:	6983      	ldr	r3, [r0, #24]
  40abc6:	2b00      	cmp	r3, #0
  40abc8:	dd09      	ble.n	40abde <task_quintic_startGetAccelData+0x22>
	{	
		sendString(qConfig->uartDevice, "getAccel1\r\n");
  40abca:	4906      	ldr	r1, [pc, #24]	; (40abe4 <task_quintic_startGetAccelData+0x28>)
  40abcc:	6940      	ldr	r0, [r0, #20]
  40abce:	4d06      	ldr	r5, [pc, #24]	; (40abe8 <task_quintic_startGetAccelData+0x2c>)
  40abd0:	47a8      	blx	r5
		vTaskDelay(100); 
  40abd2:	2064      	movs	r0, #100	; 0x64
  40abd4:	4b05      	ldr	r3, [pc, #20]	; (40abec <task_quintic_startGetAccelData+0x30>)
  40abd6:	4798      	blx	r3
		sendString(qConfig->uartDevice, "start\r\n");
  40abd8:	6960      	ldr	r0, [r4, #20]
  40abda:	4905      	ldr	r1, [pc, #20]	; (40abf0 <task_quintic_startGetAccelData+0x34>)
  40abdc:	47a8      	blx	r5
	}
	return STATUS_PASS; 
}
  40abde:	2000      	movs	r0, #0
  40abe0:	bd38      	pop	{r3, r4, r5, pc}
  40abe2:	bf00      	nop
  40abe4:	00416e08 	.word	0x00416e08
  40abe8:	0040a4d1 	.word	0x0040a4d1
  40abec:	004072ed 	.word	0x004072ed
  40abf0:	00416df0 	.word	0x00416df0

0040abf4 <task_quintic_stopGetAccelData>:
 * @brief Send the start command to the IMUs to request acceleration data
 * @param quinticConfiguration_t* qConfig 
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t task_quintic_stopGetAccelData(quinticConfiguration_t* qConfig)
{
  40abf4:	b538      	push	{r3, r4, r5, lr}
	//send the start command. 
	if ((qConfig->isinit) && (qConfig->expectedNumberOfNods > 0))
  40abf6:	6a43      	ldr	r3, [r0, #36]	; 0x24
 * @brief Send the start command to the IMUs to request acceleration data
 * @param quinticConfiguration_t* qConfig 
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t task_quintic_stopGetAccelData(quinticConfiguration_t* qConfig)
{
  40abf8:	4604      	mov	r4, r0
	//send the start command. 
	if ((qConfig->isinit) && (qConfig->expectedNumberOfNods > 0))
  40abfa:	b163      	cbz	r3, 40ac16 <task_quintic_stopGetAccelData+0x22>
  40abfc:	6983      	ldr	r3, [r0, #24]
  40abfe:	2b00      	cmp	r3, #0
  40ac00:	dd09      	ble.n	40ac16 <task_quintic_stopGetAccelData+0x22>
	{	
		sendString(qConfig->uartDevice, "getAccel0\r\n");
  40ac02:	4906      	ldr	r1, [pc, #24]	; (40ac1c <task_quintic_stopGetAccelData+0x28>)
  40ac04:	6940      	ldr	r0, [r0, #20]
  40ac06:	4d06      	ldr	r5, [pc, #24]	; (40ac20 <task_quintic_stopGetAccelData+0x2c>)
  40ac08:	47a8      	blx	r5
		vTaskDelay(100); 
  40ac0a:	2064      	movs	r0, #100	; 0x64
  40ac0c:	4b05      	ldr	r3, [pc, #20]	; (40ac24 <task_quintic_stopGetAccelData+0x30>)
  40ac0e:	4798      	blx	r3
		sendString(qConfig->uartDevice, "stop\r\n");
  40ac10:	6960      	ldr	r0, [r4, #20]
  40ac12:	4905      	ldr	r1, [pc, #20]	; (40ac28 <task_quintic_stopGetAccelData+0x34>)
  40ac14:	47a8      	blx	r5
	}
	return STATUS_PASS; 
}
  40ac16:	2000      	movs	r0, #0
  40ac18:	bd38      	pop	{r3, r4, r5, pc}
  40ac1a:	bf00      	nop
  40ac1c:	00416e14 	.word	0x00416e14
  40ac20:	0040a4d1 	.word	0x0040a4d1
  40ac24:	004072ed 	.word	0x004072ed
  40ac28:	00416df8 	.word	0x00416df8

0040ac2c <DisconnectImus>:
 * @brief Issue begin command to Quintics to disconnect and power cycle them
 * @param quinticConfiguration_t* qConfig
 * @return void
 ***********************************************************************************************/
void DisconnectImus(quinticConfiguration_t* qConfig)
{
  40ac2c:	b570      	push	{r4, r5, r6, lr}
	if ((qConfig->isinit) && (qConfig->expectedNumberOfNods > 0))
  40ac2e:	6a43      	ldr	r3, [r0, #36]	; 0x24
 * @brief Issue begin command to Quintics to disconnect and power cycle them
 * @param quinticConfiguration_t* qConfig
 * @return void
 ***********************************************************************************************/
void DisconnectImus(quinticConfiguration_t* qConfig)
{
  40ac30:	4604      	mov	r4, r0
	if ((qConfig->isinit) && (qConfig->expectedNumberOfNods > 0))
  40ac32:	b1bb      	cbz	r3, 40ac64 <DisconnectImus+0x38>
  40ac34:	6983      	ldr	r3, [r0, #24]
  40ac36:	2b00      	cmp	r3, #0
  40ac38:	dd14      	ble.n	40ac64 <DisconnectImus+0x38>
	{
		sendString(qConfig->uartDevice,QCMD_BEGIN);
  40ac3a:	490b      	ldr	r1, [pc, #44]	; (40ac68 <DisconnectImus+0x3c>)
  40ac3c:	4b0b      	ldr	r3, [pc, #44]	; (40ac6c <DisconnectImus+0x40>)
  40ac3e:	6940      	ldr	r0, [r0, #20]
		vTaskDelay(100);
  40ac40:	4e0b      	ldr	r6, [pc, #44]	; (40ac70 <DisconnectImus+0x44>)
		getAck(qConfig->uartDevice);
		drv_gpio_setPinState(qConfig->resetPin, DRV_GPIO_PIN_STATE_LOW);
  40ac42:	4d0c      	ldr	r5, [pc, #48]	; (40ac74 <DisconnectImus+0x48>)
 ***********************************************************************************************/
void DisconnectImus(quinticConfiguration_t* qConfig)
{
	if ((qConfig->isinit) && (qConfig->expectedNumberOfNods > 0))
	{
		sendString(qConfig->uartDevice,QCMD_BEGIN);
  40ac44:	4798      	blx	r3
		vTaskDelay(100);
  40ac46:	2064      	movs	r0, #100	; 0x64
  40ac48:	47b0      	blx	r6
		getAck(qConfig->uartDevice);
  40ac4a:	4b0b      	ldr	r3, [pc, #44]	; (40ac78 <DisconnectImus+0x4c>)
  40ac4c:	6960      	ldr	r0, [r4, #20]
  40ac4e:	4798      	blx	r3
		drv_gpio_setPinState(qConfig->resetPin, DRV_GPIO_PIN_STATE_LOW);
  40ac50:	2100      	movs	r1, #0
  40ac52:	f894 0020 	ldrb.w	r0, [r4, #32]
  40ac56:	47a8      	blx	r5
		vTaskDelay(100);
  40ac58:	2064      	movs	r0, #100	; 0x64
  40ac5a:	47b0      	blx	r6
		drv_gpio_setPinState(qConfig->resetPin, DRV_GPIO_PIN_STATE_HIGH);
  40ac5c:	f894 0020 	ldrb.w	r0, [r4, #32]
  40ac60:	2101      	movs	r1, #1
  40ac62:	47a8      	blx	r5
  40ac64:	bd70      	pop	{r4, r5, r6, pc}
  40ac66:	bf00      	nop
  40ac68:	00416d60 	.word	0x00416d60
  40ac6c:	0040a4d1 	.word	0x0040a4d1
  40ac70:	004072ed 	.word	0x004072ed
  40ac74:	004087b1 	.word	0x004087b1
  40ac78:	0040a505 	.word	0x0040a505

0040ac7c <sysclk_init>:
	pmc_disable_udpck();
}
#endif // CONFIG_USBCLK_SOURCE

void sysclk_init(void)
{
  40ac7c:	b538      	push	{r3, r4, r5, lr}
	/* Set flash wait state to max in case the below clock switching. */
	system_init_flash(CHIP_FREQ_CPU_MAX);
  40ac7e:	480e      	ldr	r0, [pc, #56]	; (40acb8 <sysclk_init+0x3c>)
  40ac80:	4d0e      	ldr	r5, [pc, #56]	; (40acbc <sysclk_init+0x40>)
  40ac82:	4c0f      	ldr	r4, [pc, #60]	; (40acc0 <sysclk_init+0x44>)
  40ac84:	47a8      	blx	r5
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_12_MHz);
		break;


	case OSC_MAINCK_XTAL:
		pmc_switch_mainck_to_xtal(PMC_OSC_XTAL,
  40ac86:	2000      	movs	r0, #0
  40ac88:	213e      	movs	r1, #62	; 0x3e
  40ac8a:	4b0e      	ldr	r3, [pc, #56]	; (40acc4 <sysclk_init+0x48>)
  40ac8c:	4798      	blx	r3
	case OSC_MAINCK_4M_RC:
	case OSC_MAINCK_8M_RC:
	case OSC_MAINCK_12M_RC:
	case OSC_MAINCK_XTAL:
	case OSC_MAINCK_BYPASS:
		return pmc_osc_is_ready_mainck();
  40ac8e:	47a0      	blx	r4
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
	while (!osc_is_ready(id)) {
  40ac90:	2800      	cmp	r0, #0
  40ac92:	d0fc      	beq.n	40ac8e <sysclk_init+0x12>
static inline void pll_enable(const struct pll_config *p_cfg, uint32_t ul_pll_id)
{
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
		pmc_disable_pllack(); // Always stop PLL first!
  40ac94:	4b0c      	ldr	r3, [pc, #48]	; (40acc8 <sysclk_init+0x4c>)
  40ac96:	4c0d      	ldr	r4, [pc, #52]	; (40accc <sysclk_init+0x50>)
  40ac98:	4798      	blx	r3
		PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | p_cfg->ctrl;
  40ac9a:	4b0d      	ldr	r3, [pc, #52]	; (40acd0 <sysclk_init+0x54>)
  40ac9c:	4a0d      	ldr	r2, [pc, #52]	; (40acd4 <sysclk_init+0x58>)
  40ac9e:	629a      	str	r2, [r3, #40]	; 0x28
static inline uint32_t pll_is_locked(uint32_t ul_pll_id)
{
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
		return pmc_is_locked_pllack();
  40aca0:	47a0      	blx	r4
 */
static inline int pll_wait_for_lock(unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	while (!pll_is_locked(pll_id)) {
  40aca2:	2800      	cmp	r0, #0
  40aca4:	d0fc      	beq.n	40aca0 <sysclk_init+0x24>

		pll_enable_source(CONFIG_PLL0_SOURCE);
		pll_config_defaults(&pllcfg, 0);
		pll_enable(&pllcfg, 0);
		pll_wait_for_lock(0);
		pmc_switch_mck_to_pllack(CONFIG_SYSCLK_PRES);
  40aca6:	4b0c      	ldr	r3, [pc, #48]	; (40acd8 <sysclk_init+0x5c>)
  40aca8:	2010      	movs	r0, #16
  40acaa:	4798      	blx	r3
		pmc_switch_mck_to_pllbck(CONFIG_SYSCLK_PRES);
	}
#endif

	/* Update the SystemFrequency variable */
	SystemCoreClockUpdate();
  40acac:	4b0b      	ldr	r3, [pc, #44]	; (40acdc <sysclk_init+0x60>)
  40acae:	4798      	blx	r3

	/* Set a flash wait state depending on the new cpu frequency */
	system_init_flash(sysclk_get_cpu_hz());
  40acb0:	4801      	ldr	r0, [pc, #4]	; (40acb8 <sysclk_init+0x3c>)
  40acb2:	47a8      	blx	r5
  40acb4:	bd38      	pop	{r3, r4, r5, pc}
  40acb6:	bf00      	nop
  40acb8:	07270e00 	.word	0x07270e00
  40acbc:	0040b46d 	.word	0x0040b46d
  40acc0:	0040b201 	.word	0x0040b201
  40acc4:	0040b1ad 	.word	0x0040b1ad
  40acc8:	0040b211 	.word	0x0040b211
  40accc:	0040b221 	.word	0x0040b221
  40acd0:	400e0400 	.word	0x400e0400
  40acd4:	200e3f01 	.word	0x200e3f01
  40acd8:	0040b115 	.word	0x0040b115
  40acdc:	0040b385 	.word	0x0040b385

0040ace0 <board_init>:
 * \addtogroup sam4s_xplained_pro_group
 * @{
 */

void board_init(void)
{
  40ace0:	b538      	push	{r3, r4, r5, lr}
  40ace2:	200b      	movs	r0, #11
  40ace4:	4d13      	ldr	r5, [pc, #76]	; (40ad34 <board_init+0x54>)
// 	ioport_set_pin_level(IO1_LED3_PIN, !IO1_LED3_ACTIVE);
// 	ioport_set_pin_dir(IO1_LED3_PIN, IOPORT_DIR_OUTPUT);
	
	
	/* Configure HSMCI pins */
	gpio_configure_pin(PIN_HSMCI_MCCDA_GPIO, PIN_HSMCI_MCCDA_FLAGS);
  40ace6:	4c14      	ldr	r4, [pc, #80]	; (40ad38 <board_init+0x58>)
  40ace8:	47a8      	blx	r5
  40acea:	200c      	movs	r0, #12
  40acec:	47a8      	blx	r5
  40acee:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  40acf2:	201c      	movs	r0, #28
  40acf4:	47a0      	blx	r4
	gpio_configure_pin(PIN_HSMCI_MCCK_GPIO, PIN_HSMCI_MCCK_FLAGS);
  40acf6:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  40acfa:	201d      	movs	r0, #29
  40acfc:	47a0      	blx	r4
	gpio_configure_pin(PIN_HSMCI_MCDA0_GPIO, PIN_HSMCI_MCDA0_FLAGS);
  40acfe:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  40ad02:	201e      	movs	r0, #30
  40ad04:	47a0      	blx	r4
	gpio_configure_pin(PIN_HSMCI_MCDA1_GPIO, PIN_HSMCI_MCDA1_FLAGS);
  40ad06:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  40ad0a:	201f      	movs	r0, #31
  40ad0c:	47a0      	blx	r4
	gpio_configure_pin(PIN_HSMCI_MCDA2_GPIO, PIN_HSMCI_MCDA2_FLAGS);
  40ad0e:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  40ad12:	201a      	movs	r0, #26
  40ad14:	47a0      	blx	r4
	gpio_configure_pin(PIN_HSMCI_MCDA3_GPIO, PIN_HSMCI_MCDA3_FLAGS);
  40ad16:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  40ad1a:	201b      	movs	r0, #27
  40ad1c:	47a0      	blx	r4

	/* Configure SD/MMC card detect pin */
	gpio_configure_pin(SD_MMC_0_CD_GPIO, SD_MMC_0_CD_FLAGS);
  40ad1e:	4907      	ldr	r1, [pc, #28]	; (40ad3c <board_init+0x5c>)
  40ad20:	202b      	movs	r0, #43	; 0x2b
  40ad22:	47a0      	blx	r4

//#ifdef CONF_BOARD_UART_CONSOLE
	/* Configure UART pins */
	gpio_configure_group(PINS_UART1_PIO, PINS_UART1, PINS_UART1_FLAGS);
  40ad24:	4b06      	ldr	r3, [pc, #24]	; (40ad40 <board_init+0x60>)
  40ad26:	4807      	ldr	r0, [pc, #28]	; (40ad44 <board_init+0x64>)
  40ad28:	210c      	movs	r1, #12
  40ad2a:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
  40ad2e:	4798      	blx	r3
  40ad30:	bd38      	pop	{r3, r4, r5, pc}
  40ad32:	bf00      	nop
  40ad34:	0040b231 	.word	0x0040b231
  40ad38:	0040aebd 	.word	0x0040aebd
  40ad3c:	28000001 	.word	0x28000001
  40ad40:	0040af75 	.word	0x0040af75
  40ad44:	400e1000 	.word	0x400e1000

0040ad48 <pio_set_debounce_filter>:
	/*
	 * The debouncing filter can filter a pulse of less than 1/2 Period of a
	 * programmable Divided Slow Clock:
	 * Tdiv_slclk = ((DIV+1)*2).Tslow_clock
	 */
	p_pio->PIO_SCDR = PIO_SCDR_DIV((FREQ_SLOW_CLOCK_EXT /
  40ad48:	0052      	lsls	r2, r2, #1
  40ad4a:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  40ad4e:	fbb3 f2f2 	udiv	r2, r3, r2
  40ad52:	3a01      	subs	r2, #1
  40ad54:	f3c2 020d 	ubfx	r2, r2, #0, #14
void pio_set_debounce_filter(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_cut_off)
{
#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	/* Set Debouncing, 0 bit field no effect */
	p_pio->PIO_IFSCER = ul_mask;
  40ad58:	f8c0 1084 	str.w	r1, [r0, #132]	; 0x84
	/*
	 * The debouncing filter can filter a pulse of less than 1/2 Period of a
	 * programmable Divided Slow Clock:
	 * Tdiv_slclk = ((DIV+1)*2).Tslow_clock
	 */
	p_pio->PIO_SCDR = PIO_SCDR_DIV((FREQ_SLOW_CLOCK_EXT /
  40ad5c:	f8c0 208c 	str.w	r2, [r0, #140]	; 0x8c
  40ad60:	4770      	bx	lr
  40ad62:	bf00      	nop

0040ad64 <pio_set_peripheral>:

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	switch (ul_type) {
  40ad64:	f1b1 5fc0 	cmp.w	r1, #402653184	; 0x18000000
 * \param ul_type PIO type.
 * \param ul_mask Bitmask of one or more pin(s) to configure.
 */
void pio_set_peripheral(Pio *p_pio, const pio_type_t ul_type,
		const uint32_t ul_mask)
{
  40ad68:	b410      	push	{r4}
	uint32_t ul_sr;

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;
  40ad6a:	6442      	str	r2, [r0, #68]	; 0x44

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	switch (ul_type) {
  40ad6c:	d030      	beq.n	40add0 <pio_set_peripheral+0x6c>
  40ad6e:	d812      	bhi.n	40ad96 <pio_set_peripheral+0x32>
  40ad70:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
  40ad74:	d020      	beq.n	40adb8 <pio_set_peripheral+0x54>
  40ad76:	f1b1 5f80 	cmp.w	r1, #268435456	; 0x10000000
  40ad7a:	d11a      	bne.n	40adb2 <pio_set_peripheral+0x4e>

		ul_sr = p_pio->PIO_ABCDSR[1];
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
		break;
	case PIO_PERIPH_B:
		ul_sr = p_pio->PIO_ABCDSR[0];
  40ad7c:	6f03      	ldr	r3, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] = (ul_mask | ul_sr);
  40ad7e:	4313      	orrs	r3, r2
  40ad80:	6703      	str	r3, [r0, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  40ad82:	6f43      	ldr	r3, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  40ad84:	6f41      	ldr	r1, [r0, #116]	; 0x74
  40ad86:	400b      	ands	r3, r1
  40ad88:	ea23 0302 	bic.w	r3, r3, r2
  40ad8c:	6743      	str	r3, [r0, #116]	; 0x74
#else
#error "Unsupported device"
#endif

	/* Remove the pins from under the control of PIO */
	p_pio->PIO_PDR = ul_mask;
  40ad8e:	6042      	str	r2, [r0, #4]
}
  40ad90:	f85d 4b04 	ldr.w	r4, [sp], #4
  40ad94:	4770      	bx	lr

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	switch (ul_type) {
  40ad96:	f1b1 5f20 	cmp.w	r1, #671088640	; 0x28000000
  40ad9a:	d0f9      	beq.n	40ad90 <pio_set_peripheral+0x2c>
  40ad9c:	d822      	bhi.n	40ade4 <pio_set_peripheral+0x80>
  40ad9e:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
  40ada2:	d1f4      	bne.n	40ad8e <pio_set_peripheral+0x2a>

		ul_sr = p_pio->PIO_ABCDSR[1];
		p_pio->PIO_ABCDSR[1] = (ul_mask | ul_sr);
		break;
	case PIO_PERIPH_D:
		ul_sr = p_pio->PIO_ABCDSR[0];
  40ada4:	6f03      	ldr	r3, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] = (ul_mask | ul_sr);
  40ada6:	4313      	orrs	r3, r2
  40ada8:	6703      	str	r3, [r0, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  40adaa:	6f43      	ldr	r3, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] = (ul_mask | ul_sr);
  40adac:	4313      	orrs	r3, r2
  40adae:	6743      	str	r3, [r0, #116]	; 0x74
		break;
  40adb0:	e7ed      	b.n	40ad8e <pio_set_peripheral+0x2a>

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	switch (ul_type) {
  40adb2:	2900      	cmp	r1, #0
  40adb4:	d1eb      	bne.n	40ad8e <pio_set_peripheral+0x2a>
  40adb6:	e7eb      	b.n	40ad90 <pio_set_peripheral+0x2c>
	case PIO_PERIPH_A:
		ul_sr = p_pio->PIO_ABCDSR[0];
  40adb8:	6f01      	ldr	r1, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] &= (~ul_mask & ul_sr);
  40adba:	6f04      	ldr	r4, [r0, #112]	; 0x70
  40adbc:	43d3      	mvns	r3, r2
  40adbe:	4021      	ands	r1, r4
  40adc0:	4019      	ands	r1, r3
  40adc2:	6701      	str	r1, [r0, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  40adc4:	6f41      	ldr	r1, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  40adc6:	6f44      	ldr	r4, [r0, #116]	; 0x74
  40adc8:	4021      	ands	r1, r4
  40adca:	400b      	ands	r3, r1
  40adcc:	6743      	str	r3, [r0, #116]	; 0x74
		break;
  40adce:	e7de      	b.n	40ad8e <pio_set_peripheral+0x2a>
		ul_sr = p_pio->PIO_ABCDSR[1];
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
		break;
#if (!SAMG)
	case PIO_PERIPH_C:
		ul_sr = p_pio->PIO_ABCDSR[0];
  40add0:	6f03      	ldr	r3, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] &= (~ul_mask & ul_sr);
  40add2:	6f01      	ldr	r1, [r0, #112]	; 0x70
  40add4:	400b      	ands	r3, r1
  40add6:	ea23 0302 	bic.w	r3, r3, r2
  40adda:	6703      	str	r3, [r0, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  40addc:	6f43      	ldr	r3, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] = (ul_mask | ul_sr);
  40adde:	4313      	orrs	r3, r2
  40ade0:	6743      	str	r3, [r0, #116]	; 0x74
		break;
  40ade2:	e7d4      	b.n	40ad8e <pio_set_peripheral+0x2a>

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	switch (ul_type) {
  40ade4:	f1b1 5f40 	cmp.w	r1, #805306368	; 0x30000000
  40ade8:	d0d2      	beq.n	40ad90 <pio_set_peripheral+0x2c>
  40adea:	f1b1 5f60 	cmp.w	r1, #939524096	; 0x38000000
  40adee:	d0cf      	beq.n	40ad90 <pio_set_peripheral+0x2c>
  40adf0:	e7cd      	b.n	40ad8e <pio_set_peripheral+0x2a>
  40adf2:	bf00      	nop

0040adf4 <pio_set_input>:
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
  40adf4:	07d3      	lsls	r3, r2, #31
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_disable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
	p_pio->PIO_IDR = ul_mask;
  40adf6:	6441      	str	r1, [r0, #68]	; 0x44
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
		p_pio->PIO_PUER = ul_mask;
  40adf8:	bf4c      	ite	mi
  40adfa:	6641      	strmi	r1, [r0, #100]	; 0x64
	} else {
		p_pio->PIO_PUDR = ul_mask;
  40adfc:	6601      	strpl	r1, [r0, #96]	; 0x60
{
	pio_disable_interrupt(p_pio, ul_mask);
	pio_pull_up(p_pio, ul_mask, ul_attribute & PIO_PULLUP);

	/* Enable Input Filter if necessary */
	if (ul_attribute & (PIO_DEGLITCH | PIO_DEBOUNCE)) {
  40adfe:	f012 0f0a 	tst.w	r2, #10
		p_pio->PIO_IFER = ul_mask;
  40ae02:	bf14      	ite	ne
  40ae04:	6201      	strne	r1, [r0, #32]
	} else {
		p_pio->PIO_IFDR = ul_mask;
  40ae06:	6241      	streq	r1, [r0, #36]	; 0x24
	}

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	/* Enable de-glitch or de-bounce if necessary */
	if (ul_attribute & PIO_DEGLITCH) {
  40ae08:	0793      	lsls	r3, r2, #30
  40ae0a:	d406      	bmi.n	40ae1a <pio_set_input+0x26>
		p_pio->PIO_IFSCDR = ul_mask;
	} else {
		if (ul_attribute & PIO_DEBOUNCE) {
  40ae0c:	0713      	lsls	r3, r2, #28
			p_pio->PIO_IFSCER = ul_mask;
  40ae0e:	bf48      	it	mi
  40ae10:	f8c0 1084 	strmi.w	r1, [r0, #132]	; 0x84
#else
#error "Unsupported device"
#endif

	/* Configure pin as input */
	p_pio->PIO_ODR = ul_mask;
  40ae14:	6141      	str	r1, [r0, #20]
	p_pio->PIO_PER = ul_mask;
  40ae16:	6001      	str	r1, [r0, #0]
  40ae18:	4770      	bx	lr
	}

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	/* Enable de-glitch or de-bounce if necessary */
	if (ul_attribute & PIO_DEGLITCH) {
		p_pio->PIO_IFSCDR = ul_mask;
  40ae1a:	f8c0 1080 	str.w	r1, [r0, #128]	; 0x80
#else
#error "Unsupported device"
#endif

	/* Configure pin as input */
	p_pio->PIO_ODR = ul_mask;
  40ae1e:	6141      	str	r1, [r0, #20]
	p_pio->PIO_PER = ul_mask;
  40ae20:	6001      	str	r1, [r0, #0]
  40ae22:	4770      	bx	lr

0040ae24 <pio_configure_interrupt>:
 */
void pio_configure_interrupt(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_attr)
{
	/* Configure additional interrupt mode registers. */
	if (ul_attr & PIO_IT_AIME) {
  40ae24:	06d3      	lsls	r3, r2, #27
  40ae26:	d50e      	bpl.n	40ae46 <pio_configure_interrupt+0x22>
		/* Enable additional interrupt mode. */
		p_pio->PIO_AIMER = ul_mask;

		/* If bit field of the selected pin is 1, set as
		   Rising Edge/High level detection event. */
		if (ul_attr & PIO_IT_RE_OR_HL) {
  40ae28:	0693      	lsls	r3, r2, #26
		const uint32_t ul_attr)
{
	/* Configure additional interrupt mode registers. */
	if (ul_attr & PIO_IT_AIME) {
		/* Enable additional interrupt mode. */
		p_pio->PIO_AIMER = ul_mask;
  40ae2a:	f8c0 10b0 	str.w	r1, [r0, #176]	; 0xb0

		/* If bit field of the selected pin is 1, set as
		   Rising Edge/High level detection event. */
		if (ul_attr & PIO_IT_RE_OR_HL) {
			/* Rising Edge or High Level */
			p_pio->PIO_REHLSR = ul_mask;
  40ae2e:	bf4c      	ite	mi
  40ae30:	f8c0 10d4 	strmi.w	r1, [r0, #212]	; 0xd4
		} else {
			/* Falling Edge or Low Level */
			p_pio->PIO_FELLSR = ul_mask;
  40ae34:	f8c0 10d0 	strpl.w	r1, [r0, #208]	; 0xd0
		}

		/* If bit field of the selected pin is 1, set as
		   edge detection source. */
		if (ul_attr & PIO_IT_EDGE) {
  40ae38:	0653      	lsls	r3, r2, #25
			/* Edge select */
			p_pio->PIO_ESR = ul_mask;
  40ae3a:	bf4c      	ite	mi
  40ae3c:	f8c0 10c0 	strmi.w	r1, [r0, #192]	; 0xc0
		} else {
			/* Level select */
			p_pio->PIO_LSR = ul_mask;
  40ae40:	f8c0 10c4 	strpl.w	r1, [r0, #196]	; 0xc4
  40ae44:	4770      	bx	lr
		}
	} else {
		/* Disable additional interrupt mode. */
		p_pio->PIO_AIMDR = ul_mask;
  40ae46:	f8c0 10b4 	str.w	r1, [r0, #180]	; 0xb4
  40ae4a:	4770      	bx	lr

0040ae4c <pio_enable_interrupt>:
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_enable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
	p_pio->PIO_ISR;
  40ae4c:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
	p_pio->PIO_IER = ul_mask;
  40ae4e:	6401      	str	r1, [r0, #64]	; 0x40
  40ae50:	4770      	bx	lr
  40ae52:	bf00      	nop

0040ae54 <pio_disable_interrupt>:
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_disable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
	p_pio->PIO_IDR = ul_mask;
  40ae54:	6441      	str	r1, [r0, #68]	; 0x44
  40ae56:	4770      	bx	lr

0040ae58 <pio_get_interrupt_status>:
 *
 * \return The interrupt status mask value.
 */
uint32_t pio_get_interrupt_status(const Pio *p_pio)
{
	return p_pio->PIO_ISR;
  40ae58:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
}
  40ae5a:	4770      	bx	lr

0040ae5c <pio_get_interrupt_mask>:
 *
 * \return The interrupt mask value.
 */
uint32_t pio_get_interrupt_mask(const Pio *p_pio)
{
	return p_pio->PIO_IMR;
  40ae5c:	6c80      	ldr	r0, [r0, #72]	; 0x48
}
  40ae5e:	4770      	bx	lr

0040ae60 <pio_set_pin_high>:
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  40ae60:	0943      	lsrs	r3, r0, #5
  40ae62:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  40ae66:	f203 7307 	addw	r3, r3, #1799	; 0x707
  40ae6a:	025b      	lsls	r3, r3, #9
void pio_set_pin_high(uint32_t ul_pin)
{
	Pio *p_pio = pio_get_pin_group(ul_pin);

	/* Value to be driven on the I/O line: 1. */
	p_pio->PIO_SODR = 1 << (ul_pin & 0x1F);
  40ae6c:	f000 001f 	and.w	r0, r0, #31
  40ae70:	2201      	movs	r2, #1
  40ae72:	fa02 f000 	lsl.w	r0, r2, r0
  40ae76:	6318      	str	r0, [r3, #48]	; 0x30
  40ae78:	4770      	bx	lr
  40ae7a:	bf00      	nop

0040ae7c <pio_set_pin_low>:
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  40ae7c:	0943      	lsrs	r3, r0, #5
  40ae7e:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  40ae82:	f203 7307 	addw	r3, r3, #1799	; 0x707
  40ae86:	025b      	lsls	r3, r3, #9
void pio_set_pin_low(uint32_t ul_pin)
{
	Pio *p_pio = pio_get_pin_group(ul_pin);

	/* Value to be driven on the I/O line: 0. */
	p_pio->PIO_CODR = 1 << (ul_pin & 0x1F);
  40ae88:	f000 001f 	and.w	r0, r0, #31
  40ae8c:	2201      	movs	r2, #1
  40ae8e:	fa02 f000 	lsl.w	r0, r2, r0
  40ae92:	6358      	str	r0, [r3, #52]	; 0x34
  40ae94:	4770      	bx	lr
  40ae96:	bf00      	nop

0040ae98 <pio_toggle_pin>:
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  40ae98:	0943      	lsrs	r3, r0, #5
  40ae9a:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  40ae9e:	f203 7307 	addw	r3, r3, #1799	; 0x707
  40aea2:	025b      	lsls	r3, r3, #9
 */
void pio_toggle_pin(uint32_t ul_pin)
{
	Pio *p_pio = pio_get_pin_group(ul_pin);

	if (p_pio->PIO_ODSR & (1 << (ul_pin & 0x1F))) {
  40aea4:	f000 001f 	and.w	r0, r0, #31
  40aea8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  40aeaa:	2101      	movs	r1, #1
  40aeac:	fa01 f000 	lsl.w	r0, r1, r0
  40aeb0:	4210      	tst	r0, r2
		/* Value to be driven on the I/O line: 0. */
		p_pio->PIO_CODR = 1 << (ul_pin & 0x1F);
  40aeb2:	bf14      	ite	ne
  40aeb4:	6358      	strne	r0, [r3, #52]	; 0x34
	} else {
		/* Value to be driven on the I/O line: 1. */
		p_pio->PIO_SODR = 1 << (ul_pin & 0x1F);
  40aeb6:	6318      	streq	r0, [r3, #48]	; 0x30
  40aeb8:	4770      	bx	lr
  40aeba:	bf00      	nop

0040aebc <pio_configure_pin>:
 * \param ul_flags Pins attributes.
 *
 * \return Whether the pin(s) have been configured properly.
 */
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
  40aebc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  40aebe:	0944      	lsrs	r4, r0, #5
 * \param ul_flags Pins attributes.
 *
 * \return Whether the pin(s) have been configured properly.
 */
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
  40aec0:	460d      	mov	r5, r1
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  40aec2:	f504 1400 	add.w	r4, r4, #2097152	; 0x200000
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
	Pio *p_pio = pio_get_pin_group(ul_pin);

	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  40aec6:	f001 41f0 	and.w	r1, r1, #2013265920	; 0x78000000
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  40aeca:	f204 7407 	addw	r4, r4, #1799	; 0x707
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
	Pio *p_pio = pio_get_pin_group(ul_pin);

	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  40aece:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  40aed2:	ea4f 2444 	mov.w	r4, r4, lsl #9
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
	Pio *p_pio = pio_get_pin_group(ul_pin);

	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  40aed6:	d00b      	beq.n	40aef0 <pio_configure_pin+0x34>
  40aed8:	d819      	bhi.n	40af0e <pio_configure_pin+0x52>
  40aeda:	f1b1 5f80 	cmp.w	r1, #268435456	; 0x10000000
  40aede:	d007      	beq.n	40aef0 <pio_configure_pin+0x34>
  40aee0:	f1b1 5fc0 	cmp.w	r1, #402653184	; 0x18000000
  40aee4:	d004      	beq.n	40aef0 <pio_configure_pin+0x34>
  40aee6:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
  40aeea:	d001      	beq.n	40aef0 <pio_configure_pin+0x34>
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
				(ul_flags & PIO_PULLUP) ? 1 : 0);
		break;

	default:
		return 0;
  40aeec:	2000      	movs	r0, #0
	}

	return 1;
}
  40aeee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		pio_set_peripheral(p_pio, PIO_PERIPH_C, (1 << (ul_pin & 0x1F)));
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
				(ul_flags & PIO_PULLUP));
		break;
	case PIO_TYPE_PIO_PERIPH_D:
		pio_set_peripheral(p_pio, PIO_PERIPH_D, (1 << (ul_pin & 0x1F)));
  40aef0:	2601      	movs	r6, #1
  40aef2:	f000 001f 	and.w	r0, r0, #31
  40aef6:	fa06 f700 	lsl.w	r7, r6, r0
  40aefa:	463a      	mov	r2, r7
  40aefc:	4620      	mov	r0, r4
  40aefe:	4b1b      	ldr	r3, [pc, #108]	; (40af6c <pio_configure_pin+0xb0>)
  40af00:	4798      	blx	r3
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
  40af02:	07ed      	lsls	r5, r5, #31
		p_pio->PIO_PUER = ul_mask;
  40af04:	bf4c      	ite	mi
  40af06:	6667      	strmi	r7, [r4, #100]	; 0x64
	} else {
		p_pio->PIO_PUDR = ul_mask;
  40af08:	6627      	strpl	r7, [r4, #96]	; 0x60

	default:
		return 0;
	}

	return 1;
  40af0a:	4630      	mov	r0, r6
  40af0c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
	Pio *p_pio = pio_get_pin_group(ul_pin);

	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  40af0e:	f1b1 5f40 	cmp.w	r1, #805306368	; 0x30000000
  40af12:	d010      	beq.n	40af36 <pio_configure_pin+0x7a>
  40af14:	f1b1 5f60 	cmp.w	r1, #939524096	; 0x38000000
  40af18:	d00d      	beq.n	40af36 <pio_configure_pin+0x7a>
  40af1a:	f1b1 5f20 	cmp.w	r1, #671088640	; 0x28000000
  40af1e:	d1e5      	bne.n	40aeec <pio_configure_pin+0x30>
				(ul_flags & PIO_PULLUP));
		break;
//#endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, (1 << (ul_pin & 0x1F)), ul_flags);
  40af20:	2601      	movs	r6, #1
  40af22:	f000 011f 	and.w	r1, r0, #31
  40af26:	462a      	mov	r2, r5
  40af28:	4620      	mov	r0, r4
  40af2a:	fa06 f101 	lsl.w	r1, r6, r1
  40af2e:	4b10      	ldr	r3, [pc, #64]	; (40af70 <pio_configure_pin+0xb4>)
  40af30:	4798      	blx	r3

	default:
		return 0;
	}

	return 1;
  40af32:	4630      	mov	r0, r6
		break;
//#endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, (1 << (ul_pin & 0x1F)), ul_flags);
		break;
  40af34:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, (1 << (ul_pin & 0x1F)),
  40af36:	f000 001f 	and.w	r0, r0, #31
  40af3a:	2301      	movs	r3, #1
  40af3c:	4083      	lsls	r3, r0
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
				== PIO_TYPE_PIO_OUTPUT_1) ? 1 : 0,
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
  40af3e:	f005 0104 	and.w	r1, r5, #4
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
  40af42:	07e8      	lsls	r0, r5, #31
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_disable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
	p_pio->PIO_IDR = ul_mask;
  40af44:	6463      	str	r3, [r4, #68]	; 0x44
		break;

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, (1 << (ul_pin & 0x1F)),
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
  40af46:	f005 5260 	and.w	r2, r5, #939524096	; 0x38000000
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
		p_pio->PIO_PUER = ul_mask;
  40af4a:	bf4c      	ite	mi
  40af4c:	6663      	strmi	r3, [r4, #100]	; 0x64
	} else {
		p_pio->PIO_PUDR = ul_mask;
  40af4e:	6623      	strpl	r3, [r4, #96]	; 0x60
{
	pio_disable_interrupt(p_pio, ul_mask);
	pio_pull_up(p_pio, ul_mask, ul_pull_up_enable);

	/* Enable multi-drive if necessary */
	if (ul_multidrive_enable) {
  40af50:	b149      	cbz	r1, 40af66 <pio_configure_pin+0xaa>
		p_pio->PIO_MDER = ul_mask;
  40af52:	6523      	str	r3, [r4, #80]	; 0x50
	} else {
		p_pio->PIO_MDDR = ul_mask;
	}

	/* Set default value */
	if (ul_default_level) {
  40af54:	f1b2 5f60 	cmp.w	r2, #939524096	; 0x38000000
		p_pio->PIO_SODR = ul_mask;
  40af58:	bf0c      	ite	eq
  40af5a:	6323      	streq	r3, [r4, #48]	; 0x30
	} else {
		p_pio->PIO_CODR = ul_mask;
  40af5c:	6363      	strne	r3, [r4, #52]	; 0x34
	}

	/* Configure pin(s) as output(s) */
	p_pio->PIO_OER = ul_mask;
  40af5e:	6123      	str	r3, [r4, #16]
	p_pio->PIO_PER = ul_mask;
  40af60:	6023      	str	r3, [r4, #0]

	default:
		return 0;
	}

	return 1;
  40af62:	2001      	movs	r0, #1
  40af64:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	/* Enable multi-drive if necessary */
	if (ul_multidrive_enable) {
		p_pio->PIO_MDER = ul_mask;
	} else {
		p_pio->PIO_MDDR = ul_mask;
  40af66:	6563      	str	r3, [r4, #84]	; 0x54
  40af68:	e7f4      	b.n	40af54 <pio_configure_pin+0x98>
  40af6a:	bf00      	nop
  40af6c:	0040ad65 	.word	0x0040ad65
  40af70:	0040adf5 	.word	0x0040adf5

0040af74 <pio_configure_pin_group>:
 */
uint32_t pio_configure_pin_group(Pio *p_pio,
		uint32_t ul_mask, const uint32_t ul_flags)
{
	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  40af74:	f002 43f0 	and.w	r3, r2, #2013265920	; 0x78000000
  40af78:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 *
 * \return Whether the pin(s) have been configured properly.
 */
uint32_t pio_configure_pin_group(Pio *p_pio,
		uint32_t ul_mask, const uint32_t ul_flags)
{
  40af7c:	b570      	push	{r4, r5, r6, lr}
  40af7e:	4614      	mov	r4, r2
  40af80:	4606      	mov	r6, r0
  40af82:	460d      	mov	r5, r1
	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  40af84:	d00b      	beq.n	40af9e <pio_configure_pin_group+0x2a>
  40af86:	d814      	bhi.n	40afb2 <pio_configure_pin_group+0x3e>
  40af88:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
  40af8c:	d007      	beq.n	40af9e <pio_configure_pin_group+0x2a>
  40af8e:	f1b3 5fc0 	cmp.w	r3, #402653184	; 0x18000000
  40af92:	d004      	beq.n	40af9e <pio_configure_pin_group+0x2a>
  40af94:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
  40af98:	d001      	beq.n	40af9e <pio_configure_pin_group+0x2a>
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
				(ul_flags & PIO_PULLUP) ? 1 : 0);
		break;

	default:
		return 0;
  40af9a:	2000      	movs	r0, #0
	}

	return 1;
}
  40af9c:	bd70      	pop	{r4, r5, r6, pc}
	case PIO_TYPE_PIO_PERIPH_C:
		pio_set_peripheral(p_pio, PIO_PERIPH_C, ul_mask);
		pio_pull_up(p_pio, ul_mask, (ul_flags & PIO_PULLUP));
		break;
	case PIO_TYPE_PIO_PERIPH_D:
		pio_set_peripheral(p_pio, PIO_PERIPH_D, ul_mask);
  40af9e:	4619      	mov	r1, r3
  40afa0:	462a      	mov	r2, r5
  40afa2:	4b15      	ldr	r3, [pc, #84]	; (40aff8 <pio_configure_pin_group+0x84>)
  40afa4:	4798      	blx	r3
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
  40afa6:	07e0      	lsls	r0, r4, #31
		p_pio->PIO_PUER = ul_mask;
  40afa8:	bf4c      	ite	mi
  40afaa:	6675      	strmi	r5, [r6, #100]	; 0x64
	} else {
		p_pio->PIO_PUDR = ul_mask;
  40afac:	6635      	strpl	r5, [r6, #96]	; 0x60

	default:
		return 0;
	}

	return 1;
  40afae:	2001      	movs	r0, #1
  40afb0:	bd70      	pop	{r4, r5, r6, pc}
 */
uint32_t pio_configure_pin_group(Pio *p_pio,
		uint32_t ul_mask, const uint32_t ul_flags)
{
	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  40afb2:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
  40afb6:	d009      	beq.n	40afcc <pio_configure_pin_group+0x58>
  40afb8:	f1b3 5f60 	cmp.w	r3, #939524096	; 0x38000000
  40afbc:	d006      	beq.n	40afcc <pio_configure_pin_group+0x58>
  40afbe:	f1b3 5f20 	cmp.w	r3, #671088640	; 0x28000000
  40afc2:	d1ea      	bne.n	40af9a <pio_configure_pin_group+0x26>
		pio_pull_up(p_pio, ul_mask, (ul_flags & PIO_PULLUP));
		break;
#endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, ul_mask, ul_flags);
  40afc4:	4b0d      	ldr	r3, [pc, #52]	; (40affc <pio_configure_pin_group+0x88>)
  40afc6:	4798      	blx	r3

	default:
		return 0;
	}

	return 1;
  40afc8:	2001      	movs	r0, #1
		break;
#endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, ul_mask, ul_flags);
		break;
  40afca:	bd70      	pop	{r4, r5, r6, pc}
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
  40afcc:	07e1      	lsls	r1, r4, #31
	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, ul_mask,
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
				== PIO_TYPE_PIO_OUTPUT_1) ? 1 : 0,
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
  40afce:	f004 0204 	and.w	r2, r4, #4
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_disable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
	p_pio->PIO_IDR = ul_mask;
  40afd2:	6475      	str	r5, [r6, #68]	; 0x44
		break;

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, ul_mask,
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
  40afd4:	f004 5360 	and.w	r3, r4, #939524096	; 0x38000000
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
		p_pio->PIO_PUER = ul_mask;
  40afd8:	bf4c      	ite	mi
  40afda:	6675      	strmi	r5, [r6, #100]	; 0x64
	} else {
		p_pio->PIO_PUDR = ul_mask;
  40afdc:	6635      	strpl	r5, [r6, #96]	; 0x60
{
	pio_disable_interrupt(p_pio, ul_mask);
	pio_pull_up(p_pio, ul_mask, ul_pull_up_enable);

	/* Enable multi-drive if necessary */
	if (ul_multidrive_enable) {
  40afde:	b14a      	cbz	r2, 40aff4 <pio_configure_pin_group+0x80>
		p_pio->PIO_MDER = ul_mask;
  40afe0:	6535      	str	r5, [r6, #80]	; 0x50
	} else {
		p_pio->PIO_MDDR = ul_mask;
	}

	/* Set default value */
	if (ul_default_level) {
  40afe2:	f1b3 5f60 	cmp.w	r3, #939524096	; 0x38000000
		p_pio->PIO_SODR = ul_mask;
  40afe6:	bf0c      	ite	eq
  40afe8:	6335      	streq	r5, [r6, #48]	; 0x30
	} else {
		p_pio->PIO_CODR = ul_mask;
  40afea:	6375      	strne	r5, [r6, #52]	; 0x34
	}

	/* Configure pin(s) as output(s) */
	p_pio->PIO_OER = ul_mask;
  40afec:	6135      	str	r5, [r6, #16]
	p_pio->PIO_PER = ul_mask;
  40afee:	6035      	str	r5, [r6, #0]

	default:
		return 0;
	}

	return 1;
  40aff0:	2001      	movs	r0, #1
  40aff2:	bd70      	pop	{r4, r5, r6, pc}

	/* Enable multi-drive if necessary */
	if (ul_multidrive_enable) {
		p_pio->PIO_MDER = ul_mask;
	} else {
		p_pio->PIO_MDDR = ul_mask;
  40aff4:	6575      	str	r5, [r6, #84]	; 0x54
  40aff6:	e7f4      	b.n	40afe2 <pio_configure_pin_group+0x6e>
  40aff8:	0040ad65 	.word	0x0040ad65
  40affc:	0040adf5 	.word	0x0040adf5

0040b000 <pio_get_pin_group>:
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  40b000:	0940      	lsrs	r0, r0, #5
  40b002:	f500 1000 	add.w	r0, r0, #2097152	; 0x200000
  40b006:	f200 7007 	addw	r0, r0, #1799	; 0x707
#endif
	return p_pio;
}
  40b00a:	0240      	lsls	r0, r0, #9
  40b00c:	4770      	bx	lr
  40b00e:	bf00      	nop

0040b010 <pio_get_pin_group_id>:
		ul_id = ID_PIOC;
	} else {
		ul_id = ID_PIOA + (ul_pin >> 5);
	}
#else
	ul_id = ID_PIOA + (ul_pin >> 5);
  40b010:	0940      	lsrs	r0, r0, #5
#endif
	return ul_id;
}
  40b012:	300b      	adds	r0, #11
  40b014:	4770      	bx	lr
  40b016:	bf00      	nop

0040b018 <pio_get_pin_group_mask>:
 *
 * \return GPIO port pin mask.
 */
uint32_t pio_get_pin_group_mask(uint32_t ul_pin)
{
	uint32_t ul_mask = 1 << (ul_pin & 0x1F);
  40b018:	2301      	movs	r3, #1
  40b01a:	f000 001f 	and.w	r0, r0, #31
	return ul_mask;
}
  40b01e:	fa03 f000 	lsl.w	r0, r3, r0
  40b022:	4770      	bx	lr

0040b024 <pio_handler_process>:
 *
 * \param p_pio PIO controller base address.
 * \param ul_id PIO controller ID.
 */
void pio_handler_process(Pio *p_pio, uint32_t ul_id)
{
  40b024:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint32_t status;
	uint32_t i;

	/* Read PIO controller status */
	status = pio_get_interrupt_status(p_pio);
  40b028:	4b17      	ldr	r3, [pc, #92]	; (40b088 <pio_handler_process+0x64>)
 *
 * \param p_pio PIO controller base address.
 * \param ul_id PIO controller ID.
 */
void pio_handler_process(Pio *p_pio, uint32_t ul_id)
{
  40b02a:	4680      	mov	r8, r0
  40b02c:	460e      	mov	r6, r1
	uint32_t status;
	uint32_t i;

	/* Read PIO controller status */
	status = pio_get_interrupt_status(p_pio);
  40b02e:	4798      	blx	r3
	status &= pio_get_interrupt_mask(p_pio);
  40b030:	4b16      	ldr	r3, [pc, #88]	; (40b08c <pio_handler_process+0x68>)
{
	uint32_t status;
	uint32_t i;

	/* Read PIO controller status */
	status = pio_get_interrupt_status(p_pio);
  40b032:	4605      	mov	r5, r0
	status &= pio_get_interrupt_mask(p_pio);
  40b034:	4640      	mov	r0, r8
  40b036:	4798      	blx	r3

	/* Check pending events */
	if (status != 0) {
  40b038:	4005      	ands	r5, r0
  40b03a:	d018      	beq.n	40b06e <pio_handler_process+0x4a>
  40b03c:	4c14      	ldr	r4, [pc, #80]	; (40b090 <pio_handler_process+0x6c>)
  40b03e:	f104 07b0 	add.w	r7, r4, #176	; 0xb0
  40b042:	e003      	b.n	40b04c <pio_handler_process+0x28>
							gs_interrupt_sources[i].mask);
					status &= ~(gs_interrupt_sources[i].mask);
				}
			}
			i++;
			if (i >= MAX_INTERRUPT_SOURCES) {
  40b044:	42bc      	cmp	r4, r7
  40b046:	d012      	beq.n	40b06e <pio_handler_process+0x4a>
  40b048:	3410      	adds	r4, #16

	/* Check pending events */
	if (status != 0) {
		/* Find triggering source */
		i = 0;
		while (status != 0) {
  40b04a:	b185      	cbz	r5, 40b06e <pio_handler_process+0x4a>
			/* Source is configured on the same controller */
			if (gs_interrupt_sources[i].id == ul_id) {
  40b04c:	f854 3c0c 	ldr.w	r3, [r4, #-12]
  40b050:	42b3      	cmp	r3, r6
  40b052:	d1f7      	bne.n	40b044 <pio_handler_process+0x20>
				/* Source has PIOs whose statuses have changed */
				if ((status & gs_interrupt_sources[i].mask) != 0) {
  40b054:	f854 1c08 	ldr.w	r1, [r4, #-8]
  40b058:	4229      	tst	r1, r5
  40b05a:	d0f3      	beq.n	40b044 <pio_handler_process+0x20>
					gs_interrupt_sources[i].handler(gs_interrupt_sources[i].id,
  40b05c:	6823      	ldr	r3, [r4, #0]
  40b05e:	4630      	mov	r0, r6
  40b060:	4798      	blx	r3
							gs_interrupt_sources[i].mask);
					status &= ~(gs_interrupt_sources[i].mask);
  40b062:	f854 3c08 	ldr.w	r3, [r4, #-8]
				}
			}
			i++;
			if (i >= MAX_INTERRUPT_SOURCES) {
  40b066:	42bc      	cmp	r4, r7
			if (gs_interrupt_sources[i].id == ul_id) {
				/* Source has PIOs whose statuses have changed */
				if ((status & gs_interrupt_sources[i].mask) != 0) {
					gs_interrupt_sources[i].handler(gs_interrupt_sources[i].id,
							gs_interrupt_sources[i].mask);
					status &= ~(gs_interrupt_sources[i].mask);
  40b068:	ea25 0503 	bic.w	r5, r5, r3
				}
			}
			i++;
			if (i >= MAX_INTERRUPT_SOURCES) {
  40b06c:	d1ec      	bne.n	40b048 <pio_handler_process+0x24>
		}
	}

	/* Check capture events */
#if (SAM3S || SAM4S || SAM4E)
	if (pio_capture_enable_flag) {
  40b06e:	4b09      	ldr	r3, [pc, #36]	; (40b094 <pio_handler_process+0x70>)
  40b070:	681b      	ldr	r3, [r3, #0]
  40b072:	b133      	cbz	r3, 40b082 <pio_handler_process+0x5e>
		if (pio_capture_handler) {
  40b074:	4b08      	ldr	r3, [pc, #32]	; (40b098 <pio_handler_process+0x74>)
  40b076:	681b      	ldr	r3, [r3, #0]
  40b078:	b10b      	cbz	r3, 40b07e <pio_handler_process+0x5a>
			pio_capture_handler(p_pio);
  40b07a:	4640      	mov	r0, r8
  40b07c:	4798      	blx	r3
  40b07e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40b082:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40b086:	bf00      	nop
  40b088:	0040ae59 	.word	0x0040ae59
  40b08c:	0040ae5d 	.word	0x0040ae5d
  40b090:	200038b8 	.word	0x200038b8
  40b094:	20005038 	.word	0x20005038
  40b098:	200038a8 	.word	0x200038a8

0040b09c <pio_handler_set>:
 *
 * \return 0 if successful, 1 if the maximum number of sources has been defined.
 */
uint32_t pio_handler_set(Pio *p_pio, uint32_t ul_id, uint32_t ul_mask,
		uint32_t ul_attr, void (*p_handler) (uint32_t, uint32_t))
{
  40b09c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	struct s_interrupt_source *pSource;

	if (gs_ul_nb_sources >= MAX_INTERRUPT_SOURCES)
  40b0a0:	4d0f      	ldr	r5, [pc, #60]	; (40b0e0 <pio_handler_set+0x44>)
  40b0a2:	682c      	ldr	r4, [r5, #0]
  40b0a4:	2c0b      	cmp	r4, #11
 *
 * \return 0 if successful, 1 if the maximum number of sources has been defined.
 */
uint32_t pio_handler_set(Pio *p_pio, uint32_t ul_id, uint32_t ul_mask,
		uint32_t ul_attr, void (*p_handler) (uint32_t, uint32_t))
{
  40b0a6:	468c      	mov	ip, r1
  40b0a8:	4616      	mov	r6, r2
	struct s_interrupt_source *pSource;

	if (gs_ul_nb_sources >= MAX_INTERRUPT_SOURCES)
  40b0aa:	d902      	bls.n	40b0b2 <pio_handler_set+0x16>
		return 1;
  40b0ac:	2001      	movs	r0, #1

	/* Configure interrupt mode */
	pio_configure_interrupt(p_pio, ul_mask, ul_attr);

	return 0;
}
  40b0ae:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

	if (gs_ul_nb_sources >= MAX_INTERRUPT_SOURCES)
		return 1;

	/* Define new source */
	pSource = &(gs_interrupt_sources[gs_ul_nb_sources]);
  40b0b2:	f8df 8030 	ldr.w	r8, [pc, #48]	; 40b0e4 <pio_handler_set+0x48>
	pSource->attr = ul_attr;
	pSource->handler = p_handler;
	gs_ul_nb_sources++;

	/* Configure interrupt mode */
	pio_configure_interrupt(p_pio, ul_mask, ul_attr);
  40b0b6:	f8df 9030 	ldr.w	r9, [pc, #48]	; 40b0e8 <pio_handler_set+0x4c>

	if (gs_ul_nb_sources >= MAX_INTERRUPT_SOURCES)
		return 1;

	/* Define new source */
	pSource = &(gs_interrupt_sources[gs_ul_nb_sources]);
  40b0ba:	ea4f 1e04 	mov.w	lr, r4, lsl #4
  40b0be:	eb08 070e 	add.w	r7, r8, lr
	pSource->id = ul_id;
  40b0c2:	f848 c00e 	str.w	ip, [r8, lr]
	pSource->attr = ul_attr;
	pSource->handler = p_handler;
	gs_ul_nb_sources++;

	/* Configure interrupt mode */
	pio_configure_interrupt(p_pio, ul_mask, ul_attr);
  40b0c6:	4611      	mov	r1, r2

	/* Define new source */
	pSource = &(gs_interrupt_sources[gs_ul_nb_sources]);
	pSource->id = ul_id;
	pSource->mask = ul_mask;
	pSource->attr = ul_attr;
  40b0c8:	60bb      	str	r3, [r7, #8]
	pSource->handler = p_handler;
	gs_ul_nb_sources++;

	/* Configure interrupt mode */
	pio_configure_interrupt(p_pio, ul_mask, ul_attr);
  40b0ca:	461a      	mov	r2, r3
	/* Define new source */
	pSource = &(gs_interrupt_sources[gs_ul_nb_sources]);
	pSource->id = ul_id;
	pSource->mask = ul_mask;
	pSource->attr = ul_attr;
	pSource->handler = p_handler;
  40b0cc:	9b08      	ldr	r3, [sp, #32]
		return 1;

	/* Define new source */
	pSource = &(gs_interrupt_sources[gs_ul_nb_sources]);
	pSource->id = ul_id;
	pSource->mask = ul_mask;
  40b0ce:	607e      	str	r6, [r7, #4]
	pSource->attr = ul_attr;
	pSource->handler = p_handler;
	gs_ul_nb_sources++;
  40b0d0:	3401      	adds	r4, #1
	/* Define new source */
	pSource = &(gs_interrupt_sources[gs_ul_nb_sources]);
	pSource->id = ul_id;
	pSource->mask = ul_mask;
	pSource->attr = ul_attr;
	pSource->handler = p_handler;
  40b0d2:	60fb      	str	r3, [r7, #12]
	gs_ul_nb_sources++;
  40b0d4:	602c      	str	r4, [r5, #0]

	/* Configure interrupt mode */
	pio_configure_interrupt(p_pio, ul_mask, ul_attr);
  40b0d6:	47c8      	blx	r9

	return 0;
  40b0d8:	2000      	movs	r0, #0
  40b0da:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  40b0de:	bf00      	nop
  40b0e0:	200038a4 	.word	0x200038a4
  40b0e4:	200038ac 	.word	0x200038ac
  40b0e8:	0040ae25 	.word	0x0040ae25

0040b0ec <PIOA_Handler>:
/**
 * \brief Parallel IO Controller A interrupt handler.
 * Redefined PIOA interrupt handler for NVIC interrupt table.
 */
void PIOA_Handler(void)
{
  40b0ec:	b508      	push	{r3, lr}
	pio_handler_process(PIOA, ID_PIOA);
  40b0ee:	4802      	ldr	r0, [pc, #8]	; (40b0f8 <PIOA_Handler+0xc>)
  40b0f0:	4b02      	ldr	r3, [pc, #8]	; (40b0fc <PIOA_Handler+0x10>)
  40b0f2:	210b      	movs	r1, #11
  40b0f4:	4798      	blx	r3
  40b0f6:	bd08      	pop	{r3, pc}
  40b0f8:	400e0e00 	.word	0x400e0e00
  40b0fc:	0040b025 	.word	0x0040b025

0040b100 <PIOB_Handler>:
/**
 * \brief Parallel IO Controller B interrupt handler
 * Redefined PIOB interrupt handler for NVIC interrupt table.
 */
void PIOB_Handler(void)
{
  40b100:	b508      	push	{r3, lr}
    pio_handler_process(PIOB, ID_PIOB);
  40b102:	4802      	ldr	r0, [pc, #8]	; (40b10c <PIOB_Handler+0xc>)
  40b104:	4b02      	ldr	r3, [pc, #8]	; (40b110 <PIOB_Handler+0x10>)
  40b106:	210c      	movs	r1, #12
  40b108:	4798      	blx	r3
  40b10a:	bd08      	pop	{r3, pc}
  40b10c:	400e1000 	.word	0x400e1000
  40b110:	0040b025 	.word	0x0040b025

0040b114 <pmc_switch_mck_to_pllack>:
 */
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
  40b114:	4914      	ldr	r1, [pc, #80]	; (40b168 <pmc_switch_mck_to_pllack+0x54>)
  40b116:	6b0b      	ldr	r3, [r1, #48]	; 0x30
  40b118:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  40b11c:	4318      	orrs	r0, r3
  40b11e:	6308      	str	r0, [r1, #48]	; 0x30
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  40b120:	6e8b      	ldr	r3, [r1, #104]	; 0x68
  40b122:	071b      	lsls	r3, r3, #28
  40b124:	d407      	bmi.n	40b136 <pmc_switch_mck_to_pllack+0x22>
  40b126:	f44f 6300 	mov.w	r3, #2048	; 0x800
  40b12a:	e001      	b.n	40b130 <pmc_switch_mck_to_pllack+0x1c>
			--ul_timeout) {
		if (ul_timeout == 0) {
  40b12c:	3b01      	subs	r3, #1
  40b12e:	d016      	beq.n	40b15e <pmc_switch_mck_to_pllack+0x4a>
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  40b130:	6e8a      	ldr	r2, [r1, #104]	; 0x68
  40b132:	0710      	lsls	r0, r2, #28
  40b134:	d5fa      	bpl.n	40b12c <pmc_switch_mck_to_pllack+0x18>
		if (ul_timeout == 0) {
			return 1;
		}
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
  40b136:	490c      	ldr	r1, [pc, #48]	; (40b168 <pmc_switch_mck_to_pllack+0x54>)
  40b138:	6b0b      	ldr	r3, [r1, #48]	; 0x30
  40b13a:	f023 0303 	bic.w	r3, r3, #3
  40b13e:	f043 0302 	orr.w	r3, r3, #2
  40b142:	630b      	str	r3, [r1, #48]	; 0x30
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  40b144:	6e88      	ldr	r0, [r1, #104]	; 0x68
  40b146:	f010 0008 	ands.w	r0, r0, #8
  40b14a:	d10a      	bne.n	40b162 <pmc_switch_mck_to_pllack+0x4e>
  40b14c:	f44f 6300 	mov.w	r3, #2048	; 0x800
  40b150:	e001      	b.n	40b156 <pmc_switch_mck_to_pllack+0x42>
			--ul_timeout) {
		if (ul_timeout == 0) {
  40b152:	3b01      	subs	r3, #1
  40b154:	d003      	beq.n	40b15e <pmc_switch_mck_to_pllack+0x4a>
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  40b156:	6e8a      	ldr	r2, [r1, #104]	; 0x68
  40b158:	0712      	lsls	r2, r2, #28
  40b15a:	d5fa      	bpl.n	40b152 <pmc_switch_mck_to_pllack+0x3e>
  40b15c:	4770      	bx	lr

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
			--ul_timeout) {
		if (ul_timeout == 0) {
			return 1;
  40b15e:	2001      	movs	r0, #1
  40b160:	4770      	bx	lr
		if (ul_timeout == 0) {
			return 1;
		}
	}

	return 0;
  40b162:	2000      	movs	r0, #0
}
  40b164:	4770      	bx	lr
  40b166:	bf00      	nop
  40b168:	400e0400 	.word	0x400e0400

0040b16c <pmc_switch_sclk_to_32kxtal>:
 * \param ul_bypass 0 for Xtal, 1 for bypass.
 */
void pmc_switch_sclk_to_32kxtal(uint32_t ul_bypass)
{
	/* Set Bypass mode if required */
	if (ul_bypass == 1) {
  40b16c:	2801      	cmp	r0, #1
  40b16e:	d106      	bne.n	40b17e <pmc_switch_sclk_to_32kxtal+0x12>
		SUPC->SUPC_MR |= SUPC_MR_KEY_PASSWD |
  40b170:	4a05      	ldr	r2, [pc, #20]	; (40b188 <pmc_switch_sclk_to_32kxtal+0x1c>)
  40b172:	6893      	ldr	r3, [r2, #8]
  40b174:	f043 4325 	orr.w	r3, r3, #2768240640	; 0xa5000000
  40b178:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  40b17c:	6093      	str	r3, [r2, #8]
			SUPC_MR_OSCBYPASS;
	}

	SUPC->SUPC_CR = SUPC_CR_KEY_PASSWD | SUPC_CR_XTALSEL;
  40b17e:	4b02      	ldr	r3, [pc, #8]	; (40b188 <pmc_switch_sclk_to_32kxtal+0x1c>)
  40b180:	4a02      	ldr	r2, [pc, #8]	; (40b18c <pmc_switch_sclk_to_32kxtal+0x20>)
  40b182:	601a      	str	r2, [r3, #0]
  40b184:	4770      	bx	lr
  40b186:	bf00      	nop
  40b188:	400e1410 	.word	0x400e1410
  40b18c:	a5000008 	.word	0xa5000008

0040b190 <pmc_osc_is_ready_32kxtal>:
 * \retval 1 External 32k Xtal is ready.
 * \retval 0 External 32k Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_32kxtal(void)
{
	return ((SUPC->SUPC_SR & SUPC_SR_OSCSEL)
  40b190:	4b05      	ldr	r3, [pc, #20]	; (40b1a8 <pmc_osc_is_ready_32kxtal+0x18>)
  40b192:	6958      	ldr	r0, [r3, #20]
			&& (PMC->PMC_SR & PMC_SR_OSCSELS));
  40b194:	f010 0080 	ands.w	r0, r0, #128	; 0x80
  40b198:	d005      	beq.n	40b1a6 <pmc_osc_is_ready_32kxtal+0x16>
  40b19a:	f5a3 5380 	sub.w	r3, r3, #4096	; 0x1000
  40b19e:	3b10      	subs	r3, #16
  40b1a0:	6e98      	ldr	r0, [r3, #104]	; 0x68
  40b1a2:	f3c0 10c0 	ubfx	r0, r0, #7, #1
}
  40b1a6:	4770      	bx	lr
  40b1a8:	400e1410 	.word	0x400e1410

0040b1ac <pmc_switch_mainck_to_xtal>:
 */
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass,
		uint32_t ul_xtal_startup_time)
{
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
  40b1ac:	b9c8      	cbnz	r0, 40b1e2 <pmc_switch_mainck_to_xtal+0x36>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  40b1ae:	4b11      	ldr	r3, [pc, #68]	; (40b1f4 <pmc_switch_mainck_to_xtal+0x48>)
  40b1b0:	6a1a      	ldr	r2, [r3, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
  40b1b2:	f422 125c 	bic.w	r2, r2, #3604480	; 0x370000
  40b1b6:	f022 0203 	bic.w	r2, r2, #3
				CKGR_MOR_MOSCXTST(ul_xtal_startup_time);
  40b1ba:	0209      	lsls	r1, r1, #8
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
  40b1bc:	f442 125c 	orr.w	r2, r2, #3604480	; 0x370000
				CKGR_MOR_MOSCXTST(ul_xtal_startup_time);
  40b1c0:	b289      	uxth	r1, r1
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
  40b1c2:	f042 0201 	orr.w	r2, r2, #1
  40b1c6:	430a      	orrs	r2, r1
	if (ul_bypass) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  40b1c8:	621a      	str	r2, [r3, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
				CKGR_MOR_MOSCXTST(ul_xtal_startup_time);
		/* Wait the Xtal to stabilize */
		while (!(PMC->PMC_SR & PMC_SR_MOSCXTS));
  40b1ca:	4619      	mov	r1, r3
  40b1cc:	6e8b      	ldr	r3, [r1, #104]	; 0x68
  40b1ce:	4a09      	ldr	r2, [pc, #36]	; (40b1f4 <pmc_switch_mainck_to_xtal+0x48>)
  40b1d0:	07db      	lsls	r3, r3, #31
  40b1d2:	d5fb      	bpl.n	40b1cc <pmc_switch_mainck_to_xtal+0x20>

		PMC->CKGR_MOR |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCSEL;
  40b1d4:	6a13      	ldr	r3, [r2, #32]
  40b1d6:	f043 739b 	orr.w	r3, r3, #20316160	; 0x1360000
  40b1da:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  40b1de:	6213      	str	r3, [r2, #32]
  40b1e0:	4770      	bx	lr
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass,
		uint32_t ul_xtal_startup_time)
{
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  40b1e2:	4904      	ldr	r1, [pc, #16]	; (40b1f4 <pmc_switch_mainck_to_xtal+0x48>)
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
  40b1e4:	4a04      	ldr	r2, [pc, #16]	; (40b1f8 <pmc_switch_mainck_to_xtal+0x4c>)
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass,
		uint32_t ul_xtal_startup_time)
{
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  40b1e6:	6a08      	ldr	r0, [r1, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
  40b1e8:	4b04      	ldr	r3, [pc, #16]	; (40b1fc <pmc_switch_mainck_to_xtal+0x50>)
  40b1ea:	4002      	ands	r2, r0
  40b1ec:	4313      	orrs	r3, r2
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass,
		uint32_t ul_xtal_startup_time)
{
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  40b1ee:	620b      	str	r3, [r1, #32]
  40b1f0:	4770      	bx	lr
  40b1f2:	bf00      	nop
  40b1f4:	400e0400 	.word	0x400e0400
  40b1f8:	fec8fffc 	.word	0xfec8fffc
  40b1fc:	01370002 	.word	0x01370002

0040b200 <pmc_osc_is_ready_mainck>:
 * \retval 1 Xtal is ready.
 * \retval 0 Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_mainck(void)
{
	return PMC->PMC_SR & PMC_SR_MOSCSELS;
  40b200:	4b02      	ldr	r3, [pc, #8]	; (40b20c <pmc_osc_is_ready_mainck+0xc>)
  40b202:	6e98      	ldr	r0, [r3, #104]	; 0x68
}
  40b204:	f400 3080 	and.w	r0, r0, #65536	; 0x10000
  40b208:	4770      	bx	lr
  40b20a:	bf00      	nop
  40b20c:	400e0400 	.word	0x400e0400

0040b210 <pmc_disable_pllack>:
void pmc_disable_pllack(void)
{
#if (SAM4C || SAM4CM || SAM4CP || SAMG)
	PMC->CKGR_PLLAR = CKGR_PLLAR_MULA(0);
#else
	PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | CKGR_PLLAR_MULA(0);
  40b210:	4b02      	ldr	r3, [pc, #8]	; (40b21c <pmc_disable_pllack+0xc>)
  40b212:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
  40b216:	629a      	str	r2, [r3, #40]	; 0x28
  40b218:	4770      	bx	lr
  40b21a:	bf00      	nop
  40b21c:	400e0400 	.word	0x400e0400

0040b220 <pmc_is_locked_pllack>:
 * \retval 0 Not locked.
 * \retval 1 Locked.
 */
uint32_t pmc_is_locked_pllack(void)
{
	return (PMC->PMC_SR & PMC_SR_LOCKA);
  40b220:	4b02      	ldr	r3, [pc, #8]	; (40b22c <pmc_is_locked_pllack+0xc>)
  40b222:	6e98      	ldr	r0, [r3, #104]	; 0x68
}
  40b224:	f000 0002 	and.w	r0, r0, #2
  40b228:	4770      	bx	lr
  40b22a:	bf00      	nop
  40b22c:	400e0400 	.word	0x400e0400

0040b230 <pmc_enable_periph_clk>:
 * \retval 0 Success.
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_enable_periph_clk(uint32_t ul_id)
{
	if (ul_id > MAX_PERIPH_ID) {
  40b230:	2822      	cmp	r0, #34	; 0x22
  40b232:	d819      	bhi.n	40b268 <pmc_enable_periph_clk+0x38>
		return 1;
	}

	if (ul_id < 32) {
  40b234:	281f      	cmp	r0, #31
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
  40b236:	4b0e      	ldr	r3, [pc, #56]	; (40b270 <pmc_enable_periph_clk+0x40>)
{
	if (ul_id > MAX_PERIPH_ID) {
		return 1;
	}

	if (ul_id < 32) {
  40b238:	d809      	bhi.n	40b24e <pmc_enable_periph_clk+0x1e>
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
  40b23a:	2101      	movs	r1, #1
  40b23c:	699a      	ldr	r2, [r3, #24]
  40b23e:	fa01 f000 	lsl.w	r0, r1, r0
  40b242:	4002      	ands	r2, r0
  40b244:	4290      	cmp	r0, r2
  40b246:	d011      	beq.n	40b26c <pmc_enable_periph_clk+0x3c>
			PMC->PMC_PCER0 = 1 << ul_id;
  40b248:	6118      	str	r0, [r3, #16]
			PMC->PMC_PCER1 = 1 << ul_id;
		}
#endif
	}

	return 0;
  40b24a:	2000      	movs	r0, #0
  40b24c:	4770      	bx	lr
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
			PMC->PMC_PCER0 = 1 << ul_id;
		}
#if (SAM3S || SAM3XA || SAM4S || SAM4E || SAM4C || SAM4CM || SAM4CP || SAMG55 || SAMV71 || SAMV70 || SAME70 || SAMS70)
	} else {
		ul_id -= 32;
  40b24e:	3820      	subs	r0, #32
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) != (1u << ul_id)) {
  40b250:	2101      	movs	r1, #1
  40b252:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
  40b256:	fa01 f000 	lsl.w	r0, r1, r0
  40b25a:	4002      	ands	r2, r0
  40b25c:	4290      	cmp	r0, r2
  40b25e:	d005      	beq.n	40b26c <pmc_enable_periph_clk+0x3c>
			PMC->PMC_PCER1 = 1 << ul_id;
  40b260:	f8c3 0100 	str.w	r0, [r3, #256]	; 0x100
		}
#endif
	}

	return 0;
  40b264:	2000      	movs	r0, #0
  40b266:	4770      	bx	lr
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_enable_periph_clk(uint32_t ul_id)
{
	if (ul_id > MAX_PERIPH_ID) {
		return 1;
  40b268:	2001      	movs	r0, #1
  40b26a:	4770      	bx	lr
			PMC->PMC_PCER1 = 1 << ul_id;
		}
#endif
	}

	return 0;
  40b26c:	2000      	movs	r0, #0
}
  40b26e:	4770      	bx	lr
  40b270:	400e0400 	.word	0x400e0400

0040b274 <pmc_enable_sleepmode>:
void pmc_enable_sleepmode(uint8_t uc_type)
{
#if !(SAM4S || SAM4E || SAM4N || SAM4C || SAM4CM || SAM4CP || SAMV71 || SAMV70 || SAME70 || SAMS70)
	PMC->PMC_FSMR &= (uint32_t) ~ PMC_FSMR_LPM; // Enter Sleep mode
#endif
	SCB->SCR &= (uint32_t) ~ SCB_SCR_SLEEPDEEP_Msk; // Deep sleep
  40b274:	4b03      	ldr	r3, [pc, #12]	; (40b284 <pmc_enable_sleepmode+0x10>)
  40b276:	691a      	ldr	r2, [r3, #16]
  40b278:	f022 0204 	bic.w	r2, r2, #4
  40b27c:	611a      	str	r2, [r3, #16]
    Wait For Interrupt is a hint instruction that suspends execution
    until one of a number of events occurs.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFI(void)
{
  __ASM volatile ("wfi");
  40b27e:	bf30      	wfi
  40b280:	4770      	bx	lr
  40b282:	bf00      	nop
  40b284:	e000ed00 	.word	0xe000ed00

0040b288 <wdt_get_timeout_value>:
 */
uint32_t wdt_get_timeout_value(uint32_t ul_us, uint32_t ul_sclk)
{
	uint32_t max, min;

	min = WDT_SLCK_DIV * 1000000 / ul_sclk;
  40b288:	4b08      	ldr	r3, [pc, #32]	; (40b2ac <wdt_get_timeout_value+0x24>)
  40b28a:	fbb3 f1f1 	udiv	r1, r3, r1
	max = min * WDT_MAX_VALUE;

	if ((ul_us < min) || (ul_us > max)) {
  40b28e:	4281      	cmp	r1, r0
  40b290:	d902      	bls.n	40b298 <wdt_get_timeout_value+0x10>
		return WDT_INVALID_ARGUMENT;
  40b292:	f64f 70ff 	movw	r0, #65535	; 0xffff
	}

	return WDT_MR_WDV(ul_us / min);
}
  40b296:	4770      	bx	lr
uint32_t wdt_get_timeout_value(uint32_t ul_us, uint32_t ul_sclk)
{
	uint32_t max, min;

	min = WDT_SLCK_DIV * 1000000 / ul_sclk;
	max = min * WDT_MAX_VALUE;
  40b298:	ebc1 3301 	rsb	r3, r1, r1, lsl #12

	if ((ul_us < min) || (ul_us > max)) {
  40b29c:	4283      	cmp	r3, r0
  40b29e:	d3f8      	bcc.n	40b292 <wdt_get_timeout_value+0xa>
		return WDT_INVALID_ARGUMENT;
	}

	return WDT_MR_WDV(ul_us / min);
  40b2a0:	fbb0 f0f1 	udiv	r0, r0, r1
  40b2a4:	f3c0 000b 	ubfx	r0, r0, #0, #12
  40b2a8:	4770      	bx	lr
  40b2aa:	bf00      	nop
  40b2ac:	07a12000 	.word	0x07a12000

0040b2b0 <wdt_init>:
 * \param us_counter The value loaded in the 12-bit Watchdog Counter.
 * \param us_delta The permitted range for reloading the Watchdog Timer.
 */
void wdt_init(Wdt *p_wdt, uint32_t ul_mode, uint16_t us_counter,
		uint16_t us_delta)
{
  40b2b0:	b410      	push	{r4}
	p_wdt->WDT_MR = ul_mode |
			WDT_MR_WDV(us_counter) | WDT_MR_WDD(us_delta);
  40b2b2:	4c06      	ldr	r4, [pc, #24]	; (40b2cc <wdt_init+0x1c>)
 * \param us_delta The permitted range for reloading the Watchdog Timer.
 */
void wdt_init(Wdt *p_wdt, uint32_t ul_mode, uint16_t us_counter,
		uint16_t us_delta)
{
	p_wdt->WDT_MR = ul_mode |
  40b2b4:	f3c2 020b 	ubfx	r2, r2, #0, #12
			WDT_MR_WDV(us_counter) | WDT_MR_WDD(us_delta);
  40b2b8:	ea04 4303 	and.w	r3, r4, r3, lsl #16
 * \param us_delta The permitted range for reloading the Watchdog Timer.
 */
void wdt_init(Wdt *p_wdt, uint32_t ul_mode, uint16_t us_counter,
		uint16_t us_delta)
{
	p_wdt->WDT_MR = ul_mode |
  40b2bc:	ea42 0403 	orr.w	r4, r2, r3
			WDT_MR_WDV(us_counter) | WDT_MR_WDD(us_delta);
  40b2c0:	4321      	orrs	r1, r4
 * \param us_delta The permitted range for reloading the Watchdog Timer.
 */
void wdt_init(Wdt *p_wdt, uint32_t ul_mode, uint16_t us_counter,
		uint16_t us_delta)
{
	p_wdt->WDT_MR = ul_mode |
  40b2c2:	6041      	str	r1, [r0, #4]
			WDT_MR_WDV(us_counter) | WDT_MR_WDD(us_delta);
}
  40b2c4:	f85d 4b04 	ldr.w	r4, [sp], #4
  40b2c8:	4770      	bx	lr
  40b2ca:	bf00      	nop
  40b2cc:	0fff0000 	.word	0x0fff0000

0040b2d0 <wdt_restart>:
/**
 * \brief Restart the watchdog timer.
 */
void wdt_restart(Wdt *p_wdt)
{
	if (p_wdt == WDT) {
  40b2d0:	4b02      	ldr	r3, [pc, #8]	; (40b2dc <wdt_restart+0xc>)
  40b2d2:	4298      	cmp	r0, r3
		p_wdt->WDT_CR = WDT_KEY_PASSWORD | WDT_CR_WDRSTT;
  40b2d4:	bf04      	itt	eq
  40b2d6:	4b02      	ldreq	r3, [pc, #8]	; (40b2e0 <wdt_restart+0x10>)
  40b2d8:	6003      	streq	r3, [r0, #0]
  40b2da:	4770      	bx	lr
  40b2dc:	400e1450 	.word	0x400e1450
  40b2e0:	a5000001 	.word	0xa5000001

0040b2e4 <wdt_get_status>:
 *
 * \return Bitmask of watchdog timer status.
 */
uint32_t wdt_get_status(Wdt *p_wdt)
{
	return p_wdt->WDT_SR;
  40b2e4:	6880      	ldr	r0, [r0, #8]
}
  40b2e6:	4770      	bx	lr

0040b2e8 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
  40b2e8:	e7fe      	b.n	40b2e8 <Dummy_Handler>
  40b2ea:	bf00      	nop

0040b2ec <Reset_Handler>:

	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc > pDest) {
  40b2ec:	481c      	ldr	r0, [pc, #112]	; (40b360 <Reset_Handler+0x74>)
  40b2ee:	4b1d      	ldr	r3, [pc, #116]	; (40b364 <Reset_Handler+0x78>)
  40b2f0:	4298      	cmp	r0, r3
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
  40b2f2:	b510      	push	{r4, lr}

	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc > pDest) {
  40b2f4:	d925      	bls.n	40b342 <Reset_Handler+0x56>
		for (; pDest < &_erelocate;) {
  40b2f6:	4a1c      	ldr	r2, [pc, #112]	; (40b368 <Reset_Handler+0x7c>)
  40b2f8:	4293      	cmp	r3, r2
  40b2fa:	d20a      	bcs.n	40b312 <Reset_Handler+0x26>
  40b2fc:	43d9      	mvns	r1, r3
  40b2fe:	440a      	add	r2, r1
  40b300:	f022 0403 	bic.w	r4, r2, #3
  40b304:	3404      	adds	r4, #4
  40b306:	2200      	movs	r2, #0
			*pDest++ = *pSrc++;
  40b308:	5881      	ldr	r1, [r0, r2]
  40b30a:	5099      	str	r1, [r3, r2]
  40b30c:	3204      	adds	r2, #4
	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc > pDest) {
		for (; pDest < &_erelocate;) {
  40b30e:	42a2      	cmp	r2, r4
  40b310:	d1fa      	bne.n	40b308 <Reset_Handler+0x1c>

    No Operation does nothing. This instruction can be used for code alignment purposes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
{
  __ASM volatile ("nop");
  40b312:	bf00      	nop
		}
	}
	__NOP();

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
  40b314:	4b15      	ldr	r3, [pc, #84]	; (40b36c <Reset_Handler+0x80>)
  40b316:	4a16      	ldr	r2, [pc, #88]	; (40b370 <Reset_Handler+0x84>)
  40b318:	4293      	cmp	r3, r2
  40b31a:	d20a      	bcs.n	40b332 <Reset_Handler+0x46>
  40b31c:	43d9      	mvns	r1, r3
  40b31e:	440a      	add	r2, r1
  40b320:	f022 0103 	bic.w	r1, r2, #3
  40b324:	4419      	add	r1, r3
		*pDest++ = 0;
  40b326:	2200      	movs	r2, #0
  40b328:	3b04      	subs	r3, #4
  40b32a:	f843 2f04 	str.w	r2, [r3, #4]!
		}
	}
	__NOP();

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
  40b32e:	428b      	cmp	r3, r1
  40b330:	d1fb      	bne.n	40b32a <Reset_Handler+0x3e>
		*pDest++ = 0;
	}

	/* Set the vector table base address */
	pSrc = (uint32_t *) & _sfixed;
	SCB->VTOR = ((uint32_t) pSrc);
  40b332:	4b10      	ldr	r3, [pc, #64]	; (40b374 <Reset_Handler+0x88>)
  40b334:	4a10      	ldr	r2, [pc, #64]	; (40b378 <Reset_Handler+0x8c>)
  40b336:	609a      	str	r2, [r3, #8]

	/* Initialize the C library */
	__libc_init_array();
  40b338:	4b10      	ldr	r3, [pc, #64]	; (40b37c <Reset_Handler+0x90>)
  40b33a:	4798      	blx	r3

	/* Branch to main function */
	main();
  40b33c:	4b10      	ldr	r3, [pc, #64]	; (40b380 <Reset_Handler+0x94>)
  40b33e:	4798      	blx	r3
  40b340:	e7fe      	b.n	40b340 <Reset_Handler+0x54>

	if (pSrc > pDest) {
		for (; pDest < &_erelocate;) {
			*pDest++ = *pSrc++;
		}
	} else if (pSrc < pDest) {
  40b342:	d2e6      	bcs.n	40b312 <Reset_Handler+0x26>
		uint32_t nb_bytes = (uint32_t)&_erelocate - (uint32_t)&_srelocate;
  40b344:	4908      	ldr	r1, [pc, #32]	; (40b368 <Reset_Handler+0x7c>)
		pSrc = (uint32_t*)((uint32_t)pSrc + nb_bytes) - 1;
  40b346:	3804      	subs	r0, #4
	if (pSrc > pDest) {
		for (; pDest < &_erelocate;) {
			*pDest++ = *pSrc++;
		}
	} else if (pSrc < pDest) {
		uint32_t nb_bytes = (uint32_t)&_erelocate - (uint32_t)&_srelocate;
  40b348:	1aca      	subs	r2, r1, r3
		pSrc = (uint32_t*)((uint32_t)pSrc + nb_bytes) - 1;
  40b34a:	4410      	add	r0, r2
		pDest = (uint32_t*)((uint32_t)pDest + nb_bytes) - 1;
		for (;nb_bytes;nb_bytes -= 4) {
  40b34c:	2a00      	cmp	r2, #0
  40b34e:	d0e0      	beq.n	40b312 <Reset_Handler+0x26>
  40b350:	460a      	mov	r2, r1
  40b352:	1a54      	subs	r4, r2, r1
			*pDest-- = *pSrc--;
  40b354:	5824      	ldr	r4, [r4, r0]
  40b356:	f842 4d04 	str.w	r4, [r2, #-4]!
		}
	} else if (pSrc < pDest) {
		uint32_t nb_bytes = (uint32_t)&_erelocate - (uint32_t)&_srelocate;
		pSrc = (uint32_t*)((uint32_t)pSrc + nb_bytes) - 1;
		pDest = (uint32_t*)((uint32_t)pDest + nb_bytes) - 1;
		for (;nb_bytes;nb_bytes -= 4) {
  40b35a:	4293      	cmp	r3, r2
  40b35c:	d1f9      	bne.n	40b352 <Reset_Handler+0x66>
  40b35e:	e7d8      	b.n	40b312 <Reset_Handler+0x26>
  40b360:	0041729c 	.word	0x0041729c
  40b364:	20000000 	.word	0x20000000
  40b368:	20000fac 	.word	0x20000fac
  40b36c:	20000fac 	.word	0x20000fac
  40b370:	20005040 	.word	0x20005040
  40b374:	e000ed00 	.word	0xe000ed00
  40b378:	00400000 	.word	0x00400000
  40b37c:	0040bb59 	.word	0x0040bb59
  40b380:	0040b53d 	.word	0x0040b53d

0040b384 <SystemCoreClockUpdate>:
 * \brief Get Core Clock Frequency.
 */
void SystemCoreClockUpdate( void )
{
	/* Determine clock frequency according to clock register values */
	switch ( PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk ) {
  40b384:	4b32      	ldr	r3, [pc, #200]	; (40b450 <SystemCoreClockUpdate+0xcc>)
  40b386:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  40b388:	f002 0203 	and.w	r2, r2, #3
  40b38c:	2a01      	cmp	r2, #1
  40b38e:	d03a      	beq.n	40b406 <SystemCoreClockUpdate+0x82>
  40b390:	d323      	bcc.n	40b3da <SystemCoreClockUpdate+0x56>
		}
		break;
		
	case PMC_MCKR_CSS_PLLA_CLK:	/* PLLA clock */
	case PMC_MCKR_CSS_PLLB_CLK:	/* PLLB clock */
			if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL ) {
  40b392:	6a1a      	ldr	r2, [r3, #32]
  40b394:	01d2      	lsls	r2, r2, #7
  40b396:	d547      	bpl.n	40b428 <SystemCoreClockUpdate+0xa4>
				SystemCoreClock = CHIP_FREQ_XTAL;
  40b398:	4a2e      	ldr	r2, [pc, #184]	; (40b454 <SystemCoreClockUpdate+0xd0>)
  40b39a:	482f      	ldr	r0, [pc, #188]	; (40b458 <SystemCoreClockUpdate+0xd4>)
  40b39c:	6010      	str	r0, [r2, #0]
				default:
					break;
				}
			}
			
			if ( (uint32_t)(PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) ==
  40b39e:	4b2c      	ldr	r3, [pc, #176]	; (40b450 <SystemCoreClockUpdate+0xcc>)
  40b3a0:	6b19      	ldr	r1, [r3, #48]	; 0x30
  40b3a2:	f001 0103 	and.w	r1, r1, #3
  40b3a6:	2902      	cmp	r1, #2
					PMC_MCKR_CSS_PLLA_CLK ) {
				SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk)
  40b3a8:	bf0b      	itete	eq
  40b3aa:	6a99      	ldreq	r1, [r3, #40]	; 0x28
						>> CKGR_PLLAR_MULA_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk)
						>> CKGR_PLLAR_DIVA_Pos));
			} else {
				SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk)
  40b3ac:	6ad9      	ldrne	r1, [r3, #44]	; 0x2c
			
			if ( (uint32_t)(PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) ==
					PMC_MCKR_CSS_PLLA_CLK ) {
				SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk)
						>> CKGR_PLLAR_MULA_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk)
  40b3ae:	6a9b      	ldreq	r3, [r3, #40]	; 0x28
						>> CKGR_PLLAR_DIVA_Pos));
			} else {
				SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk)
						>> CKGR_PLLBR_MULB_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_DIVB_Msk)
  40b3b0:	6adb      	ldrne	r3, [r3, #44]	; 0x2c
						>> CKGR_PLLAR_MULA_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk)
						>> CKGR_PLLAR_DIVA_Pos));
			} else {
				SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk)
						>> CKGR_PLLBR_MULB_Pos) + 1U);
  40b3b2:	f3c1 410a 	ubfx	r1, r1, #16, #11
				SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk)
						>> CKGR_PLLAR_MULA_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk)
						>> CKGR_PLLAR_DIVA_Pos));
			} else {
				SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk)
  40b3b6:	fb01 0000 	mla	r0, r1, r0, r0
						>> CKGR_PLLBR_MULB_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_DIVB_Msk)
						>> CKGR_PLLBR_DIVB_Pos));
  40b3ba:	b2db      	uxtb	r3, r3
				SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk)
						>> CKGR_PLLAR_DIVA_Pos));
			} else {
				SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk)
						>> CKGR_PLLBR_MULB_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_DIVB_Msk)
  40b3bc:	fbb0 f0f3 	udiv	r0, r0, r3
		
	default:
		break;
	}

	if ( (PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3 ) {
  40b3c0:	4b23      	ldr	r3, [pc, #140]	; (40b450 <SystemCoreClockUpdate+0xcc>)
				SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk)
						>> CKGR_PLLAR_DIVA_Pos));
			} else {
				SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk)
						>> CKGR_PLLBR_MULB_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_DIVB_Msk)
  40b3c2:	6010      	str	r0, [r2, #0]
		
	default:
		break;
	}

	if ( (PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3 ) {
  40b3c4:	6b19      	ldr	r1, [r3, #48]	; 0x30
  40b3c6:	f001 0170 	and.w	r1, r1, #112	; 0x70
  40b3ca:	2970      	cmp	r1, #112	; 0x70
  40b3cc:	d115      	bne.n	40b3fa <SystemCoreClockUpdate+0x76>
		SystemCoreClock /= 3U;
  40b3ce:	4b23      	ldr	r3, [pc, #140]	; (40b45c <SystemCoreClockUpdate+0xd8>)
  40b3d0:	fba3 1000 	umull	r1, r0, r3, r0
  40b3d4:	0840      	lsrs	r0, r0, #1
  40b3d6:	6010      	str	r0, [r2, #0]
  40b3d8:	4770      	bx	lr
void SystemCoreClockUpdate( void )
{
	/* Determine clock frequency according to clock register values */
	switch ( PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk ) {
	case PMC_MCKR_CSS_SLOW_CLK: /* Slow clock */
			if ( SUPC->SUPC_SR & SUPC_SR_OSCSEL ) {
  40b3da:	4b21      	ldr	r3, [pc, #132]	; (40b460 <SystemCoreClockUpdate+0xdc>)
				SystemCoreClock = CHIP_FREQ_XTAL_32K;
  40b3dc:	4a1d      	ldr	r2, [pc, #116]	; (40b454 <SystemCoreClockUpdate+0xd0>)
void SystemCoreClockUpdate( void )
{
	/* Determine clock frequency according to clock register values */
	switch ( PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk ) {
	case PMC_MCKR_CSS_SLOW_CLK: /* Slow clock */
			if ( SUPC->SUPC_SR & SUPC_SR_OSCSEL ) {
  40b3de:	695b      	ldr	r3, [r3, #20]
  40b3e0:	061b      	lsls	r3, r3, #24
				SystemCoreClock = CHIP_FREQ_XTAL_32K;
  40b3e2:	bf4c      	ite	mi
  40b3e4:	f44f 4000 	movmi.w	r0, #32768	; 0x8000
			} else {
				SystemCoreClock = CHIP_FREQ_SLCK_RC;
  40b3e8:	f44f 40fa 	movpl.w	r0, #32000	; 0x7d00
  40b3ec:	6010      	str	r0, [r2, #0]
		
	default:
		break;
	}

	if ( (PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3 ) {
  40b3ee:	4b18      	ldr	r3, [pc, #96]	; (40b450 <SystemCoreClockUpdate+0xcc>)
  40b3f0:	6b19      	ldr	r1, [r3, #48]	; 0x30
  40b3f2:	f001 0170 	and.w	r1, r1, #112	; 0x70
  40b3f6:	2970      	cmp	r1, #112	; 0x70
  40b3f8:	d0e9      	beq.n	40b3ce <SystemCoreClockUpdate+0x4a>
		SystemCoreClock /= 3U;
	} else {
		SystemCoreClock >>=
			((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >> PMC_MCKR_PRES_Pos);
  40b3fa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40b3fc:	f3c3 1302 	ubfx	r3, r3, #4, #3
	}

	if ( (PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3 ) {
		SystemCoreClock /= 3U;
	} else {
		SystemCoreClock >>=
  40b400:	40d8      	lsrs	r0, r3
  40b402:	6010      	str	r0, [r2, #0]
  40b404:	4770      	bx	lr
				SystemCoreClock = CHIP_FREQ_SLCK_RC;
			}
		break;
		
	case PMC_MCKR_CSS_MAIN_CLK: /* Main clock */
		if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL ) {
  40b406:	6a1a      	ldr	r2, [r3, #32]
  40b408:	f012 7f80 	tst.w	r2, #16777216	; 0x1000000
			SystemCoreClock = CHIP_FREQ_XTAL;
  40b40c:	4a11      	ldr	r2, [pc, #68]	; (40b454 <SystemCoreClockUpdate+0xd0>)
				SystemCoreClock = CHIP_FREQ_SLCK_RC;
			}
		break;
		
	case PMC_MCKR_CSS_MAIN_CLK: /* Main clock */
		if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL ) {
  40b40e:	d108      	bne.n	40b422 <SystemCoreClockUpdate+0x9e>
			SystemCoreClock = CHIP_FREQ_XTAL;
		} else {
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  40b410:	4814      	ldr	r0, [pc, #80]	; (40b464 <SystemCoreClockUpdate+0xe0>)
  40b412:	6010      	str	r0, [r2, #0]
			
			switch ( PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk ) {
  40b414:	6a1b      	ldr	r3, [r3, #32]
  40b416:	f003 0370 	and.w	r3, r3, #112	; 0x70
  40b41a:	2b10      	cmp	r3, #16
  40b41c:	d014      	beq.n	40b448 <SystemCoreClockUpdate+0xc4>
  40b41e:	2b20      	cmp	r3, #32
  40b420:	d1e5      	bne.n	40b3ee <SystemCoreClockUpdate+0x6a>
			case CKGR_MOR_MOSCRCF_8_MHz:
				SystemCoreClock = CHIP_FREQ_MAINCK_RC_8MHZ;
			break;
			
			case CKGR_MOR_MOSCRCF_12_MHz:
				SystemCoreClock = CHIP_FREQ_MAINCK_RC_12MHZ;
  40b422:	480d      	ldr	r0, [pc, #52]	; (40b458 <SystemCoreClockUpdate+0xd4>)
  40b424:	6010      	str	r0, [r2, #0]
			break;
  40b426:	e7e2      	b.n	40b3ee <SystemCoreClockUpdate+0x6a>
	case PMC_MCKR_CSS_PLLA_CLK:	/* PLLA clock */
	case PMC_MCKR_CSS_PLLB_CLK:	/* PLLB clock */
			if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL ) {
				SystemCoreClock = CHIP_FREQ_XTAL;
			} else {
				SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  40b428:	4a0a      	ldr	r2, [pc, #40]	; (40b454 <SystemCoreClockUpdate+0xd0>)
  40b42a:	480e      	ldr	r0, [pc, #56]	; (40b464 <SystemCoreClockUpdate+0xe0>)
  40b42c:	6010      	str	r0, [r2, #0]
				
				switch ( PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk ) {
  40b42e:	6a1b      	ldr	r3, [r3, #32]
  40b430:	f003 0370 	and.w	r3, r3, #112	; 0x70
  40b434:	2b10      	cmp	r3, #16
  40b436:	d004      	beq.n	40b442 <SystemCoreClockUpdate+0xbe>
  40b438:	2b20      	cmp	r3, #32
  40b43a:	d1b0      	bne.n	40b39e <SystemCoreClockUpdate+0x1a>
				case CKGR_MOR_MOSCRCF_8_MHz:
					SystemCoreClock = CHIP_FREQ_MAINCK_RC_8MHZ;
					break;
				
				case CKGR_MOR_MOSCRCF_12_MHz:
					SystemCoreClock = CHIP_FREQ_MAINCK_RC_12MHZ;
  40b43c:	4806      	ldr	r0, [pc, #24]	; (40b458 <SystemCoreClockUpdate+0xd4>)
  40b43e:	6010      	str	r0, [r2, #0]
					break;
  40b440:	e7ad      	b.n	40b39e <SystemCoreClockUpdate+0x1a>
				case CKGR_MOR_MOSCRCF_4_MHz:
					SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
					break;
				
				case CKGR_MOR_MOSCRCF_8_MHz:
					SystemCoreClock = CHIP_FREQ_MAINCK_RC_8MHZ;
  40b442:	4809      	ldr	r0, [pc, #36]	; (40b468 <SystemCoreClockUpdate+0xe4>)
  40b444:	6010      	str	r0, [r2, #0]
					break;
  40b446:	e7aa      	b.n	40b39e <SystemCoreClockUpdate+0x1a>
			case CKGR_MOR_MOSCRCF_4_MHz:
				SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
			break;
			
			case CKGR_MOR_MOSCRCF_8_MHz:
				SystemCoreClock = CHIP_FREQ_MAINCK_RC_8MHZ;
  40b448:	4807      	ldr	r0, [pc, #28]	; (40b468 <SystemCoreClockUpdate+0xe4>)
  40b44a:	6010      	str	r0, [r2, #0]
			break;
  40b44c:	e7cf      	b.n	40b3ee <SystemCoreClockUpdate+0x6a>
  40b44e:	bf00      	nop
  40b450:	400e0400 	.word	0x400e0400
  40b454:	20000700 	.word	0x20000700
  40b458:	00b71b00 	.word	0x00b71b00
  40b45c:	aaaaaaab 	.word	0xaaaaaaab
  40b460:	400e1410 	.word	0x400e1410
  40b464:	003d0900 	.word	0x003d0900
  40b468:	007a1200 	.word	0x007a1200

0040b46c <system_init_flash>:
 */
void system_init_flash( uint32_t ul_clk )
{
  /* Set FWS for embedded Flash access according to operating frequency */
#if !defined(ID_EFC1)
	if ( ul_clk < CHIP_FREQ_FWS_0 ) {
  40b46c:	4b0f      	ldr	r3, [pc, #60]	; (40b4ac <system_init_flash+0x40>)
  40b46e:	4298      	cmp	r0, r3
  40b470:	d912      	bls.n	40b498 <system_init_flash+0x2c>
		EFC0->EEFC_FMR = EEFC_FMR_FWS(0)|EEFC_FMR_CLOE;
	} else {
		if ( ul_clk < CHIP_FREQ_FWS_1 ) {
  40b472:	4b0f      	ldr	r3, [pc, #60]	; (40b4b0 <system_init_flash+0x44>)
  40b474:	4298      	cmp	r0, r3
  40b476:	d90b      	bls.n	40b490 <system_init_flash+0x24>
			EFC0->EEFC_FMR = EEFC_FMR_FWS(1)|EEFC_FMR_CLOE;
		} else {
			if ( ul_clk < CHIP_FREQ_FWS_2 ) {
  40b478:	4b0e      	ldr	r3, [pc, #56]	; (40b4b4 <system_init_flash+0x48>)
  40b47a:	4298      	cmp	r0, r3
  40b47c:	d911      	bls.n	40b4a2 <system_init_flash+0x36>
				EFC0->EEFC_FMR = EEFC_FMR_FWS(2)|EEFC_FMR_CLOE;
			} else {
				if ( ul_clk < CHIP_FREQ_FWS_3 ) {
					EFC0->EEFC_FMR = EEFC_FMR_FWS(3)|EEFC_FMR_CLOE;
				} else {
					if ( ul_clk < CHIP_FREQ_FWS_4 ) {
  40b47e:	4b0e      	ldr	r3, [pc, #56]	; (40b4b8 <system_init_flash+0x4c>)
  40b480:	4298      	cmp	r0, r3
					EFC0->EEFC_FMR = EEFC_FMR_FWS(4)|EEFC_FMR_CLOE;
  40b482:	4b0e      	ldr	r3, [pc, #56]	; (40b4bc <system_init_flash+0x50>)
					} else {
					EFC0->EEFC_FMR = EEFC_FMR_FWS(5)|EEFC_FMR_CLOE;
  40b484:	bf8c      	ite	hi
  40b486:	4a0e      	ldrhi	r2, [pc, #56]	; (40b4c0 <system_init_flash+0x54>)
			} else {
				if ( ul_clk < CHIP_FREQ_FWS_3 ) {
					EFC0->EEFC_FMR = EEFC_FMR_FWS(3)|EEFC_FMR_CLOE;
				} else {
					if ( ul_clk < CHIP_FREQ_FWS_4 ) {
					EFC0->EEFC_FMR = EEFC_FMR_FWS(4)|EEFC_FMR_CLOE;
  40b488:	f04f 2204 	movls.w	r2, #67109888	; 0x4000400
					} else {
					EFC0->EEFC_FMR = EEFC_FMR_FWS(5)|EEFC_FMR_CLOE;
  40b48c:	601a      	str	r2, [r3, #0]
  40b48e:	4770      	bx	lr
#if !defined(ID_EFC1)
	if ( ul_clk < CHIP_FREQ_FWS_0 ) {
		EFC0->EEFC_FMR = EEFC_FMR_FWS(0)|EEFC_FMR_CLOE;
	} else {
		if ( ul_clk < CHIP_FREQ_FWS_1 ) {
			EFC0->EEFC_FMR = EEFC_FMR_FWS(1)|EEFC_FMR_CLOE;
  40b490:	4b0a      	ldr	r3, [pc, #40]	; (40b4bc <system_init_flash+0x50>)
  40b492:	4a0c      	ldr	r2, [pc, #48]	; (40b4c4 <system_init_flash+0x58>)
  40b494:	601a      	str	r2, [r3, #0]
  40b496:	4770      	bx	lr
void system_init_flash( uint32_t ul_clk )
{
  /* Set FWS for embedded Flash access according to operating frequency */
#if !defined(ID_EFC1)
	if ( ul_clk < CHIP_FREQ_FWS_0 ) {
		EFC0->EEFC_FMR = EEFC_FMR_FWS(0)|EEFC_FMR_CLOE;
  40b498:	4b08      	ldr	r3, [pc, #32]	; (40b4bc <system_init_flash+0x50>)
  40b49a:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
  40b49e:	601a      	str	r2, [r3, #0]
  40b4a0:	4770      	bx	lr
	} else {
		if ( ul_clk < CHIP_FREQ_FWS_1 ) {
			EFC0->EEFC_FMR = EEFC_FMR_FWS(1)|EEFC_FMR_CLOE;
		} else {
			if ( ul_clk < CHIP_FREQ_FWS_2 ) {
				EFC0->EEFC_FMR = EEFC_FMR_FWS(2)|EEFC_FMR_CLOE;
  40b4a2:	4b06      	ldr	r3, [pc, #24]	; (40b4bc <system_init_flash+0x50>)
  40b4a4:	4a08      	ldr	r2, [pc, #32]	; (40b4c8 <system_init_flash+0x5c>)
  40b4a6:	601a      	str	r2, [r3, #0]
  40b4a8:	4770      	bx	lr
  40b4aa:	bf00      	nop
  40b4ac:	01ba813f 	.word	0x01ba813f
  40b4b0:	0375027f 	.word	0x0375027f
  40b4b4:	053ec5ff 	.word	0x053ec5ff
  40b4b8:	07270dff 	.word	0x07270dff
  40b4bc:	400e0a00 	.word	0x400e0a00
  40b4c0:	04000500 	.word	0x04000500
  40b4c4:	04000100 	.word	0x04000100
  40b4c8:	04000200 	.word	0x04000200

0040b4cc <_sbrk>:
{
	static unsigned char *heap = NULL;
	unsigned char *prev_heap;
	int ramend = (int)&__ram_end__;

	if (heap == NULL) {
  40b4cc:	4a07      	ldr	r2, [pc, #28]	; (40b4ec <_sbrk+0x20>)

extern caddr_t _sbrk(int incr)
{
	static unsigned char *heap = NULL;
	unsigned char *prev_heap;
	int ramend = (int)&__ram_end__;
  40b4ce:	4908      	ldr	r1, [pc, #32]	; (40b4f0 <_sbrk+0x24>)

	if (heap == NULL) {
  40b4d0:	6813      	ldr	r3, [r2, #0]
  40b4d2:	b13b      	cbz	r3, 40b4e4 <_sbrk+0x18>
		heap = (unsigned char *)&_end;
	}
	prev_heap = heap;

	if (((int)prev_heap + incr) > ramend) {
  40b4d4:	4418      	add	r0, r3
  40b4d6:	4281      	cmp	r1, r0
		return (caddr_t) -1;	
	}

	heap += incr;
  40b4d8:	bfa6      	itte	ge
  40b4da:	6010      	strge	r0, [r2, #0]

	return (caddr_t) prev_heap;
  40b4dc:	4618      	movge	r0, r3
		heap = (unsigned char *)&_end;
	}
	prev_heap = heap;

	if (((int)prev_heap + incr) > ramend) {
		return (caddr_t) -1;	
  40b4de:	f04f 30ff 	movlt.w	r0, #4294967295
	}

	heap += incr;

	return (caddr_t) prev_heap;
}
  40b4e2:	4770      	bx	lr
	static unsigned char *heap = NULL;
	unsigned char *prev_heap;
	int ramend = (int)&__ram_end__;

	if (heap == NULL) {
		heap = (unsigned char *)&_end;
  40b4e4:	4b03      	ldr	r3, [pc, #12]	; (40b4f4 <_sbrk+0x28>)
  40b4e6:	6013      	str	r3, [r2, #0]
  40b4e8:	e7f4      	b.n	40b4d4 <_sbrk+0x8>
  40b4ea:	bf00      	nop
  40b4ec:	2000396c 	.word	0x2000396c
  40b4f0:	2000fffc 	.word	0x2000fffc
  40b4f4:	20008040 	.word	0x20008040

0040b4f8 <_close>:
}

extern int _close(int file)
{
	return -1;
}
  40b4f8:	f04f 30ff 	mov.w	r0, #4294967295
  40b4fc:	4770      	bx	lr
  40b4fe:	bf00      	nop

0040b500 <_fstat>:

extern int _fstat(int file, struct stat *st)
{
	st->st_mode = S_IFCHR;
  40b500:	f44f 5300 	mov.w	r3, #8192	; 0x2000
  40b504:	604b      	str	r3, [r1, #4]

	return 0;
}
  40b506:	2000      	movs	r0, #0
  40b508:	4770      	bx	lr
  40b50a:	bf00      	nop

0040b50c <_isatty>:

extern int _isatty(int file)
{
	return 1;
}
  40b50c:	2001      	movs	r0, #1
  40b50e:	4770      	bx	lr

0040b510 <_lseek>:

extern int _lseek(int file, int ptr, int dir)
{
	return 0;
}
  40b510:	2000      	movs	r0, #0
  40b512:	4770      	bx	lr

0040b514 <HardFault_Handler>:
extern drv_uart_config_t usart1Config;
extern brainSettings_t brainSettings; 
volatile unsigned long sgSysTickCount = 0;

void HardFault_Handler()
{
  40b514:	e7fe      	b.n	40b514 <HardFault_Handler>
  40b516:	bf00      	nop

0040b518 <MemManage_Handler>:
	while(1); 
}
void MemManage_Handler()
{
  40b518:	e7fe      	b.n	40b518 <MemManage_Handler>
  40b51a:	bf00      	nop

0040b51c <BusFault_Handler>:
	while(1); 
}
void BusFault_Handler()
{
  40b51c:	e7fe      	b.n	40b51c <BusFault_Handler>
  40b51e:	bf00      	nop

0040b520 <UsageFault_Handler>:
	while(1); 
}
void UsageFault_Handler()
{
  40b520:	e7fe      	b.n	40b520 <UsageFault_Handler>
  40b522:	bf00      	nop

0040b524 <SysTick_Handler>:

/**
 * \brief Handler for System Tick interrupt.
 */
void SysTick_Handler(void)
{
  40b524:	b508      	push	{r3, lr}
	sgSysTickCount++;
  40b526:	4b03      	ldr	r3, [pc, #12]	; (40b534 <SysTick_Handler+0x10>)
	xPortSysTickHandler();
  40b528:	4a03      	ldr	r2, [pc, #12]	; (40b538 <SysTick_Handler+0x14>)
/**
 * \brief Handler for System Tick interrupt.
 */
void SysTick_Handler(void)
{
	sgSysTickCount++;
  40b52a:	6819      	ldr	r1, [r3, #0]
  40b52c:	3101      	adds	r1, #1
  40b52e:	6019      	str	r1, [r3, #0]
	xPortSysTickHandler();
  40b530:	4790      	blx	r2
  40b532:	bd08      	pop	{r3, pc}
  40b534:	20003970 	.word	0x20003970
  40b538:	00406751 	.word	0x00406751

0040b53c <main>:
}


int main (void)
{
  40b53c:	b500      	push	{lr}
	irq_initialize_vectors();
	cpu_irq_enable();
  40b53e:	4b11      	ldr	r3, [pc, #68]	; (40b584 <main+0x48>)
  40b540:	2201      	movs	r2, #1
	xPortSysTickHandler();
}


int main (void)
{
  40b542:	b085      	sub	sp, #20
	irq_initialize_vectors();
	cpu_irq_enable();
  40b544:	701a      	strb	r2, [r3, #0]
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
  40b546:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
  40b54a:	b662      	cpsie	i
	//Initialize system clock and peripherals
	sysclk_init();
  40b54c:	4b0e      	ldr	r3, [pc, #56]	; (40b588 <main+0x4c>)
	

	
	
	/*	Create task Main	*/
	if (xTaskCreate(TaskMain, "Main", TASK_MAIN_STACK_SIZE, NULL, TASK_MAIN_STACK_PRIORITY, NULL ) != pdPASS)
  40b54e:	4d0f      	ldr	r5, [pc, #60]	; (40b58c <main+0x50>)
  40b550:	4c0f      	ldr	r4, [pc, #60]	; (40b590 <main+0x54>)
int main (void)
{
	irq_initialize_vectors();
	cpu_irq_enable();
	//Initialize system clock and peripherals
	sysclk_init();
  40b552:	4798      	blx	r3
	#ifdef COMPILE_AS_BOOTLOADER
	runBootloader(); 
	#else
	
	//turn on pullups for SWDIO (PB5) and SWDIO (PB6)
	PIOB->PIO_PUER |= PIO_PB5 | PIO_PB6; 
  40b554:	4b0f      	ldr	r3, [pc, #60]	; (40b594 <main+0x58>)
	board_init();
  40b556:	4a10      	ldr	r2, [pc, #64]	; (40b598 <main+0x5c>)
	#ifdef COMPILE_AS_BOOTLOADER
	runBootloader(); 
	#else
	
	//turn on pullups for SWDIO (PB5) and SWDIO (PB6)
	PIOB->PIO_PUER |= PIO_PB5 | PIO_PB6; 
  40b558:	6e59      	ldr	r1, [r3, #100]	; 0x64
  40b55a:	f041 0160 	orr.w	r1, r1, #96	; 0x60
  40b55e:	6659      	str	r1, [r3, #100]	; 0x64
	board_init();
  40b560:	4790      	blx	r2
	

	
	
	/*	Create task Main	*/
	if (xTaskCreate(TaskMain, "Main", TASK_MAIN_STACK_SIZE, NULL, TASK_MAIN_STACK_PRIORITY, NULL ) != pdPASS)
  40b562:	2300      	movs	r3, #0
  40b564:	2202      	movs	r2, #2
  40b566:	e88d 000c 	stmia.w	sp, {r2, r3}
  40b56a:	9302      	str	r3, [sp, #8]
  40b56c:	9303      	str	r3, [sp, #12]
  40b56e:	480b      	ldr	r0, [pc, #44]	; (40b59c <main+0x60>)
  40b570:	490b      	ldr	r1, [pc, #44]	; (40b5a0 <main+0x64>)
  40b572:	f44f 7240 	mov.w	r2, #768	; 0x300
  40b576:	47a8      	blx	r5
	{
		//debugPrintString("Failed to create Main task\r\n");
	}

	/* Start the scheduler. */
	vTaskStartScheduler();
  40b578:	4b0a      	ldr	r3, [pc, #40]	; (40b5a4 <main+0x68>)
  40b57a:	4798      	blx	r3
	#endif
	//we should never get here. 
	/*	Debug code */
	while (1) 
	{		
		delay_ms(1000);
  40b57c:	480a      	ldr	r0, [pc, #40]	; (40b5a8 <main+0x6c>)
  40b57e:	47a0      	blx	r4
  40b580:	e7fc      	b.n	40b57c <main+0x40>
  40b582:	bf00      	nop
  40b584:	200006fd 	.word	0x200006fd
  40b588:	0040ac7d 	.word	0x0040ac7d
  40b58c:	00406dcd 	.word	0x00406dcd
  40b590:	20000085 	.word	0x20000085
  40b594:	400e1000 	.word	0x400e1000
  40b598:	0040ace1 	.word	0x0040ace1
  40b59c:	00409b09 	.word	0x00409b09
  40b5a0:	00416e30 	.word	0x00416e30
  40b5a4:	0040702d 	.word	0x0040702d
  40b5a8:	0082ca25 	.word	0x0082ca25

0040b5ac <__aeabi_uldivmod>:
  40b5ac:	b94b      	cbnz	r3, 40b5c2 <__aeabi_uldivmod+0x16>
  40b5ae:	b942      	cbnz	r2, 40b5c2 <__aeabi_uldivmod+0x16>
  40b5b0:	2900      	cmp	r1, #0
  40b5b2:	bf08      	it	eq
  40b5b4:	2800      	cmpeq	r0, #0
  40b5b6:	d002      	beq.n	40b5be <__aeabi_uldivmod+0x12>
  40b5b8:	f04f 31ff 	mov.w	r1, #4294967295
  40b5bc:	4608      	mov	r0, r1
  40b5be:	f000 b83b 	b.w	40b638 <__aeabi_idiv0>
  40b5c2:	b082      	sub	sp, #8
  40b5c4:	46ec      	mov	ip, sp
  40b5c6:	e92d 5000 	stmdb	sp!, {ip, lr}
  40b5ca:	f000 f81d 	bl	40b608 <__gnu_uldivmod_helper>
  40b5ce:	f8dd e004 	ldr.w	lr, [sp, #4]
  40b5d2:	b002      	add	sp, #8
  40b5d4:	bc0c      	pop	{r2, r3}
  40b5d6:	4770      	bx	lr

0040b5d8 <__gnu_ldivmod_helper>:
  40b5d8:	e92d 4370 	stmdb	sp!, {r4, r5, r6, r8, r9, lr}
  40b5dc:	9e06      	ldr	r6, [sp, #24]
  40b5de:	4614      	mov	r4, r2
  40b5e0:	461d      	mov	r5, r3
  40b5e2:	4680      	mov	r8, r0
  40b5e4:	4689      	mov	r9, r1
  40b5e6:	f000 f829 	bl	40b63c <__divdi3>
  40b5ea:	fb04 f301 	mul.w	r3, r4, r1
  40b5ee:	fb00 3305 	mla	r3, r0, r5, r3
  40b5f2:	fba4 4500 	umull	r4, r5, r4, r0
  40b5f6:	441d      	add	r5, r3
  40b5f8:	ebb8 0404 	subs.w	r4, r8, r4
  40b5fc:	eb69 0505 	sbc.w	r5, r9, r5
  40b600:	e9c6 4500 	strd	r4, r5, [r6]
  40b604:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}

0040b608 <__gnu_uldivmod_helper>:
  40b608:	e92d 4370 	stmdb	sp!, {r4, r5, r6, r8, r9, lr}
  40b60c:	9e06      	ldr	r6, [sp, #24]
  40b60e:	4614      	mov	r4, r2
  40b610:	4680      	mov	r8, r0
  40b612:	4689      	mov	r9, r1
  40b614:	461d      	mov	r5, r3
  40b616:	f000 f95d 	bl	40b8d4 <__udivdi3>
  40b61a:	fb00 f505 	mul.w	r5, r0, r5
  40b61e:	fb04 5301 	mla	r3, r4, r1, r5
  40b622:	fba0 4504 	umull	r4, r5, r0, r4
  40b626:	441d      	add	r5, r3
  40b628:	ebb8 0404 	subs.w	r4, r8, r4
  40b62c:	eb69 0505 	sbc.w	r5, r9, r5
  40b630:	e9c6 4500 	strd	r4, r5, [r6]
  40b634:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}

0040b638 <__aeabi_idiv0>:
  40b638:	4770      	bx	lr
  40b63a:	bf00      	nop

0040b63c <__divdi3>:
  40b63c:	2900      	cmp	r1, #0
  40b63e:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  40b642:	f2c0 809f 	blt.w	40b784 <__divdi3+0x148>
  40b646:	2400      	movs	r4, #0
  40b648:	2b00      	cmp	r3, #0
  40b64a:	f2c0 8096 	blt.w	40b77a <__divdi3+0x13e>
  40b64e:	4615      	mov	r5, r2
  40b650:	4606      	mov	r6, r0
  40b652:	460f      	mov	r7, r1
  40b654:	2b00      	cmp	r3, #0
  40b656:	d13e      	bne.n	40b6d6 <__divdi3+0x9a>
  40b658:	428a      	cmp	r2, r1
  40b65a:	d957      	bls.n	40b70c <__divdi3+0xd0>
  40b65c:	fab2 f382 	clz	r3, r2
  40b660:	b14b      	cbz	r3, 40b676 <__divdi3+0x3a>
  40b662:	f1c3 0220 	rsb	r2, r3, #32
  40b666:	fa01 f703 	lsl.w	r7, r1, r3
  40b66a:	fa20 f202 	lsr.w	r2, r0, r2
  40b66e:	409d      	lsls	r5, r3
  40b670:	4317      	orrs	r7, r2
  40b672:	fa00 f603 	lsl.w	r6, r0, r3
  40b676:	0c29      	lsrs	r1, r5, #16
  40b678:	fbb7 f2f1 	udiv	r2, r7, r1
  40b67c:	0c33      	lsrs	r3, r6, #16
  40b67e:	fb01 7c12 	mls	ip, r1, r2, r7
  40b682:	b2a8      	uxth	r0, r5
  40b684:	ea43 470c 	orr.w	r7, r3, ip, lsl #16
  40b688:	fb00 f302 	mul.w	r3, r0, r2
  40b68c:	42bb      	cmp	r3, r7
  40b68e:	d909      	bls.n	40b6a4 <__divdi3+0x68>
  40b690:	197f      	adds	r7, r7, r5
  40b692:	f102 3cff 	add.w	ip, r2, #4294967295
  40b696:	f080 8101 	bcs.w	40b89c <__divdi3+0x260>
  40b69a:	42bb      	cmp	r3, r7
  40b69c:	f240 80fe 	bls.w	40b89c <__divdi3+0x260>
  40b6a0:	3a02      	subs	r2, #2
  40b6a2:	442f      	add	r7, r5
  40b6a4:	1aff      	subs	r7, r7, r3
  40b6a6:	fbb7 f3f1 	udiv	r3, r7, r1
  40b6aa:	b2b6      	uxth	r6, r6
  40b6ac:	fb01 7113 	mls	r1, r1, r3, r7
  40b6b0:	ea46 4101 	orr.w	r1, r6, r1, lsl #16
  40b6b4:	fb00 f003 	mul.w	r0, r0, r3
  40b6b8:	4288      	cmp	r0, r1
  40b6ba:	d908      	bls.n	40b6ce <__divdi3+0x92>
  40b6bc:	1949      	adds	r1, r1, r5
  40b6be:	f103 37ff 	add.w	r7, r3, #4294967295
  40b6c2:	f080 80ed 	bcs.w	40b8a0 <__divdi3+0x264>
  40b6c6:	4288      	cmp	r0, r1
  40b6c8:	f240 80ea 	bls.w	40b8a0 <__divdi3+0x264>
  40b6cc:	3b02      	subs	r3, #2
  40b6ce:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
  40b6d2:	2300      	movs	r3, #0
  40b6d4:	e003      	b.n	40b6de <__divdi3+0xa2>
  40b6d6:	428b      	cmp	r3, r1
  40b6d8:	d90a      	bls.n	40b6f0 <__divdi3+0xb4>
  40b6da:	2300      	movs	r3, #0
  40b6dc:	461a      	mov	r2, r3
  40b6de:	4610      	mov	r0, r2
  40b6e0:	4619      	mov	r1, r3
  40b6e2:	b114      	cbz	r4, 40b6ea <__divdi3+0xae>
  40b6e4:	4240      	negs	r0, r0
  40b6e6:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  40b6ea:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  40b6ee:	4770      	bx	lr
  40b6f0:	fab3 f883 	clz	r8, r3
  40b6f4:	f1b8 0f00 	cmp.w	r8, #0
  40b6f8:	f040 8084 	bne.w	40b804 <__divdi3+0x1c8>
  40b6fc:	428b      	cmp	r3, r1
  40b6fe:	d302      	bcc.n	40b706 <__divdi3+0xca>
  40b700:	4282      	cmp	r2, r0
  40b702:	f200 80de 	bhi.w	40b8c2 <__divdi3+0x286>
  40b706:	2300      	movs	r3, #0
  40b708:	2201      	movs	r2, #1
  40b70a:	e7e8      	b.n	40b6de <__divdi3+0xa2>
  40b70c:	b912      	cbnz	r2, 40b714 <__divdi3+0xd8>
  40b70e:	2301      	movs	r3, #1
  40b710:	fbb3 f5f2 	udiv	r5, r3, r2
  40b714:	fab5 f285 	clz	r2, r5
  40b718:	2a00      	cmp	r2, #0
  40b71a:	d139      	bne.n	40b790 <__divdi3+0x154>
  40b71c:	1b7f      	subs	r7, r7, r5
  40b71e:	0c28      	lsrs	r0, r5, #16
  40b720:	fa1f fc85 	uxth.w	ip, r5
  40b724:	2301      	movs	r3, #1
  40b726:	fbb7 f1f0 	udiv	r1, r7, r0
  40b72a:	0c32      	lsrs	r2, r6, #16
  40b72c:	fb00 7711 	mls	r7, r0, r1, r7
  40b730:	ea42 4707 	orr.w	r7, r2, r7, lsl #16
  40b734:	fb0c f201 	mul.w	r2, ip, r1
  40b738:	42ba      	cmp	r2, r7
  40b73a:	d907      	bls.n	40b74c <__divdi3+0x110>
  40b73c:	197f      	adds	r7, r7, r5
  40b73e:	f101 38ff 	add.w	r8, r1, #4294967295
  40b742:	d202      	bcs.n	40b74a <__divdi3+0x10e>
  40b744:	42ba      	cmp	r2, r7
  40b746:	f200 80c1 	bhi.w	40b8cc <__divdi3+0x290>
  40b74a:	4641      	mov	r1, r8
  40b74c:	1abf      	subs	r7, r7, r2
  40b74e:	fbb7 f2f0 	udiv	r2, r7, r0
  40b752:	b2b6      	uxth	r6, r6
  40b754:	fb00 7012 	mls	r0, r0, r2, r7
  40b758:	ea46 4000 	orr.w	r0, r6, r0, lsl #16
  40b75c:	fb0c fc02 	mul.w	ip, ip, r2
  40b760:	4584      	cmp	ip, r0
  40b762:	d907      	bls.n	40b774 <__divdi3+0x138>
  40b764:	1940      	adds	r0, r0, r5
  40b766:	f102 37ff 	add.w	r7, r2, #4294967295
  40b76a:	d202      	bcs.n	40b772 <__divdi3+0x136>
  40b76c:	4584      	cmp	ip, r0
  40b76e:	f200 80ab 	bhi.w	40b8c8 <__divdi3+0x28c>
  40b772:	463a      	mov	r2, r7
  40b774:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
  40b778:	e7b1      	b.n	40b6de <__divdi3+0xa2>
  40b77a:	43e4      	mvns	r4, r4
  40b77c:	4252      	negs	r2, r2
  40b77e:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
  40b782:	e764      	b.n	40b64e <__divdi3+0x12>
  40b784:	4240      	negs	r0, r0
  40b786:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  40b78a:	f04f 34ff 	mov.w	r4, #4294967295
  40b78e:	e75b      	b.n	40b648 <__divdi3+0xc>
  40b790:	4095      	lsls	r5, r2
  40b792:	f1c2 0320 	rsb	r3, r2, #32
  40b796:	fa27 f103 	lsr.w	r1, r7, r3
  40b79a:	0c28      	lsrs	r0, r5, #16
  40b79c:	fa26 f303 	lsr.w	r3, r6, r3
  40b7a0:	4097      	lsls	r7, r2
  40b7a2:	fbb1 f8f0 	udiv	r8, r1, r0
  40b7a6:	431f      	orrs	r7, r3
  40b7a8:	0c3b      	lsrs	r3, r7, #16
  40b7aa:	fb00 1118 	mls	r1, r0, r8, r1
  40b7ae:	fa1f fc85 	uxth.w	ip, r5
  40b7b2:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
  40b7b6:	fb0c f308 	mul.w	r3, ip, r8
  40b7ba:	428b      	cmp	r3, r1
  40b7bc:	fa06 f602 	lsl.w	r6, r6, r2
  40b7c0:	d908      	bls.n	40b7d4 <__divdi3+0x198>
  40b7c2:	1949      	adds	r1, r1, r5
  40b7c4:	f108 32ff 	add.w	r2, r8, #4294967295
  40b7c8:	d279      	bcs.n	40b8be <__divdi3+0x282>
  40b7ca:	428b      	cmp	r3, r1
  40b7cc:	d977      	bls.n	40b8be <__divdi3+0x282>
  40b7ce:	f1a8 0802 	sub.w	r8, r8, #2
  40b7d2:	4429      	add	r1, r5
  40b7d4:	1ac9      	subs	r1, r1, r3
  40b7d6:	fbb1 f3f0 	udiv	r3, r1, r0
  40b7da:	b2bf      	uxth	r7, r7
  40b7dc:	fb00 1113 	mls	r1, r0, r3, r1
  40b7e0:	ea47 4701 	orr.w	r7, r7, r1, lsl #16
  40b7e4:	fb0c f203 	mul.w	r2, ip, r3
  40b7e8:	42ba      	cmp	r2, r7
  40b7ea:	d907      	bls.n	40b7fc <__divdi3+0x1c0>
  40b7ec:	197f      	adds	r7, r7, r5
  40b7ee:	f103 31ff 	add.w	r1, r3, #4294967295
  40b7f2:	d260      	bcs.n	40b8b6 <__divdi3+0x27a>
  40b7f4:	42ba      	cmp	r2, r7
  40b7f6:	d95e      	bls.n	40b8b6 <__divdi3+0x27a>
  40b7f8:	3b02      	subs	r3, #2
  40b7fa:	442f      	add	r7, r5
  40b7fc:	1abf      	subs	r7, r7, r2
  40b7fe:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
  40b802:	e790      	b.n	40b726 <__divdi3+0xea>
  40b804:	f1c8 0220 	rsb	r2, r8, #32
  40b808:	fa03 fc08 	lsl.w	ip, r3, r8
  40b80c:	fa25 f302 	lsr.w	r3, r5, r2
  40b810:	ea43 0c0c 	orr.w	ip, r3, ip
  40b814:	ea4f 491c 	mov.w	r9, ip, lsr #16
  40b818:	fa21 f302 	lsr.w	r3, r1, r2
  40b81c:	fa01 f708 	lsl.w	r7, r1, r8
  40b820:	fa20 f202 	lsr.w	r2, r0, r2
  40b824:	fbb3 f1f9 	udiv	r1, r3, r9
  40b828:	4317      	orrs	r7, r2
  40b82a:	fb09 3311 	mls	r3, r9, r1, r3
  40b82e:	0c3a      	lsrs	r2, r7, #16
  40b830:	fa1f fb8c 	uxth.w	fp, ip
  40b834:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
  40b838:	fb0b fa01 	mul.w	sl, fp, r1
  40b83c:	459a      	cmp	sl, r3
  40b83e:	fa05 f008 	lsl.w	r0, r5, r8
  40b842:	d908      	bls.n	40b856 <__divdi3+0x21a>
  40b844:	eb13 030c 	adds.w	r3, r3, ip
  40b848:	f101 32ff 	add.w	r2, r1, #4294967295
  40b84c:	d235      	bcs.n	40b8ba <__divdi3+0x27e>
  40b84e:	459a      	cmp	sl, r3
  40b850:	d933      	bls.n	40b8ba <__divdi3+0x27e>
  40b852:	3902      	subs	r1, #2
  40b854:	4463      	add	r3, ip
  40b856:	ebca 0303 	rsb	r3, sl, r3
  40b85a:	fbb3 f2f9 	udiv	r2, r3, r9
  40b85e:	fb09 3312 	mls	r3, r9, r2, r3
  40b862:	b2bf      	uxth	r7, r7
  40b864:	ea47 4703 	orr.w	r7, r7, r3, lsl #16
  40b868:	fb0b f902 	mul.w	r9, fp, r2
  40b86c:	45b9      	cmp	r9, r7
  40b86e:	d908      	bls.n	40b882 <__divdi3+0x246>
  40b870:	eb17 070c 	adds.w	r7, r7, ip
  40b874:	f102 33ff 	add.w	r3, r2, #4294967295
  40b878:	d21b      	bcs.n	40b8b2 <__divdi3+0x276>
  40b87a:	45b9      	cmp	r9, r7
  40b87c:	d919      	bls.n	40b8b2 <__divdi3+0x276>
  40b87e:	3a02      	subs	r2, #2
  40b880:	4467      	add	r7, ip
  40b882:	ea42 4501 	orr.w	r5, r2, r1, lsl #16
  40b886:	fba5 0100 	umull	r0, r1, r5, r0
  40b88a:	ebc9 0707 	rsb	r7, r9, r7
  40b88e:	428f      	cmp	r7, r1
  40b890:	f04f 0300 	mov.w	r3, #0
  40b894:	d30a      	bcc.n	40b8ac <__divdi3+0x270>
  40b896:	d005      	beq.n	40b8a4 <__divdi3+0x268>
  40b898:	462a      	mov	r2, r5
  40b89a:	e720      	b.n	40b6de <__divdi3+0xa2>
  40b89c:	4662      	mov	r2, ip
  40b89e:	e701      	b.n	40b6a4 <__divdi3+0x68>
  40b8a0:	463b      	mov	r3, r7
  40b8a2:	e714      	b.n	40b6ce <__divdi3+0x92>
  40b8a4:	fa06 f608 	lsl.w	r6, r6, r8
  40b8a8:	4286      	cmp	r6, r0
  40b8aa:	d2f5      	bcs.n	40b898 <__divdi3+0x25c>
  40b8ac:	1e6a      	subs	r2, r5, #1
  40b8ae:	2300      	movs	r3, #0
  40b8b0:	e715      	b.n	40b6de <__divdi3+0xa2>
  40b8b2:	461a      	mov	r2, r3
  40b8b4:	e7e5      	b.n	40b882 <__divdi3+0x246>
  40b8b6:	460b      	mov	r3, r1
  40b8b8:	e7a0      	b.n	40b7fc <__divdi3+0x1c0>
  40b8ba:	4611      	mov	r1, r2
  40b8bc:	e7cb      	b.n	40b856 <__divdi3+0x21a>
  40b8be:	4690      	mov	r8, r2
  40b8c0:	e788      	b.n	40b7d4 <__divdi3+0x198>
  40b8c2:	4643      	mov	r3, r8
  40b8c4:	4642      	mov	r2, r8
  40b8c6:	e70a      	b.n	40b6de <__divdi3+0xa2>
  40b8c8:	3a02      	subs	r2, #2
  40b8ca:	e753      	b.n	40b774 <__divdi3+0x138>
  40b8cc:	3902      	subs	r1, #2
  40b8ce:	442f      	add	r7, r5
  40b8d0:	e73c      	b.n	40b74c <__divdi3+0x110>
  40b8d2:	bf00      	nop

0040b8d4 <__udivdi3>:
  40b8d4:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  40b8d8:	4614      	mov	r4, r2
  40b8da:	4605      	mov	r5, r0
  40b8dc:	460e      	mov	r6, r1
  40b8de:	2b00      	cmp	r3, #0
  40b8e0:	d143      	bne.n	40b96a <__udivdi3+0x96>
  40b8e2:	428a      	cmp	r2, r1
  40b8e4:	d953      	bls.n	40b98e <__udivdi3+0xba>
  40b8e6:	fab2 f782 	clz	r7, r2
  40b8ea:	b157      	cbz	r7, 40b902 <__udivdi3+0x2e>
  40b8ec:	f1c7 0620 	rsb	r6, r7, #32
  40b8f0:	fa20 f606 	lsr.w	r6, r0, r6
  40b8f4:	fa01 f307 	lsl.w	r3, r1, r7
  40b8f8:	fa02 f407 	lsl.w	r4, r2, r7
  40b8fc:	431e      	orrs	r6, r3
  40b8fe:	fa00 f507 	lsl.w	r5, r0, r7
  40b902:	0c21      	lsrs	r1, r4, #16
  40b904:	fbb6 f2f1 	udiv	r2, r6, r1
  40b908:	0c2b      	lsrs	r3, r5, #16
  40b90a:	fb01 6712 	mls	r7, r1, r2, r6
  40b90e:	b2a0      	uxth	r0, r4
  40b910:	ea43 4607 	orr.w	r6, r3, r7, lsl #16
  40b914:	fb00 f302 	mul.w	r3, r0, r2
  40b918:	42b3      	cmp	r3, r6
  40b91a:	d909      	bls.n	40b930 <__udivdi3+0x5c>
  40b91c:	1936      	adds	r6, r6, r4
  40b91e:	f102 37ff 	add.w	r7, r2, #4294967295
  40b922:	f080 80f6 	bcs.w	40bb12 <__udivdi3+0x23e>
  40b926:	42b3      	cmp	r3, r6
  40b928:	f240 80f3 	bls.w	40bb12 <__udivdi3+0x23e>
  40b92c:	3a02      	subs	r2, #2
  40b92e:	4426      	add	r6, r4
  40b930:	1af6      	subs	r6, r6, r3
  40b932:	fbb6 f3f1 	udiv	r3, r6, r1
  40b936:	b2ad      	uxth	r5, r5
  40b938:	fb01 6113 	mls	r1, r1, r3, r6
  40b93c:	ea45 4101 	orr.w	r1, r5, r1, lsl #16
  40b940:	fb00 f003 	mul.w	r0, r0, r3
  40b944:	4288      	cmp	r0, r1
  40b946:	d908      	bls.n	40b95a <__udivdi3+0x86>
  40b948:	1909      	adds	r1, r1, r4
  40b94a:	f103 36ff 	add.w	r6, r3, #4294967295
  40b94e:	f080 80e2 	bcs.w	40bb16 <__udivdi3+0x242>
  40b952:	4288      	cmp	r0, r1
  40b954:	f240 80df 	bls.w	40bb16 <__udivdi3+0x242>
  40b958:	3b02      	subs	r3, #2
  40b95a:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
  40b95e:	2300      	movs	r3, #0
  40b960:	4610      	mov	r0, r2
  40b962:	4619      	mov	r1, r3
  40b964:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  40b968:	4770      	bx	lr
  40b96a:	428b      	cmp	r3, r1
  40b96c:	d84a      	bhi.n	40ba04 <__udivdi3+0x130>
  40b96e:	fab3 f683 	clz	r6, r3
  40b972:	2e00      	cmp	r6, #0
  40b974:	d14d      	bne.n	40ba12 <__udivdi3+0x13e>
  40b976:	428b      	cmp	r3, r1
  40b978:	d302      	bcc.n	40b980 <__udivdi3+0xac>
  40b97a:	4282      	cmp	r2, r0
  40b97c:	f200 80d6 	bhi.w	40bb2c <__udivdi3+0x258>
  40b980:	2300      	movs	r3, #0
  40b982:	2201      	movs	r2, #1
  40b984:	4610      	mov	r0, r2
  40b986:	4619      	mov	r1, r3
  40b988:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  40b98c:	4770      	bx	lr
  40b98e:	b912      	cbnz	r2, 40b996 <__udivdi3+0xc2>
  40b990:	2401      	movs	r4, #1
  40b992:	fbb4 f4f2 	udiv	r4, r4, r2
  40b996:	fab4 f284 	clz	r2, r4
  40b99a:	2a00      	cmp	r2, #0
  40b99c:	d17c      	bne.n	40ba98 <__udivdi3+0x1c4>
  40b99e:	1b09      	subs	r1, r1, r4
  40b9a0:	0c26      	lsrs	r6, r4, #16
  40b9a2:	b2a7      	uxth	r7, r4
  40b9a4:	2301      	movs	r3, #1
  40b9a6:	fbb1 f0f6 	udiv	r0, r1, r6
  40b9aa:	0c2a      	lsrs	r2, r5, #16
  40b9ac:	fb06 1110 	mls	r1, r6, r0, r1
  40b9b0:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
  40b9b4:	fb07 f200 	mul.w	r2, r7, r0
  40b9b8:	428a      	cmp	r2, r1
  40b9ba:	d907      	bls.n	40b9cc <__udivdi3+0xf8>
  40b9bc:	1909      	adds	r1, r1, r4
  40b9be:	f100 3cff 	add.w	ip, r0, #4294967295
  40b9c2:	d202      	bcs.n	40b9ca <__udivdi3+0xf6>
  40b9c4:	428a      	cmp	r2, r1
  40b9c6:	f200 80c3 	bhi.w	40bb50 <__udivdi3+0x27c>
  40b9ca:	4660      	mov	r0, ip
  40b9cc:	1a89      	subs	r1, r1, r2
  40b9ce:	fbb1 f2f6 	udiv	r2, r1, r6
  40b9d2:	b2ad      	uxth	r5, r5
  40b9d4:	fb06 1112 	mls	r1, r6, r2, r1
  40b9d8:	ea45 4501 	orr.w	r5, r5, r1, lsl #16
  40b9dc:	fb07 f702 	mul.w	r7, r7, r2
  40b9e0:	42af      	cmp	r7, r5
  40b9e2:	d908      	bls.n	40b9f6 <__udivdi3+0x122>
  40b9e4:	192c      	adds	r4, r5, r4
  40b9e6:	f102 31ff 	add.w	r1, r2, #4294967295
  40b9ea:	f080 8096 	bcs.w	40bb1a <__udivdi3+0x246>
  40b9ee:	42a7      	cmp	r7, r4
  40b9f0:	f240 8093 	bls.w	40bb1a <__udivdi3+0x246>
  40b9f4:	3a02      	subs	r2, #2
  40b9f6:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
  40b9fa:	4610      	mov	r0, r2
  40b9fc:	4619      	mov	r1, r3
  40b9fe:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  40ba02:	4770      	bx	lr
  40ba04:	2300      	movs	r3, #0
  40ba06:	461a      	mov	r2, r3
  40ba08:	4610      	mov	r0, r2
  40ba0a:	4619      	mov	r1, r3
  40ba0c:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  40ba10:	4770      	bx	lr
  40ba12:	f1c6 0520 	rsb	r5, r6, #32
  40ba16:	fa22 f405 	lsr.w	r4, r2, r5
  40ba1a:	40b3      	lsls	r3, r6
  40ba1c:	431c      	orrs	r4, r3
  40ba1e:	ea4f 4814 	mov.w	r8, r4, lsr #16
  40ba22:	fa21 f305 	lsr.w	r3, r1, r5
  40ba26:	fa01 f706 	lsl.w	r7, r1, r6
  40ba2a:	fa20 f505 	lsr.w	r5, r0, r5
  40ba2e:	fbb3 fcf8 	udiv	ip, r3, r8
  40ba32:	432f      	orrs	r7, r5
  40ba34:	fb08 331c 	mls	r3, r8, ip, r3
  40ba38:	0c3d      	lsrs	r5, r7, #16
  40ba3a:	fa1f fa84 	uxth.w	sl, r4
  40ba3e:	ea45 4303 	orr.w	r3, r5, r3, lsl #16
  40ba42:	fb0a f90c 	mul.w	r9, sl, ip
  40ba46:	4599      	cmp	r9, r3
  40ba48:	fa02 fb06 	lsl.w	fp, r2, r6
  40ba4c:	d904      	bls.n	40ba58 <__udivdi3+0x184>
  40ba4e:	191b      	adds	r3, r3, r4
  40ba50:	f10c 32ff 	add.w	r2, ip, #4294967295
  40ba54:	d36d      	bcc.n	40bb32 <__udivdi3+0x25e>
  40ba56:	4694      	mov	ip, r2
  40ba58:	ebc9 0303 	rsb	r3, r9, r3
  40ba5c:	fbb3 f5f8 	udiv	r5, r3, r8
  40ba60:	fb08 3315 	mls	r3, r8, r5, r3
  40ba64:	b2bf      	uxth	r7, r7
  40ba66:	ea47 4703 	orr.w	r7, r7, r3, lsl #16
  40ba6a:	fb0a f805 	mul.w	r8, sl, r5
  40ba6e:	45b8      	cmp	r8, r7
  40ba70:	d904      	bls.n	40ba7c <__udivdi3+0x1a8>
  40ba72:	193f      	adds	r7, r7, r4
  40ba74:	f105 33ff 	add.w	r3, r5, #4294967295
  40ba78:	d361      	bcc.n	40bb3e <__udivdi3+0x26a>
  40ba7a:	461d      	mov	r5, r3
  40ba7c:	ea45 4c0c 	orr.w	ip, r5, ip, lsl #16
  40ba80:	fbac 230b 	umull	r2, r3, ip, fp
  40ba84:	ebc8 0707 	rsb	r7, r8, r7
  40ba88:	429f      	cmp	r7, r3
  40ba8a:	f04f 0500 	mov.w	r5, #0
  40ba8e:	d349      	bcc.n	40bb24 <__udivdi3+0x250>
  40ba90:	d045      	beq.n	40bb1e <__udivdi3+0x24a>
  40ba92:	4662      	mov	r2, ip
  40ba94:	462b      	mov	r3, r5
  40ba96:	e763      	b.n	40b960 <__udivdi3+0x8c>
  40ba98:	4094      	lsls	r4, r2
  40ba9a:	f1c2 0320 	rsb	r3, r2, #32
  40ba9e:	fa21 fc03 	lsr.w	ip, r1, r3
  40baa2:	0c26      	lsrs	r6, r4, #16
  40baa4:	fa20 f303 	lsr.w	r3, r0, r3
  40baa8:	fa01 f502 	lsl.w	r5, r1, r2
  40baac:	fbbc f8f6 	udiv	r8, ip, r6
  40bab0:	ea43 0105 	orr.w	r1, r3, r5
  40bab4:	0c0b      	lsrs	r3, r1, #16
  40bab6:	fb06 cc18 	mls	ip, r6, r8, ip
  40baba:	b2a7      	uxth	r7, r4
  40babc:	ea43 4c0c 	orr.w	ip, r3, ip, lsl #16
  40bac0:	fb07 f308 	mul.w	r3, r7, r8
  40bac4:	4563      	cmp	r3, ip
  40bac6:	fa00 f502 	lsl.w	r5, r0, r2
  40baca:	d909      	bls.n	40bae0 <__udivdi3+0x20c>
  40bacc:	eb1c 0c04 	adds.w	ip, ip, r4
  40bad0:	f108 32ff 	add.w	r2, r8, #4294967295
  40bad4:	d23a      	bcs.n	40bb4c <__udivdi3+0x278>
  40bad6:	4563      	cmp	r3, ip
  40bad8:	d938      	bls.n	40bb4c <__udivdi3+0x278>
  40bada:	f1a8 0802 	sub.w	r8, r8, #2
  40bade:	44a4      	add	ip, r4
  40bae0:	ebc3 0c0c 	rsb	ip, r3, ip
  40bae4:	fbbc f3f6 	udiv	r3, ip, r6
  40bae8:	b289      	uxth	r1, r1
  40baea:	fb06 cc13 	mls	ip, r6, r3, ip
  40baee:	ea41 410c 	orr.w	r1, r1, ip, lsl #16
  40baf2:	fb07 f203 	mul.w	r2, r7, r3
  40baf6:	428a      	cmp	r2, r1
  40baf8:	d907      	bls.n	40bb0a <__udivdi3+0x236>
  40bafa:	1909      	adds	r1, r1, r4
  40bafc:	f103 30ff 	add.w	r0, r3, #4294967295
  40bb00:	d222      	bcs.n	40bb48 <__udivdi3+0x274>
  40bb02:	428a      	cmp	r2, r1
  40bb04:	d920      	bls.n	40bb48 <__udivdi3+0x274>
  40bb06:	3b02      	subs	r3, #2
  40bb08:	4421      	add	r1, r4
  40bb0a:	1a89      	subs	r1, r1, r2
  40bb0c:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
  40bb10:	e749      	b.n	40b9a6 <__udivdi3+0xd2>
  40bb12:	463a      	mov	r2, r7
  40bb14:	e70c      	b.n	40b930 <__udivdi3+0x5c>
  40bb16:	4633      	mov	r3, r6
  40bb18:	e71f      	b.n	40b95a <__udivdi3+0x86>
  40bb1a:	460a      	mov	r2, r1
  40bb1c:	e76b      	b.n	40b9f6 <__udivdi3+0x122>
  40bb1e:	40b0      	lsls	r0, r6
  40bb20:	4290      	cmp	r0, r2
  40bb22:	d2b6      	bcs.n	40ba92 <__udivdi3+0x1be>
  40bb24:	f10c 32ff 	add.w	r2, ip, #4294967295
  40bb28:	2300      	movs	r3, #0
  40bb2a:	e719      	b.n	40b960 <__udivdi3+0x8c>
  40bb2c:	4633      	mov	r3, r6
  40bb2e:	4632      	mov	r2, r6
  40bb30:	e716      	b.n	40b960 <__udivdi3+0x8c>
  40bb32:	4599      	cmp	r9, r3
  40bb34:	d98f      	bls.n	40ba56 <__udivdi3+0x182>
  40bb36:	f1ac 0c02 	sub.w	ip, ip, #2
  40bb3a:	4423      	add	r3, r4
  40bb3c:	e78c      	b.n	40ba58 <__udivdi3+0x184>
  40bb3e:	45b8      	cmp	r8, r7
  40bb40:	d99b      	bls.n	40ba7a <__udivdi3+0x1a6>
  40bb42:	3d02      	subs	r5, #2
  40bb44:	4427      	add	r7, r4
  40bb46:	e799      	b.n	40ba7c <__udivdi3+0x1a8>
  40bb48:	4603      	mov	r3, r0
  40bb4a:	e7de      	b.n	40bb0a <__udivdi3+0x236>
  40bb4c:	4690      	mov	r8, r2
  40bb4e:	e7c7      	b.n	40bae0 <__udivdi3+0x20c>
  40bb50:	3802      	subs	r0, #2
  40bb52:	4421      	add	r1, r4
  40bb54:	e73a      	b.n	40b9cc <__udivdi3+0xf8>
  40bb56:	bf00      	nop

0040bb58 <__libc_init_array>:
  40bb58:	b570      	push	{r4, r5, r6, lr}
  40bb5a:	4e0f      	ldr	r6, [pc, #60]	; (40bb98 <__libc_init_array+0x40>)
  40bb5c:	4d0f      	ldr	r5, [pc, #60]	; (40bb9c <__libc_init_array+0x44>)
  40bb5e:	1b76      	subs	r6, r6, r5
  40bb60:	10b6      	asrs	r6, r6, #2
  40bb62:	d007      	beq.n	40bb74 <__libc_init_array+0x1c>
  40bb64:	3d04      	subs	r5, #4
  40bb66:	2400      	movs	r4, #0
  40bb68:	3401      	adds	r4, #1
  40bb6a:	f855 3f04 	ldr.w	r3, [r5, #4]!
  40bb6e:	4798      	blx	r3
  40bb70:	42a6      	cmp	r6, r4
  40bb72:	d1f9      	bne.n	40bb68 <__libc_init_array+0x10>
  40bb74:	4e0a      	ldr	r6, [pc, #40]	; (40bba0 <__libc_init_array+0x48>)
  40bb76:	4d0b      	ldr	r5, [pc, #44]	; (40bba4 <__libc_init_array+0x4c>)
  40bb78:	1b76      	subs	r6, r6, r5
  40bb7a:	f00b fb79 	bl	417270 <_init>
  40bb7e:	10b6      	asrs	r6, r6, #2
  40bb80:	d008      	beq.n	40bb94 <__libc_init_array+0x3c>
  40bb82:	3d04      	subs	r5, #4
  40bb84:	2400      	movs	r4, #0
  40bb86:	3401      	adds	r4, #1
  40bb88:	f855 3f04 	ldr.w	r3, [r5, #4]!
  40bb8c:	4798      	blx	r3
  40bb8e:	42a6      	cmp	r6, r4
  40bb90:	d1f9      	bne.n	40bb86 <__libc_init_array+0x2e>
  40bb92:	bd70      	pop	{r4, r5, r6, pc}
  40bb94:	bd70      	pop	{r4, r5, r6, pc}
  40bb96:	bf00      	nop
  40bb98:	0041727c 	.word	0x0041727c
  40bb9c:	0041727c 	.word	0x0041727c
  40bba0:	00417284 	.word	0x00417284
  40bba4:	0041727c 	.word	0x0041727c

0040bba8 <iprintf>:
  40bba8:	b40f      	push	{r0, r1, r2, r3}
  40bbaa:	b500      	push	{lr}
  40bbac:	4a07      	ldr	r2, [pc, #28]	; (40bbcc <iprintf+0x24>)
  40bbae:	b083      	sub	sp, #12
  40bbb0:	ab04      	add	r3, sp, #16
  40bbb2:	6810      	ldr	r0, [r2, #0]
  40bbb4:	f853 2b04 	ldr.w	r2, [r3], #4
  40bbb8:	6881      	ldr	r1, [r0, #8]
  40bbba:	9301      	str	r3, [sp, #4]
  40bbbc:	f003 f9d6 	bl	40ef6c <_vfiprintf_r>
  40bbc0:	b003      	add	sp, #12
  40bbc2:	f85d eb04 	ldr.w	lr, [sp], #4
  40bbc6:	b004      	add	sp, #16
  40bbc8:	4770      	bx	lr
  40bbca:	bf00      	nop
  40bbcc:	20000b30 	.word	0x20000b30

0040bbd0 <malloc>:
  40bbd0:	4b02      	ldr	r3, [pc, #8]	; (40bbdc <malloc+0xc>)
  40bbd2:	4601      	mov	r1, r0
  40bbd4:	6818      	ldr	r0, [r3, #0]
  40bbd6:	f000 b80b 	b.w	40bbf0 <_malloc_r>
  40bbda:	bf00      	nop
  40bbdc:	20000b30 	.word	0x20000b30

0040bbe0 <free>:
  40bbe0:	4b02      	ldr	r3, [pc, #8]	; (40bbec <free+0xc>)
  40bbe2:	4601      	mov	r1, r0
  40bbe4:	6818      	ldr	r0, [r3, #0]
  40bbe6:	f005 ba7b 	b.w	4110e0 <_free_r>
  40bbea:	bf00      	nop
  40bbec:	20000b30 	.word	0x20000b30

0040bbf0 <_malloc_r>:
  40bbf0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40bbf4:	f101 050b 	add.w	r5, r1, #11
  40bbf8:	2d16      	cmp	r5, #22
  40bbfa:	b083      	sub	sp, #12
  40bbfc:	4606      	mov	r6, r0
  40bbfe:	d927      	bls.n	40bc50 <_malloc_r+0x60>
  40bc00:	f035 0507 	bics.w	r5, r5, #7
  40bc04:	d427      	bmi.n	40bc56 <_malloc_r+0x66>
  40bc06:	42a9      	cmp	r1, r5
  40bc08:	d825      	bhi.n	40bc56 <_malloc_r+0x66>
  40bc0a:	4630      	mov	r0, r6
  40bc0c:	f000 fbd0 	bl	40c3b0 <__malloc_lock>
  40bc10:	f5b5 7ffc 	cmp.w	r5, #504	; 0x1f8
  40bc14:	d226      	bcs.n	40bc64 <_malloc_r+0x74>
  40bc16:	4fc1      	ldr	r7, [pc, #772]	; (40bf1c <_malloc_r+0x32c>)
  40bc18:	ea4f 0cd5 	mov.w	ip, r5, lsr #3
  40bc1c:	eb07 03cc 	add.w	r3, r7, ip, lsl #3
  40bc20:	68dc      	ldr	r4, [r3, #12]
  40bc22:	429c      	cmp	r4, r3
  40bc24:	f000 81d2 	beq.w	40bfcc <_malloc_r+0x3dc>
  40bc28:	6863      	ldr	r3, [r4, #4]
  40bc2a:	68e2      	ldr	r2, [r4, #12]
  40bc2c:	68a1      	ldr	r1, [r4, #8]
  40bc2e:	f023 0303 	bic.w	r3, r3, #3
  40bc32:	4423      	add	r3, r4
  40bc34:	4630      	mov	r0, r6
  40bc36:	685d      	ldr	r5, [r3, #4]
  40bc38:	60ca      	str	r2, [r1, #12]
  40bc3a:	f045 0501 	orr.w	r5, r5, #1
  40bc3e:	6091      	str	r1, [r2, #8]
  40bc40:	605d      	str	r5, [r3, #4]
  40bc42:	f000 fbb7 	bl	40c3b4 <__malloc_unlock>
  40bc46:	3408      	adds	r4, #8
  40bc48:	4620      	mov	r0, r4
  40bc4a:	b003      	add	sp, #12
  40bc4c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40bc50:	2510      	movs	r5, #16
  40bc52:	42a9      	cmp	r1, r5
  40bc54:	d9d9      	bls.n	40bc0a <_malloc_r+0x1a>
  40bc56:	2400      	movs	r4, #0
  40bc58:	230c      	movs	r3, #12
  40bc5a:	4620      	mov	r0, r4
  40bc5c:	6033      	str	r3, [r6, #0]
  40bc5e:	b003      	add	sp, #12
  40bc60:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40bc64:	ea5f 2c55 	movs.w	ip, r5, lsr #9
  40bc68:	f000 808a 	beq.w	40bd80 <_malloc_r+0x190>
  40bc6c:	f1bc 0f04 	cmp.w	ip, #4
  40bc70:	f200 8160 	bhi.w	40bf34 <_malloc_r+0x344>
  40bc74:	ea4f 1c95 	mov.w	ip, r5, lsr #6
  40bc78:	f10c 0c38 	add.w	ip, ip, #56	; 0x38
  40bc7c:	ea4f 014c 	mov.w	r1, ip, lsl #1
  40bc80:	4fa6      	ldr	r7, [pc, #664]	; (40bf1c <_malloc_r+0x32c>)
  40bc82:	eb07 0181 	add.w	r1, r7, r1, lsl #2
  40bc86:	68cc      	ldr	r4, [r1, #12]
  40bc88:	42a1      	cmp	r1, r4
  40bc8a:	d105      	bne.n	40bc98 <_malloc_r+0xa8>
  40bc8c:	e00c      	b.n	40bca8 <_malloc_r+0xb8>
  40bc8e:	2b00      	cmp	r3, #0
  40bc90:	da7a      	bge.n	40bd88 <_malloc_r+0x198>
  40bc92:	68e4      	ldr	r4, [r4, #12]
  40bc94:	42a1      	cmp	r1, r4
  40bc96:	d007      	beq.n	40bca8 <_malloc_r+0xb8>
  40bc98:	6862      	ldr	r2, [r4, #4]
  40bc9a:	f022 0203 	bic.w	r2, r2, #3
  40bc9e:	1b53      	subs	r3, r2, r5
  40bca0:	2b0f      	cmp	r3, #15
  40bca2:	ddf4      	ble.n	40bc8e <_malloc_r+0x9e>
  40bca4:	f10c 3cff 	add.w	ip, ip, #4294967295
  40bca8:	f10c 0c01 	add.w	ip, ip, #1
  40bcac:	4b9b      	ldr	r3, [pc, #620]	; (40bf1c <_malloc_r+0x32c>)
  40bcae:	693c      	ldr	r4, [r7, #16]
  40bcb0:	f103 0e08 	add.w	lr, r3, #8
  40bcb4:	4574      	cmp	r4, lr
  40bcb6:	f000 817e 	beq.w	40bfb6 <_malloc_r+0x3c6>
  40bcba:	6861      	ldr	r1, [r4, #4]
  40bcbc:	f021 0103 	bic.w	r1, r1, #3
  40bcc0:	1b4a      	subs	r2, r1, r5
  40bcc2:	2a0f      	cmp	r2, #15
  40bcc4:	f300 8164 	bgt.w	40bf90 <_malloc_r+0x3a0>
  40bcc8:	2a00      	cmp	r2, #0
  40bcca:	f8c3 e014 	str.w	lr, [r3, #20]
  40bcce:	f8c3 e010 	str.w	lr, [r3, #16]
  40bcd2:	da6a      	bge.n	40bdaa <_malloc_r+0x1ba>
  40bcd4:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
  40bcd8:	f080 813a 	bcs.w	40bf50 <_malloc_r+0x360>
  40bcdc:	08c9      	lsrs	r1, r1, #3
  40bcde:	eb03 00c1 	add.w	r0, r3, r1, lsl #3
  40bce2:	ea4f 08a1 	mov.w	r8, r1, asr #2
  40bce6:	685a      	ldr	r2, [r3, #4]
  40bce8:	6881      	ldr	r1, [r0, #8]
  40bcea:	60a1      	str	r1, [r4, #8]
  40bcec:	f04f 0901 	mov.w	r9, #1
  40bcf0:	fa09 f808 	lsl.w	r8, r9, r8
  40bcf4:	ea48 0202 	orr.w	r2, r8, r2
  40bcf8:	60e0      	str	r0, [r4, #12]
  40bcfa:	605a      	str	r2, [r3, #4]
  40bcfc:	6084      	str	r4, [r0, #8]
  40bcfe:	60cc      	str	r4, [r1, #12]
  40bd00:	ea4f 03ac 	mov.w	r3, ip, asr #2
  40bd04:	2001      	movs	r0, #1
  40bd06:	4098      	lsls	r0, r3
  40bd08:	4290      	cmp	r0, r2
  40bd0a:	d85b      	bhi.n	40bdc4 <_malloc_r+0x1d4>
  40bd0c:	4202      	tst	r2, r0
  40bd0e:	d106      	bne.n	40bd1e <_malloc_r+0x12e>
  40bd10:	f02c 0c03 	bic.w	ip, ip, #3
  40bd14:	0040      	lsls	r0, r0, #1
  40bd16:	4202      	tst	r2, r0
  40bd18:	f10c 0c04 	add.w	ip, ip, #4
  40bd1c:	d0fa      	beq.n	40bd14 <_malloc_r+0x124>
  40bd1e:	eb07 08cc 	add.w	r8, r7, ip, lsl #3
  40bd22:	4644      	mov	r4, r8
  40bd24:	46e1      	mov	r9, ip
  40bd26:	68e3      	ldr	r3, [r4, #12]
  40bd28:	429c      	cmp	r4, r3
  40bd2a:	d107      	bne.n	40bd3c <_malloc_r+0x14c>
  40bd2c:	e145      	b.n	40bfba <_malloc_r+0x3ca>
  40bd2e:	2a00      	cmp	r2, #0
  40bd30:	f280 8156 	bge.w	40bfe0 <_malloc_r+0x3f0>
  40bd34:	68db      	ldr	r3, [r3, #12]
  40bd36:	429c      	cmp	r4, r3
  40bd38:	f000 813f 	beq.w	40bfba <_malloc_r+0x3ca>
  40bd3c:	6859      	ldr	r1, [r3, #4]
  40bd3e:	f021 0103 	bic.w	r1, r1, #3
  40bd42:	1b4a      	subs	r2, r1, r5
  40bd44:	2a0f      	cmp	r2, #15
  40bd46:	ddf2      	ble.n	40bd2e <_malloc_r+0x13e>
  40bd48:	461c      	mov	r4, r3
  40bd4a:	f8d3 c00c 	ldr.w	ip, [r3, #12]
  40bd4e:	f854 8f08 	ldr.w	r8, [r4, #8]!
  40bd52:	1959      	adds	r1, r3, r5
  40bd54:	f045 0901 	orr.w	r9, r5, #1
  40bd58:	f042 0501 	orr.w	r5, r2, #1
  40bd5c:	f8c3 9004 	str.w	r9, [r3, #4]
  40bd60:	4630      	mov	r0, r6
  40bd62:	f8c8 c00c 	str.w	ip, [r8, #12]
  40bd66:	f8cc 8008 	str.w	r8, [ip, #8]
  40bd6a:	6179      	str	r1, [r7, #20]
  40bd6c:	6139      	str	r1, [r7, #16]
  40bd6e:	f8c1 e00c 	str.w	lr, [r1, #12]
  40bd72:	f8c1 e008 	str.w	lr, [r1, #8]
  40bd76:	604d      	str	r5, [r1, #4]
  40bd78:	508a      	str	r2, [r1, r2]
  40bd7a:	f000 fb1b 	bl	40c3b4 <__malloc_unlock>
  40bd7e:	e763      	b.n	40bc48 <_malloc_r+0x58>
  40bd80:	217e      	movs	r1, #126	; 0x7e
  40bd82:	f04f 0c3f 	mov.w	ip, #63	; 0x3f
  40bd86:	e77b      	b.n	40bc80 <_malloc_r+0x90>
  40bd88:	4422      	add	r2, r4
  40bd8a:	68e3      	ldr	r3, [r4, #12]
  40bd8c:	6850      	ldr	r0, [r2, #4]
  40bd8e:	68a1      	ldr	r1, [r4, #8]
  40bd90:	f040 0501 	orr.w	r5, r0, #1
  40bd94:	60cb      	str	r3, [r1, #12]
  40bd96:	4630      	mov	r0, r6
  40bd98:	6099      	str	r1, [r3, #8]
  40bd9a:	6055      	str	r5, [r2, #4]
  40bd9c:	f000 fb0a 	bl	40c3b4 <__malloc_unlock>
  40bda0:	3408      	adds	r4, #8
  40bda2:	4620      	mov	r0, r4
  40bda4:	b003      	add	sp, #12
  40bda6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40bdaa:	4421      	add	r1, r4
  40bdac:	4630      	mov	r0, r6
  40bdae:	684b      	ldr	r3, [r1, #4]
  40bdb0:	f043 0301 	orr.w	r3, r3, #1
  40bdb4:	604b      	str	r3, [r1, #4]
  40bdb6:	f000 fafd 	bl	40c3b4 <__malloc_unlock>
  40bdba:	3408      	adds	r4, #8
  40bdbc:	4620      	mov	r0, r4
  40bdbe:	b003      	add	sp, #12
  40bdc0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40bdc4:	68bc      	ldr	r4, [r7, #8]
  40bdc6:	6863      	ldr	r3, [r4, #4]
  40bdc8:	f023 0903 	bic.w	r9, r3, #3
  40bdcc:	45a9      	cmp	r9, r5
  40bdce:	d304      	bcc.n	40bdda <_malloc_r+0x1ea>
  40bdd0:	ebc5 0309 	rsb	r3, r5, r9
  40bdd4:	2b0f      	cmp	r3, #15
  40bdd6:	f300 8091 	bgt.w	40befc <_malloc_r+0x30c>
  40bdda:	4b51      	ldr	r3, [pc, #324]	; (40bf20 <_malloc_r+0x330>)
  40bddc:	4a51      	ldr	r2, [pc, #324]	; (40bf24 <_malloc_r+0x334>)
  40bdde:	6819      	ldr	r1, [r3, #0]
  40bde0:	6813      	ldr	r3, [r2, #0]
  40bde2:	3301      	adds	r3, #1
  40bde4:	eb05 0a01 	add.w	sl, r5, r1
  40bde8:	eb04 0b09 	add.w	fp, r4, r9
  40bdec:	f000 8161 	beq.w	40c0b2 <_malloc_r+0x4c2>
  40bdf0:	f50a 5a80 	add.w	sl, sl, #4096	; 0x1000
  40bdf4:	f10a 0a0f 	add.w	sl, sl, #15
  40bdf8:	f42a 6a7f 	bic.w	sl, sl, #4080	; 0xff0
  40bdfc:	f02a 0a0f 	bic.w	sl, sl, #15
  40be00:	4630      	mov	r0, r6
  40be02:	4651      	mov	r1, sl
  40be04:	9201      	str	r2, [sp, #4]
  40be06:	f000 fad7 	bl	40c3b8 <_sbrk_r>
  40be0a:	f1b0 3fff 	cmp.w	r0, #4294967295
  40be0e:	4680      	mov	r8, r0
  40be10:	9a01      	ldr	r2, [sp, #4]
  40be12:	f000 8100 	beq.w	40c016 <_malloc_r+0x426>
  40be16:	4583      	cmp	fp, r0
  40be18:	f200 80fa 	bhi.w	40c010 <_malloc_r+0x420>
  40be1c:	f8df c110 	ldr.w	ip, [pc, #272]	; 40bf30 <_malloc_r+0x340>
  40be20:	f8dc 3000 	ldr.w	r3, [ip]
  40be24:	45c3      	cmp	fp, r8
  40be26:	4453      	add	r3, sl
  40be28:	f8cc 3000 	str.w	r3, [ip]
  40be2c:	f000 814a 	beq.w	40c0c4 <_malloc_r+0x4d4>
  40be30:	6812      	ldr	r2, [r2, #0]
  40be32:	493c      	ldr	r1, [pc, #240]	; (40bf24 <_malloc_r+0x334>)
  40be34:	3201      	adds	r2, #1
  40be36:	bf1b      	ittet	ne
  40be38:	ebcb 0b08 	rsbne	fp, fp, r8
  40be3c:	445b      	addne	r3, fp
  40be3e:	f8c1 8000 	streq.w	r8, [r1]
  40be42:	f8cc 3000 	strne.w	r3, [ip]
  40be46:	f018 0307 	ands.w	r3, r8, #7
  40be4a:	f000 8113 	beq.w	40c074 <_malloc_r+0x484>
  40be4e:	f1c3 0208 	rsb	r2, r3, #8
  40be52:	f5c3 5380 	rsb	r3, r3, #4096	; 0x1000
  40be56:	4490      	add	r8, r2
  40be58:	3308      	adds	r3, #8
  40be5a:	44c2      	add	sl, r8
  40be5c:	f3ca 0a0b 	ubfx	sl, sl, #0, #12
  40be60:	ebca 0a03 	rsb	sl, sl, r3
  40be64:	4651      	mov	r1, sl
  40be66:	4630      	mov	r0, r6
  40be68:	f8cd c004 	str.w	ip, [sp, #4]
  40be6c:	f000 faa4 	bl	40c3b8 <_sbrk_r>
  40be70:	1c43      	adds	r3, r0, #1
  40be72:	f8dd c004 	ldr.w	ip, [sp, #4]
  40be76:	f000 8135 	beq.w	40c0e4 <_malloc_r+0x4f4>
  40be7a:	ebc8 0200 	rsb	r2, r8, r0
  40be7e:	4452      	add	r2, sl
  40be80:	f042 0201 	orr.w	r2, r2, #1
  40be84:	f8dc 3000 	ldr.w	r3, [ip]
  40be88:	f8c7 8008 	str.w	r8, [r7, #8]
  40be8c:	4453      	add	r3, sl
  40be8e:	42bc      	cmp	r4, r7
  40be90:	f8c8 2004 	str.w	r2, [r8, #4]
  40be94:	f8cc 3000 	str.w	r3, [ip]
  40be98:	f8df a094 	ldr.w	sl, [pc, #148]	; 40bf30 <_malloc_r+0x340>
  40be9c:	d015      	beq.n	40beca <_malloc_r+0x2da>
  40be9e:	f1b9 0f0f 	cmp.w	r9, #15
  40bea2:	f240 80ea 	bls.w	40c07a <_malloc_r+0x48a>
  40bea6:	6861      	ldr	r1, [r4, #4]
  40bea8:	f1a9 020c 	sub.w	r2, r9, #12
  40beac:	f022 0207 	bic.w	r2, r2, #7
  40beb0:	f001 0e01 	and.w	lr, r1, #1
  40beb4:	18a1      	adds	r1, r4, r2
  40beb6:	2005      	movs	r0, #5
  40beb8:	ea42 0e0e 	orr.w	lr, r2, lr
  40bebc:	2a0f      	cmp	r2, #15
  40bebe:	f8c4 e004 	str.w	lr, [r4, #4]
  40bec2:	6048      	str	r0, [r1, #4]
  40bec4:	6088      	str	r0, [r1, #8]
  40bec6:	f200 8111 	bhi.w	40c0ec <_malloc_r+0x4fc>
  40beca:	4a17      	ldr	r2, [pc, #92]	; (40bf28 <_malloc_r+0x338>)
  40becc:	68bc      	ldr	r4, [r7, #8]
  40bece:	6811      	ldr	r1, [r2, #0]
  40bed0:	428b      	cmp	r3, r1
  40bed2:	bf88      	it	hi
  40bed4:	6013      	strhi	r3, [r2, #0]
  40bed6:	4a15      	ldr	r2, [pc, #84]	; (40bf2c <_malloc_r+0x33c>)
  40bed8:	6811      	ldr	r1, [r2, #0]
  40beda:	428b      	cmp	r3, r1
  40bedc:	bf88      	it	hi
  40bede:	6013      	strhi	r3, [r2, #0]
  40bee0:	6862      	ldr	r2, [r4, #4]
  40bee2:	f022 0203 	bic.w	r2, r2, #3
  40bee6:	4295      	cmp	r5, r2
  40bee8:	ebc5 0302 	rsb	r3, r5, r2
  40beec:	d801      	bhi.n	40bef2 <_malloc_r+0x302>
  40beee:	2b0f      	cmp	r3, #15
  40bef0:	dc04      	bgt.n	40befc <_malloc_r+0x30c>
  40bef2:	4630      	mov	r0, r6
  40bef4:	f000 fa5e 	bl	40c3b4 <__malloc_unlock>
  40bef8:	2400      	movs	r4, #0
  40befa:	e6a5      	b.n	40bc48 <_malloc_r+0x58>
  40befc:	1962      	adds	r2, r4, r5
  40befe:	f043 0301 	orr.w	r3, r3, #1
  40bf02:	f045 0501 	orr.w	r5, r5, #1
  40bf06:	6065      	str	r5, [r4, #4]
  40bf08:	4630      	mov	r0, r6
  40bf0a:	60ba      	str	r2, [r7, #8]
  40bf0c:	6053      	str	r3, [r2, #4]
  40bf0e:	f000 fa51 	bl	40c3b4 <__malloc_unlock>
  40bf12:	3408      	adds	r4, #8
  40bf14:	4620      	mov	r0, r4
  40bf16:	b003      	add	sp, #12
  40bf18:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40bf1c:	20000b34 	.word	0x20000b34
  40bf20:	2000397c 	.word	0x2000397c
  40bf24:	20000f40 	.word	0x20000f40
  40bf28:	20003978 	.word	0x20003978
  40bf2c:	20003974 	.word	0x20003974
  40bf30:	20003980 	.word	0x20003980
  40bf34:	f1bc 0f14 	cmp.w	ip, #20
  40bf38:	d961      	bls.n	40bffe <_malloc_r+0x40e>
  40bf3a:	f1bc 0f54 	cmp.w	ip, #84	; 0x54
  40bf3e:	f200 808f 	bhi.w	40c060 <_malloc_r+0x470>
  40bf42:	ea4f 3c15 	mov.w	ip, r5, lsr #12
  40bf46:	f10c 0c6e 	add.w	ip, ip, #110	; 0x6e
  40bf4a:	ea4f 014c 	mov.w	r1, ip, lsl #1
  40bf4e:	e697      	b.n	40bc80 <_malloc_r+0x90>
  40bf50:	0a4b      	lsrs	r3, r1, #9
  40bf52:	2b04      	cmp	r3, #4
  40bf54:	d958      	bls.n	40c008 <_malloc_r+0x418>
  40bf56:	2b14      	cmp	r3, #20
  40bf58:	f200 80ae 	bhi.w	40c0b8 <_malloc_r+0x4c8>
  40bf5c:	f103 025b 	add.w	r2, r3, #91	; 0x5b
  40bf60:	0050      	lsls	r0, r2, #1
  40bf62:	eb07 0080 	add.w	r0, r7, r0, lsl #2
  40bf66:	f8df 81bc 	ldr.w	r8, [pc, #444]	; 40c124 <_malloc_r+0x534>
  40bf6a:	6883      	ldr	r3, [r0, #8]
  40bf6c:	4283      	cmp	r3, r0
  40bf6e:	f000 808a 	beq.w	40c086 <_malloc_r+0x496>
  40bf72:	685a      	ldr	r2, [r3, #4]
  40bf74:	f022 0203 	bic.w	r2, r2, #3
  40bf78:	4291      	cmp	r1, r2
  40bf7a:	d202      	bcs.n	40bf82 <_malloc_r+0x392>
  40bf7c:	689b      	ldr	r3, [r3, #8]
  40bf7e:	4298      	cmp	r0, r3
  40bf80:	d1f7      	bne.n	40bf72 <_malloc_r+0x382>
  40bf82:	68d9      	ldr	r1, [r3, #12]
  40bf84:	687a      	ldr	r2, [r7, #4]
  40bf86:	60e1      	str	r1, [r4, #12]
  40bf88:	60a3      	str	r3, [r4, #8]
  40bf8a:	608c      	str	r4, [r1, #8]
  40bf8c:	60dc      	str	r4, [r3, #12]
  40bf8e:	e6b7      	b.n	40bd00 <_malloc_r+0x110>
  40bf90:	1961      	adds	r1, r4, r5
  40bf92:	f042 0701 	orr.w	r7, r2, #1
  40bf96:	f045 0501 	orr.w	r5, r5, #1
  40bf9a:	6065      	str	r5, [r4, #4]
  40bf9c:	4630      	mov	r0, r6
  40bf9e:	6159      	str	r1, [r3, #20]
  40bfa0:	6119      	str	r1, [r3, #16]
  40bfa2:	f8c1 e00c 	str.w	lr, [r1, #12]
  40bfa6:	f8c1 e008 	str.w	lr, [r1, #8]
  40bfaa:	604f      	str	r7, [r1, #4]
  40bfac:	508a      	str	r2, [r1, r2]
  40bfae:	3408      	adds	r4, #8
  40bfb0:	f000 fa00 	bl	40c3b4 <__malloc_unlock>
  40bfb4:	e648      	b.n	40bc48 <_malloc_r+0x58>
  40bfb6:	685a      	ldr	r2, [r3, #4]
  40bfb8:	e6a2      	b.n	40bd00 <_malloc_r+0x110>
  40bfba:	f109 0901 	add.w	r9, r9, #1
  40bfbe:	f019 0f03 	tst.w	r9, #3
  40bfc2:	f104 0408 	add.w	r4, r4, #8
  40bfc6:	f47f aeae 	bne.w	40bd26 <_malloc_r+0x136>
  40bfca:	e02d      	b.n	40c028 <_malloc_r+0x438>
  40bfcc:	f104 0308 	add.w	r3, r4, #8
  40bfd0:	6964      	ldr	r4, [r4, #20]
  40bfd2:	42a3      	cmp	r3, r4
  40bfd4:	bf08      	it	eq
  40bfd6:	f10c 0c02 	addeq.w	ip, ip, #2
  40bfda:	f43f ae67 	beq.w	40bcac <_malloc_r+0xbc>
  40bfde:	e623      	b.n	40bc28 <_malloc_r+0x38>
  40bfe0:	4419      	add	r1, r3
  40bfe2:	461c      	mov	r4, r3
  40bfe4:	6848      	ldr	r0, [r1, #4]
  40bfe6:	68db      	ldr	r3, [r3, #12]
  40bfe8:	f854 2f08 	ldr.w	r2, [r4, #8]!
  40bfec:	f040 0501 	orr.w	r5, r0, #1
  40bff0:	604d      	str	r5, [r1, #4]
  40bff2:	4630      	mov	r0, r6
  40bff4:	60d3      	str	r3, [r2, #12]
  40bff6:	609a      	str	r2, [r3, #8]
  40bff8:	f000 f9dc 	bl	40c3b4 <__malloc_unlock>
  40bffc:	e624      	b.n	40bc48 <_malloc_r+0x58>
  40bffe:	f10c 0c5b 	add.w	ip, ip, #91	; 0x5b
  40c002:	ea4f 014c 	mov.w	r1, ip, lsl #1
  40c006:	e63b      	b.n	40bc80 <_malloc_r+0x90>
  40c008:	098a      	lsrs	r2, r1, #6
  40c00a:	3238      	adds	r2, #56	; 0x38
  40c00c:	0050      	lsls	r0, r2, #1
  40c00e:	e7a8      	b.n	40bf62 <_malloc_r+0x372>
  40c010:	42bc      	cmp	r4, r7
  40c012:	f43f af03 	beq.w	40be1c <_malloc_r+0x22c>
  40c016:	68bc      	ldr	r4, [r7, #8]
  40c018:	6862      	ldr	r2, [r4, #4]
  40c01a:	f022 0203 	bic.w	r2, r2, #3
  40c01e:	e762      	b.n	40bee6 <_malloc_r+0x2f6>
  40c020:	f8d8 8000 	ldr.w	r8, [r8]
  40c024:	4598      	cmp	r8, r3
  40c026:	d17b      	bne.n	40c120 <_malloc_r+0x530>
  40c028:	f01c 0f03 	tst.w	ip, #3
  40c02c:	f1a8 0308 	sub.w	r3, r8, #8
  40c030:	f10c 3cff 	add.w	ip, ip, #4294967295
  40c034:	d1f4      	bne.n	40c020 <_malloc_r+0x430>
  40c036:	687b      	ldr	r3, [r7, #4]
  40c038:	ea23 0300 	bic.w	r3, r3, r0
  40c03c:	607b      	str	r3, [r7, #4]
  40c03e:	0040      	lsls	r0, r0, #1
  40c040:	4298      	cmp	r0, r3
  40c042:	f63f aebf 	bhi.w	40bdc4 <_malloc_r+0x1d4>
  40c046:	2800      	cmp	r0, #0
  40c048:	f43f aebc 	beq.w	40bdc4 <_malloc_r+0x1d4>
  40c04c:	4203      	tst	r3, r0
  40c04e:	46cc      	mov	ip, r9
  40c050:	f47f ae65 	bne.w	40bd1e <_malloc_r+0x12e>
  40c054:	0040      	lsls	r0, r0, #1
  40c056:	4203      	tst	r3, r0
  40c058:	f10c 0c04 	add.w	ip, ip, #4
  40c05c:	d0fa      	beq.n	40c054 <_malloc_r+0x464>
  40c05e:	e65e      	b.n	40bd1e <_malloc_r+0x12e>
  40c060:	f5bc 7faa 	cmp.w	ip, #340	; 0x154
  40c064:	d81a      	bhi.n	40c09c <_malloc_r+0x4ac>
  40c066:	ea4f 3cd5 	mov.w	ip, r5, lsr #15
  40c06a:	f10c 0c77 	add.w	ip, ip, #119	; 0x77
  40c06e:	ea4f 014c 	mov.w	r1, ip, lsl #1
  40c072:	e605      	b.n	40bc80 <_malloc_r+0x90>
  40c074:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  40c078:	e6ef      	b.n	40be5a <_malloc_r+0x26a>
  40c07a:	2301      	movs	r3, #1
  40c07c:	f8c8 3004 	str.w	r3, [r8, #4]
  40c080:	4644      	mov	r4, r8
  40c082:	2200      	movs	r2, #0
  40c084:	e72f      	b.n	40bee6 <_malloc_r+0x2f6>
  40c086:	1091      	asrs	r1, r2, #2
  40c088:	2001      	movs	r0, #1
  40c08a:	f8d8 2004 	ldr.w	r2, [r8, #4]
  40c08e:	fa00 f101 	lsl.w	r1, r0, r1
  40c092:	430a      	orrs	r2, r1
  40c094:	f8c8 2004 	str.w	r2, [r8, #4]
  40c098:	4619      	mov	r1, r3
  40c09a:	e774      	b.n	40bf86 <_malloc_r+0x396>
  40c09c:	f240 5354 	movw	r3, #1364	; 0x554
  40c0a0:	459c      	cmp	ip, r3
  40c0a2:	d81b      	bhi.n	40c0dc <_malloc_r+0x4ec>
  40c0a4:	ea4f 4c95 	mov.w	ip, r5, lsr #18
  40c0a8:	f10c 0c7c 	add.w	ip, ip, #124	; 0x7c
  40c0ac:	ea4f 014c 	mov.w	r1, ip, lsl #1
  40c0b0:	e5e6      	b.n	40bc80 <_malloc_r+0x90>
  40c0b2:	f10a 0a10 	add.w	sl, sl, #16
  40c0b6:	e6a3      	b.n	40be00 <_malloc_r+0x210>
  40c0b8:	2b54      	cmp	r3, #84	; 0x54
  40c0ba:	d81f      	bhi.n	40c0fc <_malloc_r+0x50c>
  40c0bc:	0b0a      	lsrs	r2, r1, #12
  40c0be:	326e      	adds	r2, #110	; 0x6e
  40c0c0:	0050      	lsls	r0, r2, #1
  40c0c2:	e74e      	b.n	40bf62 <_malloc_r+0x372>
  40c0c4:	f3cb 010b 	ubfx	r1, fp, #0, #12
  40c0c8:	2900      	cmp	r1, #0
  40c0ca:	f47f aeb1 	bne.w	40be30 <_malloc_r+0x240>
  40c0ce:	eb0a 0109 	add.w	r1, sl, r9
  40c0d2:	68ba      	ldr	r2, [r7, #8]
  40c0d4:	f041 0101 	orr.w	r1, r1, #1
  40c0d8:	6051      	str	r1, [r2, #4]
  40c0da:	e6f6      	b.n	40beca <_malloc_r+0x2da>
  40c0dc:	21fc      	movs	r1, #252	; 0xfc
  40c0de:	f04f 0c7e 	mov.w	ip, #126	; 0x7e
  40c0e2:	e5cd      	b.n	40bc80 <_malloc_r+0x90>
  40c0e4:	2201      	movs	r2, #1
  40c0e6:	f04f 0a00 	mov.w	sl, #0
  40c0ea:	e6cb      	b.n	40be84 <_malloc_r+0x294>
  40c0ec:	f104 0108 	add.w	r1, r4, #8
  40c0f0:	4630      	mov	r0, r6
  40c0f2:	f004 fff5 	bl	4110e0 <_free_r>
  40c0f6:	f8da 3000 	ldr.w	r3, [sl]
  40c0fa:	e6e6      	b.n	40beca <_malloc_r+0x2da>
  40c0fc:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
  40c100:	d803      	bhi.n	40c10a <_malloc_r+0x51a>
  40c102:	0bca      	lsrs	r2, r1, #15
  40c104:	3277      	adds	r2, #119	; 0x77
  40c106:	0050      	lsls	r0, r2, #1
  40c108:	e72b      	b.n	40bf62 <_malloc_r+0x372>
  40c10a:	f240 5254 	movw	r2, #1364	; 0x554
  40c10e:	4293      	cmp	r3, r2
  40c110:	d803      	bhi.n	40c11a <_malloc_r+0x52a>
  40c112:	0c8a      	lsrs	r2, r1, #18
  40c114:	327c      	adds	r2, #124	; 0x7c
  40c116:	0050      	lsls	r0, r2, #1
  40c118:	e723      	b.n	40bf62 <_malloc_r+0x372>
  40c11a:	20fc      	movs	r0, #252	; 0xfc
  40c11c:	227e      	movs	r2, #126	; 0x7e
  40c11e:	e720      	b.n	40bf62 <_malloc_r+0x372>
  40c120:	687b      	ldr	r3, [r7, #4]
  40c122:	e78c      	b.n	40c03e <_malloc_r+0x44e>
  40c124:	20000b34 	.word	0x20000b34

0040c128 <memcpy>:
  40c128:	4684      	mov	ip, r0
  40c12a:	ea41 0300 	orr.w	r3, r1, r0
  40c12e:	f013 0303 	ands.w	r3, r3, #3
  40c132:	d16d      	bne.n	40c210 <memcpy+0xe8>
  40c134:	3a40      	subs	r2, #64	; 0x40
  40c136:	d341      	bcc.n	40c1bc <memcpy+0x94>
  40c138:	f851 3b04 	ldr.w	r3, [r1], #4
  40c13c:	f840 3b04 	str.w	r3, [r0], #4
  40c140:	f851 3b04 	ldr.w	r3, [r1], #4
  40c144:	f840 3b04 	str.w	r3, [r0], #4
  40c148:	f851 3b04 	ldr.w	r3, [r1], #4
  40c14c:	f840 3b04 	str.w	r3, [r0], #4
  40c150:	f851 3b04 	ldr.w	r3, [r1], #4
  40c154:	f840 3b04 	str.w	r3, [r0], #4
  40c158:	f851 3b04 	ldr.w	r3, [r1], #4
  40c15c:	f840 3b04 	str.w	r3, [r0], #4
  40c160:	f851 3b04 	ldr.w	r3, [r1], #4
  40c164:	f840 3b04 	str.w	r3, [r0], #4
  40c168:	f851 3b04 	ldr.w	r3, [r1], #4
  40c16c:	f840 3b04 	str.w	r3, [r0], #4
  40c170:	f851 3b04 	ldr.w	r3, [r1], #4
  40c174:	f840 3b04 	str.w	r3, [r0], #4
  40c178:	f851 3b04 	ldr.w	r3, [r1], #4
  40c17c:	f840 3b04 	str.w	r3, [r0], #4
  40c180:	f851 3b04 	ldr.w	r3, [r1], #4
  40c184:	f840 3b04 	str.w	r3, [r0], #4
  40c188:	f851 3b04 	ldr.w	r3, [r1], #4
  40c18c:	f840 3b04 	str.w	r3, [r0], #4
  40c190:	f851 3b04 	ldr.w	r3, [r1], #4
  40c194:	f840 3b04 	str.w	r3, [r0], #4
  40c198:	f851 3b04 	ldr.w	r3, [r1], #4
  40c19c:	f840 3b04 	str.w	r3, [r0], #4
  40c1a0:	f851 3b04 	ldr.w	r3, [r1], #4
  40c1a4:	f840 3b04 	str.w	r3, [r0], #4
  40c1a8:	f851 3b04 	ldr.w	r3, [r1], #4
  40c1ac:	f840 3b04 	str.w	r3, [r0], #4
  40c1b0:	f851 3b04 	ldr.w	r3, [r1], #4
  40c1b4:	f840 3b04 	str.w	r3, [r0], #4
  40c1b8:	3a40      	subs	r2, #64	; 0x40
  40c1ba:	d2bd      	bcs.n	40c138 <memcpy+0x10>
  40c1bc:	3230      	adds	r2, #48	; 0x30
  40c1be:	d311      	bcc.n	40c1e4 <memcpy+0xbc>
  40c1c0:	f851 3b04 	ldr.w	r3, [r1], #4
  40c1c4:	f840 3b04 	str.w	r3, [r0], #4
  40c1c8:	f851 3b04 	ldr.w	r3, [r1], #4
  40c1cc:	f840 3b04 	str.w	r3, [r0], #4
  40c1d0:	f851 3b04 	ldr.w	r3, [r1], #4
  40c1d4:	f840 3b04 	str.w	r3, [r0], #4
  40c1d8:	f851 3b04 	ldr.w	r3, [r1], #4
  40c1dc:	f840 3b04 	str.w	r3, [r0], #4
  40c1e0:	3a10      	subs	r2, #16
  40c1e2:	d2ed      	bcs.n	40c1c0 <memcpy+0x98>
  40c1e4:	320c      	adds	r2, #12
  40c1e6:	d305      	bcc.n	40c1f4 <memcpy+0xcc>
  40c1e8:	f851 3b04 	ldr.w	r3, [r1], #4
  40c1ec:	f840 3b04 	str.w	r3, [r0], #4
  40c1f0:	3a04      	subs	r2, #4
  40c1f2:	d2f9      	bcs.n	40c1e8 <memcpy+0xc0>
  40c1f4:	3204      	adds	r2, #4
  40c1f6:	d008      	beq.n	40c20a <memcpy+0xe2>
  40c1f8:	07d2      	lsls	r2, r2, #31
  40c1fa:	bf1c      	itt	ne
  40c1fc:	f811 3b01 	ldrbne.w	r3, [r1], #1
  40c200:	f800 3b01 	strbne.w	r3, [r0], #1
  40c204:	d301      	bcc.n	40c20a <memcpy+0xe2>
  40c206:	880b      	ldrh	r3, [r1, #0]
  40c208:	8003      	strh	r3, [r0, #0]
  40c20a:	4660      	mov	r0, ip
  40c20c:	4770      	bx	lr
  40c20e:	bf00      	nop
  40c210:	2a08      	cmp	r2, #8
  40c212:	d313      	bcc.n	40c23c <memcpy+0x114>
  40c214:	078b      	lsls	r3, r1, #30
  40c216:	d08d      	beq.n	40c134 <memcpy+0xc>
  40c218:	f010 0303 	ands.w	r3, r0, #3
  40c21c:	d08a      	beq.n	40c134 <memcpy+0xc>
  40c21e:	f1c3 0304 	rsb	r3, r3, #4
  40c222:	1ad2      	subs	r2, r2, r3
  40c224:	07db      	lsls	r3, r3, #31
  40c226:	bf1c      	itt	ne
  40c228:	f811 3b01 	ldrbne.w	r3, [r1], #1
  40c22c:	f800 3b01 	strbne.w	r3, [r0], #1
  40c230:	d380      	bcc.n	40c134 <memcpy+0xc>
  40c232:	f831 3b02 	ldrh.w	r3, [r1], #2
  40c236:	f820 3b02 	strh.w	r3, [r0], #2
  40c23a:	e77b      	b.n	40c134 <memcpy+0xc>
  40c23c:	3a04      	subs	r2, #4
  40c23e:	d3d9      	bcc.n	40c1f4 <memcpy+0xcc>
  40c240:	3a01      	subs	r2, #1
  40c242:	f811 3b01 	ldrb.w	r3, [r1], #1
  40c246:	f800 3b01 	strb.w	r3, [r0], #1
  40c24a:	d2f9      	bcs.n	40c240 <memcpy+0x118>
  40c24c:	780b      	ldrb	r3, [r1, #0]
  40c24e:	7003      	strb	r3, [r0, #0]
  40c250:	784b      	ldrb	r3, [r1, #1]
  40c252:	7043      	strb	r3, [r0, #1]
  40c254:	788b      	ldrb	r3, [r1, #2]
  40c256:	7083      	strb	r3, [r0, #2]
  40c258:	4660      	mov	r0, ip
  40c25a:	4770      	bx	lr

0040c25c <memmove>:
  40c25c:	4288      	cmp	r0, r1
  40c25e:	b4f0      	push	{r4, r5, r6, r7}
  40c260:	d910      	bls.n	40c284 <memmove+0x28>
  40c262:	188c      	adds	r4, r1, r2
  40c264:	42a0      	cmp	r0, r4
  40c266:	d20d      	bcs.n	40c284 <memmove+0x28>
  40c268:	1885      	adds	r5, r0, r2
  40c26a:	1e53      	subs	r3, r2, #1
  40c26c:	b142      	cbz	r2, 40c280 <memmove+0x24>
  40c26e:	4621      	mov	r1, r4
  40c270:	462a      	mov	r2, r5
  40c272:	f811 4d01 	ldrb.w	r4, [r1, #-1]!
  40c276:	f802 4d01 	strb.w	r4, [r2, #-1]!
  40c27a:	3b01      	subs	r3, #1
  40c27c:	1c5c      	adds	r4, r3, #1
  40c27e:	d1f8      	bne.n	40c272 <memmove+0x16>
  40c280:	bcf0      	pop	{r4, r5, r6, r7}
  40c282:	4770      	bx	lr
  40c284:	2a0f      	cmp	r2, #15
  40c286:	d93f      	bls.n	40c308 <memmove+0xac>
  40c288:	ea40 0301 	orr.w	r3, r0, r1
  40c28c:	079b      	lsls	r3, r3, #30
  40c28e:	d13f      	bne.n	40c310 <memmove+0xb4>
  40c290:	f1a2 0710 	sub.w	r7, r2, #16
  40c294:	093f      	lsrs	r7, r7, #4
  40c296:	eb00 1607 	add.w	r6, r0, r7, lsl #4
  40c29a:	3610      	adds	r6, #16
  40c29c:	460c      	mov	r4, r1
  40c29e:	4603      	mov	r3, r0
  40c2a0:	6825      	ldr	r5, [r4, #0]
  40c2a2:	601d      	str	r5, [r3, #0]
  40c2a4:	6865      	ldr	r5, [r4, #4]
  40c2a6:	605d      	str	r5, [r3, #4]
  40c2a8:	68a5      	ldr	r5, [r4, #8]
  40c2aa:	609d      	str	r5, [r3, #8]
  40c2ac:	68e5      	ldr	r5, [r4, #12]
  40c2ae:	60dd      	str	r5, [r3, #12]
  40c2b0:	3310      	adds	r3, #16
  40c2b2:	42b3      	cmp	r3, r6
  40c2b4:	f104 0410 	add.w	r4, r4, #16
  40c2b8:	d1f2      	bne.n	40c2a0 <memmove+0x44>
  40c2ba:	1c7b      	adds	r3, r7, #1
  40c2bc:	f002 0c0f 	and.w	ip, r2, #15
  40c2c0:	011b      	lsls	r3, r3, #4
  40c2c2:	f1bc 0f03 	cmp.w	ip, #3
  40c2c6:	4419      	add	r1, r3
  40c2c8:	4403      	add	r3, r0
  40c2ca:	d923      	bls.n	40c314 <memmove+0xb8>
  40c2cc:	460e      	mov	r6, r1
  40c2ce:	461d      	mov	r5, r3
  40c2d0:	4664      	mov	r4, ip
  40c2d2:	3c04      	subs	r4, #4
  40c2d4:	f856 7b04 	ldr.w	r7, [r6], #4
  40c2d8:	f845 7b04 	str.w	r7, [r5], #4
  40c2dc:	2c03      	cmp	r4, #3
  40c2de:	d8f8      	bhi.n	40c2d2 <memmove+0x76>
  40c2e0:	f1ac 0404 	sub.w	r4, ip, #4
  40c2e4:	f024 0403 	bic.w	r4, r4, #3
  40c2e8:	3404      	adds	r4, #4
  40c2ea:	f002 0203 	and.w	r2, r2, #3
  40c2ee:	4423      	add	r3, r4
  40c2f0:	4421      	add	r1, r4
  40c2f2:	2a00      	cmp	r2, #0
  40c2f4:	d0c4      	beq.n	40c280 <memmove+0x24>
  40c2f6:	441a      	add	r2, r3
  40c2f8:	f811 4b01 	ldrb.w	r4, [r1], #1
  40c2fc:	f803 4b01 	strb.w	r4, [r3], #1
  40c300:	4293      	cmp	r3, r2
  40c302:	d1f9      	bne.n	40c2f8 <memmove+0x9c>
  40c304:	bcf0      	pop	{r4, r5, r6, r7}
  40c306:	4770      	bx	lr
  40c308:	4603      	mov	r3, r0
  40c30a:	2a00      	cmp	r2, #0
  40c30c:	d1f3      	bne.n	40c2f6 <memmove+0x9a>
  40c30e:	e7b7      	b.n	40c280 <memmove+0x24>
  40c310:	4603      	mov	r3, r0
  40c312:	e7f0      	b.n	40c2f6 <memmove+0x9a>
  40c314:	4662      	mov	r2, ip
  40c316:	2a00      	cmp	r2, #0
  40c318:	d1ed      	bne.n	40c2f6 <memmove+0x9a>
  40c31a:	e7b1      	b.n	40c280 <memmove+0x24>

0040c31c <memset>:
  40c31c:	b4f0      	push	{r4, r5, r6, r7}
  40c31e:	0784      	lsls	r4, r0, #30
  40c320:	d043      	beq.n	40c3aa <memset+0x8e>
  40c322:	1e54      	subs	r4, r2, #1
  40c324:	2a00      	cmp	r2, #0
  40c326:	d03e      	beq.n	40c3a6 <memset+0x8a>
  40c328:	b2cd      	uxtb	r5, r1
  40c32a:	4603      	mov	r3, r0
  40c32c:	e003      	b.n	40c336 <memset+0x1a>
  40c32e:	1e62      	subs	r2, r4, #1
  40c330:	2c00      	cmp	r4, #0
  40c332:	d038      	beq.n	40c3a6 <memset+0x8a>
  40c334:	4614      	mov	r4, r2
  40c336:	f803 5b01 	strb.w	r5, [r3], #1
  40c33a:	079a      	lsls	r2, r3, #30
  40c33c:	d1f7      	bne.n	40c32e <memset+0x12>
  40c33e:	2c03      	cmp	r4, #3
  40c340:	d92a      	bls.n	40c398 <memset+0x7c>
  40c342:	b2cd      	uxtb	r5, r1
  40c344:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
  40c348:	2c0f      	cmp	r4, #15
  40c34a:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
  40c34e:	d915      	bls.n	40c37c <memset+0x60>
  40c350:	f1a4 0710 	sub.w	r7, r4, #16
  40c354:	093f      	lsrs	r7, r7, #4
  40c356:	f103 0610 	add.w	r6, r3, #16
  40c35a:	eb06 1607 	add.w	r6, r6, r7, lsl #4
  40c35e:	461a      	mov	r2, r3
  40c360:	6015      	str	r5, [r2, #0]
  40c362:	6055      	str	r5, [r2, #4]
  40c364:	6095      	str	r5, [r2, #8]
  40c366:	60d5      	str	r5, [r2, #12]
  40c368:	3210      	adds	r2, #16
  40c36a:	42b2      	cmp	r2, r6
  40c36c:	d1f8      	bne.n	40c360 <memset+0x44>
  40c36e:	f004 040f 	and.w	r4, r4, #15
  40c372:	3701      	adds	r7, #1
  40c374:	2c03      	cmp	r4, #3
  40c376:	eb03 1307 	add.w	r3, r3, r7, lsl #4
  40c37a:	d90d      	bls.n	40c398 <memset+0x7c>
  40c37c:	461e      	mov	r6, r3
  40c37e:	4622      	mov	r2, r4
  40c380:	3a04      	subs	r2, #4
  40c382:	2a03      	cmp	r2, #3
  40c384:	f846 5b04 	str.w	r5, [r6], #4
  40c388:	d8fa      	bhi.n	40c380 <memset+0x64>
  40c38a:	1f22      	subs	r2, r4, #4
  40c38c:	f022 0203 	bic.w	r2, r2, #3
  40c390:	3204      	adds	r2, #4
  40c392:	4413      	add	r3, r2
  40c394:	f004 0403 	and.w	r4, r4, #3
  40c398:	b12c      	cbz	r4, 40c3a6 <memset+0x8a>
  40c39a:	b2c9      	uxtb	r1, r1
  40c39c:	441c      	add	r4, r3
  40c39e:	f803 1b01 	strb.w	r1, [r3], #1
  40c3a2:	42a3      	cmp	r3, r4
  40c3a4:	d1fb      	bne.n	40c39e <memset+0x82>
  40c3a6:	bcf0      	pop	{r4, r5, r6, r7}
  40c3a8:	4770      	bx	lr
  40c3aa:	4614      	mov	r4, r2
  40c3ac:	4603      	mov	r3, r0
  40c3ae:	e7c6      	b.n	40c33e <memset+0x22>

0040c3b0 <__malloc_lock>:
  40c3b0:	4770      	bx	lr
  40c3b2:	bf00      	nop

0040c3b4 <__malloc_unlock>:
  40c3b4:	4770      	bx	lr
  40c3b6:	bf00      	nop

0040c3b8 <_sbrk_r>:
  40c3b8:	b538      	push	{r3, r4, r5, lr}
  40c3ba:	4c07      	ldr	r4, [pc, #28]	; (40c3d8 <_sbrk_r+0x20>)
  40c3bc:	2300      	movs	r3, #0
  40c3be:	4605      	mov	r5, r0
  40c3c0:	4608      	mov	r0, r1
  40c3c2:	6023      	str	r3, [r4, #0]
  40c3c4:	f7ff f882 	bl	40b4cc <_sbrk>
  40c3c8:	1c43      	adds	r3, r0, #1
  40c3ca:	d000      	beq.n	40c3ce <_sbrk_r+0x16>
  40c3cc:	bd38      	pop	{r3, r4, r5, pc}
  40c3ce:	6823      	ldr	r3, [r4, #0]
  40c3d0:	2b00      	cmp	r3, #0
  40c3d2:	d0fb      	beq.n	40c3cc <_sbrk_r+0x14>
  40c3d4:	602b      	str	r3, [r5, #0]
  40c3d6:	bd38      	pop	{r3, r4, r5, pc}
  40c3d8:	2000503c 	.word	0x2000503c

0040c3dc <setbuf>:
  40c3dc:	2900      	cmp	r1, #0
  40c3de:	bf0c      	ite	eq
  40c3e0:	2202      	moveq	r2, #2
  40c3e2:	2200      	movne	r2, #0
  40c3e4:	f44f 6380 	mov.w	r3, #1024	; 0x400
  40c3e8:	f000 b800 	b.w	40c3ec <setvbuf>

0040c3ec <setvbuf>:
  40c3ec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  40c3f0:	4c3c      	ldr	r4, [pc, #240]	; (40c4e4 <setvbuf+0xf8>)
  40c3f2:	6825      	ldr	r5, [r4, #0]
  40c3f4:	4688      	mov	r8, r1
  40c3f6:	4604      	mov	r4, r0
  40c3f8:	4616      	mov	r6, r2
  40c3fa:	461f      	mov	r7, r3
  40c3fc:	b115      	cbz	r5, 40c404 <setvbuf+0x18>
  40c3fe:	6bab      	ldr	r3, [r5, #56]	; 0x38
  40c400:	2b00      	cmp	r3, #0
  40c402:	d04f      	beq.n	40c4a4 <setvbuf+0xb8>
  40c404:	2e02      	cmp	r6, #2
  40c406:	d830      	bhi.n	40c46a <setvbuf+0x7e>
  40c408:	2f00      	cmp	r7, #0
  40c40a:	db2e      	blt.n	40c46a <setvbuf+0x7e>
  40c40c:	4628      	mov	r0, r5
  40c40e:	4621      	mov	r1, r4
  40c410:	f004 fd08 	bl	410e24 <_fflush_r>
  40c414:	89a3      	ldrh	r3, [r4, #12]
  40c416:	2200      	movs	r2, #0
  40c418:	6062      	str	r2, [r4, #4]
  40c41a:	61a2      	str	r2, [r4, #24]
  40c41c:	061a      	lsls	r2, r3, #24
  40c41e:	d428      	bmi.n	40c472 <setvbuf+0x86>
  40c420:	f023 0383 	bic.w	r3, r3, #131	; 0x83
  40c424:	b29b      	uxth	r3, r3
  40c426:	2e02      	cmp	r6, #2
  40c428:	81a3      	strh	r3, [r4, #12]
  40c42a:	d02d      	beq.n	40c488 <setvbuf+0x9c>
  40c42c:	f1b8 0f00 	cmp.w	r8, #0
  40c430:	d03c      	beq.n	40c4ac <setvbuf+0xc0>
  40c432:	2e01      	cmp	r6, #1
  40c434:	d013      	beq.n	40c45e <setvbuf+0x72>
  40c436:	b29b      	uxth	r3, r3
  40c438:	f003 0008 	and.w	r0, r3, #8
  40c43c:	4a2a      	ldr	r2, [pc, #168]	; (40c4e8 <setvbuf+0xfc>)
  40c43e:	63ea      	str	r2, [r5, #60]	; 0x3c
  40c440:	b280      	uxth	r0, r0
  40c442:	f8c4 8000 	str.w	r8, [r4]
  40c446:	f8c4 8010 	str.w	r8, [r4, #16]
  40c44a:	6167      	str	r7, [r4, #20]
  40c44c:	b178      	cbz	r0, 40c46e <setvbuf+0x82>
  40c44e:	f013 0f03 	tst.w	r3, #3
  40c452:	bf18      	it	ne
  40c454:	2700      	movne	r7, #0
  40c456:	60a7      	str	r7, [r4, #8]
  40c458:	2000      	movs	r0, #0
  40c45a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40c45e:	f043 0301 	orr.w	r3, r3, #1
  40c462:	427a      	negs	r2, r7
  40c464:	81a3      	strh	r3, [r4, #12]
  40c466:	61a2      	str	r2, [r4, #24]
  40c468:	e7e5      	b.n	40c436 <setvbuf+0x4a>
  40c46a:	f04f 30ff 	mov.w	r0, #4294967295
  40c46e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40c472:	4628      	mov	r0, r5
  40c474:	6921      	ldr	r1, [r4, #16]
  40c476:	f004 fe33 	bl	4110e0 <_free_r>
  40c47a:	89a3      	ldrh	r3, [r4, #12]
  40c47c:	f023 0383 	bic.w	r3, r3, #131	; 0x83
  40c480:	b29b      	uxth	r3, r3
  40c482:	2e02      	cmp	r6, #2
  40c484:	81a3      	strh	r3, [r4, #12]
  40c486:	d1d1      	bne.n	40c42c <setvbuf+0x40>
  40c488:	2000      	movs	r0, #0
  40c48a:	f104 0243 	add.w	r2, r4, #67	; 0x43
  40c48e:	f043 0302 	orr.w	r3, r3, #2
  40c492:	2500      	movs	r5, #0
  40c494:	2101      	movs	r1, #1
  40c496:	81a3      	strh	r3, [r4, #12]
  40c498:	60a5      	str	r5, [r4, #8]
  40c49a:	6022      	str	r2, [r4, #0]
  40c49c:	6122      	str	r2, [r4, #16]
  40c49e:	6161      	str	r1, [r4, #20]
  40c4a0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40c4a4:	4628      	mov	r0, r5
  40c4a6:	f004 fcd9 	bl	410e5c <__sinit>
  40c4aa:	e7ab      	b.n	40c404 <setvbuf+0x18>
  40c4ac:	2f00      	cmp	r7, #0
  40c4ae:	bf08      	it	eq
  40c4b0:	f44f 6780 	moveq.w	r7, #1024	; 0x400
  40c4b4:	4638      	mov	r0, r7
  40c4b6:	f7ff fb8b 	bl	40bbd0 <malloc>
  40c4ba:	4680      	mov	r8, r0
  40c4bc:	b128      	cbz	r0, 40c4ca <setvbuf+0xde>
  40c4be:	89a3      	ldrh	r3, [r4, #12]
  40c4c0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  40c4c4:	b29b      	uxth	r3, r3
  40c4c6:	81a3      	strh	r3, [r4, #12]
  40c4c8:	e7b3      	b.n	40c432 <setvbuf+0x46>
  40c4ca:	f44f 6080 	mov.w	r0, #1024	; 0x400
  40c4ce:	f7ff fb7f 	bl	40bbd0 <malloc>
  40c4d2:	4680      	mov	r8, r0
  40c4d4:	b918      	cbnz	r0, 40c4de <setvbuf+0xf2>
  40c4d6:	89a3      	ldrh	r3, [r4, #12]
  40c4d8:	f04f 30ff 	mov.w	r0, #4294967295
  40c4dc:	e7d5      	b.n	40c48a <setvbuf+0x9e>
  40c4de:	f44f 6780 	mov.w	r7, #1024	; 0x400
  40c4e2:	e7ec      	b.n	40c4be <setvbuf+0xd2>
  40c4e4:	20000b30 	.word	0x20000b30
  40c4e8:	00410e51 	.word	0x00410e51

0040c4ec <snprintf>:
  40c4ec:	b40c      	push	{r2, r3}
  40c4ee:	b5f0      	push	{r4, r5, r6, r7, lr}
  40c4f0:	4b17      	ldr	r3, [pc, #92]	; (40c550 <snprintf+0x64>)
  40c4f2:	1e0c      	subs	r4, r1, #0
  40c4f4:	b09d      	sub	sp, #116	; 0x74
  40c4f6:	681f      	ldr	r7, [r3, #0]
  40c4f8:	db24      	blt.n	40c544 <snprintf+0x58>
  40c4fa:	f44f 7302 	mov.w	r3, #520	; 0x208
  40c4fe:	ad23      	add	r5, sp, #140	; 0x8c
  40c500:	bf14      	ite	ne
  40c502:	f104 36ff 	addne.w	r6, r4, #4294967295
  40c506:	4626      	moveq	r6, r4
  40c508:	9002      	str	r0, [sp, #8]
  40c50a:	9006      	str	r0, [sp, #24]
  40c50c:	f8ad 3014 	strh.w	r3, [sp, #20]
  40c510:	f64f 7eff 	movw	lr, #65535	; 0xffff
  40c514:	462b      	mov	r3, r5
  40c516:	4638      	mov	r0, r7
  40c518:	a902      	add	r1, sp, #8
  40c51a:	9a22      	ldr	r2, [sp, #136]	; 0x88
  40c51c:	9604      	str	r6, [sp, #16]
  40c51e:	9607      	str	r6, [sp, #28]
  40c520:	9501      	str	r5, [sp, #4]
  40c522:	f8ad e016 	strh.w	lr, [sp, #22]
  40c526:	f000 fb2b 	bl	40cb80 <_svfprintf_r>
  40c52a:	1c43      	adds	r3, r0, #1
  40c52c:	bfbc      	itt	lt
  40c52e:	238b      	movlt	r3, #139	; 0x8b
  40c530:	603b      	strlt	r3, [r7, #0]
  40c532:	b114      	cbz	r4, 40c53a <snprintf+0x4e>
  40c534:	9b02      	ldr	r3, [sp, #8]
  40c536:	2200      	movs	r2, #0
  40c538:	701a      	strb	r2, [r3, #0]
  40c53a:	b01d      	add	sp, #116	; 0x74
  40c53c:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  40c540:	b002      	add	sp, #8
  40c542:	4770      	bx	lr
  40c544:	238b      	movs	r3, #139	; 0x8b
  40c546:	603b      	str	r3, [r7, #0]
  40c548:	f04f 30ff 	mov.w	r0, #4294967295
  40c54c:	e7f5      	b.n	40c53a <snprintf+0x4e>
  40c54e:	bf00      	nop
  40c550:	20000b30 	.word	0x20000b30

0040c554 <sprintf>:
  40c554:	b40e      	push	{r1, r2, r3}
  40c556:	b5f0      	push	{r4, r5, r6, r7, lr}
  40c558:	b09c      	sub	sp, #112	; 0x70
  40c55a:	ab21      	add	r3, sp, #132	; 0x84
  40c55c:	490f      	ldr	r1, [pc, #60]	; (40c59c <sprintf+0x48>)
  40c55e:	f853 2b04 	ldr.w	r2, [r3], #4
  40c562:	9301      	str	r3, [sp, #4]
  40c564:	4605      	mov	r5, r0
  40c566:	f06f 4400 	mvn.w	r4, #2147483648	; 0x80000000
  40c56a:	6808      	ldr	r0, [r1, #0]
  40c56c:	9502      	str	r5, [sp, #8]
  40c56e:	f44f 7702 	mov.w	r7, #520	; 0x208
  40c572:	f64f 76ff 	movw	r6, #65535	; 0xffff
  40c576:	a902      	add	r1, sp, #8
  40c578:	9506      	str	r5, [sp, #24]
  40c57a:	f8ad 7014 	strh.w	r7, [sp, #20]
  40c57e:	9404      	str	r4, [sp, #16]
  40c580:	9407      	str	r4, [sp, #28]
  40c582:	f8ad 6016 	strh.w	r6, [sp, #22]
  40c586:	f000 fafb 	bl	40cb80 <_svfprintf_r>
  40c58a:	9b02      	ldr	r3, [sp, #8]
  40c58c:	2200      	movs	r2, #0
  40c58e:	701a      	strb	r2, [r3, #0]
  40c590:	b01c      	add	sp, #112	; 0x70
  40c592:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  40c596:	b003      	add	sp, #12
  40c598:	4770      	bx	lr
  40c59a:	bf00      	nop
  40c59c:	20000b30 	.word	0x20000b30

0040c5a0 <sscanf>:
  40c5a0:	b40e      	push	{r1, r2, r3}
  40c5a2:	b5f0      	push	{r4, r5, r6, r7, lr}
  40c5a4:	b09c      	sub	sp, #112	; 0x70
  40c5a6:	ac21      	add	r4, sp, #132	; 0x84
  40c5a8:	f44f 7201 	mov.w	r2, #516	; 0x204
  40c5ac:	f854 6b04 	ldr.w	r6, [r4], #4
  40c5b0:	f8ad 2014 	strh.w	r2, [sp, #20]
  40c5b4:	9002      	str	r0, [sp, #8]
  40c5b6:	9006      	str	r0, [sp, #24]
  40c5b8:	f000 f9f4 	bl	40c9a4 <strlen>
  40c5bc:	4b0c      	ldr	r3, [pc, #48]	; (40c5f0 <sscanf+0x50>)
  40c5be:	9401      	str	r4, [sp, #4]
  40c5c0:	4605      	mov	r5, r0
  40c5c2:	4632      	mov	r2, r6
  40c5c4:	4f0b      	ldr	r7, [pc, #44]	; (40c5f4 <sscanf+0x54>)
  40c5c6:	6818      	ldr	r0, [r3, #0]
  40c5c8:	9503      	str	r5, [sp, #12]
  40c5ca:	4623      	mov	r3, r4
  40c5cc:	f64f 76ff 	movw	r6, #65535	; 0xffff
  40c5d0:	2400      	movs	r4, #0
  40c5d2:	a902      	add	r1, sp, #8
  40c5d4:	9507      	str	r5, [sp, #28]
  40c5d6:	970a      	str	r7, [sp, #40]	; 0x28
  40c5d8:	940e      	str	r4, [sp, #56]	; 0x38
  40c5da:	9413      	str	r4, [sp, #76]	; 0x4c
  40c5dc:	f8ad 6016 	strh.w	r6, [sp, #22]
  40c5e0:	f001 fd4a 	bl	40e078 <__ssvfscanf_r>
  40c5e4:	b01c      	add	sp, #112	; 0x70
  40c5e6:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  40c5ea:	b003      	add	sp, #12
  40c5ec:	4770      	bx	lr
  40c5ee:	bf00      	nop
  40c5f0:	20000b30 	.word	0x20000b30
  40c5f4:	0040c61d 	.word	0x0040c61d

0040c5f8 <__sread>:
  40c5f8:	b510      	push	{r4, lr}
  40c5fa:	460c      	mov	r4, r1
  40c5fc:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  40c600:	f005 fd66 	bl	4120d0 <_read_r>
  40c604:	2800      	cmp	r0, #0
  40c606:	db03      	blt.n	40c610 <__sread+0x18>
  40c608:	6d23      	ldr	r3, [r4, #80]	; 0x50
  40c60a:	4403      	add	r3, r0
  40c60c:	6523      	str	r3, [r4, #80]	; 0x50
  40c60e:	bd10      	pop	{r4, pc}
  40c610:	89a3      	ldrh	r3, [r4, #12]
  40c612:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
  40c616:	81a3      	strh	r3, [r4, #12]
  40c618:	bd10      	pop	{r4, pc}
  40c61a:	bf00      	nop

0040c61c <__seofread>:
  40c61c:	2000      	movs	r0, #0
  40c61e:	4770      	bx	lr

0040c620 <__swrite>:
  40c620:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  40c624:	460c      	mov	r4, r1
  40c626:	8989      	ldrh	r1, [r1, #12]
  40c628:	461d      	mov	r5, r3
  40c62a:	05cb      	lsls	r3, r1, #23
  40c62c:	4616      	mov	r6, r2
  40c62e:	4607      	mov	r7, r0
  40c630:	d506      	bpl.n	40c640 <__swrite+0x20>
  40c632:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
  40c636:	2200      	movs	r2, #0
  40c638:	2302      	movs	r3, #2
  40c63a:	f004 ffed 	bl	411618 <_lseek_r>
  40c63e:	89a1      	ldrh	r1, [r4, #12]
  40c640:	f421 5180 	bic.w	r1, r1, #4096	; 0x1000
  40c644:	81a1      	strh	r1, [r4, #12]
  40c646:	4638      	mov	r0, r7
  40c648:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
  40c64c:	4632      	mov	r2, r6
  40c64e:	462b      	mov	r3, r5
  40c650:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  40c654:	f003 baf0 	b.w	40fc38 <_write_r>

0040c658 <__sseek>:
  40c658:	b510      	push	{r4, lr}
  40c65a:	460c      	mov	r4, r1
  40c65c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  40c660:	f004 ffda 	bl	411618 <_lseek_r>
  40c664:	89a3      	ldrh	r3, [r4, #12]
  40c666:	1c42      	adds	r2, r0, #1
  40c668:	bf0e      	itee	eq
  40c66a:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
  40c66e:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
  40c672:	6520      	strne	r0, [r4, #80]	; 0x50
  40c674:	81a3      	strh	r3, [r4, #12]
  40c676:	bd10      	pop	{r4, pc}

0040c678 <__sclose>:
  40c678:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  40c67c:	f003 bb62 	b.w	40fd44 <_close_r>

0040c680 <strcat>:
  40c680:	0783      	lsls	r3, r0, #30
  40c682:	b570      	push	{r4, r5, r6, lr}
  40c684:	4606      	mov	r6, r0
  40c686:	d11f      	bne.n	40c6c8 <strcat+0x48>
  40c688:	6803      	ldr	r3, [r0, #0]
  40c68a:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
  40c68e:	ea22 0303 	bic.w	r3, r2, r3
  40c692:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
  40c696:	bf08      	it	eq
  40c698:	1d03      	addeq	r3, r0, #4
  40c69a:	d115      	bne.n	40c6c8 <strcat+0x48>
  40c69c:	4618      	mov	r0, r3
  40c69e:	f853 4b04 	ldr.w	r4, [r3], #4
  40c6a2:	f1a4 3501 	sub.w	r5, r4, #16843009	; 0x1010101
  40c6a6:	ea25 0404 	bic.w	r4, r5, r4
  40c6aa:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
  40c6ae:	d0f5      	beq.n	40c69c <strcat+0x1c>
  40c6b0:	7803      	ldrb	r3, [r0, #0]
  40c6b2:	b12b      	cbz	r3, 40c6c0 <strcat+0x40>
  40c6b4:	1c43      	adds	r3, r0, #1
  40c6b6:	4618      	mov	r0, r3
  40c6b8:	3301      	adds	r3, #1
  40c6ba:	7804      	ldrb	r4, [r0, #0]
  40c6bc:	2c00      	cmp	r4, #0
  40c6be:	d1fa      	bne.n	40c6b6 <strcat+0x36>
  40c6c0:	f000 f912 	bl	40c8e8 <strcpy>
  40c6c4:	4630      	mov	r0, r6
  40c6c6:	bd70      	pop	{r4, r5, r6, pc}
  40c6c8:	4630      	mov	r0, r6
  40c6ca:	e7f1      	b.n	40c6b0 <strcat+0x30>

0040c6cc <strcmp>:
  40c6cc:	ea40 0c01 	orr.w	ip, r0, r1
  40c6d0:	f01c 0f07 	tst.w	ip, #7
  40c6d4:	d123      	bne.n	40c71e <strcmp+0x52>
  40c6d6:	f1bd 0d10 	subs.w	sp, sp, #16
  40c6da:	e9cd 4502 	strd	r4, r5, [sp, #8]
  40c6de:	e9cd 6700 	strd	r6, r7, [sp]
  40c6e2:	f06f 0600 	mvn.w	r6, #0
  40c6e6:	f04f 0700 	mov.w	r7, #0
  40c6ea:	bf00      	nop
  40c6ec:	e8f0 2302 	ldrd	r2, r3, [r0], #8
  40c6f0:	e8f1 4502 	ldrd	r4, r5, [r1], #8
  40c6f4:	42a2      	cmp	r2, r4
  40c6f6:	fa82 fc46 	uadd8	ip, r2, r6
  40c6fa:	faa7 fc86 	sel	ip, r7, r6
  40c6fe:	bf08      	it	eq
  40c700:	f1bc 0f00 	cmpeq.w	ip, #0
  40c704:	f040 80d7 	bne.w	40c8b6 <strcmp+0x1ea>
  40c708:	42ab      	cmp	r3, r5
  40c70a:	fa83 fc46 	uadd8	ip, r3, r6
  40c70e:	faa7 fc86 	sel	ip, r7, r6
  40c712:	bf08      	it	eq
  40c714:	f1bc 0f00 	cmpeq.w	ip, #0
  40c718:	f040 80ca 	bne.w	40c8b0 <strcmp+0x1e4>
  40c71c:	e7e6      	b.n	40c6ec <strcmp+0x20>
  40c71e:	f010 0c03 	ands.w	ip, r0, #3
  40c722:	d021      	beq.n	40c768 <strcmp+0x9c>
  40c724:	f020 0003 	bic.w	r0, r0, #3
  40c728:	f850 2b04 	ldr.w	r2, [r0], #4
  40c72c:	ea5f 7ccc 	movs.w	ip, ip, lsl #31
  40c730:	d008      	beq.n	40c744 <strcmp+0x78>
  40c732:	d20f      	bcs.n	40c754 <strcmp+0x88>
  40c734:	f811 cb01 	ldrb.w	ip, [r1], #1
  40c738:	fa5f f392 	uxtb.w	r3, r2, ror #8
  40c73c:	ebb3 0c0c 	subs.w	ip, r3, ip
  40c740:	d110      	bne.n	40c764 <strcmp+0x98>
  40c742:	b17b      	cbz	r3, 40c764 <strcmp+0x98>
  40c744:	f811 cb01 	ldrb.w	ip, [r1], #1
  40c748:	fa5f f3a2 	uxtb.w	r3, r2, ror #16
  40c74c:	ebb3 0c0c 	subs.w	ip, r3, ip
  40c750:	d108      	bne.n	40c764 <strcmp+0x98>
  40c752:	b13b      	cbz	r3, 40c764 <strcmp+0x98>
  40c754:	f811 cb01 	ldrb.w	ip, [r1], #1
  40c758:	fa5f f3b2 	uxtb.w	r3, r2, ror #24
  40c75c:	ebb3 0c0c 	subs.w	ip, r3, ip
  40c760:	d100      	bne.n	40c764 <strcmp+0x98>
  40c762:	b90b      	cbnz	r3, 40c768 <strcmp+0x9c>
  40c764:	4660      	mov	r0, ip
  40c766:	4770      	bx	lr
  40c768:	f1bd 0d10 	subs.w	sp, sp, #16
  40c76c:	e9cd 4502 	strd	r4, r5, [sp, #8]
  40c770:	e9cd 6700 	strd	r6, r7, [sp]
  40c774:	f06f 0600 	mvn.w	r6, #0
  40c778:	f04f 0700 	mov.w	r7, #0
  40c77c:	f011 0c03 	ands.w	ip, r1, #3
  40c780:	d12d      	bne.n	40c7de <strcmp+0x112>
  40c782:	f010 0f04 	tst.w	r0, #4
  40c786:	d00d      	beq.n	40c7a4 <strcmp+0xd8>
  40c788:	f850 2b04 	ldr.w	r2, [r0], #4
  40c78c:	f851 4b04 	ldr.w	r4, [r1], #4
  40c790:	42a2      	cmp	r2, r4
  40c792:	fa82 fc46 	uadd8	ip, r2, r6
  40c796:	faa7 fc86 	sel	ip, r7, r6
  40c79a:	bf08      	it	eq
  40c79c:	f1bc 0f00 	cmpeq.w	ip, #0
  40c7a0:	f040 8089 	bne.w	40c8b6 <strcmp+0x1ea>
  40c7a4:	f011 0f04 	tst.w	r1, #4
  40c7a8:	d09f      	beq.n	40c6ea <strcmp+0x1e>
  40c7aa:	f851 5b04 	ldr.w	r5, [r1], #4
  40c7ae:	bf00      	nop
  40c7b0:	e8f0 2302 	ldrd	r2, r3, [r0], #8
  40c7b4:	42aa      	cmp	r2, r5
  40c7b6:	fa82 fc46 	uadd8	ip, r2, r6
  40c7ba:	faa7 fc86 	sel	ip, r7, r6
  40c7be:	bf08      	it	eq
  40c7c0:	f1bc 0f00 	cmpeq.w	ip, #0
  40c7c4:	d171      	bne.n	40c8aa <strcmp+0x1de>
  40c7c6:	e8f1 4502 	ldrd	r4, r5, [r1], #8
  40c7ca:	42a3      	cmp	r3, r4
  40c7cc:	fa83 fc46 	uadd8	ip, r3, r6
  40c7d0:	faa7 fc86 	sel	ip, r7, r6
  40c7d4:	bf08      	it	eq
  40c7d6:	f1bc 0f00 	cmpeq.w	ip, #0
  40c7da:	d163      	bne.n	40c8a4 <strcmp+0x1d8>
  40c7dc:	e7e8      	b.n	40c7b0 <strcmp+0xe4>
  40c7de:	f021 0103 	bic.w	r1, r1, #3
  40c7e2:	f1bc 0f02 	cmp.w	ip, #2
  40c7e6:	d01e      	beq.n	40c826 <strcmp+0x15a>
  40c7e8:	da3b      	bge.n	40c862 <strcmp+0x196>
  40c7ea:	f851 5b04 	ldr.w	r5, [r1], #4
  40c7ee:	bf00      	nop
  40c7f0:	f850 3b04 	ldr.w	r3, [r0], #4
  40c7f4:	ea4f 2515 	mov.w	r5, r5, lsr #8
  40c7f8:	fa83 fc46 	uadd8	ip, r3, r6
  40c7fc:	faa7 fc86 	sel	ip, r7, r6
  40c800:	ebb7 2f0c 	cmp.w	r7, ip, lsl #8
  40c804:	ea03 2216 	and.w	r2, r3, r6, lsr #8
  40c808:	bf08      	it	eq
  40c80a:	42aa      	cmpeq	r2, r5
  40c80c:	d14d      	bne.n	40c8aa <strcmp+0x1de>
  40c80e:	f851 5b04 	ldr.w	r5, [r1], #4
  40c812:	f1bc 0f00 	cmp.w	ip, #0
  40c816:	ea82 0303 	eor.w	r3, r2, r3
  40c81a:	ea4f 6205 	mov.w	r2, r5, lsl #24
  40c81e:	bf08      	it	eq
  40c820:	4293      	cmpeq	r3, r2
  40c822:	d13c      	bne.n	40c89e <strcmp+0x1d2>
  40c824:	e7e4      	b.n	40c7f0 <strcmp+0x124>
  40c826:	f851 5b04 	ldr.w	r5, [r1], #4
  40c82a:	bf00      	nop
  40c82c:	f850 3b04 	ldr.w	r3, [r0], #4
  40c830:	ea4f 4515 	mov.w	r5, r5, lsr #16
  40c834:	fa83 fc46 	uadd8	ip, r3, r6
  40c838:	faa7 fc86 	sel	ip, r7, r6
  40c83c:	ebb7 4f0c 	cmp.w	r7, ip, lsl #16
  40c840:	ea03 4216 	and.w	r2, r3, r6, lsr #16
  40c844:	bf08      	it	eq
  40c846:	42aa      	cmpeq	r2, r5
  40c848:	d12f      	bne.n	40c8aa <strcmp+0x1de>
  40c84a:	f851 5b04 	ldr.w	r5, [r1], #4
  40c84e:	f1bc 0f00 	cmp.w	ip, #0
  40c852:	ea82 0303 	eor.w	r3, r2, r3
  40c856:	ea4f 4205 	mov.w	r2, r5, lsl #16
  40c85a:	bf08      	it	eq
  40c85c:	4293      	cmpeq	r3, r2
  40c85e:	d11e      	bne.n	40c89e <strcmp+0x1d2>
  40c860:	e7e4      	b.n	40c82c <strcmp+0x160>
  40c862:	f851 5b04 	ldr.w	r5, [r1], #4
  40c866:	bf00      	nop
  40c868:	f850 3b04 	ldr.w	r3, [r0], #4
  40c86c:	ea4f 6515 	mov.w	r5, r5, lsr #24
  40c870:	fa83 fc46 	uadd8	ip, r3, r6
  40c874:	faa7 fc86 	sel	ip, r7, r6
  40c878:	ebb7 6f0c 	cmp.w	r7, ip, lsl #24
  40c87c:	ea03 6216 	and.w	r2, r3, r6, lsr #24
  40c880:	bf08      	it	eq
  40c882:	42aa      	cmpeq	r2, r5
  40c884:	d111      	bne.n	40c8aa <strcmp+0x1de>
  40c886:	f851 5b04 	ldr.w	r5, [r1], #4
  40c88a:	f1bc 0f00 	cmp.w	ip, #0
  40c88e:	ea82 0303 	eor.w	r3, r2, r3
  40c892:	ea4f 2205 	mov.w	r2, r5, lsl #8
  40c896:	bf08      	it	eq
  40c898:	4293      	cmpeq	r3, r2
  40c89a:	d100      	bne.n	40c89e <strcmp+0x1d2>
  40c89c:	e7e4      	b.n	40c868 <strcmp+0x19c>
  40c89e:	ba19      	rev	r1, r3
  40c8a0:	ba12      	rev	r2, r2
  40c8a2:	e00a      	b.n	40c8ba <strcmp+0x1ee>
  40c8a4:	ba19      	rev	r1, r3
  40c8a6:	ba22      	rev	r2, r4
  40c8a8:	e007      	b.n	40c8ba <strcmp+0x1ee>
  40c8aa:	ba11      	rev	r1, r2
  40c8ac:	ba2a      	rev	r2, r5
  40c8ae:	e004      	b.n	40c8ba <strcmp+0x1ee>
  40c8b0:	ba19      	rev	r1, r3
  40c8b2:	ba2a      	rev	r2, r5
  40c8b4:	e001      	b.n	40c8ba <strcmp+0x1ee>
  40c8b6:	ba11      	rev	r1, r2
  40c8b8:	ba22      	rev	r2, r4
  40c8ba:	fa9c f08c 	rev.w	r0, ip
  40c8be:	e9dd 6700 	ldrd	r6, r7, [sp]
  40c8c2:	e9dd 4502 	ldrd	r4, r5, [sp, #8]
  40c8c6:	f11d 0d10 	adds.w	sp, sp, #16
  40c8ca:	b138      	cbz	r0, 40c8dc <strcmp+0x210>
  40c8cc:	fab0 f080 	clz	r0, r0
  40c8d0:	f1c0 0018 	rsb	r0, r0, #24
  40c8d4:	fa21 f100 	lsr.w	r1, r1, r0
  40c8d8:	fa22 f200 	lsr.w	r2, r2, r0
  40c8dc:	2001      	movs	r0, #1
  40c8de:	4291      	cmp	r1, r2
  40c8e0:	bf98      	it	ls
  40c8e2:	4180      	sbcls	r0, r0
  40c8e4:	4770      	bx	lr
  40c8e6:	bf00      	nop

0040c8e8 <strcpy>:
  40c8e8:	ea80 0201 	eor.w	r2, r0, r1
  40c8ec:	4684      	mov	ip, r0
  40c8ee:	f012 0f03 	tst.w	r2, #3
  40c8f2:	d14f      	bne.n	40c994 <strcpy+0xac>
  40c8f4:	f011 0f03 	tst.w	r1, #3
  40c8f8:	d132      	bne.n	40c960 <strcpy+0x78>
  40c8fa:	f84d 4d04 	str.w	r4, [sp, #-4]!
  40c8fe:	f011 0f04 	tst.w	r1, #4
  40c902:	f851 3b04 	ldr.w	r3, [r1], #4
  40c906:	d00b      	beq.n	40c920 <strcpy+0x38>
  40c908:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
  40c90c:	439a      	bics	r2, r3
  40c90e:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
  40c912:	bf04      	itt	eq
  40c914:	f84c 3b04 	streq.w	r3, [ip], #4
  40c918:	f851 3b04 	ldreq.w	r3, [r1], #4
  40c91c:	d116      	bne.n	40c94c <strcpy+0x64>
  40c91e:	bf00      	nop
  40c920:	f851 4b04 	ldr.w	r4, [r1], #4
  40c924:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
  40c928:	439a      	bics	r2, r3
  40c92a:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
  40c92e:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
  40c932:	d10b      	bne.n	40c94c <strcpy+0x64>
  40c934:	f84c 3b04 	str.w	r3, [ip], #4
  40c938:	43a2      	bics	r2, r4
  40c93a:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
  40c93e:	bf04      	itt	eq
  40c940:	f851 3b04 	ldreq.w	r3, [r1], #4
  40c944:	f84c 4b04 	streq.w	r4, [ip], #4
  40c948:	d0ea      	beq.n	40c920 <strcpy+0x38>
  40c94a:	4623      	mov	r3, r4
  40c94c:	f80c 3b01 	strb.w	r3, [ip], #1
  40c950:	f013 0fff 	tst.w	r3, #255	; 0xff
  40c954:	ea4f 2333 	mov.w	r3, r3, ror #8
  40c958:	d1f8      	bne.n	40c94c <strcpy+0x64>
  40c95a:	f85d 4b04 	ldr.w	r4, [sp], #4
  40c95e:	4770      	bx	lr
  40c960:	f011 0f01 	tst.w	r1, #1
  40c964:	d006      	beq.n	40c974 <strcpy+0x8c>
  40c966:	f811 2b01 	ldrb.w	r2, [r1], #1
  40c96a:	f80c 2b01 	strb.w	r2, [ip], #1
  40c96e:	2a00      	cmp	r2, #0
  40c970:	bf08      	it	eq
  40c972:	4770      	bxeq	lr
  40c974:	f011 0f02 	tst.w	r1, #2
  40c978:	d0bf      	beq.n	40c8fa <strcpy+0x12>
  40c97a:	f831 2b02 	ldrh.w	r2, [r1], #2
  40c97e:	f012 0fff 	tst.w	r2, #255	; 0xff
  40c982:	bf16      	itet	ne
  40c984:	f82c 2b02 	strhne.w	r2, [ip], #2
  40c988:	f88c 2000 	strbeq.w	r2, [ip]
  40c98c:	f412 4f7f 	tstne.w	r2, #65280	; 0xff00
  40c990:	d1b3      	bne.n	40c8fa <strcpy+0x12>
  40c992:	4770      	bx	lr
  40c994:	f811 2b01 	ldrb.w	r2, [r1], #1
  40c998:	f80c 2b01 	strb.w	r2, [ip], #1
  40c99c:	2a00      	cmp	r2, #0
  40c99e:	d1f9      	bne.n	40c994 <strcpy+0xac>
  40c9a0:	4770      	bx	lr
  40c9a2:	bf00      	nop

0040c9a4 <strlen>:
  40c9a4:	f020 0103 	bic.w	r1, r0, #3
  40c9a8:	f010 0003 	ands.w	r0, r0, #3
  40c9ac:	f1c0 0000 	rsb	r0, r0, #0
  40c9b0:	f851 3b04 	ldr.w	r3, [r1], #4
  40c9b4:	f100 0c04 	add.w	ip, r0, #4
  40c9b8:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
  40c9bc:	f06f 0200 	mvn.w	r2, #0
  40c9c0:	bf1c      	itt	ne
  40c9c2:	fa22 f20c 	lsrne.w	r2, r2, ip
  40c9c6:	4313      	orrne	r3, r2
  40c9c8:	f04f 0c01 	mov.w	ip, #1
  40c9cc:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
  40c9d0:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
  40c9d4:	eba3 020c 	sub.w	r2, r3, ip
  40c9d8:	ea22 0203 	bic.w	r2, r2, r3
  40c9dc:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
  40c9e0:	bf04      	itt	eq
  40c9e2:	f851 3b04 	ldreq.w	r3, [r1], #4
  40c9e6:	3004      	addeq	r0, #4
  40c9e8:	d0f4      	beq.n	40c9d4 <strlen+0x30>
  40c9ea:	f013 0fff 	tst.w	r3, #255	; 0xff
  40c9ee:	bf1f      	itttt	ne
  40c9f0:	3001      	addne	r0, #1
  40c9f2:	f413 4f7f 	tstne.w	r3, #65280	; 0xff00
  40c9f6:	3001      	addne	r0, #1
  40c9f8:	f413 0f7f 	tstne.w	r3, #16711680	; 0xff0000
  40c9fc:	bf18      	it	ne
  40c9fe:	3001      	addne	r0, #1
  40ca00:	4770      	bx	lr
  40ca02:	bf00      	nop

0040ca04 <strncat>:
  40ca04:	0783      	lsls	r3, r0, #30
  40ca06:	b470      	push	{r4, r5, r6}
  40ca08:	d12a      	bne.n	40ca60 <strncat+0x5c>
  40ca0a:	6803      	ldr	r3, [r0, #0]
  40ca0c:	f1a3 3401 	sub.w	r4, r3, #16843009	; 0x1010101
  40ca10:	ea24 0303 	bic.w	r3, r4, r3
  40ca14:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
  40ca18:	bf08      	it	eq
  40ca1a:	1d03      	addeq	r3, r0, #4
  40ca1c:	d120      	bne.n	40ca60 <strncat+0x5c>
  40ca1e:	461c      	mov	r4, r3
  40ca20:	f853 5b04 	ldr.w	r5, [r3], #4
  40ca24:	f1a5 3601 	sub.w	r6, r5, #16843009	; 0x1010101
  40ca28:	ea26 0505 	bic.w	r5, r6, r5
  40ca2c:	f015 3f80 	tst.w	r5, #2155905152	; 0x80808080
  40ca30:	d0f5      	beq.n	40ca1e <strncat+0x1a>
  40ca32:	7823      	ldrb	r3, [r4, #0]
  40ca34:	b12b      	cbz	r3, 40ca42 <strncat+0x3e>
  40ca36:	1c63      	adds	r3, r4, #1
  40ca38:	461c      	mov	r4, r3
  40ca3a:	3301      	adds	r3, #1
  40ca3c:	7825      	ldrb	r5, [r4, #0]
  40ca3e:	2d00      	cmp	r5, #0
  40ca40:	d1fa      	bne.n	40ca38 <strncat+0x34>
  40ca42:	3c01      	subs	r4, #1
  40ca44:	188d      	adds	r5, r1, r2
  40ca46:	e005      	b.n	40ca54 <strncat+0x50>
  40ca48:	f811 3b01 	ldrb.w	r3, [r1], #1
  40ca4c:	f804 3f01 	strb.w	r3, [r4, #1]!
  40ca50:	b123      	cbz	r3, 40ca5c <strncat+0x58>
  40ca52:	b13a      	cbz	r2, 40ca64 <strncat+0x60>
  40ca54:	42a9      	cmp	r1, r5
  40ca56:	f102 32ff 	add.w	r2, r2, #4294967295
  40ca5a:	d1f5      	bne.n	40ca48 <strncat+0x44>
  40ca5c:	bc70      	pop	{r4, r5, r6}
  40ca5e:	4770      	bx	lr
  40ca60:	4604      	mov	r4, r0
  40ca62:	e7e6      	b.n	40ca32 <strncat+0x2e>
  40ca64:	7062      	strb	r2, [r4, #1]
  40ca66:	e7f5      	b.n	40ca54 <strncat+0x50>

0040ca68 <strncmp>:
  40ca68:	b430      	push	{r4, r5}
  40ca6a:	2a00      	cmp	r2, #0
  40ca6c:	d04a      	beq.n	40cb04 <strncmp+0x9c>
  40ca6e:	ea40 0301 	orr.w	r3, r0, r1
  40ca72:	f013 0303 	ands.w	r3, r3, #3
  40ca76:	d12d      	bne.n	40cad4 <strncmp+0x6c>
  40ca78:	2a03      	cmp	r2, #3
  40ca7a:	d92b      	bls.n	40cad4 <strncmp+0x6c>
  40ca7c:	6804      	ldr	r4, [r0, #0]
  40ca7e:	680d      	ldr	r5, [r1, #0]
  40ca80:	42ac      	cmp	r4, r5
  40ca82:	d127      	bne.n	40cad4 <strncmp+0x6c>
  40ca84:	3a04      	subs	r2, #4
  40ca86:	d03d      	beq.n	40cb04 <strncmp+0x9c>
  40ca88:	f1a4 3501 	sub.w	r5, r4, #16843009	; 0x1010101
  40ca8c:	ea25 0404 	bic.w	r4, r5, r4
  40ca90:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
  40ca94:	d13c      	bne.n	40cb10 <strncmp+0xa8>
  40ca96:	460c      	mov	r4, r1
  40ca98:	4603      	mov	r3, r0
  40ca9a:	e00e      	b.n	40caba <strncmp+0x52>
  40ca9c:	685b      	ldr	r3, [r3, #4]
  40ca9e:	6864      	ldr	r4, [r4, #4]
  40caa0:	f1a3 3501 	sub.w	r5, r3, #16843009	; 0x1010101
  40caa4:	42a3      	cmp	r3, r4
  40caa6:	ea25 0503 	bic.w	r5, r5, r3
  40caaa:	d113      	bne.n	40cad4 <strncmp+0x6c>
  40caac:	3a04      	subs	r2, #4
  40caae:	d029      	beq.n	40cb04 <strncmp+0x9c>
  40cab0:	f015 3f80 	tst.w	r5, #2155905152	; 0x80808080
  40cab4:	d129      	bne.n	40cb0a <strncmp+0xa2>
  40cab6:	4603      	mov	r3, r0
  40cab8:	460c      	mov	r4, r1
  40caba:	2a03      	cmp	r2, #3
  40cabc:	f100 0004 	add.w	r0, r0, #4
  40cac0:	f101 0104 	add.w	r1, r1, #4
  40cac4:	d8ea      	bhi.n	40ca9c <strncmp+0x34>
  40cac6:	1e55      	subs	r5, r2, #1
  40cac8:	b92a      	cbnz	r2, 40cad6 <strncmp+0x6e>
  40caca:	7918      	ldrb	r0, [r3, #4]
  40cacc:	7922      	ldrb	r2, [r4, #4]
  40cace:	1a80      	subs	r0, r0, r2
  40cad0:	bc30      	pop	{r4, r5}
  40cad2:	4770      	bx	lr
  40cad4:	1e55      	subs	r5, r2, #1
  40cad6:	7803      	ldrb	r3, [r0, #0]
  40cad8:	780a      	ldrb	r2, [r1, #0]
  40cada:	4293      	cmp	r3, r2
  40cadc:	d11a      	bne.n	40cb14 <strncmp+0xac>
  40cade:	b1dd      	cbz	r5, 40cb18 <strncmp+0xb0>
  40cae0:	b1b3      	cbz	r3, 40cb10 <strncmp+0xa8>
  40cae2:	1c6c      	adds	r4, r5, #1
  40cae4:	440c      	add	r4, r1
  40cae6:	1c8b      	adds	r3, r1, #2
  40cae8:	4601      	mov	r1, r0
  40caea:	e004      	b.n	40caf6 <strncmp+0x8e>
  40caec:	42a3      	cmp	r3, r4
  40caee:	d00c      	beq.n	40cb0a <strncmp+0xa2>
  40caf0:	3301      	adds	r3, #1
  40caf2:	2800      	cmp	r0, #0
  40caf4:	d0ec      	beq.n	40cad0 <strncmp+0x68>
  40caf6:	f811 0f01 	ldrb.w	r0, [r1, #1]!
  40cafa:	f813 2c01 	ldrb.w	r2, [r3, #-1]
  40cafe:	4290      	cmp	r0, r2
  40cb00:	d0f4      	beq.n	40caec <strncmp+0x84>
  40cb02:	e7e4      	b.n	40cace <strncmp+0x66>
  40cb04:	4610      	mov	r0, r2
  40cb06:	bc30      	pop	{r4, r5}
  40cb08:	4770      	bx	lr
  40cb0a:	2000      	movs	r0, #0
  40cb0c:	bc30      	pop	{r4, r5}
  40cb0e:	4770      	bx	lr
  40cb10:	4618      	mov	r0, r3
  40cb12:	e7dd      	b.n	40cad0 <strncmp+0x68>
  40cb14:	4618      	mov	r0, r3
  40cb16:	e7da      	b.n	40cace <strncmp+0x66>
  40cb18:	4628      	mov	r0, r5
  40cb1a:	e7d9      	b.n	40cad0 <strncmp+0x68>

0040cb1c <strncpy>:
  40cb1c:	ea40 0301 	orr.w	r3, r0, r1
  40cb20:	079b      	lsls	r3, r3, #30
  40cb22:	b470      	push	{r4, r5, r6}
  40cb24:	d12a      	bne.n	40cb7c <strncpy+0x60>
  40cb26:	2a03      	cmp	r2, #3
  40cb28:	d928      	bls.n	40cb7c <strncpy+0x60>
  40cb2a:	460c      	mov	r4, r1
  40cb2c:	4603      	mov	r3, r0
  40cb2e:	4621      	mov	r1, r4
  40cb30:	f854 5b04 	ldr.w	r5, [r4], #4
  40cb34:	f1a5 3601 	sub.w	r6, r5, #16843009	; 0x1010101
  40cb38:	ea26 0605 	bic.w	r6, r6, r5
  40cb3c:	f016 3f80 	tst.w	r6, #2155905152	; 0x80808080
  40cb40:	d105      	bne.n	40cb4e <strncpy+0x32>
  40cb42:	3a04      	subs	r2, #4
  40cb44:	2a03      	cmp	r2, #3
  40cb46:	f843 5b04 	str.w	r5, [r3], #4
  40cb4a:	4621      	mov	r1, r4
  40cb4c:	d8ef      	bhi.n	40cb2e <strncpy+0x12>
  40cb4e:	b19a      	cbz	r2, 40cb78 <strncpy+0x5c>
  40cb50:	780c      	ldrb	r4, [r1, #0]
  40cb52:	701c      	strb	r4, [r3, #0]
  40cb54:	3a01      	subs	r2, #1
  40cb56:	3301      	adds	r3, #1
  40cb58:	b13c      	cbz	r4, 40cb6a <strncpy+0x4e>
  40cb5a:	b16a      	cbz	r2, 40cb78 <strncpy+0x5c>
  40cb5c:	f811 4f01 	ldrb.w	r4, [r1, #1]!
  40cb60:	f803 4b01 	strb.w	r4, [r3], #1
  40cb64:	3a01      	subs	r2, #1
  40cb66:	2c00      	cmp	r4, #0
  40cb68:	d1f7      	bne.n	40cb5a <strncpy+0x3e>
  40cb6a:	b12a      	cbz	r2, 40cb78 <strncpy+0x5c>
  40cb6c:	441a      	add	r2, r3
  40cb6e:	2100      	movs	r1, #0
  40cb70:	f803 1b01 	strb.w	r1, [r3], #1
  40cb74:	4293      	cmp	r3, r2
  40cb76:	d1fb      	bne.n	40cb70 <strncpy+0x54>
  40cb78:	bc70      	pop	{r4, r5, r6}
  40cb7a:	4770      	bx	lr
  40cb7c:	4603      	mov	r3, r0
  40cb7e:	e7e6      	b.n	40cb4e <strncpy+0x32>

0040cb80 <_svfprintf_r>:
  40cb80:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40cb84:	b0c9      	sub	sp, #292	; 0x124
  40cb86:	4691      	mov	r9, r2
  40cb88:	9310      	str	r3, [sp, #64]	; 0x40
  40cb8a:	910c      	str	r1, [sp, #48]	; 0x30
  40cb8c:	900d      	str	r0, [sp, #52]	; 0x34
  40cb8e:	f004 fd3f 	bl	411610 <_localeconv_r>
  40cb92:	6800      	ldr	r0, [r0, #0]
  40cb94:	9015      	str	r0, [sp, #84]	; 0x54
  40cb96:	f7ff ff05 	bl	40c9a4 <strlen>
  40cb9a:	9c0c      	ldr	r4, [sp, #48]	; 0x30
  40cb9c:	9018      	str	r0, [sp, #96]	; 0x60
  40cb9e:	89a3      	ldrh	r3, [r4, #12]
  40cba0:	061a      	lsls	r2, r3, #24
  40cba2:	d503      	bpl.n	40cbac <_svfprintf_r+0x2c>
  40cba4:	6923      	ldr	r3, [r4, #16]
  40cba6:	2b00      	cmp	r3, #0
  40cba8:	f001 808d 	beq.w	40dcc6 <_svfprintf_r+0x1146>
  40cbac:	ac38      	add	r4, sp, #224	; 0xe0
  40cbae:	46a4      	mov	ip, r4
  40cbb0:	9408      	str	r4, [sp, #32]
  40cbb2:	942b      	str	r4, [sp, #172]	; 0xac
  40cbb4:	2500      	movs	r5, #0
  40cbb6:	2400      	movs	r4, #0
  40cbb8:	e9cd 4516 	strd	r4, r5, [sp, #88]	; 0x58
  40cbbc:	2300      	movs	r3, #0
  40cbbe:	9311      	str	r3, [sp, #68]	; 0x44
  40cbc0:	932d      	str	r3, [sp, #180]	; 0xb4
  40cbc2:	932c      	str	r3, [sp, #176]	; 0xb0
  40cbc4:	931a      	str	r3, [sp, #104]	; 0x68
  40cbc6:	9319      	str	r3, [sp, #100]	; 0x64
  40cbc8:	930e      	str	r3, [sp, #56]	; 0x38
  40cbca:	4666      	mov	r6, ip
  40cbcc:	f899 3000 	ldrb.w	r3, [r9]
  40cbd0:	2b00      	cmp	r3, #0
  40cbd2:	f000 80f8 	beq.w	40cdc6 <_svfprintf_r+0x246>
  40cbd6:	2b25      	cmp	r3, #37	; 0x25
  40cbd8:	f000 80f5 	beq.w	40cdc6 <_svfprintf_r+0x246>
  40cbdc:	f109 0201 	add.w	r2, r9, #1
  40cbe0:	e001      	b.n	40cbe6 <_svfprintf_r+0x66>
  40cbe2:	2b25      	cmp	r3, #37	; 0x25
  40cbe4:	d004      	beq.n	40cbf0 <_svfprintf_r+0x70>
  40cbe6:	4614      	mov	r4, r2
  40cbe8:	3201      	adds	r2, #1
  40cbea:	7823      	ldrb	r3, [r4, #0]
  40cbec:	2b00      	cmp	r3, #0
  40cbee:	d1f8      	bne.n	40cbe2 <_svfprintf_r+0x62>
  40cbf0:	ebc9 0504 	rsb	r5, r9, r4
  40cbf4:	b17d      	cbz	r5, 40cc16 <_svfprintf_r+0x96>
  40cbf6:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
  40cbf8:	9a2d      	ldr	r2, [sp, #180]	; 0xb4
  40cbfa:	f8c6 9000 	str.w	r9, [r6]
  40cbfe:	3301      	adds	r3, #1
  40cc00:	442a      	add	r2, r5
  40cc02:	2b07      	cmp	r3, #7
  40cc04:	6075      	str	r5, [r6, #4]
  40cc06:	922d      	str	r2, [sp, #180]	; 0xb4
  40cc08:	932c      	str	r3, [sp, #176]	; 0xb0
  40cc0a:	f300 80c2 	bgt.w	40cd92 <_svfprintf_r+0x212>
  40cc0e:	3608      	adds	r6, #8
  40cc10:	980e      	ldr	r0, [sp, #56]	; 0x38
  40cc12:	4428      	add	r0, r5
  40cc14:	900e      	str	r0, [sp, #56]	; 0x38
  40cc16:	7823      	ldrb	r3, [r4, #0]
  40cc18:	2b00      	cmp	r3, #0
  40cc1a:	f000 80c2 	beq.w	40cda2 <_svfprintf_r+0x222>
  40cc1e:	2300      	movs	r3, #0
  40cc20:	f894 8001 	ldrb.w	r8, [r4, #1]
  40cc24:	f88d 308f 	strb.w	r3, [sp, #143]	; 0x8f
  40cc28:	461a      	mov	r2, r3
  40cc2a:	930f      	str	r3, [sp, #60]	; 0x3c
  40cc2c:	9309      	str	r3, [sp, #36]	; 0x24
  40cc2e:	f104 0901 	add.w	r9, r4, #1
  40cc32:	f04f 34ff 	mov.w	r4, #4294967295
  40cc36:	940a      	str	r4, [sp, #40]	; 0x28
  40cc38:	f109 0901 	add.w	r9, r9, #1
  40cc3c:	f1a8 0320 	sub.w	r3, r8, #32
  40cc40:	2b58      	cmp	r3, #88	; 0x58
  40cc42:	f200 83c7 	bhi.w	40d3d4 <_svfprintf_r+0x854>
  40cc46:	e8df f013 	tbh	[pc, r3, lsl #1]
  40cc4a:	026a      	.short	0x026a
  40cc4c:	03c503c5 	.word	0x03c503c5
  40cc50:	03c50271 	.word	0x03c50271
  40cc54:	03c503c5 	.word	0x03c503c5
  40cc58:	03c503c5 	.word	0x03c503c5
  40cc5c:	031403c5 	.word	0x031403c5
  40cc60:	03c50364 	.word	0x03c50364
  40cc64:	00c0009d 	.word	0x00c0009d
  40cc68:	027803c5 	.word	0x027803c5
  40cc6c:	027f027f 	.word	0x027f027f
  40cc70:	027f027f 	.word	0x027f027f
  40cc74:	027f027f 	.word	0x027f027f
  40cc78:	027f027f 	.word	0x027f027f
  40cc7c:	03c5027f 	.word	0x03c5027f
  40cc80:	03c503c5 	.word	0x03c503c5
  40cc84:	03c503c5 	.word	0x03c503c5
  40cc88:	03c503c5 	.word	0x03c503c5
  40cc8c:	03c503c5 	.word	0x03c503c5
  40cc90:	029003c5 	.word	0x029003c5
  40cc94:	03c5036f 	.word	0x03c5036f
  40cc98:	03c5036f 	.word	0x03c5036f
  40cc9c:	03c503c5 	.word	0x03c503c5
  40cca0:	036803c5 	.word	0x036803c5
  40cca4:	03c503c5 	.word	0x03c503c5
  40cca8:	03c50078 	.word	0x03c50078
  40ccac:	03c503c5 	.word	0x03c503c5
  40ccb0:	03c503c5 	.word	0x03c503c5
  40ccb4:	03c50059 	.word	0x03c50059
  40ccb8:	02af03c5 	.word	0x02af03c5
  40ccbc:	03c503c5 	.word	0x03c503c5
  40ccc0:	03c503c5 	.word	0x03c503c5
  40ccc4:	03c503c5 	.word	0x03c503c5
  40ccc8:	03c503c5 	.word	0x03c503c5
  40cccc:	03c503c5 	.word	0x03c503c5
  40ccd0:	03480337 	.word	0x03480337
  40ccd4:	036f036f 	.word	0x036f036f
  40ccd8:	02ff036f 	.word	0x02ff036f
  40ccdc:	03c50348 	.word	0x03c50348
  40cce0:	030803c5 	.word	0x030803c5
  40cce4:	02c503c5 	.word	0x02c503c5
  40cce8:	0321007c 	.word	0x0321007c
  40ccec:	03c503a5 	.word	0x03c503a5
  40ccf0:	03c502d9 	.word	0x03c502d9
  40ccf4:	03c5005f 	.word	0x03c5005f
  40ccf8:	00de03c5 	.word	0x00de03c5
  40ccfc:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
  40cd00:	f04c 0c10 	orr.w	ip, ip, #16
  40cd04:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
  40cd08:	9c09      	ldr	r4, [sp, #36]	; 0x24
  40cd0a:	06a2      	lsls	r2, r4, #26
  40cd0c:	f100 8356 	bmi.w	40d3bc <_svfprintf_r+0x83c>
  40cd10:	9c09      	ldr	r4, [sp, #36]	; 0x24
  40cd12:	06e3      	lsls	r3, r4, #27
  40cd14:	f100 85e0 	bmi.w	40d8d8 <_svfprintf_r+0xd58>
  40cd18:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
  40cd1c:	f01c 0f40 	tst.w	ip, #64	; 0x40
  40cd20:	f000 85da 	beq.w	40d8d8 <_svfprintf_r+0xd58>
  40cd24:	f8dd c040 	ldr.w	ip, [sp, #64]	; 0x40
  40cd28:	f8bc 4000 	ldrh.w	r4, [ip]
  40cd2c:	f10c 0c04 	add.w	ip, ip, #4
  40cd30:	2500      	movs	r5, #0
  40cd32:	2301      	movs	r3, #1
  40cd34:	f8cd c040 	str.w	ip, [sp, #64]	; 0x40
  40cd38:	e08c      	b.n	40ce54 <_svfprintf_r+0x2d4>
  40cd3a:	9d09      	ldr	r5, [sp, #36]	; 0x24
  40cd3c:	f045 0510 	orr.w	r5, r5, #16
  40cd40:	9509      	str	r5, [sp, #36]	; 0x24
  40cd42:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
  40cd46:	f01c 0320 	ands.w	r3, ip, #32
  40cd4a:	f040 832c 	bne.w	40d3a6 <_svfprintf_r+0x826>
  40cd4e:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
  40cd52:	f01c 0210 	ands.w	r2, ip, #16
  40cd56:	f040 85b8 	bne.w	40d8ca <_svfprintf_r+0xd4a>
  40cd5a:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
  40cd5e:	f01c 0340 	ands.w	r3, ip, #64	; 0x40
  40cd62:	f000 85b2 	beq.w	40d8ca <_svfprintf_r+0xd4a>
  40cd66:	f8dd c040 	ldr.w	ip, [sp, #64]	; 0x40
  40cd6a:	f8bc 4000 	ldrh.w	r4, [ip]
  40cd6e:	f10c 0c04 	add.w	ip, ip, #4
  40cd72:	4613      	mov	r3, r2
  40cd74:	2500      	movs	r5, #0
  40cd76:	f8cd c040 	str.w	ip, [sp, #64]	; 0x40
  40cd7a:	e06b      	b.n	40ce54 <_svfprintf_r+0x2d4>
  40cd7c:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
  40cd7e:	9310      	str	r3, [sp, #64]	; 0x40
  40cd80:	4264      	negs	r4, r4
  40cd82:	940f      	str	r4, [sp, #60]	; 0x3c
  40cd84:	9d09      	ldr	r5, [sp, #36]	; 0x24
  40cd86:	f045 0504 	orr.w	r5, r5, #4
  40cd8a:	9509      	str	r5, [sp, #36]	; 0x24
  40cd8c:	f899 8000 	ldrb.w	r8, [r9]
  40cd90:	e752      	b.n	40cc38 <_svfprintf_r+0xb8>
  40cd92:	980d      	ldr	r0, [sp, #52]	; 0x34
  40cd94:	990c      	ldr	r1, [sp, #48]	; 0x30
  40cd96:	aa2b      	add	r2, sp, #172	; 0xac
  40cd98:	f006 fe6a 	bl	413a70 <__ssprint_r>
  40cd9c:	b940      	cbnz	r0, 40cdb0 <_svfprintf_r+0x230>
  40cd9e:	ae38      	add	r6, sp, #224	; 0xe0
  40cda0:	e736      	b.n	40cc10 <_svfprintf_r+0x90>
  40cda2:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
  40cda4:	b123      	cbz	r3, 40cdb0 <_svfprintf_r+0x230>
  40cda6:	980d      	ldr	r0, [sp, #52]	; 0x34
  40cda8:	990c      	ldr	r1, [sp, #48]	; 0x30
  40cdaa:	aa2b      	add	r2, sp, #172	; 0xac
  40cdac:	f006 fe60 	bl	413a70 <__ssprint_r>
  40cdb0:	9c0c      	ldr	r4, [sp, #48]	; 0x30
  40cdb2:	980e      	ldr	r0, [sp, #56]	; 0x38
  40cdb4:	89a3      	ldrh	r3, [r4, #12]
  40cdb6:	f013 0f40 	tst.w	r3, #64	; 0x40
  40cdba:	bf18      	it	ne
  40cdbc:	f04f 30ff 	movne.w	r0, #4294967295
  40cdc0:	b049      	add	sp, #292	; 0x124
  40cdc2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40cdc6:	464c      	mov	r4, r9
  40cdc8:	e725      	b.n	40cc16 <_svfprintf_r+0x96>
  40cdca:	f899 8000 	ldrb.w	r8, [r9]
  40cdce:	f1b8 0f2a 	cmp.w	r8, #42	; 0x2a
  40cdd2:	f109 0001 	add.w	r0, r9, #1
  40cdd6:	f001 8118 	beq.w	40e00a <_svfprintf_r+0x148a>
  40cdda:	f1a8 0330 	sub.w	r3, r8, #48	; 0x30
  40cdde:	2b09      	cmp	r3, #9
  40cde0:	bf98      	it	ls
  40cde2:	2100      	movls	r1, #0
  40cde4:	f201 8077 	bhi.w	40ded6 <_svfprintf_r+0x1356>
  40cde8:	f810 8b01 	ldrb.w	r8, [r0], #1
  40cdec:	eb01 0181 	add.w	r1, r1, r1, lsl #2
  40cdf0:	eb03 0141 	add.w	r1, r3, r1, lsl #1
  40cdf4:	f1a8 0330 	sub.w	r3, r8, #48	; 0x30
  40cdf8:	2b09      	cmp	r3, #9
  40cdfa:	d9f5      	bls.n	40cde8 <_svfprintf_r+0x268>
  40cdfc:	ea41 71e1 	orr.w	r1, r1, r1, asr #31
  40ce00:	910a      	str	r1, [sp, #40]	; 0x28
  40ce02:	4681      	mov	r9, r0
  40ce04:	e71a      	b.n	40cc3c <_svfprintf_r+0xbc>
  40ce06:	9d09      	ldr	r5, [sp, #36]	; 0x24
  40ce08:	4ca1      	ldr	r4, [pc, #644]	; (40d090 <_svfprintf_r+0x510>)
  40ce0a:	941a      	str	r4, [sp, #104]	; 0x68
  40ce0c:	06af      	lsls	r7, r5, #26
  40ce0e:	f88d 208f 	strb.w	r2, [sp, #143]	; 0x8f
  40ce12:	f140 81d1 	bpl.w	40d1b8 <_svfprintf_r+0x638>
  40ce16:	f8dd c040 	ldr.w	ip, [sp, #64]	; 0x40
  40ce1a:	f10c 0307 	add.w	r3, ip, #7
  40ce1e:	f023 0307 	bic.w	r3, r3, #7
  40ce22:	f103 0408 	add.w	r4, r3, #8
  40ce26:	9410      	str	r4, [sp, #64]	; 0x40
  40ce28:	e9d3 4500 	ldrd	r4, r5, [r3]
  40ce2c:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
  40ce30:	f01c 0f01 	tst.w	ip, #1
  40ce34:	f000 8464 	beq.w	40d700 <_svfprintf_r+0xb80>
  40ce38:	ea54 0005 	orrs.w	r0, r4, r5
  40ce3c:	f000 8460 	beq.w	40d700 <_svfprintf_r+0xb80>
  40ce40:	2330      	movs	r3, #48	; 0x30
  40ce42:	f04c 0c02 	orr.w	ip, ip, #2
  40ce46:	f88d 3090 	strb.w	r3, [sp, #144]	; 0x90
  40ce4a:	f88d 8091 	strb.w	r8, [sp, #145]	; 0x91
  40ce4e:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
  40ce52:	2302      	movs	r3, #2
  40ce54:	f04f 0a00 	mov.w	sl, #0
  40ce58:	f88d a08f 	strb.w	sl, [sp, #143]	; 0x8f
  40ce5c:	990a      	ldr	r1, [sp, #40]	; 0x28
  40ce5e:	2900      	cmp	r1, #0
  40ce60:	db05      	blt.n	40ce6e <_svfprintf_r+0x2ee>
  40ce62:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
  40ce66:	f02c 0c80 	bic.w	ip, ip, #128	; 0x80
  40ce6a:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
  40ce6e:	ea54 0005 	orrs.w	r0, r4, r5
  40ce72:	f040 82c7 	bne.w	40d404 <_svfprintf_r+0x884>
  40ce76:	990a      	ldr	r1, [sp, #40]	; 0x28
  40ce78:	2900      	cmp	r1, #0
  40ce7a:	f040 82c3 	bne.w	40d404 <_svfprintf_r+0x884>
  40ce7e:	2b00      	cmp	r3, #0
  40ce80:	f040 843a 	bne.w	40d6f8 <_svfprintf_r+0xb78>
  40ce84:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
  40ce88:	f01c 0f01 	tst.w	ip, #1
  40ce8c:	f000 8434 	beq.w	40d6f8 <_svfprintf_r+0xb78>
  40ce90:	af48      	add	r7, sp, #288	; 0x120
  40ce92:	2330      	movs	r3, #48	; 0x30
  40ce94:	f807 3d41 	strb.w	r3, [r7, #-65]!
  40ce98:	9d08      	ldr	r5, [sp, #32]
  40ce9a:	1bec      	subs	r4, r5, r7
  40ce9c:	f8dd c028 	ldr.w	ip, [sp, #40]	; 0x28
  40cea0:	2500      	movs	r5, #0
  40cea2:	4564      	cmp	r4, ip
  40cea4:	bfa8      	it	ge
  40cea6:	46a4      	movge	ip, r4
  40cea8:	f8cd c02c 	str.w	ip, [sp, #44]	; 0x2c
  40ceac:	9514      	str	r5, [sp, #80]	; 0x50
  40ceae:	f1ba 0f00 	cmp.w	sl, #0
  40ceb2:	d002      	beq.n	40ceba <_svfprintf_r+0x33a>
  40ceb4:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
  40ceb6:	3501      	adds	r5, #1
  40ceb8:	950b      	str	r5, [sp, #44]	; 0x2c
  40ceba:	9b09      	ldr	r3, [sp, #36]	; 0x24
  40cebc:	f013 0302 	ands.w	r3, r3, #2
  40cec0:	9312      	str	r3, [sp, #72]	; 0x48
  40cec2:	d002      	beq.n	40ceca <_svfprintf_r+0x34a>
  40cec4:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
  40cec6:	3502      	adds	r5, #2
  40cec8:	950b      	str	r5, [sp, #44]	; 0x2c
  40ceca:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
  40cece:	f01c 0c84 	ands.w	ip, ip, #132	; 0x84
  40ced2:	f8cd c04c 	str.w	ip, [sp, #76]	; 0x4c
  40ced6:	f040 8292 	bne.w	40d3fe <_svfprintf_r+0x87e>
  40ceda:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
  40cedc:	f8dd c02c 	ldr.w	ip, [sp, #44]	; 0x2c
  40cee0:	ebcc 0b05 	rsb	fp, ip, r5
  40cee4:	f1bb 0f00 	cmp.w	fp, #0
  40cee8:	f340 8289 	ble.w	40d3fe <_svfprintf_r+0x87e>
  40ceec:	f1bb 0f10 	cmp.w	fp, #16
  40cef0:	992d      	ldr	r1, [sp, #180]	; 0xb4
  40cef2:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
  40cef4:	f8df a1a0 	ldr.w	sl, [pc, #416]	; 40d098 <_svfprintf_r+0x518>
  40cef8:	dd2c      	ble.n	40cf54 <_svfprintf_r+0x3d4>
  40cefa:	971b      	str	r7, [sp, #108]	; 0x6c
  40cefc:	4630      	mov	r0, r6
  40cefe:	4657      	mov	r7, sl
  40cf00:	2510      	movs	r5, #16
  40cf02:	46ca      	mov	sl, r9
  40cf04:	9e0c      	ldr	r6, [sp, #48]	; 0x30
  40cf06:	46a1      	mov	r9, r4
  40cf08:	9c0d      	ldr	r4, [sp, #52]	; 0x34
  40cf0a:	e006      	b.n	40cf1a <_svfprintf_r+0x39a>
  40cf0c:	f1ab 0b10 	sub.w	fp, fp, #16
  40cf10:	f1bb 0f10 	cmp.w	fp, #16
  40cf14:	f100 0008 	add.w	r0, r0, #8
  40cf18:	dd17      	ble.n	40cf4a <_svfprintf_r+0x3ca>
  40cf1a:	3201      	adds	r2, #1
  40cf1c:	3110      	adds	r1, #16
  40cf1e:	2a07      	cmp	r2, #7
  40cf20:	912d      	str	r1, [sp, #180]	; 0xb4
  40cf22:	922c      	str	r2, [sp, #176]	; 0xb0
  40cf24:	6007      	str	r7, [r0, #0]
  40cf26:	6045      	str	r5, [r0, #4]
  40cf28:	ddf0      	ble.n	40cf0c <_svfprintf_r+0x38c>
  40cf2a:	4620      	mov	r0, r4
  40cf2c:	4631      	mov	r1, r6
  40cf2e:	aa2b      	add	r2, sp, #172	; 0xac
  40cf30:	f006 fd9e 	bl	413a70 <__ssprint_r>
  40cf34:	2800      	cmp	r0, #0
  40cf36:	f47f af3b 	bne.w	40cdb0 <_svfprintf_r+0x230>
  40cf3a:	f1ab 0b10 	sub.w	fp, fp, #16
  40cf3e:	f1bb 0f10 	cmp.w	fp, #16
  40cf42:	992d      	ldr	r1, [sp, #180]	; 0xb4
  40cf44:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
  40cf46:	a838      	add	r0, sp, #224	; 0xe0
  40cf48:	dce7      	bgt.n	40cf1a <_svfprintf_r+0x39a>
  40cf4a:	464c      	mov	r4, r9
  40cf4c:	46d1      	mov	r9, sl
  40cf4e:	46ba      	mov	sl, r7
  40cf50:	9f1b      	ldr	r7, [sp, #108]	; 0x6c
  40cf52:	4606      	mov	r6, r0
  40cf54:	3201      	adds	r2, #1
  40cf56:	eb0b 0c01 	add.w	ip, fp, r1
  40cf5a:	2a07      	cmp	r2, #7
  40cf5c:	f8cd c0b4 	str.w	ip, [sp, #180]	; 0xb4
  40cf60:	922c      	str	r2, [sp, #176]	; 0xb0
  40cf62:	e886 0c00 	stmia.w	r6, {sl, fp}
  40cf66:	f300 841c 	bgt.w	40d7a2 <_svfprintf_r+0xc22>
  40cf6a:	f89d a08f 	ldrb.w	sl, [sp, #143]	; 0x8f
  40cf6e:	3608      	adds	r6, #8
  40cf70:	f1ba 0f00 	cmp.w	sl, #0
  40cf74:	d00f      	beq.n	40cf96 <_svfprintf_r+0x416>
  40cf76:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
  40cf78:	3301      	adds	r3, #1
  40cf7a:	f10c 0c01 	add.w	ip, ip, #1
  40cf7e:	f10d 018f 	add.w	r1, sp, #143	; 0x8f
  40cf82:	2201      	movs	r2, #1
  40cf84:	2b07      	cmp	r3, #7
  40cf86:	f8cd c0b4 	str.w	ip, [sp, #180]	; 0xb4
  40cf8a:	932c      	str	r3, [sp, #176]	; 0xb0
  40cf8c:	e886 0006 	stmia.w	r6, {r1, r2}
  40cf90:	f300 839a 	bgt.w	40d6c8 <_svfprintf_r+0xb48>
  40cf94:	3608      	adds	r6, #8
  40cf96:	9b12      	ldr	r3, [sp, #72]	; 0x48
  40cf98:	b173      	cbz	r3, 40cfb8 <_svfprintf_r+0x438>
  40cf9a:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
  40cf9c:	3301      	adds	r3, #1
  40cf9e:	f10c 0c02 	add.w	ip, ip, #2
  40cfa2:	a924      	add	r1, sp, #144	; 0x90
  40cfa4:	2202      	movs	r2, #2
  40cfa6:	2b07      	cmp	r3, #7
  40cfa8:	f8cd c0b4 	str.w	ip, [sp, #180]	; 0xb4
  40cfac:	932c      	str	r3, [sp, #176]	; 0xb0
  40cfae:	e886 0006 	stmia.w	r6, {r1, r2}
  40cfb2:	f300 8395 	bgt.w	40d6e0 <_svfprintf_r+0xb60>
  40cfb6:	3608      	adds	r6, #8
  40cfb8:	9d13      	ldr	r5, [sp, #76]	; 0x4c
  40cfba:	2d80      	cmp	r5, #128	; 0x80
  40cfbc:	f000 82cc 	beq.w	40d558 <_svfprintf_r+0x9d8>
  40cfc0:	9d0a      	ldr	r5, [sp, #40]	; 0x28
  40cfc2:	ebc4 0a05 	rsb	sl, r4, r5
  40cfc6:	f1ba 0f00 	cmp.w	sl, #0
  40cfca:	dd3b      	ble.n	40d044 <_svfprintf_r+0x4c4>
  40cfcc:	f1ba 0f10 	cmp.w	sl, #16
  40cfd0:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
  40cfd2:	4d30      	ldr	r5, [pc, #192]	; (40d094 <_svfprintf_r+0x514>)
  40cfd4:	dd2b      	ble.n	40d02e <_svfprintf_r+0x4ae>
  40cfd6:	940a      	str	r4, [sp, #40]	; 0x28
  40cfd8:	4632      	mov	r2, r6
  40cfda:	f04f 0b10 	mov.w	fp, #16
  40cfde:	462e      	mov	r6, r5
  40cfe0:	4661      	mov	r1, ip
  40cfe2:	9c0d      	ldr	r4, [sp, #52]	; 0x34
  40cfe4:	9d0c      	ldr	r5, [sp, #48]	; 0x30
  40cfe6:	e006      	b.n	40cff6 <_svfprintf_r+0x476>
  40cfe8:	f1aa 0a10 	sub.w	sl, sl, #16
  40cfec:	f1ba 0f10 	cmp.w	sl, #16
  40cff0:	f102 0208 	add.w	r2, r2, #8
  40cff4:	dd17      	ble.n	40d026 <_svfprintf_r+0x4a6>
  40cff6:	3301      	adds	r3, #1
  40cff8:	3110      	adds	r1, #16
  40cffa:	2b07      	cmp	r3, #7
  40cffc:	912d      	str	r1, [sp, #180]	; 0xb4
  40cffe:	932c      	str	r3, [sp, #176]	; 0xb0
  40d000:	e882 0840 	stmia.w	r2, {r6, fp}
  40d004:	ddf0      	ble.n	40cfe8 <_svfprintf_r+0x468>
  40d006:	4620      	mov	r0, r4
  40d008:	4629      	mov	r1, r5
  40d00a:	aa2b      	add	r2, sp, #172	; 0xac
  40d00c:	f006 fd30 	bl	413a70 <__ssprint_r>
  40d010:	2800      	cmp	r0, #0
  40d012:	f47f aecd 	bne.w	40cdb0 <_svfprintf_r+0x230>
  40d016:	f1aa 0a10 	sub.w	sl, sl, #16
  40d01a:	f1ba 0f10 	cmp.w	sl, #16
  40d01e:	992d      	ldr	r1, [sp, #180]	; 0xb4
  40d020:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
  40d022:	aa38      	add	r2, sp, #224	; 0xe0
  40d024:	dce7      	bgt.n	40cff6 <_svfprintf_r+0x476>
  40d026:	9c0a      	ldr	r4, [sp, #40]	; 0x28
  40d028:	4635      	mov	r5, r6
  40d02a:	468c      	mov	ip, r1
  40d02c:	4616      	mov	r6, r2
  40d02e:	3301      	adds	r3, #1
  40d030:	44d4      	add	ip, sl
  40d032:	2b07      	cmp	r3, #7
  40d034:	f8cd c0b4 	str.w	ip, [sp, #180]	; 0xb4
  40d038:	932c      	str	r3, [sp, #176]	; 0xb0
  40d03a:	e886 0420 	stmia.w	r6, {r5, sl}
  40d03e:	f300 8337 	bgt.w	40d6b0 <_svfprintf_r+0xb30>
  40d042:	3608      	adds	r6, #8
  40d044:	9d09      	ldr	r5, [sp, #36]	; 0x24
  40d046:	05ed      	lsls	r5, r5, #23
  40d048:	f100 8226 	bmi.w	40d498 <_svfprintf_r+0x918>
  40d04c:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
  40d04e:	6037      	str	r7, [r6, #0]
  40d050:	3301      	adds	r3, #1
  40d052:	44a4      	add	ip, r4
  40d054:	2b07      	cmp	r3, #7
  40d056:	f8cd c0b4 	str.w	ip, [sp, #180]	; 0xb4
  40d05a:	6074      	str	r4, [r6, #4]
  40d05c:	932c      	str	r3, [sp, #176]	; 0xb0
  40d05e:	f300 8311 	bgt.w	40d684 <_svfprintf_r+0xb04>
  40d062:	3608      	adds	r6, #8
  40d064:	9c09      	ldr	r4, [sp, #36]	; 0x24
  40d066:	0763      	lsls	r3, r4, #29
  40d068:	d549      	bpl.n	40d0fe <_svfprintf_r+0x57e>
  40d06a:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
  40d06c:	980b      	ldr	r0, [sp, #44]	; 0x2c
  40d06e:	1a2c      	subs	r4, r5, r0
  40d070:	2c00      	cmp	r4, #0
  40d072:	dd44      	ble.n	40d0fe <_svfprintf_r+0x57e>
  40d074:	2c10      	cmp	r4, #16
  40d076:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
  40d078:	f8df a01c 	ldr.w	sl, [pc, #28]	; 40d098 <_svfprintf_r+0x518>
  40d07c:	dd2b      	ble.n	40d0d6 <_svfprintf_r+0x556>
  40d07e:	4657      	mov	r7, sl
  40d080:	2510      	movs	r5, #16
  40d082:	4662      	mov	r2, ip
  40d084:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
  40d088:	f8dd a034 	ldr.w	sl, [sp, #52]	; 0x34
  40d08c:	e00b      	b.n	40d0a6 <_svfprintf_r+0x526>
  40d08e:	bf00      	nop
  40d090:	00416e74 	.word	0x00416e74
  40d094:	00416e40 	.word	0x00416e40
  40d098:	00416e94 	.word	0x00416e94
  40d09c:	3c10      	subs	r4, #16
  40d09e:	2c10      	cmp	r4, #16
  40d0a0:	f106 0608 	add.w	r6, r6, #8
  40d0a4:	dd15      	ble.n	40d0d2 <_svfprintf_r+0x552>
  40d0a6:	3301      	adds	r3, #1
  40d0a8:	3210      	adds	r2, #16
  40d0aa:	2b07      	cmp	r3, #7
  40d0ac:	922d      	str	r2, [sp, #180]	; 0xb4
  40d0ae:	932c      	str	r3, [sp, #176]	; 0xb0
  40d0b0:	6037      	str	r7, [r6, #0]
  40d0b2:	6075      	str	r5, [r6, #4]
  40d0b4:	ddf2      	ble.n	40d09c <_svfprintf_r+0x51c>
  40d0b6:	4650      	mov	r0, sl
  40d0b8:	4641      	mov	r1, r8
  40d0ba:	aa2b      	add	r2, sp, #172	; 0xac
  40d0bc:	f006 fcd8 	bl	413a70 <__ssprint_r>
  40d0c0:	2800      	cmp	r0, #0
  40d0c2:	f47f ae75 	bne.w	40cdb0 <_svfprintf_r+0x230>
  40d0c6:	3c10      	subs	r4, #16
  40d0c8:	2c10      	cmp	r4, #16
  40d0ca:	9a2d      	ldr	r2, [sp, #180]	; 0xb4
  40d0cc:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
  40d0ce:	ae38      	add	r6, sp, #224	; 0xe0
  40d0d0:	dce9      	bgt.n	40d0a6 <_svfprintf_r+0x526>
  40d0d2:	4694      	mov	ip, r2
  40d0d4:	46ba      	mov	sl, r7
  40d0d6:	3301      	adds	r3, #1
  40d0d8:	44a4      	add	ip, r4
  40d0da:	2b07      	cmp	r3, #7
  40d0dc:	f8cd c0b4 	str.w	ip, [sp, #180]	; 0xb4
  40d0e0:	932c      	str	r3, [sp, #176]	; 0xb0
  40d0e2:	f8c6 a000 	str.w	sl, [r6]
  40d0e6:	6074      	str	r4, [r6, #4]
  40d0e8:	dd09      	ble.n	40d0fe <_svfprintf_r+0x57e>
  40d0ea:	980d      	ldr	r0, [sp, #52]	; 0x34
  40d0ec:	990c      	ldr	r1, [sp, #48]	; 0x30
  40d0ee:	aa2b      	add	r2, sp, #172	; 0xac
  40d0f0:	f006 fcbe 	bl	413a70 <__ssprint_r>
  40d0f4:	2800      	cmp	r0, #0
  40d0f6:	f47f ae5b 	bne.w	40cdb0 <_svfprintf_r+0x230>
  40d0fa:	f8dd c0b4 	ldr.w	ip, [sp, #180]	; 0xb4
  40d0fe:	9c0e      	ldr	r4, [sp, #56]	; 0x38
  40d100:	980b      	ldr	r0, [sp, #44]	; 0x2c
  40d102:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
  40d104:	42a8      	cmp	r0, r5
  40d106:	bfac      	ite	ge
  40d108:	1824      	addge	r4, r4, r0
  40d10a:	1964      	addlt	r4, r4, r5
  40d10c:	940e      	str	r4, [sp, #56]	; 0x38
  40d10e:	f1bc 0f00 	cmp.w	ip, #0
  40d112:	f040 82c3 	bne.w	40d69c <_svfprintf_r+0xb1c>
  40d116:	2300      	movs	r3, #0
  40d118:	932c      	str	r3, [sp, #176]	; 0xb0
  40d11a:	ae38      	add	r6, sp, #224	; 0xe0
  40d11c:	e556      	b.n	40cbcc <_svfprintf_r+0x4c>
  40d11e:	f899 8000 	ldrb.w	r8, [r9]
  40d122:	2a00      	cmp	r2, #0
  40d124:	f47f ad88 	bne.w	40cc38 <_svfprintf_r+0xb8>
  40d128:	2220      	movs	r2, #32
  40d12a:	e585      	b.n	40cc38 <_svfprintf_r+0xb8>
  40d12c:	9d09      	ldr	r5, [sp, #36]	; 0x24
  40d12e:	f045 0501 	orr.w	r5, r5, #1
  40d132:	9509      	str	r5, [sp, #36]	; 0x24
  40d134:	f899 8000 	ldrb.w	r8, [r9]
  40d138:	e57e      	b.n	40cc38 <_svfprintf_r+0xb8>
  40d13a:	9d09      	ldr	r5, [sp, #36]	; 0x24
  40d13c:	f045 0580 	orr.w	r5, r5, #128	; 0x80
  40d140:	9509      	str	r5, [sp, #36]	; 0x24
  40d142:	f899 8000 	ldrb.w	r8, [r9]
  40d146:	e577      	b.n	40cc38 <_svfprintf_r+0xb8>
  40d148:	2400      	movs	r4, #0
  40d14a:	f1a8 0330 	sub.w	r3, r8, #48	; 0x30
  40d14e:	940f      	str	r4, [sp, #60]	; 0x3c
  40d150:	4621      	mov	r1, r4
  40d152:	f819 8b01 	ldrb.w	r8, [r9], #1
  40d156:	eb01 0181 	add.w	r1, r1, r1, lsl #2
  40d15a:	eb03 0141 	add.w	r1, r3, r1, lsl #1
  40d15e:	f1a8 0330 	sub.w	r3, r8, #48	; 0x30
  40d162:	2b09      	cmp	r3, #9
  40d164:	d9f5      	bls.n	40d152 <_svfprintf_r+0x5d2>
  40d166:	910f      	str	r1, [sp, #60]	; 0x3c
  40d168:	e568      	b.n	40cc3c <_svfprintf_r+0xbc>
  40d16a:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
  40d16e:	f88d 208f 	strb.w	r2, [sp, #143]	; 0x8f
  40d172:	f04c 0c10 	orr.w	ip, ip, #16
  40d176:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
  40d17a:	9c09      	ldr	r4, [sp, #36]	; 0x24
  40d17c:	06a3      	lsls	r3, r4, #26
  40d17e:	f140 80b2 	bpl.w	40d2e6 <_svfprintf_r+0x766>
  40d182:	9d10      	ldr	r5, [sp, #64]	; 0x40
  40d184:	1de9      	adds	r1, r5, #7
  40d186:	f021 0107 	bic.w	r1, r1, #7
  40d18a:	e9d1 2300 	ldrd	r2, r3, [r1]
  40d18e:	3108      	adds	r1, #8
  40d190:	9110      	str	r1, [sp, #64]	; 0x40
  40d192:	4614      	mov	r4, r2
  40d194:	461d      	mov	r5, r3
  40d196:	2a00      	cmp	r2, #0
  40d198:	f173 0000 	sbcs.w	r0, r3, #0
  40d19c:	f2c0 838b 	blt.w	40d8b6 <_svfprintf_r+0xd36>
  40d1a0:	f89d a08f 	ldrb.w	sl, [sp, #143]	; 0x8f
  40d1a4:	2301      	movs	r3, #1
  40d1a6:	e659      	b.n	40ce5c <_svfprintf_r+0x2dc>
  40d1a8:	9d09      	ldr	r5, [sp, #36]	; 0x24
  40d1aa:	4cb7      	ldr	r4, [pc, #732]	; (40d488 <_svfprintf_r+0x908>)
  40d1ac:	f88d 208f 	strb.w	r2, [sp, #143]	; 0x8f
  40d1b0:	06af      	lsls	r7, r5, #26
  40d1b2:	941a      	str	r4, [sp, #104]	; 0x68
  40d1b4:	f53f ae2f 	bmi.w	40ce16 <_svfprintf_r+0x296>
  40d1b8:	9d09      	ldr	r5, [sp, #36]	; 0x24
  40d1ba:	06ed      	lsls	r5, r5, #27
  40d1bc:	f140 845d 	bpl.w	40da7a <_svfprintf_r+0xefa>
  40d1c0:	f8dd c040 	ldr.w	ip, [sp, #64]	; 0x40
  40d1c4:	f8dc 4000 	ldr.w	r4, [ip]
  40d1c8:	f10c 0c04 	add.w	ip, ip, #4
  40d1cc:	f8cd c040 	str.w	ip, [sp, #64]	; 0x40
  40d1d0:	2500      	movs	r5, #0
  40d1d2:	e62b      	b.n	40ce2c <_svfprintf_r+0x2ac>
  40d1d4:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
  40d1d8:	f88d 208f 	strb.w	r2, [sp, #143]	; 0x8f
  40d1dc:	f01c 0f20 	tst.w	ip, #32
  40d1e0:	f000 843d 	beq.w	40da5e <_svfprintf_r+0xede>
  40d1e4:	9c10      	ldr	r4, [sp, #64]	; 0x40
  40d1e6:	6821      	ldr	r1, [r4, #0]
  40d1e8:	9c0e      	ldr	r4, [sp, #56]	; 0x38
  40d1ea:	17e5      	asrs	r5, r4, #31
  40d1ec:	462b      	mov	r3, r5
  40d1ee:	9d10      	ldr	r5, [sp, #64]	; 0x40
  40d1f0:	4622      	mov	r2, r4
  40d1f2:	3504      	adds	r5, #4
  40d1f4:	9510      	str	r5, [sp, #64]	; 0x40
  40d1f6:	e9c1 2300 	strd	r2, r3, [r1]
  40d1fa:	e4e7      	b.n	40cbcc <_svfprintf_r+0x4c>
  40d1fc:	9c10      	ldr	r4, [sp, #64]	; 0x40
  40d1fe:	6827      	ldr	r7, [r4, #0]
  40d200:	f04f 0a00 	mov.w	sl, #0
  40d204:	f88d a08f 	strb.w	sl, [sp, #143]	; 0x8f
  40d208:	1d25      	adds	r5, r4, #4
  40d20a:	2f00      	cmp	r7, #0
  40d20c:	f000 85f5 	beq.w	40ddfa <_svfprintf_r+0x127a>
  40d210:	9c0a      	ldr	r4, [sp, #40]	; 0x28
  40d212:	2c00      	cmp	r4, #0
  40d214:	4638      	mov	r0, r7
  40d216:	f2c0 85a7 	blt.w	40dd68 <_svfprintf_r+0x11e8>
  40d21a:	4651      	mov	r1, sl
  40d21c:	4622      	mov	r2, r4
  40d21e:	f004 fac3 	bl	4117a8 <memchr>
  40d222:	2800      	cmp	r0, #0
  40d224:	f000 861f 	beq.w	40de66 <_svfprintf_r+0x12e6>
  40d228:	9c0a      	ldr	r4, [sp, #40]	; 0x28
  40d22a:	9510      	str	r5, [sp, #64]	; 0x40
  40d22c:	1bc0      	subs	r0, r0, r7
  40d22e:	42a0      	cmp	r0, r4
  40d230:	bfb8      	it	lt
  40d232:	4604      	movlt	r4, r0
  40d234:	ea24 75e4 	bic.w	r5, r4, r4, asr #31
  40d238:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
  40d23c:	f8cd a050 	str.w	sl, [sp, #80]	; 0x50
  40d240:	950b      	str	r5, [sp, #44]	; 0x2c
  40d242:	f89d a08f 	ldrb.w	sl, [sp, #143]	; 0x8f
  40d246:	e632      	b.n	40ceae <_svfprintf_r+0x32e>
  40d248:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
  40d24c:	f04c 0c40 	orr.w	ip, ip, #64	; 0x40
  40d250:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
  40d254:	f899 8000 	ldrb.w	r8, [r9]
  40d258:	e4ee      	b.n	40cc38 <_svfprintf_r+0xb8>
  40d25a:	f899 8000 	ldrb.w	r8, [r9]
  40d25e:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
  40d262:	464b      	mov	r3, r9
  40d264:	f000 848b 	beq.w	40db7e <_svfprintf_r+0xffe>
  40d268:	9d09      	ldr	r5, [sp, #36]	; 0x24
  40d26a:	f045 0510 	orr.w	r5, r5, #16
  40d26e:	9509      	str	r5, [sp, #36]	; 0x24
  40d270:	e4e2      	b.n	40cc38 <_svfprintf_r+0xb8>
  40d272:	9c10      	ldr	r4, [sp, #64]	; 0x40
  40d274:	9d10      	ldr	r5, [sp, #64]	; 0x40
  40d276:	6824      	ldr	r4, [r4, #0]
  40d278:	940f      	str	r4, [sp, #60]	; 0x3c
  40d27a:	2c00      	cmp	r4, #0
  40d27c:	f105 0304 	add.w	r3, r5, #4
  40d280:	f6ff ad7c 	blt.w	40cd7c <_svfprintf_r+0x1fc>
  40d284:	9310      	str	r3, [sp, #64]	; 0x40
  40d286:	f899 8000 	ldrb.w	r8, [r9]
  40d28a:	e4d5      	b.n	40cc38 <_svfprintf_r+0xb8>
  40d28c:	9a10      	ldr	r2, [sp, #64]	; 0x40
  40d28e:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
  40d292:	487e      	ldr	r0, [pc, #504]	; (40d48c <_svfprintf_r+0x90c>)
  40d294:	6814      	ldr	r4, [r2, #0]
  40d296:	901a      	str	r0, [sp, #104]	; 0x68
  40d298:	2330      	movs	r3, #48	; 0x30
  40d29a:	1d15      	adds	r5, r2, #4
  40d29c:	f04f 0878 	mov.w	r8, #120	; 0x78
  40d2a0:	f04c 0c02 	orr.w	ip, ip, #2
  40d2a4:	f88d 3090 	strb.w	r3, [sp, #144]	; 0x90
  40d2a8:	9510      	str	r5, [sp, #64]	; 0x40
  40d2aa:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
  40d2ae:	2500      	movs	r5, #0
  40d2b0:	f88d 8091 	strb.w	r8, [sp, #145]	; 0x91
  40d2b4:	2302      	movs	r3, #2
  40d2b6:	e5cd      	b.n	40ce54 <_svfprintf_r+0x2d4>
  40d2b8:	9a10      	ldr	r2, [sp, #64]	; 0x40
  40d2ba:	9d10      	ldr	r5, [sp, #64]	; 0x40
  40d2bc:	6812      	ldr	r2, [r2, #0]
  40d2be:	f88d 20b8 	strb.w	r2, [sp, #184]	; 0xb8
  40d2c2:	2300      	movs	r3, #0
  40d2c4:	2401      	movs	r4, #1
  40d2c6:	3504      	adds	r5, #4
  40d2c8:	469a      	mov	sl, r3
  40d2ca:	940b      	str	r4, [sp, #44]	; 0x2c
  40d2cc:	9510      	str	r5, [sp, #64]	; 0x40
  40d2ce:	f88d 308f 	strb.w	r3, [sp, #143]	; 0x8f
  40d2d2:	930a      	str	r3, [sp, #40]	; 0x28
  40d2d4:	9314      	str	r3, [sp, #80]	; 0x50
  40d2d6:	af2e      	add	r7, sp, #184	; 0xb8
  40d2d8:	e5ef      	b.n	40ceba <_svfprintf_r+0x33a>
  40d2da:	9c09      	ldr	r4, [sp, #36]	; 0x24
  40d2dc:	f88d 208f 	strb.w	r2, [sp, #143]	; 0x8f
  40d2e0:	06a3      	lsls	r3, r4, #26
  40d2e2:	f53f af4e 	bmi.w	40d182 <_svfprintf_r+0x602>
  40d2e6:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
  40d2ea:	f01c 0f10 	tst.w	ip, #16
  40d2ee:	f040 82d2 	bne.w	40d896 <_svfprintf_r+0xd16>
  40d2f2:	9c09      	ldr	r4, [sp, #36]	; 0x24
  40d2f4:	0667      	lsls	r7, r4, #25
  40d2f6:	f140 82ce 	bpl.w	40d896 <_svfprintf_r+0xd16>
  40d2fa:	f8dd c040 	ldr.w	ip, [sp, #64]	; 0x40
  40d2fe:	f9bc 4000 	ldrsh.w	r4, [ip]
  40d302:	f10c 0c04 	add.w	ip, ip, #4
  40d306:	17e5      	asrs	r5, r4, #31
  40d308:	4622      	mov	r2, r4
  40d30a:	462b      	mov	r3, r5
  40d30c:	f8cd c040 	str.w	ip, [sp, #64]	; 0x40
  40d310:	e741      	b.n	40d196 <_svfprintf_r+0x616>
  40d312:	f899 8000 	ldrb.w	r8, [r9]
  40d316:	222b      	movs	r2, #43	; 0x2b
  40d318:	e48e      	b.n	40cc38 <_svfprintf_r+0xb8>
  40d31a:	9d09      	ldr	r5, [sp, #36]	; 0x24
  40d31c:	f045 0508 	orr.w	r5, r5, #8
  40d320:	9509      	str	r5, [sp, #36]	; 0x24
  40d322:	f899 8000 	ldrb.w	r8, [r9]
  40d326:	e487      	b.n	40cc38 <_svfprintf_r+0xb8>
  40d328:	9d10      	ldr	r5, [sp, #64]	; 0x40
  40d32a:	9c09      	ldr	r4, [sp, #36]	; 0x24
  40d32c:	f88d 208f 	strb.w	r2, [sp, #143]	; 0x8f
  40d330:	1deb      	adds	r3, r5, #7
  40d332:	0725      	lsls	r5, r4, #28
  40d334:	f023 0307 	bic.w	r3, r3, #7
  40d338:	f140 838a 	bpl.w	40da50 <_svfprintf_r+0xed0>
  40d33c:	e9d3 4500 	ldrd	r4, r5, [r3]
  40d340:	e9cd 4516 	strd	r4, r5, [sp, #88]	; 0x58
  40d344:	f103 0c08 	add.w	ip, r3, #8
  40d348:	f8cd c040 	str.w	ip, [sp, #64]	; 0x40
  40d34c:	e9dd 0116 	ldrd	r0, r1, [sp, #88]	; 0x58
  40d350:	f005 f8b8 	bl	4124c4 <__fpclassifyd>
  40d354:	2801      	cmp	r0, #1
  40d356:	e9dd 0116 	ldrd	r0, r1, [sp, #88]	; 0x58
  40d35a:	f040 835f 	bne.w	40da1c <_svfprintf_r+0xe9c>
  40d35e:	2200      	movs	r2, #0
  40d360:	2300      	movs	r3, #0
  40d362:	f007 fe37 	bl	414fd4 <__aeabi_dcmplt>
  40d366:	2800      	cmp	r0, #0
  40d368:	f040 856d 	bne.w	40de46 <_svfprintf_r+0x12c6>
  40d36c:	f89d a08f 	ldrb.w	sl, [sp, #143]	; 0x8f
  40d370:	2503      	movs	r5, #3
  40d372:	950b      	str	r5, [sp, #44]	; 0x2c
  40d374:	9d09      	ldr	r5, [sp, #36]	; 0x24
  40d376:	4f46      	ldr	r7, [pc, #280]	; (40d490 <_svfprintf_r+0x910>)
  40d378:	4b46      	ldr	r3, [pc, #280]	; (40d494 <_svfprintf_r+0x914>)
  40d37a:	f025 0580 	bic.w	r5, r5, #128	; 0x80
  40d37e:	2400      	movs	r4, #0
  40d380:	9509      	str	r5, [sp, #36]	; 0x24
  40d382:	2500      	movs	r5, #0
  40d384:	940a      	str	r4, [sp, #40]	; 0x28
  40d386:	f1b8 0f47 	cmp.w	r8, #71	; 0x47
  40d38a:	bfd8      	it	le
  40d38c:	461f      	movle	r7, r3
  40d38e:	2403      	movs	r4, #3
  40d390:	9514      	str	r5, [sp, #80]	; 0x50
  40d392:	e58c      	b.n	40ceae <_svfprintf_r+0x32e>
  40d394:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
  40d398:	f04c 0c20 	orr.w	ip, ip, #32
  40d39c:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
  40d3a0:	f899 8000 	ldrb.w	r8, [r9]
  40d3a4:	e448      	b.n	40cc38 <_svfprintf_r+0xb8>
  40d3a6:	9c10      	ldr	r4, [sp, #64]	; 0x40
  40d3a8:	1de3      	adds	r3, r4, #7
  40d3aa:	f023 0307 	bic.w	r3, r3, #7
  40d3ae:	f103 0508 	add.w	r5, r3, #8
  40d3b2:	9510      	str	r5, [sp, #64]	; 0x40
  40d3b4:	e9d3 4500 	ldrd	r4, r5, [r3]
  40d3b8:	2300      	movs	r3, #0
  40d3ba:	e54b      	b.n	40ce54 <_svfprintf_r+0x2d4>
  40d3bc:	9d10      	ldr	r5, [sp, #64]	; 0x40
  40d3be:	1deb      	adds	r3, r5, #7
  40d3c0:	f023 0307 	bic.w	r3, r3, #7
  40d3c4:	f103 0c08 	add.w	ip, r3, #8
  40d3c8:	e9d3 4500 	ldrd	r4, r5, [r3]
  40d3cc:	f8cd c040 	str.w	ip, [sp, #64]	; 0x40
  40d3d0:	2301      	movs	r3, #1
  40d3d2:	e53f      	b.n	40ce54 <_svfprintf_r+0x2d4>
  40d3d4:	f88d 208f 	strb.w	r2, [sp, #143]	; 0x8f
  40d3d8:	f1b8 0f00 	cmp.w	r8, #0
  40d3dc:	f43f ace1 	beq.w	40cda2 <_svfprintf_r+0x222>
  40d3e0:	2300      	movs	r3, #0
  40d3e2:	f04f 0c01 	mov.w	ip, #1
  40d3e6:	469a      	mov	sl, r3
  40d3e8:	f8cd c02c 	str.w	ip, [sp, #44]	; 0x2c
  40d3ec:	f88d 80b8 	strb.w	r8, [sp, #184]	; 0xb8
  40d3f0:	f88d 308f 	strb.w	r3, [sp, #143]	; 0x8f
  40d3f4:	930a      	str	r3, [sp, #40]	; 0x28
  40d3f6:	9314      	str	r3, [sp, #80]	; 0x50
  40d3f8:	4664      	mov	r4, ip
  40d3fa:	af2e      	add	r7, sp, #184	; 0xb8
  40d3fc:	e55d      	b.n	40ceba <_svfprintf_r+0x33a>
  40d3fe:	f8dd c0b4 	ldr.w	ip, [sp, #180]	; 0xb4
  40d402:	e5b5      	b.n	40cf70 <_svfprintf_r+0x3f0>
  40d404:	2b01      	cmp	r3, #1
  40d406:	f000 80ec 	beq.w	40d5e2 <_svfprintf_r+0xa62>
  40d40a:	2b02      	cmp	r3, #2
  40d40c:	f10d 03df 	add.w	r3, sp, #223	; 0xdf
  40d410:	d118      	bne.n	40d444 <_svfprintf_r+0x8c4>
  40d412:	f8dd c068 	ldr.w	ip, [sp, #104]	; 0x68
  40d416:	4619      	mov	r1, r3
  40d418:	f004 000f 	and.w	r0, r4, #15
  40d41c:	0922      	lsrs	r2, r4, #4
  40d41e:	ea42 7205 	orr.w	r2, r2, r5, lsl #28
  40d422:	460f      	mov	r7, r1
  40d424:	092b      	lsrs	r3, r5, #4
  40d426:	f81c 1000 	ldrb.w	r1, [ip, r0]
  40d42a:	7039      	strb	r1, [r7, #0]
  40d42c:	ea52 0003 	orrs.w	r0, r2, r3
  40d430:	4614      	mov	r4, r2
  40d432:	461d      	mov	r5, r3
  40d434:	f107 31ff 	add.w	r1, r7, #4294967295
  40d438:	d1ee      	bne.n	40d418 <_svfprintf_r+0x898>
  40d43a:	9d08      	ldr	r5, [sp, #32]
  40d43c:	e9cd 231e 	strd	r2, r3, [sp, #120]	; 0x78
  40d440:	1bec      	subs	r4, r5, r7
  40d442:	e52b      	b.n	40ce9c <_svfprintf_r+0x31c>
  40d444:	08e0      	lsrs	r0, r4, #3
  40d446:	ea40 7045 	orr.w	r0, r0, r5, lsl #29
  40d44a:	f004 0207 	and.w	r2, r4, #7
  40d44e:	08e9      	lsrs	r1, r5, #3
  40d450:	3230      	adds	r2, #48	; 0x30
  40d452:	ea50 0c01 	orrs.w	ip, r0, r1
  40d456:	461f      	mov	r7, r3
  40d458:	701a      	strb	r2, [r3, #0]
  40d45a:	4604      	mov	r4, r0
  40d45c:	460d      	mov	r5, r1
  40d45e:	f103 33ff 	add.w	r3, r3, #4294967295
  40d462:	d1ef      	bne.n	40d444 <_svfprintf_r+0x8c4>
  40d464:	9c09      	ldr	r4, [sp, #36]	; 0x24
  40d466:	e9cd 011c 	strd	r0, r1, [sp, #112]	; 0x70
  40d46a:	07e0      	lsls	r0, r4, #31
  40d46c:	4639      	mov	r1, r7
  40d46e:	f140 80c1 	bpl.w	40d5f4 <_svfprintf_r+0xa74>
  40d472:	2a30      	cmp	r2, #48	; 0x30
  40d474:	f000 80be 	beq.w	40d5f4 <_svfprintf_r+0xa74>
  40d478:	9d08      	ldr	r5, [sp, #32]
  40d47a:	461f      	mov	r7, r3
  40d47c:	2330      	movs	r3, #48	; 0x30
  40d47e:	1bec      	subs	r4, r5, r7
  40d480:	f801 3c01 	strb.w	r3, [r1, #-1]
  40d484:	e50a      	b.n	40ce9c <_svfprintf_r+0x31c>
  40d486:	bf00      	nop
  40d488:	00416e60 	.word	0x00416e60
  40d48c:	00416e74 	.word	0x00416e74
  40d490:	00416e54 	.word	0x00416e54
  40d494:	00416e50 	.word	0x00416e50
  40d498:	f1b8 0f65 	cmp.w	r8, #101	; 0x65
  40d49c:	f340 80ad 	ble.w	40d5fa <_svfprintf_r+0xa7a>
  40d4a0:	e9dd 0116 	ldrd	r0, r1, [sp, #88]	; 0x58
  40d4a4:	2200      	movs	r2, #0
  40d4a6:	2300      	movs	r3, #0
  40d4a8:	f8cd c01c 	str.w	ip, [sp, #28]
  40d4ac:	f007 fd88 	bl	414fc0 <__aeabi_dcmpeq>
  40d4b0:	f8dd c01c 	ldr.w	ip, [sp, #28]
  40d4b4:	2800      	cmp	r0, #0
  40d4b6:	f000 8126 	beq.w	40d706 <_svfprintf_r+0xb86>
  40d4ba:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
  40d4bc:	4aaa      	ldr	r2, [pc, #680]	; (40d768 <_svfprintf_r+0xbe8>)
  40d4be:	6032      	str	r2, [r6, #0]
  40d4c0:	3301      	adds	r3, #1
  40d4c2:	f10c 0c01 	add.w	ip, ip, #1
  40d4c6:	2201      	movs	r2, #1
  40d4c8:	2b07      	cmp	r3, #7
  40d4ca:	f8cd c0b4 	str.w	ip, [sp, #180]	; 0xb4
  40d4ce:	932c      	str	r3, [sp, #176]	; 0xb0
  40d4d0:	6072      	str	r2, [r6, #4]
  40d4d2:	f300 82f7 	bgt.w	40dac4 <_svfprintf_r+0xf44>
  40d4d6:	3608      	adds	r6, #8
  40d4d8:	9b25      	ldr	r3, [sp, #148]	; 0x94
  40d4da:	9c11      	ldr	r4, [sp, #68]	; 0x44
  40d4dc:	42a3      	cmp	r3, r4
  40d4de:	db03      	blt.n	40d4e8 <_svfprintf_r+0x968>
  40d4e0:	9d09      	ldr	r5, [sp, #36]	; 0x24
  40d4e2:	07ec      	lsls	r4, r5, #31
  40d4e4:	f57f adbe 	bpl.w	40d064 <_svfprintf_r+0x4e4>
  40d4e8:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
  40d4ea:	9d18      	ldr	r5, [sp, #96]	; 0x60
  40d4ec:	9c15      	ldr	r4, [sp, #84]	; 0x54
  40d4ee:	6034      	str	r4, [r6, #0]
  40d4f0:	3301      	adds	r3, #1
  40d4f2:	44ac      	add	ip, r5
  40d4f4:	2b07      	cmp	r3, #7
  40d4f6:	f8cd c0b4 	str.w	ip, [sp, #180]	; 0xb4
  40d4fa:	6075      	str	r5, [r6, #4]
  40d4fc:	932c      	str	r3, [sp, #176]	; 0xb0
  40d4fe:	f300 8348 	bgt.w	40db92 <_svfprintf_r+0x1012>
  40d502:	3608      	adds	r6, #8
  40d504:	9d11      	ldr	r5, [sp, #68]	; 0x44
  40d506:	1e6c      	subs	r4, r5, #1
  40d508:	2c00      	cmp	r4, #0
  40d50a:	f77f adab 	ble.w	40d064 <_svfprintf_r+0x4e4>
  40d50e:	2c10      	cmp	r4, #16
  40d510:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
  40d512:	4d96      	ldr	r5, [pc, #600]	; (40d76c <_svfprintf_r+0xbec>)
  40d514:	f340 8197 	ble.w	40d846 <_svfprintf_r+0xcc6>
  40d518:	2710      	movs	r7, #16
  40d51a:	4662      	mov	r2, ip
  40d51c:	f8dd 8034 	ldr.w	r8, [sp, #52]	; 0x34
  40d520:	f8dd a030 	ldr.w	sl, [sp, #48]	; 0x30
  40d524:	e004      	b.n	40d530 <_svfprintf_r+0x9b0>
  40d526:	3608      	adds	r6, #8
  40d528:	3c10      	subs	r4, #16
  40d52a:	2c10      	cmp	r4, #16
  40d52c:	f340 818a 	ble.w	40d844 <_svfprintf_r+0xcc4>
  40d530:	3301      	adds	r3, #1
  40d532:	3210      	adds	r2, #16
  40d534:	2b07      	cmp	r3, #7
  40d536:	922d      	str	r2, [sp, #180]	; 0xb4
  40d538:	932c      	str	r3, [sp, #176]	; 0xb0
  40d53a:	e886 00a0 	stmia.w	r6, {r5, r7}
  40d53e:	ddf2      	ble.n	40d526 <_svfprintf_r+0x9a6>
  40d540:	4640      	mov	r0, r8
  40d542:	4651      	mov	r1, sl
  40d544:	aa2b      	add	r2, sp, #172	; 0xac
  40d546:	f006 fa93 	bl	413a70 <__ssprint_r>
  40d54a:	2800      	cmp	r0, #0
  40d54c:	f47f ac30 	bne.w	40cdb0 <_svfprintf_r+0x230>
  40d550:	9a2d      	ldr	r2, [sp, #180]	; 0xb4
  40d552:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
  40d554:	ae38      	add	r6, sp, #224	; 0xe0
  40d556:	e7e7      	b.n	40d528 <_svfprintf_r+0x9a8>
  40d558:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
  40d55a:	980b      	ldr	r0, [sp, #44]	; 0x2c
  40d55c:	ebc0 0a05 	rsb	sl, r0, r5
  40d560:	f1ba 0f00 	cmp.w	sl, #0
  40d564:	f77f ad2c 	ble.w	40cfc0 <_svfprintf_r+0x440>
  40d568:	f1ba 0f10 	cmp.w	sl, #16
  40d56c:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
  40d56e:	4d7f      	ldr	r5, [pc, #508]	; (40d76c <_svfprintf_r+0xbec>)
  40d570:	dd2b      	ble.n	40d5ca <_svfprintf_r+0xa4a>
  40d572:	9412      	str	r4, [sp, #72]	; 0x48
  40d574:	4632      	mov	r2, r6
  40d576:	f04f 0b10 	mov.w	fp, #16
  40d57a:	462e      	mov	r6, r5
  40d57c:	4661      	mov	r1, ip
  40d57e:	9c0d      	ldr	r4, [sp, #52]	; 0x34
  40d580:	9d0c      	ldr	r5, [sp, #48]	; 0x30
  40d582:	e006      	b.n	40d592 <_svfprintf_r+0xa12>
  40d584:	f1aa 0a10 	sub.w	sl, sl, #16
  40d588:	f1ba 0f10 	cmp.w	sl, #16
  40d58c:	f102 0208 	add.w	r2, r2, #8
  40d590:	dd17      	ble.n	40d5c2 <_svfprintf_r+0xa42>
  40d592:	3301      	adds	r3, #1
  40d594:	3110      	adds	r1, #16
  40d596:	2b07      	cmp	r3, #7
  40d598:	912d      	str	r1, [sp, #180]	; 0xb4
  40d59a:	932c      	str	r3, [sp, #176]	; 0xb0
  40d59c:	e882 0840 	stmia.w	r2, {r6, fp}
  40d5a0:	ddf0      	ble.n	40d584 <_svfprintf_r+0xa04>
  40d5a2:	4620      	mov	r0, r4
  40d5a4:	4629      	mov	r1, r5
  40d5a6:	aa2b      	add	r2, sp, #172	; 0xac
  40d5a8:	f006 fa62 	bl	413a70 <__ssprint_r>
  40d5ac:	2800      	cmp	r0, #0
  40d5ae:	f47f abff 	bne.w	40cdb0 <_svfprintf_r+0x230>
  40d5b2:	f1aa 0a10 	sub.w	sl, sl, #16
  40d5b6:	f1ba 0f10 	cmp.w	sl, #16
  40d5ba:	992d      	ldr	r1, [sp, #180]	; 0xb4
  40d5bc:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
  40d5be:	aa38      	add	r2, sp, #224	; 0xe0
  40d5c0:	dce7      	bgt.n	40d592 <_svfprintf_r+0xa12>
  40d5c2:	9c12      	ldr	r4, [sp, #72]	; 0x48
  40d5c4:	4635      	mov	r5, r6
  40d5c6:	468c      	mov	ip, r1
  40d5c8:	4616      	mov	r6, r2
  40d5ca:	3301      	adds	r3, #1
  40d5cc:	44d4      	add	ip, sl
  40d5ce:	2b07      	cmp	r3, #7
  40d5d0:	f8cd c0b4 	str.w	ip, [sp, #180]	; 0xb4
  40d5d4:	932c      	str	r3, [sp, #176]	; 0xb0
  40d5d6:	e886 0420 	stmia.w	r6, {r5, sl}
  40d5da:	f300 8212 	bgt.w	40da02 <_svfprintf_r+0xe82>
  40d5de:	3608      	adds	r6, #8
  40d5e0:	e4ee      	b.n	40cfc0 <_svfprintf_r+0x440>
  40d5e2:	2d00      	cmp	r5, #0
  40d5e4:	bf08      	it	eq
  40d5e6:	2c0a      	cmpeq	r4, #10
  40d5e8:	f080 8138 	bcs.w	40d85c <_svfprintf_r+0xcdc>
  40d5ec:	af48      	add	r7, sp, #288	; 0x120
  40d5ee:	3430      	adds	r4, #48	; 0x30
  40d5f0:	f807 4d41 	strb.w	r4, [r7, #-65]!
  40d5f4:	9d08      	ldr	r5, [sp, #32]
  40d5f6:	1bec      	subs	r4, r5, r7
  40d5f8:	e450      	b.n	40ce9c <_svfprintf_r+0x31c>
  40d5fa:	9c11      	ldr	r4, [sp, #68]	; 0x44
  40d5fc:	2c01      	cmp	r4, #1
  40d5fe:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
  40d600:	f340 81d5 	ble.w	40d9ae <_svfprintf_r+0xe2e>
  40d604:	3401      	adds	r4, #1
  40d606:	f10c 0301 	add.w	r3, ip, #1
  40d60a:	2201      	movs	r2, #1
  40d60c:	2c07      	cmp	r4, #7
  40d60e:	6037      	str	r7, [r6, #0]
  40d610:	932d      	str	r3, [sp, #180]	; 0xb4
  40d612:	942c      	str	r4, [sp, #176]	; 0xb0
  40d614:	6072      	str	r2, [r6, #4]
  40d616:	f300 81db 	bgt.w	40d9d0 <_svfprintf_r+0xe50>
  40d61a:	3608      	adds	r6, #8
  40d61c:	f8dd 8060 	ldr.w	r8, [sp, #96]	; 0x60
  40d620:	9d15      	ldr	r5, [sp, #84]	; 0x54
  40d622:	6035      	str	r5, [r6, #0]
  40d624:	3401      	adds	r4, #1
  40d626:	4498      	add	r8, r3
  40d628:	9d18      	ldr	r5, [sp, #96]	; 0x60
  40d62a:	f8cd 80b4 	str.w	r8, [sp, #180]	; 0xb4
  40d62e:	2c07      	cmp	r4, #7
  40d630:	942c      	str	r4, [sp, #176]	; 0xb0
  40d632:	6075      	str	r5, [r6, #4]
  40d634:	f300 81d8 	bgt.w	40d9e8 <_svfprintf_r+0xe68>
  40d638:	3608      	adds	r6, #8
  40d63a:	e9dd 0116 	ldrd	r0, r1, [sp, #88]	; 0x58
  40d63e:	2200      	movs	r2, #0
  40d640:	2300      	movs	r3, #0
  40d642:	f007 fcbd 	bl	414fc0 <__aeabi_dcmpeq>
  40d646:	9d11      	ldr	r5, [sp, #68]	; 0x44
  40d648:	2800      	cmp	r0, #0
  40d64a:	f040 80b9 	bne.w	40d7c0 <_svfprintf_r+0xc40>
  40d64e:	1e6b      	subs	r3, r5, #1
  40d650:	3401      	adds	r4, #1
  40d652:	3701      	adds	r7, #1
  40d654:	4498      	add	r8, r3
  40d656:	2c07      	cmp	r4, #7
  40d658:	942c      	str	r4, [sp, #176]	; 0xb0
  40d65a:	f8cd 80b4 	str.w	r8, [sp, #180]	; 0xb4
  40d65e:	6037      	str	r7, [r6, #0]
  40d660:	6073      	str	r3, [r6, #4]
  40d662:	f300 80e2 	bgt.w	40d82a <_svfprintf_r+0xcaa>
  40d666:	3608      	adds	r6, #8
  40d668:	f8dd c064 	ldr.w	ip, [sp, #100]	; 0x64
  40d66c:	9d19      	ldr	r5, [sp, #100]	; 0x64
  40d66e:	3401      	adds	r4, #1
  40d670:	44c4      	add	ip, r8
  40d672:	ab27      	add	r3, sp, #156	; 0x9c
  40d674:	2c07      	cmp	r4, #7
  40d676:	f8cd c0b4 	str.w	ip, [sp, #180]	; 0xb4
  40d67a:	942c      	str	r4, [sp, #176]	; 0xb0
  40d67c:	e886 0028 	stmia.w	r6, {r3, r5}
  40d680:	f77f acef 	ble.w	40d062 <_svfprintf_r+0x4e2>
  40d684:	980d      	ldr	r0, [sp, #52]	; 0x34
  40d686:	990c      	ldr	r1, [sp, #48]	; 0x30
  40d688:	aa2b      	add	r2, sp, #172	; 0xac
  40d68a:	f006 f9f1 	bl	413a70 <__ssprint_r>
  40d68e:	2800      	cmp	r0, #0
  40d690:	f47f ab8e 	bne.w	40cdb0 <_svfprintf_r+0x230>
  40d694:	f8dd c0b4 	ldr.w	ip, [sp, #180]	; 0xb4
  40d698:	ae38      	add	r6, sp, #224	; 0xe0
  40d69a:	e4e3      	b.n	40d064 <_svfprintf_r+0x4e4>
  40d69c:	980d      	ldr	r0, [sp, #52]	; 0x34
  40d69e:	990c      	ldr	r1, [sp, #48]	; 0x30
  40d6a0:	aa2b      	add	r2, sp, #172	; 0xac
  40d6a2:	f006 f9e5 	bl	413a70 <__ssprint_r>
  40d6a6:	2800      	cmp	r0, #0
  40d6a8:	f43f ad35 	beq.w	40d116 <_svfprintf_r+0x596>
  40d6ac:	f7ff bb80 	b.w	40cdb0 <_svfprintf_r+0x230>
  40d6b0:	980d      	ldr	r0, [sp, #52]	; 0x34
  40d6b2:	990c      	ldr	r1, [sp, #48]	; 0x30
  40d6b4:	aa2b      	add	r2, sp, #172	; 0xac
  40d6b6:	f006 f9db 	bl	413a70 <__ssprint_r>
  40d6ba:	2800      	cmp	r0, #0
  40d6bc:	f47f ab78 	bne.w	40cdb0 <_svfprintf_r+0x230>
  40d6c0:	f8dd c0b4 	ldr.w	ip, [sp, #180]	; 0xb4
  40d6c4:	ae38      	add	r6, sp, #224	; 0xe0
  40d6c6:	e4bd      	b.n	40d044 <_svfprintf_r+0x4c4>
  40d6c8:	980d      	ldr	r0, [sp, #52]	; 0x34
  40d6ca:	990c      	ldr	r1, [sp, #48]	; 0x30
  40d6cc:	aa2b      	add	r2, sp, #172	; 0xac
  40d6ce:	f006 f9cf 	bl	413a70 <__ssprint_r>
  40d6d2:	2800      	cmp	r0, #0
  40d6d4:	f47f ab6c 	bne.w	40cdb0 <_svfprintf_r+0x230>
  40d6d8:	f8dd c0b4 	ldr.w	ip, [sp, #180]	; 0xb4
  40d6dc:	ae38      	add	r6, sp, #224	; 0xe0
  40d6de:	e45a      	b.n	40cf96 <_svfprintf_r+0x416>
  40d6e0:	980d      	ldr	r0, [sp, #52]	; 0x34
  40d6e2:	990c      	ldr	r1, [sp, #48]	; 0x30
  40d6e4:	aa2b      	add	r2, sp, #172	; 0xac
  40d6e6:	f006 f9c3 	bl	413a70 <__ssprint_r>
  40d6ea:	2800      	cmp	r0, #0
  40d6ec:	f47f ab60 	bne.w	40cdb0 <_svfprintf_r+0x230>
  40d6f0:	f8dd c0b4 	ldr.w	ip, [sp, #180]	; 0xb4
  40d6f4:	ae38      	add	r6, sp, #224	; 0xe0
  40d6f6:	e45f      	b.n	40cfb8 <_svfprintf_r+0x438>
  40d6f8:	9c0a      	ldr	r4, [sp, #40]	; 0x28
  40d6fa:	af38      	add	r7, sp, #224	; 0xe0
  40d6fc:	f7ff bbce 	b.w	40ce9c <_svfprintf_r+0x31c>
  40d700:	2302      	movs	r3, #2
  40d702:	f7ff bba7 	b.w	40ce54 <_svfprintf_r+0x2d4>
  40d706:	9b25      	ldr	r3, [sp, #148]	; 0x94
  40d708:	2b00      	cmp	r3, #0
  40d70a:	f340 81e7 	ble.w	40dadc <_svfprintf_r+0xf5c>
  40d70e:	9c11      	ldr	r4, [sp, #68]	; 0x44
  40d710:	9d14      	ldr	r5, [sp, #80]	; 0x50
  40d712:	f8dd a044 	ldr.w	sl, [sp, #68]	; 0x44
  40d716:	42ac      	cmp	r4, r5
  40d718:	bfa8      	it	ge
  40d71a:	462c      	movge	r4, r5
  40d71c:	2c00      	cmp	r4, #0
  40d71e:	44ba      	add	sl, r7
  40d720:	dd0b      	ble.n	40d73a <_svfprintf_r+0xbba>
  40d722:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
  40d724:	6037      	str	r7, [r6, #0]
  40d726:	3301      	adds	r3, #1
  40d728:	44a4      	add	ip, r4
  40d72a:	2b07      	cmp	r3, #7
  40d72c:	f8cd c0b4 	str.w	ip, [sp, #180]	; 0xb4
  40d730:	6074      	str	r4, [r6, #4]
  40d732:	932c      	str	r3, [sp, #176]	; 0xb0
  40d734:	f300 8328 	bgt.w	40dd88 <_svfprintf_r+0x1208>
  40d738:	3608      	adds	r6, #8
  40d73a:	9d14      	ldr	r5, [sp, #80]	; 0x50
  40d73c:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
  40d740:	1b2c      	subs	r4, r5, r4
  40d742:	2c00      	cmp	r4, #0
  40d744:	f340 80db 	ble.w	40d8fe <_svfprintf_r+0xd7e>
  40d748:	2c10      	cmp	r4, #16
  40d74a:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
  40d74c:	4d07      	ldr	r5, [pc, #28]	; (40d76c <_svfprintf_r+0xbec>)
  40d74e:	f340 81ad 	ble.w	40daac <_svfprintf_r+0xf2c>
  40d752:	970a      	str	r7, [sp, #40]	; 0x28
  40d754:	f04f 0810 	mov.w	r8, #16
  40d758:	462f      	mov	r7, r5
  40d75a:	4662      	mov	r2, ip
  40d75c:	4625      	mov	r5, r4
  40d75e:	f8dd b034 	ldr.w	fp, [sp, #52]	; 0x34
  40d762:	9c0c      	ldr	r4, [sp, #48]	; 0x30
  40d764:	e009      	b.n	40d77a <_svfprintf_r+0xbfa>
  40d766:	bf00      	nop
  40d768:	00416e90 	.word	0x00416e90
  40d76c:	00416e40 	.word	0x00416e40
  40d770:	3608      	adds	r6, #8
  40d772:	3d10      	subs	r5, #16
  40d774:	2d10      	cmp	r5, #16
  40d776:	f340 8195 	ble.w	40daa4 <_svfprintf_r+0xf24>
  40d77a:	3301      	adds	r3, #1
  40d77c:	3210      	adds	r2, #16
  40d77e:	2b07      	cmp	r3, #7
  40d780:	922d      	str	r2, [sp, #180]	; 0xb4
  40d782:	932c      	str	r3, [sp, #176]	; 0xb0
  40d784:	e886 0180 	stmia.w	r6, {r7, r8}
  40d788:	ddf2      	ble.n	40d770 <_svfprintf_r+0xbf0>
  40d78a:	4658      	mov	r0, fp
  40d78c:	4621      	mov	r1, r4
  40d78e:	aa2b      	add	r2, sp, #172	; 0xac
  40d790:	f006 f96e 	bl	413a70 <__ssprint_r>
  40d794:	2800      	cmp	r0, #0
  40d796:	f47f ab0b 	bne.w	40cdb0 <_svfprintf_r+0x230>
  40d79a:	9a2d      	ldr	r2, [sp, #180]	; 0xb4
  40d79c:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
  40d79e:	ae38      	add	r6, sp, #224	; 0xe0
  40d7a0:	e7e7      	b.n	40d772 <_svfprintf_r+0xbf2>
  40d7a2:	980d      	ldr	r0, [sp, #52]	; 0x34
  40d7a4:	990c      	ldr	r1, [sp, #48]	; 0x30
  40d7a6:	aa2b      	add	r2, sp, #172	; 0xac
  40d7a8:	f006 f962 	bl	413a70 <__ssprint_r>
  40d7ac:	2800      	cmp	r0, #0
  40d7ae:	f47f aaff 	bne.w	40cdb0 <_svfprintf_r+0x230>
  40d7b2:	f89d a08f 	ldrb.w	sl, [sp, #143]	; 0x8f
  40d7b6:	f8dd c0b4 	ldr.w	ip, [sp, #180]	; 0xb4
  40d7ba:	ae38      	add	r6, sp, #224	; 0xe0
  40d7bc:	f7ff bbd8 	b.w	40cf70 <_svfprintf_r+0x3f0>
  40d7c0:	1e6f      	subs	r7, r5, #1
  40d7c2:	2f00      	cmp	r7, #0
  40d7c4:	f77f af50 	ble.w	40d668 <_svfprintf_r+0xae8>
  40d7c8:	2f10      	cmp	r7, #16
  40d7ca:	4db3      	ldr	r5, [pc, #716]	; (40da98 <_svfprintf_r+0xf18>)
  40d7cc:	dd23      	ble.n	40d816 <_svfprintf_r+0xc96>
  40d7ce:	4643      	mov	r3, r8
  40d7d0:	f04f 0a10 	mov.w	sl, #16
  40d7d4:	f8dd 8034 	ldr.w	r8, [sp, #52]	; 0x34
  40d7d8:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
  40d7dc:	e004      	b.n	40d7e8 <_svfprintf_r+0xc68>
  40d7de:	3f10      	subs	r7, #16
  40d7e0:	2f10      	cmp	r7, #16
  40d7e2:	f106 0608 	add.w	r6, r6, #8
  40d7e6:	dd15      	ble.n	40d814 <_svfprintf_r+0xc94>
  40d7e8:	3401      	adds	r4, #1
  40d7ea:	3310      	adds	r3, #16
  40d7ec:	2c07      	cmp	r4, #7
  40d7ee:	932d      	str	r3, [sp, #180]	; 0xb4
  40d7f0:	942c      	str	r4, [sp, #176]	; 0xb0
  40d7f2:	e886 0420 	stmia.w	r6, {r5, sl}
  40d7f6:	ddf2      	ble.n	40d7de <_svfprintf_r+0xc5e>
  40d7f8:	4640      	mov	r0, r8
  40d7fa:	4659      	mov	r1, fp
  40d7fc:	aa2b      	add	r2, sp, #172	; 0xac
  40d7fe:	f006 f937 	bl	413a70 <__ssprint_r>
  40d802:	2800      	cmp	r0, #0
  40d804:	f47f aad4 	bne.w	40cdb0 <_svfprintf_r+0x230>
  40d808:	3f10      	subs	r7, #16
  40d80a:	2f10      	cmp	r7, #16
  40d80c:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
  40d80e:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
  40d810:	ae38      	add	r6, sp, #224	; 0xe0
  40d812:	dce9      	bgt.n	40d7e8 <_svfprintf_r+0xc68>
  40d814:	4698      	mov	r8, r3
  40d816:	3401      	adds	r4, #1
  40d818:	44b8      	add	r8, r7
  40d81a:	2c07      	cmp	r4, #7
  40d81c:	f8cd 80b4 	str.w	r8, [sp, #180]	; 0xb4
  40d820:	942c      	str	r4, [sp, #176]	; 0xb0
  40d822:	e886 00a0 	stmia.w	r6, {r5, r7}
  40d826:	f77f af1e 	ble.w	40d666 <_svfprintf_r+0xae6>
  40d82a:	980d      	ldr	r0, [sp, #52]	; 0x34
  40d82c:	990c      	ldr	r1, [sp, #48]	; 0x30
  40d82e:	aa2b      	add	r2, sp, #172	; 0xac
  40d830:	f006 f91e 	bl	413a70 <__ssprint_r>
  40d834:	2800      	cmp	r0, #0
  40d836:	f47f aabb 	bne.w	40cdb0 <_svfprintf_r+0x230>
  40d83a:	f8dd 80b4 	ldr.w	r8, [sp, #180]	; 0xb4
  40d83e:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
  40d840:	ae38      	add	r6, sp, #224	; 0xe0
  40d842:	e711      	b.n	40d668 <_svfprintf_r+0xae8>
  40d844:	4694      	mov	ip, r2
  40d846:	3301      	adds	r3, #1
  40d848:	44a4      	add	ip, r4
  40d84a:	2b07      	cmp	r3, #7
  40d84c:	f8cd c0b4 	str.w	ip, [sp, #180]	; 0xb4
  40d850:	932c      	str	r3, [sp, #176]	; 0xb0
  40d852:	6035      	str	r5, [r6, #0]
  40d854:	6074      	str	r4, [r6, #4]
  40d856:	f77f ac04 	ble.w	40d062 <_svfprintf_r+0x4e2>
  40d85a:	e713      	b.n	40d684 <_svfprintf_r+0xb04>
  40d85c:	f10d 0bdf 	add.w	fp, sp, #223	; 0xdf
  40d860:	4620      	mov	r0, r4
  40d862:	4629      	mov	r1, r5
  40d864:	220a      	movs	r2, #10
  40d866:	2300      	movs	r3, #0
  40d868:	f7fd fea0 	bl	40b5ac <__aeabi_uldivmod>
  40d86c:	3230      	adds	r2, #48	; 0x30
  40d86e:	f88b 2000 	strb.w	r2, [fp]
  40d872:	4620      	mov	r0, r4
  40d874:	4629      	mov	r1, r5
  40d876:	220a      	movs	r2, #10
  40d878:	2300      	movs	r3, #0
  40d87a:	f7fd fe97 	bl	40b5ac <__aeabi_uldivmod>
  40d87e:	4604      	mov	r4, r0
  40d880:	460d      	mov	r5, r1
  40d882:	ea54 0c05 	orrs.w	ip, r4, r5
  40d886:	465f      	mov	r7, fp
  40d888:	f10b 3bff 	add.w	fp, fp, #4294967295
  40d88c:	d1e8      	bne.n	40d860 <_svfprintf_r+0xce0>
  40d88e:	9d08      	ldr	r5, [sp, #32]
  40d890:	1bec      	subs	r4, r5, r7
  40d892:	f7ff bb03 	b.w	40ce9c <_svfprintf_r+0x31c>
  40d896:	9d10      	ldr	r5, [sp, #64]	; 0x40
  40d898:	f8dd c040 	ldr.w	ip, [sp, #64]	; 0x40
  40d89c:	682c      	ldr	r4, [r5, #0]
  40d89e:	17e5      	asrs	r5, r4, #31
  40d8a0:	4622      	mov	r2, r4
  40d8a2:	462b      	mov	r3, r5
  40d8a4:	f10c 0c04 	add.w	ip, ip, #4
  40d8a8:	2a00      	cmp	r2, #0
  40d8aa:	f173 0000 	sbcs.w	r0, r3, #0
  40d8ae:	f8cd c040 	str.w	ip, [sp, #64]	; 0x40
  40d8b2:	f6bf ac75 	bge.w	40d1a0 <_svfprintf_r+0x620>
  40d8b6:	f04f 0a2d 	mov.w	sl, #45	; 0x2d
  40d8ba:	4264      	negs	r4, r4
  40d8bc:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
  40d8c0:	f88d a08f 	strb.w	sl, [sp, #143]	; 0x8f
  40d8c4:	2301      	movs	r3, #1
  40d8c6:	f7ff bac9 	b.w	40ce5c <_svfprintf_r+0x2dc>
  40d8ca:	9d10      	ldr	r5, [sp, #64]	; 0x40
  40d8cc:	682c      	ldr	r4, [r5, #0]
  40d8ce:	3504      	adds	r5, #4
  40d8d0:	9510      	str	r5, [sp, #64]	; 0x40
  40d8d2:	2500      	movs	r5, #0
  40d8d4:	f7ff babe 	b.w	40ce54 <_svfprintf_r+0x2d4>
  40d8d8:	9d10      	ldr	r5, [sp, #64]	; 0x40
  40d8da:	682c      	ldr	r4, [r5, #0]
  40d8dc:	3504      	adds	r5, #4
  40d8de:	9510      	str	r5, [sp, #64]	; 0x40
  40d8e0:	2301      	movs	r3, #1
  40d8e2:	2500      	movs	r5, #0
  40d8e4:	f7ff bab6 	b.w	40ce54 <_svfprintf_r+0x2d4>
  40d8e8:	980d      	ldr	r0, [sp, #52]	; 0x34
  40d8ea:	990c      	ldr	r1, [sp, #48]	; 0x30
  40d8ec:	aa2b      	add	r2, sp, #172	; 0xac
  40d8ee:	f006 f8bf 	bl	413a70 <__ssprint_r>
  40d8f2:	2800      	cmp	r0, #0
  40d8f4:	f47f aa5c 	bne.w	40cdb0 <_svfprintf_r+0x230>
  40d8f8:	f8dd c0b4 	ldr.w	ip, [sp, #180]	; 0xb4
  40d8fc:	ae38      	add	r6, sp, #224	; 0xe0
  40d8fe:	9d14      	ldr	r5, [sp, #80]	; 0x50
  40d900:	9c25      	ldr	r4, [sp, #148]	; 0x94
  40d902:	442f      	add	r7, r5
  40d904:	9d11      	ldr	r5, [sp, #68]	; 0x44
  40d906:	42ac      	cmp	r4, r5
  40d908:	db42      	blt.n	40d990 <_svfprintf_r+0xe10>
  40d90a:	9d09      	ldr	r5, [sp, #36]	; 0x24
  40d90c:	07e9      	lsls	r1, r5, #31
  40d90e:	d43f      	bmi.n	40d990 <_svfprintf_r+0xe10>
  40d910:	9811      	ldr	r0, [sp, #68]	; 0x44
  40d912:	ebc7 050a 	rsb	r5, r7, sl
  40d916:	1b04      	subs	r4, r0, r4
  40d918:	42ac      	cmp	r4, r5
  40d91a:	bfb8      	it	lt
  40d91c:	4625      	movlt	r5, r4
  40d91e:	2d00      	cmp	r5, #0
  40d920:	dd0b      	ble.n	40d93a <_svfprintf_r+0xdba>
  40d922:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
  40d924:	6037      	str	r7, [r6, #0]
  40d926:	3301      	adds	r3, #1
  40d928:	44ac      	add	ip, r5
  40d92a:	2b07      	cmp	r3, #7
  40d92c:	f8cd c0b4 	str.w	ip, [sp, #180]	; 0xb4
  40d930:	6075      	str	r5, [r6, #4]
  40d932:	932c      	str	r3, [sp, #176]	; 0xb0
  40d934:	f300 8252 	bgt.w	40dddc <_svfprintf_r+0x125c>
  40d938:	3608      	adds	r6, #8
  40d93a:	ea25 75e5 	bic.w	r5, r5, r5, asr #31
  40d93e:	1b64      	subs	r4, r4, r5
  40d940:	2c00      	cmp	r4, #0
  40d942:	f77f ab8f 	ble.w	40d064 <_svfprintf_r+0x4e4>
  40d946:	2c10      	cmp	r4, #16
  40d948:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
  40d94a:	4d53      	ldr	r5, [pc, #332]	; (40da98 <_svfprintf_r+0xf18>)
  40d94c:	f77f af7b 	ble.w	40d846 <_svfprintf_r+0xcc6>
  40d950:	2710      	movs	r7, #16
  40d952:	4662      	mov	r2, ip
  40d954:	f8dd 8034 	ldr.w	r8, [sp, #52]	; 0x34
  40d958:	f8dd a030 	ldr.w	sl, [sp, #48]	; 0x30
  40d95c:	e004      	b.n	40d968 <_svfprintf_r+0xde8>
  40d95e:	3608      	adds	r6, #8
  40d960:	3c10      	subs	r4, #16
  40d962:	2c10      	cmp	r4, #16
  40d964:	f77f af6e 	ble.w	40d844 <_svfprintf_r+0xcc4>
  40d968:	3301      	adds	r3, #1
  40d96a:	3210      	adds	r2, #16
  40d96c:	2b07      	cmp	r3, #7
  40d96e:	922d      	str	r2, [sp, #180]	; 0xb4
  40d970:	932c      	str	r3, [sp, #176]	; 0xb0
  40d972:	e886 00a0 	stmia.w	r6, {r5, r7}
  40d976:	ddf2      	ble.n	40d95e <_svfprintf_r+0xdde>
  40d978:	4640      	mov	r0, r8
  40d97a:	4651      	mov	r1, sl
  40d97c:	aa2b      	add	r2, sp, #172	; 0xac
  40d97e:	f006 f877 	bl	413a70 <__ssprint_r>
  40d982:	2800      	cmp	r0, #0
  40d984:	f47f aa14 	bne.w	40cdb0 <_svfprintf_r+0x230>
  40d988:	9a2d      	ldr	r2, [sp, #180]	; 0xb4
  40d98a:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
  40d98c:	ae38      	add	r6, sp, #224	; 0xe0
  40d98e:	e7e7      	b.n	40d960 <_svfprintf_r+0xde0>
  40d990:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
  40d992:	9d15      	ldr	r5, [sp, #84]	; 0x54
  40d994:	6035      	str	r5, [r6, #0]
  40d996:	9d18      	ldr	r5, [sp, #96]	; 0x60
  40d998:	6075      	str	r5, [r6, #4]
  40d99a:	3301      	adds	r3, #1
  40d99c:	44ac      	add	ip, r5
  40d99e:	2b07      	cmp	r3, #7
  40d9a0:	f8cd c0b4 	str.w	ip, [sp, #180]	; 0xb4
  40d9a4:	932c      	str	r3, [sp, #176]	; 0xb0
  40d9a6:	f300 81fb 	bgt.w	40dda0 <_svfprintf_r+0x1220>
  40d9aa:	3608      	adds	r6, #8
  40d9ac:	e7b0      	b.n	40d910 <_svfprintf_r+0xd90>
  40d9ae:	9d09      	ldr	r5, [sp, #36]	; 0x24
  40d9b0:	07ea      	lsls	r2, r5, #31
  40d9b2:	f53f ae27 	bmi.w	40d604 <_svfprintf_r+0xa84>
  40d9b6:	3401      	adds	r4, #1
  40d9b8:	f10c 0801 	add.w	r8, ip, #1
  40d9bc:	2301      	movs	r3, #1
  40d9be:	2c07      	cmp	r4, #7
  40d9c0:	f8cd 80b4 	str.w	r8, [sp, #180]	; 0xb4
  40d9c4:	942c      	str	r4, [sp, #176]	; 0xb0
  40d9c6:	6037      	str	r7, [r6, #0]
  40d9c8:	6073      	str	r3, [r6, #4]
  40d9ca:	f77f ae4c 	ble.w	40d666 <_svfprintf_r+0xae6>
  40d9ce:	e72c      	b.n	40d82a <_svfprintf_r+0xcaa>
  40d9d0:	980d      	ldr	r0, [sp, #52]	; 0x34
  40d9d2:	990c      	ldr	r1, [sp, #48]	; 0x30
  40d9d4:	aa2b      	add	r2, sp, #172	; 0xac
  40d9d6:	f006 f84b 	bl	413a70 <__ssprint_r>
  40d9da:	2800      	cmp	r0, #0
  40d9dc:	f47f a9e8 	bne.w	40cdb0 <_svfprintf_r+0x230>
  40d9e0:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
  40d9e2:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
  40d9e4:	ae38      	add	r6, sp, #224	; 0xe0
  40d9e6:	e619      	b.n	40d61c <_svfprintf_r+0xa9c>
  40d9e8:	980d      	ldr	r0, [sp, #52]	; 0x34
  40d9ea:	990c      	ldr	r1, [sp, #48]	; 0x30
  40d9ec:	aa2b      	add	r2, sp, #172	; 0xac
  40d9ee:	f006 f83f 	bl	413a70 <__ssprint_r>
  40d9f2:	2800      	cmp	r0, #0
  40d9f4:	f47f a9dc 	bne.w	40cdb0 <_svfprintf_r+0x230>
  40d9f8:	f8dd 80b4 	ldr.w	r8, [sp, #180]	; 0xb4
  40d9fc:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
  40d9fe:	ae38      	add	r6, sp, #224	; 0xe0
  40da00:	e61b      	b.n	40d63a <_svfprintf_r+0xaba>
  40da02:	980d      	ldr	r0, [sp, #52]	; 0x34
  40da04:	990c      	ldr	r1, [sp, #48]	; 0x30
  40da06:	aa2b      	add	r2, sp, #172	; 0xac
  40da08:	f006 f832 	bl	413a70 <__ssprint_r>
  40da0c:	2800      	cmp	r0, #0
  40da0e:	f47f a9cf 	bne.w	40cdb0 <_svfprintf_r+0x230>
  40da12:	f8dd c0b4 	ldr.w	ip, [sp, #180]	; 0xb4
  40da16:	ae38      	add	r6, sp, #224	; 0xe0
  40da18:	f7ff bad2 	b.w	40cfc0 <_svfprintf_r+0x440>
  40da1c:	f004 fd52 	bl	4124c4 <__fpclassifyd>
  40da20:	2800      	cmp	r0, #0
  40da22:	f040 80c2 	bne.w	40dbaa <_svfprintf_r+0x102a>
  40da26:	9c09      	ldr	r4, [sp, #36]	; 0x24
  40da28:	4f1c      	ldr	r7, [pc, #112]	; (40da9c <_svfprintf_r+0xf1c>)
  40da2a:	4b1d      	ldr	r3, [pc, #116]	; (40daa0 <_svfprintf_r+0xf20>)
  40da2c:	f89d a08f 	ldrb.w	sl, [sp, #143]	; 0x8f
  40da30:	900a      	str	r0, [sp, #40]	; 0x28
  40da32:	f04f 0c03 	mov.w	ip, #3
  40da36:	f024 0480 	bic.w	r4, r4, #128	; 0x80
  40da3a:	9409      	str	r4, [sp, #36]	; 0x24
  40da3c:	f8cd c02c 	str.w	ip, [sp, #44]	; 0x2c
  40da40:	9014      	str	r0, [sp, #80]	; 0x50
  40da42:	f1b8 0f47 	cmp.w	r8, #71	; 0x47
  40da46:	bfd8      	it	le
  40da48:	461f      	movle	r7, r3
  40da4a:	4664      	mov	r4, ip
  40da4c:	f7ff ba2f 	b.w	40ceae <_svfprintf_r+0x32e>
  40da50:	e9d3 4500 	ldrd	r4, r5, [r3]
  40da54:	3308      	adds	r3, #8
  40da56:	e9cd 4516 	strd	r4, r5, [sp, #88]	; 0x58
  40da5a:	9310      	str	r3, [sp, #64]	; 0x40
  40da5c:	e476      	b.n	40d34c <_svfprintf_r+0x7cc>
  40da5e:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
  40da62:	f01c 0f10 	tst.w	ip, #16
  40da66:	f000 8155 	beq.w	40dd14 <_svfprintf_r+0x1194>
  40da6a:	9c10      	ldr	r4, [sp, #64]	; 0x40
  40da6c:	9d0e      	ldr	r5, [sp, #56]	; 0x38
  40da6e:	6823      	ldr	r3, [r4, #0]
  40da70:	3404      	adds	r4, #4
  40da72:	9410      	str	r4, [sp, #64]	; 0x40
  40da74:	601d      	str	r5, [r3, #0]
  40da76:	f7ff b8a9 	b.w	40cbcc <_svfprintf_r+0x4c>
  40da7a:	9c09      	ldr	r4, [sp, #36]	; 0x24
  40da7c:	0664      	lsls	r4, r4, #25
  40da7e:	f140 8142 	bpl.w	40dd06 <_svfprintf_r+0x1186>
  40da82:	f8dd c040 	ldr.w	ip, [sp, #64]	; 0x40
  40da86:	f8bc 4000 	ldrh.w	r4, [ip]
  40da8a:	f10c 0c04 	add.w	ip, ip, #4
  40da8e:	2500      	movs	r5, #0
  40da90:	f8cd c040 	str.w	ip, [sp, #64]	; 0x40
  40da94:	f7ff b9ca 	b.w	40ce2c <_svfprintf_r+0x2ac>
  40da98:	00416e40 	.word	0x00416e40
  40da9c:	00416e5c 	.word	0x00416e5c
  40daa0:	00416e58 	.word	0x00416e58
  40daa4:	462c      	mov	r4, r5
  40daa6:	463d      	mov	r5, r7
  40daa8:	9f0a      	ldr	r7, [sp, #40]	; 0x28
  40daaa:	4694      	mov	ip, r2
  40daac:	3301      	adds	r3, #1
  40daae:	44a4      	add	ip, r4
  40dab0:	2b07      	cmp	r3, #7
  40dab2:	f8cd c0b4 	str.w	ip, [sp, #180]	; 0xb4
  40dab6:	932c      	str	r3, [sp, #176]	; 0xb0
  40dab8:	6035      	str	r5, [r6, #0]
  40daba:	6074      	str	r4, [r6, #4]
  40dabc:	f73f af14 	bgt.w	40d8e8 <_svfprintf_r+0xd68>
  40dac0:	3608      	adds	r6, #8
  40dac2:	e71c      	b.n	40d8fe <_svfprintf_r+0xd7e>
  40dac4:	980d      	ldr	r0, [sp, #52]	; 0x34
  40dac6:	990c      	ldr	r1, [sp, #48]	; 0x30
  40dac8:	aa2b      	add	r2, sp, #172	; 0xac
  40daca:	f005 ffd1 	bl	413a70 <__ssprint_r>
  40dace:	2800      	cmp	r0, #0
  40dad0:	f47f a96e 	bne.w	40cdb0 <_svfprintf_r+0x230>
  40dad4:	f8dd c0b4 	ldr.w	ip, [sp, #180]	; 0xb4
  40dad8:	ae38      	add	r6, sp, #224	; 0xe0
  40dada:	e4fd      	b.n	40d4d8 <_svfprintf_r+0x958>
  40dadc:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
  40dade:	49b7      	ldr	r1, [pc, #732]	; (40ddbc <_svfprintf_r+0x123c>)
  40dae0:	6031      	str	r1, [r6, #0]
  40dae2:	3201      	adds	r2, #1
  40dae4:	f10c 0c01 	add.w	ip, ip, #1
  40dae8:	2101      	movs	r1, #1
  40daea:	2a07      	cmp	r2, #7
  40daec:	f8cd c0b4 	str.w	ip, [sp, #180]	; 0xb4
  40daf0:	922c      	str	r2, [sp, #176]	; 0xb0
  40daf2:	6071      	str	r1, [r6, #4]
  40daf4:	f300 80f7 	bgt.w	40dce6 <_svfprintf_r+0x1166>
  40daf8:	3608      	adds	r6, #8
  40dafa:	461c      	mov	r4, r3
  40dafc:	b92c      	cbnz	r4, 40db0a <_svfprintf_r+0xf8a>
  40dafe:	9d11      	ldr	r5, [sp, #68]	; 0x44
  40db00:	b91d      	cbnz	r5, 40db0a <_svfprintf_r+0xf8a>
  40db02:	9d09      	ldr	r5, [sp, #36]	; 0x24
  40db04:	07e8      	lsls	r0, r5, #31
  40db06:	f57f aaad 	bpl.w	40d064 <_svfprintf_r+0x4e4>
  40db0a:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
  40db0c:	9918      	ldr	r1, [sp, #96]	; 0x60
  40db0e:	9d15      	ldr	r5, [sp, #84]	; 0x54
  40db10:	6035      	str	r5, [r6, #0]
  40db12:	3301      	adds	r3, #1
  40db14:	4461      	add	r1, ip
  40db16:	9d18      	ldr	r5, [sp, #96]	; 0x60
  40db18:	912d      	str	r1, [sp, #180]	; 0xb4
  40db1a:	2b07      	cmp	r3, #7
  40db1c:	6075      	str	r5, [r6, #4]
  40db1e:	932c      	str	r3, [sp, #176]	; 0xb0
  40db20:	f300 81de 	bgt.w	40dee0 <_svfprintf_r+0x1360>
  40db24:	f106 0208 	add.w	r2, r6, #8
  40db28:	4264      	negs	r4, r4
  40db2a:	2c00      	cmp	r4, #0
  40db2c:	f340 810b 	ble.w	40dd46 <_svfprintf_r+0x11c6>
  40db30:	2c10      	cmp	r4, #16
  40db32:	4da3      	ldr	r5, [pc, #652]	; (40ddc0 <_svfprintf_r+0x1240>)
  40db34:	f340 8148 	ble.w	40ddc8 <_svfprintf_r+0x1248>
  40db38:	46a3      	mov	fp, r4
  40db3a:	2610      	movs	r6, #16
  40db3c:	460c      	mov	r4, r1
  40db3e:	f8dd 8034 	ldr.w	r8, [sp, #52]	; 0x34
  40db42:	f8dd a030 	ldr.w	sl, [sp, #48]	; 0x30
  40db46:	e006      	b.n	40db56 <_svfprintf_r+0xfd6>
  40db48:	3208      	adds	r2, #8
  40db4a:	f1ab 0b10 	sub.w	fp, fp, #16
  40db4e:	f1bb 0f10 	cmp.w	fp, #16
  40db52:	f340 8137 	ble.w	40ddc4 <_svfprintf_r+0x1244>
  40db56:	3301      	adds	r3, #1
  40db58:	3410      	adds	r4, #16
  40db5a:	2b07      	cmp	r3, #7
  40db5c:	942d      	str	r4, [sp, #180]	; 0xb4
  40db5e:	932c      	str	r3, [sp, #176]	; 0xb0
  40db60:	e882 0060 	stmia.w	r2, {r5, r6}
  40db64:	ddf0      	ble.n	40db48 <_svfprintf_r+0xfc8>
  40db66:	4640      	mov	r0, r8
  40db68:	4651      	mov	r1, sl
  40db6a:	aa2b      	add	r2, sp, #172	; 0xac
  40db6c:	f005 ff80 	bl	413a70 <__ssprint_r>
  40db70:	2800      	cmp	r0, #0
  40db72:	f47f a91d 	bne.w	40cdb0 <_svfprintf_r+0x230>
  40db76:	9c2d      	ldr	r4, [sp, #180]	; 0xb4
  40db78:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
  40db7a:	aa38      	add	r2, sp, #224	; 0xe0
  40db7c:	e7e5      	b.n	40db4a <_svfprintf_r+0xfca>
  40db7e:	9c09      	ldr	r4, [sp, #36]	; 0x24
  40db80:	f893 8001 	ldrb.w	r8, [r3, #1]
  40db84:	f044 0420 	orr.w	r4, r4, #32
  40db88:	f109 0901 	add.w	r9, r9, #1
  40db8c:	9409      	str	r4, [sp, #36]	; 0x24
  40db8e:	f7ff b853 	b.w	40cc38 <_svfprintf_r+0xb8>
  40db92:	980d      	ldr	r0, [sp, #52]	; 0x34
  40db94:	990c      	ldr	r1, [sp, #48]	; 0x30
  40db96:	aa2b      	add	r2, sp, #172	; 0xac
  40db98:	f005 ff6a 	bl	413a70 <__ssprint_r>
  40db9c:	2800      	cmp	r0, #0
  40db9e:	f47f a907 	bne.w	40cdb0 <_svfprintf_r+0x230>
  40dba2:	f8dd c0b4 	ldr.w	ip, [sp, #180]	; 0xb4
  40dba6:	ae38      	add	r6, sp, #224	; 0xe0
  40dba8:	e4ac      	b.n	40d504 <_svfprintf_r+0x984>
  40dbaa:	9d0a      	ldr	r5, [sp, #40]	; 0x28
  40dbac:	3501      	adds	r5, #1
  40dbae:	f028 0a20 	bic.w	sl, r8, #32
  40dbb2:	f000 80a5 	beq.w	40dd00 <_svfprintf_r+0x1180>
  40dbb6:	f1ba 0f47 	cmp.w	sl, #71	; 0x47
  40dbba:	d104      	bne.n	40dbc6 <_svfprintf_r+0x1046>
  40dbbc:	9d0a      	ldr	r5, [sp, #40]	; 0x28
  40dbbe:	2d00      	cmp	r5, #0
  40dbc0:	bf08      	it	eq
  40dbc2:	2501      	moveq	r5, #1
  40dbc4:	950a      	str	r5, [sp, #40]	; 0x28
  40dbc6:	e9dd 2316 	ldrd	r2, r3, [sp, #88]	; 0x58
  40dbca:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
  40dbce:	2b00      	cmp	r3, #0
  40dbd0:	f44c 7c80 	orr.w	ip, ip, #256	; 0x100
  40dbd4:	f8cd c048 	str.w	ip, [sp, #72]	; 0x48
  40dbd8:	f2c0 819c 	blt.w	40df14 <_svfprintf_r+0x1394>
  40dbdc:	e9dd 4516 	ldrd	r4, r5, [sp, #88]	; 0x58
  40dbe0:	e9cd 4520 	strd	r4, r5, [sp, #128]	; 0x80
  40dbe4:	f04f 0b00 	mov.w	fp, #0
  40dbe8:	f1b8 0f66 	cmp.w	r8, #102	; 0x66
  40dbec:	f000 819b 	beq.w	40df26 <_svfprintf_r+0x13a6>
  40dbf0:	f1b8 0f46 	cmp.w	r8, #70	; 0x46
  40dbf4:	f000 81a9 	beq.w	40df4a <_svfprintf_r+0x13ca>
  40dbf8:	f1ba 0f45 	cmp.w	sl, #69	; 0x45
  40dbfc:	bf0a      	itet	eq
  40dbfe:	9c0a      	ldreq	r4, [sp, #40]	; 0x28
  40dc00:	9d0a      	ldrne	r5, [sp, #40]	; 0x28
  40dc02:	1c65      	addeq	r5, r4, #1
  40dc04:	2002      	movs	r0, #2
  40dc06:	a925      	add	r1, sp, #148	; 0x94
  40dc08:	aa26      	add	r2, sp, #152	; 0x98
  40dc0a:	ab29      	add	r3, sp, #164	; 0xa4
  40dc0c:	e88d 0021 	stmia.w	sp, {r0, r5}
  40dc10:	9203      	str	r2, [sp, #12]
  40dc12:	9304      	str	r3, [sp, #16]
  40dc14:	9102      	str	r1, [sp, #8]
  40dc16:	980d      	ldr	r0, [sp, #52]	; 0x34
  40dc18:	e9dd 2320 	ldrd	r2, r3, [sp, #128]	; 0x80
  40dc1c:	f002 f93c 	bl	40fe98 <_dtoa_r>
  40dc20:	f1b8 0f67 	cmp.w	r8, #103	; 0x67
  40dc24:	4607      	mov	r7, r0
  40dc26:	d002      	beq.n	40dc2e <_svfprintf_r+0x10ae>
  40dc28:	f1b8 0f47 	cmp.w	r8, #71	; 0x47
  40dc2c:	d105      	bne.n	40dc3a <_svfprintf_r+0x10ba>
  40dc2e:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
  40dc32:	f01c 0f01 	tst.w	ip, #1
  40dc36:	f000 819c 	beq.w	40df72 <_svfprintf_r+0x13f2>
  40dc3a:	f1ba 0f46 	cmp.w	sl, #70	; 0x46
  40dc3e:	eb07 0405 	add.w	r4, r7, r5
  40dc42:	f000 811c 	beq.w	40de7e <_svfprintf_r+0x12fe>
  40dc46:	e9dd 0120 	ldrd	r0, r1, [sp, #128]	; 0x80
  40dc4a:	2200      	movs	r2, #0
  40dc4c:	2300      	movs	r3, #0
  40dc4e:	f007 f9b7 	bl	414fc0 <__aeabi_dcmpeq>
  40dc52:	2800      	cmp	r0, #0
  40dc54:	f040 8105 	bne.w	40de62 <_svfprintf_r+0x12e2>
  40dc58:	9b29      	ldr	r3, [sp, #164]	; 0xa4
  40dc5a:	429c      	cmp	r4, r3
  40dc5c:	d906      	bls.n	40dc6c <_svfprintf_r+0x10ec>
  40dc5e:	2130      	movs	r1, #48	; 0x30
  40dc60:	1c5a      	adds	r2, r3, #1
  40dc62:	9229      	str	r2, [sp, #164]	; 0xa4
  40dc64:	7019      	strb	r1, [r3, #0]
  40dc66:	9b29      	ldr	r3, [sp, #164]	; 0xa4
  40dc68:	429c      	cmp	r4, r3
  40dc6a:	d8f9      	bhi.n	40dc60 <_svfprintf_r+0x10e0>
  40dc6c:	1bdb      	subs	r3, r3, r7
  40dc6e:	f1ba 0f47 	cmp.w	sl, #71	; 0x47
  40dc72:	9311      	str	r3, [sp, #68]	; 0x44
  40dc74:	f000 80ed 	beq.w	40de52 <_svfprintf_r+0x12d2>
  40dc78:	f1b8 0f65 	cmp.w	r8, #101	; 0x65
  40dc7c:	f340 81f2 	ble.w	40e064 <_svfprintf_r+0x14e4>
  40dc80:	f1b8 0f66 	cmp.w	r8, #102	; 0x66
  40dc84:	f000 8168 	beq.w	40df58 <_svfprintf_r+0x13d8>
  40dc88:	9c25      	ldr	r4, [sp, #148]	; 0x94
  40dc8a:	9414      	str	r4, [sp, #80]	; 0x50
  40dc8c:	9c11      	ldr	r4, [sp, #68]	; 0x44
  40dc8e:	9d14      	ldr	r5, [sp, #80]	; 0x50
  40dc90:	42ac      	cmp	r4, r5
  40dc92:	f300 8132 	bgt.w	40defa <_svfprintf_r+0x137a>
  40dc96:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
  40dc9a:	f01c 0f01 	tst.w	ip, #1
  40dc9e:	f040 81ad 	bne.w	40dffc <_svfprintf_r+0x147c>
  40dca2:	ea25 73e5 	bic.w	r3, r5, r5, asr #31
  40dca6:	462c      	mov	r4, r5
  40dca8:	f04f 0867 	mov.w	r8, #103	; 0x67
  40dcac:	f1bb 0f00 	cmp.w	fp, #0
  40dcb0:	f040 80b2 	bne.w	40de18 <_svfprintf_r+0x1298>
  40dcb4:	9d12      	ldr	r5, [sp, #72]	; 0x48
  40dcb6:	930b      	str	r3, [sp, #44]	; 0x2c
  40dcb8:	9509      	str	r5, [sp, #36]	; 0x24
  40dcba:	f8cd b028 	str.w	fp, [sp, #40]	; 0x28
  40dcbe:	f89d a08f 	ldrb.w	sl, [sp, #143]	; 0x8f
  40dcc2:	f7ff b8f4 	b.w	40ceae <_svfprintf_r+0x32e>
  40dcc6:	980d      	ldr	r0, [sp, #52]	; 0x34
  40dcc8:	2140      	movs	r1, #64	; 0x40
  40dcca:	f7fd ff91 	bl	40bbf0 <_malloc_r>
  40dcce:	6020      	str	r0, [r4, #0]
  40dcd0:	6120      	str	r0, [r4, #16]
  40dcd2:	2800      	cmp	r0, #0
  40dcd4:	f000 81bf 	beq.w	40e056 <_svfprintf_r+0x14d6>
  40dcd8:	f8dd c030 	ldr.w	ip, [sp, #48]	; 0x30
  40dcdc:	2340      	movs	r3, #64	; 0x40
  40dcde:	f8cc 3014 	str.w	r3, [ip, #20]
  40dce2:	f7fe bf63 	b.w	40cbac <_svfprintf_r+0x2c>
  40dce6:	980d      	ldr	r0, [sp, #52]	; 0x34
  40dce8:	990c      	ldr	r1, [sp, #48]	; 0x30
  40dcea:	aa2b      	add	r2, sp, #172	; 0xac
  40dcec:	f005 fec0 	bl	413a70 <__ssprint_r>
  40dcf0:	2800      	cmp	r0, #0
  40dcf2:	f47f a85d 	bne.w	40cdb0 <_svfprintf_r+0x230>
  40dcf6:	9c25      	ldr	r4, [sp, #148]	; 0x94
  40dcf8:	f8dd c0b4 	ldr.w	ip, [sp, #180]	; 0xb4
  40dcfc:	ae38      	add	r6, sp, #224	; 0xe0
  40dcfe:	e6fd      	b.n	40dafc <_svfprintf_r+0xf7c>
  40dd00:	2406      	movs	r4, #6
  40dd02:	940a      	str	r4, [sp, #40]	; 0x28
  40dd04:	e75f      	b.n	40dbc6 <_svfprintf_r+0x1046>
  40dd06:	9d10      	ldr	r5, [sp, #64]	; 0x40
  40dd08:	682c      	ldr	r4, [r5, #0]
  40dd0a:	3504      	adds	r5, #4
  40dd0c:	9510      	str	r5, [sp, #64]	; 0x40
  40dd0e:	2500      	movs	r5, #0
  40dd10:	f7ff b88c 	b.w	40ce2c <_svfprintf_r+0x2ac>
  40dd14:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
  40dd18:	f01c 0f40 	tst.w	ip, #64	; 0x40
  40dd1c:	f000 8087 	beq.w	40de2e <_svfprintf_r+0x12ae>
  40dd20:	9c10      	ldr	r4, [sp, #64]	; 0x40
  40dd22:	9d0e      	ldr	r5, [sp, #56]	; 0x38
  40dd24:	6823      	ldr	r3, [r4, #0]
  40dd26:	3404      	adds	r4, #4
  40dd28:	9410      	str	r4, [sp, #64]	; 0x40
  40dd2a:	801d      	strh	r5, [r3, #0]
  40dd2c:	f7fe bf4e 	b.w	40cbcc <_svfprintf_r+0x4c>
  40dd30:	980d      	ldr	r0, [sp, #52]	; 0x34
  40dd32:	990c      	ldr	r1, [sp, #48]	; 0x30
  40dd34:	aa2b      	add	r2, sp, #172	; 0xac
  40dd36:	f005 fe9b 	bl	413a70 <__ssprint_r>
  40dd3a:	2800      	cmp	r0, #0
  40dd3c:	f47f a838 	bne.w	40cdb0 <_svfprintf_r+0x230>
  40dd40:	992d      	ldr	r1, [sp, #180]	; 0xb4
  40dd42:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
  40dd44:	aa38      	add	r2, sp, #224	; 0xe0
  40dd46:	f8dd c044 	ldr.w	ip, [sp, #68]	; 0x44
  40dd4a:	9c11      	ldr	r4, [sp, #68]	; 0x44
  40dd4c:	6017      	str	r7, [r2, #0]
  40dd4e:	3301      	adds	r3, #1
  40dd50:	448c      	add	ip, r1
  40dd52:	2b07      	cmp	r3, #7
  40dd54:	f8cd c0b4 	str.w	ip, [sp, #180]	; 0xb4
  40dd58:	932c      	str	r3, [sp, #176]	; 0xb0
  40dd5a:	6054      	str	r4, [r2, #4]
  40dd5c:	f73f ac92 	bgt.w	40d684 <_svfprintf_r+0xb04>
  40dd60:	f102 0608 	add.w	r6, r2, #8
  40dd64:	f7ff b97e 	b.w	40d064 <_svfprintf_r+0x4e4>
  40dd68:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
  40dd6c:	f7fe fe1a 	bl	40c9a4 <strlen>
  40dd70:	9510      	str	r5, [sp, #64]	; 0x40
  40dd72:	ea20 7ce0 	bic.w	ip, r0, r0, asr #31
  40dd76:	9d0a      	ldr	r5, [sp, #40]	; 0x28
  40dd78:	f8cd c02c 	str.w	ip, [sp, #44]	; 0x2c
  40dd7c:	4604      	mov	r4, r0
  40dd7e:	9514      	str	r5, [sp, #80]	; 0x50
  40dd80:	f89d a08f 	ldrb.w	sl, [sp, #143]	; 0x8f
  40dd84:	f7ff b893 	b.w	40ceae <_svfprintf_r+0x32e>
  40dd88:	980d      	ldr	r0, [sp, #52]	; 0x34
  40dd8a:	990c      	ldr	r1, [sp, #48]	; 0x30
  40dd8c:	aa2b      	add	r2, sp, #172	; 0xac
  40dd8e:	f005 fe6f 	bl	413a70 <__ssprint_r>
  40dd92:	2800      	cmp	r0, #0
  40dd94:	f47f a80c 	bne.w	40cdb0 <_svfprintf_r+0x230>
  40dd98:	f8dd c0b4 	ldr.w	ip, [sp, #180]	; 0xb4
  40dd9c:	ae38      	add	r6, sp, #224	; 0xe0
  40dd9e:	e4cc      	b.n	40d73a <_svfprintf_r+0xbba>
  40dda0:	980d      	ldr	r0, [sp, #52]	; 0x34
  40dda2:	990c      	ldr	r1, [sp, #48]	; 0x30
  40dda4:	aa2b      	add	r2, sp, #172	; 0xac
  40dda6:	f005 fe63 	bl	413a70 <__ssprint_r>
  40ddaa:	2800      	cmp	r0, #0
  40ddac:	f47f a800 	bne.w	40cdb0 <_svfprintf_r+0x230>
  40ddb0:	9c25      	ldr	r4, [sp, #148]	; 0x94
  40ddb2:	f8dd c0b4 	ldr.w	ip, [sp, #180]	; 0xb4
  40ddb6:	ae38      	add	r6, sp, #224	; 0xe0
  40ddb8:	e5aa      	b.n	40d910 <_svfprintf_r+0xd90>
  40ddba:	bf00      	nop
  40ddbc:	00416e90 	.word	0x00416e90
  40ddc0:	00416e40 	.word	0x00416e40
  40ddc4:	4621      	mov	r1, r4
  40ddc6:	465c      	mov	r4, fp
  40ddc8:	3301      	adds	r3, #1
  40ddca:	4421      	add	r1, r4
  40ddcc:	2b07      	cmp	r3, #7
  40ddce:	912d      	str	r1, [sp, #180]	; 0xb4
  40ddd0:	932c      	str	r3, [sp, #176]	; 0xb0
  40ddd2:	6015      	str	r5, [r2, #0]
  40ddd4:	6054      	str	r4, [r2, #4]
  40ddd6:	dcab      	bgt.n	40dd30 <_svfprintf_r+0x11b0>
  40ddd8:	3208      	adds	r2, #8
  40ddda:	e7b4      	b.n	40dd46 <_svfprintf_r+0x11c6>
  40dddc:	980d      	ldr	r0, [sp, #52]	; 0x34
  40ddde:	990c      	ldr	r1, [sp, #48]	; 0x30
  40dde0:	aa2b      	add	r2, sp, #172	; 0xac
  40dde2:	f005 fe45 	bl	413a70 <__ssprint_r>
  40dde6:	2800      	cmp	r0, #0
  40dde8:	f47e afe2 	bne.w	40cdb0 <_svfprintf_r+0x230>
  40ddec:	9c25      	ldr	r4, [sp, #148]	; 0x94
  40ddee:	9911      	ldr	r1, [sp, #68]	; 0x44
  40ddf0:	f8dd c0b4 	ldr.w	ip, [sp, #180]	; 0xb4
  40ddf4:	1b0c      	subs	r4, r1, r4
  40ddf6:	ae38      	add	r6, sp, #224	; 0xe0
  40ddf8:	e59f      	b.n	40d93a <_svfprintf_r+0xdba>
  40ddfa:	9c0a      	ldr	r4, [sp, #40]	; 0x28
  40ddfc:	9714      	str	r7, [sp, #80]	; 0x50
  40ddfe:	2c06      	cmp	r4, #6
  40de00:	bf28      	it	cs
  40de02:	2406      	movcs	r4, #6
  40de04:	ea24 7ce4 	bic.w	ip, r4, r4, asr #31
  40de08:	46ba      	mov	sl, r7
  40de0a:	970a      	str	r7, [sp, #40]	; 0x28
  40de0c:	9510      	str	r5, [sp, #64]	; 0x40
  40de0e:	f8cd c02c 	str.w	ip, [sp, #44]	; 0x2c
  40de12:	4f97      	ldr	r7, [pc, #604]	; (40e070 <_svfprintf_r+0x14f0>)
  40de14:	f7ff b84b 	b.w	40ceae <_svfprintf_r+0x32e>
  40de18:	9d12      	ldr	r5, [sp, #72]	; 0x48
  40de1a:	9509      	str	r5, [sp, #36]	; 0x24
  40de1c:	f04f 0a2d 	mov.w	sl, #45	; 0x2d
  40de20:	2500      	movs	r5, #0
  40de22:	930b      	str	r3, [sp, #44]	; 0x2c
  40de24:	f88d a08f 	strb.w	sl, [sp, #143]	; 0x8f
  40de28:	950a      	str	r5, [sp, #40]	; 0x28
  40de2a:	f7ff b843 	b.w	40ceb4 <_svfprintf_r+0x334>
  40de2e:	f8dd c040 	ldr.w	ip, [sp, #64]	; 0x40
  40de32:	9c0e      	ldr	r4, [sp, #56]	; 0x38
  40de34:	f8dc 3000 	ldr.w	r3, [ip]
  40de38:	f10c 0c04 	add.w	ip, ip, #4
  40de3c:	f8cd c040 	str.w	ip, [sp, #64]	; 0x40
  40de40:	601c      	str	r4, [r3, #0]
  40de42:	f7fe bec3 	b.w	40cbcc <_svfprintf_r+0x4c>
  40de46:	f04f 0a2d 	mov.w	sl, #45	; 0x2d
  40de4a:	f88d a08f 	strb.w	sl, [sp, #143]	; 0x8f
  40de4e:	f7ff ba8f 	b.w	40d370 <_svfprintf_r+0x7f0>
  40de52:	9b25      	ldr	r3, [sp, #148]	; 0x94
  40de54:	1cdc      	adds	r4, r3, #3
  40de56:	db19      	blt.n	40de8c <_svfprintf_r+0x130c>
  40de58:	9c0a      	ldr	r4, [sp, #40]	; 0x28
  40de5a:	429c      	cmp	r4, r3
  40de5c:	db16      	blt.n	40de8c <_svfprintf_r+0x130c>
  40de5e:	9314      	str	r3, [sp, #80]	; 0x50
  40de60:	e714      	b.n	40dc8c <_svfprintf_r+0x110c>
  40de62:	4623      	mov	r3, r4
  40de64:	e702      	b.n	40dc6c <_svfprintf_r+0x10ec>
  40de66:	ea24 7ce4 	bic.w	ip, r4, r4, asr #31
  40de6a:	f8cd c02c 	str.w	ip, [sp, #44]	; 0x2c
  40de6e:	9c0a      	ldr	r4, [sp, #40]	; 0x28
  40de70:	9510      	str	r5, [sp, #64]	; 0x40
  40de72:	900a      	str	r0, [sp, #40]	; 0x28
  40de74:	9014      	str	r0, [sp, #80]	; 0x50
  40de76:	f89d a08f 	ldrb.w	sl, [sp, #143]	; 0x8f
  40de7a:	f7ff b818 	b.w	40ceae <_svfprintf_r+0x32e>
  40de7e:	783b      	ldrb	r3, [r7, #0]
  40de80:	2b30      	cmp	r3, #48	; 0x30
  40de82:	f000 80ad 	beq.w	40dfe0 <_svfprintf_r+0x1460>
  40de86:	9d25      	ldr	r5, [sp, #148]	; 0x94
  40de88:	442c      	add	r4, r5
  40de8a:	e6dc      	b.n	40dc46 <_svfprintf_r+0x10c6>
  40de8c:	f1a8 0802 	sub.w	r8, r8, #2
  40de90:	3b01      	subs	r3, #1
  40de92:	2b00      	cmp	r3, #0
  40de94:	9325      	str	r3, [sp, #148]	; 0x94
  40de96:	bfba      	itte	lt
  40de98:	425b      	neglt	r3, r3
  40de9a:	222d      	movlt	r2, #45	; 0x2d
  40de9c:	222b      	movge	r2, #43	; 0x2b
  40de9e:	2b09      	cmp	r3, #9
  40dea0:	f88d 809c 	strb.w	r8, [sp, #156]	; 0x9c
  40dea4:	f88d 209d 	strb.w	r2, [sp, #157]	; 0x9d
  40dea8:	dc65      	bgt.n	40df76 <_svfprintf_r+0x13f6>
  40deaa:	3330      	adds	r3, #48	; 0x30
  40deac:	2230      	movs	r2, #48	; 0x30
  40deae:	f88d 309f 	strb.w	r3, [sp, #159]	; 0x9f
  40deb2:	f88d 209e 	strb.w	r2, [sp, #158]	; 0x9e
  40deb6:	ab28      	add	r3, sp, #160	; 0xa0
  40deb8:	9d11      	ldr	r5, [sp, #68]	; 0x44
  40deba:	9c11      	ldr	r4, [sp, #68]	; 0x44
  40debc:	aa27      	add	r2, sp, #156	; 0x9c
  40debe:	1a9a      	subs	r2, r3, r2
  40dec0:	2d01      	cmp	r5, #1
  40dec2:	9219      	str	r2, [sp, #100]	; 0x64
  40dec4:	4414      	add	r4, r2
  40dec6:	f340 80b7 	ble.w	40e038 <_svfprintf_r+0x14b8>
  40deca:	3401      	adds	r4, #1
  40decc:	2500      	movs	r5, #0
  40dece:	ea24 73e4 	bic.w	r3, r4, r4, asr #31
  40ded2:	9514      	str	r5, [sp, #80]	; 0x50
  40ded4:	e6ea      	b.n	40dcac <_svfprintf_r+0x112c>
  40ded6:	2400      	movs	r4, #0
  40ded8:	4681      	mov	r9, r0
  40deda:	940a      	str	r4, [sp, #40]	; 0x28
  40dedc:	f7fe beae 	b.w	40cc3c <_svfprintf_r+0xbc>
  40dee0:	980d      	ldr	r0, [sp, #52]	; 0x34
  40dee2:	990c      	ldr	r1, [sp, #48]	; 0x30
  40dee4:	aa2b      	add	r2, sp, #172	; 0xac
  40dee6:	f005 fdc3 	bl	413a70 <__ssprint_r>
  40deea:	2800      	cmp	r0, #0
  40deec:	f47e af60 	bne.w	40cdb0 <_svfprintf_r+0x230>
  40def0:	9c25      	ldr	r4, [sp, #148]	; 0x94
  40def2:	992d      	ldr	r1, [sp, #180]	; 0xb4
  40def4:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
  40def6:	aa38      	add	r2, sp, #224	; 0xe0
  40def8:	e616      	b.n	40db28 <_svfprintf_r+0xfa8>
  40defa:	9c14      	ldr	r4, [sp, #80]	; 0x50
  40defc:	9d11      	ldr	r5, [sp, #68]	; 0x44
  40defe:	2c00      	cmp	r4, #0
  40df00:	bfd4      	ite	le
  40df02:	f1c4 0402 	rsble	r4, r4, #2
  40df06:	2401      	movgt	r4, #1
  40df08:	442c      	add	r4, r5
  40df0a:	ea24 73e4 	bic.w	r3, r4, r4, asr #31
  40df0e:	f04f 0867 	mov.w	r8, #103	; 0x67
  40df12:	e6cb      	b.n	40dcac <_svfprintf_r+0x112c>
  40df14:	9917      	ldr	r1, [sp, #92]	; 0x5c
  40df16:	9816      	ldr	r0, [sp, #88]	; 0x58
  40df18:	9020      	str	r0, [sp, #128]	; 0x80
  40df1a:	f101 4100 	add.w	r1, r1, #2147483648	; 0x80000000
  40df1e:	9121      	str	r1, [sp, #132]	; 0x84
  40df20:	f04f 0b2d 	mov.w	fp, #45	; 0x2d
  40df24:	e660      	b.n	40dbe8 <_svfprintf_r+0x1068>
  40df26:	9d0a      	ldr	r5, [sp, #40]	; 0x28
  40df28:	9501      	str	r5, [sp, #4]
  40df2a:	2003      	movs	r0, #3
  40df2c:	a925      	add	r1, sp, #148	; 0x94
  40df2e:	aa26      	add	r2, sp, #152	; 0x98
  40df30:	ab29      	add	r3, sp, #164	; 0xa4
  40df32:	9000      	str	r0, [sp, #0]
  40df34:	9203      	str	r2, [sp, #12]
  40df36:	9304      	str	r3, [sp, #16]
  40df38:	9102      	str	r1, [sp, #8]
  40df3a:	980d      	ldr	r0, [sp, #52]	; 0x34
  40df3c:	e9dd 2320 	ldrd	r2, r3, [sp, #128]	; 0x80
  40df40:	f001 ffaa 	bl	40fe98 <_dtoa_r>
  40df44:	9d0a      	ldr	r5, [sp, #40]	; 0x28
  40df46:	4607      	mov	r7, r0
  40df48:	e677      	b.n	40dc3a <_svfprintf_r+0x10ba>
  40df4a:	9c0a      	ldr	r4, [sp, #40]	; 0x28
  40df4c:	9401      	str	r4, [sp, #4]
  40df4e:	2003      	movs	r0, #3
  40df50:	a925      	add	r1, sp, #148	; 0x94
  40df52:	aa26      	add	r2, sp, #152	; 0x98
  40df54:	ab29      	add	r3, sp, #164	; 0xa4
  40df56:	e7ec      	b.n	40df32 <_svfprintf_r+0x13b2>
  40df58:	9d25      	ldr	r5, [sp, #148]	; 0x94
  40df5a:	9514      	str	r5, [sp, #80]	; 0x50
  40df5c:	2d00      	cmp	r5, #0
  40df5e:	9c0a      	ldr	r4, [sp, #40]	; 0x28
  40df60:	dd63      	ble.n	40e02a <_svfprintf_r+0x14aa>
  40df62:	bbb4      	cbnz	r4, 40dfd2 <_svfprintf_r+0x1452>
  40df64:	9d09      	ldr	r5, [sp, #36]	; 0x24
  40df66:	07e8      	lsls	r0, r5, #31
  40df68:	d433      	bmi.n	40dfd2 <_svfprintf_r+0x1452>
  40df6a:	9c14      	ldr	r4, [sp, #80]	; 0x50
  40df6c:	ea24 73e4 	bic.w	r3, r4, r4, asr #31
  40df70:	e69c      	b.n	40dcac <_svfprintf_r+0x112c>
  40df72:	9b29      	ldr	r3, [sp, #164]	; 0xa4
  40df74:	e67a      	b.n	40dc6c <_svfprintf_r+0x10ec>
  40df76:	f10d 00aa 	add.w	r0, sp, #170	; 0xaa
  40df7a:	4d3e      	ldr	r5, [pc, #248]	; (40e074 <_svfprintf_r+0x14f4>)
  40df7c:	17da      	asrs	r2, r3, #31
  40df7e:	fb85 5103 	smull	r5, r1, r5, r3
  40df82:	ebc2 01a1 	rsb	r1, r2, r1, asr #2
  40df86:	eb01 0481 	add.w	r4, r1, r1, lsl #2
  40df8a:	4602      	mov	r2, r0
  40df8c:	eba3 0344 	sub.w	r3, r3, r4, lsl #1
  40df90:	f103 0030 	add.w	r0, r3, #48	; 0x30
  40df94:	2909      	cmp	r1, #9
  40df96:	7010      	strb	r0, [r2, #0]
  40df98:	460b      	mov	r3, r1
  40df9a:	f102 30ff 	add.w	r0, r2, #4294967295
  40df9e:	dcec      	bgt.n	40df7a <_svfprintf_r+0x13fa>
  40dfa0:	f101 0330 	add.w	r3, r1, #48	; 0x30
  40dfa4:	f10d 04ab 	add.w	r4, sp, #171	; 0xab
  40dfa8:	b2d9      	uxtb	r1, r3
  40dfaa:	4284      	cmp	r4, r0
  40dfac:	f802 1c01 	strb.w	r1, [r2, #-1]
  40dfb0:	d95a      	bls.n	40e068 <_svfprintf_r+0x14e8>
  40dfb2:	f10d 009d 	add.w	r0, sp, #157	; 0x9d
  40dfb6:	4613      	mov	r3, r2
  40dfb8:	e001      	b.n	40dfbe <_svfprintf_r+0x143e>
  40dfba:	f813 1b01 	ldrb.w	r1, [r3], #1
  40dfbe:	42a3      	cmp	r3, r4
  40dfc0:	f800 1f01 	strb.w	r1, [r0, #1]!
  40dfc4:	d1f9      	bne.n	40dfba <_svfprintf_r+0x143a>
  40dfc6:	f50d 7c90 	add.w	ip, sp, #288	; 0x120
  40dfca:	ebc2 034c 	rsb	r3, r2, ip, lsl #1
  40dfce:	3bf6      	subs	r3, #246	; 0xf6
  40dfd0:	e772      	b.n	40deb8 <_svfprintf_r+0x1338>
  40dfd2:	9d0a      	ldr	r5, [sp, #40]	; 0x28
  40dfd4:	1c6c      	adds	r4, r5, #1
  40dfd6:	9d14      	ldr	r5, [sp, #80]	; 0x50
  40dfd8:	442c      	add	r4, r5
  40dfda:	ea24 73e4 	bic.w	r3, r4, r4, asr #31
  40dfde:	e665      	b.n	40dcac <_svfprintf_r+0x112c>
  40dfe0:	e9dd 0120 	ldrd	r0, r1, [sp, #128]	; 0x80
  40dfe4:	2200      	movs	r2, #0
  40dfe6:	2300      	movs	r3, #0
  40dfe8:	f006 ffea 	bl	414fc0 <__aeabi_dcmpeq>
  40dfec:	2800      	cmp	r0, #0
  40dfee:	f47f af4a 	bne.w	40de86 <_svfprintf_r+0x1306>
  40dff2:	f1c5 0501 	rsb	r5, r5, #1
  40dff6:	9525      	str	r5, [sp, #148]	; 0x94
  40dff8:	442c      	add	r4, r5
  40dffa:	e624      	b.n	40dc46 <_svfprintf_r+0x10c6>
  40dffc:	9d14      	ldr	r5, [sp, #80]	; 0x50
  40dffe:	1c6c      	adds	r4, r5, #1
  40e000:	ea24 73e4 	bic.w	r3, r4, r4, asr #31
  40e004:	f04f 0867 	mov.w	r8, #103	; 0x67
  40e008:	e650      	b.n	40dcac <_svfprintf_r+0x112c>
  40e00a:	9d10      	ldr	r5, [sp, #64]	; 0x40
  40e00c:	f8dd c040 	ldr.w	ip, [sp, #64]	; 0x40
  40e010:	682d      	ldr	r5, [r5, #0]
  40e012:	f899 8001 	ldrb.w	r8, [r9, #1]
  40e016:	950a      	str	r5, [sp, #40]	; 0x28
  40e018:	f10c 0304 	add.w	r3, ip, #4
  40e01c:	2d00      	cmp	r5, #0
  40e01e:	9310      	str	r3, [sp, #64]	; 0x40
  40e020:	4681      	mov	r9, r0
  40e022:	f6be ae09 	bge.w	40cc38 <_svfprintf_r+0xb8>
  40e026:	f7fe be04 	b.w	40cc32 <_svfprintf_r+0xb2>
  40e02a:	b97c      	cbnz	r4, 40e04c <_svfprintf_r+0x14cc>
  40e02c:	9d09      	ldr	r5, [sp, #36]	; 0x24
  40e02e:	07e9      	lsls	r1, r5, #31
  40e030:	d40c      	bmi.n	40e04c <_svfprintf_r+0x14cc>
  40e032:	2301      	movs	r3, #1
  40e034:	461c      	mov	r4, r3
  40e036:	e639      	b.n	40dcac <_svfprintf_r+0x112c>
  40e038:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
  40e03c:	f01c 0301 	ands.w	r3, ip, #1
  40e040:	f47f af43 	bne.w	40deca <_svfprintf_r+0x134a>
  40e044:	9314      	str	r3, [sp, #80]	; 0x50
  40e046:	ea24 73e4 	bic.w	r3, r4, r4, asr #31
  40e04a:	e62f      	b.n	40dcac <_svfprintf_r+0x112c>
  40e04c:	9d0a      	ldr	r5, [sp, #40]	; 0x28
  40e04e:	1cac      	adds	r4, r5, #2
  40e050:	ea24 73e4 	bic.w	r3, r4, r4, asr #31
  40e054:	e62a      	b.n	40dcac <_svfprintf_r+0x112c>
  40e056:	9d0d      	ldr	r5, [sp, #52]	; 0x34
  40e058:	230c      	movs	r3, #12
  40e05a:	602b      	str	r3, [r5, #0]
  40e05c:	f04f 30ff 	mov.w	r0, #4294967295
  40e060:	f7fe beae 	b.w	40cdc0 <_svfprintf_r+0x240>
  40e064:	9b25      	ldr	r3, [sp, #148]	; 0x94
  40e066:	e713      	b.n	40de90 <_svfprintf_r+0x1310>
  40e068:	f10d 039e 	add.w	r3, sp, #158	; 0x9e
  40e06c:	e724      	b.n	40deb8 <_svfprintf_r+0x1338>
  40e06e:	bf00      	nop
  40e070:	00416e88 	.word	0x00416e88
  40e074:	66666667 	.word	0x66666667

0040e078 <__ssvfscanf_r>:
  40e078:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40e07c:	460d      	mov	r5, r1
  40e07e:	8989      	ldrh	r1, [r1, #12]
  40e080:	f5ad 7d2f 	sub.w	sp, sp, #700	; 0x2bc
  40e084:	048c      	lsls	r4, r1, #18
  40e086:	900e      	str	r0, [sp, #56]	; 0x38
  40e088:	9306      	str	r3, [sp, #24]
  40e08a:	d406      	bmi.n	40e09a <__ssvfscanf_r+0x22>
  40e08c:	6e6b      	ldr	r3, [r5, #100]	; 0x64
  40e08e:	f441 5100 	orr.w	r1, r1, #8192	; 0x2000
  40e092:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
  40e096:	81a9      	strh	r1, [r5, #12]
  40e098:	666b      	str	r3, [r5, #100]	; 0x64
  40e09a:	4692      	mov	sl, r2
  40e09c:	2400      	movs	r4, #0
  40e09e:	f81a 3b01 	ldrb.w	r3, [sl], #1
  40e0a2:	9409      	str	r4, [sp, #36]	; 0x24
  40e0a4:	940c      	str	r4, [sp, #48]	; 0x30
  40e0a6:	46a1      	mov	r9, r4
  40e0a8:	940b      	str	r4, [sp, #44]	; 0x2c
  40e0aa:	f8df 83e4 	ldr.w	r8, [pc, #996]	; 40e490 <__ssvfscanf_r+0x418>
  40e0ae:	9e0e      	ldr	r6, [sp, #56]	; 0x38
  40e0b0:	9313      	str	r3, [sp, #76]	; 0x4c
  40e0b2:	b343      	cbz	r3, 40e106 <__ssvfscanf_r+0x8e>
  40e0b4:	f8d8 1000 	ldr.w	r1, [r8]
  40e0b8:	18c8      	adds	r0, r1, r3
  40e0ba:	7840      	ldrb	r0, [r0, #1]
  40e0bc:	f000 0008 	and.w	r0, r0, #8
  40e0c0:	f000 07ff 	and.w	r7, r0, #255	; 0xff
  40e0c4:	b320      	cbz	r0, 40e110 <__ssvfscanf_r+0x98>
  40e0c6:	686b      	ldr	r3, [r5, #4]
  40e0c8:	e00e      	b.n	40e0e8 <__ssvfscanf_r+0x70>
  40e0ca:	682b      	ldr	r3, [r5, #0]
  40e0cc:	f8d8 2000 	ldr.w	r2, [r8]
  40e0d0:	7819      	ldrb	r1, [r3, #0]
  40e0d2:	440a      	add	r2, r1
  40e0d4:	3301      	adds	r3, #1
  40e0d6:	7852      	ldrb	r2, [r2, #1]
  40e0d8:	0710      	lsls	r0, r2, #28
  40e0da:	d50d      	bpl.n	40e0f8 <__ssvfscanf_r+0x80>
  40e0dc:	686a      	ldr	r2, [r5, #4]
  40e0de:	602b      	str	r3, [r5, #0]
  40e0e0:	1e53      	subs	r3, r2, #1
  40e0e2:	f109 0901 	add.w	r9, r9, #1
  40e0e6:	606b      	str	r3, [r5, #4]
  40e0e8:	2b00      	cmp	r3, #0
  40e0ea:	dcee      	bgt.n	40e0ca <__ssvfscanf_r+0x52>
  40e0ec:	4630      	mov	r0, r6
  40e0ee:	4629      	mov	r1, r5
  40e0f0:	f005 fd7e 	bl	413bf0 <__ssrefill_r>
  40e0f4:	2800      	cmp	r0, #0
  40e0f6:	d0e8      	beq.n	40e0ca <__ssvfscanf_r+0x52>
  40e0f8:	4652      	mov	r2, sl
  40e0fa:	4692      	mov	sl, r2
  40e0fc:	f81a 3b01 	ldrb.w	r3, [sl], #1
  40e100:	9313      	str	r3, [sp, #76]	; 0x4c
  40e102:	2b00      	cmp	r3, #0
  40e104:	d1d6      	bne.n	40e0b4 <__ssvfscanf_r+0x3c>
  40e106:	980b      	ldr	r0, [sp, #44]	; 0x2c
  40e108:	f50d 7d2f 	add.w	sp, sp, #700	; 0x2bc
  40e10c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40e110:	2b25      	cmp	r3, #37	; 0x25
  40e112:	f040 8084 	bne.w	40e21e <__ssvfscanf_r+0x1a6>
  40e116:	7853      	ldrb	r3, [r2, #1]
  40e118:	463c      	mov	r4, r7
  40e11a:	f10a 0201 	add.w	r2, sl, #1
  40e11e:	2b78      	cmp	r3, #120	; 0x78
  40e120:	f200 82e5 	bhi.w	40e6ee <__ssvfscanf_r+0x676>
  40e124:	e8df f013 	tbh	[pc, r3, lsl #1]
  40e128:	02e3008f 	.word	0x02e3008f
  40e12c:	02e302e3 	.word	0x02e302e3
  40e130:	02e302e3 	.word	0x02e302e3
  40e134:	02e302e3 	.word	0x02e302e3
  40e138:	02e302e3 	.word	0x02e302e3
  40e13c:	02e302e3 	.word	0x02e302e3
  40e140:	02e302e3 	.word	0x02e302e3
  40e144:	02e302e3 	.word	0x02e302e3
  40e148:	02e302e3 	.word	0x02e302e3
  40e14c:	02e302e3 	.word	0x02e302e3
  40e150:	02e302e3 	.word	0x02e302e3
  40e154:	02e302e3 	.word	0x02e302e3
  40e158:	02e302e3 	.word	0x02e302e3
  40e15c:	02e302e3 	.word	0x02e302e3
  40e160:	02e302e3 	.word	0x02e302e3
  40e164:	02e302e3 	.word	0x02e302e3
  40e168:	02e302e3 	.word	0x02e302e3
  40e16c:	02e302e3 	.word	0x02e302e3
  40e170:	007902e3 	.word	0x007902e3
  40e174:	02e302e3 	.word	0x02e302e3
  40e178:	02e302e3 	.word	0x02e302e3
  40e17c:	02e30226 	.word	0x02e30226
  40e180:	02e302e3 	.word	0x02e302e3
  40e184:	02e302e3 	.word	0x02e302e3
  40e188:	024f024f 	.word	0x024f024f
  40e18c:	024f024f 	.word	0x024f024f
  40e190:	024f024f 	.word	0x024f024f
  40e194:	024f024f 	.word	0x024f024f
  40e198:	024f024f 	.word	0x024f024f
  40e19c:	02e302e3 	.word	0x02e302e3
  40e1a0:	02e302e3 	.word	0x02e302e3
  40e1a4:	02e302e3 	.word	0x02e302e3
  40e1a8:	02e302e3 	.word	0x02e302e3
  40e1ac:	02e302e3 	.word	0x02e302e3
  40e1b0:	0273022c 	.word	0x0273022c
  40e1b4:	027302e3 	.word	0x027302e3
  40e1b8:	02e302e3 	.word	0x02e302e3
  40e1bc:	02e302e3 	.word	0x02e302e3
  40e1c0:	02e3026d 	.word	0x02e3026d
  40e1c4:	026302e3 	.word	0x026302e3
  40e1c8:	02e302e3 	.word	0x02e302e3
  40e1cc:	02e302e3 	.word	0x02e302e3
  40e1d0:	02e302e3 	.word	0x02e302e3
  40e1d4:	02e302e3 	.word	0x02e302e3
  40e1d8:	02e30259 	.word	0x02e30259
  40e1dc:	029302e3 	.word	0x029302e3
  40e1e0:	02e302e3 	.word	0x02e302e3
  40e1e4:	02e302e3 	.word	0x02e302e3
  40e1e8:	02e302e3 	.word	0x02e302e3
  40e1ec:	028d02e3 	.word	0x028d02e3
  40e1f0:	0273029e 	.word	0x0273029e
  40e1f4:	02730273 	.word	0x02730273
  40e1f8:	00950287 	.word	0x00950287
  40e1fc:	02e302e3 	.word	0x02e302e3
  40e200:	02e302b6 	.word	0x02e302b6
  40e204:	02770279 	.word	0x02770279
  40e208:	02e302ac 	.word	0x02e302ac
  40e20c:	02a802e3 	.word	0x02a802e3
  40e210:	02a002e3 	.word	0x02a002e3
  40e214:	02e302e3 	.word	0x02e302e3
  40e218:	0259      	.short	0x0259
  40e21a:	9207      	str	r2, [sp, #28]
  40e21c:	4692      	mov	sl, r2
  40e21e:	686b      	ldr	r3, [r5, #4]
  40e220:	2b00      	cmp	r3, #0
  40e222:	f340 8557 	ble.w	40ecd4 <__ssvfscanf_r+0xc5c>
  40e226:	682b      	ldr	r3, [r5, #0]
  40e228:	f81a 2c01 	ldrb.w	r2, [sl, #-1]
  40e22c:	7819      	ldrb	r1, [r3, #0]
  40e22e:	4291      	cmp	r1, r2
  40e230:	f47f af69 	bne.w	40e106 <__ssvfscanf_r+0x8e>
  40e234:	686a      	ldr	r2, [r5, #4]
  40e236:	3301      	adds	r3, #1
  40e238:	3a01      	subs	r2, #1
  40e23a:	606a      	str	r2, [r5, #4]
  40e23c:	602b      	str	r3, [r5, #0]
  40e23e:	f109 0901 	add.w	r9, r9, #1
  40e242:	4652      	mov	r2, sl
  40e244:	e759      	b.n	40e0fa <__ssvfscanf_r+0x82>
  40e246:	f04f 30ff 	mov.w	r0, #4294967295
  40e24a:	f50d 7d2f 	add.w	sp, sp, #700	; 0x2bc
  40e24e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40e252:	9207      	str	r2, [sp, #28]
  40e254:	2300      	movs	r3, #0
  40e256:	4a8d      	ldr	r2, [pc, #564]	; (40e48c <__ssvfscanf_r+0x414>)
  40e258:	9209      	str	r2, [sp, #36]	; 0x24
  40e25a:	930c      	str	r3, [sp, #48]	; 0x30
  40e25c:	f04f 0a03 	mov.w	sl, #3
  40e260:	686b      	ldr	r3, [r5, #4]
  40e262:	2b00      	cmp	r3, #0
  40e264:	f340 8199 	ble.w	40e59a <__ssvfscanf_r+0x522>
  40e268:	0679      	lsls	r1, r7, #25
  40e26a:	d512      	bpl.n	40e292 <__ssvfscanf_r+0x21a>
  40e26c:	f10a 3aff 	add.w	sl, sl, #4294967295
  40e270:	f1ba 0f03 	cmp.w	sl, #3
  40e274:	f200 80b7 	bhi.w	40e3e6 <__ssvfscanf_r+0x36e>
  40e278:	e8df f01a 	tbh	[pc, sl, lsl #1]
  40e27c:	008e00da 	.word	0x008e00da
  40e280:	0244001e 	.word	0x0244001e
  40e284:	4630      	mov	r0, r6
  40e286:	4629      	mov	r1, r5
  40e288:	f005 fcb2 	bl	413bf0 <__ssrefill_r>
  40e28c:	2800      	cmp	r0, #0
  40e28e:	f040 818b 	bne.w	40e5a8 <__ssvfscanf_r+0x530>
  40e292:	f8d8 1000 	ldr.w	r1, [r8]
  40e296:	682b      	ldr	r3, [r5, #0]
  40e298:	e000      	b.n	40e29c <__ssvfscanf_r+0x224>
  40e29a:	602b      	str	r3, [r5, #0]
  40e29c:	781a      	ldrb	r2, [r3, #0]
  40e29e:	440a      	add	r2, r1
  40e2a0:	3301      	adds	r3, #1
  40e2a2:	7852      	ldrb	r2, [r2, #1]
  40e2a4:	0712      	lsls	r2, r2, #28
  40e2a6:	d5e1      	bpl.n	40e26c <__ssvfscanf_r+0x1f4>
  40e2a8:	686a      	ldr	r2, [r5, #4]
  40e2aa:	3a01      	subs	r2, #1
  40e2ac:	2a00      	cmp	r2, #0
  40e2ae:	f109 0901 	add.w	r9, r9, #1
  40e2b2:	606a      	str	r2, [r5, #4]
  40e2b4:	dcf1      	bgt.n	40e29a <__ssvfscanf_r+0x222>
  40e2b6:	e7e5      	b.n	40e284 <__ssvfscanf_r+0x20c>
  40e2b8:	1e63      	subs	r3, r4, #1
  40e2ba:	f5b3 7fae 	cmp.w	r3, #348	; 0x15c
  40e2be:	bf86      	itte	hi
  40e2c0:	f46f 71ae 	mvnhi.w	r1, #348	; 0x15c
  40e2c4:	1863      	addhi	r3, r4, r1
  40e2c6:	2300      	movls	r3, #0
  40e2c8:	f04f 0b00 	mov.w	fp, #0
  40e2cc:	f50d 7cac 	add.w	ip, sp, #344	; 0x158
  40e2d0:	9308      	str	r3, [sp, #32]
  40e2d2:	465b      	mov	r3, fp
  40e2d4:	46b3      	mov	fp, r6
  40e2d6:	9e0c      	ldr	r6, [sp, #48]	; 0x30
  40e2d8:	f8cd c014 	str.w	ip, [sp, #20]
  40e2dc:	46e2      	mov	sl, ip
  40e2de:	bf88      	it	hi
  40e2e0:	f240 145d 	movwhi	r4, #349	; 0x15d
  40e2e4:	f447 6758 	orr.w	r7, r7, #3456	; 0xd80
  40e2e8:	46cc      	mov	ip, r9
  40e2ea:	6828      	ldr	r0, [r5, #0]
  40e2ec:	7801      	ldrb	r1, [r0, #0]
  40e2ee:	f1a1 022b 	sub.w	r2, r1, #43	; 0x2b
  40e2f2:	2a4d      	cmp	r2, #77	; 0x4d
  40e2f4:	f200 80e2 	bhi.w	40e4bc <__ssvfscanf_r+0x444>
  40e2f8:	e8df f012 	tbh	[pc, r2, lsl #1]
  40e2fc:	00e00126 	.word	0x00e00126
  40e300:	00e00126 	.word	0x00e00126
  40e304:	00fd00e0 	.word	0x00fd00e0
  40e308:	00cc00cc 	.word	0x00cc00cc
  40e30c:	00cc00cc 	.word	0x00cc00cc
  40e310:	00cc00cc 	.word	0x00cc00cc
  40e314:	013600cc 	.word	0x013600cc
  40e318:	00e00136 	.word	0x00e00136
  40e31c:	00e000e0 	.word	0x00e000e0
  40e320:	00e000e0 	.word	0x00e000e0
  40e324:	00e000e0 	.word	0x00e000e0
  40e328:	01210121 	.word	0x01210121
  40e32c:	01210121 	.word	0x01210121
  40e330:	01210121 	.word	0x01210121
  40e334:	00e000e0 	.word	0x00e000e0
  40e338:	00e000e0 	.word	0x00e000e0
  40e33c:	00e000e0 	.word	0x00e000e0
  40e340:	00e000e0 	.word	0x00e000e0
  40e344:	00e000e0 	.word	0x00e000e0
  40e348:	00e000e0 	.word	0x00e000e0
  40e34c:	00e000e0 	.word	0x00e000e0
  40e350:	00e000e0 	.word	0x00e000e0
  40e354:	012b00e0 	.word	0x012b00e0
  40e358:	00e000e0 	.word	0x00e000e0
  40e35c:	00e000e0 	.word	0x00e000e0
  40e360:	00e000e0 	.word	0x00e000e0
  40e364:	00e000e0 	.word	0x00e000e0
  40e368:	01210121 	.word	0x01210121
  40e36c:	01210121 	.word	0x01210121
  40e370:	01210121 	.word	0x01210121
  40e374:	00e000e0 	.word	0x00e000e0
  40e378:	00e000e0 	.word	0x00e000e0
  40e37c:	00e000e0 	.word	0x00e000e0
  40e380:	00e000e0 	.word	0x00e000e0
  40e384:	00e000e0 	.word	0x00e000e0
  40e388:	00e000e0 	.word	0x00e000e0
  40e38c:	00e000e0 	.word	0x00e000e0
  40e390:	00e000e0 	.word	0x00e000e0
  40e394:	012b00e0 	.word	0x012b00e0
  40e398:	2c00      	cmp	r4, #0
  40e39a:	bf08      	it	eq
  40e39c:	f04f 34ff 	moveq.w	r4, #4294967295
  40e3a0:	f017 0301 	ands.w	r3, r7, #1
  40e3a4:	f040 817f 	bne.w	40e6a6 <__ssvfscanf_r+0x62e>
  40e3a8:	06f9      	lsls	r1, r7, #27
  40e3aa:	f140 8390 	bpl.w	40eace <__ssvfscanf_r+0xa56>
  40e3ae:	461f      	mov	r7, r3
  40e3b0:	f8d8 1000 	ldr.w	r1, [r8]
  40e3b4:	682b      	ldr	r3, [r5, #0]
  40e3b6:	781a      	ldrb	r2, [r3, #0]
  40e3b8:	440a      	add	r2, r1
  40e3ba:	3301      	adds	r3, #1
  40e3bc:	7852      	ldrb	r2, [r2, #1]
  40e3be:	0712      	lsls	r2, r2, #28
  40e3c0:	d431      	bmi.n	40e426 <__ssvfscanf_r+0x3ae>
  40e3c2:	686a      	ldr	r2, [r5, #4]
  40e3c4:	602b      	str	r3, [r5, #0]
  40e3c6:	3701      	adds	r7, #1
  40e3c8:	3a01      	subs	r2, #1
  40e3ca:	42bc      	cmp	r4, r7
  40e3cc:	606a      	str	r2, [r5, #4]
  40e3ce:	d02a      	beq.n	40e426 <__ssvfscanf_r+0x3ae>
  40e3d0:	2a00      	cmp	r2, #0
  40e3d2:	dcf0      	bgt.n	40e3b6 <__ssvfscanf_r+0x33e>
  40e3d4:	4630      	mov	r0, r6
  40e3d6:	4629      	mov	r1, r5
  40e3d8:	f005 fc0a 	bl	413bf0 <__ssrefill_r>
  40e3dc:	bb18      	cbnz	r0, 40e426 <__ssvfscanf_r+0x3ae>
  40e3de:	f8d8 1000 	ldr.w	r1, [r8]
  40e3e2:	682b      	ldr	r3, [r5, #0]
  40e3e4:	e7e7      	b.n	40e3b6 <__ssvfscanf_r+0x33e>
  40e3e6:	2c00      	cmp	r4, #0
  40e3e8:	bf08      	it	eq
  40e3ea:	2401      	moveq	r4, #1
  40e3ec:	f017 0301 	ands.w	r3, r7, #1
  40e3f0:	f040 839f 	bne.w	40eb32 <__ssvfscanf_r+0xaba>
  40e3f4:	06f9      	lsls	r1, r7, #27
  40e3f6:	f140 8454 	bpl.w	40eca2 <__ssvfscanf_r+0xc2a>
  40e3fa:	461f      	mov	r7, r3
  40e3fc:	e008      	b.n	40e410 <__ssvfscanf_r+0x398>
  40e3fe:	441a      	add	r2, r3
  40e400:	602a      	str	r2, [r5, #0]
  40e402:	441f      	add	r7, r3
  40e404:	1ae4      	subs	r4, r4, r3
  40e406:	f005 fbf3 	bl	413bf0 <__ssrefill_r>
  40e40a:	2800      	cmp	r0, #0
  40e40c:	f040 8441 	bne.w	40ec92 <__ssvfscanf_r+0xc1a>
  40e410:	686b      	ldr	r3, [r5, #4]
  40e412:	682a      	ldr	r2, [r5, #0]
  40e414:	42a3      	cmp	r3, r4
  40e416:	4630      	mov	r0, r6
  40e418:	4629      	mov	r1, r5
  40e41a:	dbf0      	blt.n	40e3fe <__ssvfscanf_r+0x386>
  40e41c:	1b1b      	subs	r3, r3, r4
  40e41e:	4422      	add	r2, r4
  40e420:	606b      	str	r3, [r5, #4]
  40e422:	4427      	add	r7, r4
  40e424:	602a      	str	r2, [r5, #0]
  40e426:	f8dd a01c 	ldr.w	sl, [sp, #28]
  40e42a:	44b9      	add	r9, r7
  40e42c:	4652      	mov	r2, sl
  40e42e:	e664      	b.n	40e0fa <__ssvfscanf_r+0x82>
  40e430:	2c00      	cmp	r4, #0
  40e432:	bf08      	it	eq
  40e434:	f04f 34ff 	moveq.w	r4, #4294967295
  40e438:	06fa      	lsls	r2, r7, #27
  40e43a:	f140 8315 	bpl.w	40ea68 <__ssvfscanf_r+0x9f0>
  40e43e:	682b      	ldr	r3, [r5, #0]
  40e440:	2700      	movs	r7, #0
  40e442:	f10d 0b58 	add.w	fp, sp, #88	; 0x58
  40e446:	781a      	ldrb	r2, [r3, #0]
  40e448:	f81b 2002 	ldrb.w	r2, [fp, r2]
  40e44c:	3301      	adds	r3, #1
  40e44e:	b1aa      	cbz	r2, 40e47c <__ssvfscanf_r+0x404>
  40e450:	686a      	ldr	r2, [r5, #4]
  40e452:	602b      	str	r3, [r5, #0]
  40e454:	3701      	adds	r7, #1
  40e456:	3a01      	subs	r2, #1
  40e458:	42bc      	cmp	r4, r7
  40e45a:	606a      	str	r2, [r5, #4]
  40e45c:	d0e3      	beq.n	40e426 <__ssvfscanf_r+0x3ae>
  40e45e:	2a00      	cmp	r2, #0
  40e460:	dcf1      	bgt.n	40e446 <__ssvfscanf_r+0x3ce>
  40e462:	4630      	mov	r0, r6
  40e464:	4629      	mov	r1, r5
  40e466:	f005 fbc3 	bl	413bf0 <__ssrefill_r>
  40e46a:	2800      	cmp	r0, #0
  40e46c:	d1db      	bne.n	40e426 <__ssvfscanf_r+0x3ae>
  40e46e:	682b      	ldr	r3, [r5, #0]
  40e470:	781a      	ldrb	r2, [r3, #0]
  40e472:	f81b 2002 	ldrb.w	r2, [fp, r2]
  40e476:	3301      	adds	r3, #1
  40e478:	2a00      	cmp	r2, #0
  40e47a:	d1e9      	bne.n	40e450 <__ssvfscanf_r+0x3d8>
  40e47c:	2f00      	cmp	r7, #0
  40e47e:	f43f ae42 	beq.w	40e106 <__ssvfscanf_r+0x8e>
  40e482:	44b9      	add	r9, r7
  40e484:	f8dd a01c 	ldr.w	sl, [sp, #28]
  40e488:	e7d0      	b.n	40e42c <__ssvfscanf_r+0x3b4>
  40e48a:	bf00      	nop
  40e48c:	00413511 	.word	0x00413511
  40e490:	20000f44 	.word	0x20000f44
  40e494:	f8df 9364 	ldr.w	r9, [pc, #868]	; 40e7fc <__ssvfscanf_r+0x784>
  40e498:	f939 6016 	ldrsh.w	r6, [r9, r6, lsl #1]
  40e49c:	f427 6738 	bic.w	r7, r7, #2944	; 0xb80
  40e4a0:	686a      	ldr	r2, [r5, #4]
  40e4a2:	f88a 1000 	strb.w	r1, [sl]
  40e4a6:	3a01      	subs	r2, #1
  40e4a8:	2a00      	cmp	r2, #0
  40e4aa:	f10a 0a01 	add.w	sl, sl, #1
  40e4ae:	606a      	str	r2, [r5, #4]
  40e4b0:	dd38      	ble.n	40e524 <__ssvfscanf_r+0x4ac>
  40e4b2:	3001      	adds	r0, #1
  40e4b4:	6028      	str	r0, [r5, #0]
  40e4b6:	3c01      	subs	r4, #1
  40e4b8:	f47f af17 	bne.w	40e2ea <__ssvfscanf_r+0x272>
  40e4bc:	05f9      	lsls	r1, r7, #23
  40e4be:	960c      	str	r6, [sp, #48]	; 0x30
  40e4c0:	46e1      	mov	r9, ip
  40e4c2:	465e      	mov	r6, fp
  40e4c4:	469b      	mov	fp, r3
  40e4c6:	d508      	bpl.n	40e4da <__ssvfscanf_r+0x462>
  40e4c8:	9c05      	ldr	r4, [sp, #20]
  40e4ca:	45a2      	cmp	sl, r4
  40e4cc:	f200 840a 	bhi.w	40ece4 <__ssvfscanf_r+0xc6c>
  40e4d0:	f8dd c014 	ldr.w	ip, [sp, #20]
  40e4d4:	45e2      	cmp	sl, ip
  40e4d6:	f43f ae16 	beq.w	40e106 <__ssvfscanf_r+0x8e>
  40e4da:	f017 0410 	ands.w	r4, r7, #16
  40e4de:	f000 8372 	beq.w	40ebc6 <__ssvfscanf_r+0xb4e>
  40e4e2:	f8dd c014 	ldr.w	ip, [sp, #20]
  40e4e6:	ebcc 0a0a 	rsb	sl, ip, sl
  40e4ea:	44d3      	add	fp, sl
  40e4ec:	f8dd a01c 	ldr.w	sl, [sp, #28]
  40e4f0:	44d9      	add	r9, fp
  40e4f2:	4652      	mov	r2, sl
  40e4f4:	e601      	b.n	40e0fa <__ssvfscanf_r+0x82>
  40e4f6:	053a      	lsls	r2, r7, #20
  40e4f8:	d5d2      	bpl.n	40e4a0 <__ssvfscanf_r+0x428>
  40e4fa:	b916      	cbnz	r6, 40e502 <__ssvfscanf_r+0x48a>
  40e4fc:	f447 7700 	orr.w	r7, r7, #512	; 0x200
  40e500:	2608      	movs	r6, #8
  40e502:	057a      	lsls	r2, r7, #21
  40e504:	f100 837d 	bmi.w	40ec02 <__ssvfscanf_r+0xb8a>
  40e508:	9a08      	ldr	r2, [sp, #32]
  40e50a:	f427 7760 	bic.w	r7, r7, #896	; 0x380
  40e50e:	b112      	cbz	r2, 40e516 <__ssvfscanf_r+0x49e>
  40e510:	3a01      	subs	r2, #1
  40e512:	9208      	str	r2, [sp, #32]
  40e514:	3401      	adds	r4, #1
  40e516:	686a      	ldr	r2, [r5, #4]
  40e518:	3a01      	subs	r2, #1
  40e51a:	2a00      	cmp	r2, #0
  40e51c:	f103 0301 	add.w	r3, r3, #1
  40e520:	606a      	str	r2, [r5, #4]
  40e522:	dcc6      	bgt.n	40e4b2 <__ssvfscanf_r+0x43a>
  40e524:	4658      	mov	r0, fp
  40e526:	4629      	mov	r1, r5
  40e528:	9303      	str	r3, [sp, #12]
  40e52a:	f8cd c010 	str.w	ip, [sp, #16]
  40e52e:	f005 fb5f 	bl	413bf0 <__ssrefill_r>
  40e532:	9b03      	ldr	r3, [sp, #12]
  40e534:	f8dd c010 	ldr.w	ip, [sp, #16]
  40e538:	2800      	cmp	r0, #0
  40e53a:	d0bc      	beq.n	40e4b6 <__ssvfscanf_r+0x43e>
  40e53c:	e7be      	b.n	40e4bc <__ssvfscanf_r+0x444>
  40e53e:	2e0a      	cmp	r6, #10
  40e540:	ddbc      	ble.n	40e4bc <__ssvfscanf_r+0x444>
  40e542:	f427 6738 	bic.w	r7, r7, #2944	; 0xb80
  40e546:	e7ab      	b.n	40e4a0 <__ssvfscanf_r+0x428>
  40e548:	063a      	lsls	r2, r7, #24
  40e54a:	d5b7      	bpl.n	40e4bc <__ssvfscanf_r+0x444>
  40e54c:	f027 0780 	bic.w	r7, r7, #128	; 0x80
  40e550:	e7a6      	b.n	40e4a0 <__ssvfscanf_r+0x428>
  40e552:	f407 62c0 	and.w	r2, r7, #1536	; 0x600
  40e556:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
  40e55a:	d1af      	bne.n	40e4bc <__ssvfscanf_r+0x444>
  40e55c:	f427 7700 	bic.w	r7, r7, #512	; 0x200
  40e560:	f447 67a0 	orr.w	r7, r7, #1280	; 0x500
  40e564:	2610      	movs	r6, #16
  40e566:	e79b      	b.n	40e4a0 <__ssvfscanf_r+0x428>
  40e568:	4aa4      	ldr	r2, [pc, #656]	; (40e7fc <__ssvfscanf_r+0x784>)
  40e56a:	f932 6016 	ldrsh.w	r6, [r2, r6, lsl #1]
  40e56e:	2e08      	cmp	r6, #8
  40e570:	dce7      	bgt.n	40e542 <__ssvfscanf_r+0x4ca>
  40e572:	e7a3      	b.n	40e4bc <__ssvfscanf_r+0x444>
  40e574:	f89a 3001 	ldrb.w	r3, [sl, #1]
  40e578:	f047 0710 	orr.w	r7, r7, #16
  40e57c:	4692      	mov	sl, r2
  40e57e:	e5cc      	b.n	40e11a <__ssvfscanf_r+0xa2>
  40e580:	9207      	str	r2, [sp, #28]
  40e582:	f047 0701 	orr.w	r7, r7, #1
  40e586:	686b      	ldr	r3, [r5, #4]
  40e588:	489d      	ldr	r0, [pc, #628]	; (40e800 <__ssvfscanf_r+0x788>)
  40e58a:	9009      	str	r0, [sp, #36]	; 0x24
  40e58c:	210a      	movs	r1, #10
  40e58e:	2b00      	cmp	r3, #0
  40e590:	910c      	str	r1, [sp, #48]	; 0x30
  40e592:	f04f 0a03 	mov.w	sl, #3
  40e596:	f73f ae67 	bgt.w	40e268 <__ssvfscanf_r+0x1f0>
  40e59a:	4630      	mov	r0, r6
  40e59c:	4629      	mov	r1, r5
  40e59e:	f005 fb27 	bl	413bf0 <__ssrefill_r>
  40e5a2:	2800      	cmp	r0, #0
  40e5a4:	f43f ae60 	beq.w	40e268 <__ssvfscanf_r+0x1f0>
  40e5a8:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
  40e5aa:	2c00      	cmp	r4, #0
  40e5ac:	f43f ae4b 	beq.w	40e246 <__ssvfscanf_r+0x1ce>
  40e5b0:	89ab      	ldrh	r3, [r5, #12]
  40e5b2:	4620      	mov	r0, r4
  40e5b4:	f013 0f40 	tst.w	r3, #64	; 0x40
  40e5b8:	bf18      	it	ne
  40e5ba:	f04f 30ff 	movne.w	r0, #4294967295
  40e5be:	f50d 7d2f 	add.w	sp, sp, #700	; 0x2bc
  40e5c2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40e5c6:	eb04 0484 	add.w	r4, r4, r4, lsl #2
  40e5ca:	eb03 0344 	add.w	r3, r3, r4, lsl #1
  40e5ce:	f1a3 0430 	sub.w	r4, r3, #48	; 0x30
  40e5d2:	f89a 3001 	ldrb.w	r3, [sl, #1]
  40e5d6:	4692      	mov	sl, r2
  40e5d8:	e59f      	b.n	40e11a <__ssvfscanf_r+0xa2>
  40e5da:	9207      	str	r2, [sp, #28]
  40e5dc:	2310      	movs	r3, #16
  40e5de:	4a89      	ldr	r2, [pc, #548]	; (40e804 <__ssvfscanf_r+0x78c>)
  40e5e0:	9209      	str	r2, [sp, #36]	; 0x24
  40e5e2:	f447 7700 	orr.w	r7, r7, #512	; 0x200
  40e5e6:	930c      	str	r3, [sp, #48]	; 0x30
  40e5e8:	f04f 0a03 	mov.w	sl, #3
  40e5ec:	e638      	b.n	40e260 <__ssvfscanf_r+0x1e8>
  40e5ee:	9207      	str	r2, [sp, #28]
  40e5f0:	f047 0701 	orr.w	r7, r7, #1
  40e5f4:	4a83      	ldr	r2, [pc, #524]	; (40e804 <__ssvfscanf_r+0x78c>)
  40e5f6:	9209      	str	r2, [sp, #36]	; 0x24
  40e5f8:	2308      	movs	r3, #8
  40e5fa:	930c      	str	r3, [sp, #48]	; 0x30
  40e5fc:	f04f 0a03 	mov.w	sl, #3
  40e600:	e62e      	b.n	40e260 <__ssvfscanf_r+0x1e8>
  40e602:	f89a 3001 	ldrb.w	r3, [sl, #1]
  40e606:	f047 0702 	orr.w	r7, r7, #2
  40e60a:	4692      	mov	sl, r2
  40e60c:	e585      	b.n	40e11a <__ssvfscanf_r+0xa2>
  40e60e:	9207      	str	r2, [sp, #28]
  40e610:	f04f 0a04 	mov.w	sl, #4
  40e614:	e624      	b.n	40e260 <__ssvfscanf_r+0x1e8>
  40e616:	9207      	str	r2, [sp, #28]
  40e618:	e7ec      	b.n	40e5f4 <__ssvfscanf_r+0x57c>
  40e61a:	06f9      	lsls	r1, r7, #27
  40e61c:	9207      	str	r2, [sp, #28]
  40e61e:	d462      	bmi.n	40e6e6 <__ssvfscanf_r+0x66e>
  40e620:	077b      	lsls	r3, r7, #29
  40e622:	f140 8381 	bpl.w	40ed28 <__ssvfscanf_r+0xcb0>
  40e626:	9c06      	ldr	r4, [sp, #24]
  40e628:	6823      	ldr	r3, [r4, #0]
  40e62a:	3404      	adds	r4, #4
  40e62c:	4692      	mov	sl, r2
  40e62e:	f8a3 9000 	strh.w	r9, [r3]
  40e632:	9406      	str	r4, [sp, #24]
  40e634:	e560      	b.n	40e0f8 <__ssvfscanf_r+0x80>
  40e636:	f89a 3001 	ldrb.w	r3, [sl, #1]
  40e63a:	f047 0704 	orr.w	r7, r7, #4
  40e63e:	4692      	mov	sl, r2
  40e640:	e56b      	b.n	40e11a <__ssvfscanf_r+0xa2>
  40e642:	9207      	str	r2, [sp, #28]
  40e644:	f047 0740 	orr.w	r7, r7, #64	; 0x40
  40e648:	f04f 0a00 	mov.w	sl, #0
  40e64c:	e608      	b.n	40e260 <__ssvfscanf_r+0x1e8>
  40e64e:	4611      	mov	r1, r2
  40e650:	a816      	add	r0, sp, #88	; 0x58
  40e652:	9207      	str	r2, [sp, #28]
  40e654:	f003 ff5e 	bl	412514 <__sccl>
  40e658:	f047 0740 	orr.w	r7, r7, #64	; 0x40
  40e65c:	9007      	str	r0, [sp, #28]
  40e65e:	f04f 0a01 	mov.w	sl, #1
  40e662:	e5fd      	b.n	40e260 <__ssvfscanf_r+0x1e8>
  40e664:	9207      	str	r2, [sp, #28]
  40e666:	e78e      	b.n	40e586 <__ssvfscanf_r+0x50e>
  40e668:	4866      	ldr	r0, [pc, #408]	; (40e804 <__ssvfscanf_r+0x78c>)
  40e66a:	9207      	str	r2, [sp, #28]
  40e66c:	210a      	movs	r1, #10
  40e66e:	9009      	str	r0, [sp, #36]	; 0x24
  40e670:	910c      	str	r1, [sp, #48]	; 0x30
  40e672:	f04f 0a03 	mov.w	sl, #3
  40e676:	e5f3      	b.n	40e260 <__ssvfscanf_r+0x1e8>
  40e678:	9207      	str	r2, [sp, #28]
  40e67a:	f04f 0a02 	mov.w	sl, #2
  40e67e:	e5ef      	b.n	40e260 <__ssvfscanf_r+0x1e8>
  40e680:	4860      	ldr	r0, [pc, #384]	; (40e804 <__ssvfscanf_r+0x78c>)
  40e682:	9207      	str	r2, [sp, #28]
  40e684:	2110      	movs	r1, #16
  40e686:	f447 7708 	orr.w	r7, r7, #544	; 0x220
  40e68a:	9009      	str	r0, [sp, #36]	; 0x24
  40e68c:	910c      	str	r1, [sp, #48]	; 0x30
  40e68e:	f04f 0a03 	mov.w	sl, #3
  40e692:	e5e5      	b.n	40e260 <__ssvfscanf_r+0x1e8>
  40e694:	f89a 3001 	ldrb.w	r3, [sl, #1]
  40e698:	2b6c      	cmp	r3, #108	; 0x6c
  40e69a:	f000 8336 	beq.w	40ed0a <__ssvfscanf_r+0xc92>
  40e69e:	f047 0701 	orr.w	r7, r7, #1
  40e6a2:	4692      	mov	sl, r2
  40e6a4:	e539      	b.n	40e11a <__ssvfscanf_r+0xa2>
  40e6a6:	a814      	add	r0, sp, #80	; 0x50
  40e6a8:	2100      	movs	r1, #0
  40e6aa:	2208      	movs	r2, #8
  40e6ac:	900a      	str	r0, [sp, #40]	; 0x28
  40e6ae:	f7fd fe35 	bl	40c31c <memset>
  40e6b2:	f017 0b10 	ands.w	fp, r7, #16
  40e6b6:	f000 82bd 	beq.w	40ec34 <__ssvfscanf_r+0xbbc>
  40e6ba:	f10d 0a4c 	add.w	sl, sp, #76	; 0x4c
  40e6be:	2200      	movs	r2, #0
  40e6c0:	6829      	ldr	r1, [r5, #0]
  40e6c2:	f8d8 3000 	ldr.w	r3, [r8]
  40e6c6:	7809      	ldrb	r1, [r1, #0]
  40e6c8:	440b      	add	r3, r1
  40e6ca:	785b      	ldrb	r3, [r3, #1]
  40e6cc:	0718      	lsls	r0, r3, #28
  40e6ce:	d402      	bmi.n	40e6d6 <__ssvfscanf_r+0x65e>
  40e6d0:	2c00      	cmp	r4, #0
  40e6d2:	f040 8372 	bne.w	40edba <__ssvfscanf_r+0xd42>
  40e6d6:	f1bb 0f00 	cmp.w	fp, #0
  40e6da:	d104      	bne.n	40e6e6 <__ssvfscanf_r+0x66e>
  40e6dc:	f8ca b000 	str.w	fp, [sl]
  40e6e0:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
  40e6e2:	3401      	adds	r4, #1
  40e6e4:	940b      	str	r4, [sp, #44]	; 0x2c
  40e6e6:	f8dd a01c 	ldr.w	sl, [sp, #28]
  40e6ea:	4652      	mov	r2, sl
  40e6ec:	e505      	b.n	40e0fa <__ssvfscanf_r+0x82>
  40e6ee:	440b      	add	r3, r1
  40e6f0:	9207      	str	r2, [sp, #28]
  40e6f2:	785b      	ldrb	r3, [r3, #1]
  40e6f4:	f003 0303 	and.w	r3, r3, #3
  40e6f8:	2b01      	cmp	r3, #1
  40e6fa:	f47f af44 	bne.w	40e586 <__ssvfscanf_r+0x50e>
  40e6fe:	f047 0701 	orr.w	r7, r7, #1
  40e702:	e740      	b.n	40e586 <__ssvfscanf_r+0x50e>
  40e704:	4630      	mov	r0, r6
  40e706:	f002 ff83 	bl	411610 <_localeconv_r>
  40e70a:	1e63      	subs	r3, r4, #1
  40e70c:	6800      	ldr	r0, [r0, #0]
  40e70e:	900f      	str	r0, [sp, #60]	; 0x3c
  40e710:	f5b3 7fae 	cmp.w	r3, #348	; 0x15c
  40e714:	f240 81a5 	bls.w	40ea62 <__ssvfscanf_r+0x9ea>
  40e718:	f46f 70ae 	mvn.w	r0, #348	; 0x15c
  40e71c:	4404      	add	r4, r0
  40e71e:	940d      	str	r4, [sp, #52]	; 0x34
  40e720:	f240 145d 	movw	r4, #349	; 0x15d
  40e724:	f04f 0a00 	mov.w	sl, #0
  40e728:	f50d 7cac 	add.w	ip, sp, #344	; 0x158
  40e72c:	960e      	str	r6, [sp, #56]	; 0x38
  40e72e:	f8cd c014 	str.w	ip, [sp, #20]
  40e732:	f447 67f0 	orr.w	r7, r7, #1920	; 0x780
  40e736:	4653      	mov	r3, sl
  40e738:	f8cd a044 	str.w	sl, [sp, #68]	; 0x44
  40e73c:	f8cd a040 	str.w	sl, [sp, #64]	; 0x40
  40e740:	f8cd a020 	str.w	sl, [sp, #32]
  40e744:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
  40e748:	46e3      	mov	fp, ip
  40e74a:	4656      	mov	r6, sl
  40e74c:	6828      	ldr	r0, [r5, #0]
  40e74e:	7802      	ldrb	r2, [r0, #0]
  40e750:	f1a2 012b 	sub.w	r1, r2, #43	; 0x2b
  40e754:	294e      	cmp	r1, #78	; 0x4e
  40e756:	f200 8156 	bhi.w	40ea06 <__ssvfscanf_r+0x98e>
  40e75a:	e8df f011 	tbh	[pc, r1, lsl #1]
  40e75e:	007e      	.short	0x007e
  40e760:	007e0154 	.word	0x007e0154
  40e764:	01540154 	.word	0x01540154
  40e768:	00550072 	.word	0x00550072
  40e76c:	00550055 	.word	0x00550055
  40e770:	00550055 	.word	0x00550055
  40e774:	00550055 	.word	0x00550055
  40e778:	00550055 	.word	0x00550055
  40e77c:	01540154 	.word	0x01540154
  40e780:	01540154 	.word	0x01540154
  40e784:	01540154 	.word	0x01540154
  40e788:	014f0154 	.word	0x014f0154
  40e78c:	01540154 	.word	0x01540154
  40e790:	01350154 	.word	0x01350154
  40e794:	0154012e 	.word	0x0154012e
  40e798:	00a40154 	.word	0x00a40154
  40e79c:	01540154 	.word	0x01540154
  40e7a0:	01540154 	.word	0x01540154
  40e7a4:	0154008f 	.word	0x0154008f
  40e7a8:	01540154 	.word	0x01540154
  40e7ac:	01540154 	.word	0x01540154
  40e7b0:	01540089 	.word	0x01540089
  40e7b4:	01540154 	.word	0x01540154
  40e7b8:	00830154 	.word	0x00830154
  40e7bc:	01540154 	.word	0x01540154
  40e7c0:	01540154 	.word	0x01540154
  40e7c4:	01540154 	.word	0x01540154
  40e7c8:	014f0154 	.word	0x014f0154
  40e7cc:	01540154 	.word	0x01540154
  40e7d0:	01350154 	.word	0x01350154
  40e7d4:	0154012e 	.word	0x0154012e
  40e7d8:	00a40154 	.word	0x00a40154
  40e7dc:	01540154 	.word	0x01540154
  40e7e0:	01540154 	.word	0x01540154
  40e7e4:	0154008f 	.word	0x0154008f
  40e7e8:	01540154 	.word	0x01540154
  40e7ec:	01540154 	.word	0x01540154
  40e7f0:	01540089 	.word	0x01540089
  40e7f4:	01540154 	.word	0x01540154
  40e7f8:	00830154 	.word	0x00830154
  40e7fc:	00416ea4 	.word	0x00416ea4
  40e800:	00413511 	.word	0x00413511
  40e804:	004137c1 	.word	0x004137c1
  40e808:	eb03 010a 	add.w	r1, r3, sl
  40e80c:	b999      	cbnz	r1, 40e836 <__ssvfscanf_r+0x7be>
  40e80e:	f427 77c0 	bic.w	r7, r7, #384	; 0x180
  40e812:	f88b 2000 	strb.w	r2, [fp]
  40e816:	f10b 0b01 	add.w	fp, fp, #1
  40e81a:	686a      	ldr	r2, [r5, #4]
  40e81c:	3a01      	subs	r2, #1
  40e81e:	2a00      	cmp	r2, #0
  40e820:	f104 34ff 	add.w	r4, r4, #4294967295
  40e824:	f109 0901 	add.w	r9, r9, #1
  40e828:	606a      	str	r2, [r5, #4]
  40e82a:	f340 80fa 	ble.w	40ea22 <__ssvfscanf_r+0x9aa>
  40e82e:	3001      	adds	r0, #1
  40e830:	6028      	str	r0, [r5, #0]
  40e832:	2c00      	cmp	r4, #0
  40e834:	d18a      	bne.n	40e74c <__ssvfscanf_r+0x6d4>
  40e836:	9608      	str	r6, [sp, #32]
  40e838:	9c08      	ldr	r4, [sp, #32]
  40e83a:	9e0e      	ldr	r6, [sp, #56]	; 0x38
  40e83c:	2c00      	cmp	r4, #0
  40e83e:	d041      	beq.n	40e8c4 <__ssvfscanf_r+0x84c>
  40e840:	e10c      	b.n	40ea5c <__ssvfscanf_r+0x9e4>
  40e842:	05f9      	lsls	r1, r7, #23
  40e844:	d5e0      	bpl.n	40e808 <__ssvfscanf_r+0x790>
  40e846:	9a0d      	ldr	r2, [sp, #52]	; 0x34
  40e848:	f027 0780 	bic.w	r7, r7, #128	; 0x80
  40e84c:	3601      	adds	r6, #1
  40e84e:	2a00      	cmp	r2, #0
  40e850:	d0e3      	beq.n	40e81a <__ssvfscanf_r+0x7a2>
  40e852:	3a01      	subs	r2, #1
  40e854:	920d      	str	r2, [sp, #52]	; 0x34
  40e856:	3401      	adds	r4, #1
  40e858:	e7df      	b.n	40e81a <__ssvfscanf_r+0x7a2>
  40e85a:	0639      	lsls	r1, r7, #24
  40e85c:	d5eb      	bpl.n	40e836 <__ssvfscanf_r+0x7be>
  40e85e:	f027 0780 	bic.w	r7, r7, #128	; 0x80
  40e862:	e7d6      	b.n	40e812 <__ssvfscanf_r+0x79a>
  40e864:	f1ba 0f07 	cmp.w	sl, #7
  40e868:	d1e5      	bne.n	40e836 <__ssvfscanf_r+0x7be>
  40e86a:	f04f 0a08 	mov.w	sl, #8
  40e86e:	e7d0      	b.n	40e812 <__ssvfscanf_r+0x79a>
  40e870:	f1ba 0f06 	cmp.w	sl, #6
  40e874:	d1df      	bne.n	40e836 <__ssvfscanf_r+0x7be>
  40e876:	f04f 0a07 	mov.w	sl, #7
  40e87a:	e7ca      	b.n	40e812 <__ssvfscanf_r+0x79a>
  40e87c:	2b00      	cmp	r3, #0
  40e87e:	f040 80e6 	bne.w	40ea4e <__ssvfscanf_r+0x9d6>
  40e882:	b92e      	cbnz	r6, 40e890 <__ssvfscanf_r+0x818>
  40e884:	f407 61e0 	and.w	r1, r7, #1792	; 0x700
  40e888:	f5b1 6fe0 	cmp.w	r1, #1792	; 0x700
  40e88c:	f000 8239 	beq.w	40ed02 <__ssvfscanf_r+0xc8a>
  40e890:	f1ba 0f01 	cmp.w	sl, #1
  40e894:	d002      	beq.n	40e89c <__ssvfscanf_r+0x824>
  40e896:	f1ba 0f04 	cmp.w	sl, #4
  40e89a:	d1cc      	bne.n	40e836 <__ssvfscanf_r+0x7be>
  40e89c:	f10a 0a01 	add.w	sl, sl, #1
  40e8a0:	fa5f fa8a 	uxtb.w	sl, sl
  40e8a4:	e7b5      	b.n	40e812 <__ssvfscanf_r+0x79a>
  40e8a6:	f1ba 0f00 	cmp.w	sl, #0
  40e8aa:	f040 80c7 	bne.w	40ea3c <__ssvfscanf_r+0x9c4>
  40e8ae:	2e00      	cmp	r6, #0
  40e8b0:	f040 80d2 	bne.w	40ea58 <__ssvfscanf_r+0x9e0>
  40e8b4:	f407 61e0 	and.w	r1, r7, #1792	; 0x700
  40e8b8:	f5b1 6fe0 	cmp.w	r1, #1792	; 0x700
  40e8bc:	f000 821c 	beq.w	40ecf8 <__ssvfscanf_r+0xc80>
  40e8c0:	9608      	str	r6, [sp, #32]
  40e8c2:	9e0e      	ldr	r6, [sp, #56]	; 0x38
  40e8c4:	f103 3cff 	add.w	ip, r3, #4294967295
  40e8c8:	f1bc 0f01 	cmp.w	ip, #1
  40e8cc:	f240 82dc 	bls.w	40ee88 <__ssvfscanf_r+0xe10>
  40e8d0:	f10a 32ff 	add.w	r2, sl, #4294967295
  40e8d4:	2a06      	cmp	r2, #6
  40e8d6:	d822      	bhi.n	40e91e <__ssvfscanf_r+0x8a6>
  40e8d8:	f1ba 0f02 	cmp.w	sl, #2
  40e8dc:	f240 82ad 	bls.w	40ee3a <__ssvfscanf_r+0xdc2>
  40e8e0:	f1ba 0f03 	cmp.w	sl, #3
  40e8e4:	d01b      	beq.n	40e91e <__ssvfscanf_r+0x8a6>
  40e8e6:	f1aa 0a04 	sub.w	sl, sl, #4
  40e8ea:	fa5f fa8a 	uxtb.w	sl, sl
  40e8ee:	f10b 34ff 	add.w	r4, fp, #4294967295
  40e8f2:	f8cd a034 	str.w	sl, [sp, #52]	; 0x34
  40e8f6:	ebca 0404 	rsb	r4, sl, r4
  40e8fa:	46da      	mov	sl, fp
  40e8fc:	f81a 1d01 	ldrb.w	r1, [sl, #-1]!
  40e900:	4630      	mov	r0, r6
  40e902:	462a      	mov	r2, r5
  40e904:	f005 f934 	bl	413b70 <_sungetc_r>
  40e908:	45a2      	cmp	sl, r4
  40e90a:	d1f7      	bne.n	40e8fc <__ssvfscanf_r+0x884>
  40e90c:	f8dd c034 	ldr.w	ip, [sp, #52]	; 0x34
  40e910:	f109 39ff 	add.w	r9, r9, #4294967295
  40e914:	ea6f 020c 	mvn.w	r2, ip
  40e918:	ebcc 0909 	rsb	r9, ip, r9
  40e91c:	4493      	add	fp, r2
  40e91e:	05f8      	lsls	r0, r7, #23
  40e920:	d51c      	bpl.n	40e95c <__ssvfscanf_r+0x8e4>
  40e922:	0579      	lsls	r1, r7, #21
  40e924:	f100 829b 	bmi.w	40ee5e <__ssvfscanf_r+0xde6>
  40e928:	f81b 1c01 	ldrb.w	r1, [fp, #-1]
  40e92c:	2965      	cmp	r1, #101	; 0x65
  40e92e:	f10b 34ff 	add.w	r4, fp, #4294967295
  40e932:	f109 3aff 	add.w	sl, r9, #4294967295
  40e936:	d00b      	beq.n	40e950 <__ssvfscanf_r+0x8d8>
  40e938:	2945      	cmp	r1, #69	; 0x45
  40e93a:	d009      	beq.n	40e950 <__ssvfscanf_r+0x8d8>
  40e93c:	4630      	mov	r0, r6
  40e93e:	462a      	mov	r2, r5
  40e940:	f005 f916 	bl	413b70 <_sungetc_r>
  40e944:	f81b 1c02 	ldrb.w	r1, [fp, #-2]
  40e948:	f1a9 0a02 	sub.w	sl, r9, #2
  40e94c:	f1ab 0402 	sub.w	r4, fp, #2
  40e950:	4630      	mov	r0, r6
  40e952:	462a      	mov	r2, r5
  40e954:	f005 f90c 	bl	413b70 <_sungetc_r>
  40e958:	46d1      	mov	r9, sl
  40e95a:	46a3      	mov	fp, r4
  40e95c:	f017 0210 	ands.w	r2, r7, #16
  40e960:	f47f aec1 	bne.w	40e6e6 <__ssvfscanf_r+0x66e>
  40e964:	f407 61c0 	and.w	r1, r7, #1536	; 0x600
  40e968:	f5b1 6f80 	cmp.w	r1, #1024	; 0x400
  40e96c:	f88b 2000 	strb.w	r2, [fp]
  40e970:	f000 81d3 	beq.w	40ed1a <__ssvfscanf_r+0xca2>
  40e974:	9c10      	ldr	r4, [sp, #64]	; 0x40
  40e976:	2c00      	cmp	r4, #0
  40e978:	f040 816e 	bne.w	40ec58 <__ssvfscanf_r+0xbe0>
  40e97c:	2200      	movs	r2, #0
  40e97e:	9905      	ldr	r1, [sp, #20]
  40e980:	4630      	mov	r0, r6
  40e982:	f003 fe25 	bl	4125d0 <_strtod_r>
  40e986:	07fa      	lsls	r2, r7, #31
  40e988:	4682      	mov	sl, r0
  40e98a:	468b      	mov	fp, r1
  40e98c:	f100 8132 	bmi.w	40ebf4 <__ssvfscanf_r+0xb7c>
  40e990:	07bb      	lsls	r3, r7, #30
  40e992:	f140 81e8 	bpl.w	40ed66 <__ssvfscanf_r+0xcee>
  40e996:	f8dd c018 	ldr.w	ip, [sp, #24]
  40e99a:	f8dc 3000 	ldr.w	r3, [ip]
  40e99e:	f10c 0c04 	add.w	ip, ip, #4
  40e9a2:	f8cd c018 	str.w	ip, [sp, #24]
  40e9a6:	e9c3 ab00 	strd	sl, fp, [r3]
  40e9aa:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
  40e9ac:	f8dd a01c 	ldr.w	sl, [sp, #28]
  40e9b0:	3401      	adds	r4, #1
  40e9b2:	940b      	str	r4, [sp, #44]	; 0x2c
  40e9b4:	4652      	mov	r2, sl
  40e9b6:	f7ff bba0 	b.w	40e0fa <__ssvfscanf_r+0x82>
  40e9ba:	f1ba 0f02 	cmp.w	sl, #2
  40e9be:	f47f af3a 	bne.w	40e836 <__ssvfscanf_r+0x7be>
  40e9c2:	f04f 0a03 	mov.w	sl, #3
  40e9c6:	e724      	b.n	40e812 <__ssvfscanf_r+0x79a>
  40e9c8:	f407 61a0 	and.w	r1, r7, #1280	; 0x500
  40e9cc:	f5b1 6f80 	cmp.w	r1, #1024	; 0x400
  40e9d0:	d005      	beq.n	40e9de <__ssvfscanf_r+0x966>
  40e9d2:	0579      	lsls	r1, r7, #21
  40e9d4:	f57f af2f 	bpl.w	40e836 <__ssvfscanf_r+0x7be>
  40e9d8:	2e00      	cmp	r6, #0
  40e9da:	f43f af71 	beq.w	40e8c0 <__ssvfscanf_r+0x848>
  40e9de:	05b9      	lsls	r1, r7, #22
  40e9e0:	d406      	bmi.n	40e9f0 <__ssvfscanf_r+0x978>
  40e9e2:	f8dd c028 	ldr.w	ip, [sp, #40]	; 0x28
  40e9e6:	f8cd b044 	str.w	fp, [sp, #68]	; 0x44
  40e9ea:	ebcc 0606 	rsb	r6, ip, r6
  40e9ee:	9610      	str	r6, [sp, #64]	; 0x40
  40e9f0:	f427 67f0 	bic.w	r7, r7, #1920	; 0x780
  40e9f4:	f447 77c0 	orr.w	r7, r7, #384	; 0x180
  40e9f8:	2600      	movs	r6, #0
  40e9fa:	e70a      	b.n	40e812 <__ssvfscanf_r+0x79a>
  40e9fc:	2b01      	cmp	r3, #1
  40e9fe:	f47f af1a 	bne.w	40e836 <__ssvfscanf_r+0x7be>
  40ea02:	2302      	movs	r3, #2
  40ea04:	e705      	b.n	40e812 <__ssvfscanf_r+0x79a>
  40ea06:	f8dd c03c 	ldr.w	ip, [sp, #60]	; 0x3c
  40ea0a:	f89c 1000 	ldrb.w	r1, [ip]
  40ea0e:	4291      	cmp	r1, r2
  40ea10:	f47f af11 	bne.w	40e836 <__ssvfscanf_r+0x7be>
  40ea14:	05b9      	lsls	r1, r7, #22
  40ea16:	f57f af0e 	bpl.w	40e836 <__ssvfscanf_r+0x7be>
  40ea1a:	f427 7720 	bic.w	r7, r7, #640	; 0x280
  40ea1e:	960a      	str	r6, [sp, #40]	; 0x28
  40ea20:	e6f7      	b.n	40e812 <__ssvfscanf_r+0x79a>
  40ea22:	980e      	ldr	r0, [sp, #56]	; 0x38
  40ea24:	9303      	str	r3, [sp, #12]
  40ea26:	4629      	mov	r1, r5
  40ea28:	f005 f8e2 	bl	413bf0 <__ssrefill_r>
  40ea2c:	9b03      	ldr	r3, [sp, #12]
  40ea2e:	2800      	cmp	r0, #0
  40ea30:	f47f af01 	bne.w	40e836 <__ssvfscanf_r+0x7be>
  40ea34:	2c00      	cmp	r4, #0
  40ea36:	f47f ae89 	bne.w	40e74c <__ssvfscanf_r+0x6d4>
  40ea3a:	e6fc      	b.n	40e836 <__ssvfscanf_r+0x7be>
  40ea3c:	f1ba 0f03 	cmp.w	sl, #3
  40ea40:	f43f af2c 	beq.w	40e89c <__ssvfscanf_r+0x824>
  40ea44:	f1ba 0f05 	cmp.w	sl, #5
  40ea48:	f43f af28 	beq.w	40e89c <__ssvfscanf_r+0x824>
  40ea4c:	e6f3      	b.n	40e836 <__ssvfscanf_r+0x7be>
  40ea4e:	2b02      	cmp	r3, #2
  40ea50:	f47f af1e 	bne.w	40e890 <__ssvfscanf_r+0x818>
  40ea54:	2303      	movs	r3, #3
  40ea56:	e6dc      	b.n	40e812 <__ssvfscanf_r+0x79a>
  40ea58:	9608      	str	r6, [sp, #32]
  40ea5a:	9e0e      	ldr	r6, [sp, #56]	; 0x38
  40ea5c:	f427 7780 	bic.w	r7, r7, #256	; 0x100
  40ea60:	e730      	b.n	40e8c4 <__ssvfscanf_r+0x84c>
  40ea62:	2200      	movs	r2, #0
  40ea64:	920d      	str	r2, [sp, #52]	; 0x34
  40ea66:	e65d      	b.n	40e724 <__ssvfscanf_r+0x6ac>
  40ea68:	f8dd c018 	ldr.w	ip, [sp, #24]
  40ea6c:	f8dc 7000 	ldr.w	r7, [ip]
  40ea70:	f10c 0204 	add.w	r2, ip, #4
  40ea74:	9206      	str	r2, [sp, #24]
  40ea76:	46ba      	mov	sl, r7
  40ea78:	f10d 0b58 	add.w	fp, sp, #88	; 0x58
  40ea7c:	682b      	ldr	r3, [r5, #0]
  40ea7e:	781a      	ldrb	r2, [r3, #0]
  40ea80:	f81b 2002 	ldrb.w	r2, [fp, r2]
  40ea84:	1c59      	adds	r1, r3, #1
  40ea86:	b1a2      	cbz	r2, 40eab2 <__ssvfscanf_r+0xa3a>
  40ea88:	686a      	ldr	r2, [r5, #4]
  40ea8a:	6029      	str	r1, [r5, #0]
  40ea8c:	3a01      	subs	r2, #1
  40ea8e:	606a      	str	r2, [r5, #4]
  40ea90:	781b      	ldrb	r3, [r3, #0]
  40ea92:	f80a 3b01 	strb.w	r3, [sl], #1
  40ea96:	3c01      	subs	r4, #1
  40ea98:	d00b      	beq.n	40eab2 <__ssvfscanf_r+0xa3a>
  40ea9a:	686b      	ldr	r3, [r5, #4]
  40ea9c:	2b00      	cmp	r3, #0
  40ea9e:	dced      	bgt.n	40ea7c <__ssvfscanf_r+0xa04>
  40eaa0:	4630      	mov	r0, r6
  40eaa2:	4629      	mov	r1, r5
  40eaa4:	f005 f8a4 	bl	413bf0 <__ssrefill_r>
  40eaa8:	2800      	cmp	r0, #0
  40eaaa:	d0e7      	beq.n	40ea7c <__ssvfscanf_r+0xa04>
  40eaac:	4557      	cmp	r7, sl
  40eaae:	f43f ad7b 	beq.w	40e5a8 <__ssvfscanf_r+0x530>
  40eab2:	ebba 0707 	subs.w	r7, sl, r7
  40eab6:	f43f ab26 	beq.w	40e106 <__ssvfscanf_r+0x8e>
  40eaba:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
  40eabc:	2300      	movs	r3, #0
  40eabe:	3401      	adds	r4, #1
  40eac0:	f88a 3000 	strb.w	r3, [sl]
  40eac4:	940b      	str	r4, [sp, #44]	; 0x2c
  40eac6:	44b9      	add	r9, r7
  40eac8:	f8dd a01c 	ldr.w	sl, [sp, #28]
  40eacc:	e4ae      	b.n	40e42c <__ssvfscanf_r+0x3b4>
  40eace:	f8dd c018 	ldr.w	ip, [sp, #24]
  40ead2:	f8dc 7000 	ldr.w	r7, [ip]
  40ead6:	f10c 0a04 	add.w	sl, ip, #4
  40eada:	46bb      	mov	fp, r7
  40eadc:	682b      	ldr	r3, [r5, #0]
  40eade:	f8d8 2000 	ldr.w	r2, [r8]
  40eae2:	7819      	ldrb	r1, [r3, #0]
  40eae4:	440a      	add	r2, r1
  40eae6:	1c59      	adds	r1, r3, #1
  40eae8:	7852      	ldrb	r2, [r2, #1]
  40eaea:	0710      	lsls	r0, r2, #28
  40eaec:	d411      	bmi.n	40eb12 <__ssvfscanf_r+0xa9a>
  40eaee:	686a      	ldr	r2, [r5, #4]
  40eaf0:	6029      	str	r1, [r5, #0]
  40eaf2:	3a01      	subs	r2, #1
  40eaf4:	606a      	str	r2, [r5, #4]
  40eaf6:	781b      	ldrb	r3, [r3, #0]
  40eaf8:	f80b 3b01 	strb.w	r3, [fp], #1
  40eafc:	3c01      	subs	r4, #1
  40eafe:	d008      	beq.n	40eb12 <__ssvfscanf_r+0xa9a>
  40eb00:	686b      	ldr	r3, [r5, #4]
  40eb02:	2b00      	cmp	r3, #0
  40eb04:	dcea      	bgt.n	40eadc <__ssvfscanf_r+0xa64>
  40eb06:	4630      	mov	r0, r6
  40eb08:	4629      	mov	r1, r5
  40eb0a:	f005 f871 	bl	413bf0 <__ssrefill_r>
  40eb0e:	2800      	cmp	r0, #0
  40eb10:	d0e4      	beq.n	40eadc <__ssvfscanf_r+0xa64>
  40eb12:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
  40eb14:	f8cd a018 	str.w	sl, [sp, #24]
  40eb18:	f8dd a01c 	ldr.w	sl, [sp, #28]
  40eb1c:	ebc7 070b 	rsb	r7, r7, fp
  40eb20:	2300      	movs	r3, #0
  40eb22:	3401      	adds	r4, #1
  40eb24:	44b9      	add	r9, r7
  40eb26:	940b      	str	r4, [sp, #44]	; 0x2c
  40eb28:	f88b 3000 	strb.w	r3, [fp]
  40eb2c:	4652      	mov	r2, sl
  40eb2e:	f7ff bae4 	b.w	40e0fa <__ssvfscanf_r+0x82>
  40eb32:	ab14      	add	r3, sp, #80	; 0x50
  40eb34:	4618      	mov	r0, r3
  40eb36:	2100      	movs	r1, #0
  40eb38:	2208      	movs	r2, #8
  40eb3a:	930a      	str	r3, [sp, #40]	; 0x28
  40eb3c:	f7fd fbee 	bl	40c31c <memset>
  40eb40:	f017 0710 	ands.w	r7, r7, #16
  40eb44:	970d      	str	r7, [sp, #52]	; 0x34
  40eb46:	d06c      	beq.n	40ec22 <__ssvfscanf_r+0xbaa>
  40eb48:	f04f 0a00 	mov.w	sl, #0
  40eb4c:	9608      	str	r6, [sp, #32]
  40eb4e:	9e0d      	ldr	r6, [sp, #52]	; 0x34
  40eb50:	f8cd 9014 	str.w	r9, [sp, #20]
  40eb54:	f04f 0b00 	mov.w	fp, #0
  40eb58:	af56      	add	r7, sp, #344	; 0x158
  40eb5a:	f002 fd53 	bl	411604 <__locale_mb_cur_max>
  40eb5e:	4558      	cmp	r0, fp
  40eb60:	f43f ad22 	beq.w	40e5a8 <__ssvfscanf_r+0x530>
  40eb64:	682b      	ldr	r3, [r5, #0]
  40eb66:	6869      	ldr	r1, [r5, #4]
  40eb68:	f813 eb01 	ldrb.w	lr, [r3], #1
  40eb6c:	980a      	ldr	r0, [sp, #40]	; 0x28
  40eb6e:	602b      	str	r3, [r5, #0]
  40eb70:	3901      	subs	r1, #1
  40eb72:	f10b 0901 	add.w	r9, fp, #1
  40eb76:	9000      	str	r0, [sp, #0]
  40eb78:	464b      	mov	r3, r9
  40eb7a:	6069      	str	r1, [r5, #4]
  40eb7c:	9808      	ldr	r0, [sp, #32]
  40eb7e:	f807 e00b 	strb.w	lr, [r7, fp]
  40eb82:	4651      	mov	r1, sl
  40eb84:	463a      	mov	r2, r7
  40eb86:	f002 fdcb 	bl	411720 <_mbrtowc_r>
  40eb8a:	1c43      	adds	r3, r0, #1
  40eb8c:	f43f ad0c 	beq.w	40e5a8 <__ssvfscanf_r+0x530>
  40eb90:	2800      	cmp	r0, #0
  40eb92:	d177      	bne.n	40ec84 <__ssvfscanf_r+0xc0c>
  40eb94:	b90e      	cbnz	r6, 40eb9a <__ssvfscanf_r+0xb22>
  40eb96:	f8ca 6000 	str.w	r6, [sl]
  40eb9a:	9905      	ldr	r1, [sp, #20]
  40eb9c:	4449      	add	r1, r9
  40eb9e:	9105      	str	r1, [sp, #20]
  40eba0:	3c01      	subs	r4, #1
  40eba2:	2e00      	cmp	r6, #0
  40eba4:	d172      	bne.n	40ec8c <__ssvfscanf_r+0xc14>
  40eba6:	f10a 0a04 	add.w	sl, sl, #4
  40ebaa:	46b3      	mov	fp, r6
  40ebac:	686b      	ldr	r3, [r5, #4]
  40ebae:	2b00      	cmp	r3, #0
  40ebb0:	dd2a      	ble.n	40ec08 <__ssvfscanf_r+0xb90>
  40ebb2:	2c00      	cmp	r4, #0
  40ebb4:	d1d1      	bne.n	40eb5a <__ssvfscanf_r+0xae2>
  40ebb6:	f8dd 9014 	ldr.w	r9, [sp, #20]
  40ebba:	9e08      	ldr	r6, [sp, #32]
  40ebbc:	9c0d      	ldr	r4, [sp, #52]	; 0x34
  40ebbe:	2c00      	cmp	r4, #0
  40ebc0:	f43f ad8e 	beq.w	40e6e0 <__ssvfscanf_r+0x668>
  40ebc4:	e58f      	b.n	40e6e6 <__ssvfscanf_r+0x66e>
  40ebc6:	4622      	mov	r2, r4
  40ebc8:	f88a 4000 	strb.w	r4, [sl]
  40ebcc:	4630      	mov	r0, r6
  40ebce:	9905      	ldr	r1, [sp, #20]
  40ebd0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  40ebd2:	9c09      	ldr	r4, [sp, #36]	; 0x24
  40ebd4:	47a0      	blx	r4
  40ebd6:	06ba      	lsls	r2, r7, #26
  40ebd8:	d535      	bpl.n	40ec46 <__ssvfscanf_r+0xbce>
  40ebda:	f8dd c018 	ldr.w	ip, [sp, #24]
  40ebde:	f8dc 3000 	ldr.w	r3, [ip]
  40ebe2:	f10c 0c04 	add.w	ip, ip, #4
  40ebe6:	f8cd c018 	str.w	ip, [sp, #24]
  40ebea:	6018      	str	r0, [r3, #0]
  40ebec:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
  40ebee:	3401      	adds	r4, #1
  40ebf0:	940b      	str	r4, [sp, #44]	; 0x2c
  40ebf2:	e476      	b.n	40e4e2 <__ssvfscanf_r+0x46a>
  40ebf4:	9c06      	ldr	r4, [sp, #24]
  40ebf6:	6823      	ldr	r3, [r4, #0]
  40ebf8:	3404      	adds	r4, #4
  40ebfa:	9406      	str	r4, [sp, #24]
  40ebfc:	e9c3 ab00 	strd	sl, fp, [r3]
  40ec00:	e6d3      	b.n	40e9aa <__ssvfscanf_r+0x932>
  40ec02:	f427 67b0 	bic.w	r7, r7, #1408	; 0x580
  40ec06:	e44b      	b.n	40e4a0 <__ssvfscanf_r+0x428>
  40ec08:	9808      	ldr	r0, [sp, #32]
  40ec0a:	4629      	mov	r1, r5
  40ec0c:	f004 fff0 	bl	413bf0 <__ssrefill_r>
  40ec10:	2800      	cmp	r0, #0
  40ec12:	d0ce      	beq.n	40ebb2 <__ssvfscanf_r+0xb3a>
  40ec14:	f8dd 9014 	ldr.w	r9, [sp, #20]
  40ec18:	9e08      	ldr	r6, [sp, #32]
  40ec1a:	f1bb 0f00 	cmp.w	fp, #0
  40ec1e:	d0cd      	beq.n	40ebbc <__ssvfscanf_r+0xb44>
  40ec20:	e4c2      	b.n	40e5a8 <__ssvfscanf_r+0x530>
  40ec22:	f8dd c018 	ldr.w	ip, [sp, #24]
  40ec26:	f8dc a000 	ldr.w	sl, [ip]
  40ec2a:	f10c 0c04 	add.w	ip, ip, #4
  40ec2e:	f8cd c018 	str.w	ip, [sp, #24]
  40ec32:	e78b      	b.n	40eb4c <__ssvfscanf_r+0xad4>
  40ec34:	f8dd c018 	ldr.w	ip, [sp, #24]
  40ec38:	f8dc a000 	ldr.w	sl, [ip]
  40ec3c:	f10c 0c04 	add.w	ip, ip, #4
  40ec40:	f8cd c018 	str.w	ip, [sp, #24]
  40ec44:	e53b      	b.n	40e6be <__ssvfscanf_r+0x646>
  40ec46:	077b      	lsls	r3, r7, #29
  40ec48:	f140 809b 	bpl.w	40ed82 <__ssvfscanf_r+0xd0a>
  40ec4c:	9c06      	ldr	r4, [sp, #24]
  40ec4e:	6823      	ldr	r3, [r4, #0]
  40ec50:	3404      	adds	r4, #4
  40ec52:	9406      	str	r4, [sp, #24]
  40ec54:	8018      	strh	r0, [r3, #0]
  40ec56:	e7c9      	b.n	40ebec <__ssvfscanf_r+0xb74>
  40ec58:	f8dd c044 	ldr.w	ip, [sp, #68]	; 0x44
  40ec5c:	4630      	mov	r0, r6
  40ec5e:	f10c 0101 	add.w	r1, ip, #1
  40ec62:	230a      	movs	r3, #10
  40ec64:	f004 fc54 	bl	413510 <_strtol_r>
  40ec68:	f8dd b044 	ldr.w	fp, [sp, #68]	; 0x44
  40ec6c:	1b02      	subs	r2, r0, r4
  40ec6e:	f20d 21ab 	addw	r1, sp, #683	; 0x2ab
  40ec72:	458b      	cmp	fp, r1
  40ec74:	bf28      	it	cs
  40ec76:	f20d 2baa 	addwcs	fp, sp, #682	; 0x2aa
  40ec7a:	4658      	mov	r0, fp
  40ec7c:	499b      	ldr	r1, [pc, #620]	; (40eeec <__ssvfscanf_r+0xe74>)
  40ec7e:	f7fd fc69 	bl	40c554 <sprintf>
  40ec82:	e67b      	b.n	40e97c <__ssvfscanf_r+0x904>
  40ec84:	3002      	adds	r0, #2
  40ec86:	d188      	bne.n	40eb9a <__ssvfscanf_r+0xb22>
  40ec88:	46cb      	mov	fp, r9
  40ec8a:	e78f      	b.n	40ebac <__ssvfscanf_r+0xb34>
  40ec8c:	f04f 0b00 	mov.w	fp, #0
  40ec90:	e78c      	b.n	40ebac <__ssvfscanf_r+0xb34>
  40ec92:	2f00      	cmp	r7, #0
  40ec94:	f43f ac88 	beq.w	40e5a8 <__ssvfscanf_r+0x530>
  40ec98:	44b9      	add	r9, r7
  40ec9a:	f8dd a01c 	ldr.w	sl, [sp, #28]
  40ec9e:	f7ff bbc5 	b.w	40e42c <__ssvfscanf_r+0x3b4>
  40eca2:	f8dd c018 	ldr.w	ip, [sp, #24]
  40eca6:	4623      	mov	r3, r4
  40eca8:	f8dc 1000 	ldr.w	r1, [ip]
  40ecac:	9500      	str	r5, [sp, #0]
  40ecae:	4630      	mov	r0, r6
  40ecb0:	2201      	movs	r2, #1
  40ecb2:	f004 ffbb 	bl	413c2c <_sfread_r>
  40ecb6:	9c06      	ldr	r4, [sp, #24]
  40ecb8:	1d23      	adds	r3, r4, #4
  40ecba:	2800      	cmp	r0, #0
  40ecbc:	f43f ac74 	beq.w	40e5a8 <__ssvfscanf_r+0x530>
  40ecc0:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
  40ecc2:	f8dd a01c 	ldr.w	sl, [sp, #28]
  40ecc6:	9306      	str	r3, [sp, #24]
  40ecc8:	3401      	adds	r4, #1
  40ecca:	4481      	add	r9, r0
  40eccc:	940b      	str	r4, [sp, #44]	; 0x2c
  40ecce:	4652      	mov	r2, sl
  40ecd0:	f7ff ba13 	b.w	40e0fa <__ssvfscanf_r+0x82>
  40ecd4:	4630      	mov	r0, r6
  40ecd6:	4629      	mov	r1, r5
  40ecd8:	f004 ff8a 	bl	413bf0 <__ssrefill_r>
  40ecdc:	2800      	cmp	r0, #0
  40ecde:	f43f aaa2 	beq.w	40e226 <__ssvfscanf_r+0x1ae>
  40ece2:	e461      	b.n	40e5a8 <__ssvfscanf_r+0x530>
  40ece4:	f81a 1c01 	ldrb.w	r1, [sl, #-1]
  40ece8:	4630      	mov	r0, r6
  40ecea:	462a      	mov	r2, r5
  40ecec:	f004 ff40 	bl	413b70 <_sungetc_r>
  40ecf0:	f10a 3aff 	add.w	sl, sl, #4294967295
  40ecf4:	f7ff bbec 	b.w	40e4d0 <__ssvfscanf_r+0x458>
  40ecf8:	f427 67f0 	bic.w	r7, r7, #1920	; 0x780
  40ecfc:	f04f 0a01 	mov.w	sl, #1
  40ed00:	e587      	b.n	40e812 <__ssvfscanf_r+0x79a>
  40ed02:	f427 67f0 	bic.w	r7, r7, #1920	; 0x780
  40ed06:	2301      	movs	r3, #1
  40ed08:	e583      	b.n	40e812 <__ssvfscanf_r+0x79a>
  40ed0a:	f89a 3002 	ldrb.w	r3, [sl, #2]
  40ed0e:	f047 0702 	orr.w	r7, r7, #2
  40ed12:	f10a 0a02 	add.w	sl, sl, #2
  40ed16:	f7ff ba00 	b.w	40e11a <__ssvfscanf_r+0xa2>
  40ed1a:	9b08      	ldr	r3, [sp, #32]
  40ed1c:	9c0a      	ldr	r4, [sp, #40]	; 0x28
  40ed1e:	1b19      	subs	r1, r3, r4
  40ed20:	424a      	negs	r2, r1
  40ed22:	2900      	cmp	r1, #0
  40ed24:	d1a3      	bne.n	40ec6e <__ssvfscanf_r+0xbf6>
  40ed26:	e629      	b.n	40e97c <__ssvfscanf_r+0x904>
  40ed28:	07fc      	lsls	r4, r7, #31
  40ed2a:	d40e      	bmi.n	40ed4a <__ssvfscanf_r+0xcd2>
  40ed2c:	07b8      	lsls	r0, r7, #30
  40ed2e:	d50c      	bpl.n	40ed4a <__ssvfscanf_r+0xcd2>
  40ed30:	9c06      	ldr	r4, [sp, #24]
  40ed32:	f8dd a01c 	ldr.w	sl, [sp, #28]
  40ed36:	6821      	ldr	r1, [r4, #0]
  40ed38:	464a      	mov	r2, r9
  40ed3a:	ea4f 73e9 	mov.w	r3, r9, asr #31
  40ed3e:	3404      	adds	r4, #4
  40ed40:	9406      	str	r4, [sp, #24]
  40ed42:	e9c1 2300 	strd	r2, r3, [r1]
  40ed46:	f7ff b9d7 	b.w	40e0f8 <__ssvfscanf_r+0x80>
  40ed4a:	f8dd c018 	ldr.w	ip, [sp, #24]
  40ed4e:	f8dd a01c 	ldr.w	sl, [sp, #28]
  40ed52:	f8dc 3000 	ldr.w	r3, [ip]
  40ed56:	f10c 0c04 	add.w	ip, ip, #4
  40ed5a:	f8c3 9000 	str.w	r9, [r3]
  40ed5e:	f8cd c018 	str.w	ip, [sp, #24]
  40ed62:	f7ff b9c9 	b.w	40e0f8 <__ssvfscanf_r+0x80>
  40ed66:	9c06      	ldr	r4, [sp, #24]
  40ed68:	1d27      	adds	r7, r4, #4
  40ed6a:	6824      	ldr	r4, [r4, #0]
  40ed6c:	f003 fbaa 	bl	4124c4 <__fpclassifyd>
  40ed70:	2800      	cmp	r0, #0
  40ed72:	d056      	beq.n	40ee22 <__ssvfscanf_r+0xdaa>
  40ed74:	4650      	mov	r0, sl
  40ed76:	4659      	mov	r1, fp
  40ed78:	f006 f99c 	bl	4150b4 <__aeabi_d2f>
  40ed7c:	9706      	str	r7, [sp, #24]
  40ed7e:	6020      	str	r0, [r4, #0]
  40ed80:	e613      	b.n	40e9aa <__ssvfscanf_r+0x932>
  40ed82:	f017 0201 	ands.w	r2, r7, #1
  40ed86:	f47f af28 	bne.w	40ebda <__ssvfscanf_r+0xb62>
  40ed8a:	07bc      	lsls	r4, r7, #30
  40ed8c:	f140 8097 	bpl.w	40eebe <__ssvfscanf_r+0xe46>
  40ed90:	4b57      	ldr	r3, [pc, #348]	; (40eef0 <__ssvfscanf_r+0xe78>)
  40ed92:	9c09      	ldr	r4, [sp, #36]	; 0x24
  40ed94:	9905      	ldr	r1, [sp, #20]
  40ed96:	429c      	cmp	r4, r3
  40ed98:	4630      	mov	r0, r6
  40ed9a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  40ed9c:	f000 80a2 	beq.w	40eee4 <__ssvfscanf_r+0xe6c>
  40eda0:	f004 fc40 	bl	413624 <_strtoll_r>
  40eda4:	f8dd c018 	ldr.w	ip, [sp, #24]
  40eda8:	f8dc 3000 	ldr.w	r3, [ip]
  40edac:	f10c 0c04 	add.w	ip, ip, #4
  40edb0:	f8cd c018 	str.w	ip, [sp, #24]
  40edb4:	e9c3 0100 	strd	r0, r1, [r3]
  40edb8:	e718      	b.n	40ebec <__ssvfscanf_r+0xb74>
  40edba:	9204      	str	r2, [sp, #16]
  40edbc:	f002 fc22 	bl	411604 <__locale_mb_cur_max>
  40edc0:	9a04      	ldr	r2, [sp, #16]
  40edc2:	4290      	cmp	r0, r2
  40edc4:	f43f abf0 	beq.w	40e5a8 <__ssvfscanf_r+0x530>
  40edc8:	682b      	ldr	r3, [r5, #0]
  40edca:	6869      	ldr	r1, [r5, #4]
  40edcc:	f813 eb01 	ldrb.w	lr, [r3], #1
  40edd0:	980a      	ldr	r0, [sp, #40]	; 0x28
  40edd2:	602b      	str	r3, [r5, #0]
  40edd4:	f50d 7cac 	add.w	ip, sp, #344	; 0x158
  40edd8:	1c57      	adds	r7, r2, #1
  40edda:	3901      	subs	r1, #1
  40eddc:	9000      	str	r0, [sp, #0]
  40edde:	463b      	mov	r3, r7
  40ede0:	6069      	str	r1, [r5, #4]
  40ede2:	f80c e002 	strb.w	lr, [ip, r2]
  40ede6:	4630      	mov	r0, r6
  40ede8:	4651      	mov	r1, sl
  40edea:	4662      	mov	r2, ip
  40edec:	f002 fc98 	bl	411720 <_mbrtowc_r>
  40edf0:	1c43      	adds	r3, r0, #1
  40edf2:	f43f abd9 	beq.w	40e5a8 <__ssvfscanf_r+0x530>
  40edf6:	b9c8      	cbnz	r0, 40ee2c <__ssvfscanf_r+0xdb4>
  40edf8:	f8ca 0000 	str.w	r0, [sl]
  40edfc:	f002 fbf0 	bl	4115e0 <iswspace>
  40ee00:	2800      	cmp	r0, #0
  40ee02:	d053      	beq.n	40eeac <__ssvfscanf_r+0xe34>
  40ee04:	2f00      	cmp	r7, #0
  40ee06:	f43f ac66 	beq.w	40e6d6 <__ssvfscanf_r+0x65e>
  40ee0a:	ac56      	add	r4, sp, #344	; 0x158
  40ee0c:	443c      	add	r4, r7
  40ee0e:	3f01      	subs	r7, #1
  40ee10:	4630      	mov	r0, r6
  40ee12:	f814 1d01 	ldrb.w	r1, [r4, #-1]!
  40ee16:	462a      	mov	r2, r5
  40ee18:	f004 feaa 	bl	413b70 <_sungetc_r>
  40ee1c:	2f00      	cmp	r7, #0
  40ee1e:	d1f6      	bne.n	40ee0e <__ssvfscanf_r+0xd96>
  40ee20:	e459      	b.n	40e6d6 <__ssvfscanf_r+0x65e>
  40ee22:	f003 fbaf 	bl	412584 <nanf>
  40ee26:	9706      	str	r7, [sp, #24]
  40ee28:	6020      	str	r0, [r4, #0]
  40ee2a:	e5be      	b.n	40e9aa <__ssvfscanf_r+0x932>
  40ee2c:	3002      	adds	r0, #2
  40ee2e:	d128      	bne.n	40ee82 <__ssvfscanf_r+0xe0a>
  40ee30:	686b      	ldr	r3, [r5, #4]
  40ee32:	2b00      	cmp	r3, #0
  40ee34:	dd4b      	ble.n	40eece <__ssvfscanf_r+0xe56>
  40ee36:	463a      	mov	r2, r7
  40ee38:	e442      	b.n	40e6c0 <__ssvfscanf_r+0x648>
  40ee3a:	9c05      	ldr	r4, [sp, #20]
  40ee3c:	45a3      	cmp	fp, r4
  40ee3e:	bf88      	it	hi
  40ee40:	465c      	movhi	r4, fp
  40ee42:	f67f a960 	bls.w	40e106 <__ssvfscanf_r+0x8e>
  40ee46:	f814 1d01 	ldrb.w	r1, [r4, #-1]!
  40ee4a:	980e      	ldr	r0, [sp, #56]	; 0x38
  40ee4c:	462a      	mov	r2, r5
  40ee4e:	f004 fe8f 	bl	413b70 <_sungetc_r>
  40ee52:	f8dd 9014 	ldr.w	r9, [sp, #20]
  40ee56:	454c      	cmp	r4, r9
  40ee58:	d1f5      	bne.n	40ee46 <__ssvfscanf_r+0xdce>
  40ee5a:	f7ff b954 	b.w	40e106 <__ssvfscanf_r+0x8e>
  40ee5e:	f8dd c014 	ldr.w	ip, [sp, #20]
  40ee62:	45e3      	cmp	fp, ip
  40ee64:	f67f a94f 	bls.w	40e106 <__ssvfscanf_r+0x8e>
  40ee68:	465c      	mov	r4, fp
  40ee6a:	f814 1d01 	ldrb.w	r1, [r4, #-1]!
  40ee6e:	980e      	ldr	r0, [sp, #56]	; 0x38
  40ee70:	462a      	mov	r2, r5
  40ee72:	f004 fe7d 	bl	413b70 <_sungetc_r>
  40ee76:	f8dd 9014 	ldr.w	r9, [sp, #20]
  40ee7a:	454c      	cmp	r4, r9
  40ee7c:	d1f5      	bne.n	40ee6a <__ssvfscanf_r+0xdf2>
  40ee7e:	f7ff b942 	b.w	40e106 <__ssvfscanf_r+0x8e>
  40ee82:	f8da 0000 	ldr.w	r0, [sl]
  40ee86:	e7b9      	b.n	40edfc <__ssvfscanf_r+0xd84>
  40ee88:	f8dd 9014 	ldr.w	r9, [sp, #20]
  40ee8c:	45cb      	cmp	fp, r9
  40ee8e:	f67f a93a 	bls.w	40e106 <__ssvfscanf_r+0x8e>
  40ee92:	465c      	mov	r4, fp
  40ee94:	f814 1d01 	ldrb.w	r1, [r4, #-1]!
  40ee98:	980e      	ldr	r0, [sp, #56]	; 0x38
  40ee9a:	462a      	mov	r2, r5
  40ee9c:	f004 fe68 	bl	413b70 <_sungetc_r>
  40eea0:	f8dd c014 	ldr.w	ip, [sp, #20]
  40eea4:	4564      	cmp	r4, ip
  40eea6:	d1f5      	bne.n	40ee94 <__ssvfscanf_r+0xe1c>
  40eea8:	f7ff b92d 	b.w	40e106 <__ssvfscanf_r+0x8e>
  40eeac:	44b9      	add	r9, r7
  40eeae:	3c01      	subs	r4, #1
  40eeb0:	f1bb 0f00 	cmp.w	fp, #0
  40eeb4:	d109      	bne.n	40eeca <__ssvfscanf_r+0xe52>
  40eeb6:	f10a 0a04 	add.w	sl, sl, #4
  40eeba:	465f      	mov	r7, fp
  40eebc:	e7b8      	b.n	40ee30 <__ssvfscanf_r+0xdb8>
  40eebe:	9c06      	ldr	r4, [sp, #24]
  40eec0:	6823      	ldr	r3, [r4, #0]
  40eec2:	3404      	adds	r4, #4
  40eec4:	9406      	str	r4, [sp, #24]
  40eec6:	6018      	str	r0, [r3, #0]
  40eec8:	e690      	b.n	40ebec <__ssvfscanf_r+0xb74>
  40eeca:	4607      	mov	r7, r0
  40eecc:	e7b0      	b.n	40ee30 <__ssvfscanf_r+0xdb8>
  40eece:	4630      	mov	r0, r6
  40eed0:	4629      	mov	r1, r5
  40eed2:	f004 fe8d 	bl	413bf0 <__ssrefill_r>
  40eed6:	2800      	cmp	r0, #0
  40eed8:	d0ad      	beq.n	40ee36 <__ssvfscanf_r+0xdbe>
  40eeda:	2f00      	cmp	r7, #0
  40eedc:	f47f ab64 	bne.w	40e5a8 <__ssvfscanf_r+0x530>
  40eee0:	f7ff bbf9 	b.w	40e6d6 <__ssvfscanf_r+0x65e>
  40eee4:	f004 fcfc 	bl	4138e0 <_strtoull_r>
  40eee8:	e75c      	b.n	40eda4 <__ssvfscanf_r+0xd2c>
  40eeea:	bf00      	nop
  40eeec:	00416ec8 	.word	0x00416ec8
  40eef0:	004137c1 	.word	0x004137c1

0040eef4 <__sprint_r.part.0>:
  40eef4:	6e4b      	ldr	r3, [r1, #100]	; 0x64
  40eef6:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  40eefa:	049c      	lsls	r4, r3, #18
  40eefc:	460e      	mov	r6, r1
  40eefe:	4680      	mov	r8, r0
  40ef00:	4691      	mov	r9, r2
  40ef02:	d52a      	bpl.n	40ef5a <__sprint_r.part.0+0x66>
  40ef04:	6893      	ldr	r3, [r2, #8]
  40ef06:	6812      	ldr	r2, [r2, #0]
  40ef08:	f102 0a08 	add.w	sl, r2, #8
  40ef0c:	b31b      	cbz	r3, 40ef56 <__sprint_r.part.0+0x62>
  40ef0e:	e91a 00a0 	ldmdb	sl, {r5, r7}
  40ef12:	08bf      	lsrs	r7, r7, #2
  40ef14:	d017      	beq.n	40ef46 <__sprint_r.part.0+0x52>
  40ef16:	3d04      	subs	r5, #4
  40ef18:	2400      	movs	r4, #0
  40ef1a:	e001      	b.n	40ef20 <__sprint_r.part.0+0x2c>
  40ef1c:	42a7      	cmp	r7, r4
  40ef1e:	d010      	beq.n	40ef42 <__sprint_r.part.0+0x4e>
  40ef20:	4640      	mov	r0, r8
  40ef22:	f855 1f04 	ldr.w	r1, [r5, #4]!
  40ef26:	4632      	mov	r2, r6
  40ef28:	f002 f82e 	bl	410f88 <_fputwc_r>
  40ef2c:	1c43      	adds	r3, r0, #1
  40ef2e:	f104 0401 	add.w	r4, r4, #1
  40ef32:	d1f3      	bne.n	40ef1c <__sprint_r.part.0+0x28>
  40ef34:	2300      	movs	r3, #0
  40ef36:	f8c9 3008 	str.w	r3, [r9, #8]
  40ef3a:	f8c9 3004 	str.w	r3, [r9, #4]
  40ef3e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  40ef42:	f8d9 3008 	ldr.w	r3, [r9, #8]
  40ef46:	eba3 0387 	sub.w	r3, r3, r7, lsl #2
  40ef4a:	f8c9 3008 	str.w	r3, [r9, #8]
  40ef4e:	f10a 0a08 	add.w	sl, sl, #8
  40ef52:	2b00      	cmp	r3, #0
  40ef54:	d1db      	bne.n	40ef0e <__sprint_r.part.0+0x1a>
  40ef56:	2000      	movs	r0, #0
  40ef58:	e7ec      	b.n	40ef34 <__sprint_r.part.0+0x40>
  40ef5a:	f002 f98f 	bl	41127c <__sfvwrite_r>
  40ef5e:	2300      	movs	r3, #0
  40ef60:	f8c9 3008 	str.w	r3, [r9, #8]
  40ef64:	f8c9 3004 	str.w	r3, [r9, #4]
  40ef68:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0040ef6c <_vfiprintf_r>:
  40ef6c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40ef70:	b0b1      	sub	sp, #196	; 0xc4
  40ef72:	461c      	mov	r4, r3
  40ef74:	9102      	str	r1, [sp, #8]
  40ef76:	4690      	mov	r8, r2
  40ef78:	9308      	str	r3, [sp, #32]
  40ef7a:	9006      	str	r0, [sp, #24]
  40ef7c:	b118      	cbz	r0, 40ef86 <_vfiprintf_r+0x1a>
  40ef7e:	6b83      	ldr	r3, [r0, #56]	; 0x38
  40ef80:	2b00      	cmp	r3, #0
  40ef82:	f000 80e8 	beq.w	40f156 <_vfiprintf_r+0x1ea>
  40ef86:	9d02      	ldr	r5, [sp, #8]
  40ef88:	89ab      	ldrh	r3, [r5, #12]
  40ef8a:	b29a      	uxth	r2, r3
  40ef8c:	0490      	lsls	r0, r2, #18
  40ef8e:	d407      	bmi.n	40efa0 <_vfiprintf_r+0x34>
  40ef90:	6e6a      	ldr	r2, [r5, #100]	; 0x64
  40ef92:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
  40ef96:	f422 5100 	bic.w	r1, r2, #8192	; 0x2000
  40ef9a:	81ab      	strh	r3, [r5, #12]
  40ef9c:	b29a      	uxth	r2, r3
  40ef9e:	6669      	str	r1, [r5, #100]	; 0x64
  40efa0:	0711      	lsls	r1, r2, #28
  40efa2:	f140 80b7 	bpl.w	40f114 <_vfiprintf_r+0x1a8>
  40efa6:	f8dd b008 	ldr.w	fp, [sp, #8]
  40efaa:	f8db 3010 	ldr.w	r3, [fp, #16]
  40efae:	2b00      	cmp	r3, #0
  40efb0:	f000 80b0 	beq.w	40f114 <_vfiprintf_r+0x1a8>
  40efb4:	f002 021a 	and.w	r2, r2, #26
  40efb8:	2a0a      	cmp	r2, #10
  40efba:	f000 80b7 	beq.w	40f12c <_vfiprintf_r+0x1c0>
  40efbe:	2300      	movs	r3, #0
  40efc0:	f10d 0980 	add.w	r9, sp, #128	; 0x80
  40efc4:	930a      	str	r3, [sp, #40]	; 0x28
  40efc6:	9315      	str	r3, [sp, #84]	; 0x54
  40efc8:	9314      	str	r3, [sp, #80]	; 0x50
  40efca:	9309      	str	r3, [sp, #36]	; 0x24
  40efcc:	f8cd 904c 	str.w	r9, [sp, #76]	; 0x4c
  40efd0:	464e      	mov	r6, r9
  40efd2:	f898 3000 	ldrb.w	r3, [r8]
  40efd6:	2b00      	cmp	r3, #0
  40efd8:	f000 84c4 	beq.w	40f964 <_vfiprintf_r+0x9f8>
  40efdc:	2b25      	cmp	r3, #37	; 0x25
  40efde:	f000 84c1 	beq.w	40f964 <_vfiprintf_r+0x9f8>
  40efe2:	f108 0201 	add.w	r2, r8, #1
  40efe6:	e001      	b.n	40efec <_vfiprintf_r+0x80>
  40efe8:	2b25      	cmp	r3, #37	; 0x25
  40efea:	d004      	beq.n	40eff6 <_vfiprintf_r+0x8a>
  40efec:	4614      	mov	r4, r2
  40efee:	3201      	adds	r2, #1
  40eff0:	7823      	ldrb	r3, [r4, #0]
  40eff2:	2b00      	cmp	r3, #0
  40eff4:	d1f8      	bne.n	40efe8 <_vfiprintf_r+0x7c>
  40eff6:	ebc8 0504 	rsb	r5, r8, r4
  40effa:	b195      	cbz	r5, 40f022 <_vfiprintf_r+0xb6>
  40effc:	9b14      	ldr	r3, [sp, #80]	; 0x50
  40effe:	9a15      	ldr	r2, [sp, #84]	; 0x54
  40f000:	f8c6 8000 	str.w	r8, [r6]
  40f004:	3301      	adds	r3, #1
  40f006:	442a      	add	r2, r5
  40f008:	2b07      	cmp	r3, #7
  40f00a:	6075      	str	r5, [r6, #4]
  40f00c:	9215      	str	r2, [sp, #84]	; 0x54
  40f00e:	9314      	str	r3, [sp, #80]	; 0x50
  40f010:	dd7b      	ble.n	40f10a <_vfiprintf_r+0x19e>
  40f012:	2a00      	cmp	r2, #0
  40f014:	f040 84d4 	bne.w	40f9c0 <_vfiprintf_r+0xa54>
  40f018:	9809      	ldr	r0, [sp, #36]	; 0x24
  40f01a:	9214      	str	r2, [sp, #80]	; 0x50
  40f01c:	4428      	add	r0, r5
  40f01e:	464e      	mov	r6, r9
  40f020:	9009      	str	r0, [sp, #36]	; 0x24
  40f022:	7823      	ldrb	r3, [r4, #0]
  40f024:	2b00      	cmp	r3, #0
  40f026:	f000 83e9 	beq.w	40f7fc <_vfiprintf_r+0x890>
  40f02a:	2100      	movs	r1, #0
  40f02c:	f04f 0200 	mov.w	r2, #0
  40f030:	f04f 3cff 	mov.w	ip, #4294967295
  40f034:	7863      	ldrb	r3, [r4, #1]
  40f036:	f88d 2047 	strb.w	r2, [sp, #71]	; 0x47
  40f03a:	9104      	str	r1, [sp, #16]
  40f03c:	468a      	mov	sl, r1
  40f03e:	f104 0801 	add.w	r8, r4, #1
  40f042:	4608      	mov	r0, r1
  40f044:	4665      	mov	r5, ip
  40f046:	f108 0801 	add.w	r8, r8, #1
  40f04a:	f1a3 0220 	sub.w	r2, r3, #32
  40f04e:	2a58      	cmp	r2, #88	; 0x58
  40f050:	f200 82d5 	bhi.w	40f5fe <_vfiprintf_r+0x692>
  40f054:	e8df f012 	tbh	[pc, r2, lsl #1]
  40f058:	02d302c7 	.word	0x02d302c7
  40f05c:	02ce02d3 	.word	0x02ce02d3
  40f060:	02d302d3 	.word	0x02d302d3
  40f064:	02d302d3 	.word	0x02d302d3
  40f068:	02d302d3 	.word	0x02d302d3
  40f06c:	028b027e 	.word	0x028b027e
  40f070:	008402d3 	.word	0x008402d3
  40f074:	02d3028f 	.word	0x02d3028f
  40f078:	0194012b 	.word	0x0194012b
  40f07c:	01940194 	.word	0x01940194
  40f080:	01940194 	.word	0x01940194
  40f084:	01940194 	.word	0x01940194
  40f088:	01940194 	.word	0x01940194
  40f08c:	02d302d3 	.word	0x02d302d3
  40f090:	02d302d3 	.word	0x02d302d3
  40f094:	02d302d3 	.word	0x02d302d3
  40f098:	02d302d3 	.word	0x02d302d3
  40f09c:	02d302d3 	.word	0x02d302d3
  40f0a0:	02d30130 	.word	0x02d30130
  40f0a4:	02d302d3 	.word	0x02d302d3
  40f0a8:	02d302d3 	.word	0x02d302d3
  40f0ac:	02d302d3 	.word	0x02d302d3
  40f0b0:	02d302d3 	.word	0x02d302d3
  40f0b4:	017902d3 	.word	0x017902d3
  40f0b8:	02d302d3 	.word	0x02d302d3
  40f0bc:	02d302d3 	.word	0x02d302d3
  40f0c0:	01a202d3 	.word	0x01a202d3
  40f0c4:	02d302d3 	.word	0x02d302d3
  40f0c8:	02d301bd 	.word	0x02d301bd
  40f0cc:	02d302d3 	.word	0x02d302d3
  40f0d0:	02d302d3 	.word	0x02d302d3
  40f0d4:	02d302d3 	.word	0x02d302d3
  40f0d8:	02d302d3 	.word	0x02d302d3
  40f0dc:	01e202d3 	.word	0x01e202d3
  40f0e0:	02d301f8 	.word	0x02d301f8
  40f0e4:	02d302d3 	.word	0x02d302d3
  40f0e8:	01f80214 	.word	0x01f80214
  40f0ec:	02d302d3 	.word	0x02d302d3
  40f0f0:	02d30219 	.word	0x02d30219
  40f0f4:	00890226 	.word	0x00890226
  40f0f8:	02790264 	.word	0x02790264
  40f0fc:	023802d3 	.word	0x023802d3
  40f100:	011902d3 	.word	0x011902d3
  40f104:	02d302d3 	.word	0x02d302d3
  40f108:	02ab      	.short	0x02ab
  40f10a:	3608      	adds	r6, #8
  40f10c:	9809      	ldr	r0, [sp, #36]	; 0x24
  40f10e:	4428      	add	r0, r5
  40f110:	9009      	str	r0, [sp, #36]	; 0x24
  40f112:	e786      	b.n	40f022 <_vfiprintf_r+0xb6>
  40f114:	9806      	ldr	r0, [sp, #24]
  40f116:	9902      	ldr	r1, [sp, #8]
  40f118:	f000 fda2 	bl	40fc60 <__swsetup_r>
  40f11c:	b9b0      	cbnz	r0, 40f14c <_vfiprintf_r+0x1e0>
  40f11e:	9d02      	ldr	r5, [sp, #8]
  40f120:	89aa      	ldrh	r2, [r5, #12]
  40f122:	f002 021a 	and.w	r2, r2, #26
  40f126:	2a0a      	cmp	r2, #10
  40f128:	f47f af49 	bne.w	40efbe <_vfiprintf_r+0x52>
  40f12c:	f8dd b008 	ldr.w	fp, [sp, #8]
  40f130:	f9bb 300e 	ldrsh.w	r3, [fp, #14]
  40f134:	2b00      	cmp	r3, #0
  40f136:	f6ff af42 	blt.w	40efbe <_vfiprintf_r+0x52>
  40f13a:	9806      	ldr	r0, [sp, #24]
  40f13c:	4659      	mov	r1, fp
  40f13e:	4642      	mov	r2, r8
  40f140:	4623      	mov	r3, r4
  40f142:	f000 fd3d 	bl	40fbc0 <__sbprintf>
  40f146:	b031      	add	sp, #196	; 0xc4
  40f148:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40f14c:	f04f 30ff 	mov.w	r0, #4294967295
  40f150:	b031      	add	sp, #196	; 0xc4
  40f152:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40f156:	f001 fe81 	bl	410e5c <__sinit>
  40f15a:	e714      	b.n	40ef86 <_vfiprintf_r+0x1a>
  40f15c:	4240      	negs	r0, r0
  40f15e:	9308      	str	r3, [sp, #32]
  40f160:	f04a 0a04 	orr.w	sl, sl, #4
  40f164:	f898 3000 	ldrb.w	r3, [r8]
  40f168:	e76d      	b.n	40f046 <_vfiprintf_r+0xda>
  40f16a:	f01a 0320 	ands.w	r3, sl, #32
  40f16e:	9004      	str	r0, [sp, #16]
  40f170:	46ac      	mov	ip, r5
  40f172:	f000 80f2 	beq.w	40f35a <_vfiprintf_r+0x3ee>
  40f176:	f8dd b020 	ldr.w	fp, [sp, #32]
  40f17a:	f10b 0307 	add.w	r3, fp, #7
  40f17e:	f023 0307 	bic.w	r3, r3, #7
  40f182:	f103 0408 	add.w	r4, r3, #8
  40f186:	9408      	str	r4, [sp, #32]
  40f188:	e9d3 4500 	ldrd	r4, r5, [r3]
  40f18c:	2300      	movs	r3, #0
  40f18e:	f04f 0000 	mov.w	r0, #0
  40f192:	2100      	movs	r1, #0
  40f194:	f88d 0047 	strb.w	r0, [sp, #71]	; 0x47
  40f198:	f8cd c014 	str.w	ip, [sp, #20]
  40f19c:	9107      	str	r1, [sp, #28]
  40f19e:	f1bc 0f00 	cmp.w	ip, #0
  40f1a2:	bfa8      	it	ge
  40f1a4:	f02a 0a80 	bicge.w	sl, sl, #128	; 0x80
  40f1a8:	ea54 0205 	orrs.w	r2, r4, r5
  40f1ac:	f040 80ad 	bne.w	40f30a <_vfiprintf_r+0x39e>
  40f1b0:	f1bc 0f00 	cmp.w	ip, #0
  40f1b4:	f040 80a9 	bne.w	40f30a <_vfiprintf_r+0x39e>
  40f1b8:	2b00      	cmp	r3, #0
  40f1ba:	f040 83bc 	bne.w	40f936 <_vfiprintf_r+0x9ca>
  40f1be:	f01a 0f01 	tst.w	sl, #1
  40f1c2:	f000 83b8 	beq.w	40f936 <_vfiprintf_r+0x9ca>
  40f1c6:	af30      	add	r7, sp, #192	; 0xc0
  40f1c8:	2330      	movs	r3, #48	; 0x30
  40f1ca:	f807 3d41 	strb.w	r3, [r7, #-65]!
  40f1ce:	ebc7 0409 	rsb	r4, r7, r9
  40f1d2:	9405      	str	r4, [sp, #20]
  40f1d4:	f8dd b014 	ldr.w	fp, [sp, #20]
  40f1d8:	9c07      	ldr	r4, [sp, #28]
  40f1da:	45e3      	cmp	fp, ip
  40f1dc:	bfb8      	it	lt
  40f1de:	46e3      	movlt	fp, ip
  40f1e0:	f8cd b00c 	str.w	fp, [sp, #12]
  40f1e4:	b11c      	cbz	r4, 40f1ee <_vfiprintf_r+0x282>
  40f1e6:	f10b 0b01 	add.w	fp, fp, #1
  40f1ea:	f8cd b00c 	str.w	fp, [sp, #12]
  40f1ee:	f01a 0502 	ands.w	r5, sl, #2
  40f1f2:	9507      	str	r5, [sp, #28]
  40f1f4:	d005      	beq.n	40f202 <_vfiprintf_r+0x296>
  40f1f6:	f8dd b00c 	ldr.w	fp, [sp, #12]
  40f1fa:	f10b 0b02 	add.w	fp, fp, #2
  40f1fe:	f8cd b00c 	str.w	fp, [sp, #12]
  40f202:	f01a 0384 	ands.w	r3, sl, #132	; 0x84
  40f206:	930b      	str	r3, [sp, #44]	; 0x2c
  40f208:	f040 8217 	bne.w	40f63a <_vfiprintf_r+0x6ce>
  40f20c:	9d04      	ldr	r5, [sp, #16]
  40f20e:	f8dd b00c 	ldr.w	fp, [sp, #12]
  40f212:	ebcb 0405 	rsb	r4, fp, r5
  40f216:	2c00      	cmp	r4, #0
  40f218:	f340 820f 	ble.w	40f63a <_vfiprintf_r+0x6ce>
  40f21c:	2c10      	cmp	r4, #16
  40f21e:	f340 8488 	ble.w	40fb32 <_vfiprintf_r+0xbc6>
  40f222:	4dbd      	ldr	r5, [pc, #756]	; (40f518 <_vfiprintf_r+0x5ac>)
  40f224:	9a15      	ldr	r2, [sp, #84]	; 0x54
  40f226:	9814      	ldr	r0, [sp, #80]	; 0x50
  40f228:	462b      	mov	r3, r5
  40f22a:	f04f 0b10 	mov.w	fp, #16
  40f22e:	4625      	mov	r5, r4
  40f230:	4664      	mov	r4, ip
  40f232:	46b4      	mov	ip, r6
  40f234:	461e      	mov	r6, r3
  40f236:	e006      	b.n	40f246 <_vfiprintf_r+0x2da>
  40f238:	1c83      	adds	r3, r0, #2
  40f23a:	f10c 0c08 	add.w	ip, ip, #8
  40f23e:	4608      	mov	r0, r1
  40f240:	3d10      	subs	r5, #16
  40f242:	2d10      	cmp	r5, #16
  40f244:	dd11      	ble.n	40f26a <_vfiprintf_r+0x2fe>
  40f246:	1c41      	adds	r1, r0, #1
  40f248:	3210      	adds	r2, #16
  40f24a:	2907      	cmp	r1, #7
  40f24c:	9215      	str	r2, [sp, #84]	; 0x54
  40f24e:	e88c 0840 	stmia.w	ip, {r6, fp}
  40f252:	9114      	str	r1, [sp, #80]	; 0x50
  40f254:	ddf0      	ble.n	40f238 <_vfiprintf_r+0x2cc>
  40f256:	2a00      	cmp	r2, #0
  40f258:	f040 81e2 	bne.w	40f620 <_vfiprintf_r+0x6b4>
  40f25c:	3d10      	subs	r5, #16
  40f25e:	2d10      	cmp	r5, #16
  40f260:	f04f 0301 	mov.w	r3, #1
  40f264:	4610      	mov	r0, r2
  40f266:	46cc      	mov	ip, r9
  40f268:	dced      	bgt.n	40f246 <_vfiprintf_r+0x2da>
  40f26a:	4631      	mov	r1, r6
  40f26c:	4666      	mov	r6, ip
  40f26e:	46a4      	mov	ip, r4
  40f270:	462c      	mov	r4, r5
  40f272:	460d      	mov	r5, r1
  40f274:	4422      	add	r2, r4
  40f276:	2b07      	cmp	r3, #7
  40f278:	9215      	str	r2, [sp, #84]	; 0x54
  40f27a:	6035      	str	r5, [r6, #0]
  40f27c:	6074      	str	r4, [r6, #4]
  40f27e:	9314      	str	r3, [sp, #80]	; 0x50
  40f280:	f300 8369 	bgt.w	40f956 <_vfiprintf_r+0x9ea>
  40f284:	3608      	adds	r6, #8
  40f286:	1c59      	adds	r1, r3, #1
  40f288:	e1da      	b.n	40f640 <_vfiprintf_r+0x6d4>
  40f28a:	f01a 0f20 	tst.w	sl, #32
  40f28e:	9004      	str	r0, [sp, #16]
  40f290:	46ac      	mov	ip, r5
  40f292:	f000 808b 	beq.w	40f3ac <_vfiprintf_r+0x440>
  40f296:	9d08      	ldr	r5, [sp, #32]
  40f298:	1deb      	adds	r3, r5, #7
  40f29a:	f023 0307 	bic.w	r3, r3, #7
  40f29e:	f103 0b08 	add.w	fp, r3, #8
  40f2a2:	e9d3 4500 	ldrd	r4, r5, [r3]
  40f2a6:	f8cd b020 	str.w	fp, [sp, #32]
  40f2aa:	2301      	movs	r3, #1
  40f2ac:	e76f      	b.n	40f18e <_vfiprintf_r+0x222>
  40f2ae:	f04a 0a80 	orr.w	sl, sl, #128	; 0x80
  40f2b2:	f898 3000 	ldrb.w	r3, [r8]
  40f2b6:	e6c6      	b.n	40f046 <_vfiprintf_r+0xda>
  40f2b8:	f04a 0a10 	orr.w	sl, sl, #16
  40f2bc:	f01a 0f20 	tst.w	sl, #32
  40f2c0:	9004      	str	r0, [sp, #16]
  40f2c2:	46ac      	mov	ip, r5
  40f2c4:	f88d 1047 	strb.w	r1, [sp, #71]	; 0x47
  40f2c8:	f000 80c6 	beq.w	40f458 <_vfiprintf_r+0x4ec>
  40f2cc:	9c08      	ldr	r4, [sp, #32]
  40f2ce:	1de1      	adds	r1, r4, #7
  40f2d0:	f021 0107 	bic.w	r1, r1, #7
  40f2d4:	e9d1 2300 	ldrd	r2, r3, [r1]
  40f2d8:	3108      	adds	r1, #8
  40f2da:	9108      	str	r1, [sp, #32]
  40f2dc:	4614      	mov	r4, r2
  40f2de:	461d      	mov	r5, r3
  40f2e0:	2a00      	cmp	r2, #0
  40f2e2:	f173 0000 	sbcs.w	r0, r3, #0
  40f2e6:	f2c0 83cd 	blt.w	40fa84 <_vfiprintf_r+0xb18>
  40f2ea:	f1bc 0f00 	cmp.w	ip, #0
  40f2ee:	f89d 1047 	ldrb.w	r1, [sp, #71]	; 0x47
  40f2f2:	9107      	str	r1, [sp, #28]
  40f2f4:	bfa8      	it	ge
  40f2f6:	f02a 0a80 	bicge.w	sl, sl, #128	; 0x80
  40f2fa:	ea54 0205 	orrs.w	r2, r4, r5
  40f2fe:	f8cd c014 	str.w	ip, [sp, #20]
  40f302:	f04f 0301 	mov.w	r3, #1
  40f306:	f43f af53 	beq.w	40f1b0 <_vfiprintf_r+0x244>
  40f30a:	2b01      	cmp	r3, #1
  40f30c:	f000 8315 	beq.w	40f93a <_vfiprintf_r+0x9ce>
  40f310:	2b02      	cmp	r3, #2
  40f312:	f10d 037f 	add.w	r3, sp, #127	; 0x7f
  40f316:	f040 8248 	bne.w	40f7aa <_vfiprintf_r+0x83e>
  40f31a:	980a      	ldr	r0, [sp, #40]	; 0x28
  40f31c:	4619      	mov	r1, r3
  40f31e:	0922      	lsrs	r2, r4, #4
  40f320:	f004 040f 	and.w	r4, r4, #15
  40f324:	ea42 7205 	orr.w	r2, r2, r5, lsl #28
  40f328:	460f      	mov	r7, r1
  40f32a:	092b      	lsrs	r3, r5, #4
  40f32c:	5d01      	ldrb	r1, [r0, r4]
  40f32e:	7039      	strb	r1, [r7, #0]
  40f330:	ea52 0b03 	orrs.w	fp, r2, r3
  40f334:	4614      	mov	r4, r2
  40f336:	461d      	mov	r5, r3
  40f338:	f107 31ff 	add.w	r1, r7, #4294967295
  40f33c:	d1ef      	bne.n	40f31e <_vfiprintf_r+0x3b2>
  40f33e:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
  40f342:	ebc7 0309 	rsb	r3, r7, r9
  40f346:	9305      	str	r3, [sp, #20]
  40f348:	e744      	b.n	40f1d4 <_vfiprintf_r+0x268>
  40f34a:	f04a 0a10 	orr.w	sl, sl, #16
  40f34e:	f01a 0320 	ands.w	r3, sl, #32
  40f352:	9004      	str	r0, [sp, #16]
  40f354:	46ac      	mov	ip, r5
  40f356:	f47f af0e 	bne.w	40f176 <_vfiprintf_r+0x20a>
  40f35a:	f01a 0210 	ands.w	r2, sl, #16
  40f35e:	f040 830f 	bne.w	40f980 <_vfiprintf_r+0xa14>
  40f362:	f01a 0340 	ands.w	r3, sl, #64	; 0x40
  40f366:	f000 830b 	beq.w	40f980 <_vfiprintf_r+0xa14>
  40f36a:	f8dd b020 	ldr.w	fp, [sp, #32]
  40f36e:	f8bb 4000 	ldrh.w	r4, [fp]
  40f372:	f10b 0b04 	add.w	fp, fp, #4
  40f376:	4613      	mov	r3, r2
  40f378:	2500      	movs	r5, #0
  40f37a:	f8cd b020 	str.w	fp, [sp, #32]
  40f37e:	e706      	b.n	40f18e <_vfiprintf_r+0x222>
  40f380:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
  40f384:	2000      	movs	r0, #0
  40f386:	f818 3b01 	ldrb.w	r3, [r8], #1
  40f38a:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  40f38e:	eb02 0040 	add.w	r0, r2, r0, lsl #1
  40f392:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
  40f396:	2a09      	cmp	r2, #9
  40f398:	d9f5      	bls.n	40f386 <_vfiprintf_r+0x41a>
  40f39a:	e656      	b.n	40f04a <_vfiprintf_r+0xde>
  40f39c:	f04a 0a10 	orr.w	sl, sl, #16
  40f3a0:	f01a 0f20 	tst.w	sl, #32
  40f3a4:	9004      	str	r0, [sp, #16]
  40f3a6:	46ac      	mov	ip, r5
  40f3a8:	f47f af75 	bne.w	40f296 <_vfiprintf_r+0x32a>
  40f3ac:	f01a 0f10 	tst.w	sl, #16
  40f3b0:	f040 82ec 	bne.w	40f98c <_vfiprintf_r+0xa20>
  40f3b4:	f01a 0f40 	tst.w	sl, #64	; 0x40
  40f3b8:	f000 82e8 	beq.w	40f98c <_vfiprintf_r+0xa20>
  40f3bc:	f8dd b020 	ldr.w	fp, [sp, #32]
  40f3c0:	f8bb 4000 	ldrh.w	r4, [fp]
  40f3c4:	f10b 0b04 	add.w	fp, fp, #4
  40f3c8:	2500      	movs	r5, #0
  40f3ca:	2301      	movs	r3, #1
  40f3cc:	f8cd b020 	str.w	fp, [sp, #32]
  40f3d0:	e6dd      	b.n	40f18e <_vfiprintf_r+0x222>
  40f3d2:	46ac      	mov	ip, r5
  40f3d4:	f01a 0f20 	tst.w	sl, #32
  40f3d8:	4d50      	ldr	r5, [pc, #320]	; (40f51c <_vfiprintf_r+0x5b0>)
  40f3da:	9004      	str	r0, [sp, #16]
  40f3dc:	f88d 1047 	strb.w	r1, [sp, #71]	; 0x47
  40f3e0:	950a      	str	r5, [sp, #40]	; 0x28
  40f3e2:	f000 80ee 	beq.w	40f5c2 <_vfiprintf_r+0x656>
  40f3e6:	9d08      	ldr	r5, [sp, #32]
  40f3e8:	1dea      	adds	r2, r5, #7
  40f3ea:	f022 0207 	bic.w	r2, r2, #7
  40f3ee:	e9d2 4500 	ldrd	r4, r5, [r2]
  40f3f2:	f102 0b08 	add.w	fp, r2, #8
  40f3f6:	f8cd b020 	str.w	fp, [sp, #32]
  40f3fa:	f01a 0f01 	tst.w	sl, #1
  40f3fe:	f000 82a8 	beq.w	40f952 <_vfiprintf_r+0x9e6>
  40f402:	ea54 0b05 	orrs.w	fp, r4, r5
  40f406:	f000 82a4 	beq.w	40f952 <_vfiprintf_r+0x9e6>
  40f40a:	2230      	movs	r2, #48	; 0x30
  40f40c:	f88d 3049 	strb.w	r3, [sp, #73]	; 0x49
  40f410:	f04a 0a02 	orr.w	sl, sl, #2
  40f414:	f88d 2048 	strb.w	r2, [sp, #72]	; 0x48
  40f418:	2302      	movs	r3, #2
  40f41a:	e6b8      	b.n	40f18e <_vfiprintf_r+0x222>
  40f41c:	9b08      	ldr	r3, [sp, #32]
  40f41e:	f8dd b020 	ldr.w	fp, [sp, #32]
  40f422:	681b      	ldr	r3, [r3, #0]
  40f424:	9004      	str	r0, [sp, #16]
  40f426:	2401      	movs	r4, #1
  40f428:	f04f 0500 	mov.w	r5, #0
  40f42c:	f10b 0b04 	add.w	fp, fp, #4
  40f430:	9403      	str	r4, [sp, #12]
  40f432:	f88d 5047 	strb.w	r5, [sp, #71]	; 0x47
  40f436:	f88d 3058 	strb.w	r3, [sp, #88]	; 0x58
  40f43a:	f8cd b020 	str.w	fp, [sp, #32]
  40f43e:	9405      	str	r4, [sp, #20]
  40f440:	af16      	add	r7, sp, #88	; 0x58
  40f442:	f04f 0c00 	mov.w	ip, #0
  40f446:	e6d2      	b.n	40f1ee <_vfiprintf_r+0x282>
  40f448:	f01a 0f20 	tst.w	sl, #32
  40f44c:	9004      	str	r0, [sp, #16]
  40f44e:	46ac      	mov	ip, r5
  40f450:	f88d 1047 	strb.w	r1, [sp, #71]	; 0x47
  40f454:	f47f af3a 	bne.w	40f2cc <_vfiprintf_r+0x360>
  40f458:	f01a 0f10 	tst.w	sl, #16
  40f45c:	f040 82a4 	bne.w	40f9a8 <_vfiprintf_r+0xa3c>
  40f460:	f01a 0f40 	tst.w	sl, #64	; 0x40
  40f464:	f000 82a0 	beq.w	40f9a8 <_vfiprintf_r+0xa3c>
  40f468:	f8dd b020 	ldr.w	fp, [sp, #32]
  40f46c:	f9bb 4000 	ldrsh.w	r4, [fp]
  40f470:	f10b 0b04 	add.w	fp, fp, #4
  40f474:	17e5      	asrs	r5, r4, #31
  40f476:	4622      	mov	r2, r4
  40f478:	462b      	mov	r3, r5
  40f47a:	f8cd b020 	str.w	fp, [sp, #32]
  40f47e:	e72f      	b.n	40f2e0 <_vfiprintf_r+0x374>
  40f480:	f04a 0a40 	orr.w	sl, sl, #64	; 0x40
  40f484:	f898 3000 	ldrb.w	r3, [r8]
  40f488:	e5dd      	b.n	40f046 <_vfiprintf_r+0xda>
  40f48a:	f898 3000 	ldrb.w	r3, [r8]
  40f48e:	4642      	mov	r2, r8
  40f490:	2b6c      	cmp	r3, #108	; 0x6c
  40f492:	bf03      	ittte	eq
  40f494:	f108 0801 	addeq.w	r8, r8, #1
  40f498:	f04a 0a20 	orreq.w	sl, sl, #32
  40f49c:	7853      	ldrbeq	r3, [r2, #1]
  40f49e:	f04a 0a10 	orrne.w	sl, sl, #16
  40f4a2:	e5d0      	b.n	40f046 <_vfiprintf_r+0xda>
  40f4a4:	f01a 0f20 	tst.w	sl, #32
  40f4a8:	f88d 1047 	strb.w	r1, [sp, #71]	; 0x47
  40f4ac:	f000 82f8 	beq.w	40faa0 <_vfiprintf_r+0xb34>
  40f4b0:	9c08      	ldr	r4, [sp, #32]
  40f4b2:	6821      	ldr	r1, [r4, #0]
  40f4b4:	9c09      	ldr	r4, [sp, #36]	; 0x24
  40f4b6:	17e5      	asrs	r5, r4, #31
  40f4b8:	462b      	mov	r3, r5
  40f4ba:	9d08      	ldr	r5, [sp, #32]
  40f4bc:	4622      	mov	r2, r4
  40f4be:	3504      	adds	r5, #4
  40f4c0:	9508      	str	r5, [sp, #32]
  40f4c2:	e9c1 2300 	strd	r2, r3, [r1]
  40f4c6:	e584      	b.n	40efd2 <_vfiprintf_r+0x66>
  40f4c8:	9c08      	ldr	r4, [sp, #32]
  40f4ca:	9004      	str	r0, [sp, #16]
  40f4cc:	6827      	ldr	r7, [r4, #0]
  40f4ce:	46ac      	mov	ip, r5
  40f4d0:	f04f 0500 	mov.w	r5, #0
  40f4d4:	f88d 5047 	strb.w	r5, [sp, #71]	; 0x47
  40f4d8:	3404      	adds	r4, #4
  40f4da:	2f00      	cmp	r7, #0
  40f4dc:	f000 8334 	beq.w	40fb48 <_vfiprintf_r+0xbdc>
  40f4e0:	f1bc 0f00 	cmp.w	ip, #0
  40f4e4:	4638      	mov	r0, r7
  40f4e6:	f2c0 8308 	blt.w	40fafa <_vfiprintf_r+0xb8e>
  40f4ea:	4662      	mov	r2, ip
  40f4ec:	2100      	movs	r1, #0
  40f4ee:	f8cd c004 	str.w	ip, [sp, #4]
  40f4f2:	f002 f959 	bl	4117a8 <memchr>
  40f4f6:	f8dd c004 	ldr.w	ip, [sp, #4]
  40f4fa:	2800      	cmp	r0, #0
  40f4fc:	f000 833c 	beq.w	40fb78 <_vfiprintf_r+0xc0c>
  40f500:	1bc0      	subs	r0, r0, r7
  40f502:	4560      	cmp	r0, ip
  40f504:	bfa8      	it	ge
  40f506:	4660      	movge	r0, ip
  40f508:	f89d 5047 	ldrb.w	r5, [sp, #71]	; 0x47
  40f50c:	9005      	str	r0, [sp, #20]
  40f50e:	9408      	str	r4, [sp, #32]
  40f510:	9507      	str	r5, [sp, #28]
  40f512:	f04f 0c00 	mov.w	ip, #0
  40f516:	e65d      	b.n	40f1d4 <_vfiprintf_r+0x268>
  40f518:	00416ee0 	.word	0x00416ee0
  40f51c:	00416e60 	.word	0x00416e60
  40f520:	9a08      	ldr	r2, [sp, #32]
  40f522:	9004      	str	r0, [sp, #16]
  40f524:	2330      	movs	r3, #48	; 0x30
  40f526:	f88d 3048 	strb.w	r3, [sp, #72]	; 0x48
  40f52a:	f102 0b04 	add.w	fp, r2, #4
  40f52e:	2378      	movs	r3, #120	; 0x78
  40f530:	48af      	ldr	r0, [pc, #700]	; (40f7f0 <_vfiprintf_r+0x884>)
  40f532:	f88d 3049 	strb.w	r3, [sp, #73]	; 0x49
  40f536:	46ac      	mov	ip, r5
  40f538:	6814      	ldr	r4, [r2, #0]
  40f53a:	f8cd b020 	str.w	fp, [sp, #32]
  40f53e:	f04a 0a02 	orr.w	sl, sl, #2
  40f542:	2500      	movs	r5, #0
  40f544:	900a      	str	r0, [sp, #40]	; 0x28
  40f546:	2302      	movs	r3, #2
  40f548:	e621      	b.n	40f18e <_vfiprintf_r+0x222>
  40f54a:	f04a 0a20 	orr.w	sl, sl, #32
  40f54e:	f898 3000 	ldrb.w	r3, [r8]
  40f552:	e578      	b.n	40f046 <_vfiprintf_r+0xda>
  40f554:	f8dd b020 	ldr.w	fp, [sp, #32]
  40f558:	f8db 0000 	ldr.w	r0, [fp]
  40f55c:	2800      	cmp	r0, #0
  40f55e:	f10b 0304 	add.w	r3, fp, #4
  40f562:	f6ff adfb 	blt.w	40f15c <_vfiprintf_r+0x1f0>
  40f566:	9308      	str	r3, [sp, #32]
  40f568:	f898 3000 	ldrb.w	r3, [r8]
  40f56c:	e56b      	b.n	40f046 <_vfiprintf_r+0xda>
  40f56e:	f898 3000 	ldrb.w	r3, [r8]
  40f572:	212b      	movs	r1, #43	; 0x2b
  40f574:	e567      	b.n	40f046 <_vfiprintf_r+0xda>
  40f576:	f898 3000 	ldrb.w	r3, [r8]
  40f57a:	2b2a      	cmp	r3, #42	; 0x2a
  40f57c:	f108 0401 	add.w	r4, r8, #1
  40f580:	f000 8309 	beq.w	40fb96 <_vfiprintf_r+0xc2a>
  40f584:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
  40f588:	2a09      	cmp	r2, #9
  40f58a:	bf98      	it	ls
  40f58c:	2500      	movls	r5, #0
  40f58e:	f200 82fe 	bhi.w	40fb8e <_vfiprintf_r+0xc22>
  40f592:	f814 3b01 	ldrb.w	r3, [r4], #1
  40f596:	eb05 0585 	add.w	r5, r5, r5, lsl #2
  40f59a:	eb02 0545 	add.w	r5, r2, r5, lsl #1
  40f59e:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
  40f5a2:	2a09      	cmp	r2, #9
  40f5a4:	d9f5      	bls.n	40f592 <_vfiprintf_r+0x626>
  40f5a6:	ea45 75e5 	orr.w	r5, r5, r5, asr #31
  40f5aa:	46a0      	mov	r8, r4
  40f5ac:	e54d      	b.n	40f04a <_vfiprintf_r+0xde>
  40f5ae:	4c90      	ldr	r4, [pc, #576]	; (40f7f0 <_vfiprintf_r+0x884>)
  40f5b0:	9004      	str	r0, [sp, #16]
  40f5b2:	f01a 0f20 	tst.w	sl, #32
  40f5b6:	46ac      	mov	ip, r5
  40f5b8:	940a      	str	r4, [sp, #40]	; 0x28
  40f5ba:	f88d 1047 	strb.w	r1, [sp, #71]	; 0x47
  40f5be:	f47f af12 	bne.w	40f3e6 <_vfiprintf_r+0x47a>
  40f5c2:	f01a 0f10 	tst.w	sl, #16
  40f5c6:	f040 81e9 	bne.w	40f99c <_vfiprintf_r+0xa30>
  40f5ca:	f01a 0f40 	tst.w	sl, #64	; 0x40
  40f5ce:	f000 81e5 	beq.w	40f99c <_vfiprintf_r+0xa30>
  40f5d2:	f8dd b020 	ldr.w	fp, [sp, #32]
  40f5d6:	f8bb 4000 	ldrh.w	r4, [fp]
  40f5da:	f10b 0b04 	add.w	fp, fp, #4
  40f5de:	2500      	movs	r5, #0
  40f5e0:	f8cd b020 	str.w	fp, [sp, #32]
  40f5e4:	e709      	b.n	40f3fa <_vfiprintf_r+0x48e>
  40f5e6:	f898 3000 	ldrb.w	r3, [r8]
  40f5ea:	2900      	cmp	r1, #0
  40f5ec:	f47f ad2b 	bne.w	40f046 <_vfiprintf_r+0xda>
  40f5f0:	2120      	movs	r1, #32
  40f5f2:	e528      	b.n	40f046 <_vfiprintf_r+0xda>
  40f5f4:	f04a 0a01 	orr.w	sl, sl, #1
  40f5f8:	f898 3000 	ldrb.w	r3, [r8]
  40f5fc:	e523      	b.n	40f046 <_vfiprintf_r+0xda>
  40f5fe:	9004      	str	r0, [sp, #16]
  40f600:	f88d 1047 	strb.w	r1, [sp, #71]	; 0x47
  40f604:	2b00      	cmp	r3, #0
  40f606:	f000 80f9 	beq.w	40f7fc <_vfiprintf_r+0x890>
  40f60a:	2501      	movs	r5, #1
  40f60c:	f04f 0b00 	mov.w	fp, #0
  40f610:	9503      	str	r5, [sp, #12]
  40f612:	f88d 3058 	strb.w	r3, [sp, #88]	; 0x58
  40f616:	f88d b047 	strb.w	fp, [sp, #71]	; 0x47
  40f61a:	9505      	str	r5, [sp, #20]
  40f61c:	af16      	add	r7, sp, #88	; 0x58
  40f61e:	e710      	b.n	40f442 <_vfiprintf_r+0x4d6>
  40f620:	9806      	ldr	r0, [sp, #24]
  40f622:	9902      	ldr	r1, [sp, #8]
  40f624:	aa13      	add	r2, sp, #76	; 0x4c
  40f626:	f7ff fc65 	bl	40eef4 <__sprint_r.part.0>
  40f62a:	2800      	cmp	r0, #0
  40f62c:	f040 80ed 	bne.w	40f80a <_vfiprintf_r+0x89e>
  40f630:	9814      	ldr	r0, [sp, #80]	; 0x50
  40f632:	9a15      	ldr	r2, [sp, #84]	; 0x54
  40f634:	1c43      	adds	r3, r0, #1
  40f636:	46cc      	mov	ip, r9
  40f638:	e602      	b.n	40f240 <_vfiprintf_r+0x2d4>
  40f63a:	9b14      	ldr	r3, [sp, #80]	; 0x50
  40f63c:	9a15      	ldr	r2, [sp, #84]	; 0x54
  40f63e:	1c59      	adds	r1, r3, #1
  40f640:	f89d 0047 	ldrb.w	r0, [sp, #71]	; 0x47
  40f644:	b168      	cbz	r0, 40f662 <_vfiprintf_r+0x6f6>
  40f646:	3201      	adds	r2, #1
  40f648:	f10d 0047 	add.w	r0, sp, #71	; 0x47
  40f64c:	2301      	movs	r3, #1
  40f64e:	2907      	cmp	r1, #7
  40f650:	9215      	str	r2, [sp, #84]	; 0x54
  40f652:	9114      	str	r1, [sp, #80]	; 0x50
  40f654:	e886 0009 	stmia.w	r6, {r0, r3}
  40f658:	f300 8160 	bgt.w	40f91c <_vfiprintf_r+0x9b0>
  40f65c:	460b      	mov	r3, r1
  40f65e:	3608      	adds	r6, #8
  40f660:	3101      	adds	r1, #1
  40f662:	9c07      	ldr	r4, [sp, #28]
  40f664:	b164      	cbz	r4, 40f680 <_vfiprintf_r+0x714>
  40f666:	3202      	adds	r2, #2
  40f668:	a812      	add	r0, sp, #72	; 0x48
  40f66a:	2302      	movs	r3, #2
  40f66c:	2907      	cmp	r1, #7
  40f66e:	9215      	str	r2, [sp, #84]	; 0x54
  40f670:	9114      	str	r1, [sp, #80]	; 0x50
  40f672:	e886 0009 	stmia.w	r6, {r0, r3}
  40f676:	f300 8157 	bgt.w	40f928 <_vfiprintf_r+0x9bc>
  40f67a:	460b      	mov	r3, r1
  40f67c:	3608      	adds	r6, #8
  40f67e:	3101      	adds	r1, #1
  40f680:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
  40f682:	2d80      	cmp	r5, #128	; 0x80
  40f684:	f000 8101 	beq.w	40f88a <_vfiprintf_r+0x91e>
  40f688:	9d05      	ldr	r5, [sp, #20]
  40f68a:	ebc5 040c 	rsb	r4, r5, ip
  40f68e:	2c00      	cmp	r4, #0
  40f690:	dd2f      	ble.n	40f6f2 <_vfiprintf_r+0x786>
  40f692:	2c10      	cmp	r4, #16
  40f694:	4d57      	ldr	r5, [pc, #348]	; (40f7f4 <_vfiprintf_r+0x888>)
  40f696:	dd22      	ble.n	40f6de <_vfiprintf_r+0x772>
  40f698:	4630      	mov	r0, r6
  40f69a:	f04f 0b10 	mov.w	fp, #16
  40f69e:	462e      	mov	r6, r5
  40f6a0:	4625      	mov	r5, r4
  40f6a2:	9c06      	ldr	r4, [sp, #24]
  40f6a4:	e006      	b.n	40f6b4 <_vfiprintf_r+0x748>
  40f6a6:	f103 0c02 	add.w	ip, r3, #2
  40f6aa:	3008      	adds	r0, #8
  40f6ac:	460b      	mov	r3, r1
  40f6ae:	3d10      	subs	r5, #16
  40f6b0:	2d10      	cmp	r5, #16
  40f6b2:	dd10      	ble.n	40f6d6 <_vfiprintf_r+0x76a>
  40f6b4:	1c59      	adds	r1, r3, #1
  40f6b6:	3210      	adds	r2, #16
  40f6b8:	2907      	cmp	r1, #7
  40f6ba:	9215      	str	r2, [sp, #84]	; 0x54
  40f6bc:	e880 0840 	stmia.w	r0, {r6, fp}
  40f6c0:	9114      	str	r1, [sp, #80]	; 0x50
  40f6c2:	ddf0      	ble.n	40f6a6 <_vfiprintf_r+0x73a>
  40f6c4:	2a00      	cmp	r2, #0
  40f6c6:	d163      	bne.n	40f790 <_vfiprintf_r+0x824>
  40f6c8:	3d10      	subs	r5, #16
  40f6ca:	2d10      	cmp	r5, #16
  40f6cc:	f04f 0c01 	mov.w	ip, #1
  40f6d0:	4613      	mov	r3, r2
  40f6d2:	4648      	mov	r0, r9
  40f6d4:	dcee      	bgt.n	40f6b4 <_vfiprintf_r+0x748>
  40f6d6:	462c      	mov	r4, r5
  40f6d8:	4661      	mov	r1, ip
  40f6da:	4635      	mov	r5, r6
  40f6dc:	4606      	mov	r6, r0
  40f6de:	4422      	add	r2, r4
  40f6e0:	2907      	cmp	r1, #7
  40f6e2:	9215      	str	r2, [sp, #84]	; 0x54
  40f6e4:	6035      	str	r5, [r6, #0]
  40f6e6:	6074      	str	r4, [r6, #4]
  40f6e8:	9114      	str	r1, [sp, #80]	; 0x50
  40f6ea:	f300 80c1 	bgt.w	40f870 <_vfiprintf_r+0x904>
  40f6ee:	3608      	adds	r6, #8
  40f6f0:	3101      	adds	r1, #1
  40f6f2:	9d05      	ldr	r5, [sp, #20]
  40f6f4:	6037      	str	r7, [r6, #0]
  40f6f6:	442a      	add	r2, r5
  40f6f8:	2907      	cmp	r1, #7
  40f6fa:	9215      	str	r2, [sp, #84]	; 0x54
  40f6fc:	6075      	str	r5, [r6, #4]
  40f6fe:	9114      	str	r1, [sp, #80]	; 0x50
  40f700:	f340 80c1 	ble.w	40f886 <_vfiprintf_r+0x91a>
  40f704:	2a00      	cmp	r2, #0
  40f706:	f040 8130 	bne.w	40f96a <_vfiprintf_r+0x9fe>
  40f70a:	9214      	str	r2, [sp, #80]	; 0x50
  40f70c:	464e      	mov	r6, r9
  40f70e:	f01a 0f04 	tst.w	sl, #4
  40f712:	f000 808b 	beq.w	40f82c <_vfiprintf_r+0x8c0>
  40f716:	9d04      	ldr	r5, [sp, #16]
  40f718:	f8dd b00c 	ldr.w	fp, [sp, #12]
  40f71c:	ebcb 0405 	rsb	r4, fp, r5
  40f720:	2c00      	cmp	r4, #0
  40f722:	f340 8083 	ble.w	40f82c <_vfiprintf_r+0x8c0>
  40f726:	2c10      	cmp	r4, #16
  40f728:	f340 8222 	ble.w	40fb70 <_vfiprintf_r+0xc04>
  40f72c:	9914      	ldr	r1, [sp, #80]	; 0x50
  40f72e:	4d32      	ldr	r5, [pc, #200]	; (40f7f8 <_vfiprintf_r+0x88c>)
  40f730:	f8dd a018 	ldr.w	sl, [sp, #24]
  40f734:	f8dd b008 	ldr.w	fp, [sp, #8]
  40f738:	2710      	movs	r7, #16
  40f73a:	e005      	b.n	40f748 <_vfiprintf_r+0x7dc>
  40f73c:	1c88      	adds	r0, r1, #2
  40f73e:	3608      	adds	r6, #8
  40f740:	4619      	mov	r1, r3
  40f742:	3c10      	subs	r4, #16
  40f744:	2c10      	cmp	r4, #16
  40f746:	dd10      	ble.n	40f76a <_vfiprintf_r+0x7fe>
  40f748:	1c4b      	adds	r3, r1, #1
  40f74a:	3210      	adds	r2, #16
  40f74c:	2b07      	cmp	r3, #7
  40f74e:	9215      	str	r2, [sp, #84]	; 0x54
  40f750:	e886 00a0 	stmia.w	r6, {r5, r7}
  40f754:	9314      	str	r3, [sp, #80]	; 0x50
  40f756:	ddf1      	ble.n	40f73c <_vfiprintf_r+0x7d0>
  40f758:	2a00      	cmp	r2, #0
  40f75a:	d17d      	bne.n	40f858 <_vfiprintf_r+0x8ec>
  40f75c:	3c10      	subs	r4, #16
  40f75e:	2c10      	cmp	r4, #16
  40f760:	f04f 0001 	mov.w	r0, #1
  40f764:	4611      	mov	r1, r2
  40f766:	464e      	mov	r6, r9
  40f768:	dcee      	bgt.n	40f748 <_vfiprintf_r+0x7dc>
  40f76a:	4422      	add	r2, r4
  40f76c:	2807      	cmp	r0, #7
  40f76e:	9215      	str	r2, [sp, #84]	; 0x54
  40f770:	6035      	str	r5, [r6, #0]
  40f772:	6074      	str	r4, [r6, #4]
  40f774:	9014      	str	r0, [sp, #80]	; 0x50
  40f776:	dd59      	ble.n	40f82c <_vfiprintf_r+0x8c0>
  40f778:	2a00      	cmp	r2, #0
  40f77a:	d14f      	bne.n	40f81c <_vfiprintf_r+0x8b0>
  40f77c:	9c09      	ldr	r4, [sp, #36]	; 0x24
  40f77e:	f8dd b00c 	ldr.w	fp, [sp, #12]
  40f782:	9d04      	ldr	r5, [sp, #16]
  40f784:	45ab      	cmp	fp, r5
  40f786:	bfac      	ite	ge
  40f788:	445c      	addge	r4, fp
  40f78a:	1964      	addlt	r4, r4, r5
  40f78c:	9409      	str	r4, [sp, #36]	; 0x24
  40f78e:	e05e      	b.n	40f84e <_vfiprintf_r+0x8e2>
  40f790:	4620      	mov	r0, r4
  40f792:	9902      	ldr	r1, [sp, #8]
  40f794:	aa13      	add	r2, sp, #76	; 0x4c
  40f796:	f7ff fbad 	bl	40eef4 <__sprint_r.part.0>
  40f79a:	2800      	cmp	r0, #0
  40f79c:	d135      	bne.n	40f80a <_vfiprintf_r+0x89e>
  40f79e:	9b14      	ldr	r3, [sp, #80]	; 0x50
  40f7a0:	9a15      	ldr	r2, [sp, #84]	; 0x54
  40f7a2:	f103 0c01 	add.w	ip, r3, #1
  40f7a6:	4648      	mov	r0, r9
  40f7a8:	e781      	b.n	40f6ae <_vfiprintf_r+0x742>
  40f7aa:	08e0      	lsrs	r0, r4, #3
  40f7ac:	ea40 7045 	orr.w	r0, r0, r5, lsl #29
  40f7b0:	f004 0207 	and.w	r2, r4, #7
  40f7b4:	08e9      	lsrs	r1, r5, #3
  40f7b6:	3230      	adds	r2, #48	; 0x30
  40f7b8:	ea50 0b01 	orrs.w	fp, r0, r1
  40f7bc:	461f      	mov	r7, r3
  40f7be:	701a      	strb	r2, [r3, #0]
  40f7c0:	4604      	mov	r4, r0
  40f7c2:	460d      	mov	r5, r1
  40f7c4:	f103 33ff 	add.w	r3, r3, #4294967295
  40f7c8:	d1ef      	bne.n	40f7aa <_vfiprintf_r+0x83e>
  40f7ca:	f01a 0f01 	tst.w	sl, #1
  40f7ce:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
  40f7d2:	4639      	mov	r1, r7
  40f7d4:	f000 80b9 	beq.w	40f94a <_vfiprintf_r+0x9de>
  40f7d8:	2a30      	cmp	r2, #48	; 0x30
  40f7da:	f43f acf8 	beq.w	40f1ce <_vfiprintf_r+0x262>
  40f7de:	461f      	mov	r7, r3
  40f7e0:	ebc7 0509 	rsb	r5, r7, r9
  40f7e4:	2330      	movs	r3, #48	; 0x30
  40f7e6:	9505      	str	r5, [sp, #20]
  40f7e8:	f801 3c01 	strb.w	r3, [r1, #-1]
  40f7ec:	e4f2      	b.n	40f1d4 <_vfiprintf_r+0x268>
  40f7ee:	bf00      	nop
  40f7f0:	00416e74 	.word	0x00416e74
  40f7f4:	00416ed0 	.word	0x00416ed0
  40f7f8:	00416ee0 	.word	0x00416ee0
  40f7fc:	9b15      	ldr	r3, [sp, #84]	; 0x54
  40f7fe:	b123      	cbz	r3, 40f80a <_vfiprintf_r+0x89e>
  40f800:	9806      	ldr	r0, [sp, #24]
  40f802:	9902      	ldr	r1, [sp, #8]
  40f804:	aa13      	add	r2, sp, #76	; 0x4c
  40f806:	f7ff fb75 	bl	40eef4 <__sprint_r.part.0>
  40f80a:	9c02      	ldr	r4, [sp, #8]
  40f80c:	89a3      	ldrh	r3, [r4, #12]
  40f80e:	065b      	lsls	r3, r3, #25
  40f810:	f53f ac9c 	bmi.w	40f14c <_vfiprintf_r+0x1e0>
  40f814:	9809      	ldr	r0, [sp, #36]	; 0x24
  40f816:	b031      	add	sp, #196	; 0xc4
  40f818:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40f81c:	9806      	ldr	r0, [sp, #24]
  40f81e:	9902      	ldr	r1, [sp, #8]
  40f820:	aa13      	add	r2, sp, #76	; 0x4c
  40f822:	f7ff fb67 	bl	40eef4 <__sprint_r.part.0>
  40f826:	2800      	cmp	r0, #0
  40f828:	d1ef      	bne.n	40f80a <_vfiprintf_r+0x89e>
  40f82a:	9a15      	ldr	r2, [sp, #84]	; 0x54
  40f82c:	9c09      	ldr	r4, [sp, #36]	; 0x24
  40f82e:	f8dd b00c 	ldr.w	fp, [sp, #12]
  40f832:	9d04      	ldr	r5, [sp, #16]
  40f834:	45ab      	cmp	fp, r5
  40f836:	bfac      	ite	ge
  40f838:	445c      	addge	r4, fp
  40f83a:	1964      	addlt	r4, r4, r5
  40f83c:	9409      	str	r4, [sp, #36]	; 0x24
  40f83e:	b132      	cbz	r2, 40f84e <_vfiprintf_r+0x8e2>
  40f840:	9806      	ldr	r0, [sp, #24]
  40f842:	9902      	ldr	r1, [sp, #8]
  40f844:	aa13      	add	r2, sp, #76	; 0x4c
  40f846:	f7ff fb55 	bl	40eef4 <__sprint_r.part.0>
  40f84a:	2800      	cmp	r0, #0
  40f84c:	d1dd      	bne.n	40f80a <_vfiprintf_r+0x89e>
  40f84e:	2000      	movs	r0, #0
  40f850:	9014      	str	r0, [sp, #80]	; 0x50
  40f852:	464e      	mov	r6, r9
  40f854:	f7ff bbbd 	b.w	40efd2 <_vfiprintf_r+0x66>
  40f858:	4650      	mov	r0, sl
  40f85a:	4659      	mov	r1, fp
  40f85c:	aa13      	add	r2, sp, #76	; 0x4c
  40f85e:	f7ff fb49 	bl	40eef4 <__sprint_r.part.0>
  40f862:	2800      	cmp	r0, #0
  40f864:	d1d1      	bne.n	40f80a <_vfiprintf_r+0x89e>
  40f866:	9914      	ldr	r1, [sp, #80]	; 0x50
  40f868:	9a15      	ldr	r2, [sp, #84]	; 0x54
  40f86a:	1c48      	adds	r0, r1, #1
  40f86c:	464e      	mov	r6, r9
  40f86e:	e768      	b.n	40f742 <_vfiprintf_r+0x7d6>
  40f870:	2a00      	cmp	r2, #0
  40f872:	f040 80fa 	bne.w	40fa6a <_vfiprintf_r+0xafe>
  40f876:	9c05      	ldr	r4, [sp, #20]
  40f878:	9720      	str	r7, [sp, #128]	; 0x80
  40f87a:	2301      	movs	r3, #1
  40f87c:	9421      	str	r4, [sp, #132]	; 0x84
  40f87e:	9415      	str	r4, [sp, #84]	; 0x54
  40f880:	4622      	mov	r2, r4
  40f882:	9314      	str	r3, [sp, #80]	; 0x50
  40f884:	464e      	mov	r6, r9
  40f886:	3608      	adds	r6, #8
  40f888:	e741      	b.n	40f70e <_vfiprintf_r+0x7a2>
  40f88a:	9d04      	ldr	r5, [sp, #16]
  40f88c:	f8dd b00c 	ldr.w	fp, [sp, #12]
  40f890:	ebcb 0405 	rsb	r4, fp, r5
  40f894:	2c00      	cmp	r4, #0
  40f896:	f77f aef7 	ble.w	40f688 <_vfiprintf_r+0x71c>
  40f89a:	2c10      	cmp	r4, #16
  40f89c:	4da8      	ldr	r5, [pc, #672]	; (40fb40 <_vfiprintf_r+0xbd4>)
  40f89e:	f340 8174 	ble.w	40fb8a <_vfiprintf_r+0xc1e>
  40f8a2:	4629      	mov	r1, r5
  40f8a4:	f04f 0b10 	mov.w	fp, #16
  40f8a8:	4625      	mov	r5, r4
  40f8aa:	4664      	mov	r4, ip
  40f8ac:	46b4      	mov	ip, r6
  40f8ae:	460e      	mov	r6, r1
  40f8b0:	e006      	b.n	40f8c0 <_vfiprintf_r+0x954>
  40f8b2:	1c98      	adds	r0, r3, #2
  40f8b4:	f10c 0c08 	add.w	ip, ip, #8
  40f8b8:	460b      	mov	r3, r1
  40f8ba:	3d10      	subs	r5, #16
  40f8bc:	2d10      	cmp	r5, #16
  40f8be:	dd0f      	ble.n	40f8e0 <_vfiprintf_r+0x974>
  40f8c0:	1c59      	adds	r1, r3, #1
  40f8c2:	3210      	adds	r2, #16
  40f8c4:	2907      	cmp	r1, #7
  40f8c6:	9215      	str	r2, [sp, #84]	; 0x54
  40f8c8:	e88c 0840 	stmia.w	ip, {r6, fp}
  40f8cc:	9114      	str	r1, [sp, #80]	; 0x50
  40f8ce:	ddf0      	ble.n	40f8b2 <_vfiprintf_r+0x946>
  40f8d0:	b9ba      	cbnz	r2, 40f902 <_vfiprintf_r+0x996>
  40f8d2:	3d10      	subs	r5, #16
  40f8d4:	2d10      	cmp	r5, #16
  40f8d6:	f04f 0001 	mov.w	r0, #1
  40f8da:	4613      	mov	r3, r2
  40f8dc:	46cc      	mov	ip, r9
  40f8de:	dcef      	bgt.n	40f8c0 <_vfiprintf_r+0x954>
  40f8e0:	4633      	mov	r3, r6
  40f8e2:	4666      	mov	r6, ip
  40f8e4:	46a4      	mov	ip, r4
  40f8e6:	462c      	mov	r4, r5
  40f8e8:	461d      	mov	r5, r3
  40f8ea:	4422      	add	r2, r4
  40f8ec:	2807      	cmp	r0, #7
  40f8ee:	9215      	str	r2, [sp, #84]	; 0x54
  40f8f0:	6035      	str	r5, [r6, #0]
  40f8f2:	6074      	str	r4, [r6, #4]
  40f8f4:	9014      	str	r0, [sp, #80]	; 0x50
  40f8f6:	f300 80b2 	bgt.w	40fa5e <_vfiprintf_r+0xaf2>
  40f8fa:	3608      	adds	r6, #8
  40f8fc:	1c41      	adds	r1, r0, #1
  40f8fe:	4603      	mov	r3, r0
  40f900:	e6c2      	b.n	40f688 <_vfiprintf_r+0x71c>
  40f902:	9806      	ldr	r0, [sp, #24]
  40f904:	9902      	ldr	r1, [sp, #8]
  40f906:	aa13      	add	r2, sp, #76	; 0x4c
  40f908:	f7ff faf4 	bl	40eef4 <__sprint_r.part.0>
  40f90c:	2800      	cmp	r0, #0
  40f90e:	f47f af7c 	bne.w	40f80a <_vfiprintf_r+0x89e>
  40f912:	9b14      	ldr	r3, [sp, #80]	; 0x50
  40f914:	9a15      	ldr	r2, [sp, #84]	; 0x54
  40f916:	1c58      	adds	r0, r3, #1
  40f918:	46cc      	mov	ip, r9
  40f91a:	e7ce      	b.n	40f8ba <_vfiprintf_r+0x94e>
  40f91c:	2a00      	cmp	r2, #0
  40f91e:	d17c      	bne.n	40fa1a <_vfiprintf_r+0xaae>
  40f920:	4619      	mov	r1, r3
  40f922:	464e      	mov	r6, r9
  40f924:	4613      	mov	r3, r2
  40f926:	e69c      	b.n	40f662 <_vfiprintf_r+0x6f6>
  40f928:	2a00      	cmp	r2, #0
  40f92a:	f040 8087 	bne.w	40fa3c <_vfiprintf_r+0xad0>
  40f92e:	2101      	movs	r1, #1
  40f930:	4613      	mov	r3, r2
  40f932:	464e      	mov	r6, r9
  40f934:	e6a4      	b.n	40f680 <_vfiprintf_r+0x714>
  40f936:	464f      	mov	r7, r9
  40f938:	e44c      	b.n	40f1d4 <_vfiprintf_r+0x268>
  40f93a:	2d00      	cmp	r5, #0
  40f93c:	bf08      	it	eq
  40f93e:	2c0a      	cmpeq	r4, #10
  40f940:	d249      	bcs.n	40f9d6 <_vfiprintf_r+0xa6a>
  40f942:	af30      	add	r7, sp, #192	; 0xc0
  40f944:	3430      	adds	r4, #48	; 0x30
  40f946:	f807 4d41 	strb.w	r4, [r7, #-65]!
  40f94a:	ebc7 0309 	rsb	r3, r7, r9
  40f94e:	9305      	str	r3, [sp, #20]
  40f950:	e440      	b.n	40f1d4 <_vfiprintf_r+0x268>
  40f952:	2302      	movs	r3, #2
  40f954:	e41b      	b.n	40f18e <_vfiprintf_r+0x222>
  40f956:	2a00      	cmp	r2, #0
  40f958:	f040 80b2 	bne.w	40fac0 <_vfiprintf_r+0xb54>
  40f95c:	4613      	mov	r3, r2
  40f95e:	2101      	movs	r1, #1
  40f960:	464e      	mov	r6, r9
  40f962:	e66d      	b.n	40f640 <_vfiprintf_r+0x6d4>
  40f964:	4644      	mov	r4, r8
  40f966:	f7ff bb5c 	b.w	40f022 <_vfiprintf_r+0xb6>
  40f96a:	9806      	ldr	r0, [sp, #24]
  40f96c:	9902      	ldr	r1, [sp, #8]
  40f96e:	aa13      	add	r2, sp, #76	; 0x4c
  40f970:	f7ff fac0 	bl	40eef4 <__sprint_r.part.0>
  40f974:	2800      	cmp	r0, #0
  40f976:	f47f af48 	bne.w	40f80a <_vfiprintf_r+0x89e>
  40f97a:	9a15      	ldr	r2, [sp, #84]	; 0x54
  40f97c:	464e      	mov	r6, r9
  40f97e:	e6c6      	b.n	40f70e <_vfiprintf_r+0x7a2>
  40f980:	9d08      	ldr	r5, [sp, #32]
  40f982:	682c      	ldr	r4, [r5, #0]
  40f984:	3504      	adds	r5, #4
  40f986:	9508      	str	r5, [sp, #32]
  40f988:	2500      	movs	r5, #0
  40f98a:	e400      	b.n	40f18e <_vfiprintf_r+0x222>
  40f98c:	9d08      	ldr	r5, [sp, #32]
  40f98e:	682c      	ldr	r4, [r5, #0]
  40f990:	3504      	adds	r5, #4
  40f992:	9508      	str	r5, [sp, #32]
  40f994:	2301      	movs	r3, #1
  40f996:	2500      	movs	r5, #0
  40f998:	f7ff bbf9 	b.w	40f18e <_vfiprintf_r+0x222>
  40f99c:	9d08      	ldr	r5, [sp, #32]
  40f99e:	682c      	ldr	r4, [r5, #0]
  40f9a0:	3504      	adds	r5, #4
  40f9a2:	9508      	str	r5, [sp, #32]
  40f9a4:	2500      	movs	r5, #0
  40f9a6:	e528      	b.n	40f3fa <_vfiprintf_r+0x48e>
  40f9a8:	9d08      	ldr	r5, [sp, #32]
  40f9aa:	f8dd b020 	ldr.w	fp, [sp, #32]
  40f9ae:	682c      	ldr	r4, [r5, #0]
  40f9b0:	f10b 0b04 	add.w	fp, fp, #4
  40f9b4:	17e5      	asrs	r5, r4, #31
  40f9b6:	f8cd b020 	str.w	fp, [sp, #32]
  40f9ba:	4622      	mov	r2, r4
  40f9bc:	462b      	mov	r3, r5
  40f9be:	e48f      	b.n	40f2e0 <_vfiprintf_r+0x374>
  40f9c0:	9806      	ldr	r0, [sp, #24]
  40f9c2:	9902      	ldr	r1, [sp, #8]
  40f9c4:	aa13      	add	r2, sp, #76	; 0x4c
  40f9c6:	f7ff fa95 	bl	40eef4 <__sprint_r.part.0>
  40f9ca:	2800      	cmp	r0, #0
  40f9cc:	f47f af1d 	bne.w	40f80a <_vfiprintf_r+0x89e>
  40f9d0:	464e      	mov	r6, r9
  40f9d2:	f7ff bb9b 	b.w	40f10c <_vfiprintf_r+0x1a0>
  40f9d6:	f10d 0b7f 	add.w	fp, sp, #127	; 0x7f
  40f9da:	9603      	str	r6, [sp, #12]
  40f9dc:	465e      	mov	r6, fp
  40f9de:	46e3      	mov	fp, ip
  40f9e0:	4620      	mov	r0, r4
  40f9e2:	4629      	mov	r1, r5
  40f9e4:	220a      	movs	r2, #10
  40f9e6:	2300      	movs	r3, #0
  40f9e8:	f7fb fde0 	bl	40b5ac <__aeabi_uldivmod>
  40f9ec:	3230      	adds	r2, #48	; 0x30
  40f9ee:	7032      	strb	r2, [r6, #0]
  40f9f0:	4620      	mov	r0, r4
  40f9f2:	4629      	mov	r1, r5
  40f9f4:	220a      	movs	r2, #10
  40f9f6:	2300      	movs	r3, #0
  40f9f8:	f7fb fdd8 	bl	40b5ac <__aeabi_uldivmod>
  40f9fc:	4604      	mov	r4, r0
  40f9fe:	460d      	mov	r5, r1
  40fa00:	ea54 0005 	orrs.w	r0, r4, r5
  40fa04:	4637      	mov	r7, r6
  40fa06:	f106 36ff 	add.w	r6, r6, #4294967295
  40fa0a:	d1e9      	bne.n	40f9e0 <_vfiprintf_r+0xa74>
  40fa0c:	ebc7 0309 	rsb	r3, r7, r9
  40fa10:	46dc      	mov	ip, fp
  40fa12:	9e03      	ldr	r6, [sp, #12]
  40fa14:	9305      	str	r3, [sp, #20]
  40fa16:	f7ff bbdd 	b.w	40f1d4 <_vfiprintf_r+0x268>
  40fa1a:	9806      	ldr	r0, [sp, #24]
  40fa1c:	9902      	ldr	r1, [sp, #8]
  40fa1e:	f8cd c004 	str.w	ip, [sp, #4]
  40fa22:	aa13      	add	r2, sp, #76	; 0x4c
  40fa24:	f7ff fa66 	bl	40eef4 <__sprint_r.part.0>
  40fa28:	f8dd c004 	ldr.w	ip, [sp, #4]
  40fa2c:	2800      	cmp	r0, #0
  40fa2e:	f47f aeec 	bne.w	40f80a <_vfiprintf_r+0x89e>
  40fa32:	9b14      	ldr	r3, [sp, #80]	; 0x50
  40fa34:	9a15      	ldr	r2, [sp, #84]	; 0x54
  40fa36:	1c59      	adds	r1, r3, #1
  40fa38:	464e      	mov	r6, r9
  40fa3a:	e612      	b.n	40f662 <_vfiprintf_r+0x6f6>
  40fa3c:	9806      	ldr	r0, [sp, #24]
  40fa3e:	9902      	ldr	r1, [sp, #8]
  40fa40:	f8cd c004 	str.w	ip, [sp, #4]
  40fa44:	aa13      	add	r2, sp, #76	; 0x4c
  40fa46:	f7ff fa55 	bl	40eef4 <__sprint_r.part.0>
  40fa4a:	f8dd c004 	ldr.w	ip, [sp, #4]
  40fa4e:	2800      	cmp	r0, #0
  40fa50:	f47f aedb 	bne.w	40f80a <_vfiprintf_r+0x89e>
  40fa54:	9b14      	ldr	r3, [sp, #80]	; 0x50
  40fa56:	9a15      	ldr	r2, [sp, #84]	; 0x54
  40fa58:	1c59      	adds	r1, r3, #1
  40fa5a:	464e      	mov	r6, r9
  40fa5c:	e610      	b.n	40f680 <_vfiprintf_r+0x714>
  40fa5e:	2a00      	cmp	r2, #0
  40fa60:	d156      	bne.n	40fb10 <_vfiprintf_r+0xba4>
  40fa62:	2101      	movs	r1, #1
  40fa64:	4613      	mov	r3, r2
  40fa66:	464e      	mov	r6, r9
  40fa68:	e60e      	b.n	40f688 <_vfiprintf_r+0x71c>
  40fa6a:	9806      	ldr	r0, [sp, #24]
  40fa6c:	9902      	ldr	r1, [sp, #8]
  40fa6e:	aa13      	add	r2, sp, #76	; 0x4c
  40fa70:	f7ff fa40 	bl	40eef4 <__sprint_r.part.0>
  40fa74:	2800      	cmp	r0, #0
  40fa76:	f47f aec8 	bne.w	40f80a <_vfiprintf_r+0x89e>
  40fa7a:	9914      	ldr	r1, [sp, #80]	; 0x50
  40fa7c:	9a15      	ldr	r2, [sp, #84]	; 0x54
  40fa7e:	3101      	adds	r1, #1
  40fa80:	464e      	mov	r6, r9
  40fa82:	e636      	b.n	40f6f2 <_vfiprintf_r+0x786>
  40fa84:	f04f 0b2d 	mov.w	fp, #45	; 0x2d
  40fa88:	4264      	negs	r4, r4
  40fa8a:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
  40fa8e:	f88d b047 	strb.w	fp, [sp, #71]	; 0x47
  40fa92:	f8cd b01c 	str.w	fp, [sp, #28]
  40fa96:	f8cd c014 	str.w	ip, [sp, #20]
  40fa9a:	2301      	movs	r3, #1
  40fa9c:	f7ff bb7f 	b.w	40f19e <_vfiprintf_r+0x232>
  40faa0:	f01a 0f10 	tst.w	sl, #16
  40faa4:	d11d      	bne.n	40fae2 <_vfiprintf_r+0xb76>
  40faa6:	f01a 0f40 	tst.w	sl, #64	; 0x40
  40faaa:	d059      	beq.n	40fb60 <_vfiprintf_r+0xbf4>
  40faac:	9d08      	ldr	r5, [sp, #32]
  40faae:	f8dd b024 	ldr.w	fp, [sp, #36]	; 0x24
  40fab2:	682b      	ldr	r3, [r5, #0]
  40fab4:	3504      	adds	r5, #4
  40fab6:	9508      	str	r5, [sp, #32]
  40fab8:	f8a3 b000 	strh.w	fp, [r3]
  40fabc:	f7ff ba89 	b.w	40efd2 <_vfiprintf_r+0x66>
  40fac0:	9806      	ldr	r0, [sp, #24]
  40fac2:	9902      	ldr	r1, [sp, #8]
  40fac4:	f8cd c004 	str.w	ip, [sp, #4]
  40fac8:	aa13      	add	r2, sp, #76	; 0x4c
  40faca:	f7ff fa13 	bl	40eef4 <__sprint_r.part.0>
  40face:	f8dd c004 	ldr.w	ip, [sp, #4]
  40fad2:	2800      	cmp	r0, #0
  40fad4:	f47f ae99 	bne.w	40f80a <_vfiprintf_r+0x89e>
  40fad8:	9b14      	ldr	r3, [sp, #80]	; 0x50
  40fada:	9a15      	ldr	r2, [sp, #84]	; 0x54
  40fadc:	1c59      	adds	r1, r3, #1
  40fade:	464e      	mov	r6, r9
  40fae0:	e5ae      	b.n	40f640 <_vfiprintf_r+0x6d4>
  40fae2:	f8dd b020 	ldr.w	fp, [sp, #32]
  40fae6:	9c09      	ldr	r4, [sp, #36]	; 0x24
  40fae8:	f8db 3000 	ldr.w	r3, [fp]
  40faec:	f10b 0b04 	add.w	fp, fp, #4
  40faf0:	f8cd b020 	str.w	fp, [sp, #32]
  40faf4:	601c      	str	r4, [r3, #0]
  40faf6:	f7ff ba6c 	b.w	40efd2 <_vfiprintf_r+0x66>
  40fafa:	9408      	str	r4, [sp, #32]
  40fafc:	f7fc ff52 	bl	40c9a4 <strlen>
  40fb00:	f89d 4047 	ldrb.w	r4, [sp, #71]	; 0x47
  40fb04:	9005      	str	r0, [sp, #20]
  40fb06:	9407      	str	r4, [sp, #28]
  40fb08:	f04f 0c00 	mov.w	ip, #0
  40fb0c:	f7ff bb62 	b.w	40f1d4 <_vfiprintf_r+0x268>
  40fb10:	9806      	ldr	r0, [sp, #24]
  40fb12:	9902      	ldr	r1, [sp, #8]
  40fb14:	f8cd c004 	str.w	ip, [sp, #4]
  40fb18:	aa13      	add	r2, sp, #76	; 0x4c
  40fb1a:	f7ff f9eb 	bl	40eef4 <__sprint_r.part.0>
  40fb1e:	f8dd c004 	ldr.w	ip, [sp, #4]
  40fb22:	2800      	cmp	r0, #0
  40fb24:	f47f ae71 	bne.w	40f80a <_vfiprintf_r+0x89e>
  40fb28:	9b14      	ldr	r3, [sp, #80]	; 0x50
  40fb2a:	9a15      	ldr	r2, [sp, #84]	; 0x54
  40fb2c:	1c59      	adds	r1, r3, #1
  40fb2e:	464e      	mov	r6, r9
  40fb30:	e5aa      	b.n	40f688 <_vfiprintf_r+0x71c>
  40fb32:	9b14      	ldr	r3, [sp, #80]	; 0x50
  40fb34:	9a15      	ldr	r2, [sp, #84]	; 0x54
  40fb36:	4d03      	ldr	r5, [pc, #12]	; (40fb44 <_vfiprintf_r+0xbd8>)
  40fb38:	3301      	adds	r3, #1
  40fb3a:	f7ff bb9b 	b.w	40f274 <_vfiprintf_r+0x308>
  40fb3e:	bf00      	nop
  40fb40:	00416ed0 	.word	0x00416ed0
  40fb44:	00416ee0 	.word	0x00416ee0
  40fb48:	f1bc 0f06 	cmp.w	ip, #6
  40fb4c:	bf34      	ite	cc
  40fb4e:	4663      	movcc	r3, ip
  40fb50:	2306      	movcs	r3, #6
  40fb52:	9408      	str	r4, [sp, #32]
  40fb54:	ea23 74e3 	bic.w	r4, r3, r3, asr #31
  40fb58:	9305      	str	r3, [sp, #20]
  40fb5a:	9403      	str	r4, [sp, #12]
  40fb5c:	4f16      	ldr	r7, [pc, #88]	; (40fbb8 <_vfiprintf_r+0xc4c>)
  40fb5e:	e470      	b.n	40f442 <_vfiprintf_r+0x4d6>
  40fb60:	9c08      	ldr	r4, [sp, #32]
  40fb62:	9d09      	ldr	r5, [sp, #36]	; 0x24
  40fb64:	6823      	ldr	r3, [r4, #0]
  40fb66:	3404      	adds	r4, #4
  40fb68:	9408      	str	r4, [sp, #32]
  40fb6a:	601d      	str	r5, [r3, #0]
  40fb6c:	f7ff ba31 	b.w	40efd2 <_vfiprintf_r+0x66>
  40fb70:	9814      	ldr	r0, [sp, #80]	; 0x50
  40fb72:	4d12      	ldr	r5, [pc, #72]	; (40fbbc <_vfiprintf_r+0xc50>)
  40fb74:	3001      	adds	r0, #1
  40fb76:	e5f8      	b.n	40f76a <_vfiprintf_r+0x7fe>
  40fb78:	f89d 5047 	ldrb.w	r5, [sp, #71]	; 0x47
  40fb7c:	f8cd c014 	str.w	ip, [sp, #20]
  40fb80:	9507      	str	r5, [sp, #28]
  40fb82:	9408      	str	r4, [sp, #32]
  40fb84:	4684      	mov	ip, r0
  40fb86:	f7ff bb25 	b.w	40f1d4 <_vfiprintf_r+0x268>
  40fb8a:	4608      	mov	r0, r1
  40fb8c:	e6ad      	b.n	40f8ea <_vfiprintf_r+0x97e>
  40fb8e:	46a0      	mov	r8, r4
  40fb90:	2500      	movs	r5, #0
  40fb92:	f7ff ba5a 	b.w	40f04a <_vfiprintf_r+0xde>
  40fb96:	f8dd b020 	ldr.w	fp, [sp, #32]
  40fb9a:	f898 3001 	ldrb.w	r3, [r8, #1]
  40fb9e:	f8db 5000 	ldr.w	r5, [fp]
  40fba2:	f10b 0204 	add.w	r2, fp, #4
  40fba6:	2d00      	cmp	r5, #0
  40fba8:	9208      	str	r2, [sp, #32]
  40fbaa:	46a0      	mov	r8, r4
  40fbac:	f6bf aa4b 	bge.w	40f046 <_vfiprintf_r+0xda>
  40fbb0:	f04f 35ff 	mov.w	r5, #4294967295
  40fbb4:	f7ff ba47 	b.w	40f046 <_vfiprintf_r+0xda>
  40fbb8:	00416e88 	.word	0x00416e88
  40fbbc:	00416ee0 	.word	0x00416ee0

0040fbc0 <__sbprintf>:
  40fbc0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  40fbc4:	460c      	mov	r4, r1
  40fbc6:	f2ad 4d6c 	subw	sp, sp, #1132	; 0x46c
  40fbca:	f8b1 900c 	ldrh.w	r9, [r1, #12]
  40fbce:	69e7      	ldr	r7, [r4, #28]
  40fbd0:	6e49      	ldr	r1, [r1, #100]	; 0x64
  40fbd2:	f8b4 800e 	ldrh.w	r8, [r4, #14]
  40fbd6:	9119      	str	r1, [sp, #100]	; 0x64
  40fbd8:	ad1a      	add	r5, sp, #104	; 0x68
  40fbda:	f44f 6680 	mov.w	r6, #1024	; 0x400
  40fbde:	f04f 0e00 	mov.w	lr, #0
  40fbe2:	9707      	str	r7, [sp, #28]
  40fbe4:	f029 0902 	bic.w	r9, r9, #2
  40fbe8:	6a67      	ldr	r7, [r4, #36]	; 0x24
  40fbea:	9500      	str	r5, [sp, #0]
  40fbec:	4669      	mov	r1, sp
  40fbee:	9504      	str	r5, [sp, #16]
  40fbf0:	9602      	str	r6, [sp, #8]
  40fbf2:	9605      	str	r6, [sp, #20]
  40fbf4:	f8ad 900c 	strh.w	r9, [sp, #12]
  40fbf8:	f8ad 800e 	strh.w	r8, [sp, #14]
  40fbfc:	9709      	str	r7, [sp, #36]	; 0x24
  40fbfe:	f8cd e018 	str.w	lr, [sp, #24]
  40fc02:	4606      	mov	r6, r0
  40fc04:	f7ff f9b2 	bl	40ef6c <_vfiprintf_r>
  40fc08:	1e05      	subs	r5, r0, #0
  40fc0a:	db07      	blt.n	40fc1c <__sbprintf+0x5c>
  40fc0c:	4630      	mov	r0, r6
  40fc0e:	4669      	mov	r1, sp
  40fc10:	f001 f908 	bl	410e24 <_fflush_r>
  40fc14:	2800      	cmp	r0, #0
  40fc16:	bf18      	it	ne
  40fc18:	f04f 35ff 	movne.w	r5, #4294967295
  40fc1c:	f8bd 300c 	ldrh.w	r3, [sp, #12]
  40fc20:	065b      	lsls	r3, r3, #25
  40fc22:	d503      	bpl.n	40fc2c <__sbprintf+0x6c>
  40fc24:	89a3      	ldrh	r3, [r4, #12]
  40fc26:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  40fc2a:	81a3      	strh	r3, [r4, #12]
  40fc2c:	4628      	mov	r0, r5
  40fc2e:	f20d 4d6c 	addw	sp, sp, #1132	; 0x46c
  40fc32:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  40fc36:	bf00      	nop

0040fc38 <_write_r>:
  40fc38:	b570      	push	{r4, r5, r6, lr}
  40fc3a:	4c08      	ldr	r4, [pc, #32]	; (40fc5c <_write_r+0x24>)
  40fc3c:	4606      	mov	r6, r0
  40fc3e:	2500      	movs	r5, #0
  40fc40:	4608      	mov	r0, r1
  40fc42:	4611      	mov	r1, r2
  40fc44:	461a      	mov	r2, r3
  40fc46:	6025      	str	r5, [r4, #0]
  40fc48:	f7f3 fc50 	bl	4034ec <_write>
  40fc4c:	1c43      	adds	r3, r0, #1
  40fc4e:	d000      	beq.n	40fc52 <_write_r+0x1a>
  40fc50:	bd70      	pop	{r4, r5, r6, pc}
  40fc52:	6823      	ldr	r3, [r4, #0]
  40fc54:	2b00      	cmp	r3, #0
  40fc56:	d0fb      	beq.n	40fc50 <_write_r+0x18>
  40fc58:	6033      	str	r3, [r6, #0]
  40fc5a:	bd70      	pop	{r4, r5, r6, pc}
  40fc5c:	2000503c 	.word	0x2000503c

0040fc60 <__swsetup_r>:
  40fc60:	4b2f      	ldr	r3, [pc, #188]	; (40fd20 <__swsetup_r+0xc0>)
  40fc62:	681b      	ldr	r3, [r3, #0]
  40fc64:	b570      	push	{r4, r5, r6, lr}
  40fc66:	4606      	mov	r6, r0
  40fc68:	460c      	mov	r4, r1
  40fc6a:	b113      	cbz	r3, 40fc72 <__swsetup_r+0x12>
  40fc6c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  40fc6e:	2a00      	cmp	r2, #0
  40fc70:	d036      	beq.n	40fce0 <__swsetup_r+0x80>
  40fc72:	89a5      	ldrh	r5, [r4, #12]
  40fc74:	b2ab      	uxth	r3, r5
  40fc76:	0719      	lsls	r1, r3, #28
  40fc78:	d50c      	bpl.n	40fc94 <__swsetup_r+0x34>
  40fc7a:	6922      	ldr	r2, [r4, #16]
  40fc7c:	b1aa      	cbz	r2, 40fcaa <__swsetup_r+0x4a>
  40fc7e:	f013 0101 	ands.w	r1, r3, #1
  40fc82:	d01e      	beq.n	40fcc2 <__swsetup_r+0x62>
  40fc84:	6963      	ldr	r3, [r4, #20]
  40fc86:	2100      	movs	r1, #0
  40fc88:	425b      	negs	r3, r3
  40fc8a:	61a3      	str	r3, [r4, #24]
  40fc8c:	60a1      	str	r1, [r4, #8]
  40fc8e:	b1f2      	cbz	r2, 40fcce <__swsetup_r+0x6e>
  40fc90:	2000      	movs	r0, #0
  40fc92:	bd70      	pop	{r4, r5, r6, pc}
  40fc94:	06da      	lsls	r2, r3, #27
  40fc96:	d53b      	bpl.n	40fd10 <__swsetup_r+0xb0>
  40fc98:	075b      	lsls	r3, r3, #29
  40fc9a:	d425      	bmi.n	40fce8 <__swsetup_r+0x88>
  40fc9c:	6922      	ldr	r2, [r4, #16]
  40fc9e:	f045 0308 	orr.w	r3, r5, #8
  40fca2:	81a3      	strh	r3, [r4, #12]
  40fca4:	b29b      	uxth	r3, r3
  40fca6:	2a00      	cmp	r2, #0
  40fca8:	d1e9      	bne.n	40fc7e <__swsetup_r+0x1e>
  40fcaa:	f403 7120 	and.w	r1, r3, #640	; 0x280
  40fcae:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
  40fcb2:	d0e4      	beq.n	40fc7e <__swsetup_r+0x1e>
  40fcb4:	4630      	mov	r0, r6
  40fcb6:	4621      	mov	r1, r4
  40fcb8:	f001 fcc2 	bl	411640 <__smakebuf_r>
  40fcbc:	89a3      	ldrh	r3, [r4, #12]
  40fcbe:	6922      	ldr	r2, [r4, #16]
  40fcc0:	e7dd      	b.n	40fc7e <__swsetup_r+0x1e>
  40fcc2:	0798      	lsls	r0, r3, #30
  40fcc4:	bf58      	it	pl
  40fcc6:	6961      	ldrpl	r1, [r4, #20]
  40fcc8:	60a1      	str	r1, [r4, #8]
  40fcca:	2a00      	cmp	r2, #0
  40fccc:	d1e0      	bne.n	40fc90 <__swsetup_r+0x30>
  40fcce:	89a3      	ldrh	r3, [r4, #12]
  40fcd0:	061a      	lsls	r2, r3, #24
  40fcd2:	d5dd      	bpl.n	40fc90 <__swsetup_r+0x30>
  40fcd4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  40fcd8:	81a3      	strh	r3, [r4, #12]
  40fcda:	f04f 30ff 	mov.w	r0, #4294967295
  40fcde:	bd70      	pop	{r4, r5, r6, pc}
  40fce0:	4618      	mov	r0, r3
  40fce2:	f001 f8bb 	bl	410e5c <__sinit>
  40fce6:	e7c4      	b.n	40fc72 <__swsetup_r+0x12>
  40fce8:	6b21      	ldr	r1, [r4, #48]	; 0x30
  40fcea:	b149      	cbz	r1, 40fd00 <__swsetup_r+0xa0>
  40fcec:	f104 0340 	add.w	r3, r4, #64	; 0x40
  40fcf0:	4299      	cmp	r1, r3
  40fcf2:	d003      	beq.n	40fcfc <__swsetup_r+0x9c>
  40fcf4:	4630      	mov	r0, r6
  40fcf6:	f001 f9f3 	bl	4110e0 <_free_r>
  40fcfa:	89a5      	ldrh	r5, [r4, #12]
  40fcfc:	2300      	movs	r3, #0
  40fcfe:	6323      	str	r3, [r4, #48]	; 0x30
  40fd00:	f025 0524 	bic.w	r5, r5, #36	; 0x24
  40fd04:	2300      	movs	r3, #0
  40fd06:	6922      	ldr	r2, [r4, #16]
  40fd08:	6063      	str	r3, [r4, #4]
  40fd0a:	b2ad      	uxth	r5, r5
  40fd0c:	6022      	str	r2, [r4, #0]
  40fd0e:	e7c6      	b.n	40fc9e <__swsetup_r+0x3e>
  40fd10:	f045 0540 	orr.w	r5, r5, #64	; 0x40
  40fd14:	2309      	movs	r3, #9
  40fd16:	6033      	str	r3, [r6, #0]
  40fd18:	f04f 30ff 	mov.w	r0, #4294967295
  40fd1c:	81a5      	strh	r5, [r4, #12]
  40fd1e:	bd70      	pop	{r4, r5, r6, pc}
  40fd20:	20000b30 	.word	0x20000b30

0040fd24 <register_fini>:
  40fd24:	4b02      	ldr	r3, [pc, #8]	; (40fd30 <register_fini+0xc>)
  40fd26:	b113      	cbz	r3, 40fd2e <register_fini+0xa>
  40fd28:	4802      	ldr	r0, [pc, #8]	; (40fd34 <register_fini+0x10>)
  40fd2a:	f000 b805 	b.w	40fd38 <atexit>
  40fd2e:	4770      	bx	lr
  40fd30:	00000000 	.word	0x00000000
  40fd34:	00410f59 	.word	0x00410f59

0040fd38 <atexit>:
  40fd38:	4601      	mov	r1, r0
  40fd3a:	2000      	movs	r0, #0
  40fd3c:	4602      	mov	r2, r0
  40fd3e:	4603      	mov	r3, r0
  40fd40:	f004 b87a 	b.w	413e38 <__register_exitproc>

0040fd44 <_close_r>:
  40fd44:	b538      	push	{r3, r4, r5, lr}
  40fd46:	4c07      	ldr	r4, [pc, #28]	; (40fd64 <_close_r+0x20>)
  40fd48:	2300      	movs	r3, #0
  40fd4a:	4605      	mov	r5, r0
  40fd4c:	4608      	mov	r0, r1
  40fd4e:	6023      	str	r3, [r4, #0]
  40fd50:	f7fb fbd2 	bl	40b4f8 <_close>
  40fd54:	1c43      	adds	r3, r0, #1
  40fd56:	d000      	beq.n	40fd5a <_close_r+0x16>
  40fd58:	bd38      	pop	{r3, r4, r5, pc}
  40fd5a:	6823      	ldr	r3, [r4, #0]
  40fd5c:	2b00      	cmp	r3, #0
  40fd5e:	d0fb      	beq.n	40fd58 <_close_r+0x14>
  40fd60:	602b      	str	r3, [r5, #0]
  40fd62:	bd38      	pop	{r3, r4, r5, pc}
  40fd64:	2000503c 	.word	0x2000503c

0040fd68 <quorem>:
  40fd68:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40fd6c:	6903      	ldr	r3, [r0, #16]
  40fd6e:	690d      	ldr	r5, [r1, #16]
  40fd70:	429d      	cmp	r5, r3
  40fd72:	b083      	sub	sp, #12
  40fd74:	4683      	mov	fp, r0
  40fd76:	f300 808b 	bgt.w	40fe90 <quorem+0x128>
  40fd7a:	3d01      	subs	r5, #1
  40fd7c:	f101 0414 	add.w	r4, r1, #20
  40fd80:	f100 0a14 	add.w	sl, r0, #20
  40fd84:	f854 2025 	ldr.w	r2, [r4, r5, lsl #2]
  40fd88:	f85a 3025 	ldr.w	r3, [sl, r5, lsl #2]
  40fd8c:	3201      	adds	r2, #1
  40fd8e:	fbb3 f8f2 	udiv	r8, r3, r2
  40fd92:	00aa      	lsls	r2, r5, #2
  40fd94:	4691      	mov	r9, r2
  40fd96:	9200      	str	r2, [sp, #0]
  40fd98:	4452      	add	r2, sl
  40fd9a:	44a1      	add	r9, r4
  40fd9c:	9201      	str	r2, [sp, #4]
  40fd9e:	f1b8 0f00 	cmp.w	r8, #0
  40fda2:	d03d      	beq.n	40fe20 <quorem+0xb8>
  40fda4:	f04f 0e00 	mov.w	lr, #0
  40fda8:	4670      	mov	r0, lr
  40fdaa:	4622      	mov	r2, r4
  40fdac:	4653      	mov	r3, sl
  40fdae:	468c      	mov	ip, r1
  40fdb0:	f852 6b04 	ldr.w	r6, [r2], #4
  40fdb4:	6819      	ldr	r1, [r3, #0]
  40fdb6:	b2b7      	uxth	r7, r6
  40fdb8:	0c36      	lsrs	r6, r6, #16
  40fdba:	fb07 ee08 	mla	lr, r7, r8, lr
  40fdbe:	fb06 f608 	mul.w	r6, r6, r8
  40fdc2:	eb06 461e 	add.w	r6, r6, lr, lsr #16
  40fdc6:	fa1f f78e 	uxth.w	r7, lr
  40fdca:	1bc7      	subs	r7, r0, r7
  40fdcc:	b2b0      	uxth	r0, r6
  40fdce:	fa17 f781 	uxtah	r7, r7, r1
  40fdd2:	ebc0 4011 	rsb	r0, r0, r1, lsr #16
  40fdd6:	eb00 4027 	add.w	r0, r0, r7, asr #16
  40fdda:	b2bf      	uxth	r7, r7
  40fddc:	ea47 4700 	orr.w	r7, r7, r0, lsl #16
  40fde0:	4591      	cmp	r9, r2
  40fde2:	f843 7b04 	str.w	r7, [r3], #4
  40fde6:	ea4f 4020 	mov.w	r0, r0, asr #16
  40fdea:	ea4f 4e16 	mov.w	lr, r6, lsr #16
  40fdee:	d2df      	bcs.n	40fdb0 <quorem+0x48>
  40fdf0:	9a00      	ldr	r2, [sp, #0]
  40fdf2:	f85a 3002 	ldr.w	r3, [sl, r2]
  40fdf6:	4661      	mov	r1, ip
  40fdf8:	b993      	cbnz	r3, 40fe20 <quorem+0xb8>
  40fdfa:	9a01      	ldr	r2, [sp, #4]
  40fdfc:	1f13      	subs	r3, r2, #4
  40fdfe:	459a      	cmp	sl, r3
  40fe00:	d20c      	bcs.n	40fe1c <quorem+0xb4>
  40fe02:	f852 3c04 	ldr.w	r3, [r2, #-4]
  40fe06:	b94b      	cbnz	r3, 40fe1c <quorem+0xb4>
  40fe08:	f1a2 0308 	sub.w	r3, r2, #8
  40fe0c:	e002      	b.n	40fe14 <quorem+0xac>
  40fe0e:	681a      	ldr	r2, [r3, #0]
  40fe10:	3b04      	subs	r3, #4
  40fe12:	b91a      	cbnz	r2, 40fe1c <quorem+0xb4>
  40fe14:	459a      	cmp	sl, r3
  40fe16:	f105 35ff 	add.w	r5, r5, #4294967295
  40fe1a:	d3f8      	bcc.n	40fe0e <quorem+0xa6>
  40fe1c:	f8cb 5010 	str.w	r5, [fp, #16]
  40fe20:	4658      	mov	r0, fp
  40fe22:	f001 ff73 	bl	411d0c <__mcmp>
  40fe26:	2800      	cmp	r0, #0
  40fe28:	db2e      	blt.n	40fe88 <quorem+0x120>
  40fe2a:	f108 0801 	add.w	r8, r8, #1
  40fe2e:	4653      	mov	r3, sl
  40fe30:	2200      	movs	r2, #0
  40fe32:	f854 6b04 	ldr.w	r6, [r4], #4
  40fe36:	6818      	ldr	r0, [r3, #0]
  40fe38:	b2b1      	uxth	r1, r6
  40fe3a:	1a52      	subs	r2, r2, r1
  40fe3c:	0c36      	lsrs	r6, r6, #16
  40fe3e:	fa12 f180 	uxtah	r1, r2, r0
  40fe42:	ebc6 4210 	rsb	r2, r6, r0, lsr #16
  40fe46:	eb02 4221 	add.w	r2, r2, r1, asr #16
  40fe4a:	b289      	uxth	r1, r1
  40fe4c:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
  40fe50:	45a1      	cmp	r9, r4
  40fe52:	f843 1b04 	str.w	r1, [r3], #4
  40fe56:	ea4f 4222 	mov.w	r2, r2, asr #16
  40fe5a:	d2ea      	bcs.n	40fe32 <quorem+0xca>
  40fe5c:	f85a 2025 	ldr.w	r2, [sl, r5, lsl #2]
  40fe60:	eb0a 0385 	add.w	r3, sl, r5, lsl #2
  40fe64:	b982      	cbnz	r2, 40fe88 <quorem+0x120>
  40fe66:	1f1a      	subs	r2, r3, #4
  40fe68:	4592      	cmp	sl, r2
  40fe6a:	d20b      	bcs.n	40fe84 <quorem+0x11c>
  40fe6c:	f853 2c04 	ldr.w	r2, [r3, #-4]
  40fe70:	b942      	cbnz	r2, 40fe84 <quorem+0x11c>
  40fe72:	3b08      	subs	r3, #8
  40fe74:	e002      	b.n	40fe7c <quorem+0x114>
  40fe76:	681a      	ldr	r2, [r3, #0]
  40fe78:	3b04      	subs	r3, #4
  40fe7a:	b91a      	cbnz	r2, 40fe84 <quorem+0x11c>
  40fe7c:	459a      	cmp	sl, r3
  40fe7e:	f105 35ff 	add.w	r5, r5, #4294967295
  40fe82:	d3f8      	bcc.n	40fe76 <quorem+0x10e>
  40fe84:	f8cb 5010 	str.w	r5, [fp, #16]
  40fe88:	4640      	mov	r0, r8
  40fe8a:	b003      	add	sp, #12
  40fe8c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40fe90:	2000      	movs	r0, #0
  40fe92:	b003      	add	sp, #12
  40fe94:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0040fe98 <_dtoa_r>:
  40fe98:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40fe9c:	6c01      	ldr	r1, [r0, #64]	; 0x40
  40fe9e:	b09b      	sub	sp, #108	; 0x6c
  40fea0:	4604      	mov	r4, r0
  40fea2:	9d27      	ldr	r5, [sp, #156]	; 0x9c
  40fea4:	4692      	mov	sl, r2
  40fea6:	469b      	mov	fp, r3
  40fea8:	b149      	cbz	r1, 40febe <_dtoa_r+0x26>
  40feaa:	6c43      	ldr	r3, [r0, #68]	; 0x44
  40feac:	604b      	str	r3, [r1, #4]
  40feae:	2201      	movs	r2, #1
  40feb0:	fa02 f303 	lsl.w	r3, r2, r3
  40feb4:	608b      	str	r3, [r1, #8]
  40feb6:	f001 fce5 	bl	411884 <_Bfree>
  40feba:	2300      	movs	r3, #0
  40febc:	6423      	str	r3, [r4, #64]	; 0x40
  40febe:	f1bb 0f00 	cmp.w	fp, #0
  40fec2:	46d9      	mov	r9, fp
  40fec4:	db33      	blt.n	40ff2e <_dtoa_r+0x96>
  40fec6:	2300      	movs	r3, #0
  40fec8:	602b      	str	r3, [r5, #0]
  40feca:	4ba5      	ldr	r3, [pc, #660]	; (410160 <_dtoa_r+0x2c8>)
  40fecc:	461a      	mov	r2, r3
  40fece:	ea09 0303 	and.w	r3, r9, r3
  40fed2:	4293      	cmp	r3, r2
  40fed4:	d014      	beq.n	40ff00 <_dtoa_r+0x68>
  40fed6:	4650      	mov	r0, sl
  40fed8:	4659      	mov	r1, fp
  40feda:	2200      	movs	r2, #0
  40fedc:	2300      	movs	r3, #0
  40fede:	f005 f86f 	bl	414fc0 <__aeabi_dcmpeq>
  40fee2:	4680      	mov	r8, r0
  40fee4:	b348      	cbz	r0, 40ff3a <_dtoa_r+0xa2>
  40fee6:	9e26      	ldr	r6, [sp, #152]	; 0x98
  40fee8:	9d28      	ldr	r5, [sp, #160]	; 0xa0
  40feea:	2301      	movs	r3, #1
  40feec:	6033      	str	r3, [r6, #0]
  40feee:	2d00      	cmp	r5, #0
  40fef0:	f000 80c9 	beq.w	410086 <_dtoa_r+0x1ee>
  40fef4:	489b      	ldr	r0, [pc, #620]	; (410164 <_dtoa_r+0x2cc>)
  40fef6:	6028      	str	r0, [r5, #0]
  40fef8:	3801      	subs	r0, #1
  40fefa:	b01b      	add	sp, #108	; 0x6c
  40fefc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40ff00:	9d26      	ldr	r5, [sp, #152]	; 0x98
  40ff02:	f242 730f 	movw	r3, #9999	; 0x270f
  40ff06:	602b      	str	r3, [r5, #0]
  40ff08:	f1ba 0f00 	cmp.w	sl, #0
  40ff0c:	f000 80a4 	beq.w	410058 <_dtoa_r+0x1c0>
  40ff10:	4895      	ldr	r0, [pc, #596]	; (410168 <_dtoa_r+0x2d0>)
  40ff12:	9e28      	ldr	r6, [sp, #160]	; 0xa0
  40ff14:	2e00      	cmp	r6, #0
  40ff16:	d0f0      	beq.n	40fefa <_dtoa_r+0x62>
  40ff18:	78c3      	ldrb	r3, [r0, #3]
  40ff1a:	2b00      	cmp	r3, #0
  40ff1c:	f000 80b5 	beq.w	41008a <_dtoa_r+0x1f2>
  40ff20:	f100 0308 	add.w	r3, r0, #8
  40ff24:	9d28      	ldr	r5, [sp, #160]	; 0xa0
  40ff26:	602b      	str	r3, [r5, #0]
  40ff28:	b01b      	add	sp, #108	; 0x6c
  40ff2a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40ff2e:	2301      	movs	r3, #1
  40ff30:	f02b 4900 	bic.w	r9, fp, #2147483648	; 0x80000000
  40ff34:	602b      	str	r3, [r5, #0]
  40ff36:	46cb      	mov	fp, r9
  40ff38:	e7c7      	b.n	40feca <_dtoa_r+0x32>
  40ff3a:	aa19      	add	r2, sp, #100	; 0x64
  40ff3c:	ab18      	add	r3, sp, #96	; 0x60
  40ff3e:	e88d 000c 	stmia.w	sp, {r2, r3}
  40ff42:	4620      	mov	r0, r4
  40ff44:	4652      	mov	r2, sl
  40ff46:	465b      	mov	r3, fp
  40ff48:	f001 ffe8 	bl	411f1c <__d2b>
  40ff4c:	ea5f 5519 	movs.w	r5, r9, lsr #20
  40ff50:	900a      	str	r0, [sp, #40]	; 0x28
  40ff52:	f040 808a 	bne.w	41006a <_dtoa_r+0x1d2>
  40ff56:	9f18      	ldr	r7, [sp, #96]	; 0x60
  40ff58:	9d19      	ldr	r5, [sp, #100]	; 0x64
  40ff5a:	f46f 6382 	mvn.w	r3, #1040	; 0x410
  40ff5e:	443d      	add	r5, r7
  40ff60:	429d      	cmp	r5, r3
  40ff62:	f2c0 8294 	blt.w	41048e <_dtoa_r+0x5f6>
  40ff66:	331f      	adds	r3, #31
  40ff68:	f205 4212 	addw	r2, r5, #1042	; 0x412
  40ff6c:	1b5b      	subs	r3, r3, r5
  40ff6e:	fa09 f303 	lsl.w	r3, r9, r3
  40ff72:	fa2a f202 	lsr.w	r2, sl, r2
  40ff76:	ea43 0002 	orr.w	r0, r3, r2
  40ff7a:	f004 fd43 	bl	414a04 <__aeabi_ui2d>
  40ff7e:	2601      	movs	r6, #1
  40ff80:	3d01      	subs	r5, #1
  40ff82:	46b8      	mov	r8, r7
  40ff84:	f1a1 71f8 	sub.w	r1, r1, #32505856	; 0x1f00000
  40ff88:	9616      	str	r6, [sp, #88]	; 0x58
  40ff8a:	2200      	movs	r2, #0
  40ff8c:	4b77      	ldr	r3, [pc, #476]	; (41016c <_dtoa_r+0x2d4>)
  40ff8e:	f004 fbfb 	bl	414788 <__aeabi_dsub>
  40ff92:	a36d      	add	r3, pc, #436	; (adr r3, 410148 <_dtoa_r+0x2b0>)
  40ff94:	e9d3 2300 	ldrd	r2, r3, [r3]
  40ff98:	f004 fdaa 	bl	414af0 <__aeabi_dmul>
  40ff9c:	a36c      	add	r3, pc, #432	; (adr r3, 410150 <_dtoa_r+0x2b8>)
  40ff9e:	e9d3 2300 	ldrd	r2, r3, [r3]
  40ffa2:	f004 fbf3 	bl	41478c <__adddf3>
  40ffa6:	4606      	mov	r6, r0
  40ffa8:	4628      	mov	r0, r5
  40ffaa:	460f      	mov	r7, r1
  40ffac:	f004 fd3a 	bl	414a24 <__aeabi_i2d>
  40ffb0:	a369      	add	r3, pc, #420	; (adr r3, 410158 <_dtoa_r+0x2c0>)
  40ffb2:	e9d3 2300 	ldrd	r2, r3, [r3]
  40ffb6:	f004 fd9b 	bl	414af0 <__aeabi_dmul>
  40ffba:	4602      	mov	r2, r0
  40ffbc:	460b      	mov	r3, r1
  40ffbe:	4630      	mov	r0, r6
  40ffc0:	4639      	mov	r1, r7
  40ffc2:	f004 fbe3 	bl	41478c <__adddf3>
  40ffc6:	4606      	mov	r6, r0
  40ffc8:	460f      	mov	r7, r1
  40ffca:	f005 f82b 	bl	415024 <__aeabi_d2iz>
  40ffce:	4639      	mov	r1, r7
  40ffd0:	9007      	str	r0, [sp, #28]
  40ffd2:	2200      	movs	r2, #0
  40ffd4:	4630      	mov	r0, r6
  40ffd6:	2300      	movs	r3, #0
  40ffd8:	f004 fffc 	bl	414fd4 <__aeabi_dcmplt>
  40ffdc:	2800      	cmp	r0, #0
  40ffde:	f040 8228 	bne.w	410432 <_dtoa_r+0x59a>
  40ffe2:	9e07      	ldr	r6, [sp, #28]
  40ffe4:	2e16      	cmp	r6, #22
  40ffe6:	f200 8221 	bhi.w	41042c <_dtoa_r+0x594>
  40ffea:	4b61      	ldr	r3, [pc, #388]	; (410170 <_dtoa_r+0x2d8>)
  40ffec:	eb03 03c6 	add.w	r3, r3, r6, lsl #3
  40fff0:	e9d3 0100 	ldrd	r0, r1, [r3]
  40fff4:	4652      	mov	r2, sl
  40fff6:	465b      	mov	r3, fp
  40fff8:	f005 f80a 	bl	415010 <__aeabi_dcmpgt>
  40fffc:	2800      	cmp	r0, #0
  40fffe:	f000 824b 	beq.w	410498 <_dtoa_r+0x600>
  410002:	3e01      	subs	r6, #1
  410004:	9607      	str	r6, [sp, #28]
  410006:	2600      	movs	r6, #0
  410008:	960e      	str	r6, [sp, #56]	; 0x38
  41000a:	ebc5 0508 	rsb	r5, r5, r8
  41000e:	3d01      	subs	r5, #1
  410010:	9506      	str	r5, [sp, #24]
  410012:	f100 8225 	bmi.w	410460 <_dtoa_r+0x5c8>
  410016:	2500      	movs	r5, #0
  410018:	9508      	str	r5, [sp, #32]
  41001a:	9e07      	ldr	r6, [sp, #28]
  41001c:	2e00      	cmp	r6, #0
  41001e:	f2c0 8216 	blt.w	41044e <_dtoa_r+0x5b6>
  410022:	9d06      	ldr	r5, [sp, #24]
  410024:	960d      	str	r6, [sp, #52]	; 0x34
  410026:	4435      	add	r5, r6
  410028:	2600      	movs	r6, #0
  41002a:	9506      	str	r5, [sp, #24]
  41002c:	960c      	str	r6, [sp, #48]	; 0x30
  41002e:	9d24      	ldr	r5, [sp, #144]	; 0x90
  410030:	2d09      	cmp	r5, #9
  410032:	d82c      	bhi.n	41008e <_dtoa_r+0x1f6>
  410034:	2d05      	cmp	r5, #5
  410036:	bfc4      	itt	gt
  410038:	3d04      	subgt	r5, #4
  41003a:	9524      	strgt	r5, [sp, #144]	; 0x90
  41003c:	9e24      	ldr	r6, [sp, #144]	; 0x90
  41003e:	f1a6 0302 	sub.w	r3, r6, #2
  410042:	bfcc      	ite	gt
  410044:	2500      	movgt	r5, #0
  410046:	2501      	movle	r5, #1
  410048:	2b03      	cmp	r3, #3
  41004a:	d822      	bhi.n	410092 <_dtoa_r+0x1fa>
  41004c:	e8df f013 	tbh	[pc, r3, lsl #1]
  410050:	029e03b7 	.word	0x029e03b7
  410054:	049a03c0 	.word	0x049a03c0
  410058:	4a46      	ldr	r2, [pc, #280]	; (410174 <_dtoa_r+0x2dc>)
  41005a:	4b43      	ldr	r3, [pc, #268]	; (410168 <_dtoa_r+0x2d0>)
  41005c:	f3c9 0013 	ubfx	r0, r9, #0, #20
  410060:	2800      	cmp	r0, #0
  410062:	bf0c      	ite	eq
  410064:	4610      	moveq	r0, r2
  410066:	4618      	movne	r0, r3
  410068:	e753      	b.n	40ff12 <_dtoa_r+0x7a>
  41006a:	f3cb 0313 	ubfx	r3, fp, #0, #20
  41006e:	f043 517f 	orr.w	r1, r3, #1069547520	; 0x3fc00000
  410072:	f8cd 8058 	str.w	r8, [sp, #88]	; 0x58
  410076:	4650      	mov	r0, sl
  410078:	f2a5 35ff 	subw	r5, r5, #1023	; 0x3ff
  41007c:	f441 1140 	orr.w	r1, r1, #3145728	; 0x300000
  410080:	f8dd 8060 	ldr.w	r8, [sp, #96]	; 0x60
  410084:	e781      	b.n	40ff8a <_dtoa_r+0xf2>
  410086:	483c      	ldr	r0, [pc, #240]	; (410178 <_dtoa_r+0x2e0>)
  410088:	e737      	b.n	40fefa <_dtoa_r+0x62>
  41008a:	1cc3      	adds	r3, r0, #3
  41008c:	e74a      	b.n	40ff24 <_dtoa_r+0x8c>
  41008e:	2500      	movs	r5, #0
  410090:	9524      	str	r5, [sp, #144]	; 0x90
  410092:	2500      	movs	r5, #0
  410094:	6465      	str	r5, [r4, #68]	; 0x44
  410096:	4629      	mov	r1, r5
  410098:	4620      	mov	r0, r4
  41009a:	f001 fbcd 	bl	411838 <_Balloc>
  41009e:	f04f 39ff 	mov.w	r9, #4294967295
  4100a2:	2601      	movs	r6, #1
  4100a4:	9009      	str	r0, [sp, #36]	; 0x24
  4100a6:	9525      	str	r5, [sp, #148]	; 0x94
  4100a8:	6420      	str	r0, [r4, #64]	; 0x40
  4100aa:	f8cd 903c 	str.w	r9, [sp, #60]	; 0x3c
  4100ae:	960b      	str	r6, [sp, #44]	; 0x2c
  4100b0:	9b19      	ldr	r3, [sp, #100]	; 0x64
  4100b2:	2b00      	cmp	r3, #0
  4100b4:	f2c0 80d2 	blt.w	41025c <_dtoa_r+0x3c4>
  4100b8:	9e07      	ldr	r6, [sp, #28]
  4100ba:	2e0e      	cmp	r6, #14
  4100bc:	f300 80ce 	bgt.w	41025c <_dtoa_r+0x3c4>
  4100c0:	4b2b      	ldr	r3, [pc, #172]	; (410170 <_dtoa_r+0x2d8>)
  4100c2:	eb03 03c6 	add.w	r3, r3, r6, lsl #3
  4100c6:	e9d3 0100 	ldrd	r0, r1, [r3]
  4100ca:	e9cd 0104 	strd	r0, r1, [sp, #16]
  4100ce:	9925      	ldr	r1, [sp, #148]	; 0x94
  4100d0:	2900      	cmp	r1, #0
  4100d2:	f2c0 8380 	blt.w	4107d6 <_dtoa_r+0x93e>
  4100d6:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
  4100da:	4659      	mov	r1, fp
  4100dc:	4650      	mov	r0, sl
  4100de:	f004 fe31 	bl	414d44 <__aeabi_ddiv>
  4100e2:	f004 ff9f 	bl	415024 <__aeabi_d2iz>
  4100e6:	4605      	mov	r5, r0
  4100e8:	f004 fc9c 	bl	414a24 <__aeabi_i2d>
  4100ec:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
  4100f0:	f004 fcfe 	bl	414af0 <__aeabi_dmul>
  4100f4:	4602      	mov	r2, r0
  4100f6:	460b      	mov	r3, r1
  4100f8:	4650      	mov	r0, sl
  4100fa:	4659      	mov	r1, fp
  4100fc:	f004 fb44 	bl	414788 <__aeabi_dsub>
  410100:	9a09      	ldr	r2, [sp, #36]	; 0x24
  410102:	f105 0330 	add.w	r3, r5, #48	; 0x30
  410106:	f1b9 0f01 	cmp.w	r9, #1
  41010a:	4606      	mov	r6, r0
  41010c:	460f      	mov	r7, r1
  41010e:	7013      	strb	r3, [r2, #0]
  410110:	f102 0b01 	add.w	fp, r2, #1
  410114:	d064      	beq.n	4101e0 <_dtoa_r+0x348>
  410116:	2200      	movs	r2, #0
  410118:	4b18      	ldr	r3, [pc, #96]	; (41017c <_dtoa_r+0x2e4>)
  41011a:	f004 fce9 	bl	414af0 <__aeabi_dmul>
  41011e:	2200      	movs	r2, #0
  410120:	2300      	movs	r3, #0
  410122:	4606      	mov	r6, r0
  410124:	460f      	mov	r7, r1
  410126:	f004 ff4b 	bl	414fc0 <__aeabi_dcmpeq>
  41012a:	2800      	cmp	r0, #0
  41012c:	f040 8081 	bne.w	410232 <_dtoa_r+0x39a>
  410130:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
  410134:	9d09      	ldr	r5, [sp, #36]	; 0x24
  410136:	9403      	str	r4, [sp, #12]
  410138:	44c8      	add	r8, r9
  41013a:	e9dd ab04 	ldrd	sl, fp, [sp, #16]
  41013e:	f105 0902 	add.w	r9, r5, #2
  410142:	e028      	b.n	410196 <_dtoa_r+0x2fe>
  410144:	f3af 8000 	nop.w
  410148:	636f4361 	.word	0x636f4361
  41014c:	3fd287a7 	.word	0x3fd287a7
  410150:	8b60c8b3 	.word	0x8b60c8b3
  410154:	3fc68a28 	.word	0x3fc68a28
  410158:	509f79fb 	.word	0x509f79fb
  41015c:	3fd34413 	.word	0x3fd34413
  410160:	7ff00000 	.word	0x7ff00000
  410164:	00416e91 	.word	0x00416e91
  410168:	00417000 	.word	0x00417000
  41016c:	3ff80000 	.word	0x3ff80000
  410170:	00417010 	.word	0x00417010
  410174:	00416ff4 	.word	0x00416ff4
  410178:	00416e90 	.word	0x00416e90
  41017c:	40240000 	.word	0x40240000
  410180:	f004 fcb6 	bl	414af0 <__aeabi_dmul>
  410184:	2200      	movs	r2, #0
  410186:	2300      	movs	r3, #0
  410188:	4606      	mov	r6, r0
  41018a:	460f      	mov	r7, r1
  41018c:	f004 ff18 	bl	414fc0 <__aeabi_dcmpeq>
  410190:	2800      	cmp	r0, #0
  410192:	f040 83c1 	bne.w	410918 <_dtoa_r+0xa80>
  410196:	4652      	mov	r2, sl
  410198:	465b      	mov	r3, fp
  41019a:	4630      	mov	r0, r6
  41019c:	4639      	mov	r1, r7
  41019e:	f004 fdd1 	bl	414d44 <__aeabi_ddiv>
  4101a2:	f004 ff3f 	bl	415024 <__aeabi_d2iz>
  4101a6:	4605      	mov	r5, r0
  4101a8:	f004 fc3c 	bl	414a24 <__aeabi_i2d>
  4101ac:	4652      	mov	r2, sl
  4101ae:	465b      	mov	r3, fp
  4101b0:	f004 fc9e 	bl	414af0 <__aeabi_dmul>
  4101b4:	4602      	mov	r2, r0
  4101b6:	460b      	mov	r3, r1
  4101b8:	4630      	mov	r0, r6
  4101ba:	4639      	mov	r1, r7
  4101bc:	f004 fae4 	bl	414788 <__aeabi_dsub>
  4101c0:	f105 0e30 	add.w	lr, r5, #48	; 0x30
  4101c4:	45c1      	cmp	r9, r8
  4101c6:	f809 ec01 	strb.w	lr, [r9, #-1]
  4101ca:	464c      	mov	r4, r9
  4101cc:	4606      	mov	r6, r0
  4101ce:	460f      	mov	r7, r1
  4101d0:	f04f 0200 	mov.w	r2, #0
  4101d4:	4ba7      	ldr	r3, [pc, #668]	; (410474 <_dtoa_r+0x5dc>)
  4101d6:	f109 0901 	add.w	r9, r9, #1
  4101da:	d1d1      	bne.n	410180 <_dtoa_r+0x2e8>
  4101dc:	46a3      	mov	fp, r4
  4101de:	9c03      	ldr	r4, [sp, #12]
  4101e0:	4632      	mov	r2, r6
  4101e2:	463b      	mov	r3, r7
  4101e4:	4630      	mov	r0, r6
  4101e6:	4639      	mov	r1, r7
  4101e8:	f004 fad0 	bl	41478c <__adddf3>
  4101ec:	4606      	mov	r6, r0
  4101ee:	460f      	mov	r7, r1
  4101f0:	4632      	mov	r2, r6
  4101f2:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
  4101f6:	463b      	mov	r3, r7
  4101f8:	f004 feec 	bl	414fd4 <__aeabi_dcmplt>
  4101fc:	b940      	cbnz	r0, 410210 <_dtoa_r+0x378>
  4101fe:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
  410202:	4632      	mov	r2, r6
  410204:	463b      	mov	r3, r7
  410206:	f004 fedb 	bl	414fc0 <__aeabi_dcmpeq>
  41020a:	b190      	cbz	r0, 410232 <_dtoa_r+0x39a>
  41020c:	07eb      	lsls	r3, r5, #31
  41020e:	d510      	bpl.n	410232 <_dtoa_r+0x39a>
  410210:	f81b 5c01 	ldrb.w	r5, [fp, #-1]
  410214:	9a09      	ldr	r2, [sp, #36]	; 0x24
  410216:	e005      	b.n	410224 <_dtoa_r+0x38c>
  410218:	429a      	cmp	r2, r3
  41021a:	f000 8428 	beq.w	410a6e <_dtoa_r+0xbd6>
  41021e:	f813 5c01 	ldrb.w	r5, [r3, #-1]
  410222:	469b      	mov	fp, r3
  410224:	2d39      	cmp	r5, #57	; 0x39
  410226:	f10b 33ff 	add.w	r3, fp, #4294967295
  41022a:	d0f5      	beq.n	410218 <_dtoa_r+0x380>
  41022c:	1c6a      	adds	r2, r5, #1
  41022e:	b2d2      	uxtb	r2, r2
  410230:	701a      	strb	r2, [r3, #0]
  410232:	4620      	mov	r0, r4
  410234:	990a      	ldr	r1, [sp, #40]	; 0x28
  410236:	f001 fb25 	bl	411884 <_Bfree>
  41023a:	9e07      	ldr	r6, [sp, #28]
  41023c:	9d26      	ldr	r5, [sp, #152]	; 0x98
  41023e:	1c73      	adds	r3, r6, #1
  410240:	9e28      	ldr	r6, [sp, #160]	; 0xa0
  410242:	2200      	movs	r2, #0
  410244:	f88b 2000 	strb.w	r2, [fp]
  410248:	602b      	str	r3, [r5, #0]
  41024a:	2e00      	cmp	r6, #0
  41024c:	f000 8325 	beq.w	41089a <_dtoa_r+0xa02>
  410250:	9809      	ldr	r0, [sp, #36]	; 0x24
  410252:	f8c6 b000 	str.w	fp, [r6]
  410256:	b01b      	add	sp, #108	; 0x6c
  410258:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  41025c:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
  41025e:	2d00      	cmp	r5, #0
  410260:	f000 8103 	beq.w	41046a <_dtoa_r+0x5d2>
  410264:	9e24      	ldr	r6, [sp, #144]	; 0x90
  410266:	2e01      	cmp	r6, #1
  410268:	f340 82dc 	ble.w	410824 <_dtoa_r+0x98c>
  41026c:	9e0c      	ldr	r6, [sp, #48]	; 0x30
  41026e:	f109 37ff 	add.w	r7, r9, #4294967295
  410272:	42be      	cmp	r6, r7
  410274:	f2c0 8389 	blt.w	41098a <_dtoa_r+0xaf2>
  410278:	1bf7      	subs	r7, r6, r7
  41027a:	f1b9 0f00 	cmp.w	r9, #0
  41027e:	f2c0 8486 	blt.w	410b8e <_dtoa_r+0xcf6>
  410282:	9d08      	ldr	r5, [sp, #32]
  410284:	464b      	mov	r3, r9
  410286:	9e08      	ldr	r6, [sp, #32]
  410288:	441e      	add	r6, r3
  41028a:	9608      	str	r6, [sp, #32]
  41028c:	9e06      	ldr	r6, [sp, #24]
  41028e:	4620      	mov	r0, r4
  410290:	441e      	add	r6, r3
  410292:	2101      	movs	r1, #1
  410294:	9606      	str	r6, [sp, #24]
  410296:	f001 fbe5 	bl	411a64 <__i2b>
  41029a:	4606      	mov	r6, r0
  41029c:	b165      	cbz	r5, 4102b8 <_dtoa_r+0x420>
  41029e:	9806      	ldr	r0, [sp, #24]
  4102a0:	2800      	cmp	r0, #0
  4102a2:	dd09      	ble.n	4102b8 <_dtoa_r+0x420>
  4102a4:	4603      	mov	r3, r0
  4102a6:	9908      	ldr	r1, [sp, #32]
  4102a8:	42ab      	cmp	r3, r5
  4102aa:	bfa8      	it	ge
  4102ac:	462b      	movge	r3, r5
  4102ae:	1ac9      	subs	r1, r1, r3
  4102b0:	1ac0      	subs	r0, r0, r3
  4102b2:	9108      	str	r1, [sp, #32]
  4102b4:	1aed      	subs	r5, r5, r3
  4102b6:	9006      	str	r0, [sp, #24]
  4102b8:	9a0c      	ldr	r2, [sp, #48]	; 0x30
  4102ba:	2a00      	cmp	r2, #0
  4102bc:	dd1d      	ble.n	4102fa <_dtoa_r+0x462>
  4102be:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  4102c0:	2b00      	cmp	r3, #0
  4102c2:	f000 8358 	beq.w	410976 <_dtoa_r+0xade>
  4102c6:	2f00      	cmp	r7, #0
  4102c8:	dd11      	ble.n	4102ee <_dtoa_r+0x456>
  4102ca:	4631      	mov	r1, r6
  4102cc:	463a      	mov	r2, r7
  4102ce:	4620      	mov	r0, r4
  4102d0:	f001 fc70 	bl	411bb4 <__pow5mult>
  4102d4:	4606      	mov	r6, r0
  4102d6:	4631      	mov	r1, r6
  4102d8:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  4102da:	4620      	mov	r0, r4
  4102dc:	f001 fbcc 	bl	411a78 <__multiply>
  4102e0:	990a      	ldr	r1, [sp, #40]	; 0x28
  4102e2:	4680      	mov	r8, r0
  4102e4:	4620      	mov	r0, r4
  4102e6:	f001 facd 	bl	411884 <_Bfree>
  4102ea:	f8cd 8028 	str.w	r8, [sp, #40]	; 0x28
  4102ee:	f8dd e030 	ldr.w	lr, [sp, #48]	; 0x30
  4102f2:	ebbe 0207 	subs.w	r2, lr, r7
  4102f6:	f040 828f 	bne.w	410818 <_dtoa_r+0x980>
  4102fa:	4620      	mov	r0, r4
  4102fc:	2101      	movs	r1, #1
  4102fe:	f001 fbb1 	bl	411a64 <__i2b>
  410302:	4680      	mov	r8, r0
  410304:	980d      	ldr	r0, [sp, #52]	; 0x34
  410306:	2800      	cmp	r0, #0
  410308:	dd05      	ble.n	410316 <_dtoa_r+0x47e>
  41030a:	4641      	mov	r1, r8
  41030c:	4620      	mov	r0, r4
  41030e:	9a0d      	ldr	r2, [sp, #52]	; 0x34
  410310:	f001 fc50 	bl	411bb4 <__pow5mult>
  410314:	4680      	mov	r8, r0
  410316:	9924      	ldr	r1, [sp, #144]	; 0x90
  410318:	2901      	cmp	r1, #1
  41031a:	f340 82c1 	ble.w	4108a0 <_dtoa_r+0xa08>
  41031e:	2700      	movs	r7, #0
  410320:	980d      	ldr	r0, [sp, #52]	; 0x34
  410322:	2800      	cmp	r0, #0
  410324:	f040 82af 	bne.w	410886 <_dtoa_r+0x9ee>
  410328:	2001      	movs	r0, #1
  41032a:	9b06      	ldr	r3, [sp, #24]
  41032c:	4403      	add	r3, r0
  41032e:	f013 031f 	ands.w	r3, r3, #31
  410332:	f000 80a1 	beq.w	410478 <_dtoa_r+0x5e0>
  410336:	f1c3 0220 	rsb	r2, r3, #32
  41033a:	2a04      	cmp	r2, #4
  41033c:	f340 84b5 	ble.w	410caa <_dtoa_r+0xe12>
  410340:	9908      	ldr	r1, [sp, #32]
  410342:	9a06      	ldr	r2, [sp, #24]
  410344:	f1c3 031c 	rsb	r3, r3, #28
  410348:	4419      	add	r1, r3
  41034a:	441a      	add	r2, r3
  41034c:	9108      	str	r1, [sp, #32]
  41034e:	441d      	add	r5, r3
  410350:	9206      	str	r2, [sp, #24]
  410352:	9908      	ldr	r1, [sp, #32]
  410354:	2900      	cmp	r1, #0
  410356:	dd05      	ble.n	410364 <_dtoa_r+0x4cc>
  410358:	990a      	ldr	r1, [sp, #40]	; 0x28
  41035a:	9a08      	ldr	r2, [sp, #32]
  41035c:	4620      	mov	r0, r4
  41035e:	f001 fc77 	bl	411c50 <__lshift>
  410362:	900a      	str	r0, [sp, #40]	; 0x28
  410364:	9a06      	ldr	r2, [sp, #24]
  410366:	2a00      	cmp	r2, #0
  410368:	dd04      	ble.n	410374 <_dtoa_r+0x4dc>
  41036a:	4641      	mov	r1, r8
  41036c:	4620      	mov	r0, r4
  41036e:	f001 fc6f 	bl	411c50 <__lshift>
  410372:	4680      	mov	r8, r0
  410374:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  410376:	2b00      	cmp	r3, #0
  410378:	f040 826a 	bne.w	410850 <_dtoa_r+0x9b8>
  41037c:	f1b9 0f00 	cmp.w	r9, #0
  410380:	f340 82a6 	ble.w	4108d0 <_dtoa_r+0xa38>
  410384:	980b      	ldr	r0, [sp, #44]	; 0x2c
  410386:	2800      	cmp	r0, #0
  410388:	f040 8088 	bne.w	41049c <_dtoa_r+0x604>
  41038c:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
  41038e:	9f0a      	ldr	r7, [sp, #40]	; 0x28
  410390:	f8dd b024 	ldr.w	fp, [sp, #36]	; 0x24
  410394:	e006      	b.n	4103a4 <_dtoa_r+0x50c>
  410396:	4639      	mov	r1, r7
  410398:	4620      	mov	r0, r4
  41039a:	220a      	movs	r2, #10
  41039c:	2300      	movs	r3, #0
  41039e:	f001 fa7b 	bl	411898 <__multadd>
  4103a2:	4607      	mov	r7, r0
  4103a4:	4638      	mov	r0, r7
  4103a6:	4641      	mov	r1, r8
  4103a8:	f7ff fcde 	bl	40fd68 <quorem>
  4103ac:	3030      	adds	r0, #48	; 0x30
  4103ae:	f80b 0005 	strb.w	r0, [fp, r5]
  4103b2:	3501      	adds	r5, #1
  4103b4:	45a9      	cmp	r9, r5
  4103b6:	dcee      	bgt.n	410396 <_dtoa_r+0x4fe>
  4103b8:	f8dd b024 	ldr.w	fp, [sp, #36]	; 0x24
  4103bc:	970a      	str	r7, [sp, #40]	; 0x28
  4103be:	4682      	mov	sl, r0
  4103c0:	f1b9 0f01 	cmp.w	r9, #1
  4103c4:	bfac      	ite	ge
  4103c6:	44cb      	addge	fp, r9
  4103c8:	f10b 0b01 	addlt.w	fp, fp, #1
  4103cc:	2500      	movs	r5, #0
  4103ce:	990a      	ldr	r1, [sp, #40]	; 0x28
  4103d0:	2201      	movs	r2, #1
  4103d2:	4620      	mov	r0, r4
  4103d4:	f001 fc3c 	bl	411c50 <__lshift>
  4103d8:	4641      	mov	r1, r8
  4103da:	900a      	str	r0, [sp, #40]	; 0x28
  4103dc:	f001 fc96 	bl	411d0c <__mcmp>
  4103e0:	2800      	cmp	r0, #0
  4103e2:	f340 8309 	ble.w	4109f8 <_dtoa_r+0xb60>
  4103e6:	f81b 2c01 	ldrb.w	r2, [fp, #-1]
  4103ea:	9909      	ldr	r1, [sp, #36]	; 0x24
  4103ec:	e005      	b.n	4103fa <_dtoa_r+0x562>
  4103ee:	4299      	cmp	r1, r3
  4103f0:	f000 828b 	beq.w	41090a <_dtoa_r+0xa72>
  4103f4:	f813 2c01 	ldrb.w	r2, [r3, #-1]
  4103f8:	469b      	mov	fp, r3
  4103fa:	2a39      	cmp	r2, #57	; 0x39
  4103fc:	f10b 33ff 	add.w	r3, fp, #4294967295
  410400:	d0f5      	beq.n	4103ee <_dtoa_r+0x556>
  410402:	3201      	adds	r2, #1
  410404:	701a      	strb	r2, [r3, #0]
  410406:	4641      	mov	r1, r8
  410408:	4620      	mov	r0, r4
  41040a:	f001 fa3b 	bl	411884 <_Bfree>
  41040e:	2e00      	cmp	r6, #0
  410410:	f43f af0f 	beq.w	410232 <_dtoa_r+0x39a>
  410414:	b12d      	cbz	r5, 410422 <_dtoa_r+0x58a>
  410416:	42b5      	cmp	r5, r6
  410418:	d003      	beq.n	410422 <_dtoa_r+0x58a>
  41041a:	4629      	mov	r1, r5
  41041c:	4620      	mov	r0, r4
  41041e:	f001 fa31 	bl	411884 <_Bfree>
  410422:	4631      	mov	r1, r6
  410424:	4620      	mov	r0, r4
  410426:	f001 fa2d 	bl	411884 <_Bfree>
  41042a:	e702      	b.n	410232 <_dtoa_r+0x39a>
  41042c:	2601      	movs	r6, #1
  41042e:	960e      	str	r6, [sp, #56]	; 0x38
  410430:	e5eb      	b.n	41000a <_dtoa_r+0x172>
  410432:	9807      	ldr	r0, [sp, #28]
  410434:	f004 faf6 	bl	414a24 <__aeabi_i2d>
  410438:	4632      	mov	r2, r6
  41043a:	463b      	mov	r3, r7
  41043c:	f004 fdc0 	bl	414fc0 <__aeabi_dcmpeq>
  410440:	2800      	cmp	r0, #0
  410442:	f47f adce 	bne.w	40ffe2 <_dtoa_r+0x14a>
  410446:	9e07      	ldr	r6, [sp, #28]
  410448:	3e01      	subs	r6, #1
  41044a:	9607      	str	r6, [sp, #28]
  41044c:	e5c9      	b.n	40ffe2 <_dtoa_r+0x14a>
  41044e:	9e07      	ldr	r6, [sp, #28]
  410450:	9d08      	ldr	r5, [sp, #32]
  410452:	1bad      	subs	r5, r5, r6
  410454:	9508      	str	r5, [sp, #32]
  410456:	4275      	negs	r5, r6
  410458:	2600      	movs	r6, #0
  41045a:	950c      	str	r5, [sp, #48]	; 0x30
  41045c:	960d      	str	r6, [sp, #52]	; 0x34
  41045e:	e5e6      	b.n	41002e <_dtoa_r+0x196>
  410460:	426d      	negs	r5, r5
  410462:	2600      	movs	r6, #0
  410464:	9508      	str	r5, [sp, #32]
  410466:	9606      	str	r6, [sp, #24]
  410468:	e5d7      	b.n	41001a <_dtoa_r+0x182>
  41046a:	9f0c      	ldr	r7, [sp, #48]	; 0x30
  41046c:	9d08      	ldr	r5, [sp, #32]
  41046e:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
  410470:	e714      	b.n	41029c <_dtoa_r+0x404>
  410472:	bf00      	nop
  410474:	40240000 	.word	0x40240000
  410478:	231c      	movs	r3, #28
  41047a:	f8dd e020 	ldr.w	lr, [sp, #32]
  41047e:	9806      	ldr	r0, [sp, #24]
  410480:	449e      	add	lr, r3
  410482:	4418      	add	r0, r3
  410484:	f8cd e020 	str.w	lr, [sp, #32]
  410488:	441d      	add	r5, r3
  41048a:	9006      	str	r0, [sp, #24]
  41048c:	e761      	b.n	410352 <_dtoa_r+0x4ba>
  41048e:	48a7      	ldr	r0, [pc, #668]	; (41072c <_dtoa_r+0x894>)
  410490:	1b40      	subs	r0, r0, r5
  410492:	fa0a f000 	lsl.w	r0, sl, r0
  410496:	e570      	b.n	40ff7a <_dtoa_r+0xe2>
  410498:	900e      	str	r0, [sp, #56]	; 0x38
  41049a:	e5b6      	b.n	41000a <_dtoa_r+0x172>
  41049c:	2d00      	cmp	r5, #0
  41049e:	dd05      	ble.n	4104ac <_dtoa_r+0x614>
  4104a0:	4631      	mov	r1, r6
  4104a2:	462a      	mov	r2, r5
  4104a4:	4620      	mov	r0, r4
  4104a6:	f001 fbd3 	bl	411c50 <__lshift>
  4104aa:	4606      	mov	r6, r0
  4104ac:	2f00      	cmp	r7, #0
  4104ae:	f040 82e8 	bne.w	410a82 <_dtoa_r+0xbea>
  4104b2:	4637      	mov	r7, r6
  4104b4:	9d09      	ldr	r5, [sp, #36]	; 0x24
  4104b6:	9809      	ldr	r0, [sp, #36]	; 0x24
  4104b8:	444d      	add	r5, r9
  4104ba:	9508      	str	r5, [sp, #32]
  4104bc:	f00a 0501 	and.w	r5, sl, #1
  4104c0:	950b      	str	r5, [sp, #44]	; 0x2c
  4104c2:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
  4104c6:	1c45      	adds	r5, r0, #1
  4104c8:	e00a      	b.n	4104e0 <_dtoa_r+0x648>
  4104ca:	f001 f9e5 	bl	411898 <__multadd>
  4104ce:	4639      	mov	r1, r7
  4104d0:	4606      	mov	r6, r0
  4104d2:	220a      	movs	r2, #10
  4104d4:	4620      	mov	r0, r4
  4104d6:	2300      	movs	r3, #0
  4104d8:	f001 f9de 	bl	411898 <__multadd>
  4104dc:	4607      	mov	r7, r0
  4104de:	3501      	adds	r5, #1
  4104e0:	4641      	mov	r1, r8
  4104e2:	4648      	mov	r0, r9
  4104e4:	f7ff fc40 	bl	40fd68 <quorem>
  4104e8:	4631      	mov	r1, r6
  4104ea:	4683      	mov	fp, r0
  4104ec:	4648      	mov	r0, r9
  4104ee:	f001 fc0d 	bl	411d0c <__mcmp>
  4104f2:	4641      	mov	r1, r8
  4104f4:	9003      	str	r0, [sp, #12]
  4104f6:	463a      	mov	r2, r7
  4104f8:	4620      	mov	r0, r4
  4104fa:	f001 fc2b 	bl	411d54 <__mdiff>
  4104fe:	68c2      	ldr	r2, [r0, #12]
  410500:	1e69      	subs	r1, r5, #1
  410502:	4603      	mov	r3, r0
  410504:	f10b 0a30 	add.w	sl, fp, #48	; 0x30
  410508:	9106      	str	r1, [sp, #24]
  41050a:	2a00      	cmp	r2, #0
  41050c:	f040 8193 	bne.w	410836 <_dtoa_r+0x99e>
  410510:	4619      	mov	r1, r3
  410512:	4648      	mov	r0, r9
  410514:	9302      	str	r3, [sp, #8]
  410516:	f001 fbf9 	bl	411d0c <__mcmp>
  41051a:	9b02      	ldr	r3, [sp, #8]
  41051c:	4602      	mov	r2, r0
  41051e:	4619      	mov	r1, r3
  410520:	4620      	mov	r0, r4
  410522:	9202      	str	r2, [sp, #8]
  410524:	f001 f9ae 	bl	411884 <_Bfree>
  410528:	9a02      	ldr	r2, [sp, #8]
  41052a:	b92a      	cbnz	r2, 410538 <_dtoa_r+0x6a0>
  41052c:	9b24      	ldr	r3, [sp, #144]	; 0x90
  41052e:	b91b      	cbnz	r3, 410538 <_dtoa_r+0x6a0>
  410530:	980b      	ldr	r0, [sp, #44]	; 0x2c
  410532:	2800      	cmp	r0, #0
  410534:	f000 8391 	beq.w	410c5a <_dtoa_r+0xdc2>
  410538:	9b03      	ldr	r3, [sp, #12]
  41053a:	2b00      	cmp	r3, #0
  41053c:	f2c0 8234 	blt.w	4109a8 <_dtoa_r+0xb10>
  410540:	d105      	bne.n	41054e <_dtoa_r+0x6b6>
  410542:	9824      	ldr	r0, [sp, #144]	; 0x90
  410544:	b918      	cbnz	r0, 41054e <_dtoa_r+0x6b6>
  410546:	990b      	ldr	r1, [sp, #44]	; 0x2c
  410548:	2900      	cmp	r1, #0
  41054a:	f000 822d 	beq.w	4109a8 <_dtoa_r+0xb10>
  41054e:	2a00      	cmp	r2, #0
  410550:	f300 82ab 	bgt.w	410aaa <_dtoa_r+0xc12>
  410554:	f8dd e020 	ldr.w	lr, [sp, #32]
  410558:	f805 ac01 	strb.w	sl, [r5, #-1]
  41055c:	4575      	cmp	r5, lr
  41055e:	46ab      	mov	fp, r5
  410560:	f000 82b3 	beq.w	410aca <_dtoa_r+0xc32>
  410564:	4649      	mov	r1, r9
  410566:	220a      	movs	r2, #10
  410568:	2300      	movs	r3, #0
  41056a:	4620      	mov	r0, r4
  41056c:	f001 f994 	bl	411898 <__multadd>
  410570:	42be      	cmp	r6, r7
  410572:	4681      	mov	r9, r0
  410574:	4631      	mov	r1, r6
  410576:	4620      	mov	r0, r4
  410578:	f04f 020a 	mov.w	r2, #10
  41057c:	f04f 0300 	mov.w	r3, #0
  410580:	d1a3      	bne.n	4104ca <_dtoa_r+0x632>
  410582:	f001 f989 	bl	411898 <__multadd>
  410586:	4606      	mov	r6, r0
  410588:	4607      	mov	r7, r0
  41058a:	e7a8      	b.n	4104de <_dtoa_r+0x646>
  41058c:	2600      	movs	r6, #0
  41058e:	960b      	str	r6, [sp, #44]	; 0x2c
  410590:	9e07      	ldr	r6, [sp, #28]
  410592:	f8dd e094 	ldr.w	lr, [sp, #148]	; 0x94
  410596:	44b6      	add	lr, r6
  410598:	f10e 0901 	add.w	r9, lr, #1
  41059c:	f1b9 0f00 	cmp.w	r9, #0
  4105a0:	f8cd e03c 	str.w	lr, [sp, #60]	; 0x3c
  4105a4:	464e      	mov	r6, r9
  4105a6:	f340 8150 	ble.w	41084a <_dtoa_r+0x9b2>
  4105aa:	2100      	movs	r1, #0
  4105ac:	2e17      	cmp	r6, #23
  4105ae:	6461      	str	r1, [r4, #68]	; 0x44
  4105b0:	d90a      	bls.n	4105c8 <_dtoa_r+0x730>
  4105b2:	2201      	movs	r2, #1
  4105b4:	2304      	movs	r3, #4
  4105b6:	005b      	lsls	r3, r3, #1
  4105b8:	f103 0014 	add.w	r0, r3, #20
  4105bc:	42b0      	cmp	r0, r6
  4105be:	4611      	mov	r1, r2
  4105c0:	f102 0201 	add.w	r2, r2, #1
  4105c4:	d9f7      	bls.n	4105b6 <_dtoa_r+0x71e>
  4105c6:	6461      	str	r1, [r4, #68]	; 0x44
  4105c8:	4620      	mov	r0, r4
  4105ca:	f001 f935 	bl	411838 <_Balloc>
  4105ce:	2e0e      	cmp	r6, #14
  4105d0:	9009      	str	r0, [sp, #36]	; 0x24
  4105d2:	6420      	str	r0, [r4, #64]	; 0x40
  4105d4:	f63f ad6c 	bhi.w	4100b0 <_dtoa_r+0x218>
  4105d8:	2d00      	cmp	r5, #0
  4105da:	f43f ad69 	beq.w	4100b0 <_dtoa_r+0x218>
  4105de:	9d07      	ldr	r5, [sp, #28]
  4105e0:	2d00      	cmp	r5, #0
  4105e2:	e9cd ab12 	strd	sl, fp, [sp, #72]	; 0x48
  4105e6:	f340 821b 	ble.w	410a20 <_dtoa_r+0xb88>
  4105ea:	4b51      	ldr	r3, [pc, #324]	; (410730 <_dtoa_r+0x898>)
  4105ec:	f005 020f 	and.w	r2, r5, #15
  4105f0:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
  4105f4:	112d      	asrs	r5, r5, #4
  4105f6:	e9d3 6700 	ldrd	r6, r7, [r3]
  4105fa:	06eb      	lsls	r3, r5, #27
  4105fc:	f140 81cd 	bpl.w	41099a <_dtoa_r+0xb02>
  410600:	4b4c      	ldr	r3, [pc, #304]	; (410734 <_dtoa_r+0x89c>)
  410602:	4650      	mov	r0, sl
  410604:	4659      	mov	r1, fp
  410606:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
  41060a:	f004 fb9b 	bl	414d44 <__aeabi_ddiv>
  41060e:	e9cd 0110 	strd	r0, r1, [sp, #64]	; 0x40
  410612:	f005 050f 	and.w	r5, r5, #15
  410616:	f04f 0803 	mov.w	r8, #3
  41061a:	b18d      	cbz	r5, 410640 <_dtoa_r+0x7a8>
  41061c:	f8df a114 	ldr.w	sl, [pc, #276]	; 410734 <_dtoa_r+0x89c>
  410620:	4630      	mov	r0, r6
  410622:	4639      	mov	r1, r7
  410624:	07ee      	lsls	r6, r5, #31
  410626:	d505      	bpl.n	410634 <_dtoa_r+0x79c>
  410628:	e9da 2300 	ldrd	r2, r3, [sl]
  41062c:	f108 0801 	add.w	r8, r8, #1
  410630:	f004 fa5e 	bl	414af0 <__aeabi_dmul>
  410634:	106d      	asrs	r5, r5, #1
  410636:	f10a 0a08 	add.w	sl, sl, #8
  41063a:	d1f3      	bne.n	410624 <_dtoa_r+0x78c>
  41063c:	4606      	mov	r6, r0
  41063e:	460f      	mov	r7, r1
  410640:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
  410644:	4632      	mov	r2, r6
  410646:	463b      	mov	r3, r7
  410648:	f004 fb7c 	bl	414d44 <__aeabi_ddiv>
  41064c:	4682      	mov	sl, r0
  41064e:	468b      	mov	fp, r1
  410650:	9d0e      	ldr	r5, [sp, #56]	; 0x38
  410652:	b145      	cbz	r5, 410666 <_dtoa_r+0x7ce>
  410654:	4650      	mov	r0, sl
  410656:	4659      	mov	r1, fp
  410658:	2200      	movs	r2, #0
  41065a:	4b37      	ldr	r3, [pc, #220]	; (410738 <_dtoa_r+0x8a0>)
  41065c:	f004 fcba 	bl	414fd4 <__aeabi_dcmplt>
  410660:	2800      	cmp	r0, #0
  410662:	f040 82a9 	bne.w	410bb8 <_dtoa_r+0xd20>
  410666:	4640      	mov	r0, r8
  410668:	f004 f9dc 	bl	414a24 <__aeabi_i2d>
  41066c:	4652      	mov	r2, sl
  41066e:	465b      	mov	r3, fp
  410670:	f004 fa3e 	bl	414af0 <__aeabi_dmul>
  410674:	2200      	movs	r2, #0
  410676:	4b31      	ldr	r3, [pc, #196]	; (41073c <_dtoa_r+0x8a4>)
  410678:	f004 f888 	bl	41478c <__adddf3>
  41067c:	4606      	mov	r6, r0
  41067e:	f1a1 7750 	sub.w	r7, r1, #54525952	; 0x3400000
  410682:	f1b9 0f00 	cmp.w	r9, #0
  410686:	f000 815a 	beq.w	41093e <_dtoa_r+0xaa6>
  41068a:	9d07      	ldr	r5, [sp, #28]
  41068c:	9517      	str	r5, [sp, #92]	; 0x5c
  41068e:	46c8      	mov	r8, r9
  410690:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
  410692:	2d00      	cmp	r5, #0
  410694:	f000 8222 	beq.w	410adc <_dtoa_r+0xc44>
  410698:	4b25      	ldr	r3, [pc, #148]	; (410730 <_dtoa_r+0x898>)
  41069a:	4929      	ldr	r1, [pc, #164]	; (410740 <_dtoa_r+0x8a8>)
  41069c:	eb03 03c8 	add.w	r3, r3, r8, lsl #3
  4106a0:	e953 2302 	ldrd	r2, r3, [r3, #-8]
  4106a4:	2000      	movs	r0, #0
  4106a6:	f004 fb4d 	bl	414d44 <__aeabi_ddiv>
  4106aa:	4632      	mov	r2, r6
  4106ac:	463b      	mov	r3, r7
  4106ae:	f004 f86b 	bl	414788 <__aeabi_dsub>
  4106b2:	e9cd 0110 	strd	r0, r1, [sp, #64]	; 0x40
  4106b6:	4659      	mov	r1, fp
  4106b8:	4650      	mov	r0, sl
  4106ba:	f004 fcb3 	bl	415024 <__aeabi_d2iz>
  4106be:	4605      	mov	r5, r0
  4106c0:	f004 f9b0 	bl	414a24 <__aeabi_i2d>
  4106c4:	4602      	mov	r2, r0
  4106c6:	460b      	mov	r3, r1
  4106c8:	4650      	mov	r0, sl
  4106ca:	4659      	mov	r1, fp
  4106cc:	f004 f85c 	bl	414788 <__aeabi_dsub>
  4106d0:	3530      	adds	r5, #48	; 0x30
  4106d2:	9e09      	ldr	r6, [sp, #36]	; 0x24
  4106d4:	e9cd 0104 	strd	r0, r1, [sp, #16]
  4106d8:	b2ed      	uxtb	r5, r5
  4106da:	7035      	strb	r5, [r6, #0]
  4106dc:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
  4106e0:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
  4106e4:	f106 0b01 	add.w	fp, r6, #1
  4106e8:	f004 fc92 	bl	415010 <__aeabi_dcmpgt>
  4106ec:	2800      	cmp	r0, #0
  4106ee:	f040 82a9 	bne.w	410c44 <_dtoa_r+0xdac>
  4106f2:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
  4106f6:	2000      	movs	r0, #0
  4106f8:	490f      	ldr	r1, [pc, #60]	; (410738 <_dtoa_r+0x8a0>)
  4106fa:	f004 f845 	bl	414788 <__aeabi_dsub>
  4106fe:	4602      	mov	r2, r0
  410700:	460b      	mov	r3, r1
  410702:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
  410706:	f004 fc83 	bl	415010 <__aeabi_dcmpgt>
  41070a:	2800      	cmp	r0, #0
  41070c:	f040 82a0 	bne.w	410c50 <_dtoa_r+0xdb8>
  410710:	f1b8 0f01 	cmp.w	r8, #1
  410714:	f340 8180 	ble.w	410a18 <_dtoa_r+0xb80>
  410718:	44b0      	add	r8, r6
  41071a:	f8cd 9050 	str.w	r9, [sp, #80]	; 0x50
  41071e:	46a2      	mov	sl, r4
  410720:	46c1      	mov	r9, r8
  410722:	e9dd 6704 	ldrd	r6, r7, [sp, #16]
  410726:	e9dd 4510 	ldrd	r4, r5, [sp, #64]	; 0x40
  41072a:	e019      	b.n	410760 <_dtoa_r+0x8c8>
  41072c:	fffffbee 	.word	0xfffffbee
  410730:	00417010 	.word	0x00417010
  410734:	004170d8 	.word	0x004170d8
  410738:	3ff00000 	.word	0x3ff00000
  41073c:	401c0000 	.word	0x401c0000
  410740:	3fe00000 	.word	0x3fe00000
  410744:	2000      	movs	r0, #0
  410746:	49a8      	ldr	r1, [pc, #672]	; (4109e8 <_dtoa_r+0xb50>)
  410748:	f004 f81e 	bl	414788 <__aeabi_dsub>
  41074c:	4622      	mov	r2, r4
  41074e:	462b      	mov	r3, r5
  410750:	f004 fc40 	bl	414fd4 <__aeabi_dcmplt>
  410754:	2800      	cmp	r0, #0
  410756:	f040 8279 	bne.w	410c4c <_dtoa_r+0xdb4>
  41075a:	45cb      	cmp	fp, r9
  41075c:	f000 8159 	beq.w	410a12 <_dtoa_r+0xb7a>
  410760:	4620      	mov	r0, r4
  410762:	4629      	mov	r1, r5
  410764:	2200      	movs	r2, #0
  410766:	4ba1      	ldr	r3, [pc, #644]	; (4109ec <_dtoa_r+0xb54>)
  410768:	f004 f9c2 	bl	414af0 <__aeabi_dmul>
  41076c:	2200      	movs	r2, #0
  41076e:	4b9f      	ldr	r3, [pc, #636]	; (4109ec <_dtoa_r+0xb54>)
  410770:	4604      	mov	r4, r0
  410772:	460d      	mov	r5, r1
  410774:	4630      	mov	r0, r6
  410776:	4639      	mov	r1, r7
  410778:	f004 f9ba 	bl	414af0 <__aeabi_dmul>
  41077c:	460f      	mov	r7, r1
  41077e:	4606      	mov	r6, r0
  410780:	f004 fc50 	bl	415024 <__aeabi_d2iz>
  410784:	4680      	mov	r8, r0
  410786:	f004 f94d 	bl	414a24 <__aeabi_i2d>
  41078a:	4602      	mov	r2, r0
  41078c:	460b      	mov	r3, r1
  41078e:	4630      	mov	r0, r6
  410790:	4639      	mov	r1, r7
  410792:	f003 fff9 	bl	414788 <__aeabi_dsub>
  410796:	f108 0830 	add.w	r8, r8, #48	; 0x30
  41079a:	fa5f f888 	uxtb.w	r8, r8
  41079e:	4622      	mov	r2, r4
  4107a0:	462b      	mov	r3, r5
  4107a2:	f80b 8b01 	strb.w	r8, [fp], #1
  4107a6:	4606      	mov	r6, r0
  4107a8:	460f      	mov	r7, r1
  4107aa:	f004 fc13 	bl	414fd4 <__aeabi_dcmplt>
  4107ae:	4632      	mov	r2, r6
  4107b0:	463b      	mov	r3, r7
  4107b2:	2800      	cmp	r0, #0
  4107b4:	d0c6      	beq.n	410744 <_dtoa_r+0x8ac>
  4107b6:	9e17      	ldr	r6, [sp, #92]	; 0x5c
  4107b8:	9607      	str	r6, [sp, #28]
  4107ba:	4654      	mov	r4, sl
  4107bc:	e539      	b.n	410232 <_dtoa_r+0x39a>
  4107be:	2600      	movs	r6, #0
  4107c0:	960b      	str	r6, [sp, #44]	; 0x2c
  4107c2:	9825      	ldr	r0, [sp, #148]	; 0x94
  4107c4:	2800      	cmp	r0, #0
  4107c6:	dd3c      	ble.n	410842 <_dtoa_r+0x9aa>
  4107c8:	4606      	mov	r6, r0
  4107ca:	900f      	str	r0, [sp, #60]	; 0x3c
  4107cc:	4681      	mov	r9, r0
  4107ce:	e6ec      	b.n	4105aa <_dtoa_r+0x712>
  4107d0:	2601      	movs	r6, #1
  4107d2:	960b      	str	r6, [sp, #44]	; 0x2c
  4107d4:	e7f5      	b.n	4107c2 <_dtoa_r+0x92a>
  4107d6:	f1b9 0f00 	cmp.w	r9, #0
  4107da:	f73f ac7c 	bgt.w	4100d6 <_dtoa_r+0x23e>
  4107de:	f040 80c6 	bne.w	41096e <_dtoa_r+0xad6>
  4107e2:	2200      	movs	r2, #0
  4107e4:	4b82      	ldr	r3, [pc, #520]	; (4109f0 <_dtoa_r+0xb58>)
  4107e6:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
  4107ea:	f004 f981 	bl	414af0 <__aeabi_dmul>
  4107ee:	4652      	mov	r2, sl
  4107f0:	465b      	mov	r3, fp
  4107f2:	f004 fc03 	bl	414ffc <__aeabi_dcmpge>
  4107f6:	46c8      	mov	r8, r9
  4107f8:	464e      	mov	r6, r9
  4107fa:	2800      	cmp	r0, #0
  4107fc:	d07c      	beq.n	4108f8 <_dtoa_r+0xa60>
  4107fe:	9d25      	ldr	r5, [sp, #148]	; 0x94
  410800:	f8dd b024 	ldr.w	fp, [sp, #36]	; 0x24
  410804:	43ed      	mvns	r5, r5
  410806:	9507      	str	r5, [sp, #28]
  410808:	4641      	mov	r1, r8
  41080a:	4620      	mov	r0, r4
  41080c:	f001 f83a 	bl	411884 <_Bfree>
  410810:	2e00      	cmp	r6, #0
  410812:	f47f ae06 	bne.w	410422 <_dtoa_r+0x58a>
  410816:	e50c      	b.n	410232 <_dtoa_r+0x39a>
  410818:	990a      	ldr	r1, [sp, #40]	; 0x28
  41081a:	4620      	mov	r0, r4
  41081c:	f001 f9ca 	bl	411bb4 <__pow5mult>
  410820:	900a      	str	r0, [sp, #40]	; 0x28
  410822:	e56a      	b.n	4102fa <_dtoa_r+0x462>
  410824:	9d16      	ldr	r5, [sp, #88]	; 0x58
  410826:	2d00      	cmp	r5, #0
  410828:	f000 81b7 	beq.w	410b9a <_dtoa_r+0xd02>
  41082c:	f203 4333 	addw	r3, r3, #1075	; 0x433
  410830:	9f0c      	ldr	r7, [sp, #48]	; 0x30
  410832:	9d08      	ldr	r5, [sp, #32]
  410834:	e527      	b.n	410286 <_dtoa_r+0x3ee>
  410836:	4601      	mov	r1, r0
  410838:	4620      	mov	r0, r4
  41083a:	f001 f823 	bl	411884 <_Bfree>
  41083e:	2201      	movs	r2, #1
  410840:	e67a      	b.n	410538 <_dtoa_r+0x6a0>
  410842:	2601      	movs	r6, #1
  410844:	9625      	str	r6, [sp, #148]	; 0x94
  410846:	960f      	str	r6, [sp, #60]	; 0x3c
  410848:	46b1      	mov	r9, r6
  41084a:	2100      	movs	r1, #0
  41084c:	6461      	str	r1, [r4, #68]	; 0x44
  41084e:	e6bb      	b.n	4105c8 <_dtoa_r+0x730>
  410850:	980a      	ldr	r0, [sp, #40]	; 0x28
  410852:	4641      	mov	r1, r8
  410854:	f001 fa5a 	bl	411d0c <__mcmp>
  410858:	2800      	cmp	r0, #0
  41085a:	f6bf ad8f 	bge.w	41037c <_dtoa_r+0x4e4>
  41085e:	f8dd e01c 	ldr.w	lr, [sp, #28]
  410862:	990a      	ldr	r1, [sp, #40]	; 0x28
  410864:	f10e 3eff 	add.w	lr, lr, #4294967295
  410868:	4620      	mov	r0, r4
  41086a:	220a      	movs	r2, #10
  41086c:	2300      	movs	r3, #0
  41086e:	f8cd e01c 	str.w	lr, [sp, #28]
  410872:	f001 f811 	bl	411898 <__multadd>
  410876:	900a      	str	r0, [sp, #40]	; 0x28
  410878:	980b      	ldr	r0, [sp, #44]	; 0x2c
  41087a:	2800      	cmp	r0, #0
  41087c:	f040 8207 	bne.w	410c8e <_dtoa_r+0xdf6>
  410880:	f8dd 903c 	ldr.w	r9, [sp, #60]	; 0x3c
  410884:	e57a      	b.n	41037c <_dtoa_r+0x4e4>
  410886:	f8d8 3010 	ldr.w	r3, [r8, #16]
  41088a:	eb08 0383 	add.w	r3, r8, r3, lsl #2
  41088e:	6918      	ldr	r0, [r3, #16]
  410890:	f001 f89a 	bl	4119c8 <__hi0bits>
  410894:	f1c0 0020 	rsb	r0, r0, #32
  410898:	e547      	b.n	41032a <_dtoa_r+0x492>
  41089a:	9809      	ldr	r0, [sp, #36]	; 0x24
  41089c:	f7ff bb2d 	b.w	40fefa <_dtoa_r+0x62>
  4108a0:	f1ba 0f00 	cmp.w	sl, #0
  4108a4:	f47f ad3b 	bne.w	41031e <_dtoa_r+0x486>
  4108a8:	f3cb 0313 	ubfx	r3, fp, #0, #20
  4108ac:	2b00      	cmp	r3, #0
  4108ae:	f040 817b 	bne.w	410ba8 <_dtoa_r+0xd10>
  4108b2:	f02b 4700 	bic.w	r7, fp, #2147483648	; 0x80000000
  4108b6:	0d3f      	lsrs	r7, r7, #20
  4108b8:	053f      	lsls	r7, r7, #20
  4108ba:	2f00      	cmp	r7, #0
  4108bc:	f43f ad30 	beq.w	410320 <_dtoa_r+0x488>
  4108c0:	9a08      	ldr	r2, [sp, #32]
  4108c2:	9b06      	ldr	r3, [sp, #24]
  4108c4:	3201      	adds	r2, #1
  4108c6:	3301      	adds	r3, #1
  4108c8:	9208      	str	r2, [sp, #32]
  4108ca:	9306      	str	r3, [sp, #24]
  4108cc:	2701      	movs	r7, #1
  4108ce:	e527      	b.n	410320 <_dtoa_r+0x488>
  4108d0:	9924      	ldr	r1, [sp, #144]	; 0x90
  4108d2:	2902      	cmp	r1, #2
  4108d4:	f77f ad56 	ble.w	410384 <_dtoa_r+0x4ec>
  4108d8:	f1b9 0f00 	cmp.w	r9, #0
  4108dc:	d18f      	bne.n	4107fe <_dtoa_r+0x966>
  4108de:	4641      	mov	r1, r8
  4108e0:	464b      	mov	r3, r9
  4108e2:	2205      	movs	r2, #5
  4108e4:	4620      	mov	r0, r4
  4108e6:	f000 ffd7 	bl	411898 <__multadd>
  4108ea:	4680      	mov	r8, r0
  4108ec:	4641      	mov	r1, r8
  4108ee:	980a      	ldr	r0, [sp, #40]	; 0x28
  4108f0:	f001 fa0c 	bl	411d0c <__mcmp>
  4108f4:	2800      	cmp	r0, #0
  4108f6:	dd82      	ble.n	4107fe <_dtoa_r+0x966>
  4108f8:	9d07      	ldr	r5, [sp, #28]
  4108fa:	3501      	adds	r5, #1
  4108fc:	9507      	str	r5, [sp, #28]
  4108fe:	9d09      	ldr	r5, [sp, #36]	; 0x24
  410900:	2331      	movs	r3, #49	; 0x31
  410902:	702b      	strb	r3, [r5, #0]
  410904:	f105 0b01 	add.w	fp, r5, #1
  410908:	e77e      	b.n	410808 <_dtoa_r+0x970>
  41090a:	9807      	ldr	r0, [sp, #28]
  41090c:	9909      	ldr	r1, [sp, #36]	; 0x24
  41090e:	2331      	movs	r3, #49	; 0x31
  410910:	3001      	adds	r0, #1
  410912:	9007      	str	r0, [sp, #28]
  410914:	700b      	strb	r3, [r1, #0]
  410916:	e576      	b.n	410406 <_dtoa_r+0x56e>
  410918:	46a3      	mov	fp, r4
  41091a:	9c03      	ldr	r4, [sp, #12]
  41091c:	e489      	b.n	410232 <_dtoa_r+0x39a>
  41091e:	4640      	mov	r0, r8
  410920:	f004 f880 	bl	414a24 <__aeabi_i2d>
  410924:	4602      	mov	r2, r0
  410926:	460b      	mov	r3, r1
  410928:	4650      	mov	r0, sl
  41092a:	4659      	mov	r1, fp
  41092c:	f004 f8e0 	bl	414af0 <__aeabi_dmul>
  410930:	2200      	movs	r2, #0
  410932:	4b30      	ldr	r3, [pc, #192]	; (4109f4 <_dtoa_r+0xb5c>)
  410934:	f003 ff2a 	bl	41478c <__adddf3>
  410938:	4606      	mov	r6, r0
  41093a:	f1a1 7750 	sub.w	r7, r1, #54525952	; 0x3400000
  41093e:	4650      	mov	r0, sl
  410940:	4659      	mov	r1, fp
  410942:	2200      	movs	r2, #0
  410944:	4b2a      	ldr	r3, [pc, #168]	; (4109f0 <_dtoa_r+0xb58>)
  410946:	f003 ff1f 	bl	414788 <__aeabi_dsub>
  41094a:	4632      	mov	r2, r6
  41094c:	463b      	mov	r3, r7
  41094e:	4682      	mov	sl, r0
  410950:	468b      	mov	fp, r1
  410952:	f004 fb5d 	bl	415010 <__aeabi_dcmpgt>
  410956:	2800      	cmp	r0, #0
  410958:	f040 80bc 	bne.w	410ad4 <_dtoa_r+0xc3c>
  41095c:	4632      	mov	r2, r6
  41095e:	f107 4300 	add.w	r3, r7, #2147483648	; 0x80000000
  410962:	4650      	mov	r0, sl
  410964:	4659      	mov	r1, fp
  410966:	f004 fb35 	bl	414fd4 <__aeabi_dcmplt>
  41096a:	2800      	cmp	r0, #0
  41096c:	d054      	beq.n	410a18 <_dtoa_r+0xb80>
  41096e:	f04f 0800 	mov.w	r8, #0
  410972:	4646      	mov	r6, r8
  410974:	e743      	b.n	4107fe <_dtoa_r+0x966>
  410976:	990a      	ldr	r1, [sp, #40]	; 0x28
  410978:	9a0c      	ldr	r2, [sp, #48]	; 0x30
  41097a:	4620      	mov	r0, r4
  41097c:	f001 f91a 	bl	411bb4 <__pow5mult>
  410980:	900a      	str	r0, [sp, #40]	; 0x28
  410982:	e4ba      	b.n	4102fa <_dtoa_r+0x462>
  410984:	2601      	movs	r6, #1
  410986:	960b      	str	r6, [sp, #44]	; 0x2c
  410988:	e602      	b.n	410590 <_dtoa_r+0x6f8>
  41098a:	9d0c      	ldr	r5, [sp, #48]	; 0x30
  41098c:	9e0d      	ldr	r6, [sp, #52]	; 0x34
  41098e:	970c      	str	r7, [sp, #48]	; 0x30
  410990:	1b7b      	subs	r3, r7, r5
  410992:	441e      	add	r6, r3
  410994:	960d      	str	r6, [sp, #52]	; 0x34
  410996:	2700      	movs	r7, #0
  410998:	e46f      	b.n	41027a <_dtoa_r+0x3e2>
  41099a:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
  41099e:	f04f 0802 	mov.w	r8, #2
  4109a2:	e9cd 0110 	strd	r0, r1, [sp, #64]	; 0x40
  4109a6:	e638      	b.n	41061a <_dtoa_r+0x782>
  4109a8:	2a00      	cmp	r2, #0
  4109aa:	f8cd 9028 	str.w	r9, [sp, #40]	; 0x28
  4109ae:	46d9      	mov	r9, fp
  4109b0:	dd11      	ble.n	4109d6 <_dtoa_r+0xb3e>
  4109b2:	990a      	ldr	r1, [sp, #40]	; 0x28
  4109b4:	2201      	movs	r2, #1
  4109b6:	4620      	mov	r0, r4
  4109b8:	f001 f94a 	bl	411c50 <__lshift>
  4109bc:	4641      	mov	r1, r8
  4109be:	900a      	str	r0, [sp, #40]	; 0x28
  4109c0:	f001 f9a4 	bl	411d0c <__mcmp>
  4109c4:	2800      	cmp	r0, #0
  4109c6:	f340 815b 	ble.w	410c80 <_dtoa_r+0xde8>
  4109ca:	f1ba 0f39 	cmp.w	sl, #57	; 0x39
  4109ce:	f000 811a 	beq.w	410c06 <_dtoa_r+0xd6e>
  4109d2:	f109 0a31 	add.w	sl, r9, #49	; 0x31
  4109d6:	9b06      	ldr	r3, [sp, #24]
  4109d8:	4635      	mov	r5, r6
  4109da:	f883 a000 	strb.w	sl, [r3]
  4109de:	f103 0b01 	add.w	fp, r3, #1
  4109e2:	463e      	mov	r6, r7
  4109e4:	e50f      	b.n	410406 <_dtoa_r+0x56e>
  4109e6:	bf00      	nop
  4109e8:	3ff00000 	.word	0x3ff00000
  4109ec:	40240000 	.word	0x40240000
  4109f0:	40140000 	.word	0x40140000
  4109f4:	401c0000 	.word	0x401c0000
  4109f8:	d103      	bne.n	410a02 <_dtoa_r+0xb6a>
  4109fa:	f01a 0f01 	tst.w	sl, #1
  4109fe:	f47f acf2 	bne.w	4103e6 <_dtoa_r+0x54e>
  410a02:	465b      	mov	r3, fp
  410a04:	469b      	mov	fp, r3
  410a06:	3b01      	subs	r3, #1
  410a08:	f81b 2c01 	ldrb.w	r2, [fp, #-1]
  410a0c:	2a30      	cmp	r2, #48	; 0x30
  410a0e:	d0f9      	beq.n	410a04 <_dtoa_r+0xb6c>
  410a10:	e4f9      	b.n	410406 <_dtoa_r+0x56e>
  410a12:	f8dd 9050 	ldr.w	r9, [sp, #80]	; 0x50
  410a16:	4654      	mov	r4, sl
  410a18:	e9dd ab12 	ldrd	sl, fp, [sp, #72]	; 0x48
  410a1c:	f7ff bb48 	b.w	4100b0 <_dtoa_r+0x218>
  410a20:	9e07      	ldr	r6, [sp, #28]
  410a22:	4275      	negs	r5, r6
  410a24:	2d00      	cmp	r5, #0
  410a26:	f000 80c2 	beq.w	410bae <_dtoa_r+0xd16>
  410a2a:	4ba3      	ldr	r3, [pc, #652]	; (410cb8 <_dtoa_r+0xe20>)
  410a2c:	f005 020f 	and.w	r2, r5, #15
  410a30:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
  410a34:	e9d3 2300 	ldrd	r2, r3, [r3]
  410a38:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
  410a3c:	f004 f858 	bl	414af0 <__aeabi_dmul>
  410a40:	112d      	asrs	r5, r5, #4
  410a42:	4682      	mov	sl, r0
  410a44:	468b      	mov	fp, r1
  410a46:	f000 812d 	beq.w	410ca4 <_dtoa_r+0xe0c>
  410a4a:	4e9c      	ldr	r6, [pc, #624]	; (410cbc <_dtoa_r+0xe24>)
  410a4c:	f04f 0802 	mov.w	r8, #2
  410a50:	07ea      	lsls	r2, r5, #31
  410a52:	d505      	bpl.n	410a60 <_dtoa_r+0xbc8>
  410a54:	e9d6 2300 	ldrd	r2, r3, [r6]
  410a58:	f108 0801 	add.w	r8, r8, #1
  410a5c:	f004 f848 	bl	414af0 <__aeabi_dmul>
  410a60:	106d      	asrs	r5, r5, #1
  410a62:	f106 0608 	add.w	r6, r6, #8
  410a66:	d1f3      	bne.n	410a50 <_dtoa_r+0xbb8>
  410a68:	4682      	mov	sl, r0
  410a6a:	468b      	mov	fp, r1
  410a6c:	e5f0      	b.n	410650 <_dtoa_r+0x7b8>
  410a6e:	9e07      	ldr	r6, [sp, #28]
  410a70:	9d09      	ldr	r5, [sp, #36]	; 0x24
  410a72:	2230      	movs	r2, #48	; 0x30
  410a74:	702a      	strb	r2, [r5, #0]
  410a76:	3601      	adds	r6, #1
  410a78:	2231      	movs	r2, #49	; 0x31
  410a7a:	9607      	str	r6, [sp, #28]
  410a7c:	701a      	strb	r2, [r3, #0]
  410a7e:	f7ff bbd8 	b.w	410232 <_dtoa_r+0x39a>
  410a82:	6871      	ldr	r1, [r6, #4]
  410a84:	4620      	mov	r0, r4
  410a86:	f000 fed7 	bl	411838 <_Balloc>
  410a8a:	6933      	ldr	r3, [r6, #16]
  410a8c:	1c9a      	adds	r2, r3, #2
  410a8e:	4605      	mov	r5, r0
  410a90:	0092      	lsls	r2, r2, #2
  410a92:	f106 010c 	add.w	r1, r6, #12
  410a96:	300c      	adds	r0, #12
  410a98:	f7fb fb46 	bl	40c128 <memcpy>
  410a9c:	4620      	mov	r0, r4
  410a9e:	4629      	mov	r1, r5
  410aa0:	2201      	movs	r2, #1
  410aa2:	f001 f8d5 	bl	411c50 <__lshift>
  410aa6:	4607      	mov	r7, r0
  410aa8:	e504      	b.n	4104b4 <_dtoa_r+0x61c>
  410aaa:	f1ba 0f39 	cmp.w	sl, #57	; 0x39
  410aae:	f8cd 9028 	str.w	r9, [sp, #40]	; 0x28
  410ab2:	f000 80a8 	beq.w	410c06 <_dtoa_r+0xd6e>
  410ab6:	9d06      	ldr	r5, [sp, #24]
  410ab8:	f10a 0301 	add.w	r3, sl, #1
  410abc:	702b      	strb	r3, [r5, #0]
  410abe:	4635      	mov	r5, r6
  410ac0:	9e06      	ldr	r6, [sp, #24]
  410ac2:	f106 0b01 	add.w	fp, r6, #1
  410ac6:	463e      	mov	r6, r7
  410ac8:	e49d      	b.n	410406 <_dtoa_r+0x56e>
  410aca:	4635      	mov	r5, r6
  410acc:	f8cd 9028 	str.w	r9, [sp, #40]	; 0x28
  410ad0:	463e      	mov	r6, r7
  410ad2:	e47c      	b.n	4103ce <_dtoa_r+0x536>
  410ad4:	f04f 0800 	mov.w	r8, #0
  410ad8:	4646      	mov	r6, r8
  410ada:	e70d      	b.n	4108f8 <_dtoa_r+0xa60>
  410adc:	4976      	ldr	r1, [pc, #472]	; (410cb8 <_dtoa_r+0xe20>)
  410ade:	f108 35ff 	add.w	r5, r8, #4294967295
  410ae2:	eb01 01c5 	add.w	r1, r1, r5, lsl #3
  410ae6:	4632      	mov	r2, r6
  410ae8:	463b      	mov	r3, r7
  410aea:	e9d1 0100 	ldrd	r0, r1, [r1]
  410aee:	9510      	str	r5, [sp, #64]	; 0x40
  410af0:	f003 fffe 	bl	414af0 <__aeabi_dmul>
  410af4:	e9cd 0114 	strd	r0, r1, [sp, #80]	; 0x50
  410af8:	4659      	mov	r1, fp
  410afa:	4650      	mov	r0, sl
  410afc:	f004 fa92 	bl	415024 <__aeabi_d2iz>
  410b00:	4605      	mov	r5, r0
  410b02:	f003 ff8f 	bl	414a24 <__aeabi_i2d>
  410b06:	4602      	mov	r2, r0
  410b08:	460b      	mov	r3, r1
  410b0a:	4650      	mov	r0, sl
  410b0c:	4659      	mov	r1, fp
  410b0e:	f003 fe3b 	bl	414788 <__aeabi_dsub>
  410b12:	f8dd e024 	ldr.w	lr, [sp, #36]	; 0x24
  410b16:	3530      	adds	r5, #48	; 0x30
  410b18:	f1b8 0f01 	cmp.w	r8, #1
  410b1c:	4606      	mov	r6, r0
  410b1e:	460f      	mov	r7, r1
  410b20:	f88e 5000 	strb.w	r5, [lr]
  410b24:	f10e 0b01 	add.w	fp, lr, #1
  410b28:	d01e      	beq.n	410b68 <_dtoa_r+0xcd0>
  410b2a:	9d09      	ldr	r5, [sp, #36]	; 0x24
  410b2c:	1e6b      	subs	r3, r5, #1
  410b2e:	eb03 0a08 	add.w	sl, r3, r8
  410b32:	2200      	movs	r2, #0
  410b34:	4b62      	ldr	r3, [pc, #392]	; (410cc0 <_dtoa_r+0xe28>)
  410b36:	f003 ffdb 	bl	414af0 <__aeabi_dmul>
  410b3a:	460f      	mov	r7, r1
  410b3c:	4606      	mov	r6, r0
  410b3e:	f004 fa71 	bl	415024 <__aeabi_d2iz>
  410b42:	4680      	mov	r8, r0
  410b44:	f003 ff6e 	bl	414a24 <__aeabi_i2d>
  410b48:	f108 0830 	add.w	r8, r8, #48	; 0x30
  410b4c:	4602      	mov	r2, r0
  410b4e:	460b      	mov	r3, r1
  410b50:	4630      	mov	r0, r6
  410b52:	4639      	mov	r1, r7
  410b54:	f003 fe18 	bl	414788 <__aeabi_dsub>
  410b58:	f805 8f01 	strb.w	r8, [r5, #1]!
  410b5c:	4555      	cmp	r5, sl
  410b5e:	d1e8      	bne.n	410b32 <_dtoa_r+0xc9a>
  410b60:	9d10      	ldr	r5, [sp, #64]	; 0x40
  410b62:	4606      	mov	r6, r0
  410b64:	460f      	mov	r7, r1
  410b66:	44ab      	add	fp, r5
  410b68:	2200      	movs	r2, #0
  410b6a:	4b56      	ldr	r3, [pc, #344]	; (410cc4 <_dtoa_r+0xe2c>)
  410b6c:	e9dd 0114 	ldrd	r0, r1, [sp, #80]	; 0x50
  410b70:	f003 fe0c 	bl	41478c <__adddf3>
  410b74:	4632      	mov	r2, r6
  410b76:	463b      	mov	r3, r7
  410b78:	f004 fa2c 	bl	414fd4 <__aeabi_dcmplt>
  410b7c:	2800      	cmp	r0, #0
  410b7e:	d04d      	beq.n	410c1c <_dtoa_r+0xd84>
  410b80:	9e17      	ldr	r6, [sp, #92]	; 0x5c
  410b82:	9607      	str	r6, [sp, #28]
  410b84:	f81b 5c01 	ldrb.w	r5, [fp, #-1]
  410b88:	9a09      	ldr	r2, [sp, #36]	; 0x24
  410b8a:	f7ff bb4b 	b.w	410224 <_dtoa_r+0x38c>
  410b8e:	9e08      	ldr	r6, [sp, #32]
  410b90:	2300      	movs	r3, #0
  410b92:	ebc9 0506 	rsb	r5, r9, r6
  410b96:	f7ff bb76 	b.w	410286 <_dtoa_r+0x3ee>
  410b9a:	9b18      	ldr	r3, [sp, #96]	; 0x60
  410b9c:	9f0c      	ldr	r7, [sp, #48]	; 0x30
  410b9e:	9d08      	ldr	r5, [sp, #32]
  410ba0:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
  410ba4:	f7ff bb6f 	b.w	410286 <_dtoa_r+0x3ee>
  410ba8:	4657      	mov	r7, sl
  410baa:	f7ff bbb9 	b.w	410320 <_dtoa_r+0x488>
  410bae:	e9dd ab12 	ldrd	sl, fp, [sp, #72]	; 0x48
  410bb2:	f04f 0802 	mov.w	r8, #2
  410bb6:	e54b      	b.n	410650 <_dtoa_r+0x7b8>
  410bb8:	f1b9 0f00 	cmp.w	r9, #0
  410bbc:	f43f aeaf 	beq.w	41091e <_dtoa_r+0xa86>
  410bc0:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
  410bc2:	2e00      	cmp	r6, #0
  410bc4:	f77f af28 	ble.w	410a18 <_dtoa_r+0xb80>
  410bc8:	2200      	movs	r2, #0
  410bca:	4b3d      	ldr	r3, [pc, #244]	; (410cc0 <_dtoa_r+0xe28>)
  410bcc:	4650      	mov	r0, sl
  410bce:	4659      	mov	r1, fp
  410bd0:	f003 ff8e 	bl	414af0 <__aeabi_dmul>
  410bd4:	4682      	mov	sl, r0
  410bd6:	f108 0001 	add.w	r0, r8, #1
  410bda:	468b      	mov	fp, r1
  410bdc:	f003 ff22 	bl	414a24 <__aeabi_i2d>
  410be0:	4602      	mov	r2, r0
  410be2:	460b      	mov	r3, r1
  410be4:	4650      	mov	r0, sl
  410be6:	4659      	mov	r1, fp
  410be8:	f003 ff82 	bl	414af0 <__aeabi_dmul>
  410bec:	2200      	movs	r2, #0
  410bee:	4b36      	ldr	r3, [pc, #216]	; (410cc8 <_dtoa_r+0xe30>)
  410bf0:	f003 fdcc 	bl	41478c <__adddf3>
  410bf4:	9d07      	ldr	r5, [sp, #28]
  410bf6:	f8dd 803c 	ldr.w	r8, [sp, #60]	; 0x3c
  410bfa:	3d01      	subs	r5, #1
  410bfc:	4606      	mov	r6, r0
  410bfe:	f1a1 7750 	sub.w	r7, r1, #54525952	; 0x3400000
  410c02:	9517      	str	r5, [sp, #92]	; 0x5c
  410c04:	e544      	b.n	410690 <_dtoa_r+0x7f8>
  410c06:	4635      	mov	r5, r6
  410c08:	9b06      	ldr	r3, [sp, #24]
  410c0a:	9e06      	ldr	r6, [sp, #24]
  410c0c:	9909      	ldr	r1, [sp, #36]	; 0x24
  410c0e:	2239      	movs	r2, #57	; 0x39
  410c10:	7032      	strb	r2, [r6, #0]
  410c12:	f103 0b01 	add.w	fp, r3, #1
  410c16:	463e      	mov	r6, r7
  410c18:	f7ff bbef 	b.w	4103fa <_dtoa_r+0x562>
  410c1c:	e9dd 2314 	ldrd	r2, r3, [sp, #80]	; 0x50
  410c20:	2000      	movs	r0, #0
  410c22:	4928      	ldr	r1, [pc, #160]	; (410cc4 <_dtoa_r+0xe2c>)
  410c24:	f003 fdb0 	bl	414788 <__aeabi_dsub>
  410c28:	4632      	mov	r2, r6
  410c2a:	463b      	mov	r3, r7
  410c2c:	f004 f9f0 	bl	415010 <__aeabi_dcmpgt>
  410c30:	2800      	cmp	r0, #0
  410c32:	f43f aef1 	beq.w	410a18 <_dtoa_r+0xb80>
  410c36:	465b      	mov	r3, fp
  410c38:	469b      	mov	fp, r3
  410c3a:	3b01      	subs	r3, #1
  410c3c:	f81b 2c01 	ldrb.w	r2, [fp, #-1]
  410c40:	2a30      	cmp	r2, #48	; 0x30
  410c42:	d0f9      	beq.n	410c38 <_dtoa_r+0xda0>
  410c44:	9d17      	ldr	r5, [sp, #92]	; 0x5c
  410c46:	9507      	str	r5, [sp, #28]
  410c48:	f7ff baf3 	b.w	410232 <_dtoa_r+0x39a>
  410c4c:	4645      	mov	r5, r8
  410c4e:	4654      	mov	r4, sl
  410c50:	9e17      	ldr	r6, [sp, #92]	; 0x5c
  410c52:	9607      	str	r6, [sp, #28]
  410c54:	9a09      	ldr	r2, [sp, #36]	; 0x24
  410c56:	f7ff bae5 	b.w	410224 <_dtoa_r+0x38c>
  410c5a:	f1ba 0f39 	cmp.w	sl, #57	; 0x39
  410c5e:	f8cd 9028 	str.w	r9, [sp, #40]	; 0x28
  410c62:	d0d0      	beq.n	410c06 <_dtoa_r+0xd6e>
  410c64:	9b03      	ldr	r3, [sp, #12]
  410c66:	4635      	mov	r5, r6
  410c68:	2b00      	cmp	r3, #0
  410c6a:	9e06      	ldr	r6, [sp, #24]
  410c6c:	bfc8      	it	gt
  410c6e:	f10b 0a31 	addgt.w	sl, fp, #49	; 0x31
  410c72:	f886 a000 	strb.w	sl, [r6]
  410c76:	f106 0b01 	add.w	fp, r6, #1
  410c7a:	463e      	mov	r6, r7
  410c7c:	f7ff bbc3 	b.w	410406 <_dtoa_r+0x56e>
  410c80:	f47f aea9 	bne.w	4109d6 <_dtoa_r+0xb3e>
  410c84:	f01a 0f01 	tst.w	sl, #1
  410c88:	f43f aea5 	beq.w	4109d6 <_dtoa_r+0xb3e>
  410c8c:	e69d      	b.n	4109ca <_dtoa_r+0xb32>
  410c8e:	4631      	mov	r1, r6
  410c90:	4620      	mov	r0, r4
  410c92:	220a      	movs	r2, #10
  410c94:	2300      	movs	r3, #0
  410c96:	f8dd 903c 	ldr.w	r9, [sp, #60]	; 0x3c
  410c9a:	f000 fdfd 	bl	411898 <__multadd>
  410c9e:	4606      	mov	r6, r0
  410ca0:	f7ff bb6c 	b.w	41037c <_dtoa_r+0x4e4>
  410ca4:	f04f 0802 	mov.w	r8, #2
  410ca8:	e4d2      	b.n	410650 <_dtoa_r+0x7b8>
  410caa:	f43f ab52 	beq.w	410352 <_dtoa_r+0x4ba>
  410cae:	f1c3 033c 	rsb	r3, r3, #60	; 0x3c
  410cb2:	f7ff bbe2 	b.w	41047a <_dtoa_r+0x5e2>
  410cb6:	bf00      	nop
  410cb8:	00417010 	.word	0x00417010
  410cbc:	004170d8 	.word	0x004170d8
  410cc0:	40240000 	.word	0x40240000
  410cc4:	3fe00000 	.word	0x3fe00000
  410cc8:	401c0000 	.word	0x401c0000
  410ccc:	f3af 8000 	nop.w

00410cd0 <__sflush_r>:
  410cd0:	898b      	ldrh	r3, [r1, #12]
  410cd2:	b29a      	uxth	r2, r3
  410cd4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  410cd8:	460d      	mov	r5, r1
  410cda:	0711      	lsls	r1, r2, #28
  410cdc:	4680      	mov	r8, r0
  410cde:	d43c      	bmi.n	410d5a <__sflush_r+0x8a>
  410ce0:	686a      	ldr	r2, [r5, #4]
  410ce2:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
  410ce6:	2a00      	cmp	r2, #0
  410ce8:	81ab      	strh	r3, [r5, #12]
  410cea:	dd59      	ble.n	410da0 <__sflush_r+0xd0>
  410cec:	6aac      	ldr	r4, [r5, #40]	; 0x28
  410cee:	2c00      	cmp	r4, #0
  410cf0:	d04b      	beq.n	410d8a <__sflush_r+0xba>
  410cf2:	b29b      	uxth	r3, r3
  410cf4:	f403 5280 	and.w	r2, r3, #4096	; 0x1000
  410cf8:	2100      	movs	r1, #0
  410cfa:	b292      	uxth	r2, r2
  410cfc:	f8d8 6000 	ldr.w	r6, [r8]
  410d00:	f8c8 1000 	str.w	r1, [r8]
  410d04:	2a00      	cmp	r2, #0
  410d06:	d04f      	beq.n	410da8 <__sflush_r+0xd8>
  410d08:	6d2a      	ldr	r2, [r5, #80]	; 0x50
  410d0a:	075f      	lsls	r7, r3, #29
  410d0c:	d505      	bpl.n	410d1a <__sflush_r+0x4a>
  410d0e:	6869      	ldr	r1, [r5, #4]
  410d10:	6b2b      	ldr	r3, [r5, #48]	; 0x30
  410d12:	1a52      	subs	r2, r2, r1
  410d14:	b10b      	cbz	r3, 410d1a <__sflush_r+0x4a>
  410d16:	6beb      	ldr	r3, [r5, #60]	; 0x3c
  410d18:	1ad2      	subs	r2, r2, r3
  410d1a:	4640      	mov	r0, r8
  410d1c:	69e9      	ldr	r1, [r5, #28]
  410d1e:	2300      	movs	r3, #0
  410d20:	47a0      	blx	r4
  410d22:	1c44      	adds	r4, r0, #1
  410d24:	d04a      	beq.n	410dbc <__sflush_r+0xec>
  410d26:	89aa      	ldrh	r2, [r5, #12]
  410d28:	692b      	ldr	r3, [r5, #16]
  410d2a:	602b      	str	r3, [r5, #0]
  410d2c:	f422 6300 	bic.w	r3, r2, #2048	; 0x800
  410d30:	b29b      	uxth	r3, r3
  410d32:	2200      	movs	r2, #0
  410d34:	606a      	str	r2, [r5, #4]
  410d36:	04da      	lsls	r2, r3, #19
  410d38:	81ab      	strh	r3, [r5, #12]
  410d3a:	d44c      	bmi.n	410dd6 <__sflush_r+0x106>
  410d3c:	6b29      	ldr	r1, [r5, #48]	; 0x30
  410d3e:	f8c8 6000 	str.w	r6, [r8]
  410d42:	b311      	cbz	r1, 410d8a <__sflush_r+0xba>
  410d44:	f105 0340 	add.w	r3, r5, #64	; 0x40
  410d48:	4299      	cmp	r1, r3
  410d4a:	d002      	beq.n	410d52 <__sflush_r+0x82>
  410d4c:	4640      	mov	r0, r8
  410d4e:	f000 f9c7 	bl	4110e0 <_free_r>
  410d52:	2000      	movs	r0, #0
  410d54:	6328      	str	r0, [r5, #48]	; 0x30
  410d56:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  410d5a:	692e      	ldr	r6, [r5, #16]
  410d5c:	b1ae      	cbz	r6, 410d8a <__sflush_r+0xba>
  410d5e:	682c      	ldr	r4, [r5, #0]
  410d60:	602e      	str	r6, [r5, #0]
  410d62:	0791      	lsls	r1, r2, #30
  410d64:	bf0c      	ite	eq
  410d66:	696b      	ldreq	r3, [r5, #20]
  410d68:	2300      	movne	r3, #0
  410d6a:	1ba4      	subs	r4, r4, r6
  410d6c:	60ab      	str	r3, [r5, #8]
  410d6e:	e00a      	b.n	410d86 <__sflush_r+0xb6>
  410d70:	4632      	mov	r2, r6
  410d72:	4623      	mov	r3, r4
  410d74:	6a6f      	ldr	r7, [r5, #36]	; 0x24
  410d76:	69e9      	ldr	r1, [r5, #28]
  410d78:	4640      	mov	r0, r8
  410d7a:	47b8      	blx	r7
  410d7c:	2800      	cmp	r0, #0
  410d7e:	ebc0 0404 	rsb	r4, r0, r4
  410d82:	4406      	add	r6, r0
  410d84:	dd04      	ble.n	410d90 <__sflush_r+0xc0>
  410d86:	2c00      	cmp	r4, #0
  410d88:	dcf2      	bgt.n	410d70 <__sflush_r+0xa0>
  410d8a:	2000      	movs	r0, #0
  410d8c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  410d90:	89ab      	ldrh	r3, [r5, #12]
  410d92:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  410d96:	81ab      	strh	r3, [r5, #12]
  410d98:	f04f 30ff 	mov.w	r0, #4294967295
  410d9c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  410da0:	6bea      	ldr	r2, [r5, #60]	; 0x3c
  410da2:	2a00      	cmp	r2, #0
  410da4:	dca2      	bgt.n	410cec <__sflush_r+0x1c>
  410da6:	e7f0      	b.n	410d8a <__sflush_r+0xba>
  410da8:	2301      	movs	r3, #1
  410daa:	4640      	mov	r0, r8
  410dac:	69e9      	ldr	r1, [r5, #28]
  410dae:	47a0      	blx	r4
  410db0:	1c43      	adds	r3, r0, #1
  410db2:	4602      	mov	r2, r0
  410db4:	d01e      	beq.n	410df4 <__sflush_r+0x124>
  410db6:	89ab      	ldrh	r3, [r5, #12]
  410db8:	6aac      	ldr	r4, [r5, #40]	; 0x28
  410dba:	e7a6      	b.n	410d0a <__sflush_r+0x3a>
  410dbc:	f8d8 3000 	ldr.w	r3, [r8]
  410dc0:	b95b      	cbnz	r3, 410dda <__sflush_r+0x10a>
  410dc2:	89a9      	ldrh	r1, [r5, #12]
  410dc4:	606b      	str	r3, [r5, #4]
  410dc6:	f421 6300 	bic.w	r3, r1, #2048	; 0x800
  410dca:	b29b      	uxth	r3, r3
  410dcc:	692a      	ldr	r2, [r5, #16]
  410dce:	81ab      	strh	r3, [r5, #12]
  410dd0:	04db      	lsls	r3, r3, #19
  410dd2:	602a      	str	r2, [r5, #0]
  410dd4:	d5b2      	bpl.n	410d3c <__sflush_r+0x6c>
  410dd6:	6528      	str	r0, [r5, #80]	; 0x50
  410dd8:	e7b0      	b.n	410d3c <__sflush_r+0x6c>
  410dda:	2b1d      	cmp	r3, #29
  410ddc:	d001      	beq.n	410de2 <__sflush_r+0x112>
  410dde:	2b16      	cmp	r3, #22
  410de0:	d119      	bne.n	410e16 <__sflush_r+0x146>
  410de2:	89aa      	ldrh	r2, [r5, #12]
  410de4:	692b      	ldr	r3, [r5, #16]
  410de6:	602b      	str	r3, [r5, #0]
  410de8:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
  410dec:	2300      	movs	r3, #0
  410dee:	81aa      	strh	r2, [r5, #12]
  410df0:	606b      	str	r3, [r5, #4]
  410df2:	e7a3      	b.n	410d3c <__sflush_r+0x6c>
  410df4:	f8d8 3000 	ldr.w	r3, [r8]
  410df8:	2b00      	cmp	r3, #0
  410dfa:	d0dc      	beq.n	410db6 <__sflush_r+0xe6>
  410dfc:	2b1d      	cmp	r3, #29
  410dfe:	d007      	beq.n	410e10 <__sflush_r+0x140>
  410e00:	2b16      	cmp	r3, #22
  410e02:	d005      	beq.n	410e10 <__sflush_r+0x140>
  410e04:	89ab      	ldrh	r3, [r5, #12]
  410e06:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  410e0a:	81ab      	strh	r3, [r5, #12]
  410e0c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  410e10:	f8c8 6000 	str.w	r6, [r8]
  410e14:	e7b9      	b.n	410d8a <__sflush_r+0xba>
  410e16:	89ab      	ldrh	r3, [r5, #12]
  410e18:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  410e1c:	81ab      	strh	r3, [r5, #12]
  410e1e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  410e22:	bf00      	nop

00410e24 <_fflush_r>:
  410e24:	b510      	push	{r4, lr}
  410e26:	4604      	mov	r4, r0
  410e28:	b082      	sub	sp, #8
  410e2a:	b108      	cbz	r0, 410e30 <_fflush_r+0xc>
  410e2c:	6b83      	ldr	r3, [r0, #56]	; 0x38
  410e2e:	b153      	cbz	r3, 410e46 <_fflush_r+0x22>
  410e30:	f9b1 000c 	ldrsh.w	r0, [r1, #12]
  410e34:	b908      	cbnz	r0, 410e3a <_fflush_r+0x16>
  410e36:	b002      	add	sp, #8
  410e38:	bd10      	pop	{r4, pc}
  410e3a:	4620      	mov	r0, r4
  410e3c:	b002      	add	sp, #8
  410e3e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  410e42:	f7ff bf45 	b.w	410cd0 <__sflush_r>
  410e46:	9101      	str	r1, [sp, #4]
  410e48:	f000 f808 	bl	410e5c <__sinit>
  410e4c:	9901      	ldr	r1, [sp, #4]
  410e4e:	e7ef      	b.n	410e30 <_fflush_r+0xc>

00410e50 <_cleanup_r>:
  410e50:	4901      	ldr	r1, [pc, #4]	; (410e58 <_cleanup_r+0x8>)
  410e52:	f000 bb9f 	b.w	411594 <_fwalk>
  410e56:	bf00      	nop
  410e58:	00413fc1 	.word	0x00413fc1

00410e5c <__sinit>:
  410e5c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  410e60:	6b84      	ldr	r4, [r0, #56]	; 0x38
  410e62:	b083      	sub	sp, #12
  410e64:	4607      	mov	r7, r0
  410e66:	2c00      	cmp	r4, #0
  410e68:	d165      	bne.n	410f36 <__sinit+0xda>
  410e6a:	6845      	ldr	r5, [r0, #4]
  410e6c:	4833      	ldr	r0, [pc, #204]	; (410f3c <__sinit+0xe0>)
  410e6e:	63f8      	str	r0, [r7, #60]	; 0x3c
  410e70:	2304      	movs	r3, #4
  410e72:	2103      	movs	r1, #3
  410e74:	f507 723b 	add.w	r2, r7, #748	; 0x2ec
  410e78:	f8c7 12e4 	str.w	r1, [r7, #740]	; 0x2e4
  410e7c:	f8c7 22e8 	str.w	r2, [r7, #744]	; 0x2e8
  410e80:	f8c7 42e0 	str.w	r4, [r7, #736]	; 0x2e0
  410e84:	f105 005c 	add.w	r0, r5, #92	; 0x5c
  410e88:	81ab      	strh	r3, [r5, #12]
  410e8a:	602c      	str	r4, [r5, #0]
  410e8c:	606c      	str	r4, [r5, #4]
  410e8e:	60ac      	str	r4, [r5, #8]
  410e90:	666c      	str	r4, [r5, #100]	; 0x64
  410e92:	81ec      	strh	r4, [r5, #14]
  410e94:	612c      	str	r4, [r5, #16]
  410e96:	616c      	str	r4, [r5, #20]
  410e98:	61ac      	str	r4, [r5, #24]
  410e9a:	4621      	mov	r1, r4
  410e9c:	2208      	movs	r2, #8
  410e9e:	f7fb fa3d 	bl	40c31c <memset>
  410ea2:	68be      	ldr	r6, [r7, #8]
  410ea4:	f8df b098 	ldr.w	fp, [pc, #152]	; 410f40 <__sinit+0xe4>
  410ea8:	f8df a098 	ldr.w	sl, [pc, #152]	; 410f44 <__sinit+0xe8>
  410eac:	f8df 9098 	ldr.w	r9, [pc, #152]	; 410f48 <__sinit+0xec>
  410eb0:	f8df 8098 	ldr.w	r8, [pc, #152]	; 410f4c <__sinit+0xf0>
  410eb4:	61ed      	str	r5, [r5, #28]
  410eb6:	2301      	movs	r3, #1
  410eb8:	2209      	movs	r2, #9
  410eba:	f8c5 b020 	str.w	fp, [r5, #32]
  410ebe:	f8c5 a024 	str.w	sl, [r5, #36]	; 0x24
  410ec2:	f8c5 9028 	str.w	r9, [r5, #40]	; 0x28
  410ec6:	f8c5 802c 	str.w	r8, [r5, #44]	; 0x2c
  410eca:	4621      	mov	r1, r4
  410ecc:	81f3      	strh	r3, [r6, #14]
  410ece:	81b2      	strh	r2, [r6, #12]
  410ed0:	6034      	str	r4, [r6, #0]
  410ed2:	6074      	str	r4, [r6, #4]
  410ed4:	60b4      	str	r4, [r6, #8]
  410ed6:	6674      	str	r4, [r6, #100]	; 0x64
  410ed8:	6134      	str	r4, [r6, #16]
  410eda:	6174      	str	r4, [r6, #20]
  410edc:	61b4      	str	r4, [r6, #24]
  410ede:	2208      	movs	r2, #8
  410ee0:	f106 005c 	add.w	r0, r6, #92	; 0x5c
  410ee4:	9301      	str	r3, [sp, #4]
  410ee6:	f7fb fa19 	bl	40c31c <memset>
  410eea:	68fd      	ldr	r5, [r7, #12]
  410eec:	61f6      	str	r6, [r6, #28]
  410eee:	2012      	movs	r0, #18
  410ef0:	2202      	movs	r2, #2
  410ef2:	f8c6 b020 	str.w	fp, [r6, #32]
  410ef6:	f8c6 a024 	str.w	sl, [r6, #36]	; 0x24
  410efa:	f8c6 9028 	str.w	r9, [r6, #40]	; 0x28
  410efe:	f8c6 802c 	str.w	r8, [r6, #44]	; 0x2c
  410f02:	4621      	mov	r1, r4
  410f04:	81a8      	strh	r0, [r5, #12]
  410f06:	81ea      	strh	r2, [r5, #14]
  410f08:	602c      	str	r4, [r5, #0]
  410f0a:	606c      	str	r4, [r5, #4]
  410f0c:	60ac      	str	r4, [r5, #8]
  410f0e:	666c      	str	r4, [r5, #100]	; 0x64
  410f10:	612c      	str	r4, [r5, #16]
  410f12:	616c      	str	r4, [r5, #20]
  410f14:	61ac      	str	r4, [r5, #24]
  410f16:	f105 005c 	add.w	r0, r5, #92	; 0x5c
  410f1a:	2208      	movs	r2, #8
  410f1c:	f7fb f9fe 	bl	40c31c <memset>
  410f20:	9b01      	ldr	r3, [sp, #4]
  410f22:	61ed      	str	r5, [r5, #28]
  410f24:	f8c5 b020 	str.w	fp, [r5, #32]
  410f28:	f8c5 a024 	str.w	sl, [r5, #36]	; 0x24
  410f2c:	f8c5 9028 	str.w	r9, [r5, #40]	; 0x28
  410f30:	f8c5 802c 	str.w	r8, [r5, #44]	; 0x2c
  410f34:	63bb      	str	r3, [r7, #56]	; 0x38
  410f36:	b003      	add	sp, #12
  410f38:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  410f3c:	00410e51 	.word	0x00410e51
  410f40:	0040c5f9 	.word	0x0040c5f9
  410f44:	0040c621 	.word	0x0040c621
  410f48:	0040c659 	.word	0x0040c659
  410f4c:	0040c679 	.word	0x0040c679

00410f50 <__sfp_lock_acquire>:
  410f50:	4770      	bx	lr
  410f52:	bf00      	nop

00410f54 <__sfp_lock_release>:
  410f54:	4770      	bx	lr
  410f56:	bf00      	nop

00410f58 <__libc_fini_array>:
  410f58:	b538      	push	{r3, r4, r5, lr}
  410f5a:	4d09      	ldr	r5, [pc, #36]	; (410f80 <__libc_fini_array+0x28>)
  410f5c:	4c09      	ldr	r4, [pc, #36]	; (410f84 <__libc_fini_array+0x2c>)
  410f5e:	1b64      	subs	r4, r4, r5
  410f60:	10a4      	asrs	r4, r4, #2
  410f62:	bf18      	it	ne
  410f64:	eb05 0584 	addne.w	r5, r5, r4, lsl #2
  410f68:	d005      	beq.n	410f76 <__libc_fini_array+0x1e>
  410f6a:	3c01      	subs	r4, #1
  410f6c:	f855 3d04 	ldr.w	r3, [r5, #-4]!
  410f70:	4798      	blx	r3
  410f72:	2c00      	cmp	r4, #0
  410f74:	d1f9      	bne.n	410f6a <__libc_fini_array+0x12>
  410f76:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  410f7a:	f006 b983 	b.w	417284 <_fini>
  410f7e:	bf00      	nop
  410f80:	00417290 	.word	0x00417290
  410f84:	00417294 	.word	0x00417294

00410f88 <_fputwc_r>:
  410f88:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  410f8c:	8993      	ldrh	r3, [r2, #12]
  410f8e:	460f      	mov	r7, r1
  410f90:	0499      	lsls	r1, r3, #18
  410f92:	b082      	sub	sp, #8
  410f94:	4614      	mov	r4, r2
  410f96:	4680      	mov	r8, r0
  410f98:	d406      	bmi.n	410fa8 <_fputwc_r+0x20>
  410f9a:	6e52      	ldr	r2, [r2, #100]	; 0x64
  410f9c:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
  410fa0:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
  410fa4:	81a3      	strh	r3, [r4, #12]
  410fa6:	6662      	str	r2, [r4, #100]	; 0x64
  410fa8:	f000 fb2c 	bl	411604 <__locale_mb_cur_max>
  410fac:	2801      	cmp	r0, #1
  410fae:	d03d      	beq.n	41102c <_fputwc_r+0xa4>
  410fb0:	463a      	mov	r2, r7
  410fb2:	4640      	mov	r0, r8
  410fb4:	a901      	add	r1, sp, #4
  410fb6:	f104 035c 	add.w	r3, r4, #92	; 0x5c
  410fba:	f002 ff07 	bl	413dcc <_wcrtomb_r>
  410fbe:	1c42      	adds	r2, r0, #1
  410fc0:	4606      	mov	r6, r0
  410fc2:	d02c      	beq.n	41101e <_fputwc_r+0x96>
  410fc4:	2800      	cmp	r0, #0
  410fc6:	d039      	beq.n	41103c <_fputwc_r+0xb4>
  410fc8:	f89d 1004 	ldrb.w	r1, [sp, #4]
  410fcc:	2500      	movs	r5, #0
  410fce:	e009      	b.n	410fe4 <_fputwc_r+0x5c>
  410fd0:	6823      	ldr	r3, [r4, #0]
  410fd2:	7019      	strb	r1, [r3, #0]
  410fd4:	6823      	ldr	r3, [r4, #0]
  410fd6:	3301      	adds	r3, #1
  410fd8:	6023      	str	r3, [r4, #0]
  410fda:	3501      	adds	r5, #1
  410fdc:	42b5      	cmp	r5, r6
  410fde:	d22d      	bcs.n	41103c <_fputwc_r+0xb4>
  410fe0:	ab01      	add	r3, sp, #4
  410fe2:	5ce9      	ldrb	r1, [r5, r3]
  410fe4:	68a3      	ldr	r3, [r4, #8]
  410fe6:	3b01      	subs	r3, #1
  410fe8:	2b00      	cmp	r3, #0
  410fea:	60a3      	str	r3, [r4, #8]
  410fec:	daf0      	bge.n	410fd0 <_fputwc_r+0x48>
  410fee:	69a2      	ldr	r2, [r4, #24]
  410ff0:	4293      	cmp	r3, r2
  410ff2:	db05      	blt.n	411000 <_fputwc_r+0x78>
  410ff4:	6823      	ldr	r3, [r4, #0]
  410ff6:	7019      	strb	r1, [r3, #0]
  410ff8:	6823      	ldr	r3, [r4, #0]
  410ffa:	7819      	ldrb	r1, [r3, #0]
  410ffc:	290a      	cmp	r1, #10
  410ffe:	d1ea      	bne.n	410fd6 <_fputwc_r+0x4e>
  411000:	4640      	mov	r0, r8
  411002:	4622      	mov	r2, r4
  411004:	f002 fe8e 	bl	413d24 <__swbuf_r>
  411008:	f1b0 33ff 	subs.w	r3, r0, #4294967295
  41100c:	4258      	negs	r0, r3
  41100e:	4158      	adcs	r0, r3
  411010:	2800      	cmp	r0, #0
  411012:	d0e2      	beq.n	410fda <_fputwc_r+0x52>
  411014:	f04f 30ff 	mov.w	r0, #4294967295
  411018:	b002      	add	sp, #8
  41101a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  41101e:	89a3      	ldrh	r3, [r4, #12]
  411020:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  411024:	81a3      	strh	r3, [r4, #12]
  411026:	b002      	add	sp, #8
  411028:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  41102c:	1e7b      	subs	r3, r7, #1
  41102e:	2bfe      	cmp	r3, #254	; 0xfe
  411030:	d8be      	bhi.n	410fb0 <_fputwc_r+0x28>
  411032:	b2f9      	uxtb	r1, r7
  411034:	4606      	mov	r6, r0
  411036:	f88d 1004 	strb.w	r1, [sp, #4]
  41103a:	e7c7      	b.n	410fcc <_fputwc_r+0x44>
  41103c:	4638      	mov	r0, r7
  41103e:	b002      	add	sp, #8
  411040:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00411044 <_malloc_trim_r>:
  411044:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  411046:	4d23      	ldr	r5, [pc, #140]	; (4110d4 <_malloc_trim_r+0x90>)
  411048:	460f      	mov	r7, r1
  41104a:	4604      	mov	r4, r0
  41104c:	f7fb f9b0 	bl	40c3b0 <__malloc_lock>
  411050:	68ab      	ldr	r3, [r5, #8]
  411052:	685e      	ldr	r6, [r3, #4]
  411054:	f026 0603 	bic.w	r6, r6, #3
  411058:	1bf1      	subs	r1, r6, r7
  41105a:	f601 71ef 	addw	r1, r1, #4079	; 0xfef
  41105e:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
  411062:	f021 010f 	bic.w	r1, r1, #15
  411066:	f5a1 5780 	sub.w	r7, r1, #4096	; 0x1000
  41106a:	f5b7 5f80 	cmp.w	r7, #4096	; 0x1000
  41106e:	db07      	blt.n	411080 <_malloc_trim_r+0x3c>
  411070:	4620      	mov	r0, r4
  411072:	2100      	movs	r1, #0
  411074:	f7fb f9a0 	bl	40c3b8 <_sbrk_r>
  411078:	68ab      	ldr	r3, [r5, #8]
  41107a:	4433      	add	r3, r6
  41107c:	4298      	cmp	r0, r3
  41107e:	d004      	beq.n	41108a <_malloc_trim_r+0x46>
  411080:	4620      	mov	r0, r4
  411082:	f7fb f997 	bl	40c3b4 <__malloc_unlock>
  411086:	2000      	movs	r0, #0
  411088:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  41108a:	4620      	mov	r0, r4
  41108c:	4279      	negs	r1, r7
  41108e:	f7fb f993 	bl	40c3b8 <_sbrk_r>
  411092:	3001      	adds	r0, #1
  411094:	d00d      	beq.n	4110b2 <_malloc_trim_r+0x6e>
  411096:	4b10      	ldr	r3, [pc, #64]	; (4110d8 <_malloc_trim_r+0x94>)
  411098:	68aa      	ldr	r2, [r5, #8]
  41109a:	6819      	ldr	r1, [r3, #0]
  41109c:	1bf6      	subs	r6, r6, r7
  41109e:	f046 0601 	orr.w	r6, r6, #1
  4110a2:	4620      	mov	r0, r4
  4110a4:	1bc9      	subs	r1, r1, r7
  4110a6:	6056      	str	r6, [r2, #4]
  4110a8:	6019      	str	r1, [r3, #0]
  4110aa:	f7fb f983 	bl	40c3b4 <__malloc_unlock>
  4110ae:	2001      	movs	r0, #1
  4110b0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  4110b2:	4620      	mov	r0, r4
  4110b4:	2100      	movs	r1, #0
  4110b6:	f7fb f97f 	bl	40c3b8 <_sbrk_r>
  4110ba:	68ab      	ldr	r3, [r5, #8]
  4110bc:	1ac2      	subs	r2, r0, r3
  4110be:	2a0f      	cmp	r2, #15
  4110c0:	ddde      	ble.n	411080 <_malloc_trim_r+0x3c>
  4110c2:	4d06      	ldr	r5, [pc, #24]	; (4110dc <_malloc_trim_r+0x98>)
  4110c4:	4904      	ldr	r1, [pc, #16]	; (4110d8 <_malloc_trim_r+0x94>)
  4110c6:	682d      	ldr	r5, [r5, #0]
  4110c8:	f042 0201 	orr.w	r2, r2, #1
  4110cc:	1b40      	subs	r0, r0, r5
  4110ce:	605a      	str	r2, [r3, #4]
  4110d0:	6008      	str	r0, [r1, #0]
  4110d2:	e7d5      	b.n	411080 <_malloc_trim_r+0x3c>
  4110d4:	20000b34 	.word	0x20000b34
  4110d8:	20003980 	.word	0x20003980
  4110dc:	20000f40 	.word	0x20000f40

004110e0 <_free_r>:
  4110e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  4110e4:	460d      	mov	r5, r1
  4110e6:	4606      	mov	r6, r0
  4110e8:	2900      	cmp	r1, #0
  4110ea:	d055      	beq.n	411198 <_free_r+0xb8>
  4110ec:	f7fb f960 	bl	40c3b0 <__malloc_lock>
  4110f0:	f855 1c04 	ldr.w	r1, [r5, #-4]
  4110f4:	f8df c174 	ldr.w	ip, [pc, #372]	; 41126c <_free_r+0x18c>
  4110f8:	f021 0301 	bic.w	r3, r1, #1
  4110fc:	f1a5 0408 	sub.w	r4, r5, #8
  411100:	18e2      	adds	r2, r4, r3
  411102:	f8dc 0008 	ldr.w	r0, [ip, #8]
  411106:	6857      	ldr	r7, [r2, #4]
  411108:	4290      	cmp	r0, r2
  41110a:	f027 0703 	bic.w	r7, r7, #3
  41110e:	d069      	beq.n	4111e4 <_free_r+0x104>
  411110:	f011 0101 	ands.w	r1, r1, #1
  411114:	6057      	str	r7, [r2, #4]
  411116:	d032      	beq.n	41117e <_free_r+0x9e>
  411118:	2100      	movs	r1, #0
  41111a:	19d0      	adds	r0, r2, r7
  41111c:	6840      	ldr	r0, [r0, #4]
  41111e:	07c0      	lsls	r0, r0, #31
  411120:	d406      	bmi.n	411130 <_free_r+0x50>
  411122:	443b      	add	r3, r7
  411124:	6890      	ldr	r0, [r2, #8]
  411126:	2900      	cmp	r1, #0
  411128:	d04e      	beq.n	4111c8 <_free_r+0xe8>
  41112a:	68d2      	ldr	r2, [r2, #12]
  41112c:	60c2      	str	r2, [r0, #12]
  41112e:	6090      	str	r0, [r2, #8]
  411130:	f043 0201 	orr.w	r2, r3, #1
  411134:	6062      	str	r2, [r4, #4]
  411136:	50e3      	str	r3, [r4, r3]
  411138:	b9e1      	cbnz	r1, 411174 <_free_r+0x94>
  41113a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
  41113e:	d32d      	bcc.n	41119c <_free_r+0xbc>
  411140:	0a5a      	lsrs	r2, r3, #9
  411142:	2a04      	cmp	r2, #4
  411144:	d86a      	bhi.n	41121c <_free_r+0x13c>
  411146:	0998      	lsrs	r0, r3, #6
  411148:	3038      	adds	r0, #56	; 0x38
  41114a:	0041      	lsls	r1, r0, #1
  41114c:	eb0c 0c81 	add.w	ip, ip, r1, lsl #2
  411150:	4946      	ldr	r1, [pc, #280]	; (41126c <_free_r+0x18c>)
  411152:	f8dc 2008 	ldr.w	r2, [ip, #8]
  411156:	4562      	cmp	r2, ip
  411158:	d066      	beq.n	411228 <_free_r+0x148>
  41115a:	6851      	ldr	r1, [r2, #4]
  41115c:	f021 0103 	bic.w	r1, r1, #3
  411160:	428b      	cmp	r3, r1
  411162:	d202      	bcs.n	41116a <_free_r+0x8a>
  411164:	6892      	ldr	r2, [r2, #8]
  411166:	4594      	cmp	ip, r2
  411168:	d1f7      	bne.n	41115a <_free_r+0x7a>
  41116a:	68d3      	ldr	r3, [r2, #12]
  41116c:	60e3      	str	r3, [r4, #12]
  41116e:	60a2      	str	r2, [r4, #8]
  411170:	609c      	str	r4, [r3, #8]
  411172:	60d4      	str	r4, [r2, #12]
  411174:	4630      	mov	r0, r6
  411176:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  41117a:	f7fb b91b 	b.w	40c3b4 <__malloc_unlock>
  41117e:	f855 5c08 	ldr.w	r5, [r5, #-8]
  411182:	1b64      	subs	r4, r4, r5
  411184:	f10c 0808 	add.w	r8, ip, #8
  411188:	68a0      	ldr	r0, [r4, #8]
  41118a:	4540      	cmp	r0, r8
  41118c:	442b      	add	r3, r5
  41118e:	d043      	beq.n	411218 <_free_r+0x138>
  411190:	68e5      	ldr	r5, [r4, #12]
  411192:	60c5      	str	r5, [r0, #12]
  411194:	60a8      	str	r0, [r5, #8]
  411196:	e7c0      	b.n	41111a <_free_r+0x3a>
  411198:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  41119c:	08db      	lsrs	r3, r3, #3
  41119e:	eb0c 02c3 	add.w	r2, ip, r3, lsl #3
  4111a2:	2501      	movs	r5, #1
  4111a4:	f8dc 0004 	ldr.w	r0, [ip, #4]
  4111a8:	6891      	ldr	r1, [r2, #8]
  4111aa:	60a1      	str	r1, [r4, #8]
  4111ac:	109b      	asrs	r3, r3, #2
  4111ae:	fa05 f303 	lsl.w	r3, r5, r3
  4111b2:	4318      	orrs	r0, r3
  4111b4:	60e2      	str	r2, [r4, #12]
  4111b6:	f8cc 0004 	str.w	r0, [ip, #4]
  4111ba:	6094      	str	r4, [r2, #8]
  4111bc:	4630      	mov	r0, r6
  4111be:	60cc      	str	r4, [r1, #12]
  4111c0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  4111c4:	f7fb b8f6 	b.w	40c3b4 <__malloc_unlock>
  4111c8:	4d29      	ldr	r5, [pc, #164]	; (411270 <_free_r+0x190>)
  4111ca:	42a8      	cmp	r0, r5
  4111cc:	d1ad      	bne.n	41112a <_free_r+0x4a>
  4111ce:	f043 0201 	orr.w	r2, r3, #1
  4111d2:	f8cc 4014 	str.w	r4, [ip, #20]
  4111d6:	f8cc 4010 	str.w	r4, [ip, #16]
  4111da:	60e0      	str	r0, [r4, #12]
  4111dc:	60a0      	str	r0, [r4, #8]
  4111de:	6062      	str	r2, [r4, #4]
  4111e0:	50e3      	str	r3, [r4, r3]
  4111e2:	e7c7      	b.n	411174 <_free_r+0x94>
  4111e4:	441f      	add	r7, r3
  4111e6:	07cb      	lsls	r3, r1, #31
  4111e8:	d407      	bmi.n	4111fa <_free_r+0x11a>
  4111ea:	f855 3c08 	ldr.w	r3, [r5, #-8]
  4111ee:	1ae4      	subs	r4, r4, r3
  4111f0:	441f      	add	r7, r3
  4111f2:	68a2      	ldr	r2, [r4, #8]
  4111f4:	68e3      	ldr	r3, [r4, #12]
  4111f6:	60d3      	str	r3, [r2, #12]
  4111f8:	609a      	str	r2, [r3, #8]
  4111fa:	4b1e      	ldr	r3, [pc, #120]	; (411274 <_free_r+0x194>)
  4111fc:	681b      	ldr	r3, [r3, #0]
  4111fe:	f047 0201 	orr.w	r2, r7, #1
  411202:	429f      	cmp	r7, r3
  411204:	6062      	str	r2, [r4, #4]
  411206:	f8cc 4008 	str.w	r4, [ip, #8]
  41120a:	d3b3      	bcc.n	411174 <_free_r+0x94>
  41120c:	4b1a      	ldr	r3, [pc, #104]	; (411278 <_free_r+0x198>)
  41120e:	4630      	mov	r0, r6
  411210:	6819      	ldr	r1, [r3, #0]
  411212:	f7ff ff17 	bl	411044 <_malloc_trim_r>
  411216:	e7ad      	b.n	411174 <_free_r+0x94>
  411218:	2101      	movs	r1, #1
  41121a:	e77e      	b.n	41111a <_free_r+0x3a>
  41121c:	2a14      	cmp	r2, #20
  41121e:	d80c      	bhi.n	41123a <_free_r+0x15a>
  411220:	f102 005b 	add.w	r0, r2, #91	; 0x5b
  411224:	0041      	lsls	r1, r0, #1
  411226:	e791      	b.n	41114c <_free_r+0x6c>
  411228:	684b      	ldr	r3, [r1, #4]
  41122a:	1080      	asrs	r0, r0, #2
  41122c:	2501      	movs	r5, #1
  41122e:	fa05 f000 	lsl.w	r0, r5, r0
  411232:	4303      	orrs	r3, r0
  411234:	604b      	str	r3, [r1, #4]
  411236:	4613      	mov	r3, r2
  411238:	e798      	b.n	41116c <_free_r+0x8c>
  41123a:	2a54      	cmp	r2, #84	; 0x54
  41123c:	d803      	bhi.n	411246 <_free_r+0x166>
  41123e:	0b18      	lsrs	r0, r3, #12
  411240:	306e      	adds	r0, #110	; 0x6e
  411242:	0041      	lsls	r1, r0, #1
  411244:	e782      	b.n	41114c <_free_r+0x6c>
  411246:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
  41124a:	d803      	bhi.n	411254 <_free_r+0x174>
  41124c:	0bd8      	lsrs	r0, r3, #15
  41124e:	3077      	adds	r0, #119	; 0x77
  411250:	0041      	lsls	r1, r0, #1
  411252:	e77b      	b.n	41114c <_free_r+0x6c>
  411254:	f240 5154 	movw	r1, #1364	; 0x554
  411258:	428a      	cmp	r2, r1
  41125a:	d803      	bhi.n	411264 <_free_r+0x184>
  41125c:	0c98      	lsrs	r0, r3, #18
  41125e:	307c      	adds	r0, #124	; 0x7c
  411260:	0041      	lsls	r1, r0, #1
  411262:	e773      	b.n	41114c <_free_r+0x6c>
  411264:	21fc      	movs	r1, #252	; 0xfc
  411266:	207e      	movs	r0, #126	; 0x7e
  411268:	e770      	b.n	41114c <_free_r+0x6c>
  41126a:	bf00      	nop
  41126c:	20000b34 	.word	0x20000b34
  411270:	20000b3c 	.word	0x20000b3c
  411274:	20000f3c 	.word	0x20000f3c
  411278:	2000397c 	.word	0x2000397c

0041127c <__sfvwrite_r>:
  41127c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  411280:	6893      	ldr	r3, [r2, #8]
  411282:	b083      	sub	sp, #12
  411284:	4616      	mov	r6, r2
  411286:	4681      	mov	r9, r0
  411288:	460c      	mov	r4, r1
  41128a:	b32b      	cbz	r3, 4112d8 <__sfvwrite_r+0x5c>
  41128c:	898b      	ldrh	r3, [r1, #12]
  41128e:	0719      	lsls	r1, r3, #28
  411290:	d526      	bpl.n	4112e0 <__sfvwrite_r+0x64>
  411292:	6922      	ldr	r2, [r4, #16]
  411294:	b322      	cbz	r2, 4112e0 <__sfvwrite_r+0x64>
  411296:	f003 0202 	and.w	r2, r3, #2
  41129a:	b292      	uxth	r2, r2
  41129c:	6835      	ldr	r5, [r6, #0]
  41129e:	2a00      	cmp	r2, #0
  4112a0:	d02c      	beq.n	4112fc <__sfvwrite_r+0x80>
  4112a2:	f04f 0a00 	mov.w	sl, #0
  4112a6:	f8df b2e8 	ldr.w	fp, [pc, #744]	; 411590 <__sfvwrite_r+0x314>
  4112aa:	46d0      	mov	r8, sl
  4112ac:	45d8      	cmp	r8, fp
  4112ae:	bf34      	ite	cc
  4112b0:	4643      	movcc	r3, r8
  4112b2:	465b      	movcs	r3, fp
  4112b4:	4652      	mov	r2, sl
  4112b6:	4648      	mov	r0, r9
  4112b8:	f1b8 0f00 	cmp.w	r8, #0
  4112bc:	d04f      	beq.n	41135e <__sfvwrite_r+0xe2>
  4112be:	69e1      	ldr	r1, [r4, #28]
  4112c0:	6a67      	ldr	r7, [r4, #36]	; 0x24
  4112c2:	47b8      	blx	r7
  4112c4:	2800      	cmp	r0, #0
  4112c6:	dd56      	ble.n	411376 <__sfvwrite_r+0xfa>
  4112c8:	68b3      	ldr	r3, [r6, #8]
  4112ca:	1a1b      	subs	r3, r3, r0
  4112cc:	4482      	add	sl, r0
  4112ce:	ebc0 0808 	rsb	r8, r0, r8
  4112d2:	60b3      	str	r3, [r6, #8]
  4112d4:	2b00      	cmp	r3, #0
  4112d6:	d1e9      	bne.n	4112ac <__sfvwrite_r+0x30>
  4112d8:	2000      	movs	r0, #0
  4112da:	b003      	add	sp, #12
  4112dc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4112e0:	4648      	mov	r0, r9
  4112e2:	4621      	mov	r1, r4
  4112e4:	f7fe fcbc 	bl	40fc60 <__swsetup_r>
  4112e8:	2800      	cmp	r0, #0
  4112ea:	f040 8148 	bne.w	41157e <__sfvwrite_r+0x302>
  4112ee:	89a3      	ldrh	r3, [r4, #12]
  4112f0:	6835      	ldr	r5, [r6, #0]
  4112f2:	f003 0202 	and.w	r2, r3, #2
  4112f6:	b292      	uxth	r2, r2
  4112f8:	2a00      	cmp	r2, #0
  4112fa:	d1d2      	bne.n	4112a2 <__sfvwrite_r+0x26>
  4112fc:	f013 0a01 	ands.w	sl, r3, #1
  411300:	d142      	bne.n	411388 <__sfvwrite_r+0x10c>
  411302:	46d0      	mov	r8, sl
  411304:	f1b8 0f00 	cmp.w	r8, #0
  411308:	d023      	beq.n	411352 <__sfvwrite_r+0xd6>
  41130a:	059a      	lsls	r2, r3, #22
  41130c:	68a7      	ldr	r7, [r4, #8]
  41130e:	d576      	bpl.n	4113fe <__sfvwrite_r+0x182>
  411310:	45b8      	cmp	r8, r7
  411312:	f0c0 80a4 	bcc.w	41145e <__sfvwrite_r+0x1e2>
  411316:	f413 6f90 	tst.w	r3, #1152	; 0x480
  41131a:	f040 80b2 	bne.w	411482 <__sfvwrite_r+0x206>
  41131e:	6820      	ldr	r0, [r4, #0]
  411320:	46bb      	mov	fp, r7
  411322:	4651      	mov	r1, sl
  411324:	465a      	mov	r2, fp
  411326:	f7fa ff99 	bl	40c25c <memmove>
  41132a:	68a2      	ldr	r2, [r4, #8]
  41132c:	6821      	ldr	r1, [r4, #0]
  41132e:	1bd2      	subs	r2, r2, r7
  411330:	eb01 030b 	add.w	r3, r1, fp
  411334:	60a2      	str	r2, [r4, #8]
  411336:	6023      	str	r3, [r4, #0]
  411338:	4642      	mov	r2, r8
  41133a:	68b3      	ldr	r3, [r6, #8]
  41133c:	1a9b      	subs	r3, r3, r2
  41133e:	4492      	add	sl, r2
  411340:	ebc2 0808 	rsb	r8, r2, r8
  411344:	60b3      	str	r3, [r6, #8]
  411346:	2b00      	cmp	r3, #0
  411348:	d0c6      	beq.n	4112d8 <__sfvwrite_r+0x5c>
  41134a:	89a3      	ldrh	r3, [r4, #12]
  41134c:	f1b8 0f00 	cmp.w	r8, #0
  411350:	d1db      	bne.n	41130a <__sfvwrite_r+0x8e>
  411352:	f8d5 a000 	ldr.w	sl, [r5]
  411356:	f8d5 8004 	ldr.w	r8, [r5, #4]
  41135a:	3508      	adds	r5, #8
  41135c:	e7d2      	b.n	411304 <__sfvwrite_r+0x88>
  41135e:	f8d5 a000 	ldr.w	sl, [r5]
  411362:	f8d5 8004 	ldr.w	r8, [r5, #4]
  411366:	3508      	adds	r5, #8
  411368:	e7a0      	b.n	4112ac <__sfvwrite_r+0x30>
  41136a:	4648      	mov	r0, r9
  41136c:	4621      	mov	r1, r4
  41136e:	f7ff fd59 	bl	410e24 <_fflush_r>
  411372:	2800      	cmp	r0, #0
  411374:	d059      	beq.n	41142a <__sfvwrite_r+0x1ae>
  411376:	89a3      	ldrh	r3, [r4, #12]
  411378:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  41137c:	f04f 30ff 	mov.w	r0, #4294967295
  411380:	81a3      	strh	r3, [r4, #12]
  411382:	b003      	add	sp, #12
  411384:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  411388:	4692      	mov	sl, r2
  41138a:	9201      	str	r2, [sp, #4]
  41138c:	4693      	mov	fp, r2
  41138e:	4690      	mov	r8, r2
  411390:	f1b8 0f00 	cmp.w	r8, #0
  411394:	d02b      	beq.n	4113ee <__sfvwrite_r+0x172>
  411396:	9f01      	ldr	r7, [sp, #4]
  411398:	2f00      	cmp	r7, #0
  41139a:	d064      	beq.n	411466 <__sfvwrite_r+0x1ea>
  41139c:	6820      	ldr	r0, [r4, #0]
  41139e:	6921      	ldr	r1, [r4, #16]
  4113a0:	f8d4 c008 	ldr.w	ip, [r4, #8]
  4113a4:	6962      	ldr	r2, [r4, #20]
  4113a6:	45c2      	cmp	sl, r8
  4113a8:	bf34      	ite	cc
  4113aa:	4653      	movcc	r3, sl
  4113ac:	4643      	movcs	r3, r8
  4113ae:	4288      	cmp	r0, r1
  4113b0:	461f      	mov	r7, r3
  4113b2:	d903      	bls.n	4113bc <__sfvwrite_r+0x140>
  4113b4:	4494      	add	ip, r2
  4113b6:	4563      	cmp	r3, ip
  4113b8:	f300 80ae 	bgt.w	411518 <__sfvwrite_r+0x29c>
  4113bc:	4293      	cmp	r3, r2
  4113be:	db36      	blt.n	41142e <__sfvwrite_r+0x1b2>
  4113c0:	4613      	mov	r3, r2
  4113c2:	6a67      	ldr	r7, [r4, #36]	; 0x24
  4113c4:	69e1      	ldr	r1, [r4, #28]
  4113c6:	4648      	mov	r0, r9
  4113c8:	465a      	mov	r2, fp
  4113ca:	47b8      	blx	r7
  4113cc:	1e07      	subs	r7, r0, #0
  4113ce:	ddd2      	ble.n	411376 <__sfvwrite_r+0xfa>
  4113d0:	ebba 0a07 	subs.w	sl, sl, r7
  4113d4:	d03a      	beq.n	41144c <__sfvwrite_r+0x1d0>
  4113d6:	68b3      	ldr	r3, [r6, #8]
  4113d8:	1bdb      	subs	r3, r3, r7
  4113da:	44bb      	add	fp, r7
  4113dc:	ebc7 0808 	rsb	r8, r7, r8
  4113e0:	60b3      	str	r3, [r6, #8]
  4113e2:	2b00      	cmp	r3, #0
  4113e4:	f43f af78 	beq.w	4112d8 <__sfvwrite_r+0x5c>
  4113e8:	f1b8 0f00 	cmp.w	r8, #0
  4113ec:	d1d3      	bne.n	411396 <__sfvwrite_r+0x11a>
  4113ee:	2700      	movs	r7, #0
  4113f0:	f8d5 b000 	ldr.w	fp, [r5]
  4113f4:	f8d5 8004 	ldr.w	r8, [r5, #4]
  4113f8:	9701      	str	r7, [sp, #4]
  4113fa:	3508      	adds	r5, #8
  4113fc:	e7c8      	b.n	411390 <__sfvwrite_r+0x114>
  4113fe:	6820      	ldr	r0, [r4, #0]
  411400:	6923      	ldr	r3, [r4, #16]
  411402:	4298      	cmp	r0, r3
  411404:	d802      	bhi.n	41140c <__sfvwrite_r+0x190>
  411406:	6963      	ldr	r3, [r4, #20]
  411408:	4598      	cmp	r8, r3
  41140a:	d272      	bcs.n	4114f2 <__sfvwrite_r+0x276>
  41140c:	45b8      	cmp	r8, r7
  41140e:	bf38      	it	cc
  411410:	4647      	movcc	r7, r8
  411412:	463a      	mov	r2, r7
  411414:	4651      	mov	r1, sl
  411416:	f7fa ff21 	bl	40c25c <memmove>
  41141a:	68a3      	ldr	r3, [r4, #8]
  41141c:	6822      	ldr	r2, [r4, #0]
  41141e:	1bdb      	subs	r3, r3, r7
  411420:	443a      	add	r2, r7
  411422:	60a3      	str	r3, [r4, #8]
  411424:	6022      	str	r2, [r4, #0]
  411426:	2b00      	cmp	r3, #0
  411428:	d09f      	beq.n	41136a <__sfvwrite_r+0xee>
  41142a:	463a      	mov	r2, r7
  41142c:	e785      	b.n	41133a <__sfvwrite_r+0xbe>
  41142e:	461a      	mov	r2, r3
  411430:	4659      	mov	r1, fp
  411432:	9300      	str	r3, [sp, #0]
  411434:	f7fa ff12 	bl	40c25c <memmove>
  411438:	9b00      	ldr	r3, [sp, #0]
  41143a:	68a1      	ldr	r1, [r4, #8]
  41143c:	6822      	ldr	r2, [r4, #0]
  41143e:	1ac9      	subs	r1, r1, r3
  411440:	ebba 0a07 	subs.w	sl, sl, r7
  411444:	4413      	add	r3, r2
  411446:	60a1      	str	r1, [r4, #8]
  411448:	6023      	str	r3, [r4, #0]
  41144a:	d1c4      	bne.n	4113d6 <__sfvwrite_r+0x15a>
  41144c:	4648      	mov	r0, r9
  41144e:	4621      	mov	r1, r4
  411450:	f7ff fce8 	bl	410e24 <_fflush_r>
  411454:	2800      	cmp	r0, #0
  411456:	d18e      	bne.n	411376 <__sfvwrite_r+0xfa>
  411458:	f8cd a004 	str.w	sl, [sp, #4]
  41145c:	e7bb      	b.n	4113d6 <__sfvwrite_r+0x15a>
  41145e:	6820      	ldr	r0, [r4, #0]
  411460:	4647      	mov	r7, r8
  411462:	46c3      	mov	fp, r8
  411464:	e75d      	b.n	411322 <__sfvwrite_r+0xa6>
  411466:	4658      	mov	r0, fp
  411468:	210a      	movs	r1, #10
  41146a:	4642      	mov	r2, r8
  41146c:	f000 f99c 	bl	4117a8 <memchr>
  411470:	2800      	cmp	r0, #0
  411472:	d07f      	beq.n	411574 <__sfvwrite_r+0x2f8>
  411474:	f100 0a01 	add.w	sl, r0, #1
  411478:	2701      	movs	r7, #1
  41147a:	ebcb 0a0a 	rsb	sl, fp, sl
  41147e:	9701      	str	r7, [sp, #4]
  411480:	e78c      	b.n	41139c <__sfvwrite_r+0x120>
  411482:	6822      	ldr	r2, [r4, #0]
  411484:	6921      	ldr	r1, [r4, #16]
  411486:	6967      	ldr	r7, [r4, #20]
  411488:	ebc1 0c02 	rsb	ip, r1, r2
  41148c:	eb07 0747 	add.w	r7, r7, r7, lsl #1
  411490:	f10c 0201 	add.w	r2, ip, #1
  411494:	eb07 77d7 	add.w	r7, r7, r7, lsr #31
  411498:	4442      	add	r2, r8
  41149a:	107f      	asrs	r7, r7, #1
  41149c:	4297      	cmp	r7, r2
  41149e:	bf34      	ite	cc
  4114a0:	4617      	movcc	r7, r2
  4114a2:	463a      	movcs	r2, r7
  4114a4:	055b      	lsls	r3, r3, #21
  4114a6:	d54f      	bpl.n	411548 <__sfvwrite_r+0x2cc>
  4114a8:	4611      	mov	r1, r2
  4114aa:	4648      	mov	r0, r9
  4114ac:	f8cd c000 	str.w	ip, [sp]
  4114b0:	f7fa fb9e 	bl	40bbf0 <_malloc_r>
  4114b4:	f8dd c000 	ldr.w	ip, [sp]
  4114b8:	4683      	mov	fp, r0
  4114ba:	2800      	cmp	r0, #0
  4114bc:	d062      	beq.n	411584 <__sfvwrite_r+0x308>
  4114be:	4662      	mov	r2, ip
  4114c0:	6921      	ldr	r1, [r4, #16]
  4114c2:	f8cd c000 	str.w	ip, [sp]
  4114c6:	f7fa fe2f 	bl	40c128 <memcpy>
  4114ca:	89a2      	ldrh	r2, [r4, #12]
  4114cc:	f8dd c000 	ldr.w	ip, [sp]
  4114d0:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
  4114d4:	f042 0280 	orr.w	r2, r2, #128	; 0x80
  4114d8:	81a2      	strh	r2, [r4, #12]
  4114da:	eb0b 000c 	add.w	r0, fp, ip
  4114de:	ebcc 0207 	rsb	r2, ip, r7
  4114e2:	f8c4 b010 	str.w	fp, [r4, #16]
  4114e6:	6167      	str	r7, [r4, #20]
  4114e8:	6020      	str	r0, [r4, #0]
  4114ea:	60a2      	str	r2, [r4, #8]
  4114ec:	4647      	mov	r7, r8
  4114ee:	46c3      	mov	fp, r8
  4114f0:	e717      	b.n	411322 <__sfvwrite_r+0xa6>
  4114f2:	f06f 4200 	mvn.w	r2, #2147483648	; 0x80000000
  4114f6:	4590      	cmp	r8, r2
  4114f8:	bf38      	it	cc
  4114fa:	4642      	movcc	r2, r8
  4114fc:	fb92 f2f3 	sdiv	r2, r2, r3
  411500:	fb02 f303 	mul.w	r3, r2, r3
  411504:	6a67      	ldr	r7, [r4, #36]	; 0x24
  411506:	69e1      	ldr	r1, [r4, #28]
  411508:	4648      	mov	r0, r9
  41150a:	4652      	mov	r2, sl
  41150c:	47b8      	blx	r7
  41150e:	2800      	cmp	r0, #0
  411510:	f77f af31 	ble.w	411376 <__sfvwrite_r+0xfa>
  411514:	4602      	mov	r2, r0
  411516:	e710      	b.n	41133a <__sfvwrite_r+0xbe>
  411518:	4662      	mov	r2, ip
  41151a:	4659      	mov	r1, fp
  41151c:	f8cd c000 	str.w	ip, [sp]
  411520:	f7fa fe9c 	bl	40c25c <memmove>
  411524:	f8dd c000 	ldr.w	ip, [sp]
  411528:	6823      	ldr	r3, [r4, #0]
  41152a:	4463      	add	r3, ip
  41152c:	6023      	str	r3, [r4, #0]
  41152e:	4648      	mov	r0, r9
  411530:	4621      	mov	r1, r4
  411532:	f8cd c000 	str.w	ip, [sp]
  411536:	f7ff fc75 	bl	410e24 <_fflush_r>
  41153a:	f8dd c000 	ldr.w	ip, [sp]
  41153e:	2800      	cmp	r0, #0
  411540:	f47f af19 	bne.w	411376 <__sfvwrite_r+0xfa>
  411544:	4667      	mov	r7, ip
  411546:	e743      	b.n	4113d0 <__sfvwrite_r+0x154>
  411548:	4648      	mov	r0, r9
  41154a:	f8cd c000 	str.w	ip, [sp]
  41154e:	f000 fdd3 	bl	4120f8 <_realloc_r>
  411552:	f8dd c000 	ldr.w	ip, [sp]
  411556:	4683      	mov	fp, r0
  411558:	2800      	cmp	r0, #0
  41155a:	d1be      	bne.n	4114da <__sfvwrite_r+0x25e>
  41155c:	4648      	mov	r0, r9
  41155e:	6921      	ldr	r1, [r4, #16]
  411560:	f7ff fdbe 	bl	4110e0 <_free_r>
  411564:	89a3      	ldrh	r3, [r4, #12]
  411566:	220c      	movs	r2, #12
  411568:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  41156c:	b29b      	uxth	r3, r3
  41156e:	f8c9 2000 	str.w	r2, [r9]
  411572:	e701      	b.n	411378 <__sfvwrite_r+0xfc>
  411574:	2701      	movs	r7, #1
  411576:	f108 0a01 	add.w	sl, r8, #1
  41157a:	9701      	str	r7, [sp, #4]
  41157c:	e70e      	b.n	41139c <__sfvwrite_r+0x120>
  41157e:	f04f 30ff 	mov.w	r0, #4294967295
  411582:	e6aa      	b.n	4112da <__sfvwrite_r+0x5e>
  411584:	230c      	movs	r3, #12
  411586:	f8c9 3000 	str.w	r3, [r9]
  41158a:	89a3      	ldrh	r3, [r4, #12]
  41158c:	e6f4      	b.n	411378 <__sfvwrite_r+0xfc>
  41158e:	bf00      	nop
  411590:	7ffffc00 	.word	0x7ffffc00

00411594 <_fwalk>:
  411594:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  411598:	f510 7738 	adds.w	r7, r0, #736	; 0x2e0
  41159c:	4688      	mov	r8, r1
  41159e:	d01a      	beq.n	4115d6 <_fwalk+0x42>
  4115a0:	2600      	movs	r6, #0
  4115a2:	687d      	ldr	r5, [r7, #4]
  4115a4:	68bc      	ldr	r4, [r7, #8]
  4115a6:	3d01      	subs	r5, #1
  4115a8:	d40f      	bmi.n	4115ca <_fwalk+0x36>
  4115aa:	89a3      	ldrh	r3, [r4, #12]
  4115ac:	2b01      	cmp	r3, #1
  4115ae:	f105 35ff 	add.w	r5, r5, #4294967295
  4115b2:	d906      	bls.n	4115c2 <_fwalk+0x2e>
  4115b4:	f9b4 300e 	ldrsh.w	r3, [r4, #14]
  4115b8:	3301      	adds	r3, #1
  4115ba:	4620      	mov	r0, r4
  4115bc:	d001      	beq.n	4115c2 <_fwalk+0x2e>
  4115be:	47c0      	blx	r8
  4115c0:	4306      	orrs	r6, r0
  4115c2:	1c6b      	adds	r3, r5, #1
  4115c4:	f104 0468 	add.w	r4, r4, #104	; 0x68
  4115c8:	d1ef      	bne.n	4115aa <_fwalk+0x16>
  4115ca:	683f      	ldr	r7, [r7, #0]
  4115cc:	2f00      	cmp	r7, #0
  4115ce:	d1e8      	bne.n	4115a2 <_fwalk+0xe>
  4115d0:	4630      	mov	r0, r6
  4115d2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4115d6:	463e      	mov	r6, r7
  4115d8:	4630      	mov	r0, r6
  4115da:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4115de:	bf00      	nop

004115e0 <iswspace>:
  4115e0:	28ff      	cmp	r0, #255	; 0xff
  4115e2:	d807      	bhi.n	4115f4 <iswspace+0x14>
  4115e4:	4b04      	ldr	r3, [pc, #16]	; (4115f8 <iswspace+0x18>)
  4115e6:	681b      	ldr	r3, [r3, #0]
  4115e8:	4418      	add	r0, r3
  4115ea:	7840      	ldrb	r0, [r0, #1]
  4115ec:	f000 0008 	and.w	r0, r0, #8
  4115f0:	b2c0      	uxtb	r0, r0
  4115f2:	4770      	bx	lr
  4115f4:	2000      	movs	r0, #0
  4115f6:	4770      	bx	lr
  4115f8:	20000f44 	.word	0x20000f44

004115fc <__locale_charset>:
  4115fc:	4800      	ldr	r0, [pc, #0]	; (411600 <__locale_charset+0x4>)
  4115fe:	4770      	bx	lr
  411600:	20000f80 	.word	0x20000f80

00411604 <__locale_mb_cur_max>:
  411604:	4b01      	ldr	r3, [pc, #4]	; (41160c <__locale_mb_cur_max+0x8>)
  411606:	6818      	ldr	r0, [r3, #0]
  411608:	4770      	bx	lr
  41160a:	bf00      	nop
  41160c:	20000fa0 	.word	0x20000fa0

00411610 <_localeconv_r>:
  411610:	4800      	ldr	r0, [pc, #0]	; (411614 <_localeconv_r+0x4>)
  411612:	4770      	bx	lr
  411614:	20000f48 	.word	0x20000f48

00411618 <_lseek_r>:
  411618:	b570      	push	{r4, r5, r6, lr}
  41161a:	4c08      	ldr	r4, [pc, #32]	; (41163c <_lseek_r+0x24>)
  41161c:	4606      	mov	r6, r0
  41161e:	2500      	movs	r5, #0
  411620:	4608      	mov	r0, r1
  411622:	4611      	mov	r1, r2
  411624:	461a      	mov	r2, r3
  411626:	6025      	str	r5, [r4, #0]
  411628:	f7f9 ff72 	bl	40b510 <_lseek>
  41162c:	1c43      	adds	r3, r0, #1
  41162e:	d000      	beq.n	411632 <_lseek_r+0x1a>
  411630:	bd70      	pop	{r4, r5, r6, pc}
  411632:	6823      	ldr	r3, [r4, #0]
  411634:	2b00      	cmp	r3, #0
  411636:	d0fb      	beq.n	411630 <_lseek_r+0x18>
  411638:	6033      	str	r3, [r6, #0]
  41163a:	bd70      	pop	{r4, r5, r6, pc}
  41163c:	2000503c 	.word	0x2000503c

00411640 <__smakebuf_r>:
  411640:	b5f0      	push	{r4, r5, r6, r7, lr}
  411642:	898b      	ldrh	r3, [r1, #12]
  411644:	b29a      	uxth	r2, r3
  411646:	0796      	lsls	r6, r2, #30
  411648:	b091      	sub	sp, #68	; 0x44
  41164a:	460c      	mov	r4, r1
  41164c:	4605      	mov	r5, r0
  41164e:	d437      	bmi.n	4116c0 <__smakebuf_r+0x80>
  411650:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  411654:	2900      	cmp	r1, #0
  411656:	db17      	blt.n	411688 <__smakebuf_r+0x48>
  411658:	aa01      	add	r2, sp, #4
  41165a:	f002 fcb9 	bl	413fd0 <_fstat_r>
  41165e:	2800      	cmp	r0, #0
  411660:	db10      	blt.n	411684 <__smakebuf_r+0x44>
  411662:	9b02      	ldr	r3, [sp, #8]
  411664:	f403 4370 	and.w	r3, r3, #61440	; 0xf000
  411668:	f5b3 5100 	subs.w	r1, r3, #8192	; 0x2000
  41166c:	424f      	negs	r7, r1
  41166e:	414f      	adcs	r7, r1
  411670:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
  411674:	d02c      	beq.n	4116d0 <__smakebuf_r+0x90>
  411676:	89a3      	ldrh	r3, [r4, #12]
  411678:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
  41167c:	81a3      	strh	r3, [r4, #12]
  41167e:	f44f 6680 	mov.w	r6, #1024	; 0x400
  411682:	e00b      	b.n	41169c <__smakebuf_r+0x5c>
  411684:	89a3      	ldrh	r3, [r4, #12]
  411686:	b29a      	uxth	r2, r3
  411688:	f012 0f80 	tst.w	r2, #128	; 0x80
  41168c:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
  411690:	81a3      	strh	r3, [r4, #12]
  411692:	bf14      	ite	ne
  411694:	2640      	movne	r6, #64	; 0x40
  411696:	f44f 6680 	moveq.w	r6, #1024	; 0x400
  41169a:	2700      	movs	r7, #0
  41169c:	4628      	mov	r0, r5
  41169e:	4631      	mov	r1, r6
  4116a0:	f7fa faa6 	bl	40bbf0 <_malloc_r>
  4116a4:	89a3      	ldrh	r3, [r4, #12]
  4116a6:	2800      	cmp	r0, #0
  4116a8:	d029      	beq.n	4116fe <__smakebuf_r+0xbe>
  4116aa:	4a1b      	ldr	r2, [pc, #108]	; (411718 <__smakebuf_r+0xd8>)
  4116ac:	63ea      	str	r2, [r5, #60]	; 0x3c
  4116ae:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  4116b2:	81a3      	strh	r3, [r4, #12]
  4116b4:	6020      	str	r0, [r4, #0]
  4116b6:	6120      	str	r0, [r4, #16]
  4116b8:	6166      	str	r6, [r4, #20]
  4116ba:	b9a7      	cbnz	r7, 4116e6 <__smakebuf_r+0xa6>
  4116bc:	b011      	add	sp, #68	; 0x44
  4116be:	bdf0      	pop	{r4, r5, r6, r7, pc}
  4116c0:	f101 0343 	add.w	r3, r1, #67	; 0x43
  4116c4:	2201      	movs	r2, #1
  4116c6:	600b      	str	r3, [r1, #0]
  4116c8:	610b      	str	r3, [r1, #16]
  4116ca:	614a      	str	r2, [r1, #20]
  4116cc:	b011      	add	sp, #68	; 0x44
  4116ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
  4116d0:	4a12      	ldr	r2, [pc, #72]	; (41171c <__smakebuf_r+0xdc>)
  4116d2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  4116d4:	4293      	cmp	r3, r2
  4116d6:	d1ce      	bne.n	411676 <__smakebuf_r+0x36>
  4116d8:	89a3      	ldrh	r3, [r4, #12]
  4116da:	f44f 6680 	mov.w	r6, #1024	; 0x400
  4116de:	4333      	orrs	r3, r6
  4116e0:	81a3      	strh	r3, [r4, #12]
  4116e2:	64e6      	str	r6, [r4, #76]	; 0x4c
  4116e4:	e7da      	b.n	41169c <__smakebuf_r+0x5c>
  4116e6:	4628      	mov	r0, r5
  4116e8:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
  4116ec:	f003 f836 	bl	41475c <_isatty_r>
  4116f0:	2800      	cmp	r0, #0
  4116f2:	d0e3      	beq.n	4116bc <__smakebuf_r+0x7c>
  4116f4:	89a3      	ldrh	r3, [r4, #12]
  4116f6:	f043 0301 	orr.w	r3, r3, #1
  4116fa:	81a3      	strh	r3, [r4, #12]
  4116fc:	e7de      	b.n	4116bc <__smakebuf_r+0x7c>
  4116fe:	059a      	lsls	r2, r3, #22
  411700:	d4dc      	bmi.n	4116bc <__smakebuf_r+0x7c>
  411702:	f104 0243 	add.w	r2, r4, #67	; 0x43
  411706:	f043 0302 	orr.w	r3, r3, #2
  41170a:	2101      	movs	r1, #1
  41170c:	81a3      	strh	r3, [r4, #12]
  41170e:	6022      	str	r2, [r4, #0]
  411710:	6122      	str	r2, [r4, #16]
  411712:	6161      	str	r1, [r4, #20]
  411714:	e7d2      	b.n	4116bc <__smakebuf_r+0x7c>
  411716:	bf00      	nop
  411718:	00410e51 	.word	0x00410e51
  41171c:	0040c659 	.word	0x0040c659

00411720 <_mbrtowc_r>:
  411720:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  411724:	b083      	sub	sp, #12
  411726:	461f      	mov	r7, r3
  411728:	4614      	mov	r4, r2
  41172a:	4605      	mov	r5, r0
  41172c:	4688      	mov	r8, r1
  41172e:	9e0a      	ldr	r6, [sp, #40]	; 0x28
  411730:	4b10      	ldr	r3, [pc, #64]	; (411774 <_mbrtowc_r+0x54>)
  411732:	b19a      	cbz	r2, 41175c <_mbrtowc_r+0x3c>
  411734:	f8d3 9000 	ldr.w	r9, [r3]
  411738:	f7ff ff60 	bl	4115fc <__locale_charset>
  41173c:	4641      	mov	r1, r8
  41173e:	e88d 0041 	stmia.w	sp, {r0, r6}
  411742:	4622      	mov	r2, r4
  411744:	463b      	mov	r3, r7
  411746:	4628      	mov	r0, r5
  411748:	47c8      	blx	r9
  41174a:	1c43      	adds	r3, r0, #1
  41174c:	d103      	bne.n	411756 <_mbrtowc_r+0x36>
  41174e:	2200      	movs	r2, #0
  411750:	238a      	movs	r3, #138	; 0x8a
  411752:	6032      	str	r2, [r6, #0]
  411754:	602b      	str	r3, [r5, #0]
  411756:	b003      	add	sp, #12
  411758:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  41175c:	681f      	ldr	r7, [r3, #0]
  41175e:	f7ff ff4d 	bl	4115fc <__locale_charset>
  411762:	4621      	mov	r1, r4
  411764:	e88d 0041 	stmia.w	sp, {r0, r6}
  411768:	4a03      	ldr	r2, [pc, #12]	; (411778 <_mbrtowc_r+0x58>)
  41176a:	4628      	mov	r0, r5
  41176c:	2301      	movs	r3, #1
  41176e:	47b8      	blx	r7
  411770:	e7eb      	b.n	41174a <_mbrtowc_r+0x2a>
  411772:	bf00      	nop
  411774:	20000fa4 	.word	0x20000fa4
  411778:	00415370 	.word	0x00415370

0041177c <__ascii_mbtowc>:
  41177c:	b082      	sub	sp, #8
  41177e:	b149      	cbz	r1, 411794 <__ascii_mbtowc+0x18>
  411780:	b15a      	cbz	r2, 41179a <__ascii_mbtowc+0x1e>
  411782:	b16b      	cbz	r3, 4117a0 <__ascii_mbtowc+0x24>
  411784:	7813      	ldrb	r3, [r2, #0]
  411786:	600b      	str	r3, [r1, #0]
  411788:	7810      	ldrb	r0, [r2, #0]
  41178a:	3000      	adds	r0, #0
  41178c:	bf18      	it	ne
  41178e:	2001      	movne	r0, #1
  411790:	b002      	add	sp, #8
  411792:	4770      	bx	lr
  411794:	a901      	add	r1, sp, #4
  411796:	2a00      	cmp	r2, #0
  411798:	d1f3      	bne.n	411782 <__ascii_mbtowc+0x6>
  41179a:	4610      	mov	r0, r2
  41179c:	b002      	add	sp, #8
  41179e:	4770      	bx	lr
  4117a0:	f06f 0001 	mvn.w	r0, #1
  4117a4:	e7f4      	b.n	411790 <__ascii_mbtowc+0x14>
  4117a6:	bf00      	nop

004117a8 <memchr>:
  4117a8:	0783      	lsls	r3, r0, #30
  4117aa:	b470      	push	{r4, r5, r6}
  4117ac:	b2c9      	uxtb	r1, r1
  4117ae:	d03f      	beq.n	411830 <memchr+0x88>
  4117b0:	1e54      	subs	r4, r2, #1
  4117b2:	b32a      	cbz	r2, 411800 <memchr+0x58>
  4117b4:	7803      	ldrb	r3, [r0, #0]
  4117b6:	428b      	cmp	r3, r1
  4117b8:	d023      	beq.n	411802 <memchr+0x5a>
  4117ba:	1c43      	adds	r3, r0, #1
  4117bc:	e004      	b.n	4117c8 <memchr+0x20>
  4117be:	b1fc      	cbz	r4, 411800 <memchr+0x58>
  4117c0:	7804      	ldrb	r4, [r0, #0]
  4117c2:	428c      	cmp	r4, r1
  4117c4:	d01d      	beq.n	411802 <memchr+0x5a>
  4117c6:	4614      	mov	r4, r2
  4117c8:	f013 0f03 	tst.w	r3, #3
  4117cc:	4618      	mov	r0, r3
  4117ce:	f104 32ff 	add.w	r2, r4, #4294967295
  4117d2:	f103 0301 	add.w	r3, r3, #1
  4117d6:	d1f2      	bne.n	4117be <memchr+0x16>
  4117d8:	2c03      	cmp	r4, #3
  4117da:	d814      	bhi.n	411806 <memchr+0x5e>
  4117dc:	1e65      	subs	r5, r4, #1
  4117de:	b34c      	cbz	r4, 411834 <memchr+0x8c>
  4117e0:	7803      	ldrb	r3, [r0, #0]
  4117e2:	428b      	cmp	r3, r1
  4117e4:	d00d      	beq.n	411802 <memchr+0x5a>
  4117e6:	1c42      	adds	r2, r0, #1
  4117e8:	2300      	movs	r3, #0
  4117ea:	e002      	b.n	4117f2 <memchr+0x4a>
  4117ec:	7804      	ldrb	r4, [r0, #0]
  4117ee:	428c      	cmp	r4, r1
  4117f0:	d007      	beq.n	411802 <memchr+0x5a>
  4117f2:	42ab      	cmp	r3, r5
  4117f4:	4610      	mov	r0, r2
  4117f6:	f103 0301 	add.w	r3, r3, #1
  4117fa:	f102 0201 	add.w	r2, r2, #1
  4117fe:	d1f5      	bne.n	4117ec <memchr+0x44>
  411800:	2000      	movs	r0, #0
  411802:	bc70      	pop	{r4, r5, r6}
  411804:	4770      	bx	lr
  411806:	ea41 2601 	orr.w	r6, r1, r1, lsl #8
  41180a:	4603      	mov	r3, r0
  41180c:	ea46 4606 	orr.w	r6, r6, r6, lsl #16
  411810:	4618      	mov	r0, r3
  411812:	3304      	adds	r3, #4
  411814:	6802      	ldr	r2, [r0, #0]
  411816:	4072      	eors	r2, r6
  411818:	f1a2 3501 	sub.w	r5, r2, #16843009	; 0x1010101
  41181c:	ea25 0202 	bic.w	r2, r5, r2
  411820:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
  411824:	d1da      	bne.n	4117dc <memchr+0x34>
  411826:	3c04      	subs	r4, #4
  411828:	2c03      	cmp	r4, #3
  41182a:	4618      	mov	r0, r3
  41182c:	d8f0      	bhi.n	411810 <memchr+0x68>
  41182e:	e7d5      	b.n	4117dc <memchr+0x34>
  411830:	4614      	mov	r4, r2
  411832:	e7d1      	b.n	4117d8 <memchr+0x30>
  411834:	4620      	mov	r0, r4
  411836:	e7e4      	b.n	411802 <memchr+0x5a>

00411838 <_Balloc>:
  411838:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
  41183a:	b570      	push	{r4, r5, r6, lr}
  41183c:	4605      	mov	r5, r0
  41183e:	460c      	mov	r4, r1
  411840:	b14a      	cbz	r2, 411856 <_Balloc+0x1e>
  411842:	f852 0024 	ldr.w	r0, [r2, r4, lsl #2]
  411846:	b180      	cbz	r0, 41186a <_Balloc+0x32>
  411848:	6801      	ldr	r1, [r0, #0]
  41184a:	f842 1024 	str.w	r1, [r2, r4, lsl #2]
  41184e:	2200      	movs	r2, #0
  411850:	6102      	str	r2, [r0, #16]
  411852:	60c2      	str	r2, [r0, #12]
  411854:	bd70      	pop	{r4, r5, r6, pc}
  411856:	2221      	movs	r2, #33	; 0x21
  411858:	2104      	movs	r1, #4
  41185a:	f002 fb41 	bl	413ee0 <_calloc_r>
  41185e:	64e8      	str	r0, [r5, #76]	; 0x4c
  411860:	4602      	mov	r2, r0
  411862:	2800      	cmp	r0, #0
  411864:	d1ed      	bne.n	411842 <_Balloc+0xa>
  411866:	2000      	movs	r0, #0
  411868:	bd70      	pop	{r4, r5, r6, pc}
  41186a:	2101      	movs	r1, #1
  41186c:	fa01 f604 	lsl.w	r6, r1, r4
  411870:	1d72      	adds	r2, r6, #5
  411872:	4628      	mov	r0, r5
  411874:	0092      	lsls	r2, r2, #2
  411876:	f002 fb33 	bl	413ee0 <_calloc_r>
  41187a:	2800      	cmp	r0, #0
  41187c:	d0f3      	beq.n	411866 <_Balloc+0x2e>
  41187e:	6044      	str	r4, [r0, #4]
  411880:	6086      	str	r6, [r0, #8]
  411882:	e7e4      	b.n	41184e <_Balloc+0x16>

00411884 <_Bfree>:
  411884:	b131      	cbz	r1, 411894 <_Bfree+0x10>
  411886:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
  411888:	684a      	ldr	r2, [r1, #4]
  41188a:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
  41188e:	6008      	str	r0, [r1, #0]
  411890:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  411894:	4770      	bx	lr
  411896:	bf00      	nop

00411898 <__multadd>:
  411898:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  41189c:	f8d1 8010 	ldr.w	r8, [r1, #16]
  4118a0:	b082      	sub	sp, #8
  4118a2:	4689      	mov	r9, r1
  4118a4:	4682      	mov	sl, r0
  4118a6:	f101 0514 	add.w	r5, r1, #20
  4118aa:	2400      	movs	r4, #0
  4118ac:	682f      	ldr	r7, [r5, #0]
  4118ae:	b2be      	uxth	r6, r7
  4118b0:	0c3f      	lsrs	r7, r7, #16
  4118b2:	fb02 3606 	mla	r6, r2, r6, r3
  4118b6:	fb02 f307 	mul.w	r3, r2, r7
  4118ba:	eb03 4316 	add.w	r3, r3, r6, lsr #16
  4118be:	3401      	adds	r4, #1
  4118c0:	b2b6      	uxth	r6, r6
  4118c2:	eb06 4603 	add.w	r6, r6, r3, lsl #16
  4118c6:	45a0      	cmp	r8, r4
  4118c8:	f845 6b04 	str.w	r6, [r5], #4
  4118cc:	ea4f 4313 	mov.w	r3, r3, lsr #16
  4118d0:	dcec      	bgt.n	4118ac <__multadd+0x14>
  4118d2:	b153      	cbz	r3, 4118ea <__multadd+0x52>
  4118d4:	f8d9 2008 	ldr.w	r2, [r9, #8]
  4118d8:	4590      	cmp	r8, r2
  4118da:	da0a      	bge.n	4118f2 <__multadd+0x5a>
  4118dc:	eb09 0188 	add.w	r1, r9, r8, lsl #2
  4118e0:	f108 0201 	add.w	r2, r8, #1
  4118e4:	614b      	str	r3, [r1, #20]
  4118e6:	f8c9 2010 	str.w	r2, [r9, #16]
  4118ea:	4648      	mov	r0, r9
  4118ec:	b002      	add	sp, #8
  4118ee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  4118f2:	f8d9 1004 	ldr.w	r1, [r9, #4]
  4118f6:	9301      	str	r3, [sp, #4]
  4118f8:	3101      	adds	r1, #1
  4118fa:	4650      	mov	r0, sl
  4118fc:	f7ff ff9c 	bl	411838 <_Balloc>
  411900:	f8d9 2010 	ldr.w	r2, [r9, #16]
  411904:	3202      	adds	r2, #2
  411906:	f109 010c 	add.w	r1, r9, #12
  41190a:	4604      	mov	r4, r0
  41190c:	0092      	lsls	r2, r2, #2
  41190e:	300c      	adds	r0, #12
  411910:	f7fa fc0a 	bl	40c128 <memcpy>
  411914:	f8da 204c 	ldr.w	r2, [sl, #76]	; 0x4c
  411918:	f8d9 1004 	ldr.w	r1, [r9, #4]
  41191c:	9b01      	ldr	r3, [sp, #4]
  41191e:	f852 0021 	ldr.w	r0, [r2, r1, lsl #2]
  411922:	f8c9 0000 	str.w	r0, [r9]
  411926:	f842 9021 	str.w	r9, [r2, r1, lsl #2]
  41192a:	46a1      	mov	r9, r4
  41192c:	e7d6      	b.n	4118dc <__multadd+0x44>
  41192e:	bf00      	nop

00411930 <__s2b>:
  411930:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  411934:	4699      	mov	r9, r3
  411936:	4b23      	ldr	r3, [pc, #140]	; (4119c4 <__s2b+0x94>)
  411938:	9e08      	ldr	r6, [sp, #32]
  41193a:	f109 0408 	add.w	r4, r9, #8
  41193e:	fb83 5304 	smull	r5, r3, r3, r4
  411942:	17e4      	asrs	r4, r4, #31
  411944:	ebc4 0363 	rsb	r3, r4, r3, asr #1
  411948:	2b01      	cmp	r3, #1
  41194a:	4607      	mov	r7, r0
  41194c:	460c      	mov	r4, r1
  41194e:	4690      	mov	r8, r2
  411950:	dd35      	ble.n	4119be <__s2b+0x8e>
  411952:	2501      	movs	r5, #1
  411954:	2100      	movs	r1, #0
  411956:	006d      	lsls	r5, r5, #1
  411958:	42ab      	cmp	r3, r5
  41195a:	f101 0101 	add.w	r1, r1, #1
  41195e:	dcfa      	bgt.n	411956 <__s2b+0x26>
  411960:	4638      	mov	r0, r7
  411962:	f7ff ff69 	bl	411838 <_Balloc>
  411966:	2301      	movs	r3, #1
  411968:	f1b8 0f09 	cmp.w	r8, #9
  41196c:	6146      	str	r6, [r0, #20]
  41196e:	6103      	str	r3, [r0, #16]
  411970:	dd21      	ble.n	4119b6 <__s2b+0x86>
  411972:	f104 0609 	add.w	r6, r4, #9
  411976:	4635      	mov	r5, r6
  411978:	4444      	add	r4, r8
  41197a:	f815 3b01 	ldrb.w	r3, [r5], #1
  41197e:	4601      	mov	r1, r0
  411980:	3b30      	subs	r3, #48	; 0x30
  411982:	4638      	mov	r0, r7
  411984:	220a      	movs	r2, #10
  411986:	f7ff ff87 	bl	411898 <__multadd>
  41198a:	42a5      	cmp	r5, r4
  41198c:	d1f5      	bne.n	41197a <__s2b+0x4a>
  41198e:	eb06 0408 	add.w	r4, r6, r8
  411992:	3c08      	subs	r4, #8
  411994:	45c1      	cmp	r9, r8
  411996:	dd0c      	ble.n	4119b2 <__s2b+0x82>
  411998:	ebc8 0809 	rsb	r8, r8, r9
  41199c:	44a0      	add	r8, r4
  41199e:	f814 3b01 	ldrb.w	r3, [r4], #1
  4119a2:	4601      	mov	r1, r0
  4119a4:	3b30      	subs	r3, #48	; 0x30
  4119a6:	4638      	mov	r0, r7
  4119a8:	220a      	movs	r2, #10
  4119aa:	f7ff ff75 	bl	411898 <__multadd>
  4119ae:	4544      	cmp	r4, r8
  4119b0:	d1f5      	bne.n	41199e <__s2b+0x6e>
  4119b2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  4119b6:	340a      	adds	r4, #10
  4119b8:	f04f 0809 	mov.w	r8, #9
  4119bc:	e7ea      	b.n	411994 <__s2b+0x64>
  4119be:	2100      	movs	r1, #0
  4119c0:	e7ce      	b.n	411960 <__s2b+0x30>
  4119c2:	bf00      	nop
  4119c4:	38e38e39 	.word	0x38e38e39

004119c8 <__hi0bits>:
  4119c8:	0c03      	lsrs	r3, r0, #16
  4119ca:	041b      	lsls	r3, r3, #16
  4119cc:	b9b3      	cbnz	r3, 4119fc <__hi0bits+0x34>
  4119ce:	0400      	lsls	r0, r0, #16
  4119d0:	2310      	movs	r3, #16
  4119d2:	f010 4f7f 	tst.w	r0, #4278190080	; 0xff000000
  4119d6:	bf04      	itt	eq
  4119d8:	0200      	lsleq	r0, r0, #8
  4119da:	3308      	addeq	r3, #8
  4119dc:	f010 4f70 	tst.w	r0, #4026531840	; 0xf0000000
  4119e0:	bf04      	itt	eq
  4119e2:	0100      	lsleq	r0, r0, #4
  4119e4:	3304      	addeq	r3, #4
  4119e6:	f010 4f40 	tst.w	r0, #3221225472	; 0xc0000000
  4119ea:	bf04      	itt	eq
  4119ec:	0080      	lsleq	r0, r0, #2
  4119ee:	3302      	addeq	r3, #2
  4119f0:	2800      	cmp	r0, #0
  4119f2:	db07      	blt.n	411a04 <__hi0bits+0x3c>
  4119f4:	0042      	lsls	r2, r0, #1
  4119f6:	d403      	bmi.n	411a00 <__hi0bits+0x38>
  4119f8:	2020      	movs	r0, #32
  4119fa:	4770      	bx	lr
  4119fc:	2300      	movs	r3, #0
  4119fe:	e7e8      	b.n	4119d2 <__hi0bits+0xa>
  411a00:	1c58      	adds	r0, r3, #1
  411a02:	4770      	bx	lr
  411a04:	4618      	mov	r0, r3
  411a06:	4770      	bx	lr

00411a08 <__lo0bits>:
  411a08:	6803      	ldr	r3, [r0, #0]
  411a0a:	f013 0207 	ands.w	r2, r3, #7
  411a0e:	d007      	beq.n	411a20 <__lo0bits+0x18>
  411a10:	07d9      	lsls	r1, r3, #31
  411a12:	d420      	bmi.n	411a56 <__lo0bits+0x4e>
  411a14:	079a      	lsls	r2, r3, #30
  411a16:	d420      	bmi.n	411a5a <__lo0bits+0x52>
  411a18:	089b      	lsrs	r3, r3, #2
  411a1a:	6003      	str	r3, [r0, #0]
  411a1c:	2002      	movs	r0, #2
  411a1e:	4770      	bx	lr
  411a20:	b299      	uxth	r1, r3
  411a22:	b909      	cbnz	r1, 411a28 <__lo0bits+0x20>
  411a24:	0c1b      	lsrs	r3, r3, #16
  411a26:	2210      	movs	r2, #16
  411a28:	f013 0fff 	tst.w	r3, #255	; 0xff
  411a2c:	bf04      	itt	eq
  411a2e:	0a1b      	lsreq	r3, r3, #8
  411a30:	3208      	addeq	r2, #8
  411a32:	0719      	lsls	r1, r3, #28
  411a34:	bf04      	itt	eq
  411a36:	091b      	lsreq	r3, r3, #4
  411a38:	3204      	addeq	r2, #4
  411a3a:	0799      	lsls	r1, r3, #30
  411a3c:	bf04      	itt	eq
  411a3e:	089b      	lsreq	r3, r3, #2
  411a40:	3202      	addeq	r2, #2
  411a42:	07d9      	lsls	r1, r3, #31
  411a44:	d404      	bmi.n	411a50 <__lo0bits+0x48>
  411a46:	085b      	lsrs	r3, r3, #1
  411a48:	d101      	bne.n	411a4e <__lo0bits+0x46>
  411a4a:	2020      	movs	r0, #32
  411a4c:	4770      	bx	lr
  411a4e:	3201      	adds	r2, #1
  411a50:	6003      	str	r3, [r0, #0]
  411a52:	4610      	mov	r0, r2
  411a54:	4770      	bx	lr
  411a56:	2000      	movs	r0, #0
  411a58:	4770      	bx	lr
  411a5a:	085b      	lsrs	r3, r3, #1
  411a5c:	6003      	str	r3, [r0, #0]
  411a5e:	2001      	movs	r0, #1
  411a60:	4770      	bx	lr
  411a62:	bf00      	nop

00411a64 <__i2b>:
  411a64:	b510      	push	{r4, lr}
  411a66:	460c      	mov	r4, r1
  411a68:	2101      	movs	r1, #1
  411a6a:	f7ff fee5 	bl	411838 <_Balloc>
  411a6e:	2201      	movs	r2, #1
  411a70:	6144      	str	r4, [r0, #20]
  411a72:	6102      	str	r2, [r0, #16]
  411a74:	bd10      	pop	{r4, pc}
  411a76:	bf00      	nop

00411a78 <__multiply>:
  411a78:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  411a7c:	690d      	ldr	r5, [r1, #16]
  411a7e:	f8d2 9010 	ldr.w	r9, [r2, #16]
  411a82:	454d      	cmp	r5, r9
  411a84:	b085      	sub	sp, #20
  411a86:	460c      	mov	r4, r1
  411a88:	4692      	mov	sl, r2
  411a8a:	da04      	bge.n	411a96 <__multiply+0x1e>
  411a8c:	462a      	mov	r2, r5
  411a8e:	4654      	mov	r4, sl
  411a90:	464d      	mov	r5, r9
  411a92:	468a      	mov	sl, r1
  411a94:	4691      	mov	r9, r2
  411a96:	68a3      	ldr	r3, [r4, #8]
  411a98:	6861      	ldr	r1, [r4, #4]
  411a9a:	eb05 0709 	add.w	r7, r5, r9
  411a9e:	429f      	cmp	r7, r3
  411aa0:	bfc8      	it	gt
  411aa2:	3101      	addgt	r1, #1
  411aa4:	f7ff fec8 	bl	411838 <_Balloc>
  411aa8:	f100 0614 	add.w	r6, r0, #20
  411aac:	eb06 0887 	add.w	r8, r6, r7, lsl #2
  411ab0:	4546      	cmp	r6, r8
  411ab2:	9001      	str	r0, [sp, #4]
  411ab4:	d205      	bcs.n	411ac2 <__multiply+0x4a>
  411ab6:	4633      	mov	r3, r6
  411ab8:	2000      	movs	r0, #0
  411aba:	f843 0b04 	str.w	r0, [r3], #4
  411abe:	4598      	cmp	r8, r3
  411ac0:	d8fb      	bhi.n	411aba <__multiply+0x42>
  411ac2:	f10a 0c14 	add.w	ip, sl, #20
  411ac6:	eb0c 0989 	add.w	r9, ip, r9, lsl #2
  411aca:	3414      	adds	r4, #20
  411acc:	45cc      	cmp	ip, r9
  411ace:	9400      	str	r4, [sp, #0]
  411ad0:	eb04 0585 	add.w	r5, r4, r5, lsl #2
  411ad4:	d25b      	bcs.n	411b8e <__multiply+0x116>
  411ad6:	f8cd 8008 	str.w	r8, [sp, #8]
  411ada:	9703      	str	r7, [sp, #12]
  411adc:	46c8      	mov	r8, r9
  411ade:	f85c 3b04 	ldr.w	r3, [ip], #4
  411ae2:	b29c      	uxth	r4, r3
  411ae4:	b324      	cbz	r4, 411b30 <__multiply+0xb8>
  411ae6:	9a00      	ldr	r2, [sp, #0]
  411ae8:	4633      	mov	r3, r6
  411aea:	f04f 0900 	mov.w	r9, #0
  411aee:	e000      	b.n	411af2 <__multiply+0x7a>
  411af0:	460b      	mov	r3, r1
  411af2:	f852 7b04 	ldr.w	r7, [r2], #4
  411af6:	6819      	ldr	r1, [r3, #0]
  411af8:	fa1f fb87 	uxth.w	fp, r7
  411afc:	fa1f fa81 	uxth.w	sl, r1
  411b00:	0c38      	lsrs	r0, r7, #16
  411b02:	0c09      	lsrs	r1, r1, #16
  411b04:	fb04 a70b 	mla	r7, r4, fp, sl
  411b08:	44b9      	add	r9, r7
  411b0a:	fb04 1000 	mla	r0, r4, r0, r1
  411b0e:	eb00 4019 	add.w	r0, r0, r9, lsr #16
  411b12:	4619      	mov	r1, r3
  411b14:	fa1f f989 	uxth.w	r9, r9
  411b18:	ea49 4700 	orr.w	r7, r9, r0, lsl #16
  411b1c:	4295      	cmp	r5, r2
  411b1e:	ea4f 4910 	mov.w	r9, r0, lsr #16
  411b22:	f841 7b04 	str.w	r7, [r1], #4
  411b26:	d8e3      	bhi.n	411af0 <__multiply+0x78>
  411b28:	f8c3 9004 	str.w	r9, [r3, #4]
  411b2c:	f85c 3c04 	ldr.w	r3, [ip, #-4]
  411b30:	ea5f 4913 	movs.w	r9, r3, lsr #16
  411b34:	d024      	beq.n	411b80 <__multiply+0x108>
  411b36:	f8d6 a000 	ldr.w	sl, [r6]
  411b3a:	9b00      	ldr	r3, [sp, #0]
  411b3c:	4650      	mov	r0, sl
  411b3e:	4631      	mov	r1, r6
  411b40:	f04f 0b00 	mov.w	fp, #0
  411b44:	e000      	b.n	411b48 <__multiply+0xd0>
  411b46:	4611      	mov	r1, r2
  411b48:	881a      	ldrh	r2, [r3, #0]
  411b4a:	0c00      	lsrs	r0, r0, #16
  411b4c:	fb09 0002 	mla	r0, r9, r2, r0
  411b50:	4483      	add	fp, r0
  411b52:	fa1f fa8a 	uxth.w	sl, sl
  411b56:	460a      	mov	r2, r1
  411b58:	ea4a 400b 	orr.w	r0, sl, fp, lsl #16
  411b5c:	f842 0b04 	str.w	r0, [r2], #4
  411b60:	f853 7b04 	ldr.w	r7, [r3], #4
  411b64:	6848      	ldr	r0, [r1, #4]
  411b66:	ea4f 4a17 	mov.w	sl, r7, lsr #16
  411b6a:	b284      	uxth	r4, r0
  411b6c:	fb09 4a0a 	mla	sl, r9, sl, r4
  411b70:	eb0a 4a1b 	add.w	sl, sl, fp, lsr #16
  411b74:	429d      	cmp	r5, r3
  411b76:	ea4f 4b1a 	mov.w	fp, sl, lsr #16
  411b7a:	d8e4      	bhi.n	411b46 <__multiply+0xce>
  411b7c:	f8c1 a004 	str.w	sl, [r1, #4]
  411b80:	45e0      	cmp	r8, ip
  411b82:	f106 0604 	add.w	r6, r6, #4
  411b86:	d8aa      	bhi.n	411ade <__multiply+0x66>
  411b88:	f8dd 8008 	ldr.w	r8, [sp, #8]
  411b8c:	9f03      	ldr	r7, [sp, #12]
  411b8e:	2f00      	cmp	r7, #0
  411b90:	dd0a      	ble.n	411ba8 <__multiply+0x130>
  411b92:	f858 3c04 	ldr.w	r3, [r8, #-4]
  411b96:	f1a8 0804 	sub.w	r8, r8, #4
  411b9a:	b11b      	cbz	r3, 411ba4 <__multiply+0x12c>
  411b9c:	e004      	b.n	411ba8 <__multiply+0x130>
  411b9e:	f858 3d04 	ldr.w	r3, [r8, #-4]!
  411ba2:	b90b      	cbnz	r3, 411ba8 <__multiply+0x130>
  411ba4:	3f01      	subs	r7, #1
  411ba6:	d1fa      	bne.n	411b9e <__multiply+0x126>
  411ba8:	9b01      	ldr	r3, [sp, #4]
  411baa:	4618      	mov	r0, r3
  411bac:	611f      	str	r7, [r3, #16]
  411bae:	b005      	add	sp, #20
  411bb0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00411bb4 <__pow5mult>:
  411bb4:	f012 0303 	ands.w	r3, r2, #3
  411bb8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  411bbc:	4614      	mov	r4, r2
  411bbe:	4607      	mov	r7, r0
  411bc0:	460e      	mov	r6, r1
  411bc2:	d12c      	bne.n	411c1e <__pow5mult+0x6a>
  411bc4:	10a4      	asrs	r4, r4, #2
  411bc6:	d01c      	beq.n	411c02 <__pow5mult+0x4e>
  411bc8:	6cbd      	ldr	r5, [r7, #72]	; 0x48
  411bca:	2d00      	cmp	r5, #0
  411bcc:	d030      	beq.n	411c30 <__pow5mult+0x7c>
  411bce:	f04f 0800 	mov.w	r8, #0
  411bd2:	e004      	b.n	411bde <__pow5mult+0x2a>
  411bd4:	1064      	asrs	r4, r4, #1
  411bd6:	d014      	beq.n	411c02 <__pow5mult+0x4e>
  411bd8:	6828      	ldr	r0, [r5, #0]
  411bda:	b1a8      	cbz	r0, 411c08 <__pow5mult+0x54>
  411bdc:	4605      	mov	r5, r0
  411bde:	07e3      	lsls	r3, r4, #31
  411be0:	d5f8      	bpl.n	411bd4 <__pow5mult+0x20>
  411be2:	4638      	mov	r0, r7
  411be4:	4631      	mov	r1, r6
  411be6:	462a      	mov	r2, r5
  411be8:	f7ff ff46 	bl	411a78 <__multiply>
  411bec:	b1ae      	cbz	r6, 411c1a <__pow5mult+0x66>
  411bee:	6872      	ldr	r2, [r6, #4]
  411bf0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  411bf2:	1064      	asrs	r4, r4, #1
  411bf4:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
  411bf8:	6031      	str	r1, [r6, #0]
  411bfa:	f843 6022 	str.w	r6, [r3, r2, lsl #2]
  411bfe:	4606      	mov	r6, r0
  411c00:	d1ea      	bne.n	411bd8 <__pow5mult+0x24>
  411c02:	4630      	mov	r0, r6
  411c04:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  411c08:	4638      	mov	r0, r7
  411c0a:	4629      	mov	r1, r5
  411c0c:	462a      	mov	r2, r5
  411c0e:	f7ff ff33 	bl	411a78 <__multiply>
  411c12:	6028      	str	r0, [r5, #0]
  411c14:	f8c0 8000 	str.w	r8, [r0]
  411c18:	e7e0      	b.n	411bdc <__pow5mult+0x28>
  411c1a:	4606      	mov	r6, r0
  411c1c:	e7da      	b.n	411bd4 <__pow5mult+0x20>
  411c1e:	1e5d      	subs	r5, r3, #1
  411c20:	4a0a      	ldr	r2, [pc, #40]	; (411c4c <__pow5mult+0x98>)
  411c22:	2300      	movs	r3, #0
  411c24:	f852 2025 	ldr.w	r2, [r2, r5, lsl #2]
  411c28:	f7ff fe36 	bl	411898 <__multadd>
  411c2c:	4606      	mov	r6, r0
  411c2e:	e7c9      	b.n	411bc4 <__pow5mult+0x10>
  411c30:	2101      	movs	r1, #1
  411c32:	4638      	mov	r0, r7
  411c34:	f7ff fe00 	bl	411838 <_Balloc>
  411c38:	f240 2171 	movw	r1, #625	; 0x271
  411c3c:	2201      	movs	r2, #1
  411c3e:	2300      	movs	r3, #0
  411c40:	6141      	str	r1, [r0, #20]
  411c42:	6102      	str	r2, [r0, #16]
  411c44:	4605      	mov	r5, r0
  411c46:	64b8      	str	r0, [r7, #72]	; 0x48
  411c48:	6003      	str	r3, [r0, #0]
  411c4a:	e7c0      	b.n	411bce <__pow5mult+0x1a>
  411c4c:	00417100 	.word	0x00417100

00411c50 <__lshift>:
  411c50:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  411c54:	4693      	mov	fp, r2
  411c56:	690a      	ldr	r2, [r1, #16]
  411c58:	688b      	ldr	r3, [r1, #8]
  411c5a:	ea4f 1a6b 	mov.w	sl, fp, asr #5
  411c5e:	eb0a 0902 	add.w	r9, sl, r2
  411c62:	f109 0601 	add.w	r6, r9, #1
  411c66:	429e      	cmp	r6, r3
  411c68:	460f      	mov	r7, r1
  411c6a:	4680      	mov	r8, r0
  411c6c:	6849      	ldr	r1, [r1, #4]
  411c6e:	dd04      	ble.n	411c7a <__lshift+0x2a>
  411c70:	005b      	lsls	r3, r3, #1
  411c72:	429e      	cmp	r6, r3
  411c74:	f101 0101 	add.w	r1, r1, #1
  411c78:	dcfa      	bgt.n	411c70 <__lshift+0x20>
  411c7a:	4640      	mov	r0, r8
  411c7c:	f7ff fddc 	bl	411838 <_Balloc>
  411c80:	f1ba 0f00 	cmp.w	sl, #0
  411c84:	f100 0414 	add.w	r4, r0, #20
  411c88:	dd09      	ble.n	411c9e <__lshift+0x4e>
  411c8a:	2300      	movs	r3, #0
  411c8c:	461a      	mov	r2, r3
  411c8e:	4625      	mov	r5, r4
  411c90:	3301      	adds	r3, #1
  411c92:	4553      	cmp	r3, sl
  411c94:	f845 2b04 	str.w	r2, [r5], #4
  411c98:	d1fa      	bne.n	411c90 <__lshift+0x40>
  411c9a:	eb04 0483 	add.w	r4, r4, r3, lsl #2
  411c9e:	693a      	ldr	r2, [r7, #16]
  411ca0:	f107 0314 	add.w	r3, r7, #20
  411ca4:	f01b 0b1f 	ands.w	fp, fp, #31
  411ca8:	eb03 0c82 	add.w	ip, r3, r2, lsl #2
  411cac:	d021      	beq.n	411cf2 <__lshift+0xa2>
  411cae:	f1cb 0a20 	rsb	sl, fp, #32
  411cb2:	2200      	movs	r2, #0
  411cb4:	e000      	b.n	411cb8 <__lshift+0x68>
  411cb6:	462c      	mov	r4, r5
  411cb8:	6819      	ldr	r1, [r3, #0]
  411cba:	4625      	mov	r5, r4
  411cbc:	fa01 f10b 	lsl.w	r1, r1, fp
  411cc0:	430a      	orrs	r2, r1
  411cc2:	f845 2b04 	str.w	r2, [r5], #4
  411cc6:	f853 2b04 	ldr.w	r2, [r3], #4
  411cca:	4563      	cmp	r3, ip
  411ccc:	fa22 f20a 	lsr.w	r2, r2, sl
  411cd0:	d3f1      	bcc.n	411cb6 <__lshift+0x66>
  411cd2:	6062      	str	r2, [r4, #4]
  411cd4:	b10a      	cbz	r2, 411cda <__lshift+0x8a>
  411cd6:	f109 0602 	add.w	r6, r9, #2
  411cda:	f8d8 304c 	ldr.w	r3, [r8, #76]	; 0x4c
  411cde:	687a      	ldr	r2, [r7, #4]
  411ce0:	3e01      	subs	r6, #1
  411ce2:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
  411ce6:	6106      	str	r6, [r0, #16]
  411ce8:	6039      	str	r1, [r7, #0]
  411cea:	f843 7022 	str.w	r7, [r3, r2, lsl #2]
  411cee:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  411cf2:	f853 2b04 	ldr.w	r2, [r3], #4
  411cf6:	f844 2b04 	str.w	r2, [r4], #4
  411cfa:	459c      	cmp	ip, r3
  411cfc:	d9ed      	bls.n	411cda <__lshift+0x8a>
  411cfe:	f853 2b04 	ldr.w	r2, [r3], #4
  411d02:	f844 2b04 	str.w	r2, [r4], #4
  411d06:	459c      	cmp	ip, r3
  411d08:	d8f3      	bhi.n	411cf2 <__lshift+0xa2>
  411d0a:	e7e6      	b.n	411cda <__lshift+0x8a>

00411d0c <__mcmp>:
  411d0c:	6902      	ldr	r2, [r0, #16]
  411d0e:	690b      	ldr	r3, [r1, #16]
  411d10:	1ad2      	subs	r2, r2, r3
  411d12:	b410      	push	{r4}
  411d14:	d115      	bne.n	411d42 <__mcmp+0x36>
  411d16:	009b      	lsls	r3, r3, #2
  411d18:	3014      	adds	r0, #20
  411d1a:	3114      	adds	r1, #20
  411d1c:	4419      	add	r1, r3
  411d1e:	4403      	add	r3, r0
  411d20:	e001      	b.n	411d26 <__mcmp+0x1a>
  411d22:	4298      	cmp	r0, r3
  411d24:	d211      	bcs.n	411d4a <__mcmp+0x3e>
  411d26:	f853 2d04 	ldr.w	r2, [r3, #-4]!
  411d2a:	f851 4d04 	ldr.w	r4, [r1, #-4]!
  411d2e:	42a2      	cmp	r2, r4
  411d30:	d0f7      	beq.n	411d22 <__mcmp+0x16>
  411d32:	4294      	cmp	r4, r2
  411d34:	bf94      	ite	ls
  411d36:	2001      	movls	r0, #1
  411d38:	f04f 30ff 	movhi.w	r0, #4294967295
  411d3c:	f85d 4b04 	ldr.w	r4, [sp], #4
  411d40:	4770      	bx	lr
  411d42:	4610      	mov	r0, r2
  411d44:	f85d 4b04 	ldr.w	r4, [sp], #4
  411d48:	4770      	bx	lr
  411d4a:	2000      	movs	r0, #0
  411d4c:	f85d 4b04 	ldr.w	r4, [sp], #4
  411d50:	4770      	bx	lr
  411d52:	bf00      	nop

00411d54 <__mdiff>:
  411d54:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  411d58:	460d      	mov	r5, r1
  411d5a:	4604      	mov	r4, r0
  411d5c:	4611      	mov	r1, r2
  411d5e:	4628      	mov	r0, r5
  411d60:	4616      	mov	r6, r2
  411d62:	f7ff ffd3 	bl	411d0c <__mcmp>
  411d66:	1e07      	subs	r7, r0, #0
  411d68:	d055      	beq.n	411e16 <__mdiff+0xc2>
  411d6a:	db4e      	blt.n	411e0a <__mdiff+0xb6>
  411d6c:	f04f 0800 	mov.w	r8, #0
  411d70:	6869      	ldr	r1, [r5, #4]
  411d72:	4620      	mov	r0, r4
  411d74:	f7ff fd60 	bl	411838 <_Balloc>
  411d78:	692f      	ldr	r7, [r5, #16]
  411d7a:	6932      	ldr	r2, [r6, #16]
  411d7c:	f8c0 800c 	str.w	r8, [r0, #12]
  411d80:	3514      	adds	r5, #20
  411d82:	3614      	adds	r6, #20
  411d84:	f100 0314 	add.w	r3, r0, #20
  411d88:	eb05 0c87 	add.w	ip, r5, r7, lsl #2
  411d8c:	eb06 0882 	add.w	r8, r6, r2, lsl #2
  411d90:	2100      	movs	r1, #0
  411d92:	f856 2b04 	ldr.w	r2, [r6], #4
  411d96:	f855 4b04 	ldr.w	r4, [r5], #4
  411d9a:	fa1f f982 	uxth.w	r9, r2
  411d9e:	fa11 fa84 	uxtah	sl, r1, r4
  411da2:	0c11      	lsrs	r1, r2, #16
  411da4:	ebc1 4114 	rsb	r1, r1, r4, lsr #16
  411da8:	ebc9 020a 	rsb	r2, r9, sl
  411dac:	eb01 4122 	add.w	r1, r1, r2, asr #16
  411db0:	b292      	uxth	r2, r2
  411db2:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
  411db6:	45b0      	cmp	r8, r6
  411db8:	f843 2b04 	str.w	r2, [r3], #4
  411dbc:	ea4f 4121 	mov.w	r1, r1, asr #16
  411dc0:	462c      	mov	r4, r5
  411dc2:	d8e6      	bhi.n	411d92 <__mdiff+0x3e>
  411dc4:	45ac      	cmp	ip, r5
  411dc6:	4698      	mov	r8, r3
  411dc8:	d915      	bls.n	411df6 <__mdiff+0xa2>
  411dca:	f854 6b04 	ldr.w	r6, [r4], #4
  411dce:	fa11 f186 	uxtah	r1, r1, r6
  411dd2:	0c36      	lsrs	r6, r6, #16
  411dd4:	eb06 4621 	add.w	r6, r6, r1, asr #16
  411dd8:	b289      	uxth	r1, r1
  411dda:	ea41 4206 	orr.w	r2, r1, r6, lsl #16
  411dde:	45a4      	cmp	ip, r4
  411de0:	f843 2b04 	str.w	r2, [r3], #4
  411de4:	ea4f 4126 	mov.w	r1, r6, asr #16
  411de8:	d8ef      	bhi.n	411dca <__mdiff+0x76>
  411dea:	43eb      	mvns	r3, r5
  411dec:	4463      	add	r3, ip
  411dee:	f023 0303 	bic.w	r3, r3, #3
  411df2:	3304      	adds	r3, #4
  411df4:	4443      	add	r3, r8
  411df6:	3b04      	subs	r3, #4
  411df8:	b922      	cbnz	r2, 411e04 <__mdiff+0xb0>
  411dfa:	f853 2d04 	ldr.w	r2, [r3, #-4]!
  411dfe:	3f01      	subs	r7, #1
  411e00:	2a00      	cmp	r2, #0
  411e02:	d0fa      	beq.n	411dfa <__mdiff+0xa6>
  411e04:	6107      	str	r7, [r0, #16]
  411e06:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  411e0a:	462b      	mov	r3, r5
  411e0c:	f04f 0801 	mov.w	r8, #1
  411e10:	4635      	mov	r5, r6
  411e12:	461e      	mov	r6, r3
  411e14:	e7ac      	b.n	411d70 <__mdiff+0x1c>
  411e16:	4620      	mov	r0, r4
  411e18:	4639      	mov	r1, r7
  411e1a:	f7ff fd0d 	bl	411838 <_Balloc>
  411e1e:	2301      	movs	r3, #1
  411e20:	6147      	str	r7, [r0, #20]
  411e22:	6103      	str	r3, [r0, #16]
  411e24:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

00411e28 <__ulp>:
  411e28:	4b0e      	ldr	r3, [pc, #56]	; (411e64 <__ulp+0x3c>)
  411e2a:	400b      	ands	r3, r1
  411e2c:	f1a3 7350 	sub.w	r3, r3, #54525952	; 0x3400000
  411e30:	2b00      	cmp	r3, #0
  411e32:	dd02      	ble.n	411e3a <__ulp+0x12>
  411e34:	4619      	mov	r1, r3
  411e36:	2000      	movs	r0, #0
  411e38:	4770      	bx	lr
  411e3a:	425b      	negs	r3, r3
  411e3c:	151b      	asrs	r3, r3, #20
  411e3e:	2b13      	cmp	r3, #19
  411e40:	dd0a      	ble.n	411e58 <__ulp+0x30>
  411e42:	2b32      	cmp	r3, #50	; 0x32
  411e44:	bfdd      	ittte	le
  411e46:	f1c3 0333 	rsble	r3, r3, #51	; 0x33
  411e4a:	2201      	movle	r2, #1
  411e4c:	fa02 f303 	lslle.w	r3, r2, r3
  411e50:	2301      	movgt	r3, #1
  411e52:	2100      	movs	r1, #0
  411e54:	4618      	mov	r0, r3
  411e56:	4770      	bx	lr
  411e58:	f44f 2200 	mov.w	r2, #524288	; 0x80000
  411e5c:	fa42 f103 	asr.w	r1, r2, r3
  411e60:	2000      	movs	r0, #0
  411e62:	4770      	bx	lr
  411e64:	7ff00000 	.word	0x7ff00000

00411e68 <__b2d>:
  411e68:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  411e6a:	6904      	ldr	r4, [r0, #16]
  411e6c:	f100 0614 	add.w	r6, r0, #20
  411e70:	eb06 0484 	add.w	r4, r6, r4, lsl #2
  411e74:	460f      	mov	r7, r1
  411e76:	f854 5c04 	ldr.w	r5, [r4, #-4]
  411e7a:	4628      	mov	r0, r5
  411e7c:	f7ff fda4 	bl	4119c8 <__hi0bits>
  411e80:	f1c0 0320 	rsb	r3, r0, #32
  411e84:	280a      	cmp	r0, #10
  411e86:	603b      	str	r3, [r7, #0]
  411e88:	f1a4 0104 	sub.w	r1, r4, #4
  411e8c:	dc19      	bgt.n	411ec2 <__b2d+0x5a>
  411e8e:	428e      	cmp	r6, r1
  411e90:	f1c0 070b 	rsb	r7, r0, #11
  411e94:	bf38      	it	cc
  411e96:	f854 1c08 	ldrcc.w	r1, [r4, #-8]
  411e9a:	fa25 fc07 	lsr.w	ip, r5, r7
  411e9e:	f100 0015 	add.w	r0, r0, #21
  411ea2:	bf38      	it	cc
  411ea4:	fa21 f707 	lsrcc.w	r7, r1, r7
  411ea8:	fa05 f500 	lsl.w	r5, r5, r0
  411eac:	f04c 537f 	orr.w	r3, ip, #1069547520	; 0x3fc00000
  411eb0:	bf28      	it	cs
  411eb2:	2700      	movcs	r7, #0
  411eb4:	f443 1340 	orr.w	r3, r3, #3145728	; 0x300000
  411eb8:	ea47 0205 	orr.w	r2, r7, r5
  411ebc:	4610      	mov	r0, r2
  411ebe:	4619      	mov	r1, r3
  411ec0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  411ec2:	428e      	cmp	r6, r1
  411ec4:	bf36      	itet	cc
  411ec6:	f1a4 0108 	subcc.w	r1, r4, #8
  411eca:	2400      	movcs	r4, #0
  411ecc:	f854 4c08 	ldrcc.w	r4, [r4, #-8]
  411ed0:	f1b0 070b 	subs.w	r7, r0, #11
  411ed4:	d019      	beq.n	411f0a <__b2d+0xa2>
  411ed6:	42b1      	cmp	r1, r6
  411ed8:	bf88      	it	hi
  411eda:	f851 1c04 	ldrhi.w	r1, [r1, #-4]
  411ede:	fa05 f507 	lsl.w	r5, r5, r7
  411ee2:	f1c0 002b 	rsb	r0, r0, #43	; 0x2b
  411ee6:	f045 557f 	orr.w	r5, r5, #1069547520	; 0x3fc00000
  411eea:	fa24 fc00 	lsr.w	ip, r4, r0
  411eee:	f445 1540 	orr.w	r5, r5, #3145728	; 0x300000
  411ef2:	bf8c      	ite	hi
  411ef4:	fa21 f000 	lsrhi.w	r0, r1, r0
  411ef8:	2000      	movls	r0, #0
  411efa:	40bc      	lsls	r4, r7
  411efc:	ea45 030c 	orr.w	r3, r5, ip
  411f00:	ea40 0204 	orr.w	r2, r0, r4
  411f04:	4610      	mov	r0, r2
  411f06:	4619      	mov	r1, r3
  411f08:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  411f0a:	f045 537f 	orr.w	r3, r5, #1069547520	; 0x3fc00000
  411f0e:	f443 1340 	orr.w	r3, r3, #3145728	; 0x300000
  411f12:	4622      	mov	r2, r4
  411f14:	4610      	mov	r0, r2
  411f16:	4619      	mov	r1, r3
  411f18:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  411f1a:	bf00      	nop

00411f1c <__d2b>:
  411f1c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  411f20:	b083      	sub	sp, #12
  411f22:	2101      	movs	r1, #1
  411f24:	461d      	mov	r5, r3
  411f26:	f3c3 560a 	ubfx	r6, r3, #20, #11
  411f2a:	4614      	mov	r4, r2
  411f2c:	9f0a      	ldr	r7, [sp, #40]	; 0x28
  411f2e:	f7ff fc83 	bl	411838 <_Balloc>
  411f32:	f3c5 0313 	ubfx	r3, r5, #0, #20
  411f36:	4680      	mov	r8, r0
  411f38:	b10e      	cbz	r6, 411f3e <__d2b+0x22>
  411f3a:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  411f3e:	9301      	str	r3, [sp, #4]
  411f40:	b324      	cbz	r4, 411f8c <__d2b+0x70>
  411f42:	a802      	add	r0, sp, #8
  411f44:	f840 4d08 	str.w	r4, [r0, #-8]!
  411f48:	4668      	mov	r0, sp
  411f4a:	f7ff fd5d 	bl	411a08 <__lo0bits>
  411f4e:	2800      	cmp	r0, #0
  411f50:	d135      	bne.n	411fbe <__d2b+0xa2>
  411f52:	e89d 000c 	ldmia.w	sp, {r2, r3}
  411f56:	f8c8 2014 	str.w	r2, [r8, #20]
  411f5a:	2b00      	cmp	r3, #0
  411f5c:	bf0c      	ite	eq
  411f5e:	2401      	moveq	r4, #1
  411f60:	2402      	movne	r4, #2
  411f62:	f8c8 3018 	str.w	r3, [r8, #24]
  411f66:	f8c8 4010 	str.w	r4, [r8, #16]
  411f6a:	b9de      	cbnz	r6, 411fa4 <__d2b+0x88>
  411f6c:	eb08 0384 	add.w	r3, r8, r4, lsl #2
  411f70:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
  411f74:	6038      	str	r0, [r7, #0]
  411f76:	6918      	ldr	r0, [r3, #16]
  411f78:	f7ff fd26 	bl	4119c8 <__hi0bits>
  411f7c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  411f7e:	ebc0 1044 	rsb	r0, r0, r4, lsl #5
  411f82:	6018      	str	r0, [r3, #0]
  411f84:	4640      	mov	r0, r8
  411f86:	b003      	add	sp, #12
  411f88:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  411f8c:	a801      	add	r0, sp, #4
  411f8e:	f7ff fd3b 	bl	411a08 <__lo0bits>
  411f92:	2401      	movs	r4, #1
  411f94:	9b01      	ldr	r3, [sp, #4]
  411f96:	f8c8 3014 	str.w	r3, [r8, #20]
  411f9a:	3020      	adds	r0, #32
  411f9c:	f8c8 4010 	str.w	r4, [r8, #16]
  411fa0:	2e00      	cmp	r6, #0
  411fa2:	d0e3      	beq.n	411f6c <__d2b+0x50>
  411fa4:	f2a6 4933 	subw	r9, r6, #1075	; 0x433
  411fa8:	eb09 0300 	add.w	r3, r9, r0
  411fac:	603b      	str	r3, [r7, #0]
  411fae:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  411fb0:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
  411fb4:	6018      	str	r0, [r3, #0]
  411fb6:	4640      	mov	r0, r8
  411fb8:	b003      	add	sp, #12
  411fba:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  411fbe:	e89d 000c 	ldmia.w	sp, {r2, r3}
  411fc2:	f1c0 0120 	rsb	r1, r0, #32
  411fc6:	fa03 f101 	lsl.w	r1, r3, r1
  411fca:	430a      	orrs	r2, r1
  411fcc:	40c3      	lsrs	r3, r0
  411fce:	9301      	str	r3, [sp, #4]
  411fd0:	f8c8 2014 	str.w	r2, [r8, #20]
  411fd4:	e7c1      	b.n	411f5a <__d2b+0x3e>
  411fd6:	bf00      	nop

00411fd8 <__ratio>:
  411fd8:	b5f0      	push	{r4, r5, r6, r7, lr}
  411fda:	b083      	sub	sp, #12
  411fdc:	460e      	mov	r6, r1
  411fde:	4669      	mov	r1, sp
  411fe0:	4607      	mov	r7, r0
  411fe2:	f7ff ff41 	bl	411e68 <__b2d>
  411fe6:	4604      	mov	r4, r0
  411fe8:	460d      	mov	r5, r1
  411fea:	4630      	mov	r0, r6
  411fec:	a901      	add	r1, sp, #4
  411fee:	f7ff ff3b 	bl	411e68 <__b2d>
  411ff2:	4602      	mov	r2, r0
  411ff4:	460b      	mov	r3, r1
  411ff6:	e89d 0003 	ldmia.w	sp, {r0, r1}
  411ffa:	693f      	ldr	r7, [r7, #16]
  411ffc:	6936      	ldr	r6, [r6, #16]
  411ffe:	1a41      	subs	r1, r0, r1
  412000:	ebc6 0e07 	rsb	lr, r6, r7
  412004:	eb01 1e4e 	add.w	lr, r1, lr, lsl #5
  412008:	f1be 0f00 	cmp.w	lr, #0
  41200c:	dd08      	ble.n	412020 <__ratio+0x48>
  41200e:	eb05 510e 	add.w	r1, r5, lr, lsl #20
  412012:	460d      	mov	r5, r1
  412014:	4620      	mov	r0, r4
  412016:	4629      	mov	r1, r5
  412018:	f002 fe94 	bl	414d44 <__aeabi_ddiv>
  41201c:	b003      	add	sp, #12
  41201e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  412020:	eba3 570e 	sub.w	r7, r3, lr, lsl #20
  412024:	463b      	mov	r3, r7
  412026:	e7f5      	b.n	412014 <__ratio+0x3c>

00412028 <__copybits>:
  412028:	b470      	push	{r4, r5, r6}
  41202a:	6915      	ldr	r5, [r2, #16]
  41202c:	f102 0314 	add.w	r3, r2, #20
  412030:	3901      	subs	r1, #1
  412032:	114e      	asrs	r6, r1, #5
  412034:	eb03 0585 	add.w	r5, r3, r5, lsl #2
  412038:	3601      	adds	r6, #1
  41203a:	42ab      	cmp	r3, r5
  41203c:	eb00 0686 	add.w	r6, r0, r6, lsl #2
  412040:	d20c      	bcs.n	41205c <__copybits+0x34>
  412042:	4601      	mov	r1, r0
  412044:	f853 4b04 	ldr.w	r4, [r3], #4
  412048:	f841 4b04 	str.w	r4, [r1], #4
  41204c:	429d      	cmp	r5, r3
  41204e:	d8f9      	bhi.n	412044 <__copybits+0x1c>
  412050:	1aab      	subs	r3, r5, r2
  412052:	3b15      	subs	r3, #21
  412054:	f023 0303 	bic.w	r3, r3, #3
  412058:	3304      	adds	r3, #4
  41205a:	4418      	add	r0, r3
  41205c:	4286      	cmp	r6, r0
  41205e:	d904      	bls.n	41206a <__copybits+0x42>
  412060:	2300      	movs	r3, #0
  412062:	f840 3b04 	str.w	r3, [r0], #4
  412066:	4286      	cmp	r6, r0
  412068:	d8fb      	bhi.n	412062 <__copybits+0x3a>
  41206a:	bc70      	pop	{r4, r5, r6}
  41206c:	4770      	bx	lr
  41206e:	bf00      	nop

00412070 <__any_on>:
  412070:	6903      	ldr	r3, [r0, #16]
  412072:	114a      	asrs	r2, r1, #5
  412074:	4293      	cmp	r3, r2
  412076:	b410      	push	{r4}
  412078:	f100 0414 	add.w	r4, r0, #20
  41207c:	da10      	bge.n	4120a0 <__any_on+0x30>
  41207e:	eb04 0383 	add.w	r3, r4, r3, lsl #2
  412082:	429c      	cmp	r4, r3
  412084:	d221      	bcs.n	4120ca <__any_on+0x5a>
  412086:	f853 0c04 	ldr.w	r0, [r3, #-4]
  41208a:	3b04      	subs	r3, #4
  41208c:	b118      	cbz	r0, 412096 <__any_on+0x26>
  41208e:	e015      	b.n	4120bc <__any_on+0x4c>
  412090:	f853 2d04 	ldr.w	r2, [r3, #-4]!
  412094:	b992      	cbnz	r2, 4120bc <__any_on+0x4c>
  412096:	429c      	cmp	r4, r3
  412098:	d3fa      	bcc.n	412090 <__any_on+0x20>
  41209a:	f85d 4b04 	ldr.w	r4, [sp], #4
  41209e:	4770      	bx	lr
  4120a0:	dd10      	ble.n	4120c4 <__any_on+0x54>
  4120a2:	f011 011f 	ands.w	r1, r1, #31
  4120a6:	d00d      	beq.n	4120c4 <__any_on+0x54>
  4120a8:	f854 0022 	ldr.w	r0, [r4, r2, lsl #2]
  4120ac:	fa20 f301 	lsr.w	r3, r0, r1
  4120b0:	fa03 f101 	lsl.w	r1, r3, r1
  4120b4:	4281      	cmp	r1, r0
  4120b6:	eb04 0382 	add.w	r3, r4, r2, lsl #2
  4120ba:	d0e2      	beq.n	412082 <__any_on+0x12>
  4120bc:	2001      	movs	r0, #1
  4120be:	f85d 4b04 	ldr.w	r4, [sp], #4
  4120c2:	4770      	bx	lr
  4120c4:	eb04 0382 	add.w	r3, r4, r2, lsl #2
  4120c8:	e7db      	b.n	412082 <__any_on+0x12>
  4120ca:	2000      	movs	r0, #0
  4120cc:	e7e5      	b.n	41209a <__any_on+0x2a>
  4120ce:	bf00      	nop

004120d0 <_read_r>:
  4120d0:	b570      	push	{r4, r5, r6, lr}
  4120d2:	4c08      	ldr	r4, [pc, #32]	; (4120f4 <_read_r+0x24>)
  4120d4:	4606      	mov	r6, r0
  4120d6:	2500      	movs	r5, #0
  4120d8:	4608      	mov	r0, r1
  4120da:	4611      	mov	r1, r2
  4120dc:	461a      	mov	r2, r3
  4120de:	6025      	str	r5, [r4, #0]
  4120e0:	f7f1 f9e8 	bl	4034b4 <_read>
  4120e4:	1c43      	adds	r3, r0, #1
  4120e6:	d000      	beq.n	4120ea <_read_r+0x1a>
  4120e8:	bd70      	pop	{r4, r5, r6, pc}
  4120ea:	6823      	ldr	r3, [r4, #0]
  4120ec:	2b00      	cmp	r3, #0
  4120ee:	d0fb      	beq.n	4120e8 <_read_r+0x18>
  4120f0:	6033      	str	r3, [r6, #0]
  4120f2:	bd70      	pop	{r4, r5, r6, pc}
  4120f4:	2000503c 	.word	0x2000503c

004120f8 <_realloc_r>:
  4120f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4120fc:	460c      	mov	r4, r1
  4120fe:	b083      	sub	sp, #12
  412100:	4690      	mov	r8, r2
  412102:	4681      	mov	r9, r0
  412104:	2900      	cmp	r1, #0
  412106:	f000 80e2 	beq.w	4122ce <_realloc_r+0x1d6>
  41210a:	f7fa f951 	bl	40c3b0 <__malloc_lock>
  41210e:	f108 060b 	add.w	r6, r8, #11
  412112:	f854 3c04 	ldr.w	r3, [r4, #-4]
  412116:	2e16      	cmp	r6, #22
  412118:	f023 0503 	bic.w	r5, r3, #3
  41211c:	f1a4 0708 	sub.w	r7, r4, #8
  412120:	d84b      	bhi.n	4121ba <_realloc_r+0xc2>
  412122:	2110      	movs	r1, #16
  412124:	460e      	mov	r6, r1
  412126:	45b0      	cmp	r8, r6
  412128:	d84c      	bhi.n	4121c4 <_realloc_r+0xcc>
  41212a:	428d      	cmp	r5, r1
  41212c:	da78      	bge.n	412220 <_realloc_r+0x128>
  41212e:	f8df b390 	ldr.w	fp, [pc, #912]	; 4124c0 <_realloc_r+0x3c8>
  412132:	f8db e008 	ldr.w	lr, [fp, #8]
  412136:	1978      	adds	r0, r7, r5
  412138:	4586      	cmp	lr, r0
  41213a:	f000 80ce 	beq.w	4122da <_realloc_r+0x1e2>
  41213e:	6842      	ldr	r2, [r0, #4]
  412140:	f022 0c01 	bic.w	ip, r2, #1
  412144:	4484      	add	ip, r0
  412146:	f8dc c004 	ldr.w	ip, [ip, #4]
  41214a:	f01c 0f01 	tst.w	ip, #1
  41214e:	d07a      	beq.n	412246 <_realloc_r+0x14e>
  412150:	2200      	movs	r2, #0
  412152:	4610      	mov	r0, r2
  412154:	07db      	lsls	r3, r3, #31
  412156:	f100 8092 	bmi.w	41227e <_realloc_r+0x186>
  41215a:	f854 3c08 	ldr.w	r3, [r4, #-8]
  41215e:	ebc3 0a07 	rsb	sl, r3, r7
  412162:	f8da 3004 	ldr.w	r3, [sl, #4]
  412166:	f023 0303 	bic.w	r3, r3, #3
  41216a:	442b      	add	r3, r5
  41216c:	b388      	cbz	r0, 4121d2 <_realloc_r+0xda>
  41216e:	4570      	cmp	r0, lr
  412170:	f000 80ed 	beq.w	41234e <_realloc_r+0x256>
  412174:	eb02 0e03 	add.w	lr, r2, r3
  412178:	458e      	cmp	lr, r1
  41217a:	db2a      	blt.n	4121d2 <_realloc_r+0xda>
  41217c:	68c3      	ldr	r3, [r0, #12]
  41217e:	6882      	ldr	r2, [r0, #8]
  412180:	4657      	mov	r7, sl
  412182:	60d3      	str	r3, [r2, #12]
  412184:	609a      	str	r2, [r3, #8]
  412186:	f857 1f08 	ldr.w	r1, [r7, #8]!
  41218a:	f8da 300c 	ldr.w	r3, [sl, #12]
  41218e:	60cb      	str	r3, [r1, #12]
  412190:	1f2a      	subs	r2, r5, #4
  412192:	2a24      	cmp	r2, #36	; 0x24
  412194:	6099      	str	r1, [r3, #8]
  412196:	f200 8126 	bhi.w	4123e6 <_realloc_r+0x2ee>
  41219a:	2a13      	cmp	r2, #19
  41219c:	f240 80b3 	bls.w	412306 <_realloc_r+0x20e>
  4121a0:	6823      	ldr	r3, [r4, #0]
  4121a2:	f8ca 3008 	str.w	r3, [sl, #8]
  4121a6:	6863      	ldr	r3, [r4, #4]
  4121a8:	f8ca 300c 	str.w	r3, [sl, #12]
  4121ac:	2a1b      	cmp	r2, #27
  4121ae:	f200 8130 	bhi.w	412412 <_realloc_r+0x31a>
  4121b2:	3408      	adds	r4, #8
  4121b4:	f10a 0310 	add.w	r3, sl, #16
  4121b8:	e0a6      	b.n	412308 <_realloc_r+0x210>
  4121ba:	f026 0607 	bic.w	r6, r6, #7
  4121be:	2e00      	cmp	r6, #0
  4121c0:	4631      	mov	r1, r6
  4121c2:	dab0      	bge.n	412126 <_realloc_r+0x2e>
  4121c4:	230c      	movs	r3, #12
  4121c6:	2000      	movs	r0, #0
  4121c8:	f8c9 3000 	str.w	r3, [r9]
  4121cc:	b003      	add	sp, #12
  4121ce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4121d2:	428b      	cmp	r3, r1
  4121d4:	db53      	blt.n	41227e <_realloc_r+0x186>
  4121d6:	4657      	mov	r7, sl
  4121d8:	f8da 100c 	ldr.w	r1, [sl, #12]
  4121dc:	f857 0f08 	ldr.w	r0, [r7, #8]!
  4121e0:	1f2a      	subs	r2, r5, #4
  4121e2:	2a24      	cmp	r2, #36	; 0x24
  4121e4:	60c1      	str	r1, [r0, #12]
  4121e6:	6088      	str	r0, [r1, #8]
  4121e8:	f200 8109 	bhi.w	4123fe <_realloc_r+0x306>
  4121ec:	2a13      	cmp	r2, #19
  4121ee:	f240 8104 	bls.w	4123fa <_realloc_r+0x302>
  4121f2:	6821      	ldr	r1, [r4, #0]
  4121f4:	f8ca 1008 	str.w	r1, [sl, #8]
  4121f8:	6861      	ldr	r1, [r4, #4]
  4121fa:	f8ca 100c 	str.w	r1, [sl, #12]
  4121fe:	2a1b      	cmp	r2, #27
  412200:	f200 811c 	bhi.w	41243c <_realloc_r+0x344>
  412204:	3408      	adds	r4, #8
  412206:	f10a 0210 	add.w	r2, sl, #16
  41220a:	6821      	ldr	r1, [r4, #0]
  41220c:	6011      	str	r1, [r2, #0]
  41220e:	6861      	ldr	r1, [r4, #4]
  412210:	6051      	str	r1, [r2, #4]
  412212:	68a1      	ldr	r1, [r4, #8]
  412214:	6091      	str	r1, [r2, #8]
  412216:	461d      	mov	r5, r3
  412218:	f8da 3004 	ldr.w	r3, [sl, #4]
  41221c:	463c      	mov	r4, r7
  41221e:	4657      	mov	r7, sl
  412220:	1baa      	subs	r2, r5, r6
  412222:	2a0f      	cmp	r2, #15
  412224:	f003 0301 	and.w	r3, r3, #1
  412228:	d819      	bhi.n	41225e <_realloc_r+0x166>
  41222a:	432b      	orrs	r3, r5
  41222c:	443d      	add	r5, r7
  41222e:	607b      	str	r3, [r7, #4]
  412230:	686b      	ldr	r3, [r5, #4]
  412232:	f043 0301 	orr.w	r3, r3, #1
  412236:	606b      	str	r3, [r5, #4]
  412238:	4648      	mov	r0, r9
  41223a:	f7fa f8bb 	bl	40c3b4 <__malloc_unlock>
  41223e:	4620      	mov	r0, r4
  412240:	b003      	add	sp, #12
  412242:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  412246:	f022 0203 	bic.w	r2, r2, #3
  41224a:	eb02 0c05 	add.w	ip, r2, r5
  41224e:	458c      	cmp	ip, r1
  412250:	db80      	blt.n	412154 <_realloc_r+0x5c>
  412252:	68c2      	ldr	r2, [r0, #12]
  412254:	6881      	ldr	r1, [r0, #8]
  412256:	4665      	mov	r5, ip
  412258:	60ca      	str	r2, [r1, #12]
  41225a:	6091      	str	r1, [r2, #8]
  41225c:	e7e0      	b.n	412220 <_realloc_r+0x128>
  41225e:	19b9      	adds	r1, r7, r6
  412260:	f042 0001 	orr.w	r0, r2, #1
  412264:	431e      	orrs	r6, r3
  412266:	440a      	add	r2, r1
  412268:	607e      	str	r6, [r7, #4]
  41226a:	6048      	str	r0, [r1, #4]
  41226c:	6853      	ldr	r3, [r2, #4]
  41226e:	f043 0301 	orr.w	r3, r3, #1
  412272:	3108      	adds	r1, #8
  412274:	6053      	str	r3, [r2, #4]
  412276:	4648      	mov	r0, r9
  412278:	f7fe ff32 	bl	4110e0 <_free_r>
  41227c:	e7dc      	b.n	412238 <_realloc_r+0x140>
  41227e:	4641      	mov	r1, r8
  412280:	4648      	mov	r0, r9
  412282:	f7f9 fcb5 	bl	40bbf0 <_malloc_r>
  412286:	4680      	mov	r8, r0
  412288:	b1d0      	cbz	r0, 4122c0 <_realloc_r+0x1c8>
  41228a:	f854 3c04 	ldr.w	r3, [r4, #-4]
  41228e:	f023 0201 	bic.w	r2, r3, #1
  412292:	443a      	add	r2, r7
  412294:	f1a0 0108 	sub.w	r1, r0, #8
  412298:	4291      	cmp	r1, r2
  41229a:	f000 809e 	beq.w	4123da <_realloc_r+0x2e2>
  41229e:	1f2a      	subs	r2, r5, #4
  4122a0:	2a24      	cmp	r2, #36	; 0x24
  4122a2:	d850      	bhi.n	412346 <_realloc_r+0x24e>
  4122a4:	2a13      	cmp	r2, #19
  4122a6:	d823      	bhi.n	4122f0 <_realloc_r+0x1f8>
  4122a8:	4603      	mov	r3, r0
  4122aa:	4622      	mov	r2, r4
  4122ac:	6811      	ldr	r1, [r2, #0]
  4122ae:	6019      	str	r1, [r3, #0]
  4122b0:	6851      	ldr	r1, [r2, #4]
  4122b2:	6059      	str	r1, [r3, #4]
  4122b4:	6892      	ldr	r2, [r2, #8]
  4122b6:	609a      	str	r2, [r3, #8]
  4122b8:	4621      	mov	r1, r4
  4122ba:	4648      	mov	r0, r9
  4122bc:	f7fe ff10 	bl	4110e0 <_free_r>
  4122c0:	4648      	mov	r0, r9
  4122c2:	f7fa f877 	bl	40c3b4 <__malloc_unlock>
  4122c6:	4640      	mov	r0, r8
  4122c8:	b003      	add	sp, #12
  4122ca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4122ce:	4611      	mov	r1, r2
  4122d0:	b003      	add	sp, #12
  4122d2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4122d6:	f7f9 bc8b 	b.w	40bbf0 <_malloc_r>
  4122da:	f8de 2004 	ldr.w	r2, [lr, #4]
  4122de:	f022 0203 	bic.w	r2, r2, #3
  4122e2:	1950      	adds	r0, r2, r5
  4122e4:	f106 0c10 	add.w	ip, r6, #16
  4122e8:	4560      	cmp	r0, ip
  4122ea:	da19      	bge.n	412320 <_realloc_r+0x228>
  4122ec:	4670      	mov	r0, lr
  4122ee:	e731      	b.n	412154 <_realloc_r+0x5c>
  4122f0:	6823      	ldr	r3, [r4, #0]
  4122f2:	6003      	str	r3, [r0, #0]
  4122f4:	6863      	ldr	r3, [r4, #4]
  4122f6:	6043      	str	r3, [r0, #4]
  4122f8:	2a1b      	cmp	r2, #27
  4122fa:	d863      	bhi.n	4123c4 <_realloc_r+0x2cc>
  4122fc:	f100 0308 	add.w	r3, r0, #8
  412300:	f104 0208 	add.w	r2, r4, #8
  412304:	e7d2      	b.n	4122ac <_realloc_r+0x1b4>
  412306:	463b      	mov	r3, r7
  412308:	6822      	ldr	r2, [r4, #0]
  41230a:	601a      	str	r2, [r3, #0]
  41230c:	6862      	ldr	r2, [r4, #4]
  41230e:	605a      	str	r2, [r3, #4]
  412310:	68a2      	ldr	r2, [r4, #8]
  412312:	609a      	str	r2, [r3, #8]
  412314:	463c      	mov	r4, r7
  412316:	4675      	mov	r5, lr
  412318:	f8da 3004 	ldr.w	r3, [sl, #4]
  41231c:	4657      	mov	r7, sl
  41231e:	e77f      	b.n	412220 <_realloc_r+0x128>
  412320:	4437      	add	r7, r6
  412322:	1b83      	subs	r3, r0, r6
  412324:	f043 0301 	orr.w	r3, r3, #1
  412328:	f8cb 7008 	str.w	r7, [fp, #8]
  41232c:	607b      	str	r3, [r7, #4]
  41232e:	f854 3c04 	ldr.w	r3, [r4, #-4]
  412332:	f003 0301 	and.w	r3, r3, #1
  412336:	431e      	orrs	r6, r3
  412338:	4648      	mov	r0, r9
  41233a:	f844 6c04 	str.w	r6, [r4, #-4]
  41233e:	f7fa f839 	bl	40c3b4 <__malloc_unlock>
  412342:	4620      	mov	r0, r4
  412344:	e77c      	b.n	412240 <_realloc_r+0x148>
  412346:	4621      	mov	r1, r4
  412348:	f7f9 ff88 	bl	40c25c <memmove>
  41234c:	e7b4      	b.n	4122b8 <_realloc_r+0x1c0>
  41234e:	eb02 0c03 	add.w	ip, r2, r3
  412352:	f106 0210 	add.w	r2, r6, #16
  412356:	4594      	cmp	ip, r2
  412358:	f6ff af3b 	blt.w	4121d2 <_realloc_r+0xda>
  41235c:	4657      	mov	r7, sl
  41235e:	f8da 300c 	ldr.w	r3, [sl, #12]
  412362:	f857 1f08 	ldr.w	r1, [r7, #8]!
  412366:	1f2a      	subs	r2, r5, #4
  412368:	2a24      	cmp	r2, #36	; 0x24
  41236a:	60cb      	str	r3, [r1, #12]
  41236c:	6099      	str	r1, [r3, #8]
  41236e:	f200 8087 	bhi.w	412480 <_realloc_r+0x388>
  412372:	2a13      	cmp	r2, #19
  412374:	d978      	bls.n	412468 <_realloc_r+0x370>
  412376:	6823      	ldr	r3, [r4, #0]
  412378:	f8ca 3008 	str.w	r3, [sl, #8]
  41237c:	6863      	ldr	r3, [r4, #4]
  41237e:	f8ca 300c 	str.w	r3, [sl, #12]
  412382:	2a1b      	cmp	r2, #27
  412384:	f200 8085 	bhi.w	412492 <_realloc_r+0x39a>
  412388:	3408      	adds	r4, #8
  41238a:	f10a 0310 	add.w	r3, sl, #16
  41238e:	6822      	ldr	r2, [r4, #0]
  412390:	601a      	str	r2, [r3, #0]
  412392:	6862      	ldr	r2, [r4, #4]
  412394:	605a      	str	r2, [r3, #4]
  412396:	68a2      	ldr	r2, [r4, #8]
  412398:	609a      	str	r2, [r3, #8]
  41239a:	eb0a 0306 	add.w	r3, sl, r6
  41239e:	ebc6 020c 	rsb	r2, r6, ip
  4123a2:	f042 0201 	orr.w	r2, r2, #1
  4123a6:	f8cb 3008 	str.w	r3, [fp, #8]
  4123aa:	605a      	str	r2, [r3, #4]
  4123ac:	f8da 3004 	ldr.w	r3, [sl, #4]
  4123b0:	f003 0301 	and.w	r3, r3, #1
  4123b4:	431e      	orrs	r6, r3
  4123b6:	4648      	mov	r0, r9
  4123b8:	f8ca 6004 	str.w	r6, [sl, #4]
  4123bc:	f7f9 fffa 	bl	40c3b4 <__malloc_unlock>
  4123c0:	4638      	mov	r0, r7
  4123c2:	e73d      	b.n	412240 <_realloc_r+0x148>
  4123c4:	68a3      	ldr	r3, [r4, #8]
  4123c6:	6083      	str	r3, [r0, #8]
  4123c8:	68e3      	ldr	r3, [r4, #12]
  4123ca:	60c3      	str	r3, [r0, #12]
  4123cc:	2a24      	cmp	r2, #36	; 0x24
  4123ce:	d02c      	beq.n	41242a <_realloc_r+0x332>
  4123d0:	f100 0310 	add.w	r3, r0, #16
  4123d4:	f104 0210 	add.w	r2, r4, #16
  4123d8:	e768      	b.n	4122ac <_realloc_r+0x1b4>
  4123da:	f850 2c04 	ldr.w	r2, [r0, #-4]
  4123de:	f022 0203 	bic.w	r2, r2, #3
  4123e2:	4415      	add	r5, r2
  4123e4:	e71c      	b.n	412220 <_realloc_r+0x128>
  4123e6:	4621      	mov	r1, r4
  4123e8:	4638      	mov	r0, r7
  4123ea:	4675      	mov	r5, lr
  4123ec:	463c      	mov	r4, r7
  4123ee:	f7f9 ff35 	bl	40c25c <memmove>
  4123f2:	4657      	mov	r7, sl
  4123f4:	f8da 3004 	ldr.w	r3, [sl, #4]
  4123f8:	e712      	b.n	412220 <_realloc_r+0x128>
  4123fa:	463a      	mov	r2, r7
  4123fc:	e705      	b.n	41220a <_realloc_r+0x112>
  4123fe:	4621      	mov	r1, r4
  412400:	4638      	mov	r0, r7
  412402:	461d      	mov	r5, r3
  412404:	463c      	mov	r4, r7
  412406:	f7f9 ff29 	bl	40c25c <memmove>
  41240a:	4657      	mov	r7, sl
  41240c:	f8da 3004 	ldr.w	r3, [sl, #4]
  412410:	e706      	b.n	412220 <_realloc_r+0x128>
  412412:	68a3      	ldr	r3, [r4, #8]
  412414:	f8ca 3010 	str.w	r3, [sl, #16]
  412418:	68e3      	ldr	r3, [r4, #12]
  41241a:	f8ca 3014 	str.w	r3, [sl, #20]
  41241e:	2a24      	cmp	r2, #36	; 0x24
  412420:	d018      	beq.n	412454 <_realloc_r+0x35c>
  412422:	3410      	adds	r4, #16
  412424:	f10a 0318 	add.w	r3, sl, #24
  412428:	e76e      	b.n	412308 <_realloc_r+0x210>
  41242a:	6923      	ldr	r3, [r4, #16]
  41242c:	6103      	str	r3, [r0, #16]
  41242e:	6963      	ldr	r3, [r4, #20]
  412430:	6143      	str	r3, [r0, #20]
  412432:	f104 0218 	add.w	r2, r4, #24
  412436:	f100 0318 	add.w	r3, r0, #24
  41243a:	e737      	b.n	4122ac <_realloc_r+0x1b4>
  41243c:	68a1      	ldr	r1, [r4, #8]
  41243e:	f8ca 1010 	str.w	r1, [sl, #16]
  412442:	68e1      	ldr	r1, [r4, #12]
  412444:	f8ca 1014 	str.w	r1, [sl, #20]
  412448:	2a24      	cmp	r2, #36	; 0x24
  41244a:	d00f      	beq.n	41246c <_realloc_r+0x374>
  41244c:	3410      	adds	r4, #16
  41244e:	f10a 0218 	add.w	r2, sl, #24
  412452:	e6da      	b.n	41220a <_realloc_r+0x112>
  412454:	6923      	ldr	r3, [r4, #16]
  412456:	f8ca 3018 	str.w	r3, [sl, #24]
  41245a:	6963      	ldr	r3, [r4, #20]
  41245c:	f8ca 301c 	str.w	r3, [sl, #28]
  412460:	3418      	adds	r4, #24
  412462:	f10a 0320 	add.w	r3, sl, #32
  412466:	e74f      	b.n	412308 <_realloc_r+0x210>
  412468:	463b      	mov	r3, r7
  41246a:	e790      	b.n	41238e <_realloc_r+0x296>
  41246c:	6922      	ldr	r2, [r4, #16]
  41246e:	f8ca 2018 	str.w	r2, [sl, #24]
  412472:	6962      	ldr	r2, [r4, #20]
  412474:	f8ca 201c 	str.w	r2, [sl, #28]
  412478:	3418      	adds	r4, #24
  41247a:	f10a 0220 	add.w	r2, sl, #32
  41247e:	e6c4      	b.n	41220a <_realloc_r+0x112>
  412480:	4621      	mov	r1, r4
  412482:	4638      	mov	r0, r7
  412484:	f8cd c004 	str.w	ip, [sp, #4]
  412488:	f7f9 fee8 	bl	40c25c <memmove>
  41248c:	f8dd c004 	ldr.w	ip, [sp, #4]
  412490:	e783      	b.n	41239a <_realloc_r+0x2a2>
  412492:	68a3      	ldr	r3, [r4, #8]
  412494:	f8ca 3010 	str.w	r3, [sl, #16]
  412498:	68e3      	ldr	r3, [r4, #12]
  41249a:	f8ca 3014 	str.w	r3, [sl, #20]
  41249e:	2a24      	cmp	r2, #36	; 0x24
  4124a0:	d003      	beq.n	4124aa <_realloc_r+0x3b2>
  4124a2:	3410      	adds	r4, #16
  4124a4:	f10a 0318 	add.w	r3, sl, #24
  4124a8:	e771      	b.n	41238e <_realloc_r+0x296>
  4124aa:	6923      	ldr	r3, [r4, #16]
  4124ac:	f8ca 3018 	str.w	r3, [sl, #24]
  4124b0:	6963      	ldr	r3, [r4, #20]
  4124b2:	f8ca 301c 	str.w	r3, [sl, #28]
  4124b6:	3418      	adds	r4, #24
  4124b8:	f10a 0320 	add.w	r3, sl, #32
  4124bc:	e767      	b.n	41238e <_realloc_r+0x296>
  4124be:	bf00      	nop
  4124c0:	20000b34 	.word	0x20000b34

004124c4 <__fpclassifyd>:
  4124c4:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
  4124c8:	b410      	push	{r4}
  4124ca:	d008      	beq.n	4124de <__fpclassifyd+0x1a>
  4124cc:	4a0f      	ldr	r2, [pc, #60]	; (41250c <__fpclassifyd+0x48>)
  4124ce:	f5a3 1480 	sub.w	r4, r3, #1048576	; 0x100000
  4124d2:	4294      	cmp	r4, r2
  4124d4:	d80a      	bhi.n	4124ec <__fpclassifyd+0x28>
  4124d6:	2004      	movs	r0, #4
  4124d8:	f85d 4b04 	ldr.w	r4, [sp], #4
  4124dc:	4770      	bx	lr
  4124de:	2800      	cmp	r0, #0
  4124e0:	bf0c      	ite	eq
  4124e2:	2002      	moveq	r0, #2
  4124e4:	2003      	movne	r0, #3
  4124e6:	f85d 4b04 	ldr.w	r4, [sp], #4
  4124ea:	4770      	bx	lr
  4124ec:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
  4124f0:	d201      	bcs.n	4124f6 <__fpclassifyd+0x32>
  4124f2:	2003      	movs	r0, #3
  4124f4:	e7f7      	b.n	4124e6 <__fpclassifyd+0x22>
  4124f6:	4a06      	ldr	r2, [pc, #24]	; (412510 <__fpclassifyd+0x4c>)
  4124f8:	4293      	cmp	r3, r2
  4124fa:	d001      	beq.n	412500 <__fpclassifyd+0x3c>
  4124fc:	2000      	movs	r0, #0
  4124fe:	e7f2      	b.n	4124e6 <__fpclassifyd+0x22>
  412500:	f1d0 0001 	rsbs	r0, r0, #1
  412504:	bf38      	it	cc
  412506:	2000      	movcc	r0, #0
  412508:	e7ed      	b.n	4124e6 <__fpclassifyd+0x22>
  41250a:	bf00      	nop
  41250c:	7fdfffff 	.word	0x7fdfffff
  412510:	7ff00000 	.word	0x7ff00000

00412514 <__sccl>:
  412514:	b470      	push	{r4, r5, r6}
  412516:	780c      	ldrb	r4, [r1, #0]
  412518:	2c5e      	cmp	r4, #94	; 0x5e
  41251a:	d02e      	beq.n	41257a <__sccl+0x66>
  41251c:	2200      	movs	r2, #0
  41251e:	1c4d      	adds	r5, r1, #1
  412520:	4616      	mov	r6, r2
  412522:	2300      	movs	r3, #0
  412524:	54c2      	strb	r2, [r0, r3]
  412526:	3301      	adds	r3, #1
  412528:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  41252c:	d1fa      	bne.n	412524 <__sccl+0x10>
  41252e:	b184      	cbz	r4, 412552 <__sccl+0x3e>
  412530:	f086 0201 	eor.w	r2, r6, #1
  412534:	5502      	strb	r2, [r0, r4]
  412536:	1c6e      	adds	r6, r5, #1
  412538:	f816 3c01 	ldrb.w	r3, [r6, #-1]
  41253c:	2b2d      	cmp	r3, #45	; 0x2d
  41253e:	d00e      	beq.n	41255e <__sccl+0x4a>
  412540:	2b5d      	cmp	r3, #93	; 0x5d
  412542:	d009      	beq.n	412558 <__sccl+0x44>
  412544:	b113      	cbz	r3, 41254c <__sccl+0x38>
  412546:	461c      	mov	r4, r3
  412548:	4635      	mov	r5, r6
  41254a:	e7f3      	b.n	412534 <__sccl+0x20>
  41254c:	4628      	mov	r0, r5
  41254e:	bc70      	pop	{r4, r5, r6}
  412550:	4770      	bx	lr
  412552:	1e68      	subs	r0, r5, #1
  412554:	bc70      	pop	{r4, r5, r6}
  412556:	4770      	bx	lr
  412558:	4630      	mov	r0, r6
  41255a:	bc70      	pop	{r4, r5, r6}
  41255c:	4770      	bx	lr
  41255e:	7869      	ldrb	r1, [r5, #1]
  412560:	295d      	cmp	r1, #93	; 0x5d
  412562:	d0f0      	beq.n	412546 <__sccl+0x32>
  412564:	428c      	cmp	r4, r1
  412566:	dcee      	bgt.n	412546 <__sccl+0x32>
  412568:	3502      	adds	r5, #2
  41256a:	1903      	adds	r3, r0, r4
  41256c:	3401      	adds	r4, #1
  41256e:	42a1      	cmp	r1, r4
  412570:	f803 2f01 	strb.w	r2, [r3, #1]!
  412574:	dcfa      	bgt.n	41256c <__sccl+0x58>
  412576:	3602      	adds	r6, #2
  412578:	e7de      	b.n	412538 <__sccl+0x24>
  41257a:	2201      	movs	r2, #1
  41257c:	784c      	ldrb	r4, [r1, #1]
  41257e:	4616      	mov	r6, r2
  412580:	1c8d      	adds	r5, r1, #2
  412582:	e7ce      	b.n	412522 <__sccl+0xe>

00412584 <nanf>:
  412584:	4800      	ldr	r0, [pc, #0]	; (412588 <nanf+0x4>)
  412586:	4770      	bx	lr
  412588:	7fc00000 	.word	0x7fc00000

0041258c <sulp>:
  41258c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  412590:	460d      	mov	r5, r1
  412592:	4690      	mov	r8, r2
  412594:	f7ff fc48 	bl	411e28 <__ulp>
  412598:	4606      	mov	r6, r0
  41259a:	460f      	mov	r7, r1
  41259c:	f1b8 0f00 	cmp.w	r8, #0
  4125a0:	d00f      	beq.n	4125c2 <sulp+0x36>
  4125a2:	f3c5 530a 	ubfx	r3, r5, #20, #11
  4125a6:	f1c3 036b 	rsb	r3, r3, #107	; 0x6b
  4125aa:	2b00      	cmp	r3, #0
  4125ac:	dd09      	ble.n	4125c2 <sulp+0x36>
  4125ae:	051c      	lsls	r4, r3, #20
  4125b0:	f104 537f 	add.w	r3, r4, #1069547520	; 0x3fc00000
  4125b4:	f503 1340 	add.w	r3, r3, #3145728	; 0x300000
  4125b8:	2200      	movs	r2, #0
  4125ba:	f002 fa99 	bl	414af0 <__aeabi_dmul>
  4125be:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4125c2:	4630      	mov	r0, r6
  4125c4:	4639      	mov	r1, r7
  4125c6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4125ca:	bf00      	nop
  4125cc:	0000      	movs	r0, r0
	...

004125d0 <_strtod_r>:
  4125d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4125d4:	b09f      	sub	sp, #124	; 0x7c
  4125d6:	460d      	mov	r5, r1
  4125d8:	9119      	str	r1, [sp, #100]	; 0x64
  4125da:	4683      	mov	fp, r0
  4125dc:	9205      	str	r2, [sp, #20]
  4125de:	2000      	movs	r0, #0
  4125e0:	460a      	mov	r2, r1
  4125e2:	2100      	movs	r1, #0
  4125e4:	e9cd 0102 	strd	r0, r1, [sp, #8]
  4125e8:	2300      	movs	r3, #0
  4125ea:	931a      	str	r3, [sp, #104]	; 0x68
  4125ec:	4616      	mov	r6, r2
  4125ee:	f812 4b01 	ldrb.w	r4, [r2], #1
  4125f2:	2c2d      	cmp	r4, #45	; 0x2d
  4125f4:	f200 8158 	bhi.w	4128a8 <_strtod_r+0x2d8>
  4125f8:	e8df f014 	tbh	[pc, r4, lsl #1]
  4125fc:	01560039 	.word	0x01560039
  412600:	01560156 	.word	0x01560156
  412604:	01560156 	.word	0x01560156
  412608:	01560156 	.word	0x01560156
  41260c:	007d0156 	.word	0x007d0156
  412610:	007d007d 	.word	0x007d007d
  412614:	007d007d 	.word	0x007d007d
  412618:	01560156 	.word	0x01560156
  41261c:	01560156 	.word	0x01560156
  412620:	01560156 	.word	0x01560156
  412624:	01560156 	.word	0x01560156
  412628:	01560156 	.word	0x01560156
  41262c:	01560156 	.word	0x01560156
  412630:	01560156 	.word	0x01560156
  412634:	01560156 	.word	0x01560156
  412638:	01560156 	.word	0x01560156
  41263c:	0156007d 	.word	0x0156007d
  412640:	01560156 	.word	0x01560156
  412644:	01560156 	.word	0x01560156
  412648:	01560156 	.word	0x01560156
  41264c:	01560156 	.word	0x01560156
  412650:	004d0156 	.word	0x004d0156
  412654:	007f0156 	.word	0x007f0156
  412658:	2300      	movs	r3, #0
  41265a:	2101      	movs	r1, #1
  41265c:	469a      	mov	sl, r3
  41265e:	910b      	str	r1, [sp, #44]	; 0x2c
  412660:	2800      	cmp	r0, #0
  412662:	f040 8151 	bne.w	412908 <_strtod_r+0x338>
  412666:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  412668:	2a00      	cmp	r2, #0
  41266a:	f040 814d 	bne.w	412908 <_strtod_r+0x338>
  41266e:	2000      	movs	r0, #0
  412670:	f04f 0800 	mov.w	r8, #0
  412674:	f04f 0900 	mov.w	r9, #0
  412678:	9519      	str	r5, [sp, #100]	; 0x64
  41267a:	9007      	str	r0, [sp, #28]
  41267c:	9805      	ldr	r0, [sp, #20]
  41267e:	b108      	cbz	r0, 412684 <_strtod_r+0xb4>
  412680:	9b19      	ldr	r3, [sp, #100]	; 0x64
  412682:	6003      	str	r3, [r0, #0]
  412684:	9907      	ldr	r1, [sp, #28]
  412686:	2900      	cmp	r1, #0
  412688:	f040 809e 	bne.w	4127c8 <_strtod_r+0x1f8>
  41268c:	4640      	mov	r0, r8
  41268e:	4649      	mov	r1, r9
  412690:	b01f      	add	sp, #124	; 0x7c
  412692:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  412696:	2300      	movs	r3, #0
  412698:	9307      	str	r3, [sp, #28]
  41269a:	1c73      	adds	r3, r6, #1
  41269c:	9319      	str	r3, [sp, #100]	; 0x64
  41269e:	7874      	ldrb	r4, [r6, #1]
  4126a0:	2c00      	cmp	r4, #0
  4126a2:	d0e4      	beq.n	41266e <_strtod_r+0x9e>
  4126a4:	2c30      	cmp	r4, #48	; 0x30
  4126a6:	461e      	mov	r6, r3
  4126a8:	f000 8103 	beq.w	4128b2 <_strtod_r+0x2e2>
  4126ac:	2300      	movs	r3, #0
  4126ae:	9606      	str	r6, [sp, #24]
  4126b0:	930a      	str	r3, [sp, #40]	; 0x28
  4126b2:	f1a4 0330 	sub.w	r3, r4, #48	; 0x30
  4126b6:	2700      	movs	r7, #0
  4126b8:	2b09      	cmp	r3, #9
  4126ba:	46b9      	mov	r9, r7
  4126bc:	463e      	mov	r6, r7
  4126be:	d81f      	bhi.n	412700 <_strtod_r+0x130>
  4126c0:	9806      	ldr	r0, [sp, #24]
  4126c2:	1c43      	adds	r3, r0, #1
  4126c4:	e00f      	b.n	4126e6 <_strtod_r+0x116>
  4126c6:	eb09 0989 	add.w	r9, r9, r9, lsl #2
  4126ca:	eb04 0949 	add.w	r9, r4, r9, lsl #1
  4126ce:	f1a9 0930 	sub.w	r9, r9, #48	; 0x30
  4126d2:	9319      	str	r3, [sp, #100]	; 0x64
  4126d4:	4698      	mov	r8, r3
  4126d6:	f813 4b01 	ldrb.w	r4, [r3], #1
  4126da:	f1a4 0230 	sub.w	r2, r4, #48	; 0x30
  4126de:	2a09      	cmp	r2, #9
  4126e0:	f106 0601 	add.w	r6, r6, #1
  4126e4:	d80e      	bhi.n	412704 <_strtod_r+0x134>
  4126e6:	2e08      	cmp	r6, #8
  4126e8:	dded      	ble.n	4126c6 <_strtod_r+0xf6>
  4126ea:	eb07 0787 	add.w	r7, r7, r7, lsl #2
  4126ee:	eb04 0747 	add.w	r7, r4, r7, lsl #1
  4126f2:	3f30      	subs	r7, #48	; 0x30
  4126f4:	e7ed      	b.n	4126d2 <_strtod_r+0x102>
  4126f6:	9219      	str	r2, [sp, #100]	; 0x64
  4126f8:	e778      	b.n	4125ec <_strtod_r+0x1c>
  4126fa:	2201      	movs	r2, #1
  4126fc:	9207      	str	r2, [sp, #28]
  4126fe:	e7cc      	b.n	41269a <_strtod_r+0xca>
  412700:	f8dd 8018 	ldr.w	r8, [sp, #24]
  412704:	4658      	mov	r0, fp
  412706:	f7fe ff83 	bl	411610 <_localeconv_r>
  41270a:	f8d0 a000 	ldr.w	sl, [r0]
  41270e:	4658      	mov	r0, fp
  412710:	f7fe ff7e 	bl	411610 <_localeconv_r>
  412714:	6800      	ldr	r0, [r0, #0]
  412716:	f7fa f945 	bl	40c9a4 <strlen>
  41271a:	4651      	mov	r1, sl
  41271c:	4602      	mov	r2, r0
  41271e:	4640      	mov	r0, r8
  412720:	f7fa f9a2 	bl	40ca68 <strncmp>
  412724:	4680      	mov	r8, r0
  412726:	2800      	cmp	r0, #0
  412728:	f000 8146 	beq.w	4129b8 <_strtod_r+0x3e8>
  41272c:	2000      	movs	r0, #0
  41272e:	4603      	mov	r3, r0
  412730:	900b      	str	r0, [sp, #44]	; 0x2c
  412732:	46b2      	mov	sl, r6
  412734:	f024 0220 	bic.w	r2, r4, #32
  412738:	2a45      	cmp	r2, #69	; 0x45
  41273a:	f000 80e1 	beq.w	412900 <_strtod_r+0x330>
  41273e:	2100      	movs	r1, #0
  412740:	f1ba 0f00 	cmp.w	sl, #0
  412744:	d054      	beq.n	4127f0 <_strtod_r+0x220>
  412746:	1acb      	subs	r3, r1, r3
  412748:	4648      	mov	r0, r9
  41274a:	9308      	str	r3, [sp, #32]
  41274c:	f002 f95a 	bl	414a04 <__aeabi_ui2d>
  412750:	f1ba 0f10 	cmp.w	sl, #16
  412754:	bfb4      	ite	lt
  412756:	46d0      	movlt	r8, sl
  412758:	f04f 0810 	movge.w	r8, #16
  41275c:	2e00      	cmp	r6, #0
  41275e:	bf08      	it	eq
  412760:	4656      	moveq	r6, sl
  412762:	f1b8 0f09 	cmp.w	r8, #9
  412766:	e9cd 0102 	strd	r0, r1, [sp, #8]
  41276a:	dd13      	ble.n	412794 <_strtod_r+0x1c4>
  41276c:	4ba0      	ldr	r3, [pc, #640]	; (4129f0 <_strtod_r+0x420>)
  41276e:	eb03 03c8 	add.w	r3, r3, r8, lsl #3
  412772:	e953 2312 	ldrd	r2, r3, [r3, #-72]	; 0x48
  412776:	f002 f9bb 	bl	414af0 <__aeabi_dmul>
  41277a:	4604      	mov	r4, r0
  41277c:	4638      	mov	r0, r7
  41277e:	460d      	mov	r5, r1
  412780:	f002 f940 	bl	414a04 <__aeabi_ui2d>
  412784:	4602      	mov	r2, r0
  412786:	460b      	mov	r3, r1
  412788:	4620      	mov	r0, r4
  41278a:	4629      	mov	r1, r5
  41278c:	f001 fffe 	bl	41478c <__adddf3>
  412790:	e9cd 0102 	strd	r0, r1, [sp, #8]
  412794:	f1ba 0f0f 	cmp.w	sl, #15
  412798:	f300 812c 	bgt.w	4129f4 <_strtod_r+0x424>
  41279c:	9908      	ldr	r1, [sp, #32]
  41279e:	2900      	cmp	r1, #0
  4127a0:	f000 80ab 	beq.w	4128fa <_strtod_r+0x32a>
  4127a4:	f340 8580 	ble.w	4132a8 <_strtod_r+0xcd8>
  4127a8:	9a08      	ldr	r2, [sp, #32]
  4127aa:	2a16      	cmp	r2, #22
  4127ac:	f300 84ef 	bgt.w	41318e <_strtod_r+0xbbe>
  4127b0:	4b8f      	ldr	r3, [pc, #572]	; (4129f0 <_strtod_r+0x420>)
  4127b2:	eb03 0ac2 	add.w	sl, r3, r2, lsl #3
  4127b6:	e9da 0100 	ldrd	r0, r1, [sl]
  4127ba:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  4127be:	f002 f997 	bl	414af0 <__aeabi_dmul>
  4127c2:	4680      	mov	r8, r0
  4127c4:	4689      	mov	r9, r1
  4127c6:	e759      	b.n	41267c <_strtod_r+0xac>
  4127c8:	4640      	mov	r0, r8
  4127ca:	f109 4100 	add.w	r1, r9, #2147483648	; 0x80000000
  4127ce:	b01f      	add	sp, #124	; 0x7c
  4127d0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4127d4:	4633      	mov	r3, r6
  4127d6:	f1a4 0231 	sub.w	r2, r4, #49	; 0x31
  4127da:	2a08      	cmp	r2, #8
  4127dc:	f240 833c 	bls.w	412e58 <_strtod_r+0x888>
  4127e0:	f024 0220 	bic.w	r2, r4, #32
  4127e4:	2a45      	cmp	r2, #69	; 0x45
  4127e6:	4618      	mov	r0, r3
  4127e8:	f43f af36 	beq.w	412658 <_strtod_r+0x88>
  4127ec:	2101      	movs	r1, #1
  4127ee:	910b      	str	r1, [sp, #44]	; 0x2c
  4127f0:	2800      	cmp	r0, #0
  4127f2:	d171      	bne.n	4128d8 <_strtod_r+0x308>
  4127f4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  4127f6:	2b00      	cmp	r3, #0
  4127f8:	d16e      	bne.n	4128d8 <_strtod_r+0x308>
  4127fa:	980b      	ldr	r0, [sp, #44]	; 0x2c
  4127fc:	2800      	cmp	r0, #0
  4127fe:	f47f af36 	bne.w	41266e <_strtod_r+0x9e>
  412802:	3c49      	subs	r4, #73	; 0x49
  412804:	2c25      	cmp	r4, #37	; 0x25
  412806:	f63f af32 	bhi.w	41266e <_strtod_r+0x9e>
  41280a:	a101      	add	r1, pc, #4	; (adr r1, 412810 <_strtod_r+0x240>)
  41280c:	f851 f024 	ldr.w	pc, [r1, r4, lsl #2]
  412810:	00412ed3 	.word	0x00412ed3
  412814:	0041266f 	.word	0x0041266f
  412818:	0041266f 	.word	0x0041266f
  41281c:	0041266f 	.word	0x0041266f
  412820:	0041266f 	.word	0x0041266f
  412824:	00412e9b 	.word	0x00412e9b
  412828:	0041266f 	.word	0x0041266f
  41282c:	0041266f 	.word	0x0041266f
  412830:	0041266f 	.word	0x0041266f
  412834:	0041266f 	.word	0x0041266f
  412838:	0041266f 	.word	0x0041266f
  41283c:	0041266f 	.word	0x0041266f
  412840:	0041266f 	.word	0x0041266f
  412844:	0041266f 	.word	0x0041266f
  412848:	0041266f 	.word	0x0041266f
  41284c:	0041266f 	.word	0x0041266f
  412850:	0041266f 	.word	0x0041266f
  412854:	0041266f 	.word	0x0041266f
  412858:	0041266f 	.word	0x0041266f
  41285c:	0041266f 	.word	0x0041266f
  412860:	0041266f 	.word	0x0041266f
  412864:	0041266f 	.word	0x0041266f
  412868:	0041266f 	.word	0x0041266f
  41286c:	0041266f 	.word	0x0041266f
  412870:	0041266f 	.word	0x0041266f
  412874:	0041266f 	.word	0x0041266f
  412878:	0041266f 	.word	0x0041266f
  41287c:	0041266f 	.word	0x0041266f
  412880:	0041266f 	.word	0x0041266f
  412884:	0041266f 	.word	0x0041266f
  412888:	0041266f 	.word	0x0041266f
  41288c:	0041266f 	.word	0x0041266f
  412890:	00412ed3 	.word	0x00412ed3
  412894:	0041266f 	.word	0x0041266f
  412898:	0041266f 	.word	0x0041266f
  41289c:	0041266f 	.word	0x0041266f
  4128a0:	0041266f 	.word	0x0041266f
  4128a4:	00412e9b 	.word	0x00412e9b
  4128a8:	2000      	movs	r0, #0
  4128aa:	2c30      	cmp	r4, #48	; 0x30
  4128ac:	9007      	str	r0, [sp, #28]
  4128ae:	f47f aefd 	bne.w	4126ac <_strtod_r+0xdc>
  4128b2:	7873      	ldrb	r3, [r6, #1]
  4128b4:	2b58      	cmp	r3, #88	; 0x58
  4128b6:	f000 8336 	beq.w	412f26 <_strtod_r+0x956>
  4128ba:	2b78      	cmp	r3, #120	; 0x78
  4128bc:	f000 8333 	beq.w	412f26 <_strtod_r+0x956>
  4128c0:	3601      	adds	r6, #1
  4128c2:	9619      	str	r6, [sp, #100]	; 0x64
  4128c4:	4633      	mov	r3, r6
  4128c6:	f816 4b01 	ldrb.w	r4, [r6], #1
  4128ca:	2c30      	cmp	r4, #48	; 0x30
  4128cc:	d0f9      	beq.n	4128c2 <_strtod_r+0x2f2>
  4128ce:	b11c      	cbz	r4, 4128d8 <_strtod_r+0x308>
  4128d0:	9306      	str	r3, [sp, #24]
  4128d2:	2301      	movs	r3, #1
  4128d4:	930a      	str	r3, [sp, #40]	; 0x28
  4128d6:	e6ec      	b.n	4126b2 <_strtod_r+0xe2>
  4128d8:	f04f 0800 	mov.w	r8, #0
  4128dc:	f04f 0900 	mov.w	r9, #0
  4128e0:	e6cc      	b.n	41267c <_strtod_r+0xac>
  4128e2:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
  4128e6:	f04f 30ff 	mov.w	r0, #4294967295
  4128ea:	9303      	str	r3, [sp, #12]
  4128ec:	9002      	str	r0, [sp, #8]
  4128ee:	0722      	lsls	r2, r4, #28
  4128f0:	bf42      	ittt	mi
  4128f2:	9903      	ldrmi	r1, [sp, #12]
  4128f4:	f041 4100 	orrmi.w	r1, r1, #2147483648	; 0x80000000
  4128f8:	9103      	strmi	r1, [sp, #12]
  4128fa:	e9dd 8902 	ldrd	r8, r9, [sp, #8]
  4128fe:	e6bd      	b.n	41267c <_strtod_r+0xac>
  412900:	f1ba 0f00 	cmp.w	sl, #0
  412904:	f43f aeac 	beq.w	412660 <_strtod_r+0x90>
  412908:	9d19      	ldr	r5, [sp, #100]	; 0x64
  41290a:	1c6a      	adds	r2, r5, #1
  41290c:	9219      	str	r2, [sp, #100]	; 0x64
  41290e:	786c      	ldrb	r4, [r5, #1]
  412910:	2c2b      	cmp	r4, #43	; 0x2b
  412912:	f000 824b 	beq.w	412dac <_strtod_r+0x7dc>
  412916:	2c2d      	cmp	r4, #45	; 0x2d
  412918:	f040 8245 	bne.w	412da6 <_strtod_r+0x7d6>
  41291c:	2101      	movs	r1, #1
  41291e:	9108      	str	r1, [sp, #32]
  412920:	1caa      	adds	r2, r5, #2
  412922:	9219      	str	r2, [sp, #100]	; 0x64
  412924:	78ac      	ldrb	r4, [r5, #2]
  412926:	f1a4 0230 	sub.w	r2, r4, #48	; 0x30
  41292a:	2a09      	cmp	r2, #9
  41292c:	f200 81e5 	bhi.w	412cfa <_strtod_r+0x72a>
  412930:	2c30      	cmp	r4, #48	; 0x30
  412932:	d106      	bne.n	412942 <_strtod_r+0x372>
  412934:	9a19      	ldr	r2, [sp, #100]	; 0x64
  412936:	3201      	adds	r2, #1
  412938:	9219      	str	r2, [sp, #100]	; 0x64
  41293a:	f812 4b01 	ldrb.w	r4, [r2], #1
  41293e:	2c30      	cmp	r4, #48	; 0x30
  412940:	d0fa      	beq.n	412938 <_strtod_r+0x368>
  412942:	f1a4 0231 	sub.w	r2, r4, #49	; 0x31
  412946:	2a08      	cmp	r2, #8
  412948:	f63f aef9 	bhi.w	41273e <_strtod_r+0x16e>
  41294c:	9a19      	ldr	r2, [sp, #100]	; 0x64
  41294e:	920e      	str	r2, [sp, #56]	; 0x38
  412950:	f102 0801 	add.w	r8, r2, #1
  412954:	f8cd 8064 	str.w	r8, [sp, #100]	; 0x64
  412958:	f1a4 0130 	sub.w	r1, r4, #48	; 0x30
  41295c:	7854      	ldrb	r4, [r2, #1]
  41295e:	f1a4 0230 	sub.w	r2, r4, #48	; 0x30
  412962:	2a09      	cmp	r2, #9
  412964:	d812      	bhi.n	41298c <_strtod_r+0x3bc>
  412966:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  412968:	f102 0c02 	add.w	ip, r2, #2
  41296c:	4662      	mov	r2, ip
  41296e:	eb01 0181 	add.w	r1, r1, r1, lsl #2
  412972:	9219      	str	r2, [sp, #100]	; 0x64
  412974:	eb04 0141 	add.w	r1, r4, r1, lsl #1
  412978:	4690      	mov	r8, r2
  41297a:	f812 4b01 	ldrb.w	r4, [r2], #1
  41297e:	f1a4 0c30 	sub.w	ip, r4, #48	; 0x30
  412982:	f1bc 0f09 	cmp.w	ip, #9
  412986:	f1a1 0130 	sub.w	r1, r1, #48	; 0x30
  41298a:	d9f0      	bls.n	41296e <_strtod_r+0x39e>
  41298c:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  41298e:	ebc2 0808 	rsb	r8, r2, r8
  412992:	f1b8 0f08 	cmp.w	r8, #8
  412996:	f300 83f2 	bgt.w	41317e <_strtod_r+0xbae>
  41299a:	f644 621f 	movw	r2, #19999	; 0x4e1f
  41299e:	4291      	cmp	r1, r2
  4129a0:	bfa8      	it	ge
  4129a2:	4611      	movge	r1, r2
  4129a4:	9a08      	ldr	r2, [sp, #32]
  4129a6:	2a00      	cmp	r2, #0
  4129a8:	f43f aeca 	beq.w	412740 <_strtod_r+0x170>
  4129ac:	4249      	negs	r1, r1
  4129ae:	f1ba 0f00 	cmp.w	sl, #0
  4129b2:	f47f aec8 	bne.w	412746 <_strtod_r+0x176>
  4129b6:	e71b      	b.n	4127f0 <_strtod_r+0x220>
  4129b8:	4658      	mov	r0, fp
  4129ba:	9c19      	ldr	r4, [sp, #100]	; 0x64
  4129bc:	f7fe fe28 	bl	411610 <_localeconv_r>
  4129c0:	6800      	ldr	r0, [r0, #0]
  4129c2:	f7f9 ffef 	bl	40c9a4 <strlen>
  4129c6:	1823      	adds	r3, r4, r0
  4129c8:	9319      	str	r3, [sp, #100]	; 0x64
  4129ca:	5c24      	ldrb	r4, [r4, r0]
  4129cc:	2e00      	cmp	r6, #0
  4129ce:	f040 81c3 	bne.w	412d58 <_strtod_r+0x788>
  4129d2:	2c30      	cmp	r4, #48	; 0x30
  4129d4:	f47f aefe 	bne.w	4127d4 <_strtod_r+0x204>
  4129d8:	461a      	mov	r2, r3
  4129da:	4633      	mov	r3, r6
  4129dc:	e000      	b.n	4129e0 <_strtod_r+0x410>
  4129de:	460a      	mov	r2, r1
  4129e0:	1c51      	adds	r1, r2, #1
  4129e2:	9119      	str	r1, [sp, #100]	; 0x64
  4129e4:	7854      	ldrb	r4, [r2, #1]
  4129e6:	2c30      	cmp	r4, #48	; 0x30
  4129e8:	f103 0301 	add.w	r3, r3, #1
  4129ec:	d0f7      	beq.n	4129de <_strtod_r+0x40e>
  4129ee:	e6f2      	b.n	4127d6 <_strtod_r+0x206>
  4129f0:	00417010 	.word	0x00417010
  4129f4:	9908      	ldr	r1, [sp, #32]
  4129f6:	ebc8 080a 	rsb	r8, r8, sl
  4129fa:	4488      	add	r8, r1
  4129fc:	f1b8 0f00 	cmp.w	r8, #0
  412a00:	f340 8369 	ble.w	4130d6 <_strtod_r+0xb06>
  412a04:	f018 030f 	ands.w	r3, r8, #15
  412a08:	d00a      	beq.n	412a20 <_strtod_r+0x450>
  412a0a:	49a7      	ldr	r1, [pc, #668]	; (412ca8 <_strtod_r+0x6d8>)
  412a0c:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
  412a10:	e9d1 0100 	ldrd	r0, r1, [r1]
  412a14:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  412a18:	f002 f86a 	bl	414af0 <__aeabi_dmul>
  412a1c:	e9cd 0102 	strd	r0, r1, [sp, #8]
  412a20:	f038 040f 	bics.w	r4, r8, #15
  412a24:	f040 81c8 	bne.w	412db8 <_strtod_r+0x7e8>
  412a28:	2200      	movs	r2, #0
  412a2a:	920a      	str	r2, [sp, #40]	; 0x28
  412a2c:	f8cd 9000 	str.w	r9, [sp]
  412a30:	9906      	ldr	r1, [sp, #24]
  412a32:	4632      	mov	r2, r6
  412a34:	4653      	mov	r3, sl
  412a36:	4658      	mov	r0, fp
  412a38:	f7fe ff7a 	bl	411930 <__s2b>
  412a3c:	900b      	str	r0, [sp, #44]	; 0x2c
  412a3e:	2800      	cmp	r0, #0
  412a40:	f000 82d5 	beq.w	412fee <_strtod_r+0xa1e>
  412a44:	9908      	ldr	r1, [sp, #32]
  412a46:	2200      	movs	r2, #0
  412a48:	2900      	cmp	r1, #0
  412a4a:	f1c1 0300 	rsb	r3, r1, #0
  412a4e:	bfa8      	it	ge
  412a50:	4613      	movge	r3, r2
  412a52:	930e      	str	r3, [sp, #56]	; 0x38
  412a54:	ea21 73e1 	bic.w	r3, r1, r1, asr #31
  412a58:	9206      	str	r2, [sp, #24]
  412a5a:	930f      	str	r3, [sp, #60]	; 0x3c
  412a5c:	4617      	mov	r7, r2
  412a5e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
  412a60:	4658      	mov	r0, fp
  412a62:	6851      	ldr	r1, [r2, #4]
  412a64:	f7fe fee8 	bl	411838 <_Balloc>
  412a68:	4606      	mov	r6, r0
  412a6a:	2800      	cmp	r0, #0
  412a6c:	f000 82cd 	beq.w	41300a <_strtod_r+0xa3a>
  412a70:	980b      	ldr	r0, [sp, #44]	; 0x2c
  412a72:	6903      	ldr	r3, [r0, #16]
  412a74:	1c9a      	adds	r2, r3, #2
  412a76:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  412a78:	0092      	lsls	r2, r2, #2
  412a7a:	f103 010c 	add.w	r1, r3, #12
  412a7e:	f106 000c 	add.w	r0, r6, #12
  412a82:	f7f9 fb51 	bl	40c128 <memcpy>
  412a86:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
  412a8a:	e9cd 0108 	strd	r0, r1, [sp, #32]
  412a8e:	a81b      	add	r0, sp, #108	; 0x6c
  412a90:	a91c      	add	r1, sp, #112	; 0x70
  412a92:	e88d 0003 	stmia.w	sp, {r0, r1}
  412a96:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
  412a9a:	4658      	mov	r0, fp
  412a9c:	f7ff fa3e 	bl	411f1c <__d2b>
  412aa0:	901a      	str	r0, [sp, #104]	; 0x68
  412aa2:	2800      	cmp	r0, #0
  412aa4:	f000 8412 	beq.w	4132cc <_strtod_r+0xcfc>
  412aa8:	4658      	mov	r0, fp
  412aaa:	2101      	movs	r1, #1
  412aac:	f7fe ffda 	bl	411a64 <__i2b>
  412ab0:	4607      	mov	r7, r0
  412ab2:	2800      	cmp	r0, #0
  412ab4:	f000 82a9 	beq.w	41300a <_strtod_r+0xa3a>
  412ab8:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
  412aba:	2b00      	cmp	r3, #0
  412abc:	f2c0 8110 	blt.w	412ce0 <_strtod_r+0x710>
  412ac0:	f8dd 9038 	ldr.w	r9, [sp, #56]	; 0x38
  412ac4:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
  412ac6:	4499      	add	r9, r3
  412ac8:	980a      	ldr	r0, [sp, #40]	; 0x28
  412aca:	9a1c      	ldr	r2, [sp, #112]	; 0x70
  412acc:	1a1b      	subs	r3, r3, r0
  412ace:	4413      	add	r3, r2
  412ad0:	f46f 717f 	mvn.w	r1, #1020	; 0x3fc
  412ad4:	428b      	cmp	r3, r1
  412ad6:	f1c2 0a36 	rsb	sl, r2, #54	; 0x36
  412ada:	f280 80da 	bge.w	412c92 <_strtod_r+0x6c2>
  412ade:	1aca      	subs	r2, r1, r3
  412ae0:	2a1f      	cmp	r2, #31
  412ae2:	ebc2 0a0a 	rsb	sl, r2, sl
  412ae6:	f300 8100 	bgt.w	412cea <_strtod_r+0x71a>
  412aea:	f04f 0801 	mov.w	r8, #1
  412aee:	2300      	movs	r3, #0
  412af0:	fa08 f802 	lsl.w	r8, r8, r2
  412af4:	930c      	str	r3, [sp, #48]	; 0x30
  412af6:	980a      	ldr	r0, [sp, #40]	; 0x28
  412af8:	4455      	add	r5, sl
  412afa:	44ca      	add	sl, r9
  412afc:	45ca      	cmp	sl, r9
  412afe:	bfb4      	ite	lt
  412b00:	4653      	movlt	r3, sl
  412b02:	464b      	movge	r3, r9
  412b04:	4405      	add	r5, r0
  412b06:	42ab      	cmp	r3, r5
  412b08:	bfa8      	it	ge
  412b0a:	462b      	movge	r3, r5
  412b0c:	2b00      	cmp	r3, #0
  412b0e:	dd04      	ble.n	412b1a <_strtod_r+0x54a>
  412b10:	ebc3 0a0a 	rsb	sl, r3, sl
  412b14:	1aed      	subs	r5, r5, r3
  412b16:	ebc3 0909 	rsb	r9, r3, r9
  412b1a:	990e      	ldr	r1, [sp, #56]	; 0x38
  412b1c:	b1b1      	cbz	r1, 412b4c <_strtod_r+0x57c>
  412b1e:	4639      	mov	r1, r7
  412b20:	4658      	mov	r0, fp
  412b22:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  412b24:	f7ff f846 	bl	411bb4 <__pow5mult>
  412b28:	4607      	mov	r7, r0
  412b2a:	2800      	cmp	r0, #0
  412b2c:	f000 826d 	beq.w	41300a <_strtod_r+0xa3a>
  412b30:	4658      	mov	r0, fp
  412b32:	4639      	mov	r1, r7
  412b34:	9a1a      	ldr	r2, [sp, #104]	; 0x68
  412b36:	f7fe ff9f 	bl	411a78 <__multiply>
  412b3a:	4604      	mov	r4, r0
  412b3c:	2800      	cmp	r0, #0
  412b3e:	f000 8264 	beq.w	41300a <_strtod_r+0xa3a>
  412b42:	4658      	mov	r0, fp
  412b44:	991a      	ldr	r1, [sp, #104]	; 0x68
  412b46:	f7fe fe9d 	bl	411884 <_Bfree>
  412b4a:	941a      	str	r4, [sp, #104]	; 0x68
  412b4c:	f1ba 0f00 	cmp.w	sl, #0
  412b50:	dd08      	ble.n	412b64 <_strtod_r+0x594>
  412b52:	4652      	mov	r2, sl
  412b54:	4658      	mov	r0, fp
  412b56:	991a      	ldr	r1, [sp, #104]	; 0x68
  412b58:	f7ff f87a 	bl	411c50 <__lshift>
  412b5c:	901a      	str	r0, [sp, #104]	; 0x68
  412b5e:	2800      	cmp	r0, #0
  412b60:	f000 83b4 	beq.w	4132cc <_strtod_r+0xcfc>
  412b64:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  412b66:	b142      	cbz	r2, 412b7a <_strtod_r+0x5aa>
  412b68:	4631      	mov	r1, r6
  412b6a:	4658      	mov	r0, fp
  412b6c:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  412b6e:	f7ff f821 	bl	411bb4 <__pow5mult>
  412b72:	4606      	mov	r6, r0
  412b74:	2800      	cmp	r0, #0
  412b76:	f000 8248 	beq.w	41300a <_strtod_r+0xa3a>
  412b7a:	2d00      	cmp	r5, #0
  412b7c:	dd08      	ble.n	412b90 <_strtod_r+0x5c0>
  412b7e:	4631      	mov	r1, r6
  412b80:	462a      	mov	r2, r5
  412b82:	4658      	mov	r0, fp
  412b84:	f7ff f864 	bl	411c50 <__lshift>
  412b88:	4606      	mov	r6, r0
  412b8a:	2800      	cmp	r0, #0
  412b8c:	f000 823d 	beq.w	41300a <_strtod_r+0xa3a>
  412b90:	f1b9 0f00 	cmp.w	r9, #0
  412b94:	dd08      	ble.n	412ba8 <_strtod_r+0x5d8>
  412b96:	4639      	mov	r1, r7
  412b98:	464a      	mov	r2, r9
  412b9a:	4658      	mov	r0, fp
  412b9c:	f7ff f858 	bl	411c50 <__lshift>
  412ba0:	4607      	mov	r7, r0
  412ba2:	2800      	cmp	r0, #0
  412ba4:	f000 8231 	beq.w	41300a <_strtod_r+0xa3a>
  412ba8:	4658      	mov	r0, fp
  412baa:	991a      	ldr	r1, [sp, #104]	; 0x68
  412bac:	4632      	mov	r2, r6
  412bae:	f7ff f8d1 	bl	411d54 <__mdiff>
  412bb2:	9006      	str	r0, [sp, #24]
  412bb4:	2800      	cmp	r0, #0
  412bb6:	f000 8228 	beq.w	41300a <_strtod_r+0xa3a>
  412bba:	9906      	ldr	r1, [sp, #24]
  412bbc:	2300      	movs	r3, #0
  412bbe:	f8d1 a00c 	ldr.w	sl, [r1, #12]
  412bc2:	60cb      	str	r3, [r1, #12]
  412bc4:	4639      	mov	r1, r7
  412bc6:	f7ff f8a1 	bl	411d0c <__mcmp>
  412bca:	2800      	cmp	r0, #0
  412bcc:	f2c0 83cb 	blt.w	413366 <_strtod_r+0xd96>
  412bd0:	f000 8388 	beq.w	4132e4 <_strtod_r+0xd14>
  412bd4:	9806      	ldr	r0, [sp, #24]
  412bd6:	4639      	mov	r1, r7
  412bd8:	f7ff f9fe 	bl	411fd8 <__ratio>
  412bdc:	2200      	movs	r2, #0
  412bde:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  412be2:	4604      	mov	r4, r0
  412be4:	460d      	mov	r5, r1
  412be6:	f002 f9ff 	bl	414fe8 <__aeabi_dcmple>
  412bea:	2800      	cmp	r0, #0
  412bec:	d064      	beq.n	412cb8 <_strtod_r+0x6e8>
  412bee:	f1ba 0f00 	cmp.w	sl, #0
  412bf2:	f000 808e 	beq.w	412d12 <_strtod_r+0x742>
  412bf6:	4d2d      	ldr	r5, [pc, #180]	; (412cac <_strtod_r+0x6dc>)
  412bf8:	f8dd 900c 	ldr.w	r9, [sp, #12]
  412bfc:	2400      	movs	r4, #0
  412bfe:	4622      	mov	r2, r4
  412c00:	462b      	mov	r3, r5
  412c02:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
  412c06:	f8df 80ac 	ldr.w	r8, [pc, #172]	; 412cb4 <_strtod_r+0x6e4>
  412c0a:	4b29      	ldr	r3, [pc, #164]	; (412cb0 <_strtod_r+0x6e0>)
  412c0c:	ea09 0808 	and.w	r8, r9, r8
  412c10:	4598      	cmp	r8, r3
  412c12:	f000 81bf 	beq.w	412f94 <_strtod_r+0x9c4>
  412c16:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  412c18:	b182      	cbz	r2, 412c3c <_strtod_r+0x66c>
  412c1a:	f1b8 6fd4 	cmp.w	r8, #111149056	; 0x6a00000
  412c1e:	d80d      	bhi.n	412c3c <_strtod_r+0x66c>
  412c20:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
  412c24:	a31e      	add	r3, pc, #120	; (adr r3, 412ca0 <_strtod_r+0x6d0>)
  412c26:	e9d3 2300 	ldrd	r2, r3, [r3]
  412c2a:	f002 f9dd 	bl	414fe8 <__aeabi_dcmple>
  412c2e:	2800      	cmp	r0, #0
  412c30:	f040 811b 	bne.w	412e6a <_strtod_r+0x89a>
  412c34:	f105 63d6 	add.w	r3, r5, #112197632	; 0x6b00000
  412c38:	ebc8 0503 	rsb	r5, r8, r3
  412c3c:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
  412c40:	f7ff f8f2 	bl	411e28 <__ulp>
  412c44:	4602      	mov	r2, r0
  412c46:	460b      	mov	r3, r1
  412c48:	4620      	mov	r0, r4
  412c4a:	4629      	mov	r1, r5
  412c4c:	f001 ff50 	bl	414af0 <__aeabi_dmul>
  412c50:	4602      	mov	r2, r0
  412c52:	460b      	mov	r3, r1
  412c54:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
  412c58:	f001 fd98 	bl	41478c <__adddf3>
  412c5c:	e9cd 0102 	strd	r0, r1, [sp, #8]
  412c60:	9c03      	ldr	r4, [sp, #12]
  412c62:	990a      	ldr	r1, [sp, #40]	; 0x28
  412c64:	b921      	cbnz	r1, 412c70 <_strtod_r+0x6a0>
  412c66:	4b13      	ldr	r3, [pc, #76]	; (412cb4 <_strtod_r+0x6e4>)
  412c68:	4023      	ands	r3, r4
  412c6a:	4598      	cmp	r8, r3
  412c6c:	f000 81ed 	beq.w	41304a <_strtod_r+0xa7a>
  412c70:	4658      	mov	r0, fp
  412c72:	991a      	ldr	r1, [sp, #104]	; 0x68
  412c74:	f7fe fe06 	bl	411884 <_Bfree>
  412c78:	4658      	mov	r0, fp
  412c7a:	4631      	mov	r1, r6
  412c7c:	f7fe fe02 	bl	411884 <_Bfree>
  412c80:	4658      	mov	r0, fp
  412c82:	4639      	mov	r1, r7
  412c84:	f7fe fdfe 	bl	411884 <_Bfree>
  412c88:	4658      	mov	r0, fp
  412c8a:	9906      	ldr	r1, [sp, #24]
  412c8c:	f7fe fdfa 	bl	411884 <_Bfree>
  412c90:	e6e5      	b.n	412a5e <_strtod_r+0x48e>
  412c92:	2300      	movs	r3, #0
  412c94:	930c      	str	r3, [sp, #48]	; 0x30
  412c96:	f04f 0801 	mov.w	r8, #1
  412c9a:	e72c      	b.n	412af6 <_strtod_r+0x526>
  412c9c:	f3af 8000 	nop.w
  412ca0:	ffc00000 	.word	0xffc00000
  412ca4:	41dfffff 	.word	0x41dfffff
  412ca8:	00417010 	.word	0x00417010
  412cac:	3ff00000 	.word	0x3ff00000
  412cb0:	7fe00000 	.word	0x7fe00000
  412cb4:	7ff00000 	.word	0x7ff00000
  412cb8:	4620      	mov	r0, r4
  412cba:	4629      	mov	r1, r5
  412cbc:	2200      	movs	r2, #0
  412cbe:	4ba8      	ldr	r3, [pc, #672]	; (412f60 <_strtod_r+0x990>)
  412cc0:	f001 ff16 	bl	414af0 <__aeabi_dmul>
  412cc4:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
  412cc8:	f1ba 0f00 	cmp.w	sl, #0
  412ccc:	d11c      	bne.n	412d08 <_strtod_r+0x738>
  412cce:	f101 4100 	add.w	r1, r1, #2147483648	; 0x80000000
  412cd2:	9010      	str	r0, [sp, #64]	; 0x40
  412cd4:	9111      	str	r1, [sp, #68]	; 0x44
  412cd6:	e9dd 4510 	ldrd	r4, r5, [sp, #64]	; 0x40
  412cda:	f8dd 900c 	ldr.w	r9, [sp, #12]
  412cde:	e792      	b.n	412c06 <_strtod_r+0x636>
  412ce0:	990f      	ldr	r1, [sp, #60]	; 0x3c
  412ce2:	f8dd 9038 	ldr.w	r9, [sp, #56]	; 0x38
  412ce6:	1acd      	subs	r5, r1, r3
  412ce8:	e6ee      	b.n	412ac8 <_strtod_r+0x4f8>
  412cea:	4c9e      	ldr	r4, [pc, #632]	; (412f64 <_strtod_r+0x994>)
  412cec:	f04f 0801 	mov.w	r8, #1
  412cf0:	1ae4      	subs	r4, r4, r3
  412cf2:	fa08 f404 	lsl.w	r4, r8, r4
  412cf6:	940c      	str	r4, [sp, #48]	; 0x30
  412cf8:	e6fd      	b.n	412af6 <_strtod_r+0x526>
  412cfa:	9519      	str	r5, [sp, #100]	; 0x64
  412cfc:	2100      	movs	r1, #0
  412cfe:	f1ba 0f00 	cmp.w	sl, #0
  412d02:	f47f ad20 	bne.w	412746 <_strtod_r+0x176>
  412d06:	e573      	b.n	4127f0 <_strtod_r+0x220>
  412d08:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
  412d0c:	e9cd 2310 	strd	r2, r3, [sp, #64]	; 0x40
  412d10:	e7e1      	b.n	412cd6 <_strtod_r+0x706>
  412d12:	9b02      	ldr	r3, [sp, #8]
  412d14:	2b00      	cmp	r3, #0
  412d16:	f040 8092 	bne.w	412e3e <_strtod_r+0x86e>
  412d1a:	9803      	ldr	r0, [sp, #12]
  412d1c:	f3c0 0313 	ubfx	r3, r0, #0, #20
  412d20:	4681      	mov	r9, r0
  412d22:	2b00      	cmp	r3, #0
  412d24:	f040 8091 	bne.w	412e4a <_strtod_r+0x87a>
  412d28:	4620      	mov	r0, r4
  412d2a:	4629      	mov	r1, r5
  412d2c:	2200      	movs	r2, #0
  412d2e:	4b8e      	ldr	r3, [pc, #568]	; (412f68 <_strtod_r+0x998>)
  412d30:	f002 f950 	bl	414fd4 <__aeabi_dcmplt>
  412d34:	2800      	cmp	r0, #0
  412d36:	f040 8356 	bne.w	4133e6 <_strtod_r+0xe16>
  412d3a:	4620      	mov	r0, r4
  412d3c:	4629      	mov	r1, r5
  412d3e:	2200      	movs	r2, #0
  412d40:	4b87      	ldr	r3, [pc, #540]	; (412f60 <_strtod_r+0x990>)
  412d42:	f001 fed5 	bl	414af0 <__aeabi_dmul>
  412d46:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
  412d4a:	f101 4100 	add.w	r1, r1, #2147483648	; 0x80000000
  412d4e:	9016      	str	r0, [sp, #88]	; 0x58
  412d50:	9117      	str	r1, [sp, #92]	; 0x5c
  412d52:	e9dd 4516 	ldrd	r4, r5, [sp, #88]	; 0x58
  412d56:	e756      	b.n	412c06 <_strtod_r+0x636>
  412d58:	4640      	mov	r0, r8
  412d5a:	4643      	mov	r3, r8
  412d5c:	46b2      	mov	sl, r6
  412d5e:	f1a4 0230 	sub.w	r2, r4, #48	; 0x30
  412d62:	2a09      	cmp	r2, #9
  412d64:	d825      	bhi.n	412db2 <_strtod_r+0x7e2>
  412d66:	9c19      	ldr	r4, [sp, #100]	; 0x64
  412d68:	3001      	adds	r0, #1
  412d6a:	2a00      	cmp	r2, #0
  412d6c:	f000 81af 	beq.w	4130ce <_strtod_r+0xafe>
  412d70:	2801      	cmp	r0, #1
  412d72:	4403      	add	r3, r0
  412d74:	f000 81a0 	beq.w	4130b8 <_strtod_r+0xae8>
  412d78:	4450      	add	r0, sl
  412d7a:	3801      	subs	r0, #1
  412d7c:	e006      	b.n	412d8c <_strtod_r+0x7bc>
  412d7e:	eb09 0989 	add.w	r9, r9, r9, lsl #2
  412d82:	ea4f 0949 	mov.w	r9, r9, lsl #1
  412d86:	4582      	cmp	sl, r0
  412d88:	f000 8197 	beq.w	4130ba <_strtod_r+0xaea>
  412d8c:	f10a 0a01 	add.w	sl, sl, #1
  412d90:	f10a 31ff 	add.w	r1, sl, #4294967295
  412d94:	2908      	cmp	r1, #8
  412d96:	ddf2      	ble.n	412d7e <_strtod_r+0x7ae>
  412d98:	f1ba 0f10 	cmp.w	sl, #16
  412d9c:	bfdc      	itt	le
  412d9e:	eb07 0787 	addle.w	r7, r7, r7, lsl #2
  412da2:	007f      	lslle	r7, r7, #1
  412da4:	e7ef      	b.n	412d86 <_strtod_r+0x7b6>
  412da6:	2200      	movs	r2, #0
  412da8:	9208      	str	r2, [sp, #32]
  412daa:	e5bc      	b.n	412926 <_strtod_r+0x356>
  412dac:	2100      	movs	r1, #0
  412dae:	9108      	str	r1, [sp, #32]
  412db0:	e5b6      	b.n	412920 <_strtod_r+0x350>
  412db2:	2201      	movs	r2, #1
  412db4:	920b      	str	r2, [sp, #44]	; 0x2c
  412db6:	e4bd      	b.n	412734 <_strtod_r+0x164>
  412db8:	f5b4 7f9a 	cmp.w	r4, #308	; 0x134
  412dbc:	f300 8117 	bgt.w	412fee <_strtod_r+0xa1e>
  412dc0:	1124      	asrs	r4, r4, #4
  412dc2:	2c01      	cmp	r4, #1
  412dc4:	f8df 81c8 	ldr.w	r8, [pc, #456]	; 412f90 <_strtod_r+0x9c0>
  412dc8:	f340 832a 	ble.w	413420 <_strtod_r+0xe50>
  412dcc:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
  412dd0:	4645      	mov	r5, r8
  412dd2:	2700      	movs	r7, #0
  412dd4:	f014 0f01 	tst.w	r4, #1
  412dd8:	f107 0701 	add.w	r7, r7, #1
  412ddc:	ea4f 0464 	mov.w	r4, r4, asr #1
  412de0:	d003      	beq.n	412dea <_strtod_r+0x81a>
  412de2:	e9d5 2300 	ldrd	r2, r3, [r5]
  412de6:	f001 fe83 	bl	414af0 <__aeabi_dmul>
  412dea:	2c01      	cmp	r4, #1
  412dec:	f105 0508 	add.w	r5, r5, #8
  412df0:	dcf0      	bgt.n	412dd4 <_strtod_r+0x804>
  412df2:	e9cd 0102 	strd	r0, r1, [sp, #8]
  412df6:	9b03      	ldr	r3, [sp, #12]
  412df8:	f1a3 7354 	sub.w	r3, r3, #55574528	; 0x3500000
  412dfc:	9303      	str	r3, [sp, #12]
  412dfe:	eb08 07c7 	add.w	r7, r8, r7, lsl #3
  412e02:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  412e06:	e9d7 0100 	ldrd	r0, r1, [r7]
  412e0a:	f001 fe71 	bl	414af0 <__aeabi_dmul>
  412e0e:	e9cd 0102 	strd	r0, r1, [sp, #8]
  412e12:	9803      	ldr	r0, [sp, #12]
  412e14:	4a55      	ldr	r2, [pc, #340]	; (412f6c <_strtod_r+0x99c>)
  412e16:	f020 4300 	bic.w	r3, r0, #2147483648	; 0x80000000
  412e1a:	0d1b      	lsrs	r3, r3, #20
  412e1c:	051b      	lsls	r3, r3, #20
  412e1e:	4293      	cmp	r3, r2
  412e20:	f200 80e5 	bhi.w	412fee <_strtod_r+0xa1e>
  412e24:	f5a2 1280 	sub.w	r2, r2, #1048576	; 0x100000
  412e28:	4293      	cmp	r3, r2
  412e2a:	f240 82d5 	bls.w	4133d8 <_strtod_r+0xe08>
  412e2e:	4950      	ldr	r1, [pc, #320]	; (412f70 <_strtod_r+0x9a0>)
  412e30:	9103      	str	r1, [sp, #12]
  412e32:	2200      	movs	r2, #0
  412e34:	f04f 33ff 	mov.w	r3, #4294967295
  412e38:	920a      	str	r2, [sp, #40]	; 0x28
  412e3a:	9302      	str	r3, [sp, #8]
  412e3c:	e5f6      	b.n	412a2c <_strtod_r+0x45c>
  412e3e:	9902      	ldr	r1, [sp, #8]
  412e40:	f8dd 900c 	ldr.w	r9, [sp, #12]
  412e44:	2901      	cmp	r1, #1
  412e46:	f000 81c9 	beq.w	4131dc <_strtod_r+0xc0c>
  412e4a:	4947      	ldr	r1, [pc, #284]	; (412f68 <_strtod_r+0x998>)
  412e4c:	4d49      	ldr	r5, [pc, #292]	; (412f74 <_strtod_r+0x9a4>)
  412e4e:	2000      	movs	r0, #0
  412e50:	2400      	movs	r4, #0
  412e52:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
  412e56:	e6d6      	b.n	412c06 <_strtod_r+0x636>
  412e58:	9919      	ldr	r1, [sp, #100]	; 0x64
  412e5a:	9106      	str	r1, [sp, #24]
  412e5c:	f1a4 0230 	sub.w	r2, r4, #48	; 0x30
  412e60:	f04f 0a00 	mov.w	sl, #0
  412e64:	460c      	mov	r4, r1
  412e66:	2001      	movs	r0, #1
  412e68:	e77f      	b.n	412d6a <_strtod_r+0x79a>
  412e6a:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
  412e6e:	f002 f901 	bl	415074 <__aeabi_d2uiz>
  412e72:	2800      	cmp	r0, #0
  412e74:	f000 81ad 	beq.w	4131d2 <_strtod_r+0xc02>
  412e78:	f001 fdc4 	bl	414a04 <__aeabi_ui2d>
  412e7c:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
  412e80:	f1ba 0f00 	cmp.w	sl, #0
  412e84:	f040 81a0 	bne.w	4131c8 <_strtod_r+0xbf8>
  412e88:	9a0d      	ldr	r2, [sp, #52]	; 0x34
  412e8a:	990c      	ldr	r1, [sp, #48]	; 0x30
  412e8c:	9114      	str	r1, [sp, #80]	; 0x50
  412e8e:	f102 4200 	add.w	r2, r2, #2147483648	; 0x80000000
  412e92:	9215      	str	r2, [sp, #84]	; 0x54
  412e94:	e9dd 4514 	ldrd	r4, r5, [sp, #80]	; 0x50
  412e98:	e6cc      	b.n	412c34 <_strtod_r+0x664>
  412e9a:	4837      	ldr	r0, [pc, #220]	; (412f78 <_strtod_r+0x9a8>)
  412e9c:	9919      	ldr	r1, [sp, #100]	; 0x64
  412e9e:	e009      	b.n	412eb4 <_strtod_r+0x8e4>
  412ea0:	f811 3f01 	ldrb.w	r3, [r1, #1]!
  412ea4:	f1a3 0441 	sub.w	r4, r3, #65	; 0x41
  412ea8:	2c19      	cmp	r4, #25
  412eaa:	bf98      	it	ls
  412eac:	3320      	addls	r3, #32
  412eae:	4293      	cmp	r3, r2
  412eb0:	f47f abdd 	bne.w	41266e <_strtod_r+0x9e>
  412eb4:	f810 2f01 	ldrb.w	r2, [r0, #1]!
  412eb8:	2a00      	cmp	r2, #0
  412eba:	d1f1      	bne.n	412ea0 <_strtod_r+0x8d0>
  412ebc:	1c4b      	adds	r3, r1, #1
  412ebe:	9319      	str	r3, [sp, #100]	; 0x64
  412ec0:	784b      	ldrb	r3, [r1, #1]
  412ec2:	2b28      	cmp	r3, #40	; 0x28
  412ec4:	f000 82e2 	beq.w	41348c <_strtod_r+0xebc>
  412ec8:	4a2c      	ldr	r2, [pc, #176]	; (412f7c <_strtod_r+0x9ac>)
  412eca:	9203      	str	r2, [sp, #12]
  412ecc:	2300      	movs	r3, #0
  412ece:	9302      	str	r3, [sp, #8]
  412ed0:	e513      	b.n	4128fa <_strtod_r+0x32a>
  412ed2:	482b      	ldr	r0, [pc, #172]	; (412f80 <_strtod_r+0x9b0>)
  412ed4:	9919      	ldr	r1, [sp, #100]	; 0x64
  412ed6:	e009      	b.n	412eec <_strtod_r+0x91c>
  412ed8:	f811 3f01 	ldrb.w	r3, [r1, #1]!
  412edc:	f1a3 0441 	sub.w	r4, r3, #65	; 0x41
  412ee0:	2c19      	cmp	r4, #25
  412ee2:	bf98      	it	ls
  412ee4:	3320      	addls	r3, #32
  412ee6:	4293      	cmp	r3, r2
  412ee8:	f47f abc1 	bne.w	41266e <_strtod_r+0x9e>
  412eec:	f810 2f01 	ldrb.w	r2, [r0, #1]!
  412ef0:	2a00      	cmp	r2, #0
  412ef2:	d1f1      	bne.n	412ed8 <_strtod_r+0x908>
  412ef4:	9119      	str	r1, [sp, #100]	; 0x64
  412ef6:	4c23      	ldr	r4, [pc, #140]	; (412f84 <_strtod_r+0x9b4>)
  412ef8:	4608      	mov	r0, r1
  412efa:	e009      	b.n	412f10 <_strtod_r+0x940>
  412efc:	f810 3f01 	ldrb.w	r3, [r0, #1]!
  412f00:	f1a3 0541 	sub.w	r5, r3, #65	; 0x41
  412f04:	2d19      	cmp	r5, #25
  412f06:	bf98      	it	ls
  412f08:	3320      	addls	r3, #32
  412f0a:	4293      	cmp	r3, r2
  412f0c:	f040 8285 	bne.w	41341a <_strtod_r+0xe4a>
  412f10:	f814 2f01 	ldrb.w	r2, [r4, #1]!
  412f14:	2a00      	cmp	r2, #0
  412f16:	d1f1      	bne.n	412efc <_strtod_r+0x92c>
  412f18:	3001      	adds	r0, #1
  412f1a:	9019      	str	r0, [sp, #100]	; 0x64
  412f1c:	4a1a      	ldr	r2, [pc, #104]	; (412f88 <_strtod_r+0x9b8>)
  412f1e:	9203      	str	r2, [sp, #12]
  412f20:	2300      	movs	r3, #0
  412f22:	9302      	str	r3, [sp, #8]
  412f24:	e4e9      	b.n	4128fa <_strtod_r+0x32a>
  412f26:	9907      	ldr	r1, [sp, #28]
  412f28:	9101      	str	r1, [sp, #4]
  412f2a:	ab1a      	add	r3, sp, #104	; 0x68
  412f2c:	9300      	str	r3, [sp, #0]
  412f2e:	4658      	mov	r0, fp
  412f30:	a919      	add	r1, sp, #100	; 0x64
  412f32:	4a16      	ldr	r2, [pc, #88]	; (412f8c <_strtod_r+0x9bc>)
  412f34:	ab1b      	add	r3, sp, #108	; 0x6c
  412f36:	f001 f8af 	bl	414098 <__gethex>
  412f3a:	f010 0507 	ands.w	r5, r0, #7
  412f3e:	4604      	mov	r4, r0
  412f40:	f43f acca 	beq.w	4128d8 <_strtod_r+0x308>
  412f44:	2d06      	cmp	r5, #6
  412f46:	f040 8157 	bne.w	4131f8 <_strtod_r+0xc28>
  412f4a:	3601      	adds	r6, #1
  412f4c:	2200      	movs	r2, #0
  412f4e:	9619      	str	r6, [sp, #100]	; 0x64
  412f50:	f04f 0800 	mov.w	r8, #0
  412f54:	f04f 0900 	mov.w	r9, #0
  412f58:	9207      	str	r2, [sp, #28]
  412f5a:	f7ff bb8f 	b.w	41267c <_strtod_r+0xac>
  412f5e:	bf00      	nop
  412f60:	3fe00000 	.word	0x3fe00000
  412f64:	fffffbe3 	.word	0xfffffbe3
  412f68:	3ff00000 	.word	0x3ff00000
  412f6c:	7ca00000 	.word	0x7ca00000
  412f70:	7fefffff 	.word	0x7fefffff
  412f74:	bff00000 	.word	0xbff00000
  412f78:	0041712b 	.word	0x0041712b
  412f7c:	fff80000 	.word	0xfff80000
  412f80:	0041711f 	.word	0x0041711f
  412f84:	00417123 	.word	0x00417123
  412f88:	7ff00000 	.word	0x7ff00000
  412f8c:	0041710c 	.word	0x0041710c
  412f90:	004170d8 	.word	0x004170d8
  412f94:	f1a9 7954 	sub.w	r9, r9, #55574528	; 0x3500000
  412f98:	f8cd 900c 	str.w	r9, [sp, #12]
  412f9c:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
  412fa0:	f7fe ff42 	bl	411e28 <__ulp>
  412fa4:	4602      	mov	r2, r0
  412fa6:	460b      	mov	r3, r1
  412fa8:	4620      	mov	r0, r4
  412faa:	4629      	mov	r1, r5
  412fac:	f001 fda0 	bl	414af0 <__aeabi_dmul>
  412fb0:	4602      	mov	r2, r0
  412fb2:	460b      	mov	r3, r1
  412fb4:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
  412fb8:	f001 fbe8 	bl	41478c <__adddf3>
  412fbc:	e9cd 0102 	strd	r0, r1, [sp, #8]
  412fc0:	9903      	ldr	r1, [sp, #12]
  412fc2:	4aad      	ldr	r2, [pc, #692]	; (413278 <_strtod_r+0xca8>)
  412fc4:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
  412fc8:	0d1b      	lsrs	r3, r3, #20
  412fca:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
  412fce:	051b      	lsls	r3, r3, #20
  412fd0:	4293      	cmp	r3, r2
  412fd2:	e9cd 0112 	strd	r0, r1, [sp, #72]	; 0x48
  412fd6:	f240 80d5 	bls.w	413184 <_strtod_r+0xbb4>
  412fda:	4ba8      	ldr	r3, [pc, #672]	; (41327c <_strtod_r+0xcac>)
  412fdc:	9913      	ldr	r1, [sp, #76]	; 0x4c
  412fde:	4299      	cmp	r1, r3
  412fe0:	d010      	beq.n	413004 <_strtod_r+0xa34>
  412fe2:	4ba6      	ldr	r3, [pc, #664]	; (41327c <_strtod_r+0xcac>)
  412fe4:	9303      	str	r3, [sp, #12]
  412fe6:	f04f 30ff 	mov.w	r0, #4294967295
  412fea:	9002      	str	r0, [sp, #8]
  412fec:	e640      	b.n	412c70 <_strtod_r+0x6a0>
  412fee:	4aa4      	ldr	r2, [pc, #656]	; (413280 <_strtod_r+0xcb0>)
  412ff0:	9203      	str	r2, [sp, #12]
  412ff2:	2000      	movs	r0, #0
  412ff4:	2322      	movs	r3, #34	; 0x22
  412ff6:	9002      	str	r0, [sp, #8]
  412ff8:	e9dd 8902 	ldrd	r8, r9, [sp, #8]
  412ffc:	f8cb 3000 	str.w	r3, [fp]
  413000:	f7ff bb3c 	b.w	41267c <_strtod_r+0xac>
  413004:	9a12      	ldr	r2, [sp, #72]	; 0x48
  413006:	3201      	adds	r2, #1
  413008:	d1eb      	bne.n	412fe2 <_strtod_r+0xa12>
  41300a:	46b2      	mov	sl, r6
  41300c:	991a      	ldr	r1, [sp, #104]	; 0x68
  41300e:	4a9c      	ldr	r2, [pc, #624]	; (413280 <_strtod_r+0xcb0>)
  413010:	9203      	str	r2, [sp, #12]
  413012:	2000      	movs	r0, #0
  413014:	9002      	str	r0, [sp, #8]
  413016:	e9dd 8902 	ldrd	r8, r9, [sp, #8]
  41301a:	2322      	movs	r3, #34	; 0x22
  41301c:	f8cb 3000 	str.w	r3, [fp]
  413020:	4658      	mov	r0, fp
  413022:	f7fe fc2f 	bl	411884 <_Bfree>
  413026:	4658      	mov	r0, fp
  413028:	4651      	mov	r1, sl
  41302a:	f7fe fc2b 	bl	411884 <_Bfree>
  41302e:	4658      	mov	r0, fp
  413030:	4639      	mov	r1, r7
  413032:	f7fe fc27 	bl	411884 <_Bfree>
  413036:	4658      	mov	r0, fp
  413038:	990b      	ldr	r1, [sp, #44]	; 0x2c
  41303a:	f7fe fc23 	bl	411884 <_Bfree>
  41303e:	4658      	mov	r0, fp
  413040:	9906      	ldr	r1, [sp, #24]
  413042:	f7fe fc1f 	bl	411884 <_Bfree>
  413046:	f7ff bb19 	b.w	41267c <_strtod_r+0xac>
  41304a:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
  41304e:	f001 ffe9 	bl	415024 <__aeabi_d2iz>
  413052:	f001 fce7 	bl	414a24 <__aeabi_i2d>
  413056:	4602      	mov	r2, r0
  413058:	460b      	mov	r3, r1
  41305a:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
  41305e:	f001 fb93 	bl	414788 <__aeabi_dsub>
  413062:	4680      	mov	r8, r0
  413064:	4689      	mov	r9, r1
  413066:	f1ba 0f00 	cmp.w	sl, #0
  41306a:	d111      	bne.n	413090 <_strtod_r+0xac0>
  41306c:	9a02      	ldr	r2, [sp, #8]
  41306e:	b97a      	cbnz	r2, 413090 <_strtod_r+0xac0>
  413070:	f3c4 0413 	ubfx	r4, r4, #0, #20
  413074:	b964      	cbnz	r4, 413090 <_strtod_r+0xac0>
  413076:	a37a      	add	r3, pc, #488	; (adr r3, 413260 <_strtod_r+0xc90>)
  413078:	e9d3 2300 	ldrd	r2, r3, [r3]
  41307c:	f001 ffaa 	bl	414fd4 <__aeabi_dcmplt>
  413080:	2800      	cmp	r0, #0
  413082:	f43f adf5 	beq.w	412c70 <_strtod_r+0x6a0>
  413086:	46b2      	mov	sl, r6
  413088:	e9dd 8902 	ldrd	r8, r9, [sp, #8]
  41308c:	991a      	ldr	r1, [sp, #104]	; 0x68
  41308e:	e7c7      	b.n	413020 <_strtod_r+0xa50>
  413090:	4640      	mov	r0, r8
  413092:	4649      	mov	r1, r9
  413094:	a374      	add	r3, pc, #464	; (adr r3, 413268 <_strtod_r+0xc98>)
  413096:	e9d3 2300 	ldrd	r2, r3, [r3]
  41309a:	f001 ff9b 	bl	414fd4 <__aeabi_dcmplt>
  41309e:	2800      	cmp	r0, #0
  4130a0:	d1f1      	bne.n	413086 <_strtod_r+0xab6>
  4130a2:	4640      	mov	r0, r8
  4130a4:	4649      	mov	r1, r9
  4130a6:	a372      	add	r3, pc, #456	; (adr r3, 413270 <_strtod_r+0xca0>)
  4130a8:	e9d3 2300 	ldrd	r2, r3, [r3]
  4130ac:	f001 ffb0 	bl	415010 <__aeabi_dcmpgt>
  4130b0:	2800      	cmp	r0, #0
  4130b2:	f43f addd 	beq.w	412c70 <_strtod_r+0x6a0>
  4130b6:	e7e6      	b.n	413086 <_strtod_r+0xab6>
  4130b8:	4650      	mov	r0, sl
  4130ba:	2808      	cmp	r0, #8
  4130bc:	f100 0a01 	add.w	sl, r0, #1
  4130c0:	f300 8107 	bgt.w	4132d2 <_strtod_r+0xd02>
  4130c4:	eb09 0989 	add.w	r9, r9, r9, lsl #2
  4130c8:	eb02 0949 	add.w	r9, r2, r9, lsl #1
  4130cc:	2000      	movs	r0, #0
  4130ce:	1c62      	adds	r2, r4, #1
  4130d0:	9219      	str	r2, [sp, #100]	; 0x64
  4130d2:	7864      	ldrb	r4, [r4, #1]
  4130d4:	e643      	b.n	412d5e <_strtod_r+0x78e>
  4130d6:	f43f aca7 	beq.w	412a28 <_strtod_r+0x458>
  4130da:	f1c8 0400 	rsb	r4, r8, #0
  4130de:	f014 030f 	ands.w	r3, r4, #15
  4130e2:	d00a      	beq.n	4130fa <_strtod_r+0xb2a>
  4130e4:	4a67      	ldr	r2, [pc, #412]	; (413284 <_strtod_r+0xcb4>)
  4130e6:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
  4130ea:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
  4130ee:	e9d3 2300 	ldrd	r2, r3, [r3]
  4130f2:	f001 fe27 	bl	414d44 <__aeabi_ddiv>
  4130f6:	e9cd 0102 	strd	r0, r1, [sp, #8]
  4130fa:	1124      	asrs	r4, r4, #4
  4130fc:	f43f ac94 	beq.w	412a28 <_strtod_r+0x458>
  413100:	2c1f      	cmp	r4, #31
  413102:	dc33      	bgt.n	41316c <_strtod_r+0xb9c>
  413104:	f014 0f10 	tst.w	r4, #16
  413108:	bf14      	ite	ne
  41310a:	216a      	movne	r1, #106	; 0x6a
  41310c:	2100      	moveq	r1, #0
  41310e:	2c00      	cmp	r4, #0
  413110:	910a      	str	r1, [sp, #40]	; 0x28
  413112:	dd0e      	ble.n	413132 <_strtod_r+0xb62>
  413114:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
  413118:	4d5b      	ldr	r5, [pc, #364]	; (413288 <_strtod_r+0xcb8>)
  41311a:	07e3      	lsls	r3, r4, #31
  41311c:	d503      	bpl.n	413126 <_strtod_r+0xb56>
  41311e:	e9d5 2300 	ldrd	r2, r3, [r5]
  413122:	f001 fce5 	bl	414af0 <__aeabi_dmul>
  413126:	1064      	asrs	r4, r4, #1
  413128:	f105 0508 	add.w	r5, r5, #8
  41312c:	d1f5      	bne.n	41311a <_strtod_r+0xb4a>
  41312e:	e9cd 0102 	strd	r0, r1, [sp, #8]
  413132:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  413134:	b18a      	cbz	r2, 41315a <_strtod_r+0xb8a>
  413136:	9803      	ldr	r0, [sp, #12]
  413138:	f3c0 530a 	ubfx	r3, r0, #20, #11
  41313c:	f1c3 036b 	rsb	r3, r3, #107	; 0x6b
  413140:	2b00      	cmp	r3, #0
  413142:	dd0a      	ble.n	41315a <_strtod_r+0xb8a>
  413144:	2b1f      	cmp	r3, #31
  413146:	f340 81bd 	ble.w	4134c4 <_strtod_r+0xef4>
  41314a:	2100      	movs	r1, #0
  41314c:	2b34      	cmp	r3, #52	; 0x34
  41314e:	9102      	str	r1, [sp, #8]
  413150:	f340 81c0 	ble.w	4134d4 <_strtod_r+0xf04>
  413154:	f04f 725c 	mov.w	r2, #57671680	; 0x3700000
  413158:	9203      	str	r2, [sp, #12]
  41315a:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
  41315e:	2200      	movs	r2, #0
  413160:	2300      	movs	r3, #0
  413162:	f001 ff2d 	bl	414fc0 <__aeabi_dcmpeq>
  413166:	2800      	cmp	r0, #0
  413168:	f43f ac60 	beq.w	412a2c <_strtod_r+0x45c>
  41316c:	2322      	movs	r3, #34	; 0x22
  41316e:	f8cb 3000 	str.w	r3, [fp]
  413172:	f04f 0800 	mov.w	r8, #0
  413176:	f04f 0900 	mov.w	r9, #0
  41317a:	f7ff ba7f 	b.w	41267c <_strtod_r+0xac>
  41317e:	f644 611f 	movw	r1, #19999	; 0x4e1f
  413182:	e40f      	b.n	4129a4 <_strtod_r+0x3d4>
  413184:	9903      	ldr	r1, [sp, #12]
  413186:	f101 7454 	add.w	r4, r1, #55574528	; 0x3500000
  41318a:	9403      	str	r4, [sp, #12]
  41318c:	e569      	b.n	412c62 <_strtod_r+0x692>
  41318e:	9808      	ldr	r0, [sp, #32]
  413190:	f1ca 0325 	rsb	r3, sl, #37	; 0x25
  413194:	4298      	cmp	r0, r3
  413196:	f73f ac2d 	bgt.w	4129f4 <_strtod_r+0x424>
  41319a:	4c3a      	ldr	r4, [pc, #232]	; (413284 <_strtod_r+0xcb4>)
  41319c:	f1ca 050f 	rsb	r5, sl, #15
  4131a0:	eb04 01c5 	add.w	r1, r4, r5, lsl #3
  4131a4:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  4131a8:	e9d1 0100 	ldrd	r0, r1, [r1]
  4131ac:	f001 fca0 	bl	414af0 <__aeabi_dmul>
  4131b0:	9a08      	ldr	r2, [sp, #32]
  4131b2:	1b55      	subs	r5, r2, r5
  4131b4:	eb04 04c5 	add.w	r4, r4, r5, lsl #3
  4131b8:	e9d4 2300 	ldrd	r2, r3, [r4]
  4131bc:	f001 fc98 	bl	414af0 <__aeabi_dmul>
  4131c0:	4680      	mov	r8, r0
  4131c2:	4689      	mov	r9, r1
  4131c4:	f7ff ba5a 	b.w	41267c <_strtod_r+0xac>
  4131c8:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
  4131cc:	e9cd 0114 	strd	r0, r1, [sp, #80]	; 0x50
  4131d0:	e660      	b.n	412e94 <_strtod_r+0x8c4>
  4131d2:	492e      	ldr	r1, [pc, #184]	; (41328c <_strtod_r+0xcbc>)
  4131d4:	2000      	movs	r0, #0
  4131d6:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
  4131da:	e651      	b.n	412e80 <_strtod_r+0x8b0>
  4131dc:	464a      	mov	r2, r9
  4131de:	2a00      	cmp	r2, #0
  4131e0:	f47f ae33 	bne.w	412e4a <_strtod_r+0x87a>
  4131e4:	46b2      	mov	sl, r6
  4131e6:	2322      	movs	r3, #34	; 0x22
  4131e8:	f8cb 3000 	str.w	r3, [fp]
  4131ec:	991a      	ldr	r1, [sp, #104]	; 0x68
  4131ee:	f04f 0800 	mov.w	r8, #0
  4131f2:	f04f 0900 	mov.w	r9, #0
  4131f6:	e713      	b.n	413020 <_strtod_r+0xa50>
  4131f8:	9a1a      	ldr	r2, [sp, #104]	; 0x68
  4131fa:	b13a      	cbz	r2, 41320c <_strtod_r+0xc3c>
  4131fc:	a81c      	add	r0, sp, #112	; 0x70
  4131fe:	2135      	movs	r1, #53	; 0x35
  413200:	f7fe ff12 	bl	412028 <__copybits>
  413204:	4658      	mov	r0, fp
  413206:	991a      	ldr	r1, [sp, #104]	; 0x68
  413208:	f7fe fb3c 	bl	411884 <_Bfree>
  41320c:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
  41320e:	2d06      	cmp	r5, #6
  413210:	f63f ab6d 	bhi.w	4128ee <_strtod_r+0x31e>
  413214:	a001      	add	r0, pc, #4	; (adr r0, 41321c <_strtod_r+0xc4c>)
  413216:	f850 f025 	ldr.w	pc, [r0, r5, lsl #2]
  41321a:	bf00      	nop
  41321c:	00413251 	.word	0x00413251
  413220:	00413291 	.word	0x00413291
  413224:	00413245 	.word	0x00413245
  413228:	00413239 	.word	0x00413239
  41322c:	004128e3 	.word	0x004128e3
  413230:	00413291 	.word	0x00413291
  413234:	00413251 	.word	0x00413251
  413238:	4911      	ldr	r1, [pc, #68]	; (413280 <_strtod_r+0xcb0>)
  41323a:	9103      	str	r1, [sp, #12]
  41323c:	2200      	movs	r2, #0
  41323e:	9202      	str	r2, [sp, #8]
  413240:	f7ff bb55 	b.w	4128ee <_strtod_r+0x31e>
  413244:	9a1c      	ldr	r2, [sp, #112]	; 0x70
  413246:	9b1d      	ldr	r3, [sp, #116]	; 0x74
  413248:	9202      	str	r2, [sp, #8]
  41324a:	9303      	str	r3, [sp, #12]
  41324c:	f7ff bb4f 	b.w	4128ee <_strtod_r+0x31e>
  413250:	2100      	movs	r1, #0
  413252:	9103      	str	r1, [sp, #12]
  413254:	9102      	str	r1, [sp, #8]
  413256:	f7ff bb4a 	b.w	4128ee <_strtod_r+0x31e>
  41325a:	bf00      	nop
  41325c:	f3af 8000 	nop.w
  413260:	94a03595 	.word	0x94a03595
  413264:	3fcfffff 	.word	0x3fcfffff
  413268:	94a03595 	.word	0x94a03595
  41326c:	3fdfffff 	.word	0x3fdfffff
  413270:	35afe535 	.word	0x35afe535
  413274:	3fe00000 	.word	0x3fe00000
  413278:	7c9fffff 	.word	0x7c9fffff
  41327c:	7fefffff 	.word	0x7fefffff
  413280:	7ff00000 	.word	0x7ff00000
  413284:	00417010 	.word	0x00417010
  413288:	00417148 	.word	0x00417148
  41328c:	3ff00000 	.word	0x3ff00000
  413290:	9a1d      	ldr	r2, [sp, #116]	; 0x74
  413292:	981c      	ldr	r0, [sp, #112]	; 0x70
  413294:	9002      	str	r0, [sp, #8]
  413296:	f203 4333 	addw	r3, r3, #1075	; 0x433
  41329a:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
  41329e:	ea42 5203 	orr.w	r2, r2, r3, lsl #20
  4132a2:	9203      	str	r2, [sp, #12]
  4132a4:	f7ff bb23 	b.w	4128ee <_strtod_r+0x31e>
  4132a8:	9b08      	ldr	r3, [sp, #32]
  4132aa:	3316      	adds	r3, #22
  4132ac:	f6ff aba2 	blt.w	4129f4 <_strtod_r+0x424>
  4132b0:	4b8e      	ldr	r3, [pc, #568]	; (4134ec <_strtod_r+0xf1c>)
  4132b2:	9808      	ldr	r0, [sp, #32]
  4132b4:	eba3 0ac0 	sub.w	sl, r3, r0, lsl #3
  4132b8:	e9da 2300 	ldrd	r2, r3, [sl]
  4132bc:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
  4132c0:	f001 fd40 	bl	414d44 <__aeabi_ddiv>
  4132c4:	4680      	mov	r8, r0
  4132c6:	4689      	mov	r9, r1
  4132c8:	f7ff b9d8 	b.w	41267c <_strtod_r+0xac>
  4132cc:	46b2      	mov	sl, r6
  4132ce:	4601      	mov	r1, r0
  4132d0:	e69d      	b.n	41300e <_strtod_r+0xa3e>
  4132d2:	f1ba 0f10 	cmp.w	sl, #16
  4132d6:	bfdc      	itt	le
  4132d8:	eb07 0787 	addle.w	r7, r7, r7, lsl #2
  4132dc:	eb02 0747 	addle.w	r7, r2, r7, lsl #1
  4132e0:	2000      	movs	r0, #0
  4132e2:	e6f4      	b.n	4130ce <_strtod_r+0xafe>
  4132e4:	4655      	mov	r5, sl
  4132e6:	46c4      	mov	ip, r8
  4132e8:	46b2      	mov	sl, r6
  4132ea:	e9dd 8908 	ldrd	r8, r9, [sp, #32]
  4132ee:	2d00      	cmp	r5, #0
  4132f0:	f000 8082 	beq.w	4133f8 <_strtod_r+0xe28>
  4132f4:	9a03      	ldr	r2, [sp, #12]
  4132f6:	4b7e      	ldr	r3, [pc, #504]	; (4134f0 <_strtod_r+0xf20>)
  4132f8:	f3c2 0113 	ubfx	r1, r2, #0, #20
  4132fc:	4299      	cmp	r1, r3
  4132fe:	f000 80a3 	beq.w	413448 <_strtod_r+0xe78>
  413302:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  413304:	2b00      	cmp	r3, #0
  413306:	f000 8083 	beq.w	413410 <_strtod_r+0xe40>
  41330a:	9803      	ldr	r0, [sp, #12]
  41330c:	4203      	tst	r3, r0
  41330e:	d00f      	beq.n	413330 <_strtod_r+0xd60>
  413310:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
  413314:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  413316:	2d00      	cmp	r5, #0
  413318:	f000 8084 	beq.w	413424 <_strtod_r+0xe54>
  41331c:	f7ff f936 	bl	41258c <sulp>
  413320:	4602      	mov	r2, r0
  413322:	460b      	mov	r3, r1
  413324:	4640      	mov	r0, r8
  413326:	4649      	mov	r1, r9
  413328:	f001 fa30 	bl	41478c <__adddf3>
  41332c:	4680      	mov	r8, r0
  41332e:	4689      	mov	r9, r1
  413330:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  413332:	b1b3      	cbz	r3, 413362 <_strtod_r+0xd92>
  413334:	486f      	ldr	r0, [pc, #444]	; (4134f4 <_strtod_r+0xf24>)
  413336:	9013      	str	r0, [sp, #76]	; 0x4c
  413338:	2100      	movs	r1, #0
  41333a:	9112      	str	r1, [sp, #72]	; 0x48
  41333c:	e9dd 2312 	ldrd	r2, r3, [sp, #72]	; 0x48
  413340:	4640      	mov	r0, r8
  413342:	4649      	mov	r1, r9
  413344:	f001 fbd4 	bl	414af0 <__aeabi_dmul>
  413348:	4680      	mov	r8, r0
  41334a:	4689      	mov	r9, r1
  41334c:	e9cd 8902 	strd	r8, r9, [sp, #8]
  413350:	9a03      	ldr	r2, [sp, #12]
  413352:	b932      	cbnz	r2, 413362 <_strtod_r+0xd92>
  413354:	9b02      	ldr	r3, [sp, #8]
  413356:	b923      	cbnz	r3, 413362 <_strtod_r+0xd92>
  413358:	2322      	movs	r3, #34	; 0x22
  41335a:	991a      	ldr	r1, [sp, #104]	; 0x68
  41335c:	f8cb 3000 	str.w	r3, [fp]
  413360:	e65e      	b.n	413020 <_strtod_r+0xa50>
  413362:	991a      	ldr	r1, [sp, #104]	; 0x68
  413364:	e65c      	b.n	413020 <_strtod_r+0xa50>
  413366:	4655      	mov	r5, sl
  413368:	e9dd 8908 	ldrd	r8, r9, [sp, #32]
  41336c:	46b2      	mov	sl, r6
  41336e:	2d00      	cmp	r5, #0
  413370:	d1de      	bne.n	413330 <_strtod_r+0xd60>
  413372:	9a02      	ldr	r2, [sp, #8]
  413374:	2a00      	cmp	r2, #0
  413376:	d1db      	bne.n	413330 <_strtod_r+0xd60>
  413378:	9803      	ldr	r0, [sp, #12]
  41337a:	f3c0 0313 	ubfx	r3, r0, #0, #20
  41337e:	4604      	mov	r4, r0
  413380:	2b00      	cmp	r3, #0
  413382:	d1d5      	bne.n	413330 <_strtod_r+0xd60>
  413384:	f020 4300 	bic.w	r3, r0, #2147483648	; 0x80000000
  413388:	0d1b      	lsrs	r3, r3, #20
  41338a:	051b      	lsls	r3, r3, #20
  41338c:	f1b3 6fd6 	cmp.w	r3, #112197632	; 0x6b00000
  413390:	d9ce      	bls.n	413330 <_strtod_r+0xd60>
  413392:	9906      	ldr	r1, [sp, #24]
  413394:	694b      	ldr	r3, [r1, #20]
  413396:	b913      	cbnz	r3, 41339e <_strtod_r+0xdce>
  413398:	690b      	ldr	r3, [r1, #16]
  41339a:	2b01      	cmp	r3, #1
  41339c:	ddc8      	ble.n	413330 <_strtod_r+0xd60>
  41339e:	9906      	ldr	r1, [sp, #24]
  4133a0:	2201      	movs	r2, #1
  4133a2:	4658      	mov	r0, fp
  4133a4:	f7fe fc54 	bl	411c50 <__lshift>
  4133a8:	4639      	mov	r1, r7
  4133aa:	9006      	str	r0, [sp, #24]
  4133ac:	f7fe fcae 	bl	411d0c <__mcmp>
  4133b0:	2800      	cmp	r0, #0
  4133b2:	ddbd      	ble.n	413330 <_strtod_r+0xd60>
  4133b4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  4133b6:	2b00      	cmp	r3, #0
  4133b8:	d17a      	bne.n	4134b0 <_strtod_r+0xee0>
  4133ba:	4b4f      	ldr	r3, [pc, #316]	; (4134f8 <_strtod_r+0xf28>)
  4133bc:	4023      	ands	r3, r4
  4133be:	f5a3 1380 	sub.w	r3, r3, #1048576	; 0x100000
  4133c2:	ea6f 5313 	mvn.w	r3, r3, lsr #20
  4133c6:	ea6f 5003 	mvn.w	r0, r3, lsl #20
  4133ca:	f04f 31ff 	mov.w	r1, #4294967295
  4133ce:	9003      	str	r0, [sp, #12]
  4133d0:	9102      	str	r1, [sp, #8]
  4133d2:	e9dd 8902 	ldrd	r8, r9, [sp, #8]
  4133d6:	e7ab      	b.n	413330 <_strtod_r+0xd60>
  4133d8:	f100 7154 	add.w	r1, r0, #55574528	; 0x3500000
  4133dc:	2000      	movs	r0, #0
  4133de:	9103      	str	r1, [sp, #12]
  4133e0:	900a      	str	r0, [sp, #40]	; 0x28
  4133e2:	f7ff bb23 	b.w	412a2c <_strtod_r+0x45c>
  4133e6:	4b45      	ldr	r3, [pc, #276]	; (4134fc <_strtod_r+0xf2c>)
  4133e8:	4945      	ldr	r1, [pc, #276]	; (413500 <_strtod_r+0xf30>)
  4133ea:	2200      	movs	r2, #0
  4133ec:	2000      	movs	r0, #0
  4133ee:	e9cd 2316 	strd	r2, r3, [sp, #88]	; 0x58
  4133f2:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
  4133f6:	e4ac      	b.n	412d52 <_strtod_r+0x782>
  4133f8:	9903      	ldr	r1, [sp, #12]
  4133fa:	f3c1 0313 	ubfx	r3, r1, #0, #20
  4133fe:	460c      	mov	r4, r1
  413400:	2b00      	cmp	r3, #0
  413402:	f47f af7e 	bne.w	413302 <_strtod_r+0xd32>
  413406:	9a02      	ldr	r2, [sp, #8]
  413408:	2a00      	cmp	r2, #0
  41340a:	f47f af7a 	bne.w	413302 <_strtod_r+0xd32>
  41340e:	e7d1      	b.n	4133b4 <_strtod_r+0xde4>
  413410:	9902      	ldr	r1, [sp, #8]
  413412:	ea1c 0f01 	tst.w	ip, r1
  413416:	d08b      	beq.n	413330 <_strtod_r+0xd60>
  413418:	e77a      	b.n	413310 <_strtod_r+0xd40>
  41341a:	3101      	adds	r1, #1
  41341c:	9119      	str	r1, [sp, #100]	; 0x64
  41341e:	e57d      	b.n	412f1c <_strtod_r+0x94c>
  413420:	2700      	movs	r7, #0
  413422:	e4e8      	b.n	412df6 <_strtod_r+0x826>
  413424:	f7ff f8b2 	bl	41258c <sulp>
  413428:	4602      	mov	r2, r0
  41342a:	460b      	mov	r3, r1
  41342c:	4640      	mov	r0, r8
  41342e:	4649      	mov	r1, r9
  413430:	f001 f9aa 	bl	414788 <__aeabi_dsub>
  413434:	2200      	movs	r2, #0
  413436:	2300      	movs	r3, #0
  413438:	4680      	mov	r8, r0
  41343a:	4689      	mov	r9, r1
  41343c:	f001 fdc0 	bl	414fc0 <__aeabi_dcmpeq>
  413440:	2800      	cmp	r0, #0
  413442:	f47f aed0 	bne.w	4131e6 <_strtod_r+0xc16>
  413446:	e773      	b.n	413330 <_strtod_r+0xd60>
  413448:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  41344a:	9902      	ldr	r1, [sp, #8]
  41344c:	b1db      	cbz	r3, 413486 <_strtod_r+0xeb6>
  41344e:	4b2a      	ldr	r3, [pc, #168]	; (4134f8 <_strtod_r+0xf28>)
  413450:	4013      	ands	r3, r2
  413452:	f1b3 6fd4 	cmp.w	r3, #111149056	; 0x6a00000
  413456:	d816      	bhi.n	413486 <_strtod_r+0xeb6>
  413458:	0d1b      	lsrs	r3, r3, #20
  41345a:	f1c3 036b 	rsb	r3, r3, #107	; 0x6b
  41345e:	f04f 30ff 	mov.w	r0, #4294967295
  413462:	fa00 f303 	lsl.w	r3, r0, r3
  413466:	4299      	cmp	r1, r3
  413468:	f47f af4b 	bne.w	413302 <_strtod_r+0xd32>
  41346c:	4b25      	ldr	r3, [pc, #148]	; (413504 <_strtod_r+0xf34>)
  41346e:	429a      	cmp	r2, r3
  413470:	d038      	beq.n	4134e4 <_strtod_r+0xf14>
  413472:	4b21      	ldr	r3, [pc, #132]	; (4134f8 <_strtod_r+0xf28>)
  413474:	4013      	ands	r3, r2
  413476:	f503 1380 	add.w	r3, r3, #1048576	; 0x100000
  41347a:	2000      	movs	r0, #0
  41347c:	9303      	str	r3, [sp, #12]
  41347e:	9002      	str	r0, [sp, #8]
  413480:	e9dd 8902 	ldrd	r8, r9, [sp, #8]
  413484:	e754      	b.n	413330 <_strtod_r+0xd60>
  413486:	f04f 33ff 	mov.w	r3, #4294967295
  41348a:	e7ec      	b.n	413466 <_strtod_r+0xe96>
  41348c:	a819      	add	r0, sp, #100	; 0x64
  41348e:	491e      	ldr	r1, [pc, #120]	; (413508 <_strtod_r+0xf38>)
  413490:	aa1c      	add	r2, sp, #112	; 0x70
  413492:	f001 f899 	bl	4145c8 <__hexnan>
  413496:	2805      	cmp	r0, #5
  413498:	f47f ad16 	bne.w	412ec8 <_strtod_r+0x8f8>
  41349c:	9b1d      	ldr	r3, [sp, #116]	; 0x74
  41349e:	991c      	ldr	r1, [sp, #112]	; 0x70
  4134a0:	9102      	str	r1, [sp, #8]
  4134a2:	f043 43ff 	orr.w	r3, r3, #2139095040	; 0x7f800000
  4134a6:	f443 00e0 	orr.w	r0, r3, #7340032	; 0x700000
  4134aa:	9003      	str	r0, [sp, #12]
  4134ac:	f7ff ba25 	b.w	4128fa <_strtod_r+0x32a>
  4134b0:	4b11      	ldr	r3, [pc, #68]	; (4134f8 <_strtod_r+0xf28>)
  4134b2:	4023      	ands	r3, r4
  4134b4:	f1b3 6fd6 	cmp.w	r3, #112197632	; 0x6b00000
  4134b8:	d881      	bhi.n	4133be <_strtod_r+0xdee>
  4134ba:	f1b3 7f5c 	cmp.w	r3, #57671680	; 0x3700000
  4134be:	f63f af39 	bhi.w	413334 <_strtod_r+0xd64>
  4134c2:	e690      	b.n	4131e6 <_strtod_r+0xc16>
  4134c4:	9802      	ldr	r0, [sp, #8]
  4134c6:	f04f 32ff 	mov.w	r2, #4294967295
  4134ca:	fa02 f303 	lsl.w	r3, r2, r3
  4134ce:	4003      	ands	r3, r0
  4134d0:	9302      	str	r3, [sp, #8]
  4134d2:	e642      	b.n	41315a <_strtod_r+0xb8a>
  4134d4:	3b20      	subs	r3, #32
  4134d6:	f04f 31ff 	mov.w	r1, #4294967295
  4134da:	fa01 f303 	lsl.w	r3, r1, r3
  4134de:	4003      	ands	r3, r0
  4134e0:	9303      	str	r3, [sp, #12]
  4134e2:	e63a      	b.n	41315a <_strtod_r+0xb8a>
  4134e4:	3101      	adds	r1, #1
  4134e6:	d1c4      	bne.n	413472 <_strtod_r+0xea2>
  4134e8:	e590      	b.n	41300c <_strtod_r+0xa3c>
  4134ea:	bf00      	nop
  4134ec:	00417010 	.word	0x00417010
  4134f0:	000fffff 	.word	0x000fffff
  4134f4:	39500000 	.word	0x39500000
  4134f8:	7ff00000 	.word	0x7ff00000
  4134fc:	bfe00000 	.word	0xbfe00000
  413500:	3fe00000 	.word	0x3fe00000
  413504:	7fefffff 	.word	0x7fefffff
  413508:	00417130 	.word	0x00417130
  41350c:	f3af 8000 	nop.w

00413510 <_strtol_r>:
  413510:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  413514:	4c42      	ldr	r4, [pc, #264]	; (413620 <_strtol_r+0x110>)
  413516:	b082      	sub	sp, #8
  413518:	f8d4 c000 	ldr.w	ip, [r4]
  41351c:	9001      	str	r0, [sp, #4]
  41351e:	460e      	mov	r6, r1
  413520:	e000      	b.n	413524 <_strtol_r+0x14>
  413522:	4626      	mov	r6, r4
  413524:	4634      	mov	r4, r6
  413526:	f814 5b01 	ldrb.w	r5, [r4], #1
  41352a:	eb0c 0005 	add.w	r0, ip, r5
  41352e:	7840      	ldrb	r0, [r0, #1]
  413530:	f000 0008 	and.w	r0, r0, #8
  413534:	f000 0aff 	and.w	sl, r0, #255	; 0xff
  413538:	2800      	cmp	r0, #0
  41353a:	d1f2      	bne.n	413522 <_strtol_r+0x12>
  41353c:	2d2d      	cmp	r5, #45	; 0x2d
  41353e:	d05b      	beq.n	4135f8 <_strtol_r+0xe8>
  413540:	2d2b      	cmp	r5, #43	; 0x2b
  413542:	bf04      	itt	eq
  413544:	7875      	ldrbeq	r5, [r6, #1]
  413546:	1cb4      	addeq	r4, r6, #2
  413548:	f033 0010 	bics.w	r0, r3, #16
  41354c:	d03c      	beq.n	4135c8 <_strtol_r+0xb8>
  41354e:	4699      	mov	r9, r3
  413550:	f1ba 0f00 	cmp.w	sl, #0
  413554:	bf0c      	ite	eq
  413556:	f06f 4b00 	mvneq.w	fp, #2147483648	; 0x80000000
  41355a:	f04f 4b00 	movne.w	fp, #2147483648	; 0x80000000
  41355e:	fbbb f8f9 	udiv	r8, fp, r9
  413562:	2700      	movs	r7, #0
  413564:	fb09 bb18 	mls	fp, r9, r8, fp
  413568:	4638      	mov	r0, r7
  41356a:	e00c      	b.n	413586 <_strtol_r+0x76>
  41356c:	3d30      	subs	r5, #48	; 0x30
  41356e:	42ab      	cmp	r3, r5
  413570:	dd19      	ble.n	4135a6 <_strtol_r+0x96>
  413572:	1c7e      	adds	r6, r7, #1
  413574:	d005      	beq.n	413582 <_strtol_r+0x72>
  413576:	4540      	cmp	r0, r8
  413578:	d823      	bhi.n	4135c2 <_strtol_r+0xb2>
  41357a:	d020      	beq.n	4135be <_strtol_r+0xae>
  41357c:	fb09 5000 	mla	r0, r9, r0, r5
  413580:	2701      	movs	r7, #1
  413582:	f814 5b01 	ldrb.w	r5, [r4], #1
  413586:	eb0c 0605 	add.w	r6, ip, r5
  41358a:	7876      	ldrb	r6, [r6, #1]
  41358c:	f016 0f04 	tst.w	r6, #4
  413590:	d1ec      	bne.n	41356c <_strtol_r+0x5c>
  413592:	f016 0603 	ands.w	r6, r6, #3
  413596:	d006      	beq.n	4135a6 <_strtol_r+0x96>
  413598:	2e01      	cmp	r6, #1
  41359a:	bf14      	ite	ne
  41359c:	2657      	movne	r6, #87	; 0x57
  41359e:	2637      	moveq	r6, #55	; 0x37
  4135a0:	1bad      	subs	r5, r5, r6
  4135a2:	42ab      	cmp	r3, r5
  4135a4:	dce5      	bgt.n	413572 <_strtol_r+0x62>
  4135a6:	1c7b      	adds	r3, r7, #1
  4135a8:	d015      	beq.n	4135d6 <_strtol_r+0xc6>
  4135aa:	f1ba 0f00 	cmp.w	sl, #0
  4135ae:	d121      	bne.n	4135f4 <_strtol_r+0xe4>
  4135b0:	b10a      	cbz	r2, 4135b6 <_strtol_r+0xa6>
  4135b2:	b9ef      	cbnz	r7, 4135f0 <_strtol_r+0xe0>
  4135b4:	6011      	str	r1, [r2, #0]
  4135b6:	b002      	add	sp, #8
  4135b8:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  4135bc:	4770      	bx	lr
  4135be:	455d      	cmp	r5, fp
  4135c0:	dddc      	ble.n	41357c <_strtol_r+0x6c>
  4135c2:	f04f 37ff 	mov.w	r7, #4294967295
  4135c6:	e7dc      	b.n	413582 <_strtol_r+0x72>
  4135c8:	2d30      	cmp	r5, #48	; 0x30
  4135ca:	d01a      	beq.n	413602 <_strtol_r+0xf2>
  4135cc:	2b00      	cmp	r3, #0
  4135ce:	d1be      	bne.n	41354e <_strtol_r+0x3e>
  4135d0:	230a      	movs	r3, #10
  4135d2:	4699      	mov	r9, r3
  4135d4:	e7bc      	b.n	413550 <_strtol_r+0x40>
  4135d6:	9901      	ldr	r1, [sp, #4]
  4135d8:	f1ba 0f00 	cmp.w	sl, #0
  4135dc:	f04f 0322 	mov.w	r3, #34	; 0x22
  4135e0:	bf0c      	ite	eq
  4135e2:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
  4135e6:	f04f 4000 	movne.w	r0, #2147483648	; 0x80000000
  4135ea:	600b      	str	r3, [r1, #0]
  4135ec:	2a00      	cmp	r2, #0
  4135ee:	d0e2      	beq.n	4135b6 <_strtol_r+0xa6>
  4135f0:	1e61      	subs	r1, r4, #1
  4135f2:	e7df      	b.n	4135b4 <_strtol_r+0xa4>
  4135f4:	4240      	negs	r0, r0
  4135f6:	e7db      	b.n	4135b0 <_strtol_r+0xa0>
  4135f8:	1cb4      	adds	r4, r6, #2
  4135fa:	7875      	ldrb	r5, [r6, #1]
  4135fc:	f04f 0a01 	mov.w	sl, #1
  413600:	e7a2      	b.n	413548 <_strtol_r+0x38>
  413602:	7820      	ldrb	r0, [r4, #0]
  413604:	f000 00df 	and.w	r0, r0, #223	; 0xdf
  413608:	2858      	cmp	r0, #88	; 0x58
  41360a:	d003      	beq.n	413614 <_strtol_r+0x104>
  41360c:	2b00      	cmp	r3, #0
  41360e:	d19e      	bne.n	41354e <_strtol_r+0x3e>
  413610:	2308      	movs	r3, #8
  413612:	e79c      	b.n	41354e <_strtol_r+0x3e>
  413614:	2310      	movs	r3, #16
  413616:	7865      	ldrb	r5, [r4, #1]
  413618:	4699      	mov	r9, r3
  41361a:	3402      	adds	r4, #2
  41361c:	e798      	b.n	413550 <_strtol_r+0x40>
  41361e:	bf00      	nop
  413620:	20000f44 	.word	0x20000f44

00413624 <_strtoll_r>:
  413624:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  413628:	4c64      	ldr	r4, [pc, #400]	; (4137bc <_strtoll_r+0x198>)
  41362a:	b087      	sub	sp, #28
  41362c:	4694      	mov	ip, r2
  41362e:	9104      	str	r1, [sp, #16]
  413630:	f8d4 8000 	ldr.w	r8, [r4]
  413634:	9005      	str	r0, [sp, #20]
  413636:	4699      	mov	r9, r3
  413638:	460a      	mov	r2, r1
  41363a:	e000      	b.n	41363e <_strtoll_r+0x1a>
  41363c:	4632      	mov	r2, r6
  41363e:	4616      	mov	r6, r2
  413640:	f816 7b01 	ldrb.w	r7, [r6], #1
  413644:	eb08 0307 	add.w	r3, r8, r7
  413648:	785b      	ldrb	r3, [r3, #1]
  41364a:	f003 0308 	and.w	r3, r3, #8
  41364e:	f003 01ff 	and.w	r1, r3, #255	; 0xff
  413652:	2b00      	cmp	r3, #0
  413654:	d1f2      	bne.n	41363c <_strtoll_r+0x18>
  413656:	2f2d      	cmp	r7, #45	; 0x2d
  413658:	f000 808d 	beq.w	413776 <_strtoll_r+0x152>
  41365c:	2f2b      	cmp	r7, #43	; 0x2b
  41365e:	bf08      	it	eq
  413660:	7857      	ldrbeq	r7, [r2, #1]
  413662:	9102      	str	r1, [sp, #8]
  413664:	bf08      	it	eq
  413666:	1c96      	addeq	r6, r2, #2
  413668:	f039 0110 	bics.w	r1, r9, #16
  41366c:	d05e      	beq.n	41372c <_strtoll_r+0x108>
  41366e:	46ca      	mov	sl, r9
  413670:	ea4f 7be9 	mov.w	fp, r9, asr #31
  413674:	9c02      	ldr	r4, [sp, #8]
  413676:	2c00      	cmp	r4, #0
  413678:	d066      	beq.n	413748 <_strtoll_r+0x124>
  41367a:	2400      	movs	r4, #0
  41367c:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
  413680:	4620      	mov	r0, r4
  413682:	4629      	mov	r1, r5
  413684:	4652      	mov	r2, sl
  413686:	465b      	mov	r3, fp
  413688:	f8cd c004 	str.w	ip, [sp, #4]
  41368c:	f7f7 ff8e 	bl	40b5ac <__aeabi_uldivmod>
  413690:	4620      	mov	r0, r4
  413692:	9203      	str	r2, [sp, #12]
  413694:	465b      	mov	r3, fp
  413696:	4652      	mov	r2, sl
  413698:	4629      	mov	r1, r5
  41369a:	f7f7 ff87 	bl	40b5ac <__aeabi_uldivmod>
  41369e:	2400      	movs	r4, #0
  4136a0:	2200      	movs	r2, #0
  4136a2:	2300      	movs	r3, #0
  4136a4:	f8dd c004 	ldr.w	ip, [sp, #4]
  4136a8:	e019      	b.n	4136de <_strtoll_r+0xba>
  4136aa:	3f30      	subs	r7, #48	; 0x30
  4136ac:	45b9      	cmp	r9, r7
  4136ae:	dd26      	ble.n	4136fe <_strtoll_r+0xda>
  4136b0:	1c65      	adds	r5, r4, #1
  4136b2:	d012      	beq.n	4136da <_strtoll_r+0xb6>
  4136b4:	4299      	cmp	r1, r3
  4136b6:	bf08      	it	eq
  4136b8:	4290      	cmpeq	r0, r2
  4136ba:	d334      	bcc.n	413726 <_strtoll_r+0x102>
  4136bc:	428b      	cmp	r3, r1
  4136be:	bf08      	it	eq
  4136c0:	4282      	cmpeq	r2, r0
  4136c2:	d02d      	beq.n	413720 <_strtoll_r+0xfc>
  4136c4:	fb02 f40b 	mul.w	r4, r2, fp
  4136c8:	fb0a 4403 	mla	r4, sl, r3, r4
  4136cc:	fba2 230a 	umull	r2, r3, r2, sl
  4136d0:	4423      	add	r3, r4
  4136d2:	19d2      	adds	r2, r2, r7
  4136d4:	eb43 73e7 	adc.w	r3, r3, r7, asr #31
  4136d8:	2401      	movs	r4, #1
  4136da:	f816 7b01 	ldrb.w	r7, [r6], #1
  4136de:	eb08 0507 	add.w	r5, r8, r7
  4136e2:	786d      	ldrb	r5, [r5, #1]
  4136e4:	f015 0f04 	tst.w	r5, #4
  4136e8:	d1df      	bne.n	4136aa <_strtoll_r+0x86>
  4136ea:	f015 0503 	ands.w	r5, r5, #3
  4136ee:	d006      	beq.n	4136fe <_strtoll_r+0xda>
  4136f0:	2d01      	cmp	r5, #1
  4136f2:	bf14      	ite	ne
  4136f4:	2557      	movne	r5, #87	; 0x57
  4136f6:	2537      	moveq	r5, #55	; 0x37
  4136f8:	1b7f      	subs	r7, r7, r5
  4136fa:	45b9      	cmp	r9, r7
  4136fc:	dcd8      	bgt.n	4136b0 <_strtoll_r+0x8c>
  4136fe:	1c61      	adds	r1, r4, #1
  413700:	d027      	beq.n	413752 <_strtoll_r+0x12e>
  413702:	9902      	ldr	r1, [sp, #8]
  413704:	2900      	cmp	r1, #0
  413706:	d132      	bne.n	41376e <_strtoll_r+0x14a>
  413708:	4610      	mov	r0, r2
  41370a:	4619      	mov	r1, r3
  41370c:	f1bc 0f00 	cmp.w	ip, #0
  413710:	d003      	beq.n	41371a <_strtoll_r+0xf6>
  413712:	bb54      	cbnz	r4, 41376a <_strtoll_r+0x146>
  413714:	9e04      	ldr	r6, [sp, #16]
  413716:	f8cc 6000 	str.w	r6, [ip]
  41371a:	b007      	add	sp, #28
  41371c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  413720:	9c03      	ldr	r4, [sp, #12]
  413722:	42a7      	cmp	r7, r4
  413724:	ddce      	ble.n	4136c4 <_strtoll_r+0xa0>
  413726:	f04f 34ff 	mov.w	r4, #4294967295
  41372a:	e7d6      	b.n	4136da <_strtoll_r+0xb6>
  41372c:	2f30      	cmp	r7, #48	; 0x30
  41372e:	d027      	beq.n	413780 <_strtoll_r+0x15c>
  413730:	f1b9 0f00 	cmp.w	r9, #0
  413734:	d19b      	bne.n	41366e <_strtoll_r+0x4a>
  413736:	9c02      	ldr	r4, [sp, #8]
  413738:	f04f 0a0a 	mov.w	sl, #10
  41373c:	f04f 0b00 	mov.w	fp, #0
  413740:	f04f 090a 	mov.w	r9, #10
  413744:	2c00      	cmp	r4, #0
  413746:	d198      	bne.n	41367a <_strtoll_r+0x56>
  413748:	f04f 34ff 	mov.w	r4, #4294967295
  41374c:	f06f 4500 	mvn.w	r5, #2147483648	; 0x80000000
  413750:	e796      	b.n	413680 <_strtoll_r+0x5c>
  413752:	9c02      	ldr	r4, [sp, #8]
  413754:	bb24      	cbnz	r4, 4137a0 <_strtoll_r+0x17c>
  413756:	f04f 30ff 	mov.w	r0, #4294967295
  41375a:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
  41375e:	9c05      	ldr	r4, [sp, #20]
  413760:	2322      	movs	r3, #34	; 0x22
  413762:	6023      	str	r3, [r4, #0]
  413764:	f1bc 0f00 	cmp.w	ip, #0
  413768:	d0d7      	beq.n	41371a <_strtoll_r+0xf6>
  41376a:	3e01      	subs	r6, #1
  41376c:	e7d3      	b.n	413716 <_strtoll_r+0xf2>
  41376e:	4252      	negs	r2, r2
  413770:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
  413774:	e7c8      	b.n	413708 <_strtoll_r+0xe4>
  413776:	2401      	movs	r4, #1
  413778:	1c96      	adds	r6, r2, #2
  41377a:	7857      	ldrb	r7, [r2, #1]
  41377c:	9402      	str	r4, [sp, #8]
  41377e:	e773      	b.n	413668 <_strtoll_r+0x44>
  413780:	7833      	ldrb	r3, [r6, #0]
  413782:	f003 03df 	and.w	r3, r3, #223	; 0xdf
  413786:	2b58      	cmp	r3, #88	; 0x58
  413788:	d00e      	beq.n	4137a8 <_strtoll_r+0x184>
  41378a:	f1b9 0f00 	cmp.w	r9, #0
  41378e:	f47f af6e 	bne.w	41366e <_strtoll_r+0x4a>
  413792:	f04f 0a08 	mov.w	sl, #8
  413796:	f04f 0b00 	mov.w	fp, #0
  41379a:	f04f 0908 	mov.w	r9, #8
  41379e:	e769      	b.n	413674 <_strtoll_r+0x50>
  4137a0:	2000      	movs	r0, #0
  4137a2:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
  4137a6:	e7da      	b.n	41375e <_strtoll_r+0x13a>
  4137a8:	7877      	ldrb	r7, [r6, #1]
  4137aa:	f04f 0a10 	mov.w	sl, #16
  4137ae:	f04f 0b00 	mov.w	fp, #0
  4137b2:	3602      	adds	r6, #2
  4137b4:	f04f 0910 	mov.w	r9, #16
  4137b8:	e75c      	b.n	413674 <_strtoll_r+0x50>
  4137ba:	bf00      	nop
  4137bc:	20000f44 	.word	0x20000f44

004137c0 <_strtoul_r>:
  4137c0:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  4137c4:	4c44      	ldr	r4, [pc, #272]	; (4138d8 <_strtoul_r+0x118>)
  4137c6:	b082      	sub	sp, #8
  4137c8:	f8d4 c000 	ldr.w	ip, [r4]
  4137cc:	9001      	str	r0, [sp, #4]
  4137ce:	460e      	mov	r6, r1
  4137d0:	e000      	b.n	4137d4 <_strtoul_r+0x14>
  4137d2:	4626      	mov	r6, r4
  4137d4:	4634      	mov	r4, r6
  4137d6:	f814 5b01 	ldrb.w	r5, [r4], #1
  4137da:	eb0c 0005 	add.w	r0, ip, r5
  4137de:	7840      	ldrb	r0, [r0, #1]
  4137e0:	f000 0008 	and.w	r0, r0, #8
  4137e4:	f000 07ff 	and.w	r7, r0, #255	; 0xff
  4137e8:	2800      	cmp	r0, #0
  4137ea:	d1f2      	bne.n	4137d2 <_strtoul_r+0x12>
  4137ec:	2d2d      	cmp	r5, #45	; 0x2d
  4137ee:	d057      	beq.n	4138a0 <_strtoul_r+0xe0>
  4137f0:	2d2b      	cmp	r5, #43	; 0x2b
  4137f2:	bf08      	it	eq
  4137f4:	7875      	ldrbeq	r5, [r6, #1]
  4137f6:	46ba      	mov	sl, r7
  4137f8:	bf08      	it	eq
  4137fa:	1cb4      	addeq	r4, r6, #2
  4137fc:	f033 0010 	bics.w	r0, r3, #16
  413800:	d039      	beq.n	413876 <_strtoul_r+0xb6>
  413802:	f04f 38ff 	mov.w	r8, #4294967295
  413806:	fbb8 f8f3 	udiv	r8, r8, r3
  41380a:	fb03 fb08 	mul.w	fp, r3, r8
  41380e:	ea6f 0b0b 	mvn.w	fp, fp
  413812:	4699      	mov	r9, r3
  413814:	2700      	movs	r7, #0
  413816:	4638      	mov	r0, r7
  413818:	e00c      	b.n	413834 <_strtoul_r+0x74>
  41381a:	3d30      	subs	r5, #48	; 0x30
  41381c:	42ab      	cmp	r3, r5
  41381e:	dd19      	ble.n	413854 <_strtoul_r+0x94>
  413820:	2f00      	cmp	r7, #0
  413822:	db25      	blt.n	413870 <_strtoul_r+0xb0>
  413824:	4540      	cmp	r0, r8
  413826:	d823      	bhi.n	413870 <_strtoul_r+0xb0>
  413828:	d020      	beq.n	41386c <_strtoul_r+0xac>
  41382a:	fb09 5000 	mla	r0, r9, r0, r5
  41382e:	2701      	movs	r7, #1
  413830:	f814 5b01 	ldrb.w	r5, [r4], #1
  413834:	eb0c 0605 	add.w	r6, ip, r5
  413838:	7876      	ldrb	r6, [r6, #1]
  41383a:	f016 0f04 	tst.w	r6, #4
  41383e:	d1ec      	bne.n	41381a <_strtoul_r+0x5a>
  413840:	f016 0603 	ands.w	r6, r6, #3
  413844:	d006      	beq.n	413854 <_strtoul_r+0x94>
  413846:	2e01      	cmp	r6, #1
  413848:	bf14      	ite	ne
  41384a:	2657      	movne	r6, #87	; 0x57
  41384c:	2637      	moveq	r6, #55	; 0x37
  41384e:	1bad      	subs	r5, r5, r6
  413850:	42ab      	cmp	r3, r5
  413852:	dce5      	bgt.n	413820 <_strtoul_r+0x60>
  413854:	2f00      	cmp	r7, #0
  413856:	db1d      	blt.n	413894 <_strtoul_r+0xd4>
  413858:	f1ba 0f00 	cmp.w	sl, #0
  41385c:	d118      	bne.n	413890 <_strtoul_r+0xd0>
  41385e:	b10a      	cbz	r2, 413864 <_strtoul_r+0xa4>
  413860:	b9a7      	cbnz	r7, 41388c <_strtoul_r+0xcc>
  413862:	6011      	str	r1, [r2, #0]
  413864:	b002      	add	sp, #8
  413866:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  41386a:	4770      	bx	lr
  41386c:	455d      	cmp	r5, fp
  41386e:	dddc      	ble.n	41382a <_strtoul_r+0x6a>
  413870:	f04f 37ff 	mov.w	r7, #4294967295
  413874:	e7dc      	b.n	413830 <_strtoul_r+0x70>
  413876:	2d30      	cmp	r5, #48	; 0x30
  413878:	d017      	beq.n	4138aa <_strtoul_r+0xea>
  41387a:	2b00      	cmp	r3, #0
  41387c:	d1c1      	bne.n	413802 <_strtoul_r+0x42>
  41387e:	230a      	movs	r3, #10
  413880:	4699      	mov	r9, r3
  413882:	f04f 0b05 	mov.w	fp, #5
  413886:	f8df 8054 	ldr.w	r8, [pc, #84]	; 4138dc <_strtoul_r+0x11c>
  41388a:	e7c3      	b.n	413814 <_strtoul_r+0x54>
  41388c:	1e61      	subs	r1, r4, #1
  41388e:	e7e8      	b.n	413862 <_strtoul_r+0xa2>
  413890:	4240      	negs	r0, r0
  413892:	e7e4      	b.n	41385e <_strtoul_r+0x9e>
  413894:	9801      	ldr	r0, [sp, #4]
  413896:	2322      	movs	r3, #34	; 0x22
  413898:	6003      	str	r3, [r0, #0]
  41389a:	f04f 30ff 	mov.w	r0, #4294967295
  41389e:	e7de      	b.n	41385e <_strtoul_r+0x9e>
  4138a0:	1cb4      	adds	r4, r6, #2
  4138a2:	7875      	ldrb	r5, [r6, #1]
  4138a4:	f04f 0a01 	mov.w	sl, #1
  4138a8:	e7a8      	b.n	4137fc <_strtoul_r+0x3c>
  4138aa:	7820      	ldrb	r0, [r4, #0]
  4138ac:	f000 00df 	and.w	r0, r0, #223	; 0xdf
  4138b0:	2858      	cmp	r0, #88	; 0x58
  4138b2:	d008      	beq.n	4138c6 <_strtoul_r+0x106>
  4138b4:	2b00      	cmp	r3, #0
  4138b6:	d1a4      	bne.n	413802 <_strtoul_r+0x42>
  4138b8:	2308      	movs	r3, #8
  4138ba:	4699      	mov	r9, r3
  4138bc:	f04f 0b07 	mov.w	fp, #7
  4138c0:	f06f 4860 	mvn.w	r8, #3758096384	; 0xe0000000
  4138c4:	e7a6      	b.n	413814 <_strtoul_r+0x54>
  4138c6:	2310      	movs	r3, #16
  4138c8:	7865      	ldrb	r5, [r4, #1]
  4138ca:	4699      	mov	r9, r3
  4138cc:	f04f 0b0f 	mov.w	fp, #15
  4138d0:	3402      	adds	r4, #2
  4138d2:	f06f 4870 	mvn.w	r8, #4026531840	; 0xf0000000
  4138d6:	e79d      	b.n	413814 <_strtoul_r+0x54>
  4138d8:	20000f44 	.word	0x20000f44
  4138dc:	19999999 	.word	0x19999999

004138e0 <_strtoull_r>:
  4138e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4138e4:	4c60      	ldr	r4, [pc, #384]	; (413a68 <_strtoull_r+0x188>)
  4138e6:	b085      	sub	sp, #20
  4138e8:	f8d4 8000 	ldr.w	r8, [r4]
  4138ec:	9200      	str	r2, [sp, #0]
  4138ee:	9101      	str	r1, [sp, #4]
  4138f0:	9003      	str	r0, [sp, #12]
  4138f2:	4699      	mov	r9, r3
  4138f4:	460a      	mov	r2, r1
  4138f6:	e000      	b.n	4138fa <_strtoull_r+0x1a>
  4138f8:	4632      	mov	r2, r6
  4138fa:	4616      	mov	r6, r2
  4138fc:	f816 7b01 	ldrb.w	r7, [r6], #1
  413900:	eb08 0307 	add.w	r3, r8, r7
  413904:	785b      	ldrb	r3, [r3, #1]
  413906:	f003 0308 	and.w	r3, r3, #8
  41390a:	f003 01ff 	and.w	r1, r3, #255	; 0xff
  41390e:	2b00      	cmp	r3, #0
  413910:	d1f2      	bne.n	4138f8 <_strtoull_r+0x18>
  413912:	2f2d      	cmp	r7, #45	; 0x2d
  413914:	d07d      	beq.n	413a12 <_strtoull_r+0x132>
  413916:	2f2b      	cmp	r7, #43	; 0x2b
  413918:	bf08      	it	eq
  41391a:	7857      	ldrbeq	r7, [r2, #1]
  41391c:	9102      	str	r1, [sp, #8]
  41391e:	bf08      	it	eq
  413920:	1c96      	addeq	r6, r2, #2
  413922:	f039 0210 	bics.w	r2, r9, #16
  413926:	d055      	beq.n	4139d4 <_strtoull_r+0xf4>
  413928:	ea4f 7be9 	mov.w	fp, r9, asr #31
  41392c:	464a      	mov	r2, r9
  41392e:	465b      	mov	r3, fp
  413930:	f04f 30ff 	mov.w	r0, #4294967295
  413934:	f04f 31ff 	mov.w	r1, #4294967295
  413938:	f7f7 fe38 	bl	40b5ac <__aeabi_uldivmod>
  41393c:	464a      	mov	r2, r9
  41393e:	4604      	mov	r4, r0
  413940:	460d      	mov	r5, r1
  413942:	465b      	mov	r3, fp
  413944:	f04f 30ff 	mov.w	r0, #4294967295
  413948:	f04f 31ff 	mov.w	r1, #4294967295
  41394c:	f7f7 fe2e 	bl	40b5ac <__aeabi_uldivmod>
  413950:	46ca      	mov	sl, r9
  413952:	4694      	mov	ip, r2
  413954:	2300      	movs	r3, #0
  413956:	2000      	movs	r0, #0
  413958:	2100      	movs	r1, #0
  41395a:	e019      	b.n	413990 <_strtoull_r+0xb0>
  41395c:	3f30      	subs	r7, #48	; 0x30
  41395e:	45b9      	cmp	r9, r7
  413960:	dd26      	ble.n	4139b0 <_strtoull_r+0xd0>
  413962:	2b00      	cmp	r3, #0
  413964:	db33      	blt.n	4139ce <_strtoull_r+0xee>
  413966:	428d      	cmp	r5, r1
  413968:	bf08      	it	eq
  41396a:	4284      	cmpeq	r4, r0
  41396c:	d32f      	bcc.n	4139ce <_strtoull_r+0xee>
  41396e:	42a9      	cmp	r1, r5
  413970:	bf08      	it	eq
  413972:	42a0      	cmpeq	r0, r4
  413974:	d029      	beq.n	4139ca <_strtoull_r+0xea>
  413976:	fb00 f30b 	mul.w	r3, r0, fp
  41397a:	fb0a 3301 	mla	r3, sl, r1, r3
  41397e:	fba0 010a 	umull	r0, r1, r0, sl
  413982:	4419      	add	r1, r3
  413984:	19c0      	adds	r0, r0, r7
  413986:	eb41 71e7 	adc.w	r1, r1, r7, asr #31
  41398a:	2301      	movs	r3, #1
  41398c:	f816 7b01 	ldrb.w	r7, [r6], #1
  413990:	eb08 0207 	add.w	r2, r8, r7
  413994:	7852      	ldrb	r2, [r2, #1]
  413996:	f012 0f04 	tst.w	r2, #4
  41399a:	d1df      	bne.n	41395c <_strtoull_r+0x7c>
  41399c:	f012 0203 	ands.w	r2, r2, #3
  4139a0:	d006      	beq.n	4139b0 <_strtoull_r+0xd0>
  4139a2:	2a01      	cmp	r2, #1
  4139a4:	bf14      	ite	ne
  4139a6:	2257      	movne	r2, #87	; 0x57
  4139a8:	2237      	moveq	r2, #55	; 0x37
  4139aa:	1abf      	subs	r7, r7, r2
  4139ac:	45b9      	cmp	r9, r7
  4139ae:	dcd8      	bgt.n	413962 <_strtoull_r+0x82>
  4139b0:	2b00      	cmp	r3, #0
  4139b2:	db26      	blt.n	413a02 <_strtoull_r+0x122>
  4139b4:	9a02      	ldr	r2, [sp, #8]
  4139b6:	bb02      	cbnz	r2, 4139fa <_strtoull_r+0x11a>
  4139b8:	9a00      	ldr	r2, [sp, #0]
  4139ba:	b11a      	cbz	r2, 4139c4 <_strtoull_r+0xe4>
  4139bc:	b9db      	cbnz	r3, 4139f6 <_strtoull_r+0x116>
  4139be:	9e01      	ldr	r6, [sp, #4]
  4139c0:	9b00      	ldr	r3, [sp, #0]
  4139c2:	601e      	str	r6, [r3, #0]
  4139c4:	b005      	add	sp, #20
  4139c6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4139ca:	4567      	cmp	r7, ip
  4139cc:	ddd3      	ble.n	413976 <_strtoull_r+0x96>
  4139ce:	f04f 33ff 	mov.w	r3, #4294967295
  4139d2:	e7db      	b.n	41398c <_strtoull_r+0xac>
  4139d4:	2f30      	cmp	r7, #48	; 0x30
  4139d6:	d021      	beq.n	413a1c <_strtoull_r+0x13c>
  4139d8:	f1b9 0f00 	cmp.w	r9, #0
  4139dc:	d1a4      	bne.n	413928 <_strtoull_r+0x48>
  4139de:	f04f 0c05 	mov.w	ip, #5
  4139e2:	f04f 3499 	mov.w	r4, #2576980377	; 0x99999999
  4139e6:	4d21      	ldr	r5, [pc, #132]	; (413a6c <_strtoull_r+0x18c>)
  4139e8:	f04f 0a0a 	mov.w	sl, #10
  4139ec:	f04f 0b00 	mov.w	fp, #0
  4139f0:	f04f 090a 	mov.w	r9, #10
  4139f4:	e7ae      	b.n	413954 <_strtoull_r+0x74>
  4139f6:	3e01      	subs	r6, #1
  4139f8:	e7e2      	b.n	4139c0 <_strtoull_r+0xe0>
  4139fa:	4240      	negs	r0, r0
  4139fc:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  413a00:	e7da      	b.n	4139b8 <_strtoull_r+0xd8>
  413a02:	9903      	ldr	r1, [sp, #12]
  413a04:	2222      	movs	r2, #34	; 0x22
  413a06:	600a      	str	r2, [r1, #0]
  413a08:	f04f 30ff 	mov.w	r0, #4294967295
  413a0c:	f04f 31ff 	mov.w	r1, #4294967295
  413a10:	e7d2      	b.n	4139b8 <_strtoull_r+0xd8>
  413a12:	2101      	movs	r1, #1
  413a14:	1c96      	adds	r6, r2, #2
  413a16:	7857      	ldrb	r7, [r2, #1]
  413a18:	9102      	str	r1, [sp, #8]
  413a1a:	e782      	b.n	413922 <_strtoull_r+0x42>
  413a1c:	7833      	ldrb	r3, [r6, #0]
  413a1e:	f003 03df 	and.w	r3, r3, #223	; 0xdf
  413a22:	2b58      	cmp	r3, #88	; 0x58
  413a24:	d010      	beq.n	413a48 <_strtoull_r+0x168>
  413a26:	f1b9 0f00 	cmp.w	r9, #0
  413a2a:	f47f af7d 	bne.w	413928 <_strtoull_r+0x48>
  413a2e:	f04f 0c07 	mov.w	ip, #7
  413a32:	f04f 34ff 	mov.w	r4, #4294967295
  413a36:	f06f 4560 	mvn.w	r5, #3758096384	; 0xe0000000
  413a3a:	f04f 0a08 	mov.w	sl, #8
  413a3e:	f04f 0b00 	mov.w	fp, #0
  413a42:	f04f 0908 	mov.w	r9, #8
  413a46:	e785      	b.n	413954 <_strtoull_r+0x74>
  413a48:	7877      	ldrb	r7, [r6, #1]
  413a4a:	f04f 0c0f 	mov.w	ip, #15
  413a4e:	3602      	adds	r6, #2
  413a50:	f04f 34ff 	mov.w	r4, #4294967295
  413a54:	f06f 4570 	mvn.w	r5, #4026531840	; 0xf0000000
  413a58:	f04f 0a10 	mov.w	sl, #16
  413a5c:	f04f 0b00 	mov.w	fp, #0
  413a60:	f04f 0910 	mov.w	r9, #16
  413a64:	e776      	b.n	413954 <_strtoull_r+0x74>
  413a66:	bf00      	nop
  413a68:	20000f44 	.word	0x20000f44
  413a6c:	19999999 	.word	0x19999999

00413a70 <__ssprint_r>:
  413a70:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  413a74:	6894      	ldr	r4, [r2, #8]
  413a76:	6816      	ldr	r6, [r2, #0]
  413a78:	b083      	sub	sp, #12
  413a7a:	4692      	mov	sl, r2
  413a7c:	4680      	mov	r8, r0
  413a7e:	460d      	mov	r5, r1
  413a80:	2c00      	cmp	r4, #0
  413a82:	d06f      	beq.n	413b64 <__ssprint_r+0xf4>
  413a84:	f04f 0b00 	mov.w	fp, #0
  413a88:	6808      	ldr	r0, [r1, #0]
  413a8a:	688b      	ldr	r3, [r1, #8]
  413a8c:	465c      	mov	r4, fp
  413a8e:	2c00      	cmp	r4, #0
  413a90:	d043      	beq.n	413b1a <__ssprint_r+0xaa>
  413a92:	429c      	cmp	r4, r3
  413a94:	461f      	mov	r7, r3
  413a96:	d345      	bcc.n	413b24 <__ssprint_r+0xb4>
  413a98:	89ab      	ldrh	r3, [r5, #12]
  413a9a:	f413 6f90 	tst.w	r3, #1152	; 0x480
  413a9e:	d044      	beq.n	413b2a <__ssprint_r+0xba>
  413aa0:	696f      	ldr	r7, [r5, #20]
  413aa2:	6929      	ldr	r1, [r5, #16]
  413aa4:	eb07 0747 	add.w	r7, r7, r7, lsl #1
  413aa8:	eb07 77d7 	add.w	r7, r7, r7, lsr #31
  413aac:	ebc1 0900 	rsb	r9, r1, r0
  413ab0:	1c62      	adds	r2, r4, #1
  413ab2:	107f      	asrs	r7, r7, #1
  413ab4:	444a      	add	r2, r9
  413ab6:	4297      	cmp	r7, r2
  413ab8:	bf34      	ite	cc
  413aba:	4617      	movcc	r7, r2
  413abc:	463a      	movcs	r2, r7
  413abe:	055b      	lsls	r3, r3, #21
  413ac0:	d535      	bpl.n	413b2e <__ssprint_r+0xbe>
  413ac2:	4611      	mov	r1, r2
  413ac4:	4640      	mov	r0, r8
  413ac6:	f7f8 f893 	bl	40bbf0 <_malloc_r>
  413aca:	2800      	cmp	r0, #0
  413acc:	d039      	beq.n	413b42 <__ssprint_r+0xd2>
  413ace:	6929      	ldr	r1, [r5, #16]
  413ad0:	9001      	str	r0, [sp, #4]
  413ad2:	464a      	mov	r2, r9
  413ad4:	f7f8 fb28 	bl	40c128 <memcpy>
  413ad8:	89aa      	ldrh	r2, [r5, #12]
  413ada:	9b01      	ldr	r3, [sp, #4]
  413adc:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
  413ae0:	f042 0280 	orr.w	r2, r2, #128	; 0x80
  413ae4:	81aa      	strh	r2, [r5, #12]
  413ae6:	ebc9 0207 	rsb	r2, r9, r7
  413aea:	eb03 0009 	add.w	r0, r3, r9
  413aee:	616f      	str	r7, [r5, #20]
  413af0:	612b      	str	r3, [r5, #16]
  413af2:	6028      	str	r0, [r5, #0]
  413af4:	60aa      	str	r2, [r5, #8]
  413af6:	4627      	mov	r7, r4
  413af8:	46a1      	mov	r9, r4
  413afa:	464a      	mov	r2, r9
  413afc:	4659      	mov	r1, fp
  413afe:	f7f8 fbad 	bl	40c25c <memmove>
  413b02:	f8da 2008 	ldr.w	r2, [sl, #8]
  413b06:	68ab      	ldr	r3, [r5, #8]
  413b08:	6828      	ldr	r0, [r5, #0]
  413b0a:	1bdb      	subs	r3, r3, r7
  413b0c:	4448      	add	r0, r9
  413b0e:	1b14      	subs	r4, r2, r4
  413b10:	60ab      	str	r3, [r5, #8]
  413b12:	6028      	str	r0, [r5, #0]
  413b14:	f8ca 4008 	str.w	r4, [sl, #8]
  413b18:	b324      	cbz	r4, 413b64 <__ssprint_r+0xf4>
  413b1a:	f8d6 b000 	ldr.w	fp, [r6]
  413b1e:	6874      	ldr	r4, [r6, #4]
  413b20:	3608      	adds	r6, #8
  413b22:	e7b4      	b.n	413a8e <__ssprint_r+0x1e>
  413b24:	4627      	mov	r7, r4
  413b26:	46a1      	mov	r9, r4
  413b28:	e7e7      	b.n	413afa <__ssprint_r+0x8a>
  413b2a:	46b9      	mov	r9, r7
  413b2c:	e7e5      	b.n	413afa <__ssprint_r+0x8a>
  413b2e:	4640      	mov	r0, r8
  413b30:	f7fe fae2 	bl	4120f8 <_realloc_r>
  413b34:	4603      	mov	r3, r0
  413b36:	2800      	cmp	r0, #0
  413b38:	d1d5      	bne.n	413ae6 <__ssprint_r+0x76>
  413b3a:	4640      	mov	r0, r8
  413b3c:	6929      	ldr	r1, [r5, #16]
  413b3e:	f7fd facf 	bl	4110e0 <_free_r>
  413b42:	89aa      	ldrh	r2, [r5, #12]
  413b44:	230c      	movs	r3, #12
  413b46:	f8c8 3000 	str.w	r3, [r8]
  413b4a:	f042 0240 	orr.w	r2, r2, #64	; 0x40
  413b4e:	2300      	movs	r3, #0
  413b50:	f04f 30ff 	mov.w	r0, #4294967295
  413b54:	81aa      	strh	r2, [r5, #12]
  413b56:	f8ca 3008 	str.w	r3, [sl, #8]
  413b5a:	f8ca 3004 	str.w	r3, [sl, #4]
  413b5e:	b003      	add	sp, #12
  413b60:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  413b64:	4620      	mov	r0, r4
  413b66:	f8ca 4004 	str.w	r4, [sl, #4]
  413b6a:	b003      	add	sp, #12
  413b6c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00413b70 <_sungetc_r>:
  413b70:	b538      	push	{r3, r4, r5, lr}
  413b72:	1c4b      	adds	r3, r1, #1
  413b74:	4614      	mov	r4, r2
  413b76:	d019      	beq.n	413bac <_sungetc_r+0x3c>
  413b78:	8992      	ldrh	r2, [r2, #12]
  413b7a:	6b23      	ldr	r3, [r4, #48]	; 0x30
  413b7c:	f022 0220 	bic.w	r2, r2, #32
  413b80:	b2cd      	uxtb	r5, r1
  413b82:	81a2      	strh	r2, [r4, #12]
  413b84:	b1ab      	cbz	r3, 413bb2 <_sungetc_r+0x42>
  413b86:	6862      	ldr	r2, [r4, #4]
  413b88:	6b63      	ldr	r3, [r4, #52]	; 0x34
  413b8a:	429a      	cmp	r2, r3
  413b8c:	da09      	bge.n	413ba2 <_sungetc_r+0x32>
  413b8e:	6823      	ldr	r3, [r4, #0]
  413b90:	1e5a      	subs	r2, r3, #1
  413b92:	6022      	str	r2, [r4, #0]
  413b94:	f803 5c01 	strb.w	r5, [r3, #-1]
  413b98:	6863      	ldr	r3, [r4, #4]
  413b9a:	3301      	adds	r3, #1
  413b9c:	4628      	mov	r0, r5
  413b9e:	6063      	str	r3, [r4, #4]
  413ba0:	bd38      	pop	{r3, r4, r5, pc}
  413ba2:	4621      	mov	r1, r4
  413ba4:	f000 f882 	bl	413cac <__submore>
  413ba8:	2800      	cmp	r0, #0
  413baa:	d0f0      	beq.n	413b8e <_sungetc_r+0x1e>
  413bac:	f04f 30ff 	mov.w	r0, #4294967295
  413bb0:	bd38      	pop	{r3, r4, r5, pc}
  413bb2:	6923      	ldr	r3, [r4, #16]
  413bb4:	6822      	ldr	r2, [r4, #0]
  413bb6:	b12b      	cbz	r3, 413bc4 <_sungetc_r+0x54>
  413bb8:	4293      	cmp	r3, r2
  413bba:	d203      	bcs.n	413bc4 <_sungetc_r+0x54>
  413bbc:	f812 0c01 	ldrb.w	r0, [r2, #-1]
  413bc0:	42a8      	cmp	r0, r5
  413bc2:	d00f      	beq.n	413be4 <_sungetc_r+0x74>
  413bc4:	4623      	mov	r3, r4
  413bc6:	6861      	ldr	r1, [r4, #4]
  413bc8:	63a2      	str	r2, [r4, #56]	; 0x38
  413bca:	f104 0040 	add.w	r0, r4, #64	; 0x40
  413bce:	2203      	movs	r2, #3
  413bd0:	6320      	str	r0, [r4, #48]	; 0x30
  413bd2:	6362      	str	r2, [r4, #52]	; 0x34
  413bd4:	63e1      	str	r1, [r4, #60]	; 0x3c
  413bd6:	f803 5f42 	strb.w	r5, [r3, #66]!
  413bda:	2201      	movs	r2, #1
  413bdc:	6023      	str	r3, [r4, #0]
  413bde:	4628      	mov	r0, r5
  413be0:	6062      	str	r2, [r4, #4]
  413be2:	bd38      	pop	{r3, r4, r5, pc}
  413be4:	6863      	ldr	r3, [r4, #4]
  413be6:	3a01      	subs	r2, #1
  413be8:	3301      	adds	r3, #1
  413bea:	e884 000c 	stmia.w	r4, {r2, r3}
  413bee:	bd38      	pop	{r3, r4, r5, pc}

00413bf0 <__ssrefill_r>:
  413bf0:	b510      	push	{r4, lr}
  413bf2:	460c      	mov	r4, r1
  413bf4:	6b09      	ldr	r1, [r1, #48]	; 0x30
  413bf6:	b169      	cbz	r1, 413c14 <__ssrefill_r+0x24>
  413bf8:	f104 0340 	add.w	r3, r4, #64	; 0x40
  413bfc:	4299      	cmp	r1, r3
  413bfe:	d001      	beq.n	413c04 <__ssrefill_r+0x14>
  413c00:	f7fd fa6e 	bl	4110e0 <_free_r>
  413c04:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  413c06:	6063      	str	r3, [r4, #4]
  413c08:	2000      	movs	r0, #0
  413c0a:	6320      	str	r0, [r4, #48]	; 0x30
  413c0c:	b113      	cbz	r3, 413c14 <__ssrefill_r+0x24>
  413c0e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  413c10:	6023      	str	r3, [r4, #0]
  413c12:	bd10      	pop	{r4, pc}
  413c14:	89a2      	ldrh	r2, [r4, #12]
  413c16:	6923      	ldr	r3, [r4, #16]
  413c18:	6023      	str	r3, [r4, #0]
  413c1a:	f042 0220 	orr.w	r2, r2, #32
  413c1e:	2300      	movs	r3, #0
  413c20:	81a2      	strh	r2, [r4, #12]
  413c22:	6063      	str	r3, [r4, #4]
  413c24:	f04f 30ff 	mov.w	r0, #4294967295
  413c28:	bd10      	pop	{r4, pc}
  413c2a:	bf00      	nop

00413c2c <_sfread_r>:
  413c2c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  413c30:	b083      	sub	sp, #12
  413c32:	fb02 f903 	mul.w	r9, r2, r3
  413c36:	9201      	str	r2, [sp, #4]
  413c38:	469a      	mov	sl, r3
  413c3a:	4607      	mov	r7, r0
  413c3c:	460e      	mov	r6, r1
  413c3e:	9c0c      	ldr	r4, [sp, #48]	; 0x30
  413c40:	f1b9 0f00 	cmp.w	r9, #0
  413c44:	d026      	beq.n	413c94 <_sfread_r+0x68>
  413c46:	464d      	mov	r5, r9
  413c48:	f04f 0800 	mov.w	r8, #0
  413c4c:	e00e      	b.n	413c6c <_sfread_r+0x40>
  413c4e:	f7f8 fa6b 	bl	40c128 <memcpy>
  413c52:	6822      	ldr	r2, [r4, #0]
  413c54:	f8c4 8004 	str.w	r8, [r4, #4]
  413c58:	445a      	add	r2, fp
  413c5a:	6022      	str	r2, [r4, #0]
  413c5c:	4638      	mov	r0, r7
  413c5e:	4621      	mov	r1, r4
  413c60:	445e      	add	r6, fp
  413c62:	ebcb 0505 	rsb	r5, fp, r5
  413c66:	f7ff ffc3 	bl	413bf0 <__ssrefill_r>
  413c6a:	b9b8      	cbnz	r0, 413c9c <_sfread_r+0x70>
  413c6c:	f8d4 b004 	ldr.w	fp, [r4, #4]
  413c70:	6821      	ldr	r1, [r4, #0]
  413c72:	455d      	cmp	r5, fp
  413c74:	4630      	mov	r0, r6
  413c76:	465a      	mov	r2, fp
  413c78:	d8e9      	bhi.n	413c4e <_sfread_r+0x22>
  413c7a:	462a      	mov	r2, r5
  413c7c:	f7f8 fa54 	bl	40c128 <memcpy>
  413c80:	6862      	ldr	r2, [r4, #4]
  413c82:	6823      	ldr	r3, [r4, #0]
  413c84:	1b52      	subs	r2, r2, r5
  413c86:	442b      	add	r3, r5
  413c88:	4650      	mov	r0, sl
  413c8a:	6062      	str	r2, [r4, #4]
  413c8c:	6023      	str	r3, [r4, #0]
  413c8e:	b003      	add	sp, #12
  413c90:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  413c94:	4648      	mov	r0, r9
  413c96:	b003      	add	sp, #12
  413c98:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  413c9c:	9b01      	ldr	r3, [sp, #4]
  413c9e:	ebc5 0909 	rsb	r9, r5, r9
  413ca2:	fbb9 f0f3 	udiv	r0, r9, r3
  413ca6:	b003      	add	sp, #12
  413ca8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00413cac <__submore>:
  413cac:	f101 0340 	add.w	r3, r1, #64	; 0x40
  413cb0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  413cb4:	460c      	mov	r4, r1
  413cb6:	6b09      	ldr	r1, [r1, #48]	; 0x30
  413cb8:	4299      	cmp	r1, r3
  413cba:	d014      	beq.n	413ce6 <__submore+0x3a>
  413cbc:	6b66      	ldr	r6, [r4, #52]	; 0x34
  413cbe:	0077      	lsls	r7, r6, #1
  413cc0:	463a      	mov	r2, r7
  413cc2:	f7fe fa19 	bl	4120f8 <_realloc_r>
  413cc6:	4605      	mov	r5, r0
  413cc8:	b340      	cbz	r0, 413d1c <__submore+0x70>
  413cca:	eb00 0806 	add.w	r8, r0, r6
  413cce:	4632      	mov	r2, r6
  413cd0:	4640      	mov	r0, r8
  413cd2:	4629      	mov	r1, r5
  413cd4:	f7f8 fa28 	bl	40c128 <memcpy>
  413cd8:	f8c4 8000 	str.w	r8, [r4]
  413cdc:	6325      	str	r5, [r4, #48]	; 0x30
  413cde:	6367      	str	r7, [r4, #52]	; 0x34
  413ce0:	2000      	movs	r0, #0
  413ce2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  413ce6:	f44f 6180 	mov.w	r1, #1024	; 0x400
  413cea:	f7f7 ff81 	bl	40bbf0 <_malloc_r>
  413cee:	b1a8      	cbz	r0, 413d1c <__submore+0x70>
  413cf0:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
  413cf4:	6320      	str	r0, [r4, #48]	; 0x30
  413cf6:	f44f 6280 	mov.w	r2, #1024	; 0x400
  413cfa:	6362      	str	r2, [r4, #52]	; 0x34
  413cfc:	f880 33ff 	strb.w	r3, [r0, #1023]	; 0x3ff
  413d00:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  413d04:	f880 33fe 	strb.w	r3, [r0, #1022]	; 0x3fe
  413d08:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
  413d0c:	f880 33fd 	strb.w	r3, [r0, #1021]	; 0x3fd
  413d10:	f200 30fd 	addw	r0, r0, #1021	; 0x3fd
  413d14:	6020      	str	r0, [r4, #0]
  413d16:	2000      	movs	r0, #0
  413d18:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  413d1c:	f04f 30ff 	mov.w	r0, #4294967295
  413d20:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00413d24 <__swbuf_r>:
  413d24:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  413d26:	460d      	mov	r5, r1
  413d28:	4614      	mov	r4, r2
  413d2a:	4607      	mov	r7, r0
  413d2c:	b110      	cbz	r0, 413d34 <__swbuf_r+0x10>
  413d2e:	6b83      	ldr	r3, [r0, #56]	; 0x38
  413d30:	2b00      	cmp	r3, #0
  413d32:	d048      	beq.n	413dc6 <__swbuf_r+0xa2>
  413d34:	89a2      	ldrh	r2, [r4, #12]
  413d36:	69a3      	ldr	r3, [r4, #24]
  413d38:	60a3      	str	r3, [r4, #8]
  413d3a:	b293      	uxth	r3, r2
  413d3c:	0718      	lsls	r0, r3, #28
  413d3e:	d538      	bpl.n	413db2 <__swbuf_r+0x8e>
  413d40:	6926      	ldr	r6, [r4, #16]
  413d42:	2e00      	cmp	r6, #0
  413d44:	d035      	beq.n	413db2 <__swbuf_r+0x8e>
  413d46:	0499      	lsls	r1, r3, #18
  413d48:	b2ed      	uxtb	r5, r5
  413d4a:	d515      	bpl.n	413d78 <__swbuf_r+0x54>
  413d4c:	6823      	ldr	r3, [r4, #0]
  413d4e:	6962      	ldr	r2, [r4, #20]
  413d50:	1b9e      	subs	r6, r3, r6
  413d52:	4296      	cmp	r6, r2
  413d54:	da1c      	bge.n	413d90 <__swbuf_r+0x6c>
  413d56:	3601      	adds	r6, #1
  413d58:	68a2      	ldr	r2, [r4, #8]
  413d5a:	1c59      	adds	r1, r3, #1
  413d5c:	3a01      	subs	r2, #1
  413d5e:	60a2      	str	r2, [r4, #8]
  413d60:	6021      	str	r1, [r4, #0]
  413d62:	701d      	strb	r5, [r3, #0]
  413d64:	6963      	ldr	r3, [r4, #20]
  413d66:	42b3      	cmp	r3, r6
  413d68:	d01a      	beq.n	413da0 <__swbuf_r+0x7c>
  413d6a:	89a3      	ldrh	r3, [r4, #12]
  413d6c:	07db      	lsls	r3, r3, #31
  413d6e:	d501      	bpl.n	413d74 <__swbuf_r+0x50>
  413d70:	2d0a      	cmp	r5, #10
  413d72:	d015      	beq.n	413da0 <__swbuf_r+0x7c>
  413d74:	4628      	mov	r0, r5
  413d76:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  413d78:	6e63      	ldr	r3, [r4, #100]	; 0x64
  413d7a:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
  413d7e:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
  413d82:	6663      	str	r3, [r4, #100]	; 0x64
  413d84:	6823      	ldr	r3, [r4, #0]
  413d86:	81a2      	strh	r2, [r4, #12]
  413d88:	6962      	ldr	r2, [r4, #20]
  413d8a:	1b9e      	subs	r6, r3, r6
  413d8c:	4296      	cmp	r6, r2
  413d8e:	dbe2      	blt.n	413d56 <__swbuf_r+0x32>
  413d90:	4638      	mov	r0, r7
  413d92:	4621      	mov	r1, r4
  413d94:	f7fd f846 	bl	410e24 <_fflush_r>
  413d98:	b940      	cbnz	r0, 413dac <__swbuf_r+0x88>
  413d9a:	6823      	ldr	r3, [r4, #0]
  413d9c:	2601      	movs	r6, #1
  413d9e:	e7db      	b.n	413d58 <__swbuf_r+0x34>
  413da0:	4638      	mov	r0, r7
  413da2:	4621      	mov	r1, r4
  413da4:	f7fd f83e 	bl	410e24 <_fflush_r>
  413da8:	2800      	cmp	r0, #0
  413daa:	d0e3      	beq.n	413d74 <__swbuf_r+0x50>
  413dac:	f04f 30ff 	mov.w	r0, #4294967295
  413db0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  413db2:	4638      	mov	r0, r7
  413db4:	4621      	mov	r1, r4
  413db6:	f7fb ff53 	bl	40fc60 <__swsetup_r>
  413dba:	2800      	cmp	r0, #0
  413dbc:	d1f6      	bne.n	413dac <__swbuf_r+0x88>
  413dbe:	89a2      	ldrh	r2, [r4, #12]
  413dc0:	6926      	ldr	r6, [r4, #16]
  413dc2:	b293      	uxth	r3, r2
  413dc4:	e7bf      	b.n	413d46 <__swbuf_r+0x22>
  413dc6:	f7fd f849 	bl	410e5c <__sinit>
  413dca:	e7b3      	b.n	413d34 <__swbuf_r+0x10>

00413dcc <_wcrtomb_r>:
  413dcc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  413dd0:	461e      	mov	r6, r3
  413dd2:	b086      	sub	sp, #24
  413dd4:	460c      	mov	r4, r1
  413dd6:	4605      	mov	r5, r0
  413dd8:	4617      	mov	r7, r2
  413dda:	4b0f      	ldr	r3, [pc, #60]	; (413e18 <_wcrtomb_r+0x4c>)
  413ddc:	b191      	cbz	r1, 413e04 <_wcrtomb_r+0x38>
  413dde:	f8d3 8000 	ldr.w	r8, [r3]
  413de2:	f7fd fc0b 	bl	4115fc <__locale_charset>
  413de6:	9600      	str	r6, [sp, #0]
  413de8:	4603      	mov	r3, r0
  413dea:	4621      	mov	r1, r4
  413dec:	463a      	mov	r2, r7
  413dee:	4628      	mov	r0, r5
  413df0:	47c0      	blx	r8
  413df2:	1c43      	adds	r3, r0, #1
  413df4:	d103      	bne.n	413dfe <_wcrtomb_r+0x32>
  413df6:	2200      	movs	r2, #0
  413df8:	238a      	movs	r3, #138	; 0x8a
  413dfa:	6032      	str	r2, [r6, #0]
  413dfc:	602b      	str	r3, [r5, #0]
  413dfe:	b006      	add	sp, #24
  413e00:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  413e04:	681f      	ldr	r7, [r3, #0]
  413e06:	f7fd fbf9 	bl	4115fc <__locale_charset>
  413e0a:	9600      	str	r6, [sp, #0]
  413e0c:	4603      	mov	r3, r0
  413e0e:	4622      	mov	r2, r4
  413e10:	4628      	mov	r0, r5
  413e12:	a903      	add	r1, sp, #12
  413e14:	47b8      	blx	r7
  413e16:	e7ec      	b.n	413df2 <_wcrtomb_r+0x26>
  413e18:	20000fa8 	.word	0x20000fa8

00413e1c <__ascii_wctomb>:
  413e1c:	b121      	cbz	r1, 413e28 <__ascii_wctomb+0xc>
  413e1e:	2aff      	cmp	r2, #255	; 0xff
  413e20:	d804      	bhi.n	413e2c <__ascii_wctomb+0x10>
  413e22:	700a      	strb	r2, [r1, #0]
  413e24:	2001      	movs	r0, #1
  413e26:	4770      	bx	lr
  413e28:	4608      	mov	r0, r1
  413e2a:	4770      	bx	lr
  413e2c:	238a      	movs	r3, #138	; 0x8a
  413e2e:	6003      	str	r3, [r0, #0]
  413e30:	f04f 30ff 	mov.w	r0, #4294967295
  413e34:	4770      	bx	lr
  413e36:	bf00      	nop

00413e38 <__register_exitproc>:
  413e38:	b5f0      	push	{r4, r5, r6, r7, lr}
  413e3a:	4c27      	ldr	r4, [pc, #156]	; (413ed8 <__register_exitproc+0xa0>)
  413e3c:	6826      	ldr	r6, [r4, #0]
  413e3e:	f8d6 4148 	ldr.w	r4, [r6, #328]	; 0x148
  413e42:	b085      	sub	sp, #20
  413e44:	4607      	mov	r7, r0
  413e46:	2c00      	cmp	r4, #0
  413e48:	d041      	beq.n	413ece <__register_exitproc+0x96>
  413e4a:	6865      	ldr	r5, [r4, #4]
  413e4c:	2d1f      	cmp	r5, #31
  413e4e:	dd1e      	ble.n	413e8e <__register_exitproc+0x56>
  413e50:	4822      	ldr	r0, [pc, #136]	; (413edc <__register_exitproc+0xa4>)
  413e52:	b918      	cbnz	r0, 413e5c <__register_exitproc+0x24>
  413e54:	f04f 30ff 	mov.w	r0, #4294967295
  413e58:	b005      	add	sp, #20
  413e5a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  413e5c:	f44f 70c8 	mov.w	r0, #400	; 0x190
  413e60:	9103      	str	r1, [sp, #12]
  413e62:	9202      	str	r2, [sp, #8]
  413e64:	9301      	str	r3, [sp, #4]
  413e66:	f7f7 feb3 	bl	40bbd0 <malloc>
  413e6a:	9903      	ldr	r1, [sp, #12]
  413e6c:	9a02      	ldr	r2, [sp, #8]
  413e6e:	9b01      	ldr	r3, [sp, #4]
  413e70:	4604      	mov	r4, r0
  413e72:	2800      	cmp	r0, #0
  413e74:	d0ee      	beq.n	413e54 <__register_exitproc+0x1c>
  413e76:	f8d6 5148 	ldr.w	r5, [r6, #328]	; 0x148
  413e7a:	6025      	str	r5, [r4, #0]
  413e7c:	2000      	movs	r0, #0
  413e7e:	6060      	str	r0, [r4, #4]
  413e80:	4605      	mov	r5, r0
  413e82:	f8c6 4148 	str.w	r4, [r6, #328]	; 0x148
  413e86:	f8c4 0188 	str.w	r0, [r4, #392]	; 0x188
  413e8a:	f8c4 018c 	str.w	r0, [r4, #396]	; 0x18c
  413e8e:	b93f      	cbnz	r7, 413ea0 <__register_exitproc+0x68>
  413e90:	1cab      	adds	r3, r5, #2
  413e92:	2000      	movs	r0, #0
  413e94:	3501      	adds	r5, #1
  413e96:	6065      	str	r5, [r4, #4]
  413e98:	f844 1023 	str.w	r1, [r4, r3, lsl #2]
  413e9c:	b005      	add	sp, #20
  413e9e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  413ea0:	eb04 0085 	add.w	r0, r4, r5, lsl #2
  413ea4:	f04f 0c01 	mov.w	ip, #1
  413ea8:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
  413eac:	f8d4 6188 	ldr.w	r6, [r4, #392]	; 0x188
  413eb0:	fa0c f205 	lsl.w	r2, ip, r5
  413eb4:	4316      	orrs	r6, r2
  413eb6:	2f02      	cmp	r7, #2
  413eb8:	f8c4 6188 	str.w	r6, [r4, #392]	; 0x188
  413ebc:	f8c0 3108 	str.w	r3, [r0, #264]	; 0x108
  413ec0:	d1e6      	bne.n	413e90 <__register_exitproc+0x58>
  413ec2:	f8d4 318c 	ldr.w	r3, [r4, #396]	; 0x18c
  413ec6:	431a      	orrs	r2, r3
  413ec8:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
  413ecc:	e7e0      	b.n	413e90 <__register_exitproc+0x58>
  413ece:	f506 74a6 	add.w	r4, r6, #332	; 0x14c
  413ed2:	f8c6 4148 	str.w	r4, [r6, #328]	; 0x148
  413ed6:	e7b8      	b.n	413e4a <__register_exitproc+0x12>
  413ed8:	00416e3c 	.word	0x00416e3c
  413edc:	0040bbd1 	.word	0x0040bbd1

00413ee0 <_calloc_r>:
  413ee0:	b510      	push	{r4, lr}
  413ee2:	fb02 f101 	mul.w	r1, r2, r1
  413ee6:	f7f7 fe83 	bl	40bbf0 <_malloc_r>
  413eea:	4604      	mov	r4, r0
  413eec:	b168      	cbz	r0, 413f0a <_calloc_r+0x2a>
  413eee:	f850 2c04 	ldr.w	r2, [r0, #-4]
  413ef2:	f022 0203 	bic.w	r2, r2, #3
  413ef6:	3a04      	subs	r2, #4
  413ef8:	2a24      	cmp	r2, #36	; 0x24
  413efa:	d818      	bhi.n	413f2e <_calloc_r+0x4e>
  413efc:	2a13      	cmp	r2, #19
  413efe:	d806      	bhi.n	413f0e <_calloc_r+0x2e>
  413f00:	4603      	mov	r3, r0
  413f02:	2200      	movs	r2, #0
  413f04:	601a      	str	r2, [r3, #0]
  413f06:	605a      	str	r2, [r3, #4]
  413f08:	609a      	str	r2, [r3, #8]
  413f0a:	4620      	mov	r0, r4
  413f0c:	bd10      	pop	{r4, pc}
  413f0e:	2300      	movs	r3, #0
  413f10:	2a1b      	cmp	r2, #27
  413f12:	6003      	str	r3, [r0, #0]
  413f14:	6043      	str	r3, [r0, #4]
  413f16:	d90f      	bls.n	413f38 <_calloc_r+0x58>
  413f18:	2a24      	cmp	r2, #36	; 0x24
  413f1a:	6083      	str	r3, [r0, #8]
  413f1c:	60c3      	str	r3, [r0, #12]
  413f1e:	bf05      	ittet	eq
  413f20:	6103      	streq	r3, [r0, #16]
  413f22:	6143      	streq	r3, [r0, #20]
  413f24:	f100 0310 	addne.w	r3, r0, #16
  413f28:	f100 0318 	addeq.w	r3, r0, #24
  413f2c:	e7e9      	b.n	413f02 <_calloc_r+0x22>
  413f2e:	2100      	movs	r1, #0
  413f30:	f7f8 f9f4 	bl	40c31c <memset>
  413f34:	4620      	mov	r0, r4
  413f36:	bd10      	pop	{r4, pc}
  413f38:	f100 0308 	add.w	r3, r0, #8
  413f3c:	e7e1      	b.n	413f02 <_calloc_r+0x22>
  413f3e:	bf00      	nop

00413f40 <_fclose_r>:
  413f40:	b570      	push	{r4, r5, r6, lr}
  413f42:	460c      	mov	r4, r1
  413f44:	4605      	mov	r5, r0
  413f46:	b131      	cbz	r1, 413f56 <_fclose_r+0x16>
  413f48:	b110      	cbz	r0, 413f50 <_fclose_r+0x10>
  413f4a:	6b83      	ldr	r3, [r0, #56]	; 0x38
  413f4c:	2b00      	cmp	r3, #0
  413f4e:	d02f      	beq.n	413fb0 <_fclose_r+0x70>
  413f50:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  413f54:	b90b      	cbnz	r3, 413f5a <_fclose_r+0x1a>
  413f56:	2000      	movs	r0, #0
  413f58:	bd70      	pop	{r4, r5, r6, pc}
  413f5a:	4628      	mov	r0, r5
  413f5c:	4621      	mov	r1, r4
  413f5e:	f7fc ff61 	bl	410e24 <_fflush_r>
  413f62:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  413f64:	4606      	mov	r6, r0
  413f66:	b133      	cbz	r3, 413f76 <_fclose_r+0x36>
  413f68:	4628      	mov	r0, r5
  413f6a:	69e1      	ldr	r1, [r4, #28]
  413f6c:	4798      	blx	r3
  413f6e:	2800      	cmp	r0, #0
  413f70:	bfb8      	it	lt
  413f72:	f04f 36ff 	movlt.w	r6, #4294967295
  413f76:	89a3      	ldrh	r3, [r4, #12]
  413f78:	061b      	lsls	r3, r3, #24
  413f7a:	d41c      	bmi.n	413fb6 <_fclose_r+0x76>
  413f7c:	6b21      	ldr	r1, [r4, #48]	; 0x30
  413f7e:	b141      	cbz	r1, 413f92 <_fclose_r+0x52>
  413f80:	f104 0340 	add.w	r3, r4, #64	; 0x40
  413f84:	4299      	cmp	r1, r3
  413f86:	d002      	beq.n	413f8e <_fclose_r+0x4e>
  413f88:	4628      	mov	r0, r5
  413f8a:	f7fd f8a9 	bl	4110e0 <_free_r>
  413f8e:	2300      	movs	r3, #0
  413f90:	6323      	str	r3, [r4, #48]	; 0x30
  413f92:	6c61      	ldr	r1, [r4, #68]	; 0x44
  413f94:	b121      	cbz	r1, 413fa0 <_fclose_r+0x60>
  413f96:	4628      	mov	r0, r5
  413f98:	f7fd f8a2 	bl	4110e0 <_free_r>
  413f9c:	2300      	movs	r3, #0
  413f9e:	6463      	str	r3, [r4, #68]	; 0x44
  413fa0:	f7fc ffd6 	bl	410f50 <__sfp_lock_acquire>
  413fa4:	2300      	movs	r3, #0
  413fa6:	81a3      	strh	r3, [r4, #12]
  413fa8:	f7fc ffd4 	bl	410f54 <__sfp_lock_release>
  413fac:	4630      	mov	r0, r6
  413fae:	bd70      	pop	{r4, r5, r6, pc}
  413fb0:	f7fc ff54 	bl	410e5c <__sinit>
  413fb4:	e7cc      	b.n	413f50 <_fclose_r+0x10>
  413fb6:	4628      	mov	r0, r5
  413fb8:	6921      	ldr	r1, [r4, #16]
  413fba:	f7fd f891 	bl	4110e0 <_free_r>
  413fbe:	e7dd      	b.n	413f7c <_fclose_r+0x3c>

00413fc0 <fclose>:
  413fc0:	4b02      	ldr	r3, [pc, #8]	; (413fcc <fclose+0xc>)
  413fc2:	4601      	mov	r1, r0
  413fc4:	6818      	ldr	r0, [r3, #0]
  413fc6:	f7ff bfbb 	b.w	413f40 <_fclose_r>
  413fca:	bf00      	nop
  413fcc:	20000b30 	.word	0x20000b30

00413fd0 <_fstat_r>:
  413fd0:	b538      	push	{r3, r4, r5, lr}
  413fd2:	4c08      	ldr	r4, [pc, #32]	; (413ff4 <_fstat_r+0x24>)
  413fd4:	2300      	movs	r3, #0
  413fd6:	4605      	mov	r5, r0
  413fd8:	4608      	mov	r0, r1
  413fda:	4611      	mov	r1, r2
  413fdc:	6023      	str	r3, [r4, #0]
  413fde:	f7f7 fa8f 	bl	40b500 <_fstat>
  413fe2:	1c43      	adds	r3, r0, #1
  413fe4:	d000      	beq.n	413fe8 <_fstat_r+0x18>
  413fe6:	bd38      	pop	{r3, r4, r5, pc}
  413fe8:	6823      	ldr	r3, [r4, #0]
  413fea:	2b00      	cmp	r3, #0
  413fec:	d0fb      	beq.n	413fe6 <_fstat_r+0x16>
  413fee:	602b      	str	r3, [r5, #0]
  413ff0:	bd38      	pop	{r3, r4, r5, pc}
  413ff2:	bf00      	nop
  413ff4:	2000503c 	.word	0x2000503c

00413ff8 <rshift>:
  413ff8:	6902      	ldr	r2, [r0, #16]
  413ffa:	114b      	asrs	r3, r1, #5
  413ffc:	4293      	cmp	r3, r2
  413ffe:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}
  414002:	f100 0814 	add.w	r8, r0, #20
  414006:	da28      	bge.n	41405a <rshift+0x62>
  414008:	f011 0c1f 	ands.w	ip, r1, #31
  41400c:	eb08 0282 	add.w	r2, r8, r2, lsl #2
  414010:	eb08 0783 	add.w	r7, r8, r3, lsl #2
  414014:	d028      	beq.n	414068 <rshift+0x70>
  414016:	f858 4023 	ldr.w	r4, [r8, r3, lsl #2]
  41401a:	1d3b      	adds	r3, r7, #4
  41401c:	429a      	cmp	r2, r3
  41401e:	fa24 f40c 	lsr.w	r4, r4, ip
  414022:	f1cc 0120 	rsb	r1, ip, #32
  414026:	d935      	bls.n	414094 <rshift+0x9c>
  414028:	4645      	mov	r5, r8
  41402a:	681e      	ldr	r6, [r3, #0]
  41402c:	408e      	lsls	r6, r1
  41402e:	4334      	orrs	r4, r6
  414030:	f845 4b04 	str.w	r4, [r5], #4
  414034:	f853 4b04 	ldr.w	r4, [r3], #4
  414038:	4293      	cmp	r3, r2
  41403a:	fa24 f40c 	lsr.w	r4, r4, ip
  41403e:	d3f4      	bcc.n	41402a <rshift+0x32>
  414040:	1bd3      	subs	r3, r2, r7
  414042:	3b05      	subs	r3, #5
  414044:	f023 0303 	bic.w	r3, r3, #3
  414048:	3304      	adds	r3, #4
  41404a:	4443      	add	r3, r8
  41404c:	601c      	str	r4, [r3, #0]
  41404e:	b104      	cbz	r4, 414052 <rshift+0x5a>
  414050:	3304      	adds	r3, #4
  414052:	ebc8 0303 	rsb	r3, r8, r3
  414056:	109b      	asrs	r3, r3, #2
  414058:	e016      	b.n	414088 <rshift+0x90>
  41405a:	2300      	movs	r3, #0
  41405c:	6103      	str	r3, [r0, #16]
  41405e:	2300      	movs	r3, #0
  414060:	6143      	str	r3, [r0, #20]
  414062:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
  414066:	4770      	bx	lr
  414068:	42ba      	cmp	r2, r7
  41406a:	d9f6      	bls.n	41405a <rshift+0x62>
  41406c:	4641      	mov	r1, r8
  41406e:	463b      	mov	r3, r7
  414070:	f853 4b04 	ldr.w	r4, [r3], #4
  414074:	f841 4b04 	str.w	r4, [r1], #4
  414078:	429a      	cmp	r2, r3
  41407a:	d8f9      	bhi.n	414070 <rshift+0x78>
  41407c:	43fb      	mvns	r3, r7
  41407e:	4413      	add	r3, r2
  414080:	f023 0303 	bic.w	r3, r3, #3
  414084:	3304      	adds	r3, #4
  414086:	109b      	asrs	r3, r3, #2
  414088:	6103      	str	r3, [r0, #16]
  41408a:	2b00      	cmp	r3, #0
  41408c:	d0e7      	beq.n	41405e <rshift+0x66>
  41408e:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
  414092:	4770      	bx	lr
  414094:	4643      	mov	r3, r8
  414096:	e7d9      	b.n	41404c <rshift+0x54>

00414098 <__gethex>:
  414098:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  41409c:	b08b      	sub	sp, #44	; 0x2c
  41409e:	4688      	mov	r8, r1
  4140a0:	9206      	str	r2, [sp, #24]
  4140a2:	9309      	str	r3, [sp, #36]	; 0x24
  4140a4:	9007      	str	r0, [sp, #28]
  4140a6:	f7fd fab3 	bl	411610 <_localeconv_r>
  4140aa:	6800      	ldr	r0, [r0, #0]
  4140ac:	9002      	str	r0, [sp, #8]
  4140ae:	f7f8 fc79 	bl	40c9a4 <strlen>
  4140b2:	f8d8 3000 	ldr.w	r3, [r8]
  4140b6:	9902      	ldr	r1, [sp, #8]
  4140b8:	789a      	ldrb	r2, [r3, #2]
  4140ba:	9003      	str	r0, [sp, #12]
  4140bc:	4401      	add	r1, r0
  4140be:	2a30      	cmp	r2, #48	; 0x30
  4140c0:	f811 ac01 	ldrb.w	sl, [r1, #-1]
  4140c4:	f103 0502 	add.w	r5, r3, #2
  4140c8:	f040 81a6 	bne.w	414418 <__gethex+0x380>
  4140cc:	3303      	adds	r3, #3
  4140ce:	2700      	movs	r7, #0
  4140d0:	461d      	mov	r5, r3
  4140d2:	f813 2b01 	ldrb.w	r2, [r3], #1
  4140d6:	2a30      	cmp	r2, #48	; 0x30
  4140d8:	f107 0701 	add.w	r7, r7, #1
  4140dc:	d0f8      	beq.n	4140d0 <__gethex+0x38>
  4140de:	4eb1      	ldr	r6, [pc, #708]	; (4143a4 <__gethex+0x30c>)
  4140e0:	5cb4      	ldrb	r4, [r6, r2]
  4140e2:	2c00      	cmp	r4, #0
  4140e4:	f000 80f4 	beq.w	4142d0 <__gethex+0x238>
  4140e8:	782b      	ldrb	r3, [r5, #0]
  4140ea:	f04f 0900 	mov.w	r9, #0
  4140ee:	5cf3      	ldrb	r3, [r6, r3]
  4140f0:	46cb      	mov	fp, r9
  4140f2:	2b00      	cmp	r3, #0
  4140f4:	f000 8198 	beq.w	414428 <__gethex+0x390>
  4140f8:	1c6b      	adds	r3, r5, #1
  4140fa:	461c      	mov	r4, r3
  4140fc:	3301      	adds	r3, #1
  4140fe:	7822      	ldrb	r2, [r4, #0]
  414100:	5cb2      	ldrb	r2, [r6, r2]
  414102:	2a00      	cmp	r2, #0
  414104:	d1f9      	bne.n	4140fa <__gethex+0x62>
  414106:	4620      	mov	r0, r4
  414108:	9902      	ldr	r1, [sp, #8]
  41410a:	9a03      	ldr	r2, [sp, #12]
  41410c:	f7f8 fcac 	bl	40ca68 <strncmp>
  414110:	b1e0      	cbz	r0, 41414c <__gethex+0xb4>
  414112:	7823      	ldrb	r3, [r4, #0]
  414114:	f1bb 0f00 	cmp.w	fp, #0
  414118:	f000 816c 	beq.w	4143f4 <__gethex+0x35c>
  41411c:	ebc4 0b0b 	rsb	fp, r4, fp
  414120:	ea4f 028b 	mov.w	r2, fp, lsl #2
  414124:	9204      	str	r2, [sp, #16]
  414126:	2b50      	cmp	r3, #80	; 0x50
  414128:	f000 809d 	beq.w	414266 <__gethex+0x1ce>
  41412c:	2b70      	cmp	r3, #112	; 0x70
  41412e:	f000 809a 	beq.w	414266 <__gethex+0x1ce>
  414132:	4623      	mov	r3, r4
  414134:	f8c8 3000 	str.w	r3, [r8]
  414138:	f1b9 0f00 	cmp.w	r9, #0
  41413c:	d00c      	beq.n	414158 <__gethex+0xc0>
  41413e:	2f00      	cmp	r7, #0
  414140:	bf0c      	ite	eq
  414142:	2006      	moveq	r0, #6
  414144:	2000      	movne	r0, #0
  414146:	b00b      	add	sp, #44	; 0x2c
  414148:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  41414c:	f1bb 0f00 	cmp.w	fp, #0
  414150:	f000 818c 	beq.w	41446c <__gethex+0x3d4>
  414154:	7823      	ldrb	r3, [r4, #0]
  414156:	e7e1      	b.n	41411c <__gethex+0x84>
  414158:	1b63      	subs	r3, r4, r5
  41415a:	3b01      	subs	r3, #1
  41415c:	2b07      	cmp	r3, #7
  41415e:	4649      	mov	r1, r9
  414160:	dd04      	ble.n	41416c <__gethex+0xd4>
  414162:	105b      	asrs	r3, r3, #1
  414164:	2b07      	cmp	r3, #7
  414166:	f101 0101 	add.w	r1, r1, #1
  41416a:	dcfa      	bgt.n	414162 <__gethex+0xca>
  41416c:	9807      	ldr	r0, [sp, #28]
  41416e:	f7fd fb63 	bl	411838 <_Balloc>
  414172:	42a5      	cmp	r5, r4
  414174:	f100 0314 	add.w	r3, r0, #20
  414178:	9005      	str	r0, [sp, #20]
  41417a:	9308      	str	r3, [sp, #32]
  41417c:	f080 81cd 	bcs.w	41451a <__gethex+0x482>
  414180:	469b      	mov	fp, r3
  414182:	9b03      	ldr	r3, [sp, #12]
  414184:	f04f 0900 	mov.w	r9, #0
  414188:	464f      	mov	r7, r9
  41418a:	f1c3 0c01 	rsb	ip, r3, #1
  41418e:	e00e      	b.n	4141ae <__gethex+0x116>
  414190:	2f20      	cmp	r7, #32
  414192:	d05f      	beq.n	414254 <__gethex+0x1bc>
  414194:	463a      	mov	r2, r7
  414196:	3704      	adds	r7, #4
  414198:	f814 3c01 	ldrb.w	r3, [r4, #-1]
  41419c:	5cf3      	ldrb	r3, [r6, r3]
  41419e:	f003 030f 	and.w	r3, r3, #15
  4141a2:	4093      	lsls	r3, r2
  4141a4:	4545      	cmp	r5, r8
  4141a6:	ea49 0903 	orr.w	r9, r9, r3
  4141aa:	d21a      	bcs.n	4141e2 <__gethex+0x14a>
  4141ac:	4644      	mov	r4, r8
  4141ae:	f814 3c01 	ldrb.w	r3, [r4, #-1]
  4141b2:	4553      	cmp	r3, sl
  4141b4:	f104 38ff 	add.w	r8, r4, #4294967295
  4141b8:	d1ea      	bne.n	414190 <__gethex+0xf8>
  4141ba:	eb08 030c 	add.w	r3, r8, ip
  4141be:	429d      	cmp	r5, r3
  4141c0:	d8e6      	bhi.n	414190 <__gethex+0xf8>
  4141c2:	4618      	mov	r0, r3
  4141c4:	9902      	ldr	r1, [sp, #8]
  4141c6:	9a03      	ldr	r2, [sp, #12]
  4141c8:	9301      	str	r3, [sp, #4]
  4141ca:	f8cd c000 	str.w	ip, [sp]
  4141ce:	f7f8 fc4b 	bl	40ca68 <strncmp>
  4141d2:	9b01      	ldr	r3, [sp, #4]
  4141d4:	f8dd c000 	ldr.w	ip, [sp]
  4141d8:	2800      	cmp	r0, #0
  4141da:	d1d9      	bne.n	414190 <__gethex+0xf8>
  4141dc:	4698      	mov	r8, r3
  4141de:	4545      	cmp	r5, r8
  4141e0:	d3e4      	bcc.n	4141ac <__gethex+0x114>
  4141e2:	f84b 9b04 	str.w	r9, [fp], #4
  4141e6:	9b08      	ldr	r3, [sp, #32]
  4141e8:	9905      	ldr	r1, [sp, #20]
  4141ea:	ebc3 0b0b 	rsb	fp, r3, fp
  4141ee:	ea4f 03ab 	mov.w	r3, fp, asr #2
  4141f2:	4648      	mov	r0, r9
  4141f4:	610b      	str	r3, [r1, #16]
  4141f6:	015d      	lsls	r5, r3, #5
  4141f8:	f7fd fbe6 	bl	4119c8 <__hi0bits>
  4141fc:	9a06      	ldr	r2, [sp, #24]
  4141fe:	6814      	ldr	r4, [r2, #0]
  414200:	1a28      	subs	r0, r5, r0
  414202:	42a0      	cmp	r0, r4
  414204:	f300 80d0 	bgt.w	4143a8 <__gethex+0x310>
  414208:	f2c0 80f7 	blt.w	4143fa <__gethex+0x362>
  41420c:	2600      	movs	r6, #0
  41420e:	9806      	ldr	r0, [sp, #24]
  414210:	9904      	ldr	r1, [sp, #16]
  414212:	6883      	ldr	r3, [r0, #8]
  414214:	4299      	cmp	r1, r3
  414216:	f300 8092 	bgt.w	41433e <__gethex+0x2a6>
  41421a:	9806      	ldr	r0, [sp, #24]
  41421c:	9904      	ldr	r1, [sp, #16]
  41421e:	6843      	ldr	r3, [r0, #4]
  414220:	4299      	cmp	r1, r3
  414222:	f280 80a2 	bge.w	41436a <__gethex+0x2d2>
  414226:	1a5d      	subs	r5, r3, r1
  414228:	42ac      	cmp	r4, r5
  41422a:	f300 80ff 	bgt.w	41442c <__gethex+0x394>
  41422e:	68c2      	ldr	r2, [r0, #12]
  414230:	2a02      	cmp	r2, #2
  414232:	f000 8188 	beq.w	414546 <__gethex+0x4ae>
  414236:	2a03      	cmp	r2, #3
  414238:	f000 8156 	beq.w	4144e8 <__gethex+0x450>
  41423c:	2a01      	cmp	r2, #1
  41423e:	f000 8173 	beq.w	414528 <__gethex+0x490>
  414242:	9807      	ldr	r0, [sp, #28]
  414244:	9905      	ldr	r1, [sp, #20]
  414246:	f7fd fb1d 	bl	411884 <_Bfree>
  41424a:	9a14      	ldr	r2, [sp, #80]	; 0x50
  41424c:	2300      	movs	r3, #0
  41424e:	6013      	str	r3, [r2, #0]
  414250:	2050      	movs	r0, #80	; 0x50
  414252:	e778      	b.n	414146 <__gethex+0xae>
  414254:	f8cb 9000 	str.w	r9, [fp]
  414258:	f04f 0900 	mov.w	r9, #0
  41425c:	f10b 0b04 	add.w	fp, fp, #4
  414260:	464a      	mov	r2, r9
  414262:	2704      	movs	r7, #4
  414264:	e798      	b.n	414198 <__gethex+0x100>
  414266:	7863      	ldrb	r3, [r4, #1]
  414268:	2b2b      	cmp	r3, #43	; 0x2b
  41426a:	f000 8097 	beq.w	41439c <__gethex+0x304>
  41426e:	2b2d      	cmp	r3, #45	; 0x2d
  414270:	d070      	beq.n	414354 <__gethex+0x2bc>
  414272:	1c60      	adds	r0, r4, #1
  414274:	f04f 0b00 	mov.w	fp, #0
  414278:	5cf2      	ldrb	r2, [r6, r3]
  41427a:	494a      	ldr	r1, [pc, #296]	; (4143a4 <__gethex+0x30c>)
  41427c:	1e53      	subs	r3, r2, #1
  41427e:	2b18      	cmp	r3, #24
  414280:	f63f af57 	bhi.w	414132 <__gethex+0x9a>
  414284:	7843      	ldrb	r3, [r0, #1]
  414286:	5cc9      	ldrb	r1, [r1, r3]
  414288:	f101 3cff 	add.w	ip, r1, #4294967295
  41428c:	f1bc 0f18 	cmp.w	ip, #24
  414290:	f1a2 0210 	sub.w	r2, r2, #16
  414294:	f100 0301 	add.w	r3, r0, #1
  414298:	d812      	bhi.n	4142c0 <__gethex+0x228>
  41429a:	3002      	adds	r0, #2
  41429c:	f890 c000 	ldrb.w	ip, [r0]
  4142a0:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  4142a4:	eb01 0242 	add.w	r2, r1, r2, lsl #1
  4142a8:	f816 100c 	ldrb.w	r1, [r6, ip]
  4142ac:	f101 3cff 	add.w	ip, r1, #4294967295
  4142b0:	f1bc 0f18 	cmp.w	ip, #24
  4142b4:	4603      	mov	r3, r0
  4142b6:	f1a2 0210 	sub.w	r2, r2, #16
  4142ba:	f100 0001 	add.w	r0, r0, #1
  4142be:	d9ed      	bls.n	41429c <__gethex+0x204>
  4142c0:	f1bb 0f00 	cmp.w	fp, #0
  4142c4:	d000      	beq.n	4142c8 <__gethex+0x230>
  4142c6:	4252      	negs	r2, r2
  4142c8:	9804      	ldr	r0, [sp, #16]
  4142ca:	4410      	add	r0, r2
  4142cc:	9004      	str	r0, [sp, #16]
  4142ce:	e731      	b.n	414134 <__gethex+0x9c>
  4142d0:	4628      	mov	r0, r5
  4142d2:	9902      	ldr	r1, [sp, #8]
  4142d4:	9a03      	ldr	r2, [sp, #12]
  4142d6:	f7f8 fbc7 	bl	40ca68 <strncmp>
  4142da:	2800      	cmp	r0, #0
  4142dc:	d13f      	bne.n	41435e <__gethex+0x2c6>
  4142de:	9803      	ldr	r0, [sp, #12]
  4142e0:	5c2b      	ldrb	r3, [r5, r0]
  4142e2:	5cf2      	ldrb	r2, [r6, r3]
  4142e4:	4604      	mov	r4, r0
  4142e6:	442c      	add	r4, r5
  4142e8:	2a00      	cmp	r2, #0
  4142ea:	f000 8097 	beq.w	41441c <__gethex+0x384>
  4142ee:	2b30      	cmp	r3, #48	; 0x30
  4142f0:	f040 8142 	bne.w	414578 <__gethex+0x4e0>
  4142f4:	1c62      	adds	r2, r4, #1
  4142f6:	4615      	mov	r5, r2
  4142f8:	3201      	adds	r2, #1
  4142fa:	782b      	ldrb	r3, [r5, #0]
  4142fc:	2b30      	cmp	r3, #48	; 0x30
  4142fe:	d0fa      	beq.n	4142f6 <__gethex+0x25e>
  414300:	5cf3      	ldrb	r3, [r6, r3]
  414302:	f1d3 0901 	rsbs	r9, r3, #1
  414306:	46a3      	mov	fp, r4
  414308:	bf38      	it	cc
  41430a:	f04f 0900 	movcc.w	r9, #0
  41430e:	2701      	movs	r7, #1
  414310:	e6ef      	b.n	4140f2 <__gethex+0x5a>
  414312:	4447      	add	r7, r8
  414314:	f857 0c04 	ldr.w	r0, [r7, #-4]
  414318:	f7fd fb56 	bl	4119c8 <__hi0bits>
  41431c:	f1c4 0320 	rsb	r3, r4, #32
  414320:	4298      	cmp	r0, r3
  414322:	f280 80dd 	bge.w	4144e0 <__gethex+0x448>
  414326:	9805      	ldr	r0, [sp, #20]
  414328:	2101      	movs	r1, #1
  41432a:	f7ff fe65 	bl	413ff8 <rshift>
  41432e:	9806      	ldr	r0, [sp, #24]
  414330:	9904      	ldr	r1, [sp, #16]
  414332:	6883      	ldr	r3, [r0, #8]
  414334:	3101      	adds	r1, #1
  414336:	4299      	cmp	r1, r3
  414338:	9104      	str	r1, [sp, #16]
  41433a:	f340 80d1 	ble.w	4144e0 <__gethex+0x448>
  41433e:	9807      	ldr	r0, [sp, #28]
  414340:	9905      	ldr	r1, [sp, #20]
  414342:	f7fd fa9f 	bl	411884 <_Bfree>
  414346:	9a14      	ldr	r2, [sp, #80]	; 0x50
  414348:	2300      	movs	r3, #0
  41434a:	20a3      	movs	r0, #163	; 0xa3
  41434c:	6013      	str	r3, [r2, #0]
  41434e:	b00b      	add	sp, #44	; 0x2c
  414350:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  414354:	f04f 0b01 	mov.w	fp, #1
  414358:	78a3      	ldrb	r3, [r4, #2]
  41435a:	1ca0      	adds	r0, r4, #2
  41435c:	e78c      	b.n	414278 <__gethex+0x1e0>
  41435e:	9404      	str	r4, [sp, #16]
  414360:	782b      	ldrb	r3, [r5, #0]
  414362:	462c      	mov	r4, r5
  414364:	f04f 0901 	mov.w	r9, #1
  414368:	e6dd      	b.n	414126 <__gethex+0x8e>
  41436a:	2501      	movs	r5, #1
  41436c:	b166      	cbz	r6, 414388 <__gethex+0x2f0>
  41436e:	9806      	ldr	r0, [sp, #24]
  414370:	68c3      	ldr	r3, [r0, #12]
  414372:	2b02      	cmp	r3, #2
  414374:	f000 808b 	beq.w	41448e <__gethex+0x3f6>
  414378:	2b03      	cmp	r3, #3
  41437a:	f000 808c 	beq.w	414496 <__gethex+0x3fe>
  41437e:	2b01      	cmp	r3, #1
  414380:	f000 80c2 	beq.w	414508 <__gethex+0x470>
  414384:	f045 0510 	orr.w	r5, r5, #16
  414388:	9814      	ldr	r0, [sp, #80]	; 0x50
  41438a:	9b05      	ldr	r3, [sp, #20]
  41438c:	6003      	str	r3, [r0, #0]
  41438e:	9909      	ldr	r1, [sp, #36]	; 0x24
  414390:	9b04      	ldr	r3, [sp, #16]
  414392:	600b      	str	r3, [r1, #0]
  414394:	4628      	mov	r0, r5
  414396:	b00b      	add	sp, #44	; 0x2c
  414398:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  41439c:	f04f 0b00 	mov.w	fp, #0
  4143a0:	e7da      	b.n	414358 <__gethex+0x2c0>
  4143a2:	bf00      	nop
  4143a4:	00417170 	.word	0x00417170
  4143a8:	1b05      	subs	r5, r0, r4
  4143aa:	4629      	mov	r1, r5
  4143ac:	9805      	ldr	r0, [sp, #20]
  4143ae:	f7fd fe5f 	bl	412070 <__any_on>
  4143b2:	2800      	cmp	r0, #0
  4143b4:	d036      	beq.n	414424 <__gethex+0x38c>
  4143b6:	1e6b      	subs	r3, r5, #1
  4143b8:	115a      	asrs	r2, r3, #5
  4143ba:	9808      	ldr	r0, [sp, #32]
  4143bc:	f003 011f 	and.w	r1, r3, #31
  4143c0:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
  4143c4:	2601      	movs	r6, #1
  4143c6:	fa06 f101 	lsl.w	r1, r6, r1
  4143ca:	4211      	tst	r1, r2
  4143cc:	d00a      	beq.n	4143e4 <__gethex+0x34c>
  4143ce:	42b3      	cmp	r3, r6
  4143d0:	f340 80a8 	ble.w	414524 <__gethex+0x48c>
  4143d4:	9805      	ldr	r0, [sp, #20]
  4143d6:	1ea9      	subs	r1, r5, #2
  4143d8:	f7fd fe4a 	bl	412070 <__any_on>
  4143dc:	2800      	cmp	r0, #0
  4143de:	f000 80a1 	beq.w	414524 <__gethex+0x48c>
  4143e2:	2603      	movs	r6, #3
  4143e4:	9b04      	ldr	r3, [sp, #16]
  4143e6:	9805      	ldr	r0, [sp, #20]
  4143e8:	442b      	add	r3, r5
  4143ea:	4629      	mov	r1, r5
  4143ec:	9304      	str	r3, [sp, #16]
  4143ee:	f7ff fe03 	bl	413ff8 <rshift>
  4143f2:	e70c      	b.n	41420e <__gethex+0x176>
  4143f4:	f8cd b010 	str.w	fp, [sp, #16]
  4143f8:	e695      	b.n	414126 <__gethex+0x8e>
  4143fa:	1a25      	subs	r5, r4, r0
  4143fc:	9905      	ldr	r1, [sp, #20]
  4143fe:	9807      	ldr	r0, [sp, #28]
  414400:	462a      	mov	r2, r5
  414402:	f7fd fc25 	bl	411c50 <__lshift>
  414406:	9b04      	ldr	r3, [sp, #16]
  414408:	9005      	str	r0, [sp, #20]
  41440a:	1b5b      	subs	r3, r3, r5
  41440c:	9304      	str	r3, [sp, #16]
  41440e:	f100 0314 	add.w	r3, r0, #20
  414412:	9308      	str	r3, [sp, #32]
  414414:	2600      	movs	r6, #0
  414416:	e6fa      	b.n	41420e <__gethex+0x176>
  414418:	2700      	movs	r7, #0
  41441a:	e660      	b.n	4140de <__gethex+0x46>
  41441c:	9204      	str	r2, [sp, #16]
  41441e:	f04f 0901 	mov.w	r9, #1
  414422:	e680      	b.n	414126 <__gethex+0x8e>
  414424:	4606      	mov	r6, r0
  414426:	e7dd      	b.n	4143e4 <__gethex+0x34c>
  414428:	462c      	mov	r4, r5
  41442a:	e66c      	b.n	414106 <__gethex+0x6e>
  41442c:	1e6f      	subs	r7, r5, #1
  41442e:	2e00      	cmp	r6, #0
  414430:	d158      	bne.n	4144e4 <__gethex+0x44c>
  414432:	2f00      	cmp	r7, #0
  414434:	dd04      	ble.n	414440 <__gethex+0x3a8>
  414436:	9805      	ldr	r0, [sp, #20]
  414438:	4639      	mov	r1, r7
  41443a:	f7fd fe19 	bl	412070 <__any_on>
  41443e:	4606      	mov	r6, r0
  414440:	9808      	ldr	r0, [sp, #32]
  414442:	117b      	asrs	r3, r7, #5
  414444:	2201      	movs	r2, #1
  414446:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
  41444a:	9805      	ldr	r0, [sp, #20]
  41444c:	f007 071f 	and.w	r7, r7, #31
  414450:	40ba      	lsls	r2, r7
  414452:	421a      	tst	r2, r3
  414454:	4629      	mov	r1, r5
  414456:	bf18      	it	ne
  414458:	f046 0602 	orrne.w	r6, r6, #2
  41445c:	f7ff fdcc 	bl	413ff8 <rshift>
  414460:	9b06      	ldr	r3, [sp, #24]
  414462:	685b      	ldr	r3, [r3, #4]
  414464:	9304      	str	r3, [sp, #16]
  414466:	1b64      	subs	r4, r4, r5
  414468:	2502      	movs	r5, #2
  41446a:	e77f      	b.n	41436c <__gethex+0x2d4>
  41446c:	9903      	ldr	r1, [sp, #12]
  41446e:	5c63      	ldrb	r3, [r4, r1]
  414470:	5cf2      	ldrb	r2, [r6, r3]
  414472:	468b      	mov	fp, r1
  414474:	44a3      	add	fp, r4
  414476:	2a00      	cmp	r2, #0
  414478:	f000 8081 	beq.w	41457e <__gethex+0x4e6>
  41447c:	f10b 0201 	add.w	r2, fp, #1
  414480:	4614      	mov	r4, r2
  414482:	3201      	adds	r2, #1
  414484:	7823      	ldrb	r3, [r4, #0]
  414486:	5cf1      	ldrb	r1, [r6, r3]
  414488:	2900      	cmp	r1, #0
  41448a:	d1f9      	bne.n	414480 <__gethex+0x3e8>
  41448c:	e646      	b.n	41411c <__gethex+0x84>
  41448e:	9a15      	ldr	r2, [sp, #84]	; 0x54
  414490:	f1c2 0201 	rsb	r2, r2, #1
  414494:	9215      	str	r2, [sp, #84]	; 0x54
  414496:	9b15      	ldr	r3, [sp, #84]	; 0x54
  414498:	2b00      	cmp	r3, #0
  41449a:	f43f af73 	beq.w	414384 <__gethex+0x2ec>
  41449e:	9b05      	ldr	r3, [sp, #20]
  4144a0:	9f08      	ldr	r7, [sp, #32]
  4144a2:	691e      	ldr	r6, [r3, #16]
  4144a4:	9b08      	ldr	r3, [sp, #32]
  4144a6:	ea4f 0886 	mov.w	r8, r6, lsl #2
  4144aa:	4447      	add	r7, r8
  4144ac:	2000      	movs	r0, #0
  4144ae:	e003      	b.n	4144b8 <__gethex+0x420>
  4144b0:	429f      	cmp	r7, r3
  4144b2:	f843 0c04 	str.w	r0, [r3, #-4]
  4144b6:	d94a      	bls.n	41454e <__gethex+0x4b6>
  4144b8:	4619      	mov	r1, r3
  4144ba:	f853 2b04 	ldr.w	r2, [r3], #4
  4144be:	f1b2 3fff 	cmp.w	r2, #4294967295
  4144c2:	d0f5      	beq.n	4144b0 <__gethex+0x418>
  4144c4:	3201      	adds	r2, #1
  4144c6:	9f08      	ldr	r7, [sp, #32]
  4144c8:	600a      	str	r2, [r1, #0]
  4144ca:	2d02      	cmp	r5, #2
  4144cc:	d04d      	beq.n	41456a <__gethex+0x4d2>
  4144ce:	9a05      	ldr	r2, [sp, #20]
  4144d0:	6913      	ldr	r3, [r2, #16]
  4144d2:	429e      	cmp	r6, r3
  4144d4:	f6ff af27 	blt.w	414326 <__gethex+0x28e>
  4144d8:	f014 041f 	ands.w	r4, r4, #31
  4144dc:	f47f af19 	bne.w	414312 <__gethex+0x27a>
  4144e0:	2521      	movs	r5, #33	; 0x21
  4144e2:	e751      	b.n	414388 <__gethex+0x2f0>
  4144e4:	2601      	movs	r6, #1
  4144e6:	e7ab      	b.n	414440 <__gethex+0x3a8>
  4144e8:	9915      	ldr	r1, [sp, #84]	; 0x54
  4144ea:	2900      	cmp	r1, #0
  4144ec:	f43f aea9 	beq.w	414242 <__gethex+0x1aa>
  4144f0:	9809      	ldr	r0, [sp, #36]	; 0x24
  4144f2:	9914      	ldr	r1, [sp, #80]	; 0x50
  4144f4:	6003      	str	r3, [r0, #0]
  4144f6:	9b05      	ldr	r3, [sp, #20]
  4144f8:	2201      	movs	r2, #1
  4144fa:	611a      	str	r2, [r3, #16]
  4144fc:	9b08      	ldr	r3, [sp, #32]
  4144fe:	601a      	str	r2, [r3, #0]
  414500:	9b05      	ldr	r3, [sp, #20]
  414502:	600b      	str	r3, [r1, #0]
  414504:	2062      	movs	r0, #98	; 0x62
  414506:	e61e      	b.n	414146 <__gethex+0xae>
  414508:	07b2      	lsls	r2, r6, #30
  41450a:	f57f af3b 	bpl.w	414384 <__gethex+0x2ec>
  41450e:	9908      	ldr	r1, [sp, #32]
  414510:	680b      	ldr	r3, [r1, #0]
  414512:	4333      	orrs	r3, r6
  414514:	07db      	lsls	r3, r3, #31
  414516:	d4c2      	bmi.n	41449e <__gethex+0x406>
  414518:	e734      	b.n	414384 <__gethex+0x2ec>
  41451a:	f8dd b020 	ldr.w	fp, [sp, #32]
  41451e:	f04f 0900 	mov.w	r9, #0
  414522:	e65e      	b.n	4141e2 <__gethex+0x14a>
  414524:	2602      	movs	r6, #2
  414526:	e75d      	b.n	4143e4 <__gethex+0x34c>
  414528:	42a5      	cmp	r5, r4
  41452a:	f47f ae8a 	bne.w	414242 <__gethex+0x1aa>
  41452e:	2c01      	cmp	r4, #1
  414530:	ddde      	ble.n	4144f0 <__gethex+0x458>
  414532:	1e61      	subs	r1, r4, #1
  414534:	9805      	ldr	r0, [sp, #20]
  414536:	f7fd fd9b 	bl	412070 <__any_on>
  41453a:	2800      	cmp	r0, #0
  41453c:	f43f ae81 	beq.w	414242 <__gethex+0x1aa>
  414540:	9a06      	ldr	r2, [sp, #24]
  414542:	6853      	ldr	r3, [r2, #4]
  414544:	e7d4      	b.n	4144f0 <__gethex+0x458>
  414546:	9815      	ldr	r0, [sp, #84]	; 0x54
  414548:	2800      	cmp	r0, #0
  41454a:	d0d1      	beq.n	4144f0 <__gethex+0x458>
  41454c:	e679      	b.n	414242 <__gethex+0x1aa>
  41454e:	9805      	ldr	r0, [sp, #20]
  414550:	6883      	ldr	r3, [r0, #8]
  414552:	429e      	cmp	r6, r3
  414554:	da15      	bge.n	414582 <__gethex+0x4ea>
  414556:	9f08      	ldr	r7, [sp, #32]
  414558:	4633      	mov	r3, r6
  41455a:	9805      	ldr	r0, [sp, #20]
  41455c:	eb00 0283 	add.w	r2, r0, r3, lsl #2
  414560:	2101      	movs	r1, #1
  414562:	3301      	adds	r3, #1
  414564:	6103      	str	r3, [r0, #16]
  414566:	6151      	str	r1, [r2, #20]
  414568:	e7af      	b.n	4144ca <__gethex+0x432>
  41456a:	9906      	ldr	r1, [sp, #24]
  41456c:	680b      	ldr	r3, [r1, #0]
  41456e:	3b01      	subs	r3, #1
  414570:	42a3      	cmp	r3, r4
  414572:	d01c      	beq.n	4145ae <__gethex+0x516>
  414574:	2522      	movs	r5, #34	; 0x22
  414576:	e707      	b.n	414388 <__gethex+0x2f0>
  414578:	4613      	mov	r3, r2
  41457a:	4625      	mov	r5, r4
  41457c:	e6c1      	b.n	414302 <__gethex+0x26a>
  41457e:	465c      	mov	r4, fp
  414580:	e5cc      	b.n	41411c <__gethex+0x84>
  414582:	6841      	ldr	r1, [r0, #4]
  414584:	9807      	ldr	r0, [sp, #28]
  414586:	3101      	adds	r1, #1
  414588:	f7fd f956 	bl	411838 <_Balloc>
  41458c:	9905      	ldr	r1, [sp, #20]
  41458e:	690b      	ldr	r3, [r1, #16]
  414590:	1c9a      	adds	r2, r3, #2
  414592:	4607      	mov	r7, r0
  414594:	0092      	lsls	r2, r2, #2
  414596:	310c      	adds	r1, #12
  414598:	300c      	adds	r0, #12
  41459a:	f7f7 fdc5 	bl	40c128 <memcpy>
  41459e:	9807      	ldr	r0, [sp, #28]
  4145a0:	9905      	ldr	r1, [sp, #20]
  4145a2:	f7fd f96f 	bl	411884 <_Bfree>
  4145a6:	9705      	str	r7, [sp, #20]
  4145a8:	693b      	ldr	r3, [r7, #16]
  4145aa:	3714      	adds	r7, #20
  4145ac:	e7d5      	b.n	41455a <__gethex+0x4c2>
  4145ae:	1163      	asrs	r3, r4, #5
  4145b0:	2201      	movs	r2, #1
  4145b2:	f004 041f 	and.w	r4, r4, #31
  4145b6:	f857 3023 	ldr.w	r3, [r7, r3, lsl #2]
  4145ba:	40a2      	lsls	r2, r4
  4145bc:	421a      	tst	r2, r3
  4145be:	bf14      	ite	ne
  4145c0:	2521      	movne	r5, #33	; 0x21
  4145c2:	2522      	moveq	r5, #34	; 0x22
  4145c4:	e6e0      	b.n	414388 <__gethex+0x2f0>
  4145c6:	bf00      	nop

004145c8 <__hexnan>:
  4145c8:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  4145cc:	680b      	ldr	r3, [r1, #0]
  4145ce:	f8df 8188 	ldr.w	r8, [pc, #392]	; 414758 <__hexnan+0x190>
  4145d2:	b084      	sub	sp, #16
  4145d4:	4691      	mov	r9, r2
  4145d6:	115a      	asrs	r2, r3, #5
  4145d8:	eb09 0282 	add.w	r2, r9, r2, lsl #2
  4145dc:	f013 031f 	ands.w	r3, r3, #31
  4145e0:	9200      	str	r2, [sp, #0]
  4145e2:	9001      	str	r0, [sp, #4]
  4145e4:	bf1c      	itt	ne
  4145e6:	3204      	addne	r2, #4
  4145e8:	9200      	strne	r2, [sp, #0]
  4145ea:	9a01      	ldr	r2, [sp, #4]
  4145ec:	9800      	ldr	r0, [sp, #0]
  4145ee:	9303      	str	r3, [sp, #12]
  4145f0:	6811      	ldr	r1, [r2, #0]
  4145f2:	2300      	movs	r3, #0
  4145f4:	f840 3c04 	str.w	r3, [r0, #-4]
  4145f8:	469a      	mov	sl, r3
  4145fa:	461d      	mov	r5, r3
  4145fc:	461e      	mov	r6, r3
  4145fe:	784b      	ldrb	r3, [r1, #1]
  414600:	1f07      	subs	r7, r0, #4
  414602:	46bc      	mov	ip, r7
  414604:	4638      	mov	r0, r7
  414606:	9702      	str	r7, [sp, #8]
  414608:	b33b      	cbz	r3, 41465a <__hexnan+0x92>
  41460a:	f818 2003 	ldrb.w	r2, [r8, r3]
  41460e:	2a00      	cmp	r2, #0
  414610:	d148      	bne.n	4146a4 <__hexnan+0xdc>
  414612:	2b20      	cmp	r3, #32
  414614:	d866      	bhi.n	4146e4 <__hexnan+0x11c>
  414616:	42ae      	cmp	r6, r5
  414618:	dd1b      	ble.n	414652 <__hexnan+0x8a>
  41461a:	4560      	cmp	r0, ip
  41461c:	d215      	bcs.n	41464a <__hexnan+0x82>
  41461e:	f1ba 0f07 	cmp.w	sl, #7
  414622:	dc12      	bgt.n	41464a <__hexnan+0x82>
  414624:	f1ca 0a08 	rsb	sl, sl, #8
  414628:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
  41462c:	6802      	ldr	r2, [r0, #0]
  41462e:	f1ca 0b20 	rsb	fp, sl, #32
  414632:	4603      	mov	r3, r0
  414634:	685c      	ldr	r4, [r3, #4]
  414636:	fa04 f70b 	lsl.w	r7, r4, fp
  41463a:	4317      	orrs	r7, r2
  41463c:	fa24 f20a 	lsr.w	r2, r4, sl
  414640:	601f      	str	r7, [r3, #0]
  414642:	f843 2f04 	str.w	r2, [r3, #4]!
  414646:	459c      	cmp	ip, r3
  414648:	d8f4      	bhi.n	414634 <__hexnan+0x6c>
  41464a:	4548      	cmp	r0, r9
  41464c:	d841      	bhi.n	4146d2 <__hexnan+0x10a>
  41464e:	f04f 0a08 	mov.w	sl, #8
  414652:	3101      	adds	r1, #1
  414654:	784b      	ldrb	r3, [r1, #1]
  414656:	2b00      	cmp	r3, #0
  414658:	d1d7      	bne.n	41460a <__hexnan+0x42>
  41465a:	9f02      	ldr	r7, [sp, #8]
  41465c:	2e00      	cmp	r6, #0
  41465e:	d044      	beq.n	4146ea <__hexnan+0x122>
  414660:	4560      	cmp	r0, ip
  414662:	d202      	bcs.n	41466a <__hexnan+0xa2>
  414664:	f1ba 0f07 	cmp.w	sl, #7
  414668:	dd62      	ble.n	414730 <__hexnan+0x168>
  41466a:	4581      	cmp	r9, r0
  41466c:	d242      	bcs.n	4146f4 <__hexnan+0x12c>
  41466e:	464b      	mov	r3, r9
  414670:	f850 2b04 	ldr.w	r2, [r0], #4
  414674:	f843 2b04 	str.w	r2, [r3], #4
  414678:	4287      	cmp	r7, r0
  41467a:	d2f9      	bcs.n	414670 <__hexnan+0xa8>
  41467c:	2200      	movs	r2, #0
  41467e:	f843 2b04 	str.w	r2, [r3], #4
  414682:	429f      	cmp	r7, r3
  414684:	d2fb      	bcs.n	41467e <__hexnan+0xb6>
  414686:	9800      	ldr	r0, [sp, #0]
  414688:	f850 3c04 	ldr.w	r3, [r0, #-4]
  41468c:	b92b      	cbnz	r3, 41469a <__hexnan+0xd2>
  41468e:	45b9      	cmp	r9, r7
  414690:	d041      	beq.n	414716 <__hexnan+0x14e>
  414692:	f857 3d04 	ldr.w	r3, [r7, #-4]!
  414696:	2b00      	cmp	r3, #0
  414698:	d0f9      	beq.n	41468e <__hexnan+0xc6>
  41469a:	2005      	movs	r0, #5
  41469c:	b004      	add	sp, #16
  41469e:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  4146a2:	4770      	bx	lr
  4146a4:	f10a 0a01 	add.w	sl, sl, #1
  4146a8:	f1ba 0f08 	cmp.w	sl, #8
  4146ac:	f106 0601 	add.w	r6, r6, #1
  4146b0:	dc06      	bgt.n	4146c0 <__hexnan+0xf8>
  4146b2:	6803      	ldr	r3, [r0, #0]
  4146b4:	011b      	lsls	r3, r3, #4
  4146b6:	f002 020f 	and.w	r2, r2, #15
  4146ba:	431a      	orrs	r2, r3
  4146bc:	6002      	str	r2, [r0, #0]
  4146be:	e7c8      	b.n	414652 <__hexnan+0x8a>
  4146c0:	4548      	cmp	r0, r9
  4146c2:	d9c6      	bls.n	414652 <__hexnan+0x8a>
  4146c4:	2300      	movs	r3, #0
  4146c6:	f840 3c04 	str.w	r3, [r0, #-4]
  4146ca:	f04f 0a01 	mov.w	sl, #1
  4146ce:	3804      	subs	r0, #4
  4146d0:	e7f1      	b.n	4146b6 <__hexnan+0xee>
  4146d2:	2300      	movs	r3, #0
  4146d4:	f1a0 0c04 	sub.w	ip, r0, #4
  4146d8:	f840 3c04 	str.w	r3, [r0, #-4]
  4146dc:	4635      	mov	r5, r6
  4146de:	4660      	mov	r0, ip
  4146e0:	469a      	mov	sl, r3
  4146e2:	e7b6      	b.n	414652 <__hexnan+0x8a>
  4146e4:	2b29      	cmp	r3, #41	; 0x29
  4146e6:	9f02      	ldr	r7, [sp, #8]
  4146e8:	d01c      	beq.n	414724 <__hexnan+0x15c>
  4146ea:	2004      	movs	r0, #4
  4146ec:	b004      	add	sp, #16
  4146ee:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  4146f2:	4770      	bx	lr
  4146f4:	9a03      	ldr	r2, [sp, #12]
  4146f6:	2a00      	cmp	r2, #0
  4146f8:	d0c5      	beq.n	414686 <__hexnan+0xbe>
  4146fa:	9b03      	ldr	r3, [sp, #12]
  4146fc:	9800      	ldr	r0, [sp, #0]
  4146fe:	f1c3 0220 	rsb	r2, r3, #32
  414702:	f04f 31ff 	mov.w	r1, #4294967295
  414706:	f850 3c04 	ldr.w	r3, [r0, #-4]
  41470a:	fa21 f202 	lsr.w	r2, r1, r2
  41470e:	4013      	ands	r3, r2
  414710:	f840 3c04 	str.w	r3, [r0, #-4]
  414714:	e7ba      	b.n	41468c <__hexnan+0xc4>
  414716:	2301      	movs	r3, #1
  414718:	2005      	movs	r0, #5
  41471a:	603b      	str	r3, [r7, #0]
  41471c:	b004      	add	sp, #16
  41471e:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  414722:	4770      	bx	lr
  414724:	9a01      	ldr	r2, [sp, #4]
  414726:	3102      	adds	r1, #2
  414728:	6011      	str	r1, [r2, #0]
  41472a:	2e00      	cmp	r6, #0
  41472c:	d198      	bne.n	414660 <__hexnan+0x98>
  41472e:	e7dc      	b.n	4146ea <__hexnan+0x122>
  414730:	f1ca 0508 	rsb	r5, sl, #8
  414734:	00ad      	lsls	r5, r5, #2
  414736:	6802      	ldr	r2, [r0, #0]
  414738:	f1c5 0620 	rsb	r6, r5, #32
  41473c:	4603      	mov	r3, r0
  41473e:	6859      	ldr	r1, [r3, #4]
  414740:	fa01 f406 	lsl.w	r4, r1, r6
  414744:	4314      	orrs	r4, r2
  414746:	fa21 f205 	lsr.w	r2, r1, r5
  41474a:	601c      	str	r4, [r3, #0]
  41474c:	f843 2f04 	str.w	r2, [r3, #4]!
  414750:	4563      	cmp	r3, ip
  414752:	d3f4      	bcc.n	41473e <__hexnan+0x176>
  414754:	e789      	b.n	41466a <__hexnan+0xa2>
  414756:	bf00      	nop
  414758:	00417170 	.word	0x00417170

0041475c <_isatty_r>:
  41475c:	b538      	push	{r3, r4, r5, lr}
  41475e:	4c07      	ldr	r4, [pc, #28]	; (41477c <_isatty_r+0x20>)
  414760:	2300      	movs	r3, #0
  414762:	4605      	mov	r5, r0
  414764:	4608      	mov	r0, r1
  414766:	6023      	str	r3, [r4, #0]
  414768:	f7f6 fed0 	bl	40b50c <_isatty>
  41476c:	1c43      	adds	r3, r0, #1
  41476e:	d000      	beq.n	414772 <_isatty_r+0x16>
  414770:	bd38      	pop	{r3, r4, r5, pc}
  414772:	6823      	ldr	r3, [r4, #0]
  414774:	2b00      	cmp	r3, #0
  414776:	d0fb      	beq.n	414770 <_isatty_r+0x14>
  414778:	602b      	str	r3, [r5, #0]
  41477a:	bd38      	pop	{r3, r4, r5, pc}
  41477c:	2000503c 	.word	0x2000503c

00414780 <__aeabi_drsub>:
  414780:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
  414784:	e002      	b.n	41478c <__adddf3>
  414786:	bf00      	nop

00414788 <__aeabi_dsub>:
  414788:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0041478c <__adddf3>:
  41478c:	b530      	push	{r4, r5, lr}
  41478e:	ea4f 0441 	mov.w	r4, r1, lsl #1
  414792:	ea4f 0543 	mov.w	r5, r3, lsl #1
  414796:	ea94 0f05 	teq	r4, r5
  41479a:	bf08      	it	eq
  41479c:	ea90 0f02 	teqeq	r0, r2
  4147a0:	bf1f      	itttt	ne
  4147a2:	ea54 0c00 	orrsne.w	ip, r4, r0
  4147a6:	ea55 0c02 	orrsne.w	ip, r5, r2
  4147aa:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
  4147ae:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
  4147b2:	f000 80e2 	beq.w	41497a <__adddf3+0x1ee>
  4147b6:	ea4f 5454 	mov.w	r4, r4, lsr #21
  4147ba:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
  4147be:	bfb8      	it	lt
  4147c0:	426d      	neglt	r5, r5
  4147c2:	dd0c      	ble.n	4147de <__adddf3+0x52>
  4147c4:	442c      	add	r4, r5
  4147c6:	ea80 0202 	eor.w	r2, r0, r2
  4147ca:	ea81 0303 	eor.w	r3, r1, r3
  4147ce:	ea82 0000 	eor.w	r0, r2, r0
  4147d2:	ea83 0101 	eor.w	r1, r3, r1
  4147d6:	ea80 0202 	eor.w	r2, r0, r2
  4147da:	ea81 0303 	eor.w	r3, r1, r3
  4147de:	2d36      	cmp	r5, #54	; 0x36
  4147e0:	bf88      	it	hi
  4147e2:	bd30      	pophi	{r4, r5, pc}
  4147e4:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
  4147e8:	ea4f 3101 	mov.w	r1, r1, lsl #12
  4147ec:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
  4147f0:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
  4147f4:	d002      	beq.n	4147fc <__adddf3+0x70>
  4147f6:	4240      	negs	r0, r0
  4147f8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  4147fc:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
  414800:	ea4f 3303 	mov.w	r3, r3, lsl #12
  414804:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
  414808:	d002      	beq.n	414810 <__adddf3+0x84>
  41480a:	4252      	negs	r2, r2
  41480c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
  414810:	ea94 0f05 	teq	r4, r5
  414814:	f000 80a7 	beq.w	414966 <__adddf3+0x1da>
  414818:	f1a4 0401 	sub.w	r4, r4, #1
  41481c:	f1d5 0e20 	rsbs	lr, r5, #32
  414820:	db0d      	blt.n	41483e <__adddf3+0xb2>
  414822:	fa02 fc0e 	lsl.w	ip, r2, lr
  414826:	fa22 f205 	lsr.w	r2, r2, r5
  41482a:	1880      	adds	r0, r0, r2
  41482c:	f141 0100 	adc.w	r1, r1, #0
  414830:	fa03 f20e 	lsl.w	r2, r3, lr
  414834:	1880      	adds	r0, r0, r2
  414836:	fa43 f305 	asr.w	r3, r3, r5
  41483a:	4159      	adcs	r1, r3
  41483c:	e00e      	b.n	41485c <__adddf3+0xd0>
  41483e:	f1a5 0520 	sub.w	r5, r5, #32
  414842:	f10e 0e20 	add.w	lr, lr, #32
  414846:	2a01      	cmp	r2, #1
  414848:	fa03 fc0e 	lsl.w	ip, r3, lr
  41484c:	bf28      	it	cs
  41484e:	f04c 0c02 	orrcs.w	ip, ip, #2
  414852:	fa43 f305 	asr.w	r3, r3, r5
  414856:	18c0      	adds	r0, r0, r3
  414858:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
  41485c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  414860:	d507      	bpl.n	414872 <__adddf3+0xe6>
  414862:	f04f 0e00 	mov.w	lr, #0
  414866:	f1dc 0c00 	rsbs	ip, ip, #0
  41486a:	eb7e 0000 	sbcs.w	r0, lr, r0
  41486e:	eb6e 0101 	sbc.w	r1, lr, r1
  414872:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
  414876:	d31b      	bcc.n	4148b0 <__adddf3+0x124>
  414878:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
  41487c:	d30c      	bcc.n	414898 <__adddf3+0x10c>
  41487e:	0849      	lsrs	r1, r1, #1
  414880:	ea5f 0030 	movs.w	r0, r0, rrx
  414884:	ea4f 0c3c 	mov.w	ip, ip, rrx
  414888:	f104 0401 	add.w	r4, r4, #1
  41488c:	ea4f 5244 	mov.w	r2, r4, lsl #21
  414890:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
  414894:	f080 809a 	bcs.w	4149cc <__adddf3+0x240>
  414898:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
  41489c:	bf08      	it	eq
  41489e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
  4148a2:	f150 0000 	adcs.w	r0, r0, #0
  4148a6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  4148aa:	ea41 0105 	orr.w	r1, r1, r5
  4148ae:	bd30      	pop	{r4, r5, pc}
  4148b0:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
  4148b4:	4140      	adcs	r0, r0
  4148b6:	eb41 0101 	adc.w	r1, r1, r1
  4148ba:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  4148be:	f1a4 0401 	sub.w	r4, r4, #1
  4148c2:	d1e9      	bne.n	414898 <__adddf3+0x10c>
  4148c4:	f091 0f00 	teq	r1, #0
  4148c8:	bf04      	itt	eq
  4148ca:	4601      	moveq	r1, r0
  4148cc:	2000      	moveq	r0, #0
  4148ce:	fab1 f381 	clz	r3, r1
  4148d2:	bf08      	it	eq
  4148d4:	3320      	addeq	r3, #32
  4148d6:	f1a3 030b 	sub.w	r3, r3, #11
  4148da:	f1b3 0220 	subs.w	r2, r3, #32
  4148de:	da0c      	bge.n	4148fa <__adddf3+0x16e>
  4148e0:	320c      	adds	r2, #12
  4148e2:	dd08      	ble.n	4148f6 <__adddf3+0x16a>
  4148e4:	f102 0c14 	add.w	ip, r2, #20
  4148e8:	f1c2 020c 	rsb	r2, r2, #12
  4148ec:	fa01 f00c 	lsl.w	r0, r1, ip
  4148f0:	fa21 f102 	lsr.w	r1, r1, r2
  4148f4:	e00c      	b.n	414910 <__adddf3+0x184>
  4148f6:	f102 0214 	add.w	r2, r2, #20
  4148fa:	bfd8      	it	le
  4148fc:	f1c2 0c20 	rsble	ip, r2, #32
  414900:	fa01 f102 	lsl.w	r1, r1, r2
  414904:	fa20 fc0c 	lsr.w	ip, r0, ip
  414908:	bfdc      	itt	le
  41490a:	ea41 010c 	orrle.w	r1, r1, ip
  41490e:	4090      	lslle	r0, r2
  414910:	1ae4      	subs	r4, r4, r3
  414912:	bfa2      	ittt	ge
  414914:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
  414918:	4329      	orrge	r1, r5
  41491a:	bd30      	popge	{r4, r5, pc}
  41491c:	ea6f 0404 	mvn.w	r4, r4
  414920:	3c1f      	subs	r4, #31
  414922:	da1c      	bge.n	41495e <__adddf3+0x1d2>
  414924:	340c      	adds	r4, #12
  414926:	dc0e      	bgt.n	414946 <__adddf3+0x1ba>
  414928:	f104 0414 	add.w	r4, r4, #20
  41492c:	f1c4 0220 	rsb	r2, r4, #32
  414930:	fa20 f004 	lsr.w	r0, r0, r4
  414934:	fa01 f302 	lsl.w	r3, r1, r2
  414938:	ea40 0003 	orr.w	r0, r0, r3
  41493c:	fa21 f304 	lsr.w	r3, r1, r4
  414940:	ea45 0103 	orr.w	r1, r5, r3
  414944:	bd30      	pop	{r4, r5, pc}
  414946:	f1c4 040c 	rsb	r4, r4, #12
  41494a:	f1c4 0220 	rsb	r2, r4, #32
  41494e:	fa20 f002 	lsr.w	r0, r0, r2
  414952:	fa01 f304 	lsl.w	r3, r1, r4
  414956:	ea40 0003 	orr.w	r0, r0, r3
  41495a:	4629      	mov	r1, r5
  41495c:	bd30      	pop	{r4, r5, pc}
  41495e:	fa21 f004 	lsr.w	r0, r1, r4
  414962:	4629      	mov	r1, r5
  414964:	bd30      	pop	{r4, r5, pc}
  414966:	f094 0f00 	teq	r4, #0
  41496a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
  41496e:	bf06      	itte	eq
  414970:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
  414974:	3401      	addeq	r4, #1
  414976:	3d01      	subne	r5, #1
  414978:	e74e      	b.n	414818 <__adddf3+0x8c>
  41497a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
  41497e:	bf18      	it	ne
  414980:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
  414984:	d029      	beq.n	4149da <__adddf3+0x24e>
  414986:	ea94 0f05 	teq	r4, r5
  41498a:	bf08      	it	eq
  41498c:	ea90 0f02 	teqeq	r0, r2
  414990:	d005      	beq.n	41499e <__adddf3+0x212>
  414992:	ea54 0c00 	orrs.w	ip, r4, r0
  414996:	bf04      	itt	eq
  414998:	4619      	moveq	r1, r3
  41499a:	4610      	moveq	r0, r2
  41499c:	bd30      	pop	{r4, r5, pc}
  41499e:	ea91 0f03 	teq	r1, r3
  4149a2:	bf1e      	ittt	ne
  4149a4:	2100      	movne	r1, #0
  4149a6:	2000      	movne	r0, #0
  4149a8:	bd30      	popne	{r4, r5, pc}
  4149aa:	ea5f 5c54 	movs.w	ip, r4, lsr #21
  4149ae:	d105      	bne.n	4149bc <__adddf3+0x230>
  4149b0:	0040      	lsls	r0, r0, #1
  4149b2:	4149      	adcs	r1, r1
  4149b4:	bf28      	it	cs
  4149b6:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
  4149ba:	bd30      	pop	{r4, r5, pc}
  4149bc:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
  4149c0:	bf3c      	itt	cc
  4149c2:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
  4149c6:	bd30      	popcc	{r4, r5, pc}
  4149c8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  4149cc:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
  4149d0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
  4149d4:	f04f 0000 	mov.w	r0, #0
  4149d8:	bd30      	pop	{r4, r5, pc}
  4149da:	ea7f 5c64 	mvns.w	ip, r4, asr #21
  4149de:	bf1a      	itte	ne
  4149e0:	4619      	movne	r1, r3
  4149e2:	4610      	movne	r0, r2
  4149e4:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
  4149e8:	bf1c      	itt	ne
  4149ea:	460b      	movne	r3, r1
  4149ec:	4602      	movne	r2, r0
  4149ee:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
  4149f2:	bf06      	itte	eq
  4149f4:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
  4149f8:	ea91 0f03 	teqeq	r1, r3
  4149fc:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
  414a00:	bd30      	pop	{r4, r5, pc}
  414a02:	bf00      	nop

00414a04 <__aeabi_ui2d>:
  414a04:	f090 0f00 	teq	r0, #0
  414a08:	bf04      	itt	eq
  414a0a:	2100      	moveq	r1, #0
  414a0c:	4770      	bxeq	lr
  414a0e:	b530      	push	{r4, r5, lr}
  414a10:	f44f 6480 	mov.w	r4, #1024	; 0x400
  414a14:	f104 0432 	add.w	r4, r4, #50	; 0x32
  414a18:	f04f 0500 	mov.w	r5, #0
  414a1c:	f04f 0100 	mov.w	r1, #0
  414a20:	e750      	b.n	4148c4 <__adddf3+0x138>
  414a22:	bf00      	nop

00414a24 <__aeabi_i2d>:
  414a24:	f090 0f00 	teq	r0, #0
  414a28:	bf04      	itt	eq
  414a2a:	2100      	moveq	r1, #0
  414a2c:	4770      	bxeq	lr
  414a2e:	b530      	push	{r4, r5, lr}
  414a30:	f44f 6480 	mov.w	r4, #1024	; 0x400
  414a34:	f104 0432 	add.w	r4, r4, #50	; 0x32
  414a38:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
  414a3c:	bf48      	it	mi
  414a3e:	4240      	negmi	r0, r0
  414a40:	f04f 0100 	mov.w	r1, #0
  414a44:	e73e      	b.n	4148c4 <__adddf3+0x138>
  414a46:	bf00      	nop

00414a48 <__aeabi_f2d>:
  414a48:	0042      	lsls	r2, r0, #1
  414a4a:	ea4f 01e2 	mov.w	r1, r2, asr #3
  414a4e:	ea4f 0131 	mov.w	r1, r1, rrx
  414a52:	ea4f 7002 	mov.w	r0, r2, lsl #28
  414a56:	bf1f      	itttt	ne
  414a58:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
  414a5c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
  414a60:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
  414a64:	4770      	bxne	lr
  414a66:	f092 0f00 	teq	r2, #0
  414a6a:	bf14      	ite	ne
  414a6c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
  414a70:	4770      	bxeq	lr
  414a72:	b530      	push	{r4, r5, lr}
  414a74:	f44f 7460 	mov.w	r4, #896	; 0x380
  414a78:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  414a7c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
  414a80:	e720      	b.n	4148c4 <__adddf3+0x138>
  414a82:	bf00      	nop

00414a84 <__aeabi_ul2d>:
  414a84:	ea50 0201 	orrs.w	r2, r0, r1
  414a88:	bf08      	it	eq
  414a8a:	4770      	bxeq	lr
  414a8c:	b530      	push	{r4, r5, lr}
  414a8e:	f04f 0500 	mov.w	r5, #0
  414a92:	e00a      	b.n	414aaa <__aeabi_l2d+0x16>

00414a94 <__aeabi_l2d>:
  414a94:	ea50 0201 	orrs.w	r2, r0, r1
  414a98:	bf08      	it	eq
  414a9a:	4770      	bxeq	lr
  414a9c:	b530      	push	{r4, r5, lr}
  414a9e:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
  414aa2:	d502      	bpl.n	414aaa <__aeabi_l2d+0x16>
  414aa4:	4240      	negs	r0, r0
  414aa6:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  414aaa:	f44f 6480 	mov.w	r4, #1024	; 0x400
  414aae:	f104 0432 	add.w	r4, r4, #50	; 0x32
  414ab2:	ea5f 5c91 	movs.w	ip, r1, lsr #22
  414ab6:	f43f aedc 	beq.w	414872 <__adddf3+0xe6>
  414aba:	f04f 0203 	mov.w	r2, #3
  414abe:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
  414ac2:	bf18      	it	ne
  414ac4:	3203      	addne	r2, #3
  414ac6:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
  414aca:	bf18      	it	ne
  414acc:	3203      	addne	r2, #3
  414ace:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
  414ad2:	f1c2 0320 	rsb	r3, r2, #32
  414ad6:	fa00 fc03 	lsl.w	ip, r0, r3
  414ada:	fa20 f002 	lsr.w	r0, r0, r2
  414ade:	fa01 fe03 	lsl.w	lr, r1, r3
  414ae2:	ea40 000e 	orr.w	r0, r0, lr
  414ae6:	fa21 f102 	lsr.w	r1, r1, r2
  414aea:	4414      	add	r4, r2
  414aec:	e6c1      	b.n	414872 <__adddf3+0xe6>
  414aee:	bf00      	nop

00414af0 <__aeabi_dmul>:
  414af0:	b570      	push	{r4, r5, r6, lr}
  414af2:	f04f 0cff 	mov.w	ip, #255	; 0xff
  414af6:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
  414afa:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
  414afe:	bf1d      	ittte	ne
  414b00:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
  414b04:	ea94 0f0c 	teqne	r4, ip
  414b08:	ea95 0f0c 	teqne	r5, ip
  414b0c:	f000 f8de 	bleq	414ccc <__aeabi_dmul+0x1dc>
  414b10:	442c      	add	r4, r5
  414b12:	ea81 0603 	eor.w	r6, r1, r3
  414b16:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
  414b1a:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
  414b1e:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
  414b22:	bf18      	it	ne
  414b24:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
  414b28:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  414b2c:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  414b30:	d038      	beq.n	414ba4 <__aeabi_dmul+0xb4>
  414b32:	fba0 ce02 	umull	ip, lr, r0, r2
  414b36:	f04f 0500 	mov.w	r5, #0
  414b3a:	fbe1 e502 	umlal	lr, r5, r1, r2
  414b3e:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
  414b42:	fbe0 e503 	umlal	lr, r5, r0, r3
  414b46:	f04f 0600 	mov.w	r6, #0
  414b4a:	fbe1 5603 	umlal	r5, r6, r1, r3
  414b4e:	f09c 0f00 	teq	ip, #0
  414b52:	bf18      	it	ne
  414b54:	f04e 0e01 	orrne.w	lr, lr, #1
  414b58:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
  414b5c:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
  414b60:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
  414b64:	d204      	bcs.n	414b70 <__aeabi_dmul+0x80>
  414b66:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
  414b6a:	416d      	adcs	r5, r5
  414b6c:	eb46 0606 	adc.w	r6, r6, r6
  414b70:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
  414b74:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
  414b78:	ea4f 20c5 	mov.w	r0, r5, lsl #11
  414b7c:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
  414b80:	ea4f 2ece 	mov.w	lr, lr, lsl #11
  414b84:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
  414b88:	bf88      	it	hi
  414b8a:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
  414b8e:	d81e      	bhi.n	414bce <__aeabi_dmul+0xde>
  414b90:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
  414b94:	bf08      	it	eq
  414b96:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
  414b9a:	f150 0000 	adcs.w	r0, r0, #0
  414b9e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  414ba2:	bd70      	pop	{r4, r5, r6, pc}
  414ba4:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
  414ba8:	ea46 0101 	orr.w	r1, r6, r1
  414bac:	ea40 0002 	orr.w	r0, r0, r2
  414bb0:	ea81 0103 	eor.w	r1, r1, r3
  414bb4:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
  414bb8:	bfc2      	ittt	gt
  414bba:	ebd4 050c 	rsbsgt	r5, r4, ip
  414bbe:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
  414bc2:	bd70      	popgt	{r4, r5, r6, pc}
  414bc4:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  414bc8:	f04f 0e00 	mov.w	lr, #0
  414bcc:	3c01      	subs	r4, #1
  414bce:	f300 80ab 	bgt.w	414d28 <__aeabi_dmul+0x238>
  414bd2:	f114 0f36 	cmn.w	r4, #54	; 0x36
  414bd6:	bfde      	ittt	le
  414bd8:	2000      	movle	r0, #0
  414bda:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
  414bde:	bd70      	pople	{r4, r5, r6, pc}
  414be0:	f1c4 0400 	rsb	r4, r4, #0
  414be4:	3c20      	subs	r4, #32
  414be6:	da35      	bge.n	414c54 <__aeabi_dmul+0x164>
  414be8:	340c      	adds	r4, #12
  414bea:	dc1b      	bgt.n	414c24 <__aeabi_dmul+0x134>
  414bec:	f104 0414 	add.w	r4, r4, #20
  414bf0:	f1c4 0520 	rsb	r5, r4, #32
  414bf4:	fa00 f305 	lsl.w	r3, r0, r5
  414bf8:	fa20 f004 	lsr.w	r0, r0, r4
  414bfc:	fa01 f205 	lsl.w	r2, r1, r5
  414c00:	ea40 0002 	orr.w	r0, r0, r2
  414c04:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
  414c08:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
  414c0c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
  414c10:	fa21 f604 	lsr.w	r6, r1, r4
  414c14:	eb42 0106 	adc.w	r1, r2, r6
  414c18:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
  414c1c:	bf08      	it	eq
  414c1e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
  414c22:	bd70      	pop	{r4, r5, r6, pc}
  414c24:	f1c4 040c 	rsb	r4, r4, #12
  414c28:	f1c4 0520 	rsb	r5, r4, #32
  414c2c:	fa00 f304 	lsl.w	r3, r0, r4
  414c30:	fa20 f005 	lsr.w	r0, r0, r5
  414c34:	fa01 f204 	lsl.w	r2, r1, r4
  414c38:	ea40 0002 	orr.w	r0, r0, r2
  414c3c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  414c40:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
  414c44:	f141 0100 	adc.w	r1, r1, #0
  414c48:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
  414c4c:	bf08      	it	eq
  414c4e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
  414c52:	bd70      	pop	{r4, r5, r6, pc}
  414c54:	f1c4 0520 	rsb	r5, r4, #32
  414c58:	fa00 f205 	lsl.w	r2, r0, r5
  414c5c:	ea4e 0e02 	orr.w	lr, lr, r2
  414c60:	fa20 f304 	lsr.w	r3, r0, r4
  414c64:	fa01 f205 	lsl.w	r2, r1, r5
  414c68:	ea43 0302 	orr.w	r3, r3, r2
  414c6c:	fa21 f004 	lsr.w	r0, r1, r4
  414c70:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  414c74:	fa21 f204 	lsr.w	r2, r1, r4
  414c78:	ea20 0002 	bic.w	r0, r0, r2
  414c7c:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
  414c80:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
  414c84:	bf08      	it	eq
  414c86:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
  414c8a:	bd70      	pop	{r4, r5, r6, pc}
  414c8c:	f094 0f00 	teq	r4, #0
  414c90:	d10f      	bne.n	414cb2 <__aeabi_dmul+0x1c2>
  414c92:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
  414c96:	0040      	lsls	r0, r0, #1
  414c98:	eb41 0101 	adc.w	r1, r1, r1
  414c9c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  414ca0:	bf08      	it	eq
  414ca2:	3c01      	subeq	r4, #1
  414ca4:	d0f7      	beq.n	414c96 <__aeabi_dmul+0x1a6>
  414ca6:	ea41 0106 	orr.w	r1, r1, r6
  414caa:	f095 0f00 	teq	r5, #0
  414cae:	bf18      	it	ne
  414cb0:	4770      	bxne	lr
  414cb2:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
  414cb6:	0052      	lsls	r2, r2, #1
  414cb8:	eb43 0303 	adc.w	r3, r3, r3
  414cbc:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
  414cc0:	bf08      	it	eq
  414cc2:	3d01      	subeq	r5, #1
  414cc4:	d0f7      	beq.n	414cb6 <__aeabi_dmul+0x1c6>
  414cc6:	ea43 0306 	orr.w	r3, r3, r6
  414cca:	4770      	bx	lr
  414ccc:	ea94 0f0c 	teq	r4, ip
  414cd0:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
  414cd4:	bf18      	it	ne
  414cd6:	ea95 0f0c 	teqne	r5, ip
  414cda:	d00c      	beq.n	414cf6 <__aeabi_dmul+0x206>
  414cdc:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
  414ce0:	bf18      	it	ne
  414ce2:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
  414ce6:	d1d1      	bne.n	414c8c <__aeabi_dmul+0x19c>
  414ce8:	ea81 0103 	eor.w	r1, r1, r3
  414cec:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  414cf0:	f04f 0000 	mov.w	r0, #0
  414cf4:	bd70      	pop	{r4, r5, r6, pc}
  414cf6:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
  414cfa:	bf06      	itte	eq
  414cfc:	4610      	moveq	r0, r2
  414cfe:	4619      	moveq	r1, r3
  414d00:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
  414d04:	d019      	beq.n	414d3a <__aeabi_dmul+0x24a>
  414d06:	ea94 0f0c 	teq	r4, ip
  414d0a:	d102      	bne.n	414d12 <__aeabi_dmul+0x222>
  414d0c:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
  414d10:	d113      	bne.n	414d3a <__aeabi_dmul+0x24a>
  414d12:	ea95 0f0c 	teq	r5, ip
  414d16:	d105      	bne.n	414d24 <__aeabi_dmul+0x234>
  414d18:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
  414d1c:	bf1c      	itt	ne
  414d1e:	4610      	movne	r0, r2
  414d20:	4619      	movne	r1, r3
  414d22:	d10a      	bne.n	414d3a <__aeabi_dmul+0x24a>
  414d24:	ea81 0103 	eor.w	r1, r1, r3
  414d28:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
  414d2c:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
  414d30:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
  414d34:	f04f 0000 	mov.w	r0, #0
  414d38:	bd70      	pop	{r4, r5, r6, pc}
  414d3a:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
  414d3e:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
  414d42:	bd70      	pop	{r4, r5, r6, pc}

00414d44 <__aeabi_ddiv>:
  414d44:	b570      	push	{r4, r5, r6, lr}
  414d46:	f04f 0cff 	mov.w	ip, #255	; 0xff
  414d4a:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
  414d4e:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
  414d52:	bf1d      	ittte	ne
  414d54:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
  414d58:	ea94 0f0c 	teqne	r4, ip
  414d5c:	ea95 0f0c 	teqne	r5, ip
  414d60:	f000 f8a7 	bleq	414eb2 <__aeabi_ddiv+0x16e>
  414d64:	eba4 0405 	sub.w	r4, r4, r5
  414d68:	ea81 0e03 	eor.w	lr, r1, r3
  414d6c:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
  414d70:	ea4f 3101 	mov.w	r1, r1, lsl #12
  414d74:	f000 8088 	beq.w	414e88 <__aeabi_ddiv+0x144>
  414d78:	ea4f 3303 	mov.w	r3, r3, lsl #12
  414d7c:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
  414d80:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
  414d84:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
  414d88:	ea4f 2202 	mov.w	r2, r2, lsl #8
  414d8c:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
  414d90:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
  414d94:	ea4f 2600 	mov.w	r6, r0, lsl #8
  414d98:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
  414d9c:	429d      	cmp	r5, r3
  414d9e:	bf08      	it	eq
  414da0:	4296      	cmpeq	r6, r2
  414da2:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
  414da6:	f504 7440 	add.w	r4, r4, #768	; 0x300
  414daa:	d202      	bcs.n	414db2 <__aeabi_ddiv+0x6e>
  414dac:	085b      	lsrs	r3, r3, #1
  414dae:	ea4f 0232 	mov.w	r2, r2, rrx
  414db2:	1ab6      	subs	r6, r6, r2
  414db4:	eb65 0503 	sbc.w	r5, r5, r3
  414db8:	085b      	lsrs	r3, r3, #1
  414dba:	ea4f 0232 	mov.w	r2, r2, rrx
  414dbe:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
  414dc2:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
  414dc6:	ebb6 0e02 	subs.w	lr, r6, r2
  414dca:	eb75 0e03 	sbcs.w	lr, r5, r3
  414dce:	bf22      	ittt	cs
  414dd0:	1ab6      	subcs	r6, r6, r2
  414dd2:	4675      	movcs	r5, lr
  414dd4:	ea40 000c 	orrcs.w	r0, r0, ip
  414dd8:	085b      	lsrs	r3, r3, #1
  414dda:	ea4f 0232 	mov.w	r2, r2, rrx
  414dde:	ebb6 0e02 	subs.w	lr, r6, r2
  414de2:	eb75 0e03 	sbcs.w	lr, r5, r3
  414de6:	bf22      	ittt	cs
  414de8:	1ab6      	subcs	r6, r6, r2
  414dea:	4675      	movcs	r5, lr
  414dec:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
  414df0:	085b      	lsrs	r3, r3, #1
  414df2:	ea4f 0232 	mov.w	r2, r2, rrx
  414df6:	ebb6 0e02 	subs.w	lr, r6, r2
  414dfa:	eb75 0e03 	sbcs.w	lr, r5, r3
  414dfe:	bf22      	ittt	cs
  414e00:	1ab6      	subcs	r6, r6, r2
  414e02:	4675      	movcs	r5, lr
  414e04:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
  414e08:	085b      	lsrs	r3, r3, #1
  414e0a:	ea4f 0232 	mov.w	r2, r2, rrx
  414e0e:	ebb6 0e02 	subs.w	lr, r6, r2
  414e12:	eb75 0e03 	sbcs.w	lr, r5, r3
  414e16:	bf22      	ittt	cs
  414e18:	1ab6      	subcs	r6, r6, r2
  414e1a:	4675      	movcs	r5, lr
  414e1c:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
  414e20:	ea55 0e06 	orrs.w	lr, r5, r6
  414e24:	d018      	beq.n	414e58 <__aeabi_ddiv+0x114>
  414e26:	ea4f 1505 	mov.w	r5, r5, lsl #4
  414e2a:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
  414e2e:	ea4f 1606 	mov.w	r6, r6, lsl #4
  414e32:	ea4f 03c3 	mov.w	r3, r3, lsl #3
  414e36:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
  414e3a:	ea4f 02c2 	mov.w	r2, r2, lsl #3
  414e3e:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
  414e42:	d1c0      	bne.n	414dc6 <__aeabi_ddiv+0x82>
  414e44:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  414e48:	d10b      	bne.n	414e62 <__aeabi_ddiv+0x11e>
  414e4a:	ea41 0100 	orr.w	r1, r1, r0
  414e4e:	f04f 0000 	mov.w	r0, #0
  414e52:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
  414e56:	e7b6      	b.n	414dc6 <__aeabi_ddiv+0x82>
  414e58:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  414e5c:	bf04      	itt	eq
  414e5e:	4301      	orreq	r1, r0
  414e60:	2000      	moveq	r0, #0
  414e62:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
  414e66:	bf88      	it	hi
  414e68:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
  414e6c:	f63f aeaf 	bhi.w	414bce <__aeabi_dmul+0xde>
  414e70:	ebb5 0c03 	subs.w	ip, r5, r3
  414e74:	bf04      	itt	eq
  414e76:	ebb6 0c02 	subseq.w	ip, r6, r2
  414e7a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
  414e7e:	f150 0000 	adcs.w	r0, r0, #0
  414e82:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  414e86:	bd70      	pop	{r4, r5, r6, pc}
  414e88:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
  414e8c:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
  414e90:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
  414e94:	bfc2      	ittt	gt
  414e96:	ebd4 050c 	rsbsgt	r5, r4, ip
  414e9a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
  414e9e:	bd70      	popgt	{r4, r5, r6, pc}
  414ea0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  414ea4:	f04f 0e00 	mov.w	lr, #0
  414ea8:	3c01      	subs	r4, #1
  414eaa:	e690      	b.n	414bce <__aeabi_dmul+0xde>
  414eac:	ea45 0e06 	orr.w	lr, r5, r6
  414eb0:	e68d      	b.n	414bce <__aeabi_dmul+0xde>
  414eb2:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
  414eb6:	ea94 0f0c 	teq	r4, ip
  414eba:	bf08      	it	eq
  414ebc:	ea95 0f0c 	teqeq	r5, ip
  414ec0:	f43f af3b 	beq.w	414d3a <__aeabi_dmul+0x24a>
  414ec4:	ea94 0f0c 	teq	r4, ip
  414ec8:	d10a      	bne.n	414ee0 <__aeabi_ddiv+0x19c>
  414eca:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
  414ece:	f47f af34 	bne.w	414d3a <__aeabi_dmul+0x24a>
  414ed2:	ea95 0f0c 	teq	r5, ip
  414ed6:	f47f af25 	bne.w	414d24 <__aeabi_dmul+0x234>
  414eda:	4610      	mov	r0, r2
  414edc:	4619      	mov	r1, r3
  414ede:	e72c      	b.n	414d3a <__aeabi_dmul+0x24a>
  414ee0:	ea95 0f0c 	teq	r5, ip
  414ee4:	d106      	bne.n	414ef4 <__aeabi_ddiv+0x1b0>
  414ee6:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
  414eea:	f43f aefd 	beq.w	414ce8 <__aeabi_dmul+0x1f8>
  414eee:	4610      	mov	r0, r2
  414ef0:	4619      	mov	r1, r3
  414ef2:	e722      	b.n	414d3a <__aeabi_dmul+0x24a>
  414ef4:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
  414ef8:	bf18      	it	ne
  414efa:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
  414efe:	f47f aec5 	bne.w	414c8c <__aeabi_dmul+0x19c>
  414f02:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
  414f06:	f47f af0d 	bne.w	414d24 <__aeabi_dmul+0x234>
  414f0a:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
  414f0e:	f47f aeeb 	bne.w	414ce8 <__aeabi_dmul+0x1f8>
  414f12:	e712      	b.n	414d3a <__aeabi_dmul+0x24a>

00414f14 <__gedf2>:
  414f14:	f04f 3cff 	mov.w	ip, #4294967295
  414f18:	e006      	b.n	414f28 <__cmpdf2+0x4>
  414f1a:	bf00      	nop

00414f1c <__ledf2>:
  414f1c:	f04f 0c01 	mov.w	ip, #1
  414f20:	e002      	b.n	414f28 <__cmpdf2+0x4>
  414f22:	bf00      	nop

00414f24 <__cmpdf2>:
  414f24:	f04f 0c01 	mov.w	ip, #1
  414f28:	f84d cd04 	str.w	ip, [sp, #-4]!
  414f2c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
  414f30:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
  414f34:	ea4f 0c43 	mov.w	ip, r3, lsl #1
  414f38:	bf18      	it	ne
  414f3a:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
  414f3e:	d01b      	beq.n	414f78 <__cmpdf2+0x54>
  414f40:	b001      	add	sp, #4
  414f42:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
  414f46:	bf0c      	ite	eq
  414f48:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
  414f4c:	ea91 0f03 	teqne	r1, r3
  414f50:	bf02      	ittt	eq
  414f52:	ea90 0f02 	teqeq	r0, r2
  414f56:	2000      	moveq	r0, #0
  414f58:	4770      	bxeq	lr
  414f5a:	f110 0f00 	cmn.w	r0, #0
  414f5e:	ea91 0f03 	teq	r1, r3
  414f62:	bf58      	it	pl
  414f64:	4299      	cmppl	r1, r3
  414f66:	bf08      	it	eq
  414f68:	4290      	cmpeq	r0, r2
  414f6a:	bf2c      	ite	cs
  414f6c:	17d8      	asrcs	r0, r3, #31
  414f6e:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
  414f72:	f040 0001 	orr.w	r0, r0, #1
  414f76:	4770      	bx	lr
  414f78:	ea4f 0c41 	mov.w	ip, r1, lsl #1
  414f7c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
  414f80:	d102      	bne.n	414f88 <__cmpdf2+0x64>
  414f82:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
  414f86:	d107      	bne.n	414f98 <__cmpdf2+0x74>
  414f88:	ea4f 0c43 	mov.w	ip, r3, lsl #1
  414f8c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
  414f90:	d1d6      	bne.n	414f40 <__cmpdf2+0x1c>
  414f92:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
  414f96:	d0d3      	beq.n	414f40 <__cmpdf2+0x1c>
  414f98:	f85d 0b04 	ldr.w	r0, [sp], #4
  414f9c:	4770      	bx	lr
  414f9e:	bf00      	nop

00414fa0 <__aeabi_cdrcmple>:
  414fa0:	4684      	mov	ip, r0
  414fa2:	4610      	mov	r0, r2
  414fa4:	4662      	mov	r2, ip
  414fa6:	468c      	mov	ip, r1
  414fa8:	4619      	mov	r1, r3
  414faa:	4663      	mov	r3, ip
  414fac:	e000      	b.n	414fb0 <__aeabi_cdcmpeq>
  414fae:	bf00      	nop

00414fb0 <__aeabi_cdcmpeq>:
  414fb0:	b501      	push	{r0, lr}
  414fb2:	f7ff ffb7 	bl	414f24 <__cmpdf2>
  414fb6:	2800      	cmp	r0, #0
  414fb8:	bf48      	it	mi
  414fba:	f110 0f00 	cmnmi.w	r0, #0
  414fbe:	bd01      	pop	{r0, pc}

00414fc0 <__aeabi_dcmpeq>:
  414fc0:	f84d ed08 	str.w	lr, [sp, #-8]!
  414fc4:	f7ff fff4 	bl	414fb0 <__aeabi_cdcmpeq>
  414fc8:	bf0c      	ite	eq
  414fca:	2001      	moveq	r0, #1
  414fcc:	2000      	movne	r0, #0
  414fce:	f85d fb08 	ldr.w	pc, [sp], #8
  414fd2:	bf00      	nop

00414fd4 <__aeabi_dcmplt>:
  414fd4:	f84d ed08 	str.w	lr, [sp, #-8]!
  414fd8:	f7ff ffea 	bl	414fb0 <__aeabi_cdcmpeq>
  414fdc:	bf34      	ite	cc
  414fde:	2001      	movcc	r0, #1
  414fe0:	2000      	movcs	r0, #0
  414fe2:	f85d fb08 	ldr.w	pc, [sp], #8
  414fe6:	bf00      	nop

00414fe8 <__aeabi_dcmple>:
  414fe8:	f84d ed08 	str.w	lr, [sp, #-8]!
  414fec:	f7ff ffe0 	bl	414fb0 <__aeabi_cdcmpeq>
  414ff0:	bf94      	ite	ls
  414ff2:	2001      	movls	r0, #1
  414ff4:	2000      	movhi	r0, #0
  414ff6:	f85d fb08 	ldr.w	pc, [sp], #8
  414ffa:	bf00      	nop

00414ffc <__aeabi_dcmpge>:
  414ffc:	f84d ed08 	str.w	lr, [sp, #-8]!
  415000:	f7ff ffce 	bl	414fa0 <__aeabi_cdrcmple>
  415004:	bf94      	ite	ls
  415006:	2001      	movls	r0, #1
  415008:	2000      	movhi	r0, #0
  41500a:	f85d fb08 	ldr.w	pc, [sp], #8
  41500e:	bf00      	nop

00415010 <__aeabi_dcmpgt>:
  415010:	f84d ed08 	str.w	lr, [sp, #-8]!
  415014:	f7ff ffc4 	bl	414fa0 <__aeabi_cdrcmple>
  415018:	bf34      	ite	cc
  41501a:	2001      	movcc	r0, #1
  41501c:	2000      	movcs	r0, #0
  41501e:	f85d fb08 	ldr.w	pc, [sp], #8
  415022:	bf00      	nop

00415024 <__aeabi_d2iz>:
  415024:	ea4f 0241 	mov.w	r2, r1, lsl #1
  415028:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
  41502c:	d215      	bcs.n	41505a <__aeabi_d2iz+0x36>
  41502e:	d511      	bpl.n	415054 <__aeabi_d2iz+0x30>
  415030:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
  415034:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
  415038:	d912      	bls.n	415060 <__aeabi_d2iz+0x3c>
  41503a:	ea4f 23c1 	mov.w	r3, r1, lsl #11
  41503e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
  415042:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
  415046:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
  41504a:	fa23 f002 	lsr.w	r0, r3, r2
  41504e:	bf18      	it	ne
  415050:	4240      	negne	r0, r0
  415052:	4770      	bx	lr
  415054:	f04f 0000 	mov.w	r0, #0
  415058:	4770      	bx	lr
  41505a:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
  41505e:	d105      	bne.n	41506c <__aeabi_d2iz+0x48>
  415060:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
  415064:	bf08      	it	eq
  415066:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
  41506a:	4770      	bx	lr
  41506c:	f04f 0000 	mov.w	r0, #0
  415070:	4770      	bx	lr
  415072:	bf00      	nop

00415074 <__aeabi_d2uiz>:
  415074:	004a      	lsls	r2, r1, #1
  415076:	d211      	bcs.n	41509c <__aeabi_d2uiz+0x28>
  415078:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
  41507c:	d211      	bcs.n	4150a2 <__aeabi_d2uiz+0x2e>
  41507e:	d50d      	bpl.n	41509c <__aeabi_d2uiz+0x28>
  415080:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
  415084:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
  415088:	d40e      	bmi.n	4150a8 <__aeabi_d2uiz+0x34>
  41508a:	ea4f 23c1 	mov.w	r3, r1, lsl #11
  41508e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
  415092:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
  415096:	fa23 f002 	lsr.w	r0, r3, r2
  41509a:	4770      	bx	lr
  41509c:	f04f 0000 	mov.w	r0, #0
  4150a0:	4770      	bx	lr
  4150a2:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
  4150a6:	d102      	bne.n	4150ae <__aeabi_d2uiz+0x3a>
  4150a8:	f04f 30ff 	mov.w	r0, #4294967295
  4150ac:	4770      	bx	lr
  4150ae:	f04f 0000 	mov.w	r0, #0
  4150b2:	4770      	bx	lr

004150b4 <__aeabi_d2f>:
  4150b4:	ea4f 0241 	mov.w	r2, r1, lsl #1
  4150b8:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
  4150bc:	bf24      	itt	cs
  4150be:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
  4150c2:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
  4150c6:	d90d      	bls.n	4150e4 <__aeabi_d2f+0x30>
  4150c8:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
  4150cc:	ea4f 02c0 	mov.w	r2, r0, lsl #3
  4150d0:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
  4150d4:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
  4150d8:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
  4150dc:	bf08      	it	eq
  4150de:	f020 0001 	biceq.w	r0, r0, #1
  4150e2:	4770      	bx	lr
  4150e4:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
  4150e8:	d121      	bne.n	41512e <__aeabi_d2f+0x7a>
  4150ea:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
  4150ee:	bfbc      	itt	lt
  4150f0:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
  4150f4:	4770      	bxlt	lr
  4150f6:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  4150fa:	ea4f 5252 	mov.w	r2, r2, lsr #21
  4150fe:	f1c2 0218 	rsb	r2, r2, #24
  415102:	f1c2 0c20 	rsb	ip, r2, #32
  415106:	fa10 f30c 	lsls.w	r3, r0, ip
  41510a:	fa20 f002 	lsr.w	r0, r0, r2
  41510e:	bf18      	it	ne
  415110:	f040 0001 	orrne.w	r0, r0, #1
  415114:	ea4f 23c1 	mov.w	r3, r1, lsl #11
  415118:	ea4f 23d3 	mov.w	r3, r3, lsr #11
  41511c:	fa03 fc0c 	lsl.w	ip, r3, ip
  415120:	ea40 000c 	orr.w	r0, r0, ip
  415124:	fa23 f302 	lsr.w	r3, r3, r2
  415128:	ea4f 0343 	mov.w	r3, r3, lsl #1
  41512c:	e7cc      	b.n	4150c8 <__aeabi_d2f+0x14>
  41512e:	ea7f 5362 	mvns.w	r3, r2, asr #21
  415132:	d107      	bne.n	415144 <__aeabi_d2f+0x90>
  415134:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
  415138:	bf1e      	ittt	ne
  41513a:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
  41513e:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
  415142:	4770      	bxne	lr
  415144:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
  415148:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
  41514c:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
  415150:	4770      	bx	lr
  415152:	bf00      	nop

00415154 <all_twi_definitions>:
  415154:	8000 4001 8100 4001 0013 0000 0013 0000     ...@...@........
  415164:	c000 4001 c100 4001 0014 0000 0014 0000     ...@...@........
  415174:	654c 2064 6954 656d 0072 0000 6552 6f63     Led Timer...Reco
  415184:	6472 0a0d 0000 0000 4341 0d4b 000a 0000     rd......ACK.....
  415194:	6f50 6577 0d72 000a 6547 5374 6174 6574     Power...GetState
  4151a4:	0a0d 0000 6449 656c 0a0d 0000 6552 6f63     ....Idle....Reco
  4151b4:	6472 6e69 0d67 000a 7245 6f72 0d72 000a     rding...Error...
  4151c4:	6e55 6544 0d66 000a 7541 6f74 664f 0066     UnDef...AutoOff.
  4151d4:	6553 5374 7265 6169 006c 0000 414e 4b43     SetSerial...NACK
  4151e4:	0a0d 0000 6547 5374 7265 6169 006c 0000     ....GetSerial...
  4151f4:	0a0d 4341 0d4b 000a 6e45 6261 656c 5343     ..ACK...EnableCS
  415204:	0056 0000 6553 5274 6365 726f 4e64 6d61     V...SetRecordNam
  415214:	0065 0000 6547 5274 6365 726f 4e64 6d61     e...GetRecordNam
  415224:	0065 0000 7325 0a0d 0000 0000 6544 7562     e...%s......Debu
  415234:	4567 006e 6843 6365 526b 7373 0d69 000a     gEn.CheckRssi...
  415244:	5352 4953 6c20 7665 6c65 0d3a 000a 0000     RSSI level:.....
  415254:	7372 4274 454c 0a0d 0000 0000 6950 206e     rstBLE......Pin 
  415264:	6572 6573 0d74 000a 6964 6173 6c62 5565     reset...disableU
  415274:	5241 7354 0a0d 0000 4155 5452 2073 6573     ARTs....UARTs se
  415284:	2074 7361 4820 6769 2068 6d69 6570 6164     t as High impeda
  415294:	636e 0d65 000a 0000 6573 5474 6d69 0065     nce.....setTime.
  4152a4:	6425 252d 2d64 6425 252d 2d64 6425 253a     %d-%d-%d-%d-%d:%
  4152b4:	3a64 6425 0a0d 0000 0d3f 000a 4548 4444     d:%d....?...HEDD
  4152c4:	4b4f 204f 5242 4941 204e 4150 4b43 2520     OKO BRAIN PACK %
  4152d4:	0d73 000a 3056 342e 0064 0000 5542 4c49     s...V0.4d...BUIL
  4152e4:	2044 4144 4554 203a 7325 2520 0d73 000a     D DATE: %s %s...
  4152f4:	7041 2072 3532 3220 3130 0036 3431 353a     Apr 25 2016.14:5
  415304:	3a38 3533 0000 0000 5553 5449 4e20 4d55     8:35....SUIT NUM
  415314:	4542 3a52 2520 0d73 000a 0000 3025 6432     BER: %s.....%02d
  415324:	253a 3230 3a64 3025 6432 0000 5553 5449     :%02d:%02d..SUIT
  415334:	5420 4d49 3a45 2520 2073 0a0d 0000 0000      TIME: %s ......
  415344:	6c66 7375 5568 7261 7374 0a0d 0000 0000     flushUarts......
  415354:	6567 5374 6174 7374 0a0d 0000 5551 4e49     getStats....QUIN
  415364:	4954 2043 5453 5441 2053 0a0d 0000 0000     TIC STATS ......
  415374:	2551 3a64 0a0d 0000 4309 726f 7572 7470     Q%d:.....Corrupt
  415384:	5020 6361 656b 7374 203a 6425 0a0d 0000      Packets: %d....
  415394:	4409 6f72 7070 6465 4220 7479 7365 203a     .Dropped Bytes: 
  4153a4:	2020 6425 0a0d 0000 4d49 2555 3a64 0a0d       %d....IMU%d:..
  4153b4:	0000 0000 4909 554d 5020 6572 6573 746e     .....IMU Present
  4153c4:	203a 6425 0a0d 0000 4909 554d 4320 6e6f     : %d.....IMU Con
  4153d4:	656e 7463 6465 203a 6425 0a0d 0000 0000     nected: %d......
  4153e4:	4409 6f72 7070 6465 5020 6361 656b 7374     .Dropped Packets
  4153f4:	203a 6425 0a0d 0000 4109 6576 6172 6567     : %d.....Average
  415404:	5220 2078 6e69 6574 7672 6c61 7428 6369      Rx interval(tic
  415414:	736b 3a29 2520 0d64 000a 0000 5009 6361     ks): %d......Pac
  415424:	656b 2074 7852 4320 756f 746e 203a 2020     ket Rx Count:   
  415434:	6425 0a0d 0000 0000 6f54 6174 206c 7942     %d......Total By
  415444:	6574 2073 7257 7469 6574 3a6e 2520 0d64     tes Written: %d.
  415454:	000a 0000 6f54 6174 206c 7246 6d61 7365     ....Total Frames
  415464:	5720 6972 7474 6e65 203a 6425 0d20 000a      Written: %d ...
  415474:	7551 7565 6465 4d20 7365 6173 6567 3a73     Queued Messages:
  415484:	2520 0d64 000a 0000 2d2d 202d 6174 6b73      %d.....--- task
  415494:	2320 2023 7525 0000 6148 6472 6552 6573      ## %u..HardRese
  4154a4:	0d74 000a 6564 7562 5067 6361 656b 7374     t...debugPackets
  4154b4:	0a0d 0000 6863 614d 2070 0000 6552 6563     ....chMap ..Rece
  4154c4:	7669 6465 6e20 7765 6320 6168 6e6e 6c65     ived new channel
  4154d4:	6d20 7061 7220 7165 6575 7473 0d3a 000a      map request:...
  4154e4:	6573 4c74 6465 6f43 666e 6769 0000 0000     setLedConfig....
  4154f4:	6567 5374 4364 5664 6c61 6575 0000 0000     getSdCdValue....
  415504:	6948 6867 0a0d 0000 6f4c 0d77 000a 0000     High....Low.....
  415514:	6f4c 4277 7461 6574 7972 0000 6f4c 2077     LowBattery..Low 
  415524:	6142 7474 7265 0d79 000a 0000 4d49 2055     Battery.....IMU 
  415534:	5453 5441 2053 0a0d 0000 0000 3a30 6f6c     STATS ......0:lo
  415544:	4967 646e 7865 642e 7461 0000 0000 0000     gIndex.dat......
	...
  4155d8:	3a30 6f4d 6576 656d 746e 6f4c 0067 0000     0:MovementLog...
	...
  415670:	7257 7469 2065 6166 6c69 6465 203a 6573     Write failed: se
  415680:	616d 6870 726f 2065 6f6c 6b63 6465 0a0d     maphore locked..
  415690:	0000 0000 7257 7469 2065 6166 6c69 6465     ....Write failed
  4156a0:	203a 7542 6666 7265 6620 6c75 0d6c 000a     : Buffer full...
  4156b0:	3a30 7325 0000 0000 7325 252f 0073 0000     0:%s....%s/%s...
  4156c0:	6146 6c69 6465 6f20 206e 7263 6165 6974     Failed on creati
  4156d0:	676e 6e20 7765 6d20 766f 6d65 6e65 2074     ng new movement 
  4156e0:	6f6c 2067 6964 6572 7463 726f 0d79 000a     log directory...
  4156f0:	6146 6c69 6465 6f20 206e 7263 6165 6974     Failed on creati
  415700:	676e 6e20 7765 6d20 766f 6d65 6e65 2074     ng new movement 
  415710:	6f6c 2067 6966 656c 0a0d 0000 7325 252f     log file....%s/%
  415720:	5f73 7325 3025 6435 642e 7461 0000 0000     s_%s%05d.dat....
  415730:	7325 252f 5f73 7325 3025 6435 632e 7673     %s/%s_%s%05d.csv
  415740:	0000 0000 6f6c 2067 6166 6c69 6465 7420     ....log failed t
  415750:	206f 706f 6e65 0a0d 0000 0000 6143 276e     o open......Can'
  415760:	2074 6567 2074 6573 616d 6870 726f 2065     t get semaphore 
  415770:	6f74 6f20 6570 206e 6f6c 2067 6966 656c     to open log file
  415780:	0a0d 0000 3025 6435 0a0d 0000 6552 616e     ....%05d....Rena
  415790:	656d 6f20 2066 6544 7562 2067 6f4c 2067     me of Debug Log 
  4157a0:	6966 656c 6620 6961 656c 0d64 000a 0000     file failed.....
  4157b0:	6946 656c 6420 656f 2073 6f6e 2074 7865     File does not ex
  4157c0:	7369 2c74 6320 6572 7461 6e69 2067 656e     ist, creating ne
  4157d0:	2077 6966 656c 0a0d 0000 0000 6544 7562     w file......Debu
  4157e0:	4c67 676f 6620 6c69 2065 706f 6e65 6620     gLog file open f
  4157f0:	6961 656c 0d64 000a 0a0d 0a0d 0a0d 7250     ailed.........Pr
  415800:	676f 6172 206d 7473 7261 2074 7242 6961     ogram start Brai
  415810:	206e 6150 6b63 5620 2e30 6434 0d20 000a     n Pack V0.4d ...
  415820:	6544 7562 4c67 676f 6f20 6570 0d6e 000a     DebugLog open...
  415830:	6544 7562 4c67 676f 6620 6961 656c 2064     DebugLog failed 
  415840:	6f74 6f20 6570 0d6e 000a 0000 6143 276e     to open.....Can'
  415850:	2074 6567 2074 6573 616d 6870 726f 2065     t get semaphore 
  415860:	6f74 6f20 6570 206e 6544 7562 4c67 676f     to open DebugLog
  415870:	6620 6c69 0d65 000a 7257 7469 2065 6f74      file...Write to
  415880:	6c20 676f 6620 6c69 2065 6166 6c69 6465      log file failed
  415890:	203a 6944 6b73 4520 7272 726f 0a0d 0000     : Disk Error....
  4158a0:	7257 7469 2065 6f74 6c20 676f 6620 6c69     Write to log fil
  4158b0:	2065 6166 6c69 6465 0a0d 0000 6966 656c     e failed....file
  4158c0:	7320 6e79 2063 6166 6c69 6465 0a0d 0000      sync failed....
  4158d0:	7257 7469 2065 6f74 6420 6265 6775 6c20     Write to debug l
  4158e0:	676f 6620 6c69 2065 6166 6c69 6465 203a     og file failed: 
  4158f0:	6944 6b73 4520 7272 726f 0a0d 0000 0000     Disk Error......
  415900:	7257 7469 2065 6f74 6420 6265 6775 6c20     Write to debug l
  415910:	676f 6620 6c69 2065 6166 6c69 6465 0a0d     og file failed..
  415920:	0000 0000 6564 7562 2067 7973 636e 6620     ....debug sync f
  415930:	6961 656c 2064 6977 6874 6320 646f 2065     ailed with code 
  415940:	6425 0a0d 0000 0000 6157 7469 6e69 2067     %d......Waiting 
  415950:	6f66 2072 6573 616d 6870 726f 2065 6f74     for semaphore to
  415960:	7720 6972 6574 7420 206f 4453 632d 7261      write to SD-car
  415970:	0d64 000a 656e 2077 616d 2078 7277 7469     d...new max writ
  415980:	2065 6954 656d 0a0d 0000 0000 4453 6920     e Time......SD i
  415990:	736e 7265 2074 6d74 0072 0000 6146 6c69     nsert tmr...Fail
  4159a0:	6465 7420 206f 7263 6165 6574 5320 2044     ed to create SD 
  4159b0:	6163 6472 7420 6d69 7265 0a0d 0000 0000     card timer......
  4159c0:	6143 6472 6920 736e 6174 6c6c 4620 4941     Card install FAI
  4159d0:	0a4c 000d 6c50 6165 6573 7520 706e 756c     L...Please unplu
  4159e0:	2067 6e61 2064 6572 702d 756c 2067 6874     g and re-plug th
  4159f0:	2065 6163 6472 0a2e 000d 0000 7245 6f72     e card......Erro
  415a00:	3a72 4920 766e 6c61 6469 4420 6972 6576     r: Invalid Drive
  415a10:	0a0d 0000 3a30 0000 7245 6f72 3a72 4320     ....0:..Error: C
  415a20:	6e61 6f6e 2074 6163 636c 6c75 7461 2065     annot calculate 
  415a30:	7266 6565 7320 6170 6563 0a0d 0000 0000     free space......
  415a40:	7245 6f72 3a72 4c20 776f 6420 7369 206b     Error: Low disk 
  415a50:	7073 6361 2065 6e6f 5320 2d44 6163 6472     space on SD-card
  415a60:	0a0d 0000 3a30 6573 7474 6e69 7367 642e     ....0:settings.d
  415a70:	7461 0000 6166 6c69 6465 7420 206f 6567     at..failed to ge
  415a80:	2074 6572 6461 7320 7465 6974 676e 0d73     t read settings.
  415a90:	000a 0000 6951 0000 6146 6c69 6465 7420     ....Qi..Failed t
  415aa0:	206f 7263 6165 6574 5120 2030 6e69 7469     o create Q0 init
  415ab0:	7420 7361 206b 0a0d 0000 0000 6146 6c69      task ......Fail
  415ac0:	6465 7420 206f 7263 6165 6574 5120 2031     ed to create Q1 
  415ad0:	6e69 7469 7420 7361 206b 0a0d 0000 0000     init task ......
  415ae0:	6146 6c69 6465 7420 206f 7263 6165 6574     Failed to create
  415af0:	5120 2032 6e69 7469 7420 7361 206b 0a0d      Q2 init task ..
  415b00:	0000 0000 6146 5362 6e65 6573 6920 696e     ....FabSense ini
  415b10:	6974 6c61 7a69 7461 6f69 206e 6166 6c69     tialization fail
  415b20:	6465 0a0d 0000 0000 6143 6e6e 746f 6f20     ed......Cannot o
  415b30:	6570 206e 656e 2077 6966 656c 7420 206f     pen new file to 
  415b40:	7277 7469 2065 6572 6f63 6472 0d73 000a     write records...
  415b50:	6c53 6565 2070 6f6d 6564 6520 616e 6c62     Sleep mode enabl
  415b60:	6465 0a0d 0000 0000 7845 7469 5320 656c     ed......Exit Sle
  415b70:	7065 6d20 646f 0d65 000a 0000 6954 656d     ep mode.....Time
  415b80:	4f20 7475 5420 6d69 7265 0000 6146 6c69      Out Timer..Fail
  415b90:	6465 7420 206f 7263 6165 6574 7420 6d69     ed to create tim
  415ba0:	7265 7420 7361 206b 6f63 6564 2520 0d64     er task code %d.
  415bb0:	000a 0000 6e61 6520 7272 726f 6820 7361     ....an error has
  415bc0:	6f20 6363 7275 6572 2c64 7320 6174 6574      occurred, state
  415bd0:	6d20 6361 6968 656e 7120 6575 6575 6320      machine queue c
  415be0:	6572 7461 6f69 206e 6166 6c69 6465 202e     reation failed. 
  415bf0:	0a0d 0000 7543 7272 6e65 2074 7953 7473     ....Current Syst
  415c00:	6d65 7320 6174 6574 203a 5953 5f53 5453     em state: SYS_ST
  415c10:	5441 5f45 464f 0d46 000a 0000 7543 7272     ATE_OFF.....Curr
  415c20:	6e65 2074 7953 7473 6d65 7320 6174 6574     ent System state
  415c30:	203a 5953 5f53 5453 5441 5f45 4f50 4557     : SYS_STATE_POWE
  415c40:	5f52 4f44 4e57 0a0d 0000 0000 7543 7272     R_DOWN......Curr
  415c50:	6e65 2074 7953 7473 6d65 7320 6174 6574     ent System state
  415c60:	203a 5953 5f53 5453 5441 5f45 4552 4553     : SYS_STATE_RESE
  415c70:	0d54 000a 7543 7272 6e65 2074 7953 7473     T...Current Syst
  415c80:	6d65 7320 6174 6574 203a 5953 5f53 5453     em state: SYS_ST
  415c90:	5441 5f45 4449 454c 0a0d 0000 7543 7272     ATE_IDLE....Curr
  415ca0:	6e65 2074 7953 7473 6d65 7320 6174 6574     ent System state
  415cb0:	203a 5953 5f53 5453 5441 5f45 4552 4f43     : SYS_STATE_RECO
  415cc0:	4452 4e49 0d47 000a 7543 7272 6e65 2074     RDING...Current 
  415cd0:	7953 7473 6d65 7320 6174 6574 203a 5953     System state: SY
  415ce0:	5f53 5453 5441 5f45 5245 4f52 0d52 000a     S_STATE_ERROR...
  415cf0:	7543 7272 6e65 2074 7953 7473 6d65 7320     Current System s
  415d00:	6174 6574 203a 5953 5f53 5453 5441 5f45     tate: SYS_STATE_
  415d10:	4547 5f54 4341 4543 5f4c 4144 4154 0a0d     GET_ACCEL_DATA..
  415d20:	0000 0000 6552 6563 7669 6465 5320 5359     ....Received SYS
  415d30:	455f 4556 544e 505f 574f 5245 535f 4957     _EVENT_POWER_SWI
  415d40:	4354 0d48 000a 0000 6552 6563 7669 6465     TCH.....Received
  415d50:	5320 5359 455f 4556 544e 525f 5345 5445      SYS_EVENT_RESET
  415d60:	535f 4957 4354 0d48 000a 0000 6552 6563     _SWITCH.....Rece
  415d70:	7669 6465 5320 5359 455f 4556 544e 525f     ived SYS_EVENT_R
  415d80:	4345 524f 5f44 5753 5449 4843 0a0d 0000     ECORD_SWITCH....
  415d90:	6552 6563 7669 6465 5320 5359 455f 4556     Received SYS_EVE
  415da0:	544e 4f5f 4556 5f52 5543 5252 4e45 0d54     NT_OVER_CURRENT.
  415db0:	000a 0000 6552 6563 7669 6465 5320 5359     ....Received SYS
  415dc0:	455f 4556 544e 535f 5f44 4143 4452 445f     _EVENT_SD_CARD_D
  415dd0:	5445 4345 0d54 000a 6552 6563 7669 6465     ETECT...Received
  415de0:	5320 5359 455f 4556 544e 535f 5f44 4946      SYS_EVENT_SD_FI
  415df0:	454c 455f 5252 524f 0a0d 0000 6552 6563     LE_ERROR....Rece
  415e00:	7669 6465 5320 5359 455f 4556 544e 495f     ived SYS_EVENT_I
  415e10:	554d 445f 5349 4f43 4e4e 4345 0d54 000a     MU_DISCONNECT...
  415e20:	6552 6563 7669 6465 5320 5359 455f 4556     Received SYS_EVE
  415e30:	544e 425f 454c 455f 5252 524f 0a0d 0000     NT_BLE_ERROR....
  415e40:	6552 6563 7669 6465 5320 5359 455f 4556     Received SYS_EVE
  415e50:	544e 4a5f 4341 5f4b 4544 4554 5443 0a0d     NT_JACK_DETECT..
  415e60:	0000 0000 6552 6563 7669 6465 5320 5359     ....Received SYS
  415e70:	455f 4556 544e 4c5f 574f 425f 5441 4554     _EVENT_LOW_BATTE
  415e80:	5952 0a0d 0000 0000 6552 6563 7669 6465     RY......Received
  415e90:	5320 5359 455f 4556 544e 525f 5345 5445      SYS_EVENT_RESET
  415ea0:	435f 4d4f 4c50 5445 0d45 000a 6552 6563     _COMPLETE...Rece
  415eb0:	7669 6465 5320 5359 455f 4556 544e 525f     ived SYS_EVENT_R
  415ec0:	5345 5445 465f 4941 454c 0d44 000a 0000     ESET_FAILED.....
  415ed0:	6552 6563 7669 6465 5320 5359 455f 4556     Received SYS_EVE
  415ee0:	544e 505f 574f 5245 555f 5f50 4f43 504d     NT_POWER_UP_COMP
  415ef0:	454c 4554 0a0d 0000 6552 6563 7669 6465     LETE....Received
  415f00:	5320 5359 455f 4556 544e 475f 5445 415f      SYS_EVENT_GET_A
  415f10:	4343 4c45 445f 5441 5f41 4f43 504d 454c     CCEL_DATA_COMPLE
  415f20:	4554 0a0d 0000 0000                         TE......

00415f28 <sd_trans_multipliers>:
  415f28:	0000 0000 000a 0000 000c 0000 000d 0000     ................
  415f38:	000f 0000 0014 0000 0019 0000 001e 0000     ................
  415f48:	0023 0000 0028 0000 002d 0000 0032 0000     #...(...-...2...
  415f58:	0037 0000 003c 0000 0046 0000 0050 0000     7...<...F...P...

00415f68 <sd_mmc_trans_units>:
  415f68:	000a 0000 0064 0000 03e8 0000 2710 0000     ....d........'..
	...

00415f84 <mmc_trans_multipliers>:
  415f84:	0000 0000 000a 0000 000c 0000 000d 0000     ................
  415f94:	000f 0000 0014 0000 001a 0000 001e 0000     ................
  415fa4:	0023 0000 0028 0000 002d 0000 0034 0000     #...(...-...4...
  415fb4:	0037 0000 003c 0000 0046 0000 0050 0000     7...<...F...P...

00415fc4 <lun_desc>:
  415fc4:	32b1 0040 32f1 0040 3311 0040 3329 0040     .2@..2@..3@.)3@.
  415fd4:	3349 0040 338d 0040 33f1 0040 6004 0041     I3@..3@..3@..`A.
  415fe4:	32c1 0040 3301 0040 331d 0040 3339 0040     .2@..3@..3@.93@.
  415ff4:	334d 0040 33a1 0040 3405 0040 601c 0041     M3@..3@..4@..`A.
  416004:	5322 2f44 4d4d 2043 6143 6472 5320 6f6c     "SD/MMC Card Slo
  416014:	2074 2230 0000 0000 5322 2f44 4d4d 2043     t 0"...."SD/MMC 
  416024:	6143 6472 5320 6f6c 2074 2231 0000 0000     Card Slot 1"....

00416034 <excvt.4554>:
  416034:	9a80 b690 b78e 808f d3d2 d8d4 ded7 8f8e     ................
  416044:	9290 e292 e399 ebea 9959 9d9a 9d9c 9f9e     ........Y.......
  416054:	d6b5 e9e0 a5a5 a7a6 a9a8 abaa 21ac afae     .............!..
  416064:	b1b0 b3b2 b5b4 b7b6 b9b8 bbba bdbc bfbe     ................
  416074:	c1c0 c3c2 c5c4 c7c7 c9c8 cbca cdcc cfce     ................
  416084:	d1d0 d3d2 d5d4 d7d6 d9d8 dbda dddc dfde     ................
  416094:	e1e0 e3e2 e5e5 e7e6 e9e7 ebea eded efee     ................
  4160a4:	f1f0 f3f2 f5f4 f7f6 f9f8 fbfa fdfc fffe     ................
  4160b4:	2a22 3c3a 3f3e 7f7c 0000 0000 2c2b 3d3b     "*:<>?|.....+,;=
  4160c4:	5d5b 0000                                   []..

004160c8 <LfnOfs>:
  4160c8:	0301 0705 0e09 1210 1614 1c18 001e 0000     ................

004160d8 <tbl_lower.4258>:
  4160d8:	0061 0062 0063 0064 0065 0066 0067 0068     a.b.c.d.e.f.g.h.
  4160e8:	0069 006a 006b 006c 006d 006e 006f 0070     i.j.k.l.m.n.o.p.
  4160f8:	0071 0072 0073 0074 0075 0076 0077 0078     q.r.s.t.u.v.w.x.
  416108:	0079 007a 00a1 00a2 00a3 00a5 00ac 00af     y.z.............
  416118:	00e0 00e1 00e2 00e3 00e4 00e5 00e6 00e7     ................
  416128:	00e8 00e9 00ea 00eb 00ec 00ed 00ee 00ef     ................
  416138:	00f0 00f1 00f2 00f3 00f4 00f5 00f6 00f8     ................
  416148:	00f9 00fa 00fb 00fc 00fd 00fe 00ff 0101     ................
  416158:	0103 0105 0107 0109 010b 010d 010f 0111     ................
  416168:	0113 0115 0117 0119 011b 011d 011f 0121     ..............!.
  416178:	0123 0125 0127 0129 012b 012d 012f 0131     #.%.'.).+.-./.1.
  416188:	0133 0135 0137 013a 013c 013e 0140 0142     3.5.7.:.<.>.@.B.
  416198:	0144 0146 0148 014b 014d 014f 0151 0153     D.F.H.K.M.O.Q.S.
  4161a8:	0155 0157 0159 015b 015d 015f 0161 0163     U.W.Y.[.]._.a.c.
  4161b8:	0165 0167 0169 016b 016d 016f 0171 0173     e.g.i.k.m.o.q.s.
  4161c8:	0175 0177 017a 017c 017e 0192 03b1 03b2     u.w.z.|.~.......
  4161d8:	03b3 03b4 03b5 03b6 03b7 03b8 03b9 03ba     ................
  4161e8:	03bb 03bc 03bd 03be 03bf 03c0 03c1 03c3     ................
  4161f8:	03c4 03c5 03c6 03c7 03c8 03c9 03ca 0430     ..............0.
  416208:	0431 0432 0433 0434 0435 0436 0437 0438     1.2.3.4.5.6.7.8.
  416218:	0439 043a 043b 043c 043d 043e 043f 0440     9.:.;.<.=.>.?.@.
  416228:	0441 0442 0443 0444 0445 0446 0447 0448     A.B.C.D.E.F.G.H.
  416238:	0449 044a 044b 044c 044d 044e 044f 0451     I.J.K.L.M.N.O.Q.
  416248:	0452 0453 0454 0455 0456 0457 0458 0459     R.S.T.U.V.W.X.Y.
  416258:	045a 045b 045c 045e 045f 2170 2171 2172     Z.[.\.^._.p!q!r!
  416268:	2173 2174 2175 2176 2177 2178 2179 217a     s!t!u!v!w!x!y!z!
  416278:	217b 217c 217d 217e 217f ff41 ff42 ff43     {!|!}!~!.!A.B.C.
  416288:	ff44 ff45 ff46 ff47 ff48 ff49 ff4a ff4b     D.E.F.G.H.I.J.K.
  416298:	ff4c ff4d ff4e ff4f ff50 ff51 ff52 ff53     L.M.N.O.P.Q.R.S.
  4162a8:	ff54 ff55 ff56 ff57 ff58 ff59 ff5a 0000     T.U.V.W.X.Y.Z...

004162b8 <Tbl>:
  4162b8:	00c7 00fc 00e9 00e2 00e4 00e0 00e5 00e7     ................
  4162c8:	00ea 00eb 00e8 00ef 00ee 00ec 00c4 00c5     ................
  4162d8:	00c9 00e6 00c6 00f4 00f6 00f2 00fb 00f9     ................
  4162e8:	00ff 00d6 00dc 00f8 00a3 00d8 00d7 0192     ................
  4162f8:	00e1 00ed 00f3 00fa 00f1 00d1 00aa 00ba     ................
  416308:	00bf 00ae 00ac 00bd 00bc 00a1 00ab 00bb     ................
  416318:	2591 2592 2593 2502 2524 00c1 00c2 00c0     .%.%.%.%$%......
  416328:	00a9 2563 2551 2557 255d 00a2 00a5 2510     ..c%Q%W%]%.....%
  416338:	2514 2534 252c 251c 2500 253c 00e3 00c3     .%4%,%.%.%<%....
  416348:	255a 2554 2569 2566 2560 2550 256c 00a4     Z%T%i%f%`%P%l%..
  416358:	00f0 00d0 00ca 00cb 00c8 0131 00cd 00ce     ..........1.....
  416368:	00cf 2518 250c 2588 2584 00a6 00cc 2580     ...%.%.%.%.....%
  416378:	00d3 00df 00d4 00d2 00f5 00d5 00b5 00fe     ................
  416388:	00de 00da 00db 00d9 00fd 00dd 00af 00b4     ................
  416398:	00ad 00b1 2017 00be 00b6 00a7 00f7 00b8     ..... ..........
  4163a8:	00b0 00a8 00b7 00b9 00b3 00b2 25a0 00a0     .............%..

004163b8 <tbl_upper.4259>:
  4163b8:	0041 0042 0043 0044 0045 0046 0047 0048     A.B.C.D.E.F.G.H.
  4163c8:	0049 004a 004b 004c 004d 004e 004f 0050     I.J.K.L.M.N.O.P.
  4163d8:	0051 0052 0053 0054 0055 0056 0057 0058     Q.R.S.T.U.V.W.X.
  4163e8:	0059 005a 0021 ffe0 ffe1 ffe5 ffe2 ffe3     Y.Z.!...........
  4163f8:	00c0 00c1 00c2 00c3 00c4 00c5 00c6 00c7     ................
  416408:	00c8 00c9 00ca 00cb 00cc 00cd 00ce 00cf     ................
  416418:	00d0 00d1 00d2 00d3 00d4 00d5 00d6 00d8     ................
  416428:	00d9 00da 00db 00dc 00dd 00de 0178 0100     ............x...
  416438:	0102 0104 0106 0108 010a 010c 010e 0110     ................
  416448:	0112 0114 0116 0118 011a 011c 011e 0120     .............. .
  416458:	0122 0124 0126 0128 012a 012c 012e 0130     ".$.&.(.*.,...0.
  416468:	0132 0134 0136 0139 013b 013d 013f 0141     2.4.6.9.;.=.?.A.
  416478:	0143 0145 0147 014a 014c 014e 0150 0152     C.E.G.J.L.N.P.R.
  416488:	0154 0156 0158 015a 015c 015e 0160 0162     T.V.X.Z.\.^.`.b.
  416498:	0164 0166 0168 016a 016c 016e 0170 0172     d.f.h.j.l.n.p.r.
  4164a8:	0174 0176 0179 017b 017d 0191 0391 0392     t.v.y.{.}.......
  4164b8:	0393 0394 0395 0396 0397 0398 0399 039a     ................
  4164c8:	039b 039c 039d 039e 039f 03a0 03a1 03a3     ................
  4164d8:	03a4 03a5 03a6 03a7 03a8 03a9 03aa 0410     ................
  4164e8:	0411 0412 0413 0414 0415 0416 0417 0418     ................
  4164f8:	0419 041a 041b 041c 041d 041e 041f 0420     .............. .
  416508:	0421 0422 0423 0424 0425 0426 0427 0428     !.".#.$.%.&.'.(.
  416518:	0429 042a 042b 042c 042d 042e 042f 0401     ).*.+.,.-.../...
  416528:	0402 0403 0404 0405 0406 0407 0408 0409     ................
  416538:	040a 040b 040c 040e 040f 2160 2161 2162     ..........`!a!b!
  416548:	2163 2164 2165 2166 2167 2168 2169 216a     c!d!e!f!g!h!i!j!
  416558:	216b 216c 216d 216e 216f ff21 ff22 ff23     k!l!m!n!o!!.".#.
  416568:	ff24 ff25 ff26 ff27 ff28 ff29 ff2a ff2b     $.%.&.'.(.).*.+.
  416578:	ff2c ff2d ff2e ff2f ff30 ff31 ff32 ff33     ,.-.../.0.1.2.3.
  416588:	ff34 ff35 ff36 ff37 ff38 ff39 ff3a 0000     4.5.6.7.8.9.:...
  416598:	7325 0909 6325 2509 0975 7525 2509 0d75     %s..%c.%u.%u.%u.
  4165a8:	000a 0000 4449 454c 0000 0000 6d54 2072     ....IDLE....Tmr 
  4165b8:	7653 0063 6552 7473 7261 6974 676e 7320     Svc.Restarting s
  4165c8:	7379 6574 216d 2121 000d 0000 6553 6972     ystem!!!....Seri
  4165d8:	6c61 6e20 6d75 6562 2072 6f6e 2074 6573     al number not se
  4165e8:	0d74 000a 5853 5858 5858 0000 6166 6c69     t...SXXXXX..fail
  4165f8:	6465 7420 206f 6f6c 6461 6e20 6d76 7320     ed to load nvm s
  416608:	7465 6974 676e 0073 6173 6576 2064 766e     ettings.saved nv
  416618:	206d 6573 7474 6e69 7367 0a0d 0000 0000     m settings......
  416628:	6166 6c69 6465 7420 206f 6173 6576 6e20     failed to save n
  416638:	6d76 7320 7465 6974 676e 0d73 000a 0000     vm settings.....
  416648:	704f 6e65 6e69 2067 4453 4320 7261 2064     Opening SD Card 
  416658:	6f74 7220 6165 0d64 000a 0000 4646 4646     to read.....FFFF
  416668:	4646 4646 4631 0000 6f4d 6576 656d 746e     FFFF1F..Movement
  416678:	6f4c 0067 6565 0000 7325 2c20 6425 202c     Log.ee..%s ,%d, 
  416688:	7325 2c20 0a0d 0000 6166 6c69 6465 7420     %s ,....failed t
  416698:	206f 6572 6461 7320 7465 6974 676e 0d73     o read settings.
  4166a8:	000a 0000 6425 252c 2c64 7325 0a0d 0000     ....%d,%d,%s....
  4166b8:	6166 6c69 6465 7420 206f 6170 7372 2065     failed to parse 
  4166c8:	4d49 2055 6573 7474 6e69 7367 0a0d 0000     IMU settings....
  4166d8:	6572 6563 7669 6465 6920 636e 726f 6572     received incorre
  4166e8:	7463 6920 756d 6449 0000 0000 6166 6c69     ct imuId....fail
  4166f8:	6465 7420 206f 7361 6973 6e67 4920 554d     ed to assign IMU
  416708:	0020 0000 6c43 736f 6e69 2067 6874 2065      ...Closing the 
  416718:	6966 656c 0a0d 0000 7245 6f72 3a72 4320     file....Error: C
  416728:	6e61 6f6e 2074 6c43 736f 2065 6966 656c     annot Close file
  416738:	0a0d 0000                                   ....

0041673c <CSWTCH.21>:
  41673c:	0070 0000 0050 0000 0030 0000 0010 0000     p...P...0.......
  41674c:	3025 3031 2c64 3025 7834 002c 5442 2c4e     %010d,%04x,.BTN,
  41675c:	0000 0000 6e61 6520 7272 726f 6820 7361     ....an error has
  41676c:	6f20 6363 7275 6572 2c64 6420 7461 2061      occurred, data 
  41677c:	6168 646e 656c 2072 7571 7565 2065 6166     handler queue fa
  41678c:	6c69 7275 0d65 000a 7246 6d61 2065 6954     ilure...Frame Ti
  41679c:	656d 4f20 7475 5420 6d69 7265 0000 0000     me Out Timer....
  4167ac:	6146 6c69 6465 7420 206f 7263 6165 6574     Failed to create
  4167bc:	7420 6d69 7265 7420 7361 0d6b 000a 0000      timer task.....
  4167cc:	6f43 6e6e 6365 6974 6e6f 7420 7972 6f20     Connection try o
  4167dc:	7475 0a0d 0000 0000 4146 4154 3a4c 7520     ut......FATAL: u
  4167ec:	7261 2074 6f6e 2074 6e69 7469 6169 696c     art not initiali
  4167fc:	657a 2064 6f66 2072 5346 0a0d 0000 0000     zed for FS......
  41680c:	3231 3433 4242 4242 4343 4343 4444 4444     1234BBBBCCCCDDDD
  41681c:	4545 4545 0a0d 0000 6c53 6565 2070 6954     EEEE....Sleep Ti
  41682c:	656d 0072 6146 6c69 6465 7420 206f 7263     mer.Failed to cr
  41683c:	6165 6574 7420 6d69 7265 7420 7361 206b     eate timer task 
  41684c:	6f63 6564 2520 0d64 000a 0000 7953 7473     code %d.....Syst
  41685c:	6d65 5220 7365 7465 5420 6d69 7265 0000     em Reset Timer..
  41686c:	6552 6573 2074 7562 7474 6e6f 7420 6d69     Reset button tim
  41687c:	7265 0000 6146 6c69 6465 7420 206f 7263     er..Failed to cr
  41688c:	6165 6574 7220 7365 7465 6220 7475 6f74     eate reset butto
  41689c:	206e 6974 656d 2072 6174 6b73 6320 646f     n timer task cod
  4168ac:	2065 6425 0a0d 0000 3151 0000 6146 6c69     e %d....Q1..Fail
  4168bc:	6465 7420 206f 7263 6165 6574 5120 2031     ed to create Q1 
  4168cc:	6174 6b73 6320 646f 2065 6425 0a0d 0000     task code %d....
  4168dc:	3251 0000 6146 6c69 6465 7420 206f 7263     Q2..Failed to cr
  4168ec:	6165 6574 5120 2032 6174 6b73 6320 646f     eate Q2 task cod
  4168fc:	2065 6425 0a0d 0000 3351 0000 6146 6c69     e %d....Q3..Fail
  41690c:	6465 7420 206f 7263 6165 6574 5120 2033     ed to create Q3 
  41691c:	6174 6b73 6320 646f 2065 6425 0a0d 0000     task code %d....
  41692c:	5346 0000 6146 6c69 6465 7420 206f 7263     FS..Failed to cr
  41693c:	6165 6574 6620 6261 6972 2063 6573 736e     eate fabric sens
  41694c:	2065 6174 6b73 6320 646f 2065 6425 0a0d     e task code %d..
  41695c:	0000 0000 6d63 0064 6146 6c69 6465 7420     ....cmd.Failed t
  41696c:	206f 6553 6972 6c61 6820 6e61 6c64 7265     o Serial handler
  41697c:	7420 7361 206b 6f63 6564 2520 0d64 000a      task code %d...
  41698c:	4844 0000 6146 6c69 6465 7420 206f 7263     DH..Failed to cr
  41699c:	6165 6574 6420 7461 2061 6168 646e 656c     eate data handle
  4169ac:	2072 6174 6b73 6320 646f 2065 6425 0a0d     r task code %d..
  4169bc:	0000 0000 4453 0000 6146 6c69 6465 7420     ....SD..Failed t
  4169cc:	206f 7263 6165 6574 7320 2064 6163 6472     o create sd card
  4169dc:	7420 7361 206b 6f63 6564 2520 0d64 000a      task code %d...
  4169ec:	4d53 0000 6146 6c69 6465 7420 206f 7473     SM..Failed to st
  4169fc:	7461 2065 616d 6863 6e69 2065 6174 6b73     ate machine task
  416a0c:	6320 646f 2065 6425 0a0d 0000 5750 5320      code %d....PW S
  416a1c:	2057 7270 7365 6573 0d64 000a 7953 7473     W pressed...Syst
  416a2c:	6d65 7220 7365 7465 7420 6972 6767 7265     em reset trigger
  416a3c:	6465 0a0d 0000 0000 6552 6f63 6472 7320     ed......Record s
  416a4c:	6977 6374 2068 7270 7365 6573 0d64 000a     witch pressed...
  416a5c:	7551 7565 2065 7546 6c6c 4420 6f72 7070     Queue Full Dropp
  416a6c:	6465 7020 6361 656b 0d74 000a 6552 6573     ed packet...Rese
  416a7c:	2074 7773 7469 6863 7020 6572 7373 6465     t switch pressed
  416a8c:	0a0d 0000 614a 6b63 3120 4f20 6576 2072     ....Jack 1 Over 
  416a9c:	7563 7272 6e65 0d74 000a 0000 614a 6b63     current.....Jack
  416aac:	3220 4f20 6576 2072 7563 7272 6e65 0d74      2 Over current.
  416abc:	000a 0000 614a 6b63 3120 7220 6d65 766f     ....Jack 1 remov
  416acc:	6465 0a0d 0000 0000 614a 6b63 3220 7220     ed......Jack 2 r
  416adc:	6d65 766f 6465 0a0d 0000 0000 6142 7474     emoved......Batt
  416aec:	7265 2079 6f4c 0d77 000a 0000 4453 632d     ery Low.....SD-c
  416afc:	7261 2064 6572 6f6d 6576 0d64 000a 0000     ard removed.....
  416b0c:	4453 632d 7261 2064 6e69 6573 7472 6465     SD-card inserted
  416b1c:	0a0d 0000 7551 6e69 6974 2063 6174 6b73     ....Quintic task
  416b2c:	5120 2030 7473 6361 206b 656e 2077 6968      Q0 stack new hi
  416b3c:	6867 7720 7461 7265 6d20 7261 0d6b 000a     gh water mark...
  416b4c:	7551 6e69 6974 2063 6174 6b73 5120 2031     Quintic task Q1 
  416b5c:	7473 6361 206b 656e 2077 6968 6867 7720     stack new high w
  416b6c:	7461 7265 6d20 7261 0d6b 000a 7551 6e69     ater mark...Quin
  416b7c:	6974 2063 6174 6b73 5120 2032 7473 6361     tic task Q2 stac
  416b8c:	206b 656e 2077 6968 6867 7720 7461 7265     k new high water
  416b9c:	6d20 7261 0d6b 000a 6146 7262 6369 5320      mark...Fabric S
  416bac:	6e65 6573 7420 7361 206b 7473 6361 206b     ense task stack 
  416bbc:	656e 2077 6968 6867 7720 7461 7265 6d20     new high water m
  416bcc:	7261 0d6b 000a 0000 6f43 6d6d 6e61 2d64     ark.....Command-
  416bdc:	6148 646e 656c 2072 6174 6b73 7320 6174     Handler task sta
  416bec:	6b63 6e20 7765 6820 6769 2068 6177 6574     ck new high wate
  416bfc:	2072 616d 6b72 0a0d 0000 0000 6144 6174     r mark......Data
  416c0c:	482d 6e61 6c64 7265 7420 7361 206b 7473     -Handler task st
  416c1c:	6361 206b 656e 2077 6968 6867 7720 7461     ack new high wat
  416c2c:	7265 6d20 7261 0d6b 000a 0000 4453 632d     er mark.....SD-c
  416c3c:	7261 2064 6174 6b73 7320 6174 6b63 6e20     ard task stack n
  416c4c:	7765 6820 6769 2068 6177 6574 2072 616d     ew high water ma
  416c5c:	6b72 0a0d 0000 0000 7453 7461 2d65 614d     rk......State-Ma
  416c6c:	6863 6e69 2065 6174 6b73 7320 6174 6b63     chine task stack
  416c7c:	6e20 7765 6820 6769 2068 6177 6574 2072      new high water 
  416c8c:	616d 6b72 0a0d 0000                         mark....

00416c94 <CSWTCH.10>:
  416c94:	0000 0000 0001 0000 0002 0000 0003 0000     ................
  416ca4:	0004 0000 6e51 6341 0d6b 000a 7041 5370     ....QnAck...AppS
  416cb4:	6174 7472 0a0d 0000 6944 6373 6552 7073     tart....DiscResp
  416cc4:	0000 0000 6944 6373 6e6f 656e 7463 6f69     ....Disconnectio
  416cd4:	206e 7665 6e65 2074 7266 6d6f 5120 6975     n event from Qui
  416ce4:	746e 6369 0a0d 0000 6f63 6e6e 6365 0d74     ntic....connect.
  416cf4:	000a 0000 6f43 6e6e 6552 7073 0000 0000     ....ConnResp....
  416d04:	7551 6e69 6974 2063 7243 7361 6568 2164     Quintic Crashed!
  416d14:	0000 0000 5352 4953 0000 0000 7551 7565     ....RSSI....Queu
  416d24:	2065 7546 6c6c 4420 6f72 7070 6465 7020     e Full Dropped p
  416d34:	6361 656b 0d74 000a 6944 2064 6f6e 2074     acket...Did not 
  416d44:	6572 6563 7669 2065 6966 7372 2074 4341     receive first AC
  416d54:	204b 7266 6d6f 5120 0a0d 0000 6562 6967     K from Q....begi
  416d64:	0d6e 000a 6e65 0d64 000a 0000 6863 616d     n...end.....chma
  416d74:	2070 0000 6373 6e61 0a0d 0000 6353 6e61     p ..scan....Scan
  416d84:	6552 7073 0000 0000 6146 6c69 6465 6f20     Resp....Failed o
  416d94:	206e 4d49 2055 6449 0a0d 0000 6f4e 7220     n IMU Id....No r
  416da4:	7365 6f70 736e 2065 6e6f 7320 6163 0d6e     esponse on scan.
  416db4:	000a 0000 6573 746e 6320 6e6f 656e 7463     ....sent connect
  416dc4:	0a0d 0000 6f4e 7220 7365 6f70 736e 2065     ....No response 
  416dd4:	6e6f 6320 6e6f 656e 7463 0a0d 0000 0000     on connect......
  416de4:	6573 4d74 7061 0a0d 0000 0000 7473 7261     setMap......star
  416df4:	0d74 000a 7473 706f 0a0d 0000 7372 6973     t...stop....rssi
  416e04:	0a0d 0000 6567 4174 6363 6c65 0d31 000a     ....getAccel1...
  416e14:	6567 4174 6363 6c65 0d30 000a 6c73 6565     getAccel0...slee
  416e24:	0d70 000a 6863 6365 0d6b 000a 614d 6e69     p...check...Main
  416e34:	0000 0000 0043 0000                         ....C...

00416e3c <_global_impure_ptr>:
  416e3c:	0708 2000                                   ... 

00416e40 <zeroes.6763>:
  416e40:	3030 3030 3030 3030 3030 3030 3030 3030     0000000000000000
  416e50:	4e49 0046 6e69 0066 414e 004e 616e 006e     INF.inf.NAN.nan.
  416e60:	3130 3332 3534 3736 3938 4241 4443 4645     0123456789ABCDEF
  416e70:	0000 0000 3130 3332 3534 3736 3938 6261     ....0123456789ab
  416e80:	6463 6665 0000 0000 6e28 6c75 296c 0000     cdef....(null)..
  416e90:	0030 0000                                   0...

00416e94 <blanks.6762>:
  416e94:	2020 2020 2020 2020 2020 2020 2020 2020                     

00416ea4 <basefix.6714>:
  416ea4:	000a 0001 0002 0003 0004 0005 0006 0007     ................
  416eb4:	0008 0009 000a 000b 000c 000d 000e 000f     ................
  416ec4:	0010 0000 2565 646c 0000 0000               ....e%ld....

00416ed0 <zeroes.6721>:
  416ed0:	3030 3030 3030 3030 3030 3030 3030 3030     0000000000000000

00416ee0 <blanks.6720>:
  416ee0:	2020 2020 2020 2020 2020 2020 2020 2020                     

00416ef0 <_ctype_>:
  416ef0:	2000 2020 2020 2020 2020 2828 2828 2028     .         ((((( 
  416f00:	2020 2020 2020 2020 2020 2020 2020 2020                     
  416f10:	8820 1010 1010 1010 1010 1010 1010 1010      ...............
  416f20:	0410 0404 0404 0404 0404 1004 1010 1010     ................
  416f30:	1010 4141 4141 4141 0101 0101 0101 0101     ..AAAAAA........
  416f40:	0101 0101 0101 0101 0101 0101 1010 1010     ................
  416f50:	1010 4242 4242 4242 0202 0202 0202 0202     ..BBBBBB........
  416f60:	0202 0202 0202 0202 0202 0202 1010 1010     ................
  416f70:	0020 0000 0000 0000 0000 0000 0000 0000      ...............
	...
  416ff4:	6e49 6966 696e 7974 0000 0000 614e 004e     Infinity....NaN.
  417004:	4f50 4953 0058 0000 002e 0000               POSIX.......

00417010 <__mprec_tens>:
  417010:	0000 0000 0000 3ff0 0000 0000 0000 4024     .......?......$@
  417020:	0000 0000 0000 4059 0000 0000 4000 408f     ......Y@.....@.@
  417030:	0000 0000 8800 40c3 0000 0000 6a00 40f8     .......@.....j.@
  417040:	0000 0000 8480 412e 0000 0000 12d0 4163     .......A......cA
  417050:	0000 0000 d784 4197 0000 0000 cd65 41cd     .......A....e..A
  417060:	0000 2000 a05f 4202 0000 e800 4876 4237     ... _..B....vH7B
  417070:	0000 a200 1a94 426d 0000 e540 309c 42a2     ......mB..@..0.B
  417080:	0000 1e90 bcc4 42d6 0000 2634 6bf5 430c     .......B..4&.k.C
  417090:	8000 37e0 c379 4341 a000 85d8 3457 4376     ...7y.AC....W4vC
  4170a0:	c800 674e c16d 43ab 3d00 6091 58e4 43e1     ..Ngm..C.=.`.X.C
  4170b0:	8c40 78b5 af1d 4415 ef50 d6e2 1ae4 444b     @..x...DP.....KD
  4170c0:	d592 064d f0cf 4480 4af6 c7e1 2d02 44b5     ..M....D.J...-.D
  4170d0:	9db4 79d9 7843 44ea                         ...yCx.D

004170d8 <__mprec_bigtens>:
  4170d8:	8000 37e0 c379 4341 6e17 b505 b8b5 4693     ...7y.AC.n.....F
  4170e8:	f9f5 e93f 4f03 4d38 1d32 f930 7748 5a82     ..?..O8M2.0.Hw.Z
  4170f8:	bf3c 7f73 4fdd 7515                         <.s..O.u

00417100 <p05.5269>:
  417100:	0005 0000 0019 0000 007d 0000               ........}...

0041710c <fpi.5238>:
  41710c:	0035 0000 fbce ffff 03cb 0000 0001 0000     5...............
  41711c:	0000 0000 666e 0000 6e69 7469 0079 0000     ....nf..inity...
  41712c:	6e61 0000                                   an..

00417130 <fpinan.5274>:
  417130:	0034 0000 fbce ffff 03cb 0000 0001 0000     4...............
	...

00417148 <tinytens>:
  417148:	89bc 97d8 d2b2 3c9c a733 d5a8 f623 3949     .......<3...#.I9
  417158:	a73d 44f4 0ffd 32a5 979d cf8c ba08 255b     =..D...2......[%
  417168:	6f43 64ac 0628 1168                         Co.d(.h.

00417170 <__hexdig>:
	...
  4171a0:	1110 1312 1514 1716 1918 0000 0000 0000     ................
  4171b0:	1a00 1c1b 1e1d 001f 0000 0000 0000 0000     ................
	...
  4171d0:	1a00 1c1b 1e1d 001f 0000 0000 0000 0000     ................
	...

00417270 <_init>:
  417270:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  417272:	bf00      	nop
  417274:	bcf8      	pop	{r3, r4, r5, r6, r7}
  417276:	bc08      	pop	{r3}
  417278:	469e      	mov	lr, r3
  41727a:	4770      	bx	lr

0041727c <__init_array_start>:
  41727c:	0040fd25 	.word	0x0040fd25

00417280 <__frame_dummy_init_array_entry>:
  417280:	004000f1                                ..@.

00417284 <_fini>:
  417284:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  417286:	bf00      	nop
  417288:	bcf8      	pop	{r3, r4, r5, r6, r7}
  41728a:	bc08      	pop	{r3}
  41728c:	469e      	mov	lr, r3
  41728e:	4770      	bx	lr

00417290 <__fini_array_start>:
  417290:	004000cd 	.word	0x004000cd

Disassembly of section .relocate:

20000000 <efc_perform_read_sequence>:
__no_inline
RAMFUNC
uint32_t efc_perform_read_sequence(Efc *p_efc,
		uint32_t ul_cmd_st, uint32_t ul_cmd_sp,
		uint32_t *p_ul_buf, uint32_t ul_size)
{
20000000:	b470      	push	{r4, r5, r6}
20000002:	b083      	sub	sp, #12
20000004:	9e06      	ldr	r6, [sp, #24]
	uint32_t *p_ul_data = (uint32_t *) READ_BUFF_ADDR;
#else
	return EFC_RC_NOT_SUPPORT;
#endif

	if (p_ul_buf == NULL) {
20000006:	b343      	cbz	r3, 2000005a <efc_perform_read_sequence+0x5a>
		return EFC_RC_INVALID;
	}

	p_efc->EEFC_FMR |= (0x1u << 16);
20000008:	6804      	ldr	r4, [r0, #0]

	/* Send the Start Read command */
#if (SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM)
	p_efc->EEFC_FCR = EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(0)
			| EEFC_FCR_FCMD(ul_cmd_st);
2000000a:	b2c9      	uxtb	r1, r1
2000000c:	f041 41b4 	orr.w	r1, r1, #1509949440	; 0x5a000000

	if (p_ul_buf == NULL) {
		return EFC_RC_INVALID;
	}

	p_efc->EEFC_FMR |= (0x1u << 16);
20000010:	f444 3480 	orr.w	r4, r4, #65536	; 0x10000
20000014:	6004      	str	r4, [r0, #0]

	/* Send the Start Read command */
#if (SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM)
	p_efc->EEFC_FCR = EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(0)
20000016:	6041      	str	r1, [r0, #4]
#endif
	/* Wait for the FRDY bit in the Flash Programming Status Register
	 * (EEFC_FSR) falls.
	 */
	do {
		ul_status = p_efc->EEFC_FSR;
20000018:	6881      	ldr	r1, [r0, #8]
2000001a:	9101      	str	r1, [sp, #4]
	} while ((ul_status & EEFC_FSR_FRDY) == EEFC_FSR_FRDY);
2000001c:	9901      	ldr	r1, [sp, #4]
2000001e:	f011 0101 	ands.w	r1, r1, #1
20000022:	d1f9      	bne.n	20000018 <efc_perform_read_sequence+0x18>

	/* The data is located in the first address of the Flash
	 * memory mapping.
	 */
	for (ul_cnt = 0; ul_cnt < ul_size; ul_cnt++) {
20000024:	b146      	cbz	r6, 20000038 <efc_perform_read_sequence+0x38>
20000026:	4c0f      	ldr	r4, [pc, #60]	; (20000064 <efc_perform_read_sequence+0x64>)
20000028:	eb03 0686 	add.w	r6, r3, r6, lsl #2
		p_ul_buf[ul_cnt] = p_ul_data[ul_cnt];
2000002c:	f854 5f04 	ldr.w	r5, [r4, #4]!
20000030:	f843 5b04 	str.w	r5, [r3], #4
	} while ((ul_status & EEFC_FSR_FRDY) == EEFC_FSR_FRDY);

	/* The data is located in the first address of the Flash
	 * memory mapping.
	 */
	for (ul_cnt = 0; ul_cnt < ul_size; ul_cnt++) {
20000034:	42b3      	cmp	r3, r6
20000036:	d1f9      	bne.n	2000002c <efc_perform_read_sequence+0x2c>

	/* To stop the read mode */
	p_efc->EEFC_FCR =
#if (SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM)
			EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(0) |
			EEFC_FCR_FCMD(ul_cmd_sp);
20000038:	b2d2      	uxtb	r2, r2
	}

	/* To stop the read mode */
	p_efc->EEFC_FCR =
#if (SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM)
			EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(0) |
2000003a:	f042 42b4 	orr.w	r2, r2, #1509949440	; 0x5a000000
	for (ul_cnt = 0; ul_cnt < ul_size; ul_cnt++) {
		p_ul_buf[ul_cnt] = p_ul_data[ul_cnt];
	}

	/* To stop the read mode */
	p_efc->EEFC_FCR =
2000003e:	6042      	str	r2, [r0, #4]
#endif
	/* Wait for the FRDY bit in the Flash Programming Status Register (EEFC_FSR)
	 * rises.
	 */
	do {
		ul_status = p_efc->EEFC_FSR;
20000040:	6883      	ldr	r3, [r0, #8]
20000042:	9301      	str	r3, [sp, #4]
	} while ((ul_status & EEFC_FSR_FRDY) != EEFC_FSR_FRDY);
20000044:	9b01      	ldr	r3, [sp, #4]
20000046:	07db      	lsls	r3, r3, #31
20000048:	d5fa      	bpl.n	20000040 <efc_perform_read_sequence+0x40>

	p_efc->EEFC_FMR &= ~(0x1u << 16);
2000004a:	6803      	ldr	r3, [r0, #0]
2000004c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
20000050:	6003      	str	r3, [r0, #0]

	return EFC_RC_OK;
}
20000052:	4608      	mov	r0, r1
20000054:	b003      	add	sp, #12
20000056:	bc70      	pop	{r4, r5, r6}
20000058:	4770      	bx	lr
#else
	return EFC_RC_NOT_SUPPORT;
#endif

	if (p_ul_buf == NULL) {
		return EFC_RC_INVALID;
2000005a:	2102      	movs	r1, #2
	} while ((ul_status & EEFC_FSR_FRDY) != EEFC_FSR_FRDY);

	p_efc->EEFC_FMR &= ~(0x1u << 16);

	return EFC_RC_OK;
}
2000005c:	4608      	mov	r0, r1
2000005e:	b003      	add	sp, #12
20000060:	bc70      	pop	{r4, r5, r6}
20000062:	4770      	bx	lr
20000064:	003ffffc 	.word	0x003ffffc

20000068 <efc_write_fmr>:
 */
__no_inline
RAMFUNC
void efc_write_fmr(Efc *p_efc, uint32_t ul_fmr)
{
	p_efc->EEFC_FMR = ul_fmr;
20000068:	6001      	str	r1, [r0, #0]
2000006a:	4770      	bx	lr

2000006c <efc_perform_fcr>:
 * \return The current status.
 */
__no_inline
RAMFUNC
uint32_t efc_perform_fcr(Efc *p_efc, uint32_t ul_fcr)
{
2000006c:	b082      	sub	sp, #8
	volatile uint32_t ul_status;

	p_efc->EEFC_FCR = ul_fcr;
2000006e:	6041      	str	r1, [r0, #4]
	do {
		ul_status = p_efc->EEFC_FSR;
20000070:	6883      	ldr	r3, [r0, #8]
20000072:	9301      	str	r3, [sp, #4]
	} while ((ul_status & EEFC_FSR_FRDY) != EEFC_FSR_FRDY);
20000074:	9b01      	ldr	r3, [sp, #4]
20000076:	07db      	lsls	r3, r3, #31
20000078:	d5fa      	bpl.n	20000070 <efc_perform_fcr+0x4>

	return (ul_status & EEFC_ERROR_FLAGS);
2000007a:	9801      	ldr	r0, [sp, #4]
}
2000007c:	f000 000e 	and.w	r0, r0, #14
20000080:	b002      	add	sp, #8
20000082:	4770      	bx	lr

20000084 <portable_delay_cycles>:
RAMFUNC
void portable_delay_cycles(unsigned long n)
{
	UNUSED(n);

	__asm (
20000084:	f3bf 8f5f 	dmb	sy
20000088:	3801      	subs	r0, #1
2000008a:	d1fb      	bne.n	20000084 <portable_delay_cycles>
2000008c:	4770      	bx	lr
2000008e:	bf00      	nop

20000090 <debugLogOldFileName>:
20000090:	3a30 6544 7562 4c67 676f 6f5f 646c 742e     0:DebugLog_old.t
200000a0:	7478 0000                                   xt..

200000a4 <debugLogNewFileName>:
200000a4:	3a30 6544 7562 4c67 676f 742e 7478 0000     0:DebugLog.txt..

200000b4 <firstBoot>:
200000b4:	0001 0000                                   ....

200000b8 <systemEventNameString>:
200000b8:	5d24 0041 5d48 0041 5d6c 0041 5d90 0041     $]A.H]A.l]A..]A.
200000c8:	5db4 0041 5dd8 0041 5dfc 0041 5e20 0041     .]A..]A..]A. ^A.
200000d8:	5e40 0041 5e64 0041 5e88 0041 5eac 0041     @^A.d^A..^A..^A.
200000e8:	5ed0 0041 5ef8 0041                         .^A..^A.

200000f0 <systemStateNameString>:
200000f0:	5bf4 0041 5c1c 0041 5c4c 0041 5c74 0041     .[A..\A.L\A.t\A.
20000100:	5c9c 0041 5cc8 0041 5cf0 0041               .\A..\A..\A.

2000010c <sd_mmc_cards>:
	...
20000114:	002b 0000 0000 0000 0000 0000 0000 0000     +...............
	...

20000130 <uxCriticalNesting>:
20000130:	aaaa aaaa                                   ....

20000134 <uxPreviousTask>:
20000134:	00ff 0000                                   ....

20000138 <xNextTaskUnblockTime>:
20000138:	ffff ffff                                   ....

2000013c <usart1Config>:
2000013c:	8000 4002 c200 0001 00c0 0000 0800 0000     ...@............
2000014c:	0000 0000 0003 0000                         ........

20000154 <uart0Config>:
20000154:	0600 400e c200 0001 00c0 0000 0800 0000     ...@............
	...

2000016c <usart0Config>:
2000016c:	4000 4002 c200 0001 00c0 0000 0800 0000     .@.@............
2000017c:	0000 0000 0002 0000                         ........

20000184 <ledConfiguration>:
20000184:	0d0e 000c                                   ....

20000188 <uart1Config>:
20000188:	0800 400e c200 0001 00c0 0000 0800 0000     ...@............
20000198:	0000 0000 0001 0000                         ........

200001a0 <fsConfig>:
200001a0:	0014 0000 0004 0000 0154 2000               ........T.. 

200001ac <brainSettings>:
	...
20000248:	0000 0001 0000 0000 0000 0000 0000 0000     ................
	...

20000264 <quinticConfig>:
20000264:	031c 2000 0354 2000 038c 2000 0000 0000     ... T.. ... ....
20000274:	0000 0000 0188 2000 0003 0000 0000 0000     ....... ........
20000284:	0009 0000 0000 0000 0000 0000 0000 0000     ................
20000294:	3131 3131 3030 3030 0000 0000 03c4 2000     11110000....... 
200002a4:	03fc 2000 0434 2000 0000 0000 0000 0000     ... 4.. ........
200002b4:	016c 2000 0003 0000 0000 0000 000a 0000     l.. ............
200002c4:	0000 0000 0001 0000 0000 0000 3131 3131     ............1111
200002d4:	3030 3030 0000 0000 046c 2000 04a4 2000     0000....l.. ... 
200002e4:	04dc 2000 0000 0000 0000 0000 013c 2000     ... ........<.. 
200002f4:	0003 0000 0000 0000 000b 0000 0000 0000     ................
20000304:	0002 0000 0000 0000 3131 3131 3030 3030     ........11110000
20000314:	0000 0000                                   ....

20000318 <cmdConfig>:
20000318:	0154 2000                                   T.. 

2000031c <imuConfig>:
2000031c:	0000 0000 4131 4242 4343 4444 4545 4646     ....1ABBCCDDEEFF
	...
20000354:	0001 0000 4132 4242 4343 4444 4545 4646     ....2ABBCCDDEEFF
	...
2000038c:	0002 0000 4133 4242 4343 4444 4545 4646     ....3ABBCCDDEEFF
	...
200003c4:	0003 0000 4133 4242 4343 4444 4545 4646     ....3ABBCCDDEEFF
	...
200003fc:	0004 0000 4133 4242 4343 4444 4545 4646     ....3ABBCCDDEEFF
	...
20000434:	0005 0000 4133 4242 4343 4444 4545 4646     ....3ABBCCDDEEFF
	...
2000046c:	0006 0000 4133 4242 4343 4444 4545 4646     ....3ABBCCDDEEFF
	...
200004a4:	0007 0000 4133 4242 4343 4444 4545 4646     ....3ABBCCDDEEFF
	...
200004dc:	0008 0000 4133 4242 4343 4444 4545 4646     ....3ABBCCDDEEFF
	...
20000514:	0009 0000 4133 4242 4343 4444 4545 4646     ....3ABBCCDDEEFF
	...

2000054c <gpioConfig>:
2000054c:	0000 0000 0001 0001 85ed 0040 0101 0000     ..........@.....
2000055c:	0001 0000 0001 0001 85ad 0040 0101 0000     ..........@.....
2000056c:	0014 0000 0001 0001 8569 0040 0101 0000     ........i.@.....
2000057c:	0010 0000 0001 0001 8525 0040 0101 0000     ........%.@.....
2000058c:	000f 0000 0001 0001 84e1 0040 0101 0000     ..........@.....
2000059c:	0018 0000 0001 0001 849d 0040 0100 0000     ..........@.....
200005ac:	0019 0000 0001 0001 8459 0040 0100 0000     ........Y.@.....
200005bc:	0013 0000 0100 0004 0000 0000 0000 0100     ................
200005cc:	0017 0000 0100 0004 0000 0000 0000 0100     ................
200005dc:	002a 0000 0100 0004 0000 0000 0100 0100     *...............
200005ec:	0011 0000 0100 0004 0000 0000 0100 0100     ................
200005fc:	0012 0000 0100 0004 0000 0000 0100 0100     ................
2000060c:	002d 0000 0100 0004 0000 0000 0000 0100     -...............
2000061c:	0020 0000 0100 0004 0000 0000 0000 0100      ...............
2000062c:	0021 0000 0100 0004 0000 0000 0000 0100     !...............
2000063c:	000b 0000 0001 0001 8415 0040 0101 0000     ..........@.....
2000064c:	002b 0000 0001 0001 83d1 0040 0101 0000     +.........@.....
2000065c:	000c 0000 0000 0004 0000 0000 0000 0000     ................
2000066c:	0002 0000 0000 0004 0000 0000 0000 0100     ................

2000067c <programmingGpioConfig>:
2000067c:	0023 0000 0001 0004 0000 0000 0101 0000     #...............
2000068c:	0022 0000 0001 0004 0000 0000 0101 0000     "...............
2000069c:	0006 0000 0001 0004 0000 0000 0101 0000     ................
200006ac:	0005 0000 0001 0004 0000 0000 0101 0000     ................
200006bc:	0016 0000 0001 0004 0000 0000 0101 0000     ................
200006cc:	0012 0000 0001 0004 0000 0000 0101 0000     ................

200006dc <vTaskStackSize>:
200006dc:	0fa0 0000 0fa0 0000 0fa0 0000 0fa0 0000     ................
200006ec:	0fa0 0000 0fa0 0000 0fa0 0000 0fa0 0000     ................

200006fc <cycleJcEn>:
200006fc:	0101                                             .

200006fd <g_interrupt_enabled>:
200006fd:	0001 0000                                        ...

20000700 <SystemCoreClock>:
20000700:	0900 003d 0000 0000                         ..=.....

20000708 <impure_data>:
20000708:	0000 0000 09f4 2000 0a5c 2000 0ac4 2000     ....... \.. ... 
	...
2000073c:	6e38 0041 0000 0000 0000 0000 0000 0000     8nA.............
	...
200007b0:	0001 0000 0000 0000 330e abcd 1234 e66d     .........3..4.m.
200007c0:	deec 0005 000b 0000 0000 0000 0000 0000     ................
	...

20000b30 <_impure_ptr>:
20000b30:	0708 2000                                   ... 

20000b34 <__malloc_av_>:
	...
20000b3c:	0b34 2000 0b34 2000 0b3c 2000 0b3c 2000     4.. 4.. <.. <.. 
20000b4c:	0b44 2000 0b44 2000 0b4c 2000 0b4c 2000     D.. D.. L.. L.. 
20000b5c:	0b54 2000 0b54 2000 0b5c 2000 0b5c 2000     T.. T.. \.. \.. 
20000b6c:	0b64 2000 0b64 2000 0b6c 2000 0b6c 2000     d.. d.. l.. l.. 
20000b7c:	0b74 2000 0b74 2000 0b7c 2000 0b7c 2000     t.. t.. |.. |.. 
20000b8c:	0b84 2000 0b84 2000 0b8c 2000 0b8c 2000     ... ... ... ... 
20000b9c:	0b94 2000 0b94 2000 0b9c 2000 0b9c 2000     ... ... ... ... 
20000bac:	0ba4 2000 0ba4 2000 0bac 2000 0bac 2000     ... ... ... ... 
20000bbc:	0bb4 2000 0bb4 2000 0bbc 2000 0bbc 2000     ... ... ... ... 
20000bcc:	0bc4 2000 0bc4 2000 0bcc 2000 0bcc 2000     ... ... ... ... 
20000bdc:	0bd4 2000 0bd4 2000 0bdc 2000 0bdc 2000     ... ... ... ... 
20000bec:	0be4 2000 0be4 2000 0bec 2000 0bec 2000     ... ... ... ... 
20000bfc:	0bf4 2000 0bf4 2000 0bfc 2000 0bfc 2000     ... ... ... ... 
20000c0c:	0c04 2000 0c04 2000 0c0c 2000 0c0c 2000     ... ... ... ... 
20000c1c:	0c14 2000 0c14 2000 0c1c 2000 0c1c 2000     ... ... ... ... 
20000c2c:	0c24 2000 0c24 2000 0c2c 2000 0c2c 2000     $.. $.. ,.. ,.. 
20000c3c:	0c34 2000 0c34 2000 0c3c 2000 0c3c 2000     4.. 4.. <.. <.. 
20000c4c:	0c44 2000 0c44 2000 0c4c 2000 0c4c 2000     D.. D.. L.. L.. 
20000c5c:	0c54 2000 0c54 2000 0c5c 2000 0c5c 2000     T.. T.. \.. \.. 
20000c6c:	0c64 2000 0c64 2000 0c6c 2000 0c6c 2000     d.. d.. l.. l.. 
20000c7c:	0c74 2000 0c74 2000 0c7c 2000 0c7c 2000     t.. t.. |.. |.. 
20000c8c:	0c84 2000 0c84 2000 0c8c 2000 0c8c 2000     ... ... ... ... 
20000c9c:	0c94 2000 0c94 2000 0c9c 2000 0c9c 2000     ... ... ... ... 
20000cac:	0ca4 2000 0ca4 2000 0cac 2000 0cac 2000     ... ... ... ... 
20000cbc:	0cb4 2000 0cb4 2000 0cbc 2000 0cbc 2000     ... ... ... ... 
20000ccc:	0cc4 2000 0cc4 2000 0ccc 2000 0ccc 2000     ... ... ... ... 
20000cdc:	0cd4 2000 0cd4 2000 0cdc 2000 0cdc 2000     ... ... ... ... 
20000cec:	0ce4 2000 0ce4 2000 0cec 2000 0cec 2000     ... ... ... ... 
20000cfc:	0cf4 2000 0cf4 2000 0cfc 2000 0cfc 2000     ... ... ... ... 
20000d0c:	0d04 2000 0d04 2000 0d0c 2000 0d0c 2000     ... ... ... ... 
20000d1c:	0d14 2000 0d14 2000 0d1c 2000 0d1c 2000     ... ... ... ... 
20000d2c:	0d24 2000 0d24 2000 0d2c 2000 0d2c 2000     $.. $.. ,.. ,.. 
20000d3c:	0d34 2000 0d34 2000 0d3c 2000 0d3c 2000     4.. 4.. <.. <.. 
20000d4c:	0d44 2000 0d44 2000 0d4c 2000 0d4c 2000     D.. D.. L.. L.. 
20000d5c:	0d54 2000 0d54 2000 0d5c 2000 0d5c 2000     T.. T.. \.. \.. 
20000d6c:	0d64 2000 0d64 2000 0d6c 2000 0d6c 2000     d.. d.. l.. l.. 
20000d7c:	0d74 2000 0d74 2000 0d7c 2000 0d7c 2000     t.. t.. |.. |.. 
20000d8c:	0d84 2000 0d84 2000 0d8c 2000 0d8c 2000     ... ... ... ... 
20000d9c:	0d94 2000 0d94 2000 0d9c 2000 0d9c 2000     ... ... ... ... 
20000dac:	0da4 2000 0da4 2000 0dac 2000 0dac 2000     ... ... ... ... 
20000dbc:	0db4 2000 0db4 2000 0dbc 2000 0dbc 2000     ... ... ... ... 
20000dcc:	0dc4 2000 0dc4 2000 0dcc 2000 0dcc 2000     ... ... ... ... 
20000ddc:	0dd4 2000 0dd4 2000 0ddc 2000 0ddc 2000     ... ... ... ... 
20000dec:	0de4 2000 0de4 2000 0dec 2000 0dec 2000     ... ... ... ... 
20000dfc:	0df4 2000 0df4 2000 0dfc 2000 0dfc 2000     ... ... ... ... 
20000e0c:	0e04 2000 0e04 2000 0e0c 2000 0e0c 2000     ... ... ... ... 
20000e1c:	0e14 2000 0e14 2000 0e1c 2000 0e1c 2000     ... ... ... ... 
20000e2c:	0e24 2000 0e24 2000 0e2c 2000 0e2c 2000     $.. $.. ,.. ,.. 
20000e3c:	0e34 2000 0e34 2000 0e3c 2000 0e3c 2000     4.. 4.. <.. <.. 
20000e4c:	0e44 2000 0e44 2000 0e4c 2000 0e4c 2000     D.. D.. L.. L.. 
20000e5c:	0e54 2000 0e54 2000 0e5c 2000 0e5c 2000     T.. T.. \.. \.. 
20000e6c:	0e64 2000 0e64 2000 0e6c 2000 0e6c 2000     d.. d.. l.. l.. 
20000e7c:	0e74 2000 0e74 2000 0e7c 2000 0e7c 2000     t.. t.. |.. |.. 
20000e8c:	0e84 2000 0e84 2000 0e8c 2000 0e8c 2000     ... ... ... ... 
20000e9c:	0e94 2000 0e94 2000 0e9c 2000 0e9c 2000     ... ... ... ... 
20000eac:	0ea4 2000 0ea4 2000 0eac 2000 0eac 2000     ... ... ... ... 
20000ebc:	0eb4 2000 0eb4 2000 0ebc 2000 0ebc 2000     ... ... ... ... 
20000ecc:	0ec4 2000 0ec4 2000 0ecc 2000 0ecc 2000     ... ... ... ... 
20000edc:	0ed4 2000 0ed4 2000 0edc 2000 0edc 2000     ... ... ... ... 
20000eec:	0ee4 2000 0ee4 2000 0eec 2000 0eec 2000     ... ... ... ... 
20000efc:	0ef4 2000 0ef4 2000 0efc 2000 0efc 2000     ... ... ... ... 
20000f0c:	0f04 2000 0f04 2000 0f0c 2000 0f0c 2000     ... ... ... ... 
20000f1c:	0f14 2000 0f14 2000 0f1c 2000 0f1c 2000     ... ... ... ... 
20000f2c:	0f24 2000 0f24 2000 0f2c 2000 0f2c 2000     $.. $.. ,.. ,.. 

20000f3c <__malloc_trim_threshold>:
20000f3c:	0000 0002                                   ....

20000f40 <__malloc_sbrk_base>:
20000f40:	ffff ffff                                   ....

20000f44 <__ctype_ptr__>:
20000f44:	6ef0 0041                                   .nA.

20000f48 <lconv>:
20000f48:	700c 0041 5370 0041 5370 0041 5370 0041     .pA.pSA.pSA.pSA.
20000f58:	5370 0041 5370 0041 5370 0041 5370 0041     pSA.pSA.pSA.pSA.
20000f68:	5370 0041 5370 0041 ffff ffff ffff ffff     pSA.pSA.........
20000f78:	ffff ffff ffff 0000                         ........

20000f80 <lc_ctype_charset>:
20000f80:	5341 4943 0049 0000 0000 0000 0000 0000     ASCII...........
	...

20000fa0 <__mb_cur_max>:
20000fa0:	0001 0000                                   ....

20000fa4 <__mbtowc>:
20000fa4:	177d 0041                                   }.A.

20000fa8 <__wctomb>:
20000fa8:	3e1d 0041                                   .>A.
